<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Elua-svn] r760 - in trunk: . inc romfs src src/platform/lpc17xx	src/platform/lpc17xx/drivers/inc src/platform/lpc17xx/drivers/src
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/elua-svn/2010-July/index.html" >
   <LINK REL="made" HREF="mailto:elua-svn%40lists.berlios.de?Subject=Re%3A%20%5BElua-svn%5D%20r760%20-%20in%20trunk%3A%20.%20inc%20romfs%20src%20src/platform/lpc17xx%0A%09src/platform/lpc17xx/drivers/inc%20src/platform/lpc17xx/drivers/src&In-Reply-To=%3C20100712205655.3B89B480AB7%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   
   <LINK REL="Next"  HREF="000714.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Elua-svn] r760 - in trunk: . inc romfs src src/platform/lpc17xx	src/platform/lpc17xx/drivers/inc src/platform/lpc17xx/drivers/src</H1>
    <B>jbsnyder at mail.berlios.de</B> 
    <A HREF="mailto:elua-svn%40lists.berlios.de?Subject=Re%3A%20%5BElua-svn%5D%20r760%20-%20in%20trunk%3A%20.%20inc%20romfs%20src%20src/platform/lpc17xx%0A%09src/platform/lpc17xx/drivers/inc%20src/platform/lpc17xx/drivers/src&In-Reply-To=%3C20100712205655.3B89B480AB7%40sheep.berlios.de%3E"
       TITLE="[Elua-svn] r760 - in trunk: . inc romfs src src/platform/lpc17xx	src/platform/lpc17xx/drivers/inc src/platform/lpc17xx/drivers/src">jbsnyder at mail.berlios.de
       </A><BR>
    <I>Mon Jul 12 22:56:54 CEST 2010</I>
    <P><UL>
        
        <LI>Next message: <A HREF="000714.html">[Elua-svn] r761 - trunk/doc
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#713">[ date ]</a>
              <a href="thread.html#713">[ thread ]</a>
              <a href="subject.html#713">[ subject ]</a>
              <a href="author.html#713">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: jbsnyder
Date: 2010-07-12 22:56:54 +0200 (Mon, 12 Jul 2010)
New Revision: 760

Modified:
   trunk/SConstruct
   trunk/inc/elua_adc.h
   trunk/romfs/adcpoll.lua
   trunk/romfs/adcscope.lua
   trunk/src/elua_adc.c
   trunk/src/platform/lpc17xx/LPC17xx.h
   trunk/src/platform/lpc17xx/core_cm3.c
   trunk/src/platform/lpc17xx/core_cm3.h
   trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_adc.h
   trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_can.h
   trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_clkpwr.h
   trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_dac.h
   trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_emac.h
   trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_gpdma.h
   trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_gpio.h
   trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_i2c.h
   trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_i2s.h
   trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_libcfg_default.h
   trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_mcpwm.h
   trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_nvic.h
   trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_pinsel.h
   trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_pwm.h
   trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_qei.h
   trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_rit.h
   trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_rtc.h
   trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_spi.h
   trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_ssp.h
   trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_timer.h
   trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_uart.h
   trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_wdt.h
   trunk/src/platform/lpc17xx/drivers/inc/lpc_types.h
   trunk/src/platform/lpc17xx/drivers/src/lpc17xx_adc.c
   trunk/src/platform/lpc17xx/drivers/src/lpc17xx_can.c
   trunk/src/platform/lpc17xx/drivers/src/lpc17xx_clkpwr.c
   trunk/src/platform/lpc17xx/drivers/src/lpc17xx_dac.c
   trunk/src/platform/lpc17xx/drivers/src/lpc17xx_emac.c
   trunk/src/platform/lpc17xx/drivers/src/lpc17xx_gpdma.c
   trunk/src/platform/lpc17xx/drivers/src/lpc17xx_gpio.c
   trunk/src/platform/lpc17xx/drivers/src/lpc17xx_i2c.c
   trunk/src/platform/lpc17xx/drivers/src/lpc17xx_i2s.c
   trunk/src/platform/lpc17xx/drivers/src/lpc17xx_libcfg_default.c
   trunk/src/platform/lpc17xx/drivers/src/lpc17xx_mcpwm.c
   trunk/src/platform/lpc17xx/drivers/src/lpc17xx_nvic.c
   trunk/src/platform/lpc17xx/drivers/src/lpc17xx_pinsel.c
   trunk/src/platform/lpc17xx/drivers/src/lpc17xx_pwm.c
   trunk/src/platform/lpc17xx/drivers/src/lpc17xx_qei.c
   trunk/src/platform/lpc17xx/drivers/src/lpc17xx_rit.c
   trunk/src/platform/lpc17xx/drivers/src/lpc17xx_rtc.c
   trunk/src/platform/lpc17xx/drivers/src/lpc17xx_spi.c
   trunk/src/platform/lpc17xx/drivers/src/lpc17xx_ssp.c
   trunk/src/platform/lpc17xx/drivers/src/lpc17xx_timer.c
   trunk/src/platform/lpc17xx/drivers/src/lpc17xx_uart.c
   trunk/src/platform/lpc17xx/drivers/src/lpc17xx_wdt.c
   trunk/src/platform/lpc17xx/lpc17xx_libcfg.h
   trunk/src/platform/lpc17xx/platform.c
   trunk/src/platform/lpc17xx/platform_conf.h
   trunk/src/platform/lpc17xx/system_LPC17xx.c
   trunk/src/platform/lpc17xx/system_LPC17xx.h
Log:
ADC for MBED/LPC1768.

Note: MBED P15-&gt;P20 == adc dev ids 0-&gt;5

Modified: trunk/SConstruct
===================================================================
--- trunk/SConstruct	2010-06-28 21:53:59 UTC (rev 759)
+++ trunk/SConstruct	2010-07-12 20:56:54 UTC (rev 760)
@@ -144,7 +144,7 @@
               'ET-STM32' : [ 'hello', 'hangman', 'info', 'bisect','adcscope','adcpoll', 'dualpwm', 'pwmled' ],
               'EAGLE-100' : [ 'bisect', 'hangman', 'lhttpd', 'led', 'hello', 'info' ],
               'ELUA-PUC' : [ 'bisect', 'hangman', 'led', 'hello', 'info', 'pwmled' ],
-              'MBED' : [ 'bisect', 'hangman', 'hello', 'info', 'led', 'pwmled', 'dualpwm', 'life' ],
+              'MBED' : [ 'bisect', 'hangman', 'hello', 'info', 'led', 'pwmled', 'dualpwm', 'life', 'adcscope','adcpoll' ],
 }
 
 comp = Environment( tools = [],

Modified: trunk/inc/elua_adc.h
===================================================================
--- trunk/inc/elua_adc.h	2010-06-28 21:53:59 UTC (rev 759)
+++ trunk/inc/elua_adc.h	2010-07-12 20:56:54 UTC (rev 760)
@@ -42,7 +42,7 @@
 // Channel Management
 #define ACTIVATE_CHANNEL( d, id ) ( d-&gt;ch_active |= ( ( u32 )1 &lt;&lt; ( id ) ) )
 #define INACTIVATE_CHANNEL( d, id ) ( d-&gt;ch_active &amp;= ~( ( u32 )1 &lt;&lt; ( id ) ) )
-#define INCR_SEQCTR( d ) ( d-&gt;seq_ctr++ )
+#define INCR_SEQCTR( d ) ( d-&gt;seq_ctr++; if( d-&gt;seq_ctr &gt;= d-&gt;seq_len - 1) d-&gt;seq_ctr = 0; )
 
 int adc_setup_channel( unsigned id, u8 logcount );
 void adc_update_dev_sequence( unsigned dev_id );

Modified: trunk/romfs/adcpoll.lua
===================================================================
--- trunk/romfs/adcpoll.lua	2010-06-28 21:53:59 UTC (rev 759)
+++ trunk/romfs/adcpoll.lua	2010-07-12 20:56:54 UTC (rev 760)
@@ -4,6 +4,10 @@
   timer = 2
   adcchannels = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15}
   adcsmoothing = {4, 4, 4, 4, 16, 16, 16, 16, 32, 32, 32, 32, 64, 128, 64, 128}
+elseif pd.board() == &quot;MBED&quot; then
+  timer = 1
+  adcchannels = {0,1,2,3,4,5}
+  adcsmoothing = {4, 4, 16, 16, 32, 32}
 else
   timer = 0
   adcchannels = {0,1,2,3}

Modified: trunk/romfs/adcscope.lua
===================================================================
--- trunk/romfs/adcscope.lua	2010-06-28 21:53:59 UTC (rev 759)
+++ trunk/romfs/adcscope.lua	2010-07-12 20:56:54 UTC (rev 760)
@@ -5,6 +5,10 @@
   adcchannels = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15}
   adcsmoothing = {4, 4, 4, 4, 16, 16, 16, 16, 32, 32, 32, 32, 64, 128, 64, 128}
   numiter = 50
+elseif pd.board() == &quot;MBED&quot; then
+  adcchannels = {0,1,2,3,4,5}
+  adcsmoothing = {4, 4, 16, 16, 32, 32}
+  numiter = 2
 else
   adcchannels = {0,1,2,3}
   adcsmoothing = {4, 16, 64, 128}

Modified: trunk/src/elua_adc.c
===================================================================
--- trunk/src/elua_adc.c	2010-06-28 21:53:59 UTC (rev 759)
+++ trunk/src/elua_adc.c	2010-07-12 20:56:54 UTC (rev 760)
@@ -29,7 +29,9 @@
 {
   elua_adc_dev_state *d = adc_get_dev_state( dev_id );
   elua_adc_ch_state *s;
+  unsigned previd = d-&gt;ch_state[ d-&gt;seq_ctr ]-&gt;id;
   unsigned id;
+  u8 tmp_seq_ctr = 0;
   
   if( d-&gt;ch_active != d-&gt;last_ch_active || d-&gt;force_reseq == 1 )
   {
@@ -44,6 +46,8 @@
         d-&gt;ch_state[ d-&gt;seq_ctr ] = s;
         s-&gt;value_ptr = &amp;( d-&gt;sample_buf[ d-&gt;seq_ctr ] );
         s-&gt;value_fresh = 0;
+        if( s-&gt;id == previd )
+          tmp_seq_ctr = d-&gt;seq_ctr;
         d-&gt;seq_ctr++;
   	  }
     }
@@ -59,7 +63,7 @@
     platform_adc_update_sequence();
     
     d-&gt;last_ch_active = d-&gt;ch_active;
-    d-&gt;seq_ctr = 0;
+    d-&gt;seq_ctr = tmp_seq_ctr;
     d-&gt;force_reseq = 0;
     platform_cpu_enable_interrupts();
   }

Modified: trunk/src/platform/lpc17xx/LPC17xx.h
===================================================================
--- trunk/src/platform/lpc17xx/LPC17xx.h	2010-06-28 21:53:59 UTC (rev 759)
+++ trunk/src/platform/lpc17xx/LPC17xx.h	2010-07-12 20:56:54 UTC (rev 760)
@@ -1,17 +1,19 @@
-/****************************************************************************//**
- * @file :    LPC17xx.h
- * @brief : 	 CMSIS Cortex-M3 Core Peripheral Access Layer Header File for
+/**************************************************************************//**
+ * @file     LPC17xx.h
+ * @brief    CMSIS Cortex-M3 Core Peripheral Access Layer Header File for
  *           NXP LPC17xx Device Series
- * @version : V1.1
- * @date :    14th May 2009
- *----------------------------------------------------------------------------
+ * @version  V1.07
+ * @date     19. October 2009
  *
- * Copyright (C) 2008 ARM Limited. All rights reserved.
+ * @note
+ * Copyright (C) 2009 ARM Limited. All rights reserved.
  *
- * ARM Limited (ARM) is supplying this software for use with Cortex-M3
+ * @par
+ * ARM Limited (ARM) is supplying this software for use with Cortex-M
  * processor based microcontrollers.  This file can be freely distributed
  * within development tools that are supporting such ARM based processors.
  *
+ * @par
  * THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
  * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
@@ -24,20 +26,12 @@
 #ifndef __LPC17xx_H__
 #define __LPC17xx_H__
 
-
-/** @addtogroup CMSIS_Configuration
-  * @{
-  */
-
 /*
  * ==========================================================================
  * ---------- Interrupt Number Definition -----------------------------------
  * ==========================================================================
  */
 
-/**
- * @brief Interrupt Number Type Definition
- */
 typedef enum IRQn
 {
 /******  Cortex-M3 Processor Exceptions Numbers ***************************************************/
@@ -84,6 +78,8 @@
   MCPWM_IRQn                    = 30,       /*!&lt; Motor Control PWM Interrupt                      */
   QEI_IRQn                      = 31,       /*!&lt; Quadrature Encoder Interface Interrupt           */
   PLL1_IRQn                     = 32,       /*!&lt; PLL1 Lock (USB PLL) Interrupt                    */
+  USBActivity_IRQn				= 33,		/*!&lt; USB Activity Interrupt 						  */
+  CANActivity_IRQn				= 34,		/*!&lt; CAN Activity Interrupt 						  */
 } IRQn_Type;
 
 
@@ -98,44 +94,20 @@
 #define __NVIC_PRIO_BITS          5         /*!&lt; Number of Bits used for Priority Levels          */
 #define __Vendor_SysTickConfig    0         /*!&lt; Set to 1 if different SysTick Config is used     */
 
-/**
- * @}
- */
 
-#include &quot;core_cm3.h&quot;                    /* Cortex-M3 processor and core peripherals           */
+#include &quot;core_cm3.h&quot;                       /* Cortex-M3 processor and core peripherals           */
 #include &quot;system_LPC17xx.h&quot;                 /* System Header                                      */
 
 
-
-/**
- * Initialize the system clock
- *
- * @param  none
- * @return none
- *
- * @brief  Setup the microcontroller system.
- *         Initialize the System and update the SystemFrequency variable.
- */
-extern void SystemInit (void);
-
-
-/** @addtogroup Peripheral_register_structures
-  * @{
-  */
-
 /******************************************************************************/
 /*                Device Specific Peripheral registers structures             */
 /******************************************************************************/
 
-//#ifndef __IAR_SYSTEMS_ICC__
-//#pragma anon_unions
-//#endif
+#if defined ( __CC_ARM   )
+#pragma anon_unions
+#endif
 
-
 /*------------- System Control (SC) ------------------------------------------*/
-/**
- * @brief System Control Structure Type Definition
- */
 typedef struct
 {
   __IO uint32_t FLASHCFG;               /* Flash Accelerator Module           */
@@ -170,14 +142,11 @@
   __IO uint32_t PCLKSEL1;
        uint32_t RESERVED8[4];
   __IO uint32_t USBIntSt;               /* USB Device/OTG Interrupt Register  */
-       uint32_t RESERVED9;
+  __IO uint32_t DMAREQSEL;
   __IO uint32_t CLKOUTCFG;              /* Clock Output Configuration         */
- } SC_TypeDef;
+ } LPC_SC_TypeDef;
 
 /*------------- Pin Connect Block (PINCON) -----------------------------------*/
-/**
- * @brief Pin Connect (Select) Structure Type Definition
- */
 typedef struct
 {
   __IO uint32_t PINSEL0;
@@ -208,26 +177,79 @@
   __IO uint32_t PINMODE_OD3;
   __IO uint32_t PINMODE_OD4;
   __IO uint32_t I2CPADCFG;
-} PINCON_TypeDef;
+} LPC_PINCON_TypeDef;
 
-
 /*------------- General Purpose Input/Output (GPIO) --------------------------*/
-/**
- * @brief GPIO Structure Type Definition
- */
 typedef struct
 {
-  __IO uint32_t FIODIR;
-       uint32_t RESERVED0[3];
-  __IO uint32_t FIOMASK;
-  __IO uint32_t FIOPIN;
-  __IO uint32_t FIOSET;
-  __O  uint32_t FIOCLR;
-} GPIO_TypeDef;
+  union {
+    __IO uint32_t FIODIR;
+    struct {
+      __IO uint16_t FIODIRL;
+      __IO uint16_t FIODIRH;
+    };
+    struct {
+      __IO uint8_t  FIODIR0;
+      __IO uint8_t  FIODIR1;
+      __IO uint8_t  FIODIR2;
+      __IO uint8_t  FIODIR3;
+    };
+  };
+  uint32_t RESERVED0[3];
+  union {
+    __IO uint32_t FIOMASK;
+    struct {
+      __IO uint16_t FIOMASKL;
+      __IO uint16_t FIOMASKH;
+    };
+    struct {
+      __IO uint8_t  FIOMASK0;
+      __IO uint8_t  FIOMASK1;
+      __IO uint8_t  FIOMASK2;
+      __IO uint8_t  FIOMASK3;
+    };
+  };
+  union {
+    __IO uint32_t FIOPIN;
+    struct {
+      __IO uint16_t FIOPINL;
+      __IO uint16_t FIOPINH;
+    };
+    struct {
+      __IO uint8_t  FIOPIN0;
+      __IO uint8_t  FIOPIN1;
+      __IO uint8_t  FIOPIN2;
+      __IO uint8_t  FIOPIN3;
+    };
+  };
+  union {
+    __IO uint32_t FIOSET;
+    struct {
+      __IO uint16_t FIOSETL;
+      __IO uint16_t FIOSETH;
+    };
+    struct {
+      __IO uint8_t  FIOSET0;
+      __IO uint8_t  FIOSET1;
+      __IO uint8_t  FIOSET2;
+      __IO uint8_t  FIOSET3;
+    };
+  };
+  union {
+    __O  uint32_t FIOCLR;
+    struct {
+      __O  uint16_t FIOCLRL;
+      __O  uint16_t FIOCLRH;
+    };
+    struct {
+      __O  uint8_t  FIOCLR0;
+      __O  uint8_t  FIOCLR1;
+      __O  uint8_t  FIOCLR2;
+      __O  uint8_t  FIOCLR3;
+    };
+  };
+} LPC_GPIO_TypeDef;
 
-/**
- * @brief GPIO Interrupt Structure Type Definition
- */
 typedef struct
 {
   __I  uint32_t IntStatus;
@@ -242,12 +264,9 @@
   __O  uint32_t IO2IntClr;
   __IO uint32_t IO2IntEnR;
   __IO uint32_t IO2IntEnF;
-} GPIOINT_TypeDef;
+} LPC_GPIOINT_TypeDef;
 
 /*------------- Timer (TIM) --------------------------------------------------*/
-/**
- * @brief Timer Structure Type Definition
- */
 typedef struct
 {
   __IO uint32_t IR;
@@ -265,14 +284,11 @@
   __I  uint32_t CR1;
        uint32_t RESERVED0[2];
   __IO uint32_t EMR;
-       uint32_t RESERVED1[24];
+       uint32_t RESERVED1[12];
   __IO uint32_t CTCR;
-} TIM_TypeDef;
+} LPC_TIM_TypeDef;
 
 /*------------- Pulse-Width Modulation (PWM) ---------------------------------*/
-/**
- * @brief Pulse Width ModulationStructure Type Definition
- */
 typedef struct
 {
   __IO uint32_t IR;
@@ -290,7 +306,7 @@
   __I  uint32_t CR1;
   __I  uint32_t CR2;
   __I  uint32_t CR3;
-	   uint32_t RESERVED0;
+       uint32_t RESERVED0;
   __IO uint32_t MR4;
   __IO uint32_t MR5;
   __IO uint32_t MR6;
@@ -298,95 +314,115 @@
   __IO uint32_t LER;
        uint32_t RESERVED1[7];
   __IO uint32_t CTCR;
-} PWM_TypeDef;
+} LPC_PWM_TypeDef;
 
 /*------------- Universal Asynchronous Receiver Transmitter (UART) -----------*/
-/**
- * @brief Universal Asynchronous Receiver Transmitter 0/2/3 Structure Type Definition
- */
 typedef struct
 {
-	union {
-		__I uint8_t RBR;
-		__O uint8_t THR;
-		__IO uint8_t DLL;
-		uint32_t RESERVED0;
-	};
+  union {
+  __I  uint8_t  RBR;
+  __O  uint8_t  THR;
+  __IO uint8_t  DLL;
+       uint32_t RESERVED0;
+  };
+  union {
+  __IO uint8_t  DLM;
+  __IO uint32_t IER;
+  };
+  union {
+  __I  uint32_t IIR;
+  __O  uint8_t  FCR;
+  };
+  __IO uint8_t  LCR;
+       uint8_t  RESERVED1[7];
+  __I  uint8_t  LSR;
+       uint8_t  RESERVED2[7];
+  __IO uint8_t  SCR;
+       uint8_t  RESERVED3[3];
+  __IO uint32_t ACR;
+  __IO uint8_t  ICR;
+       uint8_t  RESERVED4[3];
+  __IO uint8_t  FDR;
+       uint8_t  RESERVED5[7];
+  __IO uint8_t  TER;
+       uint8_t  RESERVED6[39];
+  __I  uint8_t  FIFOLVL;
+} LPC_UART_TypeDef;
 
-	union {
-		__IO uint8_t DLM;
-		__IO uint32_t IER;
-	};
+typedef struct
+{
+  union {
+  __I  uint8_t  RBR;
+  __O  uint8_t  THR;
+  __IO uint8_t  DLL;
+       uint32_t RESERVED0;
+  };
+  union {
+  __IO uint8_t  DLM;
+  __IO uint32_t IER;
+  };
+  union {
+  __I  uint32_t IIR;
+  __O  uint8_t  FCR;
+  };
+  __IO uint8_t  LCR;
+       uint8_t  RESERVED1[7];
+  __I  uint8_t  LSR;
+       uint8_t  RESERVED2[7];
+  __IO uint8_t  SCR;
+       uint8_t  RESERVED3[3];
+  __IO uint32_t ACR;
+  __IO uint8_t  ICR;
+       uint8_t  RESERVED4[3];
+  __IO uint8_t  FDR;
+       uint8_t  RESERVED5[7];
+  __IO uint8_t  TER;
+       uint8_t  RESERVED6[39];
+  __I  uint8_t  FIFOLVL;
+} LPC_UART0_TypeDef;
 
-	union {
-		__I uint32_t IIR;
-		__O uint8_t FCR;
-	};
-
-	__IO uint8_t LCR;
-	uint8_t RESERVED1[7];
-	__I uint8_t LSR;
-	uint8_t RESERVED2[7];
-	__IO uint8_t SCR;
-	uint8_t RESERVED3[3];
-	__IO uint32_t ACR;
-	__IO uint32_t ICR;
-	__IO uint32_t FDR;
-	uint32_t RESERVED4;
-	__IO uint8_t TER;
-	uint8_t RESERVED5[39];
-	__I uint32_t FIFOLVL;
-} UART_TypeDef;
-
-/**
- * @brief Universal Asynchronous Receiver Transmitter 1 Structure Type Definition
- */
 typedef struct
 {
-	union {
-		__I  uint8_t  RBR;
-		__O  uint8_t  THR;
-		__IO uint8_t  DLL;
-		   uint32_t RESERVED0;
-	};
-	union {
-		__IO uint8_t  DLM;
-		__IO uint32_t IER;
-	};
-	union {
-		__I  uint32_t IIR;
-		__O  uint8_t  FCR;
-	};
-	__IO uint8_t  LCR;
-	   uint8_t  RESERVED1[3];
-	__IO uint8_t  MCR;
-	   uint8_t  RESERVED2[3];
-	__IO uint8_t  LSR;
-	   uint8_t  RESERVED3[3];
-	__IO uint8_t  MSR;
-	   uint8_t  RESERVED4[3];
-	__IO uint8_t  SCR;
-	   uint8_t  RESERVED5[3];
-	__IO uint32_t ACR;
-	   uint32_t RESERVED6;
-	__IO uint32_t FDR;
-	   uint32_t RESERVED7;
-	__IO uint8_t  TER;
-	   uint8_t  RESERVED8[27];
-	__IO uint8_t  RS485CTRL;
-	   uint8_t  RESERVED9[3];
-	__IO uint8_t  ADRMATCH;
-	   uint8_t  RESERVED10[3];
-	__IO uint8_t  RS485DLY;
-		uint8_t RESERVED11[3];
-	__IO uint32_t FIFOLVL;
-} UART1_TypeDef;
+  union {
+  __I  uint8_t  RBR;
+  __O  uint8_t  THR;
+  __IO uint8_t  DLL;
+       uint32_t RESERVED0;
+  };
+  union {
+  __IO uint8_t  DLM;
+  __IO uint32_t IER;
+  };
+  union {
+  __I  uint32_t IIR;
+  __O  uint8_t  FCR;
+  };
+  __IO uint8_t  LCR;
+       uint8_t  RESERVED1[3];
+  __IO uint8_t  MCR;
+       uint8_t  RESERVED2[3];
+  __I  uint8_t  LSR;
+       uint8_t  RESERVED3[3];
+  __I  uint8_t  MSR;
+       uint8_t  RESERVED4[3];
+  __IO uint8_t  SCR;
+       uint8_t  RESERVED5[3];
+  __IO uint32_t ACR;
+       uint32_t RESERVED6;
+  __IO uint32_t FDR;
+       uint32_t RESERVED7;
+  __IO uint8_t  TER;
+       uint8_t  RESERVED8[27];
+  __IO uint8_t  RS485CTRL;
+       uint8_t  RESERVED9[3];
+  __IO uint8_t  ADRMATCH;
+       uint8_t  RESERVED10[3];
+  __IO uint8_t  RS485DLY;
+       uint8_t  RESERVED11[3];
+  __I  uint8_t  FIFOLVL;
+} LPC_UART1_TypeDef;
 
-
 /*------------- Serial Peripheral Interface (SPI) ----------------------------*/
-/**
- * @brief Serial Peripheral InterfaceStructure Type Definition
- */
 typedef struct
 {
   __IO uint32_t SPCR;
@@ -395,12 +431,9 @@
   __IO uint32_t SPCCR;
        uint32_t RESERVED0[3];
   __IO uint32_t SPINT;
-} SPI_TypeDef;
+} LPC_SPI_TypeDef;
 
 /*------------- Synchronous Serial Communication (SSP) -----------------------*/
-/**
- * @brief Synchronous Serial Communication Structure Type Definition
- */
 typedef struct
 {
   __IO uint32_t CR0;
@@ -413,12 +446,9 @@
   __IO uint32_t MIS;
   __IO uint32_t ICR;
   __IO uint32_t DMACR;
-} SSP_TypeDef;
+} LPC_SSP_TypeDef;
 
 /*------------- Inter-Integrated Circuit (I2C) -------------------------------*/
-/**
- * @brief Inter-Intergrated Circuit Structure Type Definition
- */
 typedef struct
 {
   __IO uint32_t I2CONSET;
@@ -437,12 +467,9 @@
   __IO uint32_t I2MASK1;
   __IO uint32_t I2MASK2;
   __IO uint32_t I2MASK3;
-} I2C_TypeDef;
+} LPC_I2C_TypeDef;
 
 /*------------- Inter IC Sound (I2S) -----------------------------------------*/
-/**
- * @brief Inter IC Sound Structure Type Definition
- */
 typedef struct
 {
   __IO uint32_t I2SDAO;
@@ -459,12 +486,9 @@
   __IO uint32_t I2SRXBITRATE;
   __IO uint32_t I2STXMODE;
   __IO uint32_t I2SRXMODE;
-} I2S_TypeDef;
+} LPC_I2S_TypeDef;
 
 /*------------- Repetitive Interrupt Timer (RIT) -----------------------------*/
-/**
- * @brief Repetitive Interrupt Timer Structure Type Definition
- */
 typedef struct
 {
   __IO uint32_t RICOMPVAL;
@@ -472,12 +496,9 @@
   __IO uint8_t  RICTRL;
        uint8_t  RESERVED0[3];
   __IO uint32_t RICOUNTER;
-} RIT_TypeDef;
+} LPC_RIT_TypeDef;
 
 /*------------- Real-Time Clock (RTC) ----------------------------------------*/
-/**
- * @brief Real Time Clock Structure Type Definition
- */
 typedef struct
 {
   __IO uint8_t  ILR;
@@ -513,9 +534,9 @@
   __IO uint32_t GPREG2;
   __IO uint32_t GPREG3;
   __IO uint32_t GPREG4;
-  __IO uint8_t  WAKEUPDIS;
+  __IO uint8_t  RTC_AUXEN;
        uint8_t  RESERVED12[3];
-  __IO uint8_t  PWRCTRL;
+  __IO uint8_t  RTC_AUX;
        uint8_t  RESERVED13[3];
   __IO uint8_t  ALSEC;
        uint8_t  RESERVED14[3];
@@ -533,13 +554,9 @@
        uint8_t  RESERVED20[3];
   __IO uint16_t ALYEAR;
        uint16_t RESERVED21;
-} RTC_TypeDef;
+} LPC_RTC_TypeDef;
 
-
 /*------------- Watchdog Timer (WDT) -----------------------------------------*/
-/**
- * @brief Watchdog Timer Structure Type Definition
- */
 typedef struct
 {
   __IO uint8_t  WDMOD;
@@ -549,19 +566,14 @@
        uint8_t  RESERVED1[3];
   __I  uint32_t WDTV;
   __IO uint32_t WDCLKSEL;
-} WDT_TypeDef;
+} LPC_WDT_TypeDef;
 
 /*------------- Analog-to-Digital Converter (ADC) ----------------------------*/
-/**
- * @brief Analog to Digital Structure Type Definition
- */
 typedef struct
 {
   __IO uint32_t ADCR;
   __IO uint32_t ADGDR;
-#ifndef __LPC17XX_REV00
-  uint32_t RESERVED0;
-#endif
+       uint32_t RESERVED0;
   __IO uint32_t ADINTEN;
   __I  uint32_t ADDR0;
   __I  uint32_t ADDR1;
@@ -573,24 +585,17 @@
   __I  uint32_t ADDR7;
   __I  uint32_t ADSTAT;
   __IO uint32_t ADTRM;
-} ADC_TypeDef;
+} LPC_ADC_TypeDef;
 
-
 /*------------- Digital-to-Analog Converter (DAC) ----------------------------*/
-/**
- * @brief Digital to Analog Structure Type Definition
- */
 typedef struct
 {
   __IO uint32_t DACR;
   __IO uint32_t DACCTRL;
   __IO uint16_t DACCNTVAL;
-} DAC_TypeDef;
+} LPC_DAC_TypeDef;
 
 /*------------- Motor Control Pulse-Width Modulation (MCPWM) -----------------*/
-/**
- * @brief Motor Control Pulse Width Modulation Structure Type Definition
- */
 typedef struct
 {
   __I  uint32_t MCCON;
@@ -623,12 +628,9 @@
   __O  uint32_t MCINTFLAG_SET;
   __O  uint32_t MCINTFLAG_CLR;
   __O  uint32_t MCCAP_CLR;
-} MCPWM_TypeDef;
+} LPC_MCPWM_TypeDef;
 
 /*------------- Quadrature Encoder Interface (QEI) ---------------------------*/
-/**
- * @brief Quadrature Encoder Interface Structure Type Definition
- */
 typedef struct
 {
   __O  uint32_t QEICON;
@@ -654,20 +656,14 @@
   __I  uint32_t QEIIE;
   __O  uint32_t QEICLR;
   __O  uint32_t QEISET;
-} QEI_TypeDef;
+} LPC_QEI_TypeDef;
 
 /*------------- Controller Area Network (CAN) --------------------------------*/
-/**
- * @brief Control Area Network Structure Type Definition
- */
 typedef struct
 {
   __IO uint32_t mask[512];              /* ID Masks                           */
-} CANAF_RAM_TypeDef;
+} LPC_CANAF_RAM_TypeDef;
 
-/**
- * @brief Acceptance Filter Structure Type Definition
- */
 typedef struct                          /* Acceptance Filter Registers        */
 {
   __IO uint32_t AFMR;
@@ -679,23 +675,17 @@
   __I  uint32_t LUTerrAd;
   __I  uint32_t LUTerr;
   __IO uint32_t FCANIE;
-  __I  uint32_t FCANIC0;
-  __I  uint32_t FCANIC1;
-} CANAF_TypeDef;
+  __IO uint32_t FCANIC0;
+  __IO uint32_t FCANIC1;
+} LPC_CANAF_TypeDef;
 
-/**
- * @brief CAN Central Structure Type Definition
- */
 typedef struct                          /* Central Registers                  */
 {
   __I  uint32_t CANTxSR;
   __I  uint32_t CANRxSR;
   __I  uint32_t CANMSR;
-} CANCR_TypeDef;
+} LPC_CANCR_TypeDef;
 
-/**
- * @brief CAN Controller Structure Type Definition
- */
 typedef struct                          /* Controller Registers               */
 {
   __IO uint32_t MOD;
@@ -722,12 +712,9 @@
   __IO uint32_t TID3;
   __IO uint32_t TDA3;
   __IO uint32_t TDB3;
-} CAN_TypeDef;
+} LPC_CAN_TypeDef;
 
 /*------------- General Purpose Direct Memory Access (GPDMA) -----------------*/
-/**
- * @brief General Purpose Direct Memory Access Structure Type Definition
- */
 typedef struct                          /* Common Registers                   */
 {
   __I  uint32_t DMACIntStat;
@@ -744,11 +731,8 @@
   __IO uint32_t DMACSoftLSReq;
   __IO uint32_t DMACConfig;
   __IO uint32_t DMACSync;
-} GPDMA_TypeDef;
+} LPC_GPDMA_TypeDef;
 
-/**
- * @brief GPDMA Channel Structure Type Definition
- */
 typedef struct                          /* Channel Registers                  */
 {
   __IO uint32_t DMACCSrcAddr;
@@ -756,13 +740,9 @@
   __IO uint32_t DMACCLLI;
   __IO uint32_t DMACCControl;
   __IO uint32_t DMACCConfig;
-} GPDMACH_TypeDef;
+} LPC_GPDMACH_TypeDef;
 
-
 /*------------- Universal Serial Bus (USB) -----------------------------------*/
-/**
- * @brief Universal Serial Bus Structure Type Definition
- */
 typedef struct
 {
   __I  uint32_t HcRevision;             /* USB Host Registers                 */
@@ -862,12 +842,9 @@
   __I  uint32_t USBClkSt;
   __I  uint32_t OTGClkSt;
   };
-} USB_TypeDef;
+} LPC_USB_TypeDef;
 
 /*------------- Ethernet Media Access Controller (EMAC) ----------------------*/
-/**
- * @brief Ethernet Media Access Controller Structure Type Definition
- */
 typedef struct
 {
   __IO uint32_t MAC1;                   /* MAC Registers                      */
@@ -924,164 +901,138 @@
   __IO uint32_t PowerDown;
        uint32_t RESERVED8;
   __IO uint32_t Module_ID;
-} EMAC_TypeDef;
+} LPC_EMAC_TypeDef;
 
-//#ifndef __IAR_SYSTEMS_ICC__
-//#pragma no_anon_unions
-//#endif
+#if defined ( __CC_ARM   )
+#pragma no_anon_unions
+#endif
 
-/**
- * @}
- */
 
-
-/** @addtogroup Peripheral_memory_map
-  * @{
-  */
-
 /******************************************************************************/
 /*                         Peripheral memory map                              */
 /******************************************************************************/
 /* Base addresses                                                             */
-#define FLASH_BASE            (0x00000000UL)
-#define RAM_BASE              (0x10000000UL)
+#define LPC_FLASH_BASE        (0x00000000UL)
+#define LPC_RAM_BASE          (0x10000000UL)
 #ifdef __LPC17XX_REV00
-#define AHBRAM0_BASE          (0x20000000UL)
-#define AHBRAM1_BASE          (0x20004000UL)
+#define LPC_AHBRAM0_BASE      (0x20000000UL)
+#define LPC_AHBRAM1_BASE      (0x20004000UL)
 #else
-#define AHBRAM0_BASE          (0x2007C000UL)
-#define AHBRAM1_BASE          (0x20080000UL)
-#define GPIO_BASE             (0x2009C000UL)
+#define LPC_AHBRAM0_BASE      (0x2007C000UL)
+#define LPC_AHBRAM1_BASE      (0x20080000UL)
 #endif
-#define APB0_BASE             (0x40000000UL)
-#define APB1_BASE             (0x40080000UL)
-#define AHB_BASE              (0x50000000UL)
-#define CM3_BASE              (0xE0000000UL)
+#define LPC_GPIO_BASE         (0x2009C000UL)
+#define LPC_APB0_BASE         (0x40000000UL)
+#define LPC_APB1_BASE         (0x40080000UL)
+#define LPC_AHB_BASE          (0x50000000UL)
+#define LPC_CM3_BASE          (0xE0000000UL)
 
-#ifdef __LPC17XX_REV00
-#define GPIO_BASE			  (AHB_BASE  + 0x14000)
-#endif
-
 /* APB0 peripherals                                                           */
-#define WDT_BASE              (APB0_BASE + 0x00000)
-#define TIM0_BASE             (APB0_BASE + 0x04000)
-#define TIM1_BASE             (APB0_BASE + 0x08000)
-#define UART0_BASE            (APB0_BASE + 0x0C000)
-#define UART1_BASE            (APB0_BASE + 0x10000)
-#define PWM1_BASE             (APB0_BASE + 0x18000)
-#define I2C0_BASE             (APB0_BASE + 0x1C000)
-#define SPI_BASE              (APB0_BASE + 0x20000)
-#define RTC_BASE              (APB0_BASE + 0x24000)
-#define GPIOINT_BASE          (APB0_BASE + 0x28080)
-#define PINCON_BASE           (APB0_BASE + 0x2C000)
-#define SSP1_BASE             (APB0_BASE + 0x30000)
-#define ADC_BASE              (APB0_BASE + 0x34000)
-#define CANAF_RAM_BASE        (APB0_BASE + 0x38000)
-#define CANAF_BASE            (APB0_BASE + 0x3C000)
-#define CANCR_BASE            (APB0_BASE + 0x40000)
-#define CAN1_BASE             (APB0_BASE + 0x44000)
-#define CAN2_BASE             (APB0_BASE + 0x48000)
-#define I2C1_BASE             (APB0_BASE + 0x5C000)
+#define LPC_WDT_BASE          (LPC_APB0_BASE + 0x00000)
+#define LPC_TIM0_BASE         (LPC_APB0_BASE + 0x04000)
+#define LPC_TIM1_BASE         (LPC_APB0_BASE + 0x08000)
+#define LPC_UART0_BASE        (LPC_APB0_BASE + 0x0C000)
+#define LPC_UART1_BASE        (LPC_APB0_BASE + 0x10000)
+#define LPC_PWM1_BASE         (LPC_APB0_BASE + 0x18000)
+#define LPC_I2C0_BASE         (LPC_APB0_BASE + 0x1C000)
+#define LPC_SPI_BASE          (LPC_APB0_BASE + 0x20000)
+#define LPC_RTC_BASE          (LPC_APB0_BASE + 0x24000)
+#define LPC_GPIOINT_BASE      (LPC_APB0_BASE + 0x28080)
+#define LPC_PINCON_BASE       (LPC_APB0_BASE + 0x2C000)
+#define LPC_SSP1_BASE         (LPC_APB0_BASE + 0x30000)
+#define LPC_ADC_BASE          (LPC_APB0_BASE + 0x34000)
+#define LPC_CANAF_RAM_BASE    (LPC_APB0_BASE + 0x38000)
+#define LPC_CANAF_BASE        (LPC_APB0_BASE + 0x3C000)
+#define LPC_CANCR_BASE        (LPC_APB0_BASE + 0x40000)
+#define LPC_CAN1_BASE         (LPC_APB0_BASE + 0x44000)
+#define LPC_CAN2_BASE         (LPC_APB0_BASE + 0x48000)
+#define LPC_I2C1_BASE         (LPC_APB0_BASE + 0x5C000)
 
 /* APB1 peripherals                                                           */
-#define SSP0_BASE             (APB1_BASE + 0x08000)
-#define DAC_BASE              (APB1_BASE + 0x0C000)
-#define TIM2_BASE             (APB1_BASE + 0x10000)
-#define TIM3_BASE             (APB1_BASE + 0x14000)
-#define UART2_BASE            (APB1_BASE + 0x18000)
-#define UART3_BASE            (APB1_BASE + 0x1C000)
-#define I2C2_BASE             (APB1_BASE + 0x20000)
-#define I2S_BASE              (APB1_BASE + 0x28000)
-#define RIT_BASE              (APB1_BASE + 0x30000)
-#define MCPWM_BASE            (APB1_BASE + 0x38000)
-#define QEI_BASE              (APB1_BASE + 0x3C000)
-#define SC_BASE               (APB1_BASE + 0x7C000)
+#define LPC_SSP0_BASE         (LPC_APB1_BASE + 0x08000)
+#define LPC_DAC_BASE          (LPC_APB1_BASE + 0x0C000)
+#define LPC_TIM2_BASE         (LPC_APB1_BASE + 0x10000)
+#define LPC_TIM3_BASE         (LPC_APB1_BASE + 0x14000)
+#define LPC_UART2_BASE        (LPC_APB1_BASE + 0x18000)
+#define LPC_UART3_BASE        (LPC_APB1_BASE + 0x1C000)
+#define LPC_I2C2_BASE         (LPC_APB1_BASE + 0x20000)
+#define LPC_I2S_BASE          (LPC_APB1_BASE + 0x28000)
+#define LPC_RIT_BASE          (LPC_APB1_BASE + 0x30000)
+#define LPC_MCPWM_BASE        (LPC_APB1_BASE + 0x38000)
+#define LPC_QEI_BASE          (LPC_APB1_BASE + 0x3C000)
+#define LPC_SC_BASE           (LPC_APB1_BASE + 0x7C000)
 
 /* AHB peripherals                                                            */
-#define EMAC_BASE             (AHB_BASE  + 0x00000)
-#define GPDMA_BASE            (AHB_BASE  + 0x04000)
-#define GPDMACH0_BASE         (AHB_BASE  + 0x04100)
-#define GPDMACH1_BASE         (AHB_BASE  + 0x04120)
-#define GPDMACH2_BASE         (AHB_BASE  + 0x04140)
-#define GPDMACH3_BASE         (AHB_BASE  + 0x04160)
-#define GPDMACH4_BASE         (AHB_BASE  + 0x04180)
-#define GPDMACH5_BASE         (AHB_BASE  + 0x041A0)
-#define GPDMACH6_BASE         (AHB_BASE  + 0x041C0)
-#define GPDMACH7_BASE         (AHB_BASE  + 0x041E0)
-#define USB_BASE              (AHB_BASE  + 0x0C000)
+#define LPC_EMAC_BASE         (LPC_AHB_BASE  + 0x00000)
+#define LPC_GPDMA_BASE        (LPC_AHB_BASE  + 0x04000)
+#define LPC_GPDMACH0_BASE     (LPC_AHB_BASE  + 0x04100)
+#define LPC_GPDMACH1_BASE     (LPC_AHB_BASE  + 0x04120)
+#define LPC_GPDMACH2_BASE     (LPC_AHB_BASE  + 0x04140)
+#define LPC_GPDMACH3_BASE     (LPC_AHB_BASE  + 0x04160)
+#define LPC_GPDMACH4_BASE     (LPC_AHB_BASE  + 0x04180)
+#define LPC_GPDMACH5_BASE     (LPC_AHB_BASE  + 0x041A0)
+#define LPC_GPDMACH6_BASE     (LPC_AHB_BASE  + 0x041C0)
+#define LPC_GPDMACH7_BASE     (LPC_AHB_BASE  + 0x041E0)
+#define LPC_USB_BASE          (LPC_AHB_BASE  + 0x0C000)
 
 /* GPIOs                                                                      */
-#define GPIO0_BASE            (GPIO_BASE + 0x00000)
-#define GPIO1_BASE            (GPIO_BASE + 0x00020)
-#define GPIO2_BASE            (GPIO_BASE + 0x00040)
-#define GPIO3_BASE            (GPIO_BASE + 0x00060)
-#define GPIO4_BASE            (GPIO_BASE + 0x00080)
+#define LPC_GPIO0_BASE        (LPC_GPIO_BASE + 0x00000)
+#define LPC_GPIO1_BASE        (LPC_GPIO_BASE + 0x00020)
+#define LPC_GPIO2_BASE        (LPC_GPIO_BASE + 0x00040)
+#define LPC_GPIO3_BASE        (LPC_GPIO_BASE + 0x00060)
+#define LPC_GPIO4_BASE        (LPC_GPIO_BASE + 0x00080)
 
-/**
- * @}
- */
 
-
-/** @addtogroup Peripheral_declaration
-  * @{
-  */
-
 /******************************************************************************/
 /*                         Peripheral declaration                             */
 /******************************************************************************/
-#define SC                    ((     SC_TypeDef *)       SC_BASE)
-#define GPIO0                 ((   GPIO_TypeDef *)    GPIO0_BASE)
-#define GPIO1                 ((   GPIO_TypeDef *)    GPIO1_BASE)
-#define GPIO2                 ((   GPIO_TypeDef *)    GPIO2_BASE)
-#define GPIO3                 ((   GPIO_TypeDef *)    GPIO3_BASE)
-#define GPIO4                 ((   GPIO_TypeDef *)    GPIO4_BASE)
-#define WDT                   ((    WDT_TypeDef *)      WDT_BASE)
-#define TIM0                  ((    TIM_TypeDef *)     TIM0_BASE)
-#define TIM1                  ((    TIM_TypeDef *)     TIM1_BASE)
-#define TIM2                  ((    TIM_TypeDef *)     TIM2_BASE)
-#define TIM3                  ((    TIM_TypeDef *)     TIM3_BASE)
-#define RIT                   ((    RIT_TypeDef *)      RIT_BASE)
-#define UART0                 ((   UART_TypeDef *)    UART0_BASE)
-#define UART1                 ((  UART1_TypeDef *)    UART1_BASE)
-#define UART2                 ((   UART_TypeDef *)    UART2_BASE)
-#define UART3                 ((   UART_TypeDef *)    UART3_BASE)
-#define PWM1                  ((    PWM_TypeDef *)     PWM1_BASE)
-#define I2C0                  ((    I2C_TypeDef *)     I2C0_BASE)
-#define I2C1                  ((    I2C_TypeDef *)     I2C1_BASE)
-#define I2C2                  ((    I2C_TypeDef *)     I2C2_BASE)
-#define I2S                   ((    I2S_TypeDef *)      I2S_BASE)
-#define SPI                   ((    SPI_TypeDef *)      SPI_BASE)
-#define RTC                   ((    RTC_TypeDef *)      RTC_BASE)
-#define GPIOINT               ((GPIOINT_TypeDef *)  GPIOINT_BASE)
-#define PINCON                (( PINCON_TypeDef *)   PINCON_BASE)
-#define SSP0                  ((    SSP_TypeDef *)     SSP0_BASE)
-#define SSP1                  ((    SSP_TypeDef *)     SSP1_BASE)
-#define ADC                   ((    ADC_TypeDef *)      ADC_BASE)
-#define DAC                   ((    DAC_TypeDef *)      DAC_BASE)
-#define CANAF_RAM           ((CANAF_RAM_TypeDef *)CANAF_RAM_BASE)
-#define CANAF                 ((  CANAF_TypeDef *)    CANAF_BASE)
-#define CANCR                 ((  CANCR_TypeDef *)    CANCR_BASE)
-#define CAN1                  ((    CAN_TypeDef *)     CAN1_BASE)
-#define CAN2                  ((    CAN_TypeDef *)     CAN2_BASE)
-#define MCPWM                 ((  MCPWM_TypeDef *)    MCPWM_BASE)
-#define QEI                   ((    QEI_TypeDef *)      QEI_BASE)
-#define EMAC                  ((   EMAC_TypeDef *)     EMAC_BASE)
-#define GPDMA                 ((  GPDMA_TypeDef *)    GPDMA_BASE)
+#define LPC_SC                ((LPC_SC_TypeDef        *) LPC_SC_BASE       )
+#define LPC_GPIO0             ((LPC_GPIO_TypeDef      *) LPC_GPIO0_BASE    )
+#define LPC_GPIO1             ((LPC_GPIO_TypeDef      *) LPC_GPIO1_BASE    )
+#define LPC_GPIO2             ((LPC_GPIO_TypeDef      *) LPC_GPIO2_BASE    )
+#define LPC_GPIO3             ((LPC_GPIO_TypeDef      *) LPC_GPIO3_BASE    )
+#define LPC_GPIO4             ((LPC_GPIO_TypeDef      *) LPC_GPIO4_BASE    )
+#define LPC_WDT               ((LPC_WDT_TypeDef       *) LPC_WDT_BASE      )
+#define LPC_TIM0              ((LPC_TIM_TypeDef       *) LPC_TIM0_BASE     )
+#define LPC_TIM1              ((LPC_TIM_TypeDef       *) LPC_TIM1_BASE     )
+#define LPC_TIM2              ((LPC_TIM_TypeDef       *) LPC_TIM2_BASE     )
+#define LPC_TIM3              ((LPC_TIM_TypeDef       *) LPC_TIM3_BASE     )
+#define LPC_RIT               ((LPC_RIT_TypeDef       *) LPC_RIT_BASE      )
+#define LPC_UART0             ((LPC_UART_TypeDef     *) LPC_UART0_BASE    )
+#define LPC_UART1             ((LPC_UART1_TypeDef     *) LPC_UART1_BASE    )
+#define LPC_UART2             ((LPC_UART_TypeDef      *) LPC_UART2_BASE    )
+#define LPC_UART3             ((LPC_UART_TypeDef      *) LPC_UART3_BASE    )
+#define LPC_PWM1              ((LPC_PWM_TypeDef       *) LPC_PWM1_BASE     )
+#define LPC_I2C0              ((LPC_I2C_TypeDef       *) LPC_I2C0_BASE     )
+#define LPC_I2C1              ((LPC_I2C_TypeDef       *) LPC_I2C1_BASE     )
+#define LPC_I2C2              ((LPC_I2C_TypeDef       *) LPC_I2C2_BASE     )
+#define LPC_I2S               ((LPC_I2S_TypeDef       *) LPC_I2S_BASE      )
+#define LPC_SPI               ((LPC_SPI_TypeDef       *) LPC_SPI_BASE      )
+#define LPC_RTC               ((LPC_RTC_TypeDef       *) LPC_RTC_BASE      )
+#define LPC_GPIOINT           ((LPC_GPIOINT_TypeDef   *) LPC_GPIOINT_BASE  )
+#define LPC_PINCON            ((LPC_PINCON_TypeDef    *) LPC_PINCON_BASE   )
+#define LPC_SSP0              ((LPC_SSP_TypeDef       *) LPC_SSP0_BASE     )
+#define LPC_SSP1              ((LPC_SSP_TypeDef       *) LPC_SSP1_BASE     )
+#define LPC_ADC               ((LPC_ADC_TypeDef       *) LPC_ADC_BASE      )
+#define LPC_DAC               ((LPC_DAC_TypeDef       *) LPC_DAC_BASE      )
+#define LPC_CANAF_RAM         ((LPC_CANAF_RAM_TypeDef *) LPC_CANAF_RAM_BASE)
+#define LPC_CANAF             ((LPC_CANAF_TypeDef     *) LPC_CANAF_BASE    )
+#define LPC_CANCR             ((LPC_CANCR_TypeDef     *) LPC_CANCR_BASE    )
+#define LPC_CAN1              ((LPC_CAN_TypeDef       *) LPC_CAN1_BASE     )
+#define LPC_CAN2              ((LPC_CAN_TypeDef       *) LPC_CAN2_BASE     )
+#define LPC_MCPWM             ((LPC_MCPWM_TypeDef     *) LPC_MCPWM_BASE    )
+#define LPC_QEI               ((LPC_QEI_TypeDef       *) LPC_QEI_BASE      )
+#define LPC_EMAC              ((LPC_EMAC_TypeDef      *) LPC_EMAC_BASE     )
+#define LPC_GPDMA             ((LPC_GPDMA_TypeDef     *) LPC_GPDMA_BASE    )
 #define DMAREQSEL             (*(__IO uint32_t *)  ( 0x4000C1C4))
-#define GPDMACH0              ((GPDMACH_TypeDef *) GPDMACH0_BASE)
-#define GPDMACH1              ((GPDMACH_TypeDef *) GPDMACH1_BASE)
-#define GPDMACH2              ((GPDMACH_TypeDef *) GPDMACH2_BASE)
-#define GPDMACH3              ((GPDMACH_TypeDef *) GPDMACH3_BASE)
-#define GPDMACH4              ((GPDMACH_TypeDef *) GPDMACH4_BASE)
-#define GPDMACH5              ((GPDMACH_TypeDef *) GPDMACH5_BASE)
-#define GPDMACH6              ((GPDMACH_TypeDef *) GPDMACH6_BASE)
-#define GPDMACH7              ((GPDMACH_TypeDef *) GPDMACH7_BASE)
-#define USB                   ((    USB_TypeDef *)      USB_BASE)
+#define LPC_GPDMACH0          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH0_BASE )
+#define LPC_GPDMACH1          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH1_BASE )
+#define LPC_GPDMACH2          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH2_BASE )
+#define LPC_GPDMACH3          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH3_BASE )
+#define LPC_GPDMACH4          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH4_BASE )
+#define LPC_GPDMACH5          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH5_BASE )
+#define LPC_GPDMACH6          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH6_BASE )
+#define LPC_GPDMACH7          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH7_BASE )
+#define LPC_USB               ((LPC_USB_TypeDef       *) LPC_USB_BASE      )
 
-/**
- * @}
- */
-
 #endif  // __LPC17xx_H__
-
-/* End Of File ---------------------------------------------------------------- */

Modified: trunk/src/platform/lpc17xx/core_cm3.c
===================================================================
--- trunk/src/platform/lpc17xx/core_cm3.c	2010-06-28 21:53:59 UTC (rev 759)
+++ trunk/src/platform/lpc17xx/core_cm3.c	2010-07-12 20:56:54 UTC (rev 760)
@@ -1,16 +1,18 @@
-/****************************************************************************//**
- * @file :    core_cm3.c
- * @brief : CMSIS Cortex-M3 Core Peripheral Access Layer Source File
- * @version : V1.20
- * @date :    22. May 2009
- *----------------------------------------------------------------------------
+/**************************************************************************//**
+ * @file     core_cm3.c
+ * @brief    CMSIS Cortex-M3 Core Peripheral Access Layer Source File
+ * @version  V1.30
+ * @date     30. October 2009
  *
+ * @note
  * Copyright (C) 2009 ARM Limited. All rights reserved.
  *
- * ARM Limited (ARM) is supplying this software for use with Cortex-Mx 
+ * @par
+ * ARM Limited (ARM) is supplying this software for use with Cortex-M 
  * processor based microcontrollers.  This file can be freely distributed 
  * within development tools that are supporting such ARM based processors. 
  *
+ * @par
  * THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
  * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
@@ -19,39 +21,37 @@
  *
  ******************************************************************************/
 
-
-
 #include &lt;stdint.h&gt;
 
-
 /* define compiler specific symbols */
-#if defined   ( __CC_ARM   )
-  #define __ASM            __asm           /*!&lt; asm keyword for armcc           */
-  #define __INLINE         __inline        /*!&lt; inline keyword for armcc        */
+#if defined ( __CC_ARM   )
+  #define __ASM            __asm                                      /*!&lt; asm keyword for ARM Compiler          */
+  #define __INLINE         __inline                                   /*!&lt; inline keyword for ARM Compiler       */
 
 #elif defined ( __ICCARM__ )
-  #define __ASM           __asm            /*!&lt; asm keyword for iarcc           */
-  #define __INLINE        inline           /*!&lt; inline keyword for iarcc. Only avaiable in High optimization mode! */
+  #define __ASM           __asm                                       /*!&lt; asm keyword for IAR Compiler          */
+  #define __INLINE        inline                                      /*!&lt; inline keyword for IAR Compiler. Only avaiable in High optimization mode! */
 
-#elif defined (  __GNUC__  )
-  #define __ASM             __asm          /*!&lt; asm keyword for gcc            */
-  #define __INLINE          inline         /*!&lt; inline keyword for gcc         */
+#elif defined   (  __GNUC__  )
+  #define __ASM            __asm                                      /*!&lt; asm keyword for GNU Compiler          */
+  #define __INLINE         inline                                     /*!&lt; inline keyword for GNU Compiler       */
 
 #elif defined   (  __TASKING__  )
-  #define __ASM            __asm           /*!&lt; asm keyword for TASKING Compiler          */
-  #define __INLINE         inline          /*!&lt; inline keyword for TASKING Compiler       */
+  #define __ASM            __asm                                      /*!&lt; asm keyword for TASKING Compiler      */
+  #define __INLINE         inline                                     /*!&lt; inline keyword for TASKING Compiler   */
 
 #endif
 
 
+/* ###################  Compiler specific Intrinsics  ########################### */
 
 #if defined ( __CC_ARM   ) /*------------------RealView Compiler -----------------*/
+/* ARM armcc specific functions */
 
 /**
  * @brief  Return the Process Stack Pointer
  *
- * @param  none
- * @return uint32_t ProcessStackPointer
+ * @return ProcessStackPointer
  *
  * Return the actual process stack pointer
  */
@@ -64,8 +64,7 @@
 /**
  * @brief  Set the Process Stack Pointer
  *
- * @param  uint32_t Process Stack Pointer
- * @return none
+ * @param  topOfProcStack  Process Stack Pointer
  *
  * Assign the value ProcessStackPointer to the MSP 
  * (process stack pointer) Cortex processor register
@@ -79,8 +78,7 @@
 /**
  * @brief  Return the Main Stack Pointer
  *
- * @param  none
- * @return uint32_t Main Stack Pointer
+ * @return Main Stack Pointer
  *
  * Return the current value of the MSP (main stack pointer)
  * Cortex processor register
@@ -94,8 +92,7 @@
 /**
  * @brief  Set the Main Stack Pointer
  *
- * @param  uint32_t Main Stack Pointer
- * @return none
+ * @param  topOfMainStack  Main Stack Pointer
  *
  * Assign the value mainStackPointer to the MSP 
  * (main stack pointer) Cortex processor register
@@ -109,8 +106,8 @@
 /**
  * @brief  Reverse byte order in unsigned short value
  *
- * @param  uint16_t value to reverse
- * @return uint32_t reversed value
+ * @param   value  value to reverse
+ * @return         reversed value
  *
  * Reverse byte order in unsigned short value
  */
@@ -123,8 +120,8 @@
 /**
  * @brief  Reverse byte order in signed short value with sign extension to integer
  *
- * @param  int16_t value to reverse
- * @return int32_t reversed value
+ * @param   value  value to reverse
+ * @return         reversed value
  *
  * Reverse byte order in signed short value with sign extension to integer
  */
@@ -140,9 +137,6 @@
 /**
  * @brief  Remove the exclusive lock created by ldrex
  *
- * @param  none
- * @return none
- *
  * Removes the exclusive lock which is created by ldrex.
  */
 __ASM void __CLREX(void)
@@ -153,8 +147,7 @@
 /**
  * @brief  Return the Base Priority value
  *
- * @param  none
- * @return uint32_t BasePriority
+ * @return BasePriority
  *
  * Return the content of the base priority register
  */
@@ -167,8 +160,7 @@
 /**
  * @brief  Set the Base Priority value
  *
- * @param  uint32_t BasePriority
- * @return none
+ * @param  basePri  BasePriority
  *
  * Set the base priority register
  */
@@ -181,11 +173,9 @@
 /**
  * @brief  Return the Priority Mask value
  *
- * @param  none
- * @return uint32_t PriMask
+ * @return PriMask
  *
- * Return the state of the priority mask bit from the priority mask
- * register
+ * Return state of the priority mask bit from the priority mask register
  */
 __ASM uint32_t __get_PRIMASK(void)
 {
@@ -196,8 +186,7 @@
 /**
  * @brief  Set the Priority Mask value
  *
- * @param  uint32_t PriMask
- * @return none
+ * @param  priMask  PriMask
  *
  * Set the priority mask bit in the priority mask register
  */
@@ -210,8 +199,7 @@
 /**
  * @brief  Return the Fault Mask value
  *
- * @param  none
- * @return uint32_t FaultMask
+ * @return FaultMask
  *
  * Return the content of the fault mask register
  */
@@ -224,8 +212,7 @@
 /**
  * @brief  Set the Fault Mask value
  *
- * @param  uint32_t faultMask value
- * @return none
+ * @param  faultMask  faultMask value
  *
  * Set the fault mask register
  */
@@ -238,12 +225,11 @@
 /**
  * @brief  Return the Control Register value
  * 
- * @param  none
- * @return uint32_t Control value
+ * @return Control value
  *
  * Return the content of the control register
  */
-__ASM uint32_t  __get_CONTROL(void)
+__ASM uint32_t __get_CONTROL(void)
 {
   mrs r0, control
   bx lr
@@ -252,8 +238,7 @@
 /**
  * @brief  Set the Control Register value
  *
- * @param  uint32_t Control value
- * @return none
+ * @param  control  Control value
  *
  * Set the control register
  */
@@ -266,14 +251,15 @@
 #endif /* __ARMCC_VERSION  */ 
 
 
+
 #elif (defined (__ICCARM__)) /*------------------ ICC Compiler -------------------*/
+/* IAR iccarm specific functions */
 #pragma diag_suppress=Pe940
 
 /**
  * @brief  Return the Process Stack Pointer
  *
- * @param  none
- * @return uint32_t ProcessStackPointer
+ * @return ProcessStackPointer
  *
  * Return the actual process stack pointer
  */
@@ -286,8 +272,7 @@
 /**
  * @brief  Set the Process Stack Pointer
  *
- * @param  uint32_t Process Stack Pointer
- * @return none
+ * @param  topOfProcStack  Process Stack Pointer
  *
  * Assign the value ProcessStackPointer to the MSP 
  * (process stack pointer) Cortex processor register
@@ -301,8 +286,7 @@
 /**
  * @brief  Return the Main Stack Pointer
  *
- * @param  none
- * @return uint32_t Main Stack Pointer
+ * @return Main Stack Pointer
  *
  * Return the current value of the MSP (main stack pointer)
  * Cortex processor register
@@ -316,8 +300,7 @@
 /**
  * @brief  Set the Main Stack Pointer
  *
- * @param  uint32_t Main Stack Pointer
- * @return none
+ * @param  topOfMainStack  Main Stack Pointer
  *
  * Assign the value mainStackPointer to the MSP 
  * (main stack pointer) Cortex processor register
@@ -331,8 +314,8 @@
 /**
  * @brief  Reverse byte order in unsigned short value
  *
- * @param  uint16_t value to reverse
- * @return uint32_t reversed value
+ * @param  value  value to reverse
+ * @return        reversed value
  *
  * Reverse byte order in unsigned short value
  */
@@ -345,8 +328,8 @@
 /**
  * @brief  Reverse bit order of value
  *
- * @param  uint32_t value to reverse
- * @return uint32_t reversed value
+ * @param  value  value to reverse
+ * @return        reversed value
  *
  * Reverse bit order of value
  */
@@ -357,12 +340,12 @@
 }
 
 /**
- * @brief  LDR Exclusive
+ * @brief  LDR Exclusive (8 bit)
  *
- * @param  uint8_t* address
- * @return uint8_t value of (*address)
+ * @param  *addr  address pointer
+ * @return        value of (*address)
  *
- * Exclusive LDR command
+ * Exclusive LDR command for 8 bit values)
  */
 uint8_t __LDREXB(uint8_t *addr)
 {
@@ -371,12 +354,12 @@
 }
 
 /**
- * @brief  LDR Exclusive
+ * @brief  LDR Exclusive (16 bit)
  *
- * @param  uint16_t* address
- * @return uint16_t value of (*address)
+ * @param  *addr  address pointer
+ * @return        value of (*address)
  *
- * Exclusive LDR command
+ * Exclusive LDR command for 16 bit values
  */
 uint16_t __LDREXH(uint16_t *addr)
 {
@@ -385,12 +368,12 @@
 }
 
 /**
- * @brief  LDR Exclusive
+ * @brief  LDR Exclusive (32 bit)
  *
- * @param  uint32_t* address
- * @return uint32_t value of (*address)
+ * @param  *addr  address pointer
+ * @return        value of (*address)
  *
- * Exclusive LDR command
+ * Exclusive LDR command for 32 bit values
  */
 uint32_t __LDREXW(uint32_t *addr)
 {
@@ -399,13 +382,13 @@
 }
 
 /**
- * @brief  STR Exclusive
+ * @brief  STR Exclusive (8 bit)
  *
- * @param  uint8_t *address
- * @param  uint8_t value to store
- * @return uint32_t successful / failed
+ * @param  value  value to store
+ * @param  *addr  address pointer
+ * @return        successful / failed
  *
- * Exclusive STR command
+ * Exclusive STR command for 8 bit values
  */
 uint32_t __STREXB(uint8_t value, uint8_t *addr)
 {
@@ -414,13 +397,13 @@
 }
 
 /**
- * @brief  STR Exclusive
+ * @brief  STR Exclusive (16 bit)
  *
- * @param  uint16_t *address
- * @param  uint16_t value to store
- * @return uint32_t successful / failed
+ * @param  value  value to store
+ * @param  *addr  address pointer
+ * @return        successful / failed
  *
- * Exclusive STR command
+ * Exclusive STR command for 16 bit values
  */
 uint32_t __STREXH(uint16_t value, uint16_t *addr)
 {
@@ -429,13 +412,13 @@
 }
 
 /**
- * @brief  STR Exclusive
+ * @brief  STR Exclusive (32 bit)
  *
- * @param  uint32_t *address
- * @param  uint32_t value to store
- * @return uint32_t successful / failed
+ * @param  value  value to store
+ * @param  *addr  address pointer
+ * @return        successful / failed
  *
- * Exclusive STR command
+ * Exclusive STR command for 32 bit values
  */
 uint32_t __STREXW(uint32_t value, uint32_t *addr)
 {
@@ -447,12 +430,12 @@
 
 
 #elif (defined (__GNUC__)) /*------------------ GNU Compiler ---------------------*/
+/* GNU gcc specific functions */
 
 /**
  * @brief  Return the Process Stack Pointer
  *
- * @param  none
- * @return uint32_t ProcessStackPointer
+ * @return ProcessStackPointer
  *
  * Return the actual process stack pointer
  */
@@ -467,12 +450,10 @@
   return(result);
 }
 
-
 /**
  * @brief  Set the Process Stack Pointer
  *
- * @param  uint32_t Process Stack Pointer
- * @return none
+ * @param  topOfProcStack  Process Stack Pointer
  *
  * Assign the value ProcessStackPointer to the MSP 
  * (process stack pointer) Cortex processor register
@@ -487,8 +468,7 @@
 /**
  * @brief  Return the Main Stack Pointer
  *
- * @param  none
- * @return uint32_t Main Stack Pointer
+ * @return Main Stack Pointer
  *
  * Return the current value of the MSP (main stack pointer)
  * Cortex processor register
@@ -507,8 +487,7 @@
 /**
  * @brief  Set the Main Stack Pointer
  *
- * @param  uint32_t Main Stack Pointer
- * @return none
+ * @param  topOfMainStack  Main Stack Pointer
  *
  * Assign the value mainStackPointer to the MSP 
  * (main stack pointer) Cortex processor register
@@ -523,8 +502,7 @@
 /**
  * @brief  Return the Base Priority value
  *
- * @param  none
- * @return uint32_t BasePriority
+ * @return BasePriority
  *
  * Return the content of the base priority register
  */
@@ -539,8 +517,7 @@
 /**
  * @brief  Set the Base Priority value
  *
- * @param  uint32_t BasePriority
- * @return none
+ * @param  basePri  BasePriority
  *
  * Set the base priority register
  */
@@ -552,11 +529,9 @@
 /**
  * @brief  Return the Priority Mask value
  *
- * @param  none
- * @return uint32_t PriMask
+ * @return PriMask
  *
- * Return the state of the priority mask bit from the priority mask
- * register
+ * Return state of the priority mask bit from the priority mask register
  */
 uint32_t __get_PRIMASK(void)
 {
@@ -569,8 +544,7 @@
 /**
  * @brief  Set the Priority Mask value
  *
- * @param  uint32_t PriMask
- * @return none
+ * @param  priMask  PriMask
  *
  * Set the priority mask bit in the priority mask register
  */
@@ -582,8 +556,7 @@
 /**
  * @brief  Return the Fault Mask value
  *
- * @param  none
- * @return uint32_t FaultMask
+ * @return FaultMask
  *
  * Return the content of the fault mask register
  */
@@ -598,8 +571,7 @@
 /**
  * @brief  Set the Fault Mask value
  *
- * @param  uint32_t faultMask value
- * @return none
+ * @param  faultMask  faultMask value
  *
  * Set the fault mask register
  */
@@ -609,10 +581,38 @@
 }
 
 /**
+ * @brief  Return the Control Register value
+* 
+*  @return Control value
+ *
+ * Return the content of the control register
+ */
+uint32_t __get_CONTROL(void)
+{
+  uint32_t result=0;
+
+  __ASM volatile (&quot;MRS %0, control&quot; : &quot;=r&quot; (result) );
+  return(result);
+}
+
+/**
+ * @brief  Set the Control Register value
+ *
+ * @param  control  Control value
+ *
+ * Set the control register
+ */
+void __set_CONTROL(uint32_t control)
+{
+  __ASM volatile (&quot;MSR control, %0&quot; : : &quot;r&quot; (control) );
+}
+
+
+/**
  * @brief  Reverse byte order in integer value
  *
- * @param  uint32_t value to reverse
- * @return uint32_t reversed value
+ * @param  value  value to reverse
+ * @return        reversed value
  *
  * Reverse byte order in integer value
  */
@@ -627,8 +627,8 @@
 /**
  * @brief  Reverse byte order in unsigned short value
  *
- * @param  uint16_t value to reverse
- * @return uint32_t reversed value
+ * @param  value  value to reverse
+ * @return        reversed value
  *
  * Reverse byte order in unsigned short value
  */
@@ -643,8 +643,8 @@
 /**
  * @brief  Reverse byte order in signed short value with sign extension to integer
  *
- * @param  int32_t value to reverse
- * @return int32_t reversed value
+ * @param  value  value to reverse
+ * @return        reversed value
  *
  * Reverse byte order in signed short value with sign extension to integer
  */
@@ -659,8 +659,8 @@
 /**
  * @brief  Reverse bit order of value
  *
- * @param  uint32_t value to reverse
- * @return uint32_t reversed value
+ * @param  value  value to reverse
+ * @return        reversed value
  *
  * Reverse bit order of value
  */
@@ -673,12 +673,12 @@
 }
 
 /**
- * @brief  LDR Exclusive
+ * @brief  LDR Exclusive (8 bit)
  *
- * @param  uint8_t* address
- * @return uint8_t value of (*address)
+ * @param  *addr  address pointer
+ * @return        value of (*address)
  *
- * Exclusive LDR command
+ * Exclusive LDR command for 8 bit value
  */
 uint8_t __LDREXB(uint8_t *addr)
 {
@@ -689,12 +689,12 @@
 }
 
 /**
- * @brief  LDR Exclusive
+ * @brief  LDR Exclusive (16 bit)
  *
- * @param  uint16_t* address
- * @return uint16_t value of (*address)
+ * @param  *addr  address pointer
+ * @return        value of (*address)
  *
- * Exclusive LDR command
+ * Exclusive LDR command for 16 bit values
  */
 uint16_t __LDREXH(uint16_t *addr)
 {
@@ -705,12 +705,12 @@
 }
 
 /**
- * @brief  LDR Exclusive
+ * @brief  LDR Exclusive (32 bit)
  *
- * @param  uint32_t* address
- * @return uint32_t value of (*address)
+ * @param  *addr  address pointer
+ * @return        value of (*address)
  *
- * Exclusive LDR command
+ * Exclusive LDR command for 32 bit values
  */
 uint32_t __LDREXW(uint32_t *addr)
 {
@@ -721,13 +721,13 @@
 }
 
 /**
- * @brief  STR Exclusive
+ * @brief  STR Exclusive (8 bit)
  *
- * @param  uint8_t *address
- * @param  uint8_t value to store
- * @return uint32_t successful / failed
+ * @param  value  value to store
+ * @param  *addr  address pointer
+ * @return        successful / failed
  *
- * Exclusive STR command
+ * Exclusive STR command for 8 bit values
  */
 uint32_t __STREXB(uint8_t value, uint8_t *addr)
 {
@@ -738,13 +738,13 @@
 }
 
 /**
- * @brief  STR Exclusive
+ * @brief  STR Exclusive (16 bit)
  *
- * @param  uint16_t *address
- * @param  uint16_t value to store
- * @return uint32_t successful / failed
+ * @param  value  value to store
+ * @param  *addr  address pointer
+ * @return        successful / failed
  *
- * Exclusive STR command
+ * Exclusive STR command for 16 bit values
  */
 uint32_t __STREXH(uint16_t value, uint16_t *addr)
 {
@@ -755,13 +755,13 @@
 }
 
 /**
- * @brief  STR Exclusive
+ * @brief  STR Exclusive (32 bit)
  *
- * @param  uint32_t *address
- * @param  uint32_t value to store
- * @return uint32_t successful / failed
+ * @param  value  value to store
+ * @param  *addr  address pointer
+ * @return        successful / failed
  *
- * Exclusive STR command
+ * Exclusive STR command for 32 bit values
  */
 uint32_t __STREXW(uint32_t value, uint32_t *addr)
 {
@@ -771,35 +771,7 @@
    return(result);
 }
 
-/**
- * @brief  Return the Control Register value
- * 
- * @param  none
- * @return uint32_t Control value
- *
- * Return the content of the control register
- */
-uint32_t __get_CONTROL(void)
-{
-  uint32_t result=0;
 
-  __ASM volatile (&quot;MRS %0, control&quot; : &quot;=r&quot; (result) );
-  return(result);
-}
-
-/**
- * @brief  Set the Control Register value
- *
- * @param  uint32_t Control value
- * @return none
- *
- * Set the control register
- */
-void __set_CONTROL(uint32_t control)
-{
-  __ASM volatile (&quot;MSR control, %0&quot; : : &quot;r&quot; (control) );
-}
-
 #elif (defined (__TASKING__)) /*------------------ TASKING Compiler ---------------------*/
 /* TASKING carm specific functions */
 
@@ -810,20 +782,3 @@
  */
 
 #endif
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-

Modified: trunk/src/platform/lpc17xx/core_cm3.h
===================================================================
--- trunk/src/platform/lpc17xx/core_cm3.h	2010-06-28 21:53:59 UTC (rev 759)
+++ trunk/src/platform/lpc17xx/core_cm3.h	2010-07-12 20:56:54 UTC (rev 760)
@@ -1,16 +1,18 @@
-/****************************************************************************//**
- * @file :    core_cm3.h
- * @brief : CMSIS Cortex-M3 Core Peripheral Access Layer Header File
- * @version : V1.20
- * @date :    22. May 2009
- *----------------------------------------------------------------------------
+/**************************************************************************//**
+ * @file     core_cm3.h
+ * @brief    CMSIS Cortex-M3 Core Peripheral Access Layer Header File
+ * @version  V1.30
+ * @date     30. October 2009
  *
+ * @note
  * Copyright (C) 2009 ARM Limited. All rights reserved.
  *
- * ARM Limited (ARM) is supplying this software for use with Cortex-Mx
+ * @par
+ * ARM Limited (ARM) is supplying this software for use with Cortex-M
  * processor based microcontrollers.  This file can be freely distributed
  * within development tools that are supporting such ARM based processors.
  *
+ * @par
  * THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
  * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
@@ -22,53 +24,38 @@
 #ifndef __CM3_CORE_H__
 #define __CM3_CORE_H__
 
-#ifdef __cplusplus
- extern &quot;C&quot; {
-#endif
-
-#define __CM3_CMSIS_VERSION_MAIN  (0x01)                                                       /*!&lt; [31:16] CMSIS HAL main version */
-#define __CM3_CMSIS_VERSION_SUB   (0x20)                                                       /*!&lt; [15:0]  CMSIS HAL sub version  */
-#define __CM3_CMSIS_VERSION       ((__CM3_CMSIS_VERSION_MAIN &lt;&lt; 16) | __CM3_CMSIS_VERSION_SUB) /*!&lt; CMSIS HAL version number       */
-
-#define __CORTEX_M                (0x03)                                                       /*!&lt; Cortex core                    */
-
-/**
- *  Lint configuration \n
- *  ----------------------- \n
+/** @addtogroup CMSIS_CM3_core_LintCinfiguration CMSIS CM3 Core Lint Configuration
  *
- *  The following Lint messages will be suppressed and not shown: \n
- *  \n
- *    --- Error 10: --- \n
- *    register uint32_t __regBasePri         __asm(&quot;basepri&quot;); \n
- *    Error 10: Expecting ';' \n
- *     \n
- *    --- Error 530: --- \n
- *    return(__regBasePri); \n
- *    Warning 530: Symbol '__regBasePri' (line 264) not initialized \n
- *     \n
- *    --- Error 550: --- \n
- *      __regBasePri = (basePri &amp; 0x1ff); \n
- *    } \n
- *    Warning 550: Symbol '__regBasePri' (line 271) not accessed \n
- *     \n
- *    --- Error 754: --- \n
- *    uint32_t RESERVED0[24]; \n
- *    Info 754: local structure member '&lt;some, not used in the HAL&gt;' (line 109, file ./cm3_core.h) not referenced \n
- *     \n
- *    --- Error 750: --- \n
- *    #define __CM3_CORE_H__ \n
- *    Info 750: local macro '__CM3_CORE_H__' (line 43, file./cm3_core.h) not referenced \n
- *     \n
- *    --- Error 528: --- \n
- *    static __INLINE void NVIC_DisableIRQ(uint32_t IRQn) \n
- *    Warning 528: Symbol 'NVIC_DisableIRQ(unsigned int)' (line 419, file ./cm3_core.h) not referenced \n
- *     \n
- *    --- Error 751: --- \n
- *    } InterruptType_Type; \n
- *    Info 751: local typedef 'InterruptType_Type' (line 170, file ./cm3_core.h) not referenced \n
- * \n
- * \n
- *    Note:  To re-enable a Message, insert a space before 'lint' * \n
+ * List of Lint messages which will be suppressed and not shown:
+ *   - Error 10: \n
+ *     register uint32_t __regBasePri         __asm(&quot;basepri&quot;); \n
+ *     Error 10: Expecting ';'
+ * .
+ *   - Error 530: \n
+ *     return(__regBasePri); \n
+ *     Warning 530: Symbol '__regBasePri' (line 264) not initialized
+ * .
+ *   - Error 550: \n
+ *     __regBasePri = (basePri &amp; 0x1ff); \n
+ *     Warning 550: Symbol '__regBasePri' (line 271) not accessed
+ * .
+ *   - Error 754: \n
+ *     uint32_t RESERVED0[24]; \n
+ *     Info 754: local structure member '&lt;some, not used in the HAL&gt;' (line 109, file ./cm3_core.h) not referenced
+ * .
+ *   - Error 750: \n
+ *     #define __CM3_CORE_H__ \n
+ *     Info 750: local macro '__CM3_CORE_H__' (line 43, file./cm3_core.h) not referenced
+ * .
+ *   - Error 528: \n
+ *     static __INLINE void NVIC_DisableIRQ(uint32_t IRQn) \n
+ *     Warning 528: Symbol 'NVIC_DisableIRQ(unsigned int)' (line 419, file ./cm3_core.h) not referenced
+ * .
+ *   - Error 751: \n
+ *     } InterruptType_Type; \n
+ *     Info 751: local typedef 'InterruptType_Type' (line 170, file ./cm3_core.h) not referenced
+ * .
+ * Note:  To re-enable a Message, insert a space before 'lint' *
  *
  */
 
@@ -82,6 +69,24 @@
 /*lint -e751 */
 
 
+/** @addtogroup CMSIS_CM3_core_definitions CM3 Core Definitions
+  This file defines all structures and symbols for CMSIS core:
+    - CMSIS version number
+    - Cortex-M core registers and bitfields
+    - Cortex-M core peripheral base address
+  @{
+ */
+
+#ifdef __cplusplus
+ extern &quot;C&quot; {
+#endif
+
+#define __CM3_CMSIS_VERSION_MAIN  (0x01)                                                       /*!&lt; [31:16] CMSIS HAL main version */
+#define __CM3_CMSIS_VERSION_SUB   (0x30)                                                       /*!&lt; [15:0]  CMSIS HAL sub version  */
+#define __CM3_CMSIS_VERSION       ((__CM3_CMSIS_VERSION_MAIN &lt;&lt; 16) | __CM3_CMSIS_VERSION_SUB) /*!&lt; CMSIS HAL version number       */
+
+#define __CORTEX_M                (0x03)                                                       /*!&lt; Cortex core                    */
+
 #include &lt;stdint.h&gt;                           /* Include standard types */
 
 #if defined (__ICCARM__)
@@ -103,9 +108,9 @@
  */
 
 #ifdef __cplusplus
-#define     __I     volatile                  /*!&lt; defines 'read only' permissions      */
+  #define     __I     volatile                /*!&lt; defines 'read only' permissions      */
 #else
-#define     __I     volatile const            /*!&lt; defines 'read only' permissions      */
+  #define     __I     volatile const          /*!&lt; defines 'read only' permissions      */
 #endif
 #define     __O     volatile                  /*!&lt; defines 'write only' permissions     */
 #define     __IO    volatile                  /*!&lt; defines 'read / write' permissions   */
@@ -115,188 +120,630 @@
 /*******************************************************************************
  *                 Register Abstraction
  ******************************************************************************/
+/** @addtogroup CMSIS_CM3_core_register CMSIS CM3 Core Register
+ @{
+*/
 
 
-/* System Reset */
-#define NVIC_VECTRESET              0         /*!&lt; Vector Reset Bit             */
-#define NVIC_SYSRESETREQ            2         /*!&lt; System Reset Request         */
-#define NVIC_AIRCR_VECTKEY    (0x5FA &lt;&lt; 16)   /*!&lt; AIRCR Key for write access   */
-#define NVIC_AIRCR_ENDIANESS        15        /*!&lt; Endianess                    */
-
-/* Core Debug */
-#define CoreDebug_DEMCR_TRCENA (1 &lt;&lt; 24)      /*!&lt; DEMCR TRCENA enable          */
-#define ITM_TCR_ITMENA              1         /*!&lt; ITM enable                   */
-
-
-
-
-/* memory mapping struct for Nested Vectored Interrupt Controller (NVIC) */
+/** @addtogroup CMSIS_CM3_NVIC CMSIS CM3 NVIC
+  memory mapped structure for Nested Vectored Interrupt Controller (NVIC)
+  @{
+ */
 typedef struct
 {
-  __IO uint32_t ISER[8];                      /*!&lt; Interrupt Set Enable Register            */
+  __IO uint32_t ISER[8];                      /*!&lt; Offset: 0x000  Interrupt Set Enable Register           */
        uint32_t RESERVED0[24];
-  __IO uint32_t ICER[8];                      /*!&lt; Interrupt Clear Enable Register          */
+  __IO uint32_t ICER[8];                      /*!&lt; Offset: 0x080  Interrupt Clear Enable Register         */
        uint32_t RSERVED1[24];
-  __IO uint32_t ISPR[8];                      /*!&lt; Interrupt Set Pending Register           */
+  __IO uint32_t ISPR[8];                      /*!&lt; Offset: 0x100  Interrupt Set Pending Register          */
        uint32_t RESERVED2[24];
-  __IO uint32_t ICPR[8];                      /*!&lt; Interrupt Clear Pending Register         */
+  __IO uint32_t ICPR[8];                      /*!&lt; Offset: 0x180  Interrupt Clear Pending Register        */
        uint32_t RESERVED3[24];
-  __IO uint32_t IABR[8];                      /*!&lt; Interrupt Active bit Register            */
+  __IO uint32_t IABR[8];                      /*!&lt; Offset: 0x200  Interrupt Active bit Register           */
        uint32_t RESERVED4[56];
-  __IO uint8_t  IP[240];                      /*!&lt; Interrupt Priority Register, 8Bit wide   */
+  __IO uint8_t  IP[240];                      /*!&lt; Offset: 0x300  Interrupt Priority Register (8Bit wide) */
        uint32_t RESERVED5[644];
-  __O  uint32_t STIR;                         /*!&lt; Software Trigger Interrupt Register      */
+  __O  uint32_t STIR;                         /*!&lt; Offset: 0xE00  Software Trigger Interrupt Register     */
 }  NVIC_Type;
+/*@}*/ /* end of group CMSIS_CM3_NVIC */
 
 
-/* memory mapping struct for System Control Block */
+/** @addtogroup CMSIS_CM3_SCB CMSIS CM3 SCB
+  memory mapped structure for System Control Block (SCB)
+  @{
+ */
 typedef struct
 {
-  __I  uint32_t CPUID;                        /*!&lt; CPU ID Base Register                                     */
-  __IO uint32_t ICSR;                         /*!&lt; Interrupt Control State Register                         */
-  __IO uint32_t VTOR;                         /*!&lt; Vector Table Offset Register                             */
-  __IO uint32_t AIRCR;                        /*!&lt; Application Interrupt / Reset Control Register           */
-  __IO uint32_t SCR;                          /*!&lt; System Control Register                                  */
-  __IO uint32_t CCR;                          /*!&lt; Configuration Control Register                           */
-  __IO uint8_t  SHP[12];                      /*!&lt; System Handlers Priority Registers (4-7, 8-11, 12-15)    */
-  __IO uint32_t SHCSR;                        /*!&lt; System Handler Control and State Register                */
-  __IO uint32_t CFSR;                         /*!&lt; Configurable Fault Status Register                       */
-  __IO uint32_t HFSR;                         /*!&lt; Hard Fault Status Register                               */
-  __IO uint32_t DFSR;                         /*!&lt; Debug Fault Status Register                              */
-  __IO uint32_t MMFAR;                        /*!&lt; Mem Manage Address Register                              */
-  __IO uint32_t BFAR;                         /*!&lt; Bus Fault Address Register                               */
-  __IO uint32_t AFSR;                         /*!&lt; Auxiliary Fault Status Register                          */
-  __I  uint32_t PFR[2];                       /*!&lt; Processor Feature Register                               */
-  __I  uint32_t DFR;                          /*!&lt; Debug Feature Register                                   */
-  __I  uint32_t ADR;                          /*!&lt; Auxiliary Feature Register                               */
-  __I  uint32_t MMFR[4];                      /*!&lt; Memory Model Feature Register                            */
-  __I  uint32_t ISAR[5];                      /*!&lt; ISA Feature Register                                     */
+  __I  uint32_t CPUID;                        /*!&lt; Offset: 0x00  CPU ID Base Register                                  */
+  __IO uint32_t ICSR;                         /*!&lt; Offset: 0x04  Interrupt Control State Register                      */
+  __IO uint32_t VTOR;                         /*!&lt; Offset: 0x08  Vector Table Offset Register                          */
+  __IO uint32_t AIRCR;                        /*!&lt; Offset: 0x0C  Application Interrupt / Reset Control Register        */
+  __IO uint32_t SCR;                          /*!&lt; Offset: 0x10  System Control Register                               */
+  __IO uint32_t CCR;                          /*!&lt; Offset: 0x14  Configuration Control Register                        */
+  __IO uint8_t  SHP[12];                      /*!&lt; Offset: 0x18  System Handlers Priority Registers (4-7, 8-11, 12-15) */
+  __IO uint32_t SHCSR;                        /*!&lt; Offset: 0x24  System Handler Control and State Register             */
+  __IO uint32_t CFSR;                         /*!&lt; Offset: 0x28  Configurable Fault Status Register                    */
+  __IO uint32_t HFSR;                         /*!&lt; Offset: 0x2C  Hard Fault Status Register                            */
+  __IO uint32_t DFSR;                         /*!&lt; Offset: 0x30  Debug Fault Status Register                           */
+  __IO uint32_t MMFAR;                        /*!&lt; Offset: 0x34  Mem Manage Address Register                           */
+  __IO uint32_t BFAR;                         /*!&lt; Offset: 0x38  Bus Fault Address Register                            */
+  __IO uint32_t AFSR;                         /*!&lt; Offset: 0x3C  Auxiliary Fault Status Register                       */
+  __I  uint32_t PFR[2];                       /*!&lt; Offset: 0x40  Processor Feature Register                            */
+  __I  uint32_t DFR;                          /*!&lt; Offset: 0x48  Debug Feature Register                                */
+  __I  uint32_t ADR;                          /*!&lt; Offset: 0x4C  Auxiliary Feature Register                            */
+  __I  uint32_t MMFR[4];                      /*!&lt; Offset: 0x50  Memory Model Feature Register                         */
+  __I  uint32_t ISAR[5];                      /*!&lt; Offset: 0x60  ISA Feature Register                                  */
 } SCB_Type;
 
+/* SCB CPUID Register Definitions */
+#define SCB_CPUID_IMPLEMENTER_Pos          24                                             /*!&lt; SCB CPUID: IMPLEMENTER Position */
+#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFul &lt;&lt; SCB_CPUID_IMPLEMENTER_Pos)          /*!&lt; SCB CPUID: IMPLEMENTER Mask */
 
-/* memory mapping struct for SysTick */
+#define SCB_CPUID_VARIANT_Pos              20                                             /*!&lt; SCB CPUID: VARIANT Position */
+#define SCB_CPUID_VARIANT_Msk              (0xFul &lt;&lt; SCB_CPUID_VARIANT_Pos)               /*!&lt; SCB CPUID: VARIANT Mask */
+
+#define SCB_CPUID_PARTNO_Pos                4                                             /*!&lt; SCB CPUID: PARTNO Position */
+#define SCB_CPUID_PARTNO_Msk               (0xFFFul &lt;&lt; SCB_CPUID_PARTNO_Pos)              /*!&lt; SCB CPUID: PARTNO Mask */
+
+#define SCB_CPUID_REVISION_Pos              0                                             /*!&lt; SCB CPUID: REVISION Position */
+#define SCB_CPUID_REVISION_Msk             (0xFul &lt;&lt; SCB_CPUID_REVISION_Pos)              /*!&lt; SCB CPUID: REVISION Mask */
+
+/* SCB Interrupt Control State Register Definitions */
+#define SCB_ICSR_NMIPENDSET_Pos            31                                             /*!&lt; SCB ICSR: NMIPENDSET Position */
+#define SCB_ICSR_NMIPENDSET_Msk            (1ul &lt;&lt; SCB_ICSR_NMIPENDSET_Pos)               /*!&lt; SCB ICSR: NMIPENDSET Mask */
+
+#define SCB_ICSR_PENDSVSET_Pos             28                                             /*!&lt; SCB ICSR: PENDSVSET Position */
+#define SCB_ICSR_PENDSVSET_Msk             (1ul &lt;&lt; SCB_ICSR_PENDSVSET_Pos)                /*!&lt; SCB ICSR: PENDSVSET Mask */
+
+#define SCB_ICSR_PENDSVCLR_Pos             27                                             /*!&lt; SCB ICSR: PENDSVCLR Position */
+#define SCB_ICSR_PENDSVCLR_Msk             (1ul &lt;&lt; SCB_ICSR_PENDSVCLR_Pos)                /*!&lt; SCB ICSR: PENDSVCLR Mask */
+
+#define SCB_ICSR_PENDSTSET_Pos             26                                             /*!&lt; SCB ICSR: PENDSTSET Position */
+#define SCB_ICSR_PENDSTSET_Msk             (1ul &lt;&lt; SCB_ICSR_PENDSTSET_Pos)                /*!&lt; SCB ICSR: PENDSTSET Mask */
+
+#define SCB_ICSR_PENDSTCLR_Pos             25                                             /*!&lt; SCB ICSR: PENDSTCLR Position */
+#define SCB_ICSR_PENDSTCLR_Msk             (1ul &lt;&lt; SCB_ICSR_PENDSTCLR_Pos)                /*!&lt; SCB ICSR: PENDSTCLR Mask */
+
+#define SCB_ICSR_ISRPREEMPT_Pos            23                                             /*!&lt; SCB ICSR: ISRPREEMPT Position */
+#define SCB_ICSR_ISRPREEMPT_Msk            (1ul &lt;&lt; SCB_ICSR_ISRPREEMPT_Pos)               /*!&lt; SCB ICSR: ISRPREEMPT Mask */
+
+#define SCB_ICSR_ISRPENDING_Pos            22                                             /*!&lt; SCB ICSR: ISRPENDING Position */
+#define SCB_ICSR_ISRPENDING_Msk            (1ul &lt;&lt; SCB_ICSR_ISRPENDING_Pos)               /*!&lt; SCB ICSR: ISRPENDING Mask */
+
+#define SCB_ICSR_VECTPENDING_Pos           12                                             /*!&lt; SCB ICSR: VECTPENDING Position */
+#define SCB_ICSR_VECTPENDING_Msk           (0x1FFul &lt;&lt; SCB_ICSR_VECTPENDING_Pos)          /*!&lt; SCB ICSR: VECTPENDING Mask */
+
+#define SCB_ICSR_RETTOBASE_Pos             11                                             /*!&lt; SCB ICSR: RETTOBASE Position */
+#define SCB_ICSR_RETTOBASE_Msk             (1ul &lt;&lt; SCB_ICSR_RETTOBASE_Pos)                /*!&lt; SCB ICSR: RETTOBASE Mask */
+
+#define SCB_ICSR_VECTACTIVE_Pos             0                                             /*!&lt; SCB ICSR: VECTACTIVE Position */
+#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFul &lt;&lt; SCB_ICSR_VECTACTIVE_Pos)           /*!&lt; SCB ICSR: VECTACTIVE Mask */
+
+/* SCB Interrupt Control State Register Definitions */
+#define SCB_VTOR_TBLBASE_Pos               29                                             /*!&lt; SCB VTOR: TBLBASE Position */
+#define SCB_VTOR_TBLBASE_Msk               (0x1FFul &lt;&lt; SCB_VTOR_TBLBASE_Pos)              /*!&lt; SCB VTOR: TBLBASE Mask */
+
+#define SCB_VTOR_TBLOFF_Pos                 7                                             /*!&lt; SCB VTOR: TBLOFF Position */
+#define SCB_VTOR_TBLOFF_Msk                (0x3FFFFFul &lt;&lt; SCB_VTOR_TBLOFF_Pos)            /*!&lt; SCB VTOR: TBLOFF Mask */
+
+/* SCB Application Interrupt and Reset Control Register Definitions */
+#define SCB_AIRCR_VECTKEY_Pos              16                                             /*!&lt; SCB AIRCR: VECTKEY Position */
+#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFul &lt;&lt; SCB_AIRCR_VECTKEY_Pos)            /*!&lt; SCB AIRCR: VECTKEY Mask */
+
+#define SCB_AIRCR_VECTKEYSTAT_Pos          16                                             /*!&lt; SCB AIRCR: VECTKEYSTAT Position */
+#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFul &lt;&lt; SCB_AIRCR_VECTKEYSTAT_Pos)        /*!&lt; SCB AIRCR: VECTKEYSTAT Mask */
+
+#define SCB_AIRCR_ENDIANESS_Pos            15                                             /*!&lt; SCB AIRCR: ENDIANESS Position */
+#define SCB_AIRCR_ENDIANESS_Msk            (1ul &lt;&lt; SCB_AIRCR_ENDIANESS_Pos)               /*!&lt; SCB AIRCR: ENDIANESS Mask */
+
+#define SCB_AIRCR_PRIGROUP_Pos              8                                             /*!&lt; SCB AIRCR: PRIGROUP Position */
+#define SCB_AIRCR_PRIGROUP_Msk             (7ul &lt;&lt; SCB_AIRCR_PRIGROUP_Pos)                /*!&lt; SCB AIRCR: PRIGROUP Mask */
+
+#define SCB_AIRCR_SYSRESETREQ_Pos           2                                             /*!&lt; SCB AIRCR: SYSRESETREQ Position */
+#define SCB_AIRCR_SYSRESETREQ_Msk          (1ul &lt;&lt; SCB_AIRCR_SYSRESETREQ_Pos)             /*!&lt; SCB AIRCR: SYSRESETREQ Mask */
+
+#define SCB_AIRCR_VECTCLRACTIVE_Pos         1                                             /*!&lt; SCB AIRCR: VECTCLRACTIVE Position */
+#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1ul &lt;&lt; SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!&lt; SCB AIRCR: VECTCLRACTIVE Mask */
+
+#define SCB_AIRCR_VECTRESET_Pos             0                                             /*!&lt; SCB AIRCR: VECTRESET Position */
+#define SCB_AIRCR_VECTRESET_Msk            (1ul &lt;&lt; SCB_AIRCR_VECTRESET_Pos)               /*!&lt; SCB AIRCR: VECTRESET Mask */
+
+/* SCB System Control Register Definitions */
+#define SCB_SCR_SEVONPEND_Pos               4                                             /*!&lt; SCB SCR: SEVONPEND Position */
+#define SCB_SCR_SEVONPEND_Msk              (1ul &lt;&lt; SCB_SCR_SEVONPEND_Pos)                 /*!&lt; SCB SCR: SEVONPEND Mask */
+
+#define SCB_SCR_SLEEPDEEP_Pos               2                                             /*!&lt; SCB SCR: SLEEPDEEP Position */
+#define SCB_SCR_SLEEPDEEP_Msk              (1ul &lt;&lt; SCB_SCR_SLEEPDEEP_Pos)                 /*!&lt; SCB SCR: SLEEPDEEP Mask */
+
+#define SCB_SCR_SLEEPONEXIT_Pos             1                                             /*!&lt; SCB SCR: SLEEPONEXIT Position */
+#define SCB_SCR_SLEEPONEXIT_Msk            (1ul &lt;&lt; SCB_SCR_SLEEPONEXIT_Pos)               /*!&lt; SCB SCR: SLEEPONEXIT Mask */
+
+/* SCB Configuration Control Register Definitions */
+#define SCB_CCR_STKALIGN_Pos                9                                             /*!&lt; SCB CCR: STKALIGN Position */
+#define SCB_CCR_STKALIGN_Msk               (1ul &lt;&lt; SCB_CCR_STKALIGN_Pos)                  /*!&lt; SCB CCR: STKALIGN Mask */
+
+#define SCB_CCR_BFHFNMIGN_Pos               8                                             /*!&lt; SCB CCR: BFHFNMIGN Position */
+#define SCB_CCR_BFHFNMIGN_Msk              (1ul &lt;&lt; SCB_CCR_BFHFNMIGN_Pos)                 /*!&lt; SCB CCR: BFHFNMIGN Mask */
+
+#define SCB_CCR_DIV_0_TRP_Pos               4                                             /*!&lt; SCB CCR: DIV_0_TRP Position */
+#define SCB_CCR_DIV_0_TRP_Msk              (1ul &lt;&lt; SCB_CCR_DIV_0_TRP_Pos)                 /*!&lt; SCB CCR: DIV_0_TRP Mask */
+
+#define SCB_CCR_UNALIGN_TRP_Pos             3                                             /*!&lt; SCB CCR: UNALIGN_TRP Position */
+#define SCB_CCR_UNALIGN_TRP_Msk            (1ul &lt;&lt; SCB_CCR_UNALIGN_TRP_Pos)               /*!&lt; SCB CCR: UNALIGN_TRP Mask */
+
+#define SCB_CCR_USERSETMPEND_Pos            1                                             /*!&lt; SCB CCR: USERSETMPEND Position */
+#define SCB_CCR_USERSETMPEND_Msk           (1ul &lt;&lt; SCB_CCR_USERSETMPEND_Pos)              /*!&lt; SCB CCR: USERSETMPEND Mask */
+
+#define SCB_CCR_NONBASETHRDENA_Pos          0                                             /*!&lt; SCB CCR: NONBASETHRDENA Position */
+#define SCB_CCR_NONBASETHRDENA_Msk         (1ul &lt;&lt; SCB_CCR_NONBASETHRDENA_Pos)            /*!&lt; SCB CCR: NONBASETHRDENA Mask */
+
+/* SCB System Handler Control and State Register Definitions */
+#define SCB_SHCSR_USGFAULTENA_Pos          18                                             /*!&lt; SCB SHCSR: USGFAULTENA Position */
+#define SCB_SHCSR_USGFAULTENA_Msk          (1ul &lt;&lt; SCB_SHCSR_USGFAULTENA_Pos)             /*!&lt; SCB SHCSR: USGFAULTENA Mask */
+
+#define SCB_SHCSR_BUSFAULTENA_Pos          17                                             /*!&lt; SCB SHCSR: BUSFAULTENA Position */
+#define SCB_SHCSR_BUSFAULTENA_Msk          (1ul &lt;&lt; SCB_SHCSR_BUSFAULTENA_Pos)             /*!&lt; SCB SHCSR: BUSFAULTENA Mask */
+
+#define SCB_SHCSR_MEMFAULTENA_Pos          16                                             /*!&lt; SCB SHCSR: MEMFAULTENA Position */
+#define SCB_SHCSR_MEMFAULTENA_Msk          (1ul &lt;&lt; SCB_SHCSR_MEMFAULTENA_Pos)             /*!&lt; SCB SHCSR: MEMFAULTENA Mask */
+
+#define SCB_SHCSR_SVCALLPENDED_Pos         15                                             /*!&lt; SCB SHCSR: SVCALLPENDED Position */
+#define SCB_SHCSR_SVCALLPENDED_Msk         (1ul &lt;&lt; SCB_SHCSR_SVCALLPENDED_Pos)            /*!&lt; SCB SHCSR: SVCALLPENDED Mask */
+
+#define SCB_SHCSR_BUSFAULTPENDED_Pos       14                                             /*!&lt; SCB SHCSR: BUSFAULTPENDED Position */
+#define SCB_SHCSR_BUSFAULTPENDED_Msk       (1ul &lt;&lt; SCB_SHCSR_BUSFAULTPENDED_Pos)          /*!&lt; SCB SHCSR: BUSFAULTPENDED Mask */
+
+#define SCB_SHCSR_MEMFAULTPENDED_Pos       13                                             /*!&lt; SCB SHCSR: MEMFAULTPENDED Position */
+#define SCB_SHCSR_MEMFAULTPENDED_Msk       (1ul &lt;&lt; SCB_SHCSR_MEMFAULTPENDED_Pos)          /*!&lt; SCB SHCSR: MEMFAULTPENDED Mask */
+
+#define SCB_SHCSR_USGFAULTPENDED_Pos       12                                             /*!&lt; SCB SHCSR: USGFAULTPENDED Position */
+#define SCB_SHCSR_USGFAULTPENDED_Msk       (1ul &lt;&lt; SCB_SHCSR_USGFAULTPENDED_Pos)          /*!&lt; SCB SHCSR: USGFAULTPENDED Mask */
+
+#define SCB_SHCSR_SYSTICKACT_Pos           11                                             /*!&lt; SCB SHCSR: SYSTICKACT Position */
+#define SCB_SHCSR_SYSTICKACT_Msk           (1ul &lt;&lt; SCB_SHCSR_SYSTICKACT_Pos)              /*!&lt; SCB SHCSR: SYSTICKACT Mask */
+
+#define SCB_SHCSR_PENDSVACT_Pos            10                                             /*!&lt; SCB SHCSR: PENDSVACT Position */
+#define SCB_SHCSR_PENDSVACT_Msk            (1ul &lt;&lt; SCB_SHCSR_PENDSVACT_Pos)               /*!&lt; SCB SHCSR: PENDSVACT Mask */
+
+#define SCB_SHCSR_MONITORACT_Pos            8                                             /*!&lt; SCB SHCSR: MONITORACT Position */
+#define SCB_SHCSR_MONITORACT_Msk           (1ul &lt;&lt; SCB_SHCSR_MONITORACT_Pos)              /*!&lt; SCB SHCSR: MONITORACT Mask */
+
+#define SCB_SHCSR_SVCALLACT_Pos             7                                             /*!&lt; SCB SHCSR: SVCALLACT Position */
+#define SCB_SHCSR_SVCALLACT_Msk            (1ul &lt;&lt; SCB_SHCSR_SVCALLACT_Pos)               /*!&lt; SCB SHCSR: SVCALLACT Mask */
+
+#define SCB_SHCSR_USGFAULTACT_Pos           3                                             /*!&lt; SCB SHCSR: USGFAULTACT Position */
+#define SCB_SHCSR_USGFAULTACT_Msk          (1ul &lt;&lt; SCB_SHCSR_USGFAULTACT_Pos)             /*!&lt; SCB SHCSR: USGFAULTACT Mask */
+
+#define SCB_SHCSR_BUSFAULTACT_Pos           1                                             /*!&lt; SCB SHCSR: BUSFAULTACT Position */
+#define SCB_SHCSR_BUSFAULTACT_Msk          (1ul &lt;&lt; SCB_SHCSR_BUSFAULTACT_Pos)             /*!&lt; SCB SHCSR: BUSFAULTACT Mask */
+
+#define SCB_SHCSR_MEMFAULTACT_Pos           0                                             /*!&lt; SCB SHCSR: MEMFAULTACT Position */
+#define SCB_SHCSR_MEMFAULTACT_Msk          (1ul &lt;&lt; SCB_SHCSR_MEMFAULTACT_Pos)             /*!&lt; SCB SHCSR: MEMFAULTACT Mask */
+
+/* SCB Configurable Fault Status Registers Definitions */
+#define SCB_CFSR_USGFAULTSR_Pos            16                                             /*!&lt; SCB CFSR: Usage Fault Status Register Position */
+#define SCB_CFSR_USGFAULTSR_Msk            (0xFFFFul &lt;&lt; SCB_CFSR_USGFAULTSR_Pos)          /*!&lt; SCB CFSR: Usage Fault Status Register Mask */
+
+#define SCB_CFSR_BUSFAULTSR_Pos             8                                             /*!&lt; SCB CFSR: Bus Fault Status Register Position */
+#define SCB_CFSR_BUSFAULTSR_Msk            (0xFFul &lt;&lt; SCB_CFSR_BUSFAULTSR_Pos)            /*!&lt; SCB CFSR: Bus Fault Status Register Mask */
+
+#define SCB_CFSR_MEMFAULTSR_Pos             0                                             /*!&lt; SCB CFSR: Memory Manage Fault Status Register Position */
+#define SCB_CFSR_MEMFAULTSR_Msk            (0xFFul &lt;&lt; SCB_CFSR_MEMFAULTSR_Pos)            /*!&lt; SCB CFSR: Memory Manage Fault Status Register Mask */
+
+/* SCB Hard Fault Status Registers Definitions */
+#define SCB_HFSR_DEBUGEVT_Pos              31                                             /*!&lt; SCB HFSR: DEBUGEVT Position */
+#define SCB_HFSR_DEBUGEVT_Msk              (1ul &lt;&lt; SCB_HFSR_DEBUGEVT_Pos)                 /*!&lt; SCB HFSR: DEBUGEVT Mask */
+
+#define SCB_HFSR_FORCED_Pos                30                                             /*!&lt; SCB HFSR: FORCED Position */
+#define SCB_HFSR_FORCED_Msk                (1ul &lt;&lt; SCB_HFSR_FORCED_Pos)                   /*!&lt; SCB HFSR: FORCED Mask */
+
+#define SCB_HFSR_VECTTBL_Pos                1                                             /*!&lt; SCB HFSR: VECTTBL Position */
+#define SCB_HFSR_VECTTBL_Msk               (1ul &lt;&lt; SCB_HFSR_VECTTBL_Pos)                  /*!&lt; SCB HFSR: VECTTBL Mask */
+
+/* SCB Debug Fault Status Register Definitions */
+#define SCB_DFSR_EXTERNAL_Pos               4                                             /*!&lt; SCB DFSR: EXTERNAL Position */
+#define SCB_DFSR_EXTERNAL_Msk              (1ul &lt;&lt; SCB_DFSR_EXTERNAL_Pos)                 /*!&lt; SCB DFSR: EXTERNAL Mask */
+
+#define SCB_DFSR_VCATCH_Pos                 3                                             /*!&lt; SCB DFSR: VCATCH Position */
+#define SCB_DFSR_VCATCH_Msk                (1ul &lt;&lt; SCB_DFSR_VCATCH_Pos)                   /*!&lt; SCB DFSR: VCATCH Mask */
+
+#define SCB_DFSR_DWTTRAP_Pos                2                                             /*!&lt; SCB DFSR: DWTTRAP Position */
+#define SCB_DFSR_DWTTRAP_Msk               (1ul &lt;&lt; SCB_DFSR_DWTTRAP_Pos)                  /*!&lt; SCB DFSR: DWTTRAP Mask */
+
+#define SCB_DFSR_BKPT_Pos                   1                                             /*!&lt; SCB DFSR: BKPT Position */
+#define SCB_DFSR_BKPT_Msk                  (1ul &lt;&lt; SCB_DFSR_BKPT_Pos)                     /*!&lt; SCB DFSR: BKPT Mask */
+
+#define SCB_DFSR_HALTED_Pos                 0                                             /*!&lt; SCB DFSR: HALTED Position */
+#define SCB_DFSR_HALTED_Msk                (1ul &lt;&lt; SCB_DFSR_HALTED_Pos)                   /*!&lt; SCB DFSR: HALTED Mask */
+/*@}*/ /* end of group CMSIS_CM3_SCB */
+
+
+/** @addtogroup CMSIS_CM3_SysTick CMSIS CM3 SysTick
+  memory mapped structure for SysTick
+  @{
+ */
 typedef struct
 {
-  __IO uint32_t CTRL;                         /*!&lt; SysTick Control and Status Register */
-  __IO uint32_t LOAD;                         /*!&lt; SysTick Reload Value Register       */
-  __IO uint32_t VAL;                          /*!&lt; SysTick Current Value Register      */
-  __I  uint32_t CALIB;                        /*!&lt; SysTick Calibration Register        */
+  __IO uint32_t CTRL;                         /*!&lt; Offset: 0x00  SysTick Control and Status Register */
+  __IO uint32_t LOAD;                         /*!&lt; Offset: 0x04  SysTick Reload Value Register       */
+  __IO uint32_t VAL;                          /*!&lt; Offset: 0x08  SysTick Current Value Register      */
+  __I  uint32_t CALIB;                        /*!&lt; Offset: 0x0C  SysTick Calibration Register        */
 } SysTick_Type;
 
+/* SysTick Control / Status Register Definitions */
+#define SysTick_CTRL_COUNTFLAG_Pos         16                                             /*!&lt; SysTick CTRL: COUNTFLAG Position */
+#define SysTick_CTRL_COUNTFLAG_Msk         (1ul &lt;&lt; SysTick_CTRL_COUNTFLAG_Pos)            /*!&lt; SysTick CTRL: COUNTFLAG Mask */
 
-/* memory mapping structur for ITM */
+#define SysTick_CTRL_CLKSOURCE_Pos          2                                             /*!&lt; SysTick CTRL: CLKSOURCE Position */
+#define SysTick_CTRL_CLKSOURCE_Msk         (1ul &lt;&lt; SysTick_CTRL_CLKSOURCE_Pos)            /*!&lt; SysTick CTRL: CLKSOURCE Mask */
+
+#define SysTick_CTRL_TICKINT_Pos            1                                             /*!&lt; SysTick CTRL: TICKINT Position */
+#define SysTick_CTRL_TICKINT_Msk           (1ul &lt;&lt; SysTick_CTRL_TICKINT_Pos)              /*!&lt; SysTick CTRL: TICKINT Mask */
+
+#define SysTick_CTRL_ENABLE_Pos             0                                             /*!&lt; SysTick CTRL: ENABLE Position */
+#define SysTick_CTRL_ENABLE_Msk            (1ul &lt;&lt; SysTick_CTRL_ENABLE_Pos)               /*!&lt; SysTick CTRL: ENABLE Mask */
+
+/* SysTick Reload Register Definitions */
+#define SysTick_LOAD_RELOAD_Pos             0                                             /*!&lt; SysTick LOAD: RELOAD Position */
+#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFul &lt;&lt; SysTick_LOAD_RELOAD_Pos)        /*!&lt; SysTick LOAD: RELOAD Mask */
+
+/* SysTick Current Register Definitions */
+#define SysTick_VAL_CURRENT_Pos             0                                             /*!&lt; SysTick VAL: CURRENT Position */
+#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFul &lt;&lt; SysTick_VAL_CURRENT_Pos)        /*!&lt; SysTick VAL: CURRENT Mask */
+
+/* SysTick Calibration Register Definitions */
+#define SysTick_CALIB_NOREF_Pos            31                                             /*!&lt; SysTick CALIB: NOREF Position */
+#define SysTick_CALIB_NOREF_Msk            (1ul &lt;&lt; SysTick_CALIB_NOREF_Pos)               /*!&lt; SysTick CALIB: NOREF Mask */
+
+#define SysTick_CALIB_SKEW_Pos             30                                             /*!&lt; SysTick CALIB: SKEW Position */
+#define SysTick_CALIB_SKEW_Msk             (1ul &lt;&lt; SysTick_CALIB_SKEW_Pos)                /*!&lt; SysTick CALIB: SKEW Mask */
+
+#define SysTick_CALIB_TENMS_Pos             0                                             /*!&lt; SysTick CALIB: TENMS Position */
+#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFul &lt;&lt; SysTick_VAL_CURRENT_Pos)        /*!&lt; SysTick CALIB: TENMS Mask */
+/*@}*/ /* end of group CMSIS_CM3_SysTick */
+
+
+/** @addtogroup CMSIS_CM3_ITM CMSIS CM3 ITM
+  memory mapped structure for Instrumentation Trace Macrocell (ITM)
+  @{
+ */
 typedef struct
 {
   __O  union
   {
-    __O  uint8_t    u8;                       /*!&lt; ITM Stimulus Port 8-bit               */
-    __O  uint16_t   u16;                      /*!&lt; ITM Stimulus Port 16-bit              */
-    __O  uint32_t   u32;                      /*!&lt; ITM Stimulus Port 32-bit              */
-  }  PORT [32];                               /*!&lt; ITM Stimulus Port Registers           */
+    __O  uint8_t    u8;                       /*!&lt; Offset:       ITM Stimulus Port 8-bit                   */
+    __O  uint16_t   u16;                      /*!&lt; Offset:       ITM Stimulus Port 16-bit                  */
+    __O  uint32_t   u32;                      /*!&lt; Offset:       ITM Stimulus Port 32-bit                  */
+  }  PORT [32];                               /*!&lt; Offset: 0x00  ITM Stimulus Port Registers               */
        uint32_t RESERVED0[864];
-  __IO uint32_t TER;                          /*!&lt; ITM Trace Enable Register             */
+  __IO uint32_t TER;                          /*!&lt; Offset:       ITM Trace Enable Register                 */
        uint32_t RESERVED1[15];
-  __IO uint32_t TPR;                          /*!&lt; ITM Trace Privilege Register          */
+  __IO uint32_t TPR;                          /*!&lt; Offset:       ITM Trace Privilege Register              */
        uint32_t RESERVED2[15];
-  __IO uint32_t TCR;                          /*!&lt; ITM Trace Control Register            */
+  __IO uint32_t TCR;                          /*!&lt; Offset:       ITM Trace Control Register                */
        uint32_t RESERVED3[29];
-  __IO uint32_t IWR;                          /*!&lt; ITM Integration Write Register        */
-  __IO uint32_t IRR;                          /*!&lt; ITM Integration Read Register         */
-  __IO uint32_t IMCR;                         /*!&lt; ITM Integration Mode Control Register */
+  __IO uint32_t IWR;                          /*!&lt; Offset:       ITM Integration Write Register            */
+  __IO uint32_t IRR;                          /*!&lt; Offset:       ITM Integration Read Register             */
+  __IO uint32_t IMCR;                         /*!&lt; Offset:       ITM Integration Mode Control Register     */
        uint32_t RESERVED4[43];
-  __IO uint32_t LAR;                          /*!&lt; ITM Lock Access Register              */
-  __IO uint32_t LSR;                          /*!&lt; ITM Lock Status Register              */
+  __IO uint32_t LAR;                          /*!&lt; Offset:       ITM Lock Access Register                  */
+  __IO uint32_t LSR;                          /*!&lt; Offset:       ITM Lock Status Register                  */
        uint32_t RESERVED5[6];
-  __I  uint32_t PID4;                         /*!&lt; ITM Product ID Registers              */
-  __I  uint32_t PID5;
-  __I  uint32_t PID6;
-  __I  uint32_t PID7;
-  __I  uint32_t PID0;
-  __I  uint32_t PID1;
-  __I  uint32_t PID2;
-  __I  uint32_t PID3;
-  __I  uint32_t CID0;
-  __I  uint32_t CID1;
-  __I  uint32_t CID2;
-  __I  uint32_t CID3;
+  __I  uint32_t PID4;                         /*!&lt; Offset:       ITM Peripheral Identification Register #4 */
+  __I  uint32_t PID5;                         /*!&lt; Offset:       ITM Peripheral Identification Register #5 */
+  __I  uint32_t PID6;                         /*!&lt; Offset:       ITM Peripheral Identification Register #6 */
+  __I  uint32_t PID7;                         /*!&lt; Offset:       ITM Peripheral Identification Register #7 */
+  __I  uint32_t PID0;                         /*!&lt; Offset:       ITM Peripheral Identification Register #0 */
+  __I  uint32_t PID1;                         /*!&lt; Offset:       ITM Peripheral Identification Register #1 */
+  __I  uint32_t PID2;                         /*!&lt; Offset:       ITM Peripheral Identification Register #2 */
+  __I  uint32_t PID3;                         /*!&lt; Offset:       ITM Peripheral Identification Register #3 */
+  __I  uint32_t CID0;                         /*!&lt; Offset:       ITM Component  Identification Register #0 */
+  __I  uint32_t CID1;                         /*!&lt; Offset:       ITM Component  Identification Register #1 */
+  __I  uint32_t CID2;                         /*!&lt; Offset:       ITM Component  Identification Register #2 */
+  __I  uint32_t CID3;                         /*!&lt; Offset:       ITM Component  Identification Register #3 */
 } ITM_Type;
 
+/* ITM Trace Privilege Register Definitions */
+#define ITM_TPR_PRIVMASK_Pos                0                                             /*!&lt; ITM TPR: PRIVMASK Position */
+#define ITM_TPR_PRIVMASK_Msk               (0xFul &lt;&lt; ITM_TPR_PRIVMASK_Pos)                /*!&lt; ITM TPR: PRIVMASK Mask */
 
-/* memory mapped struct for Interrupt Type */
+/* ITM Trace Control Register Definitions */
+#define ITM_TCR_BUSY_Pos                   23                                             /*!&lt; ITM TCR: BUSY Position */
+#define ITM_TCR_BUSY_Msk                   (1ul &lt;&lt; ITM_TCR_BUSY_Pos)                      /*!&lt; ITM TCR: BUSY Mask */
+
+#define ITM_TCR_ATBID_Pos                  16                                             /*!&lt; ITM TCR: ATBID Position */
+#define ITM_TCR_ATBID_Msk                  (0x7Ful &lt;&lt; ITM_TCR_ATBID_Pos)                  /*!&lt; ITM TCR: ATBID Mask */
+
+#define ITM_TCR_TSPrescale_Pos              8                                             /*!&lt; ITM TCR: TSPrescale Position */
+#define ITM_TCR_TSPrescale_Msk             (3ul &lt;&lt; ITM_TCR_TSPrescale_Pos)                /*!&lt; ITM TCR: TSPrescale Mask */
+
+#define ITM_TCR_SWOENA_Pos                  4                                             /*!&lt; ITM TCR: SWOENA Position */
+#define ITM_TCR_SWOENA_Msk                 (1ul &lt;&lt; ITM_TCR_SWOENA_Pos)                    /*!&lt; ITM TCR: SWOENA Mask */
+
+#define ITM_TCR_DWTENA_Pos                  3                                             /*!&lt; ITM TCR: DWTENA Position */
+#define ITM_TCR_DWTENA_Msk                 (1ul &lt;&lt; ITM_TCR_DWTENA_Pos)                    /*!&lt; ITM TCR: DWTENA Mask */
+
+#define ITM_TCR_SYNCENA_Pos                 2                                             /*!&lt; ITM TCR: SYNCENA Position */
+#define ITM_TCR_SYNCENA_Msk                (1ul &lt;&lt; ITM_TCR_SYNCENA_Pos)                   /*!&lt; ITM TCR: SYNCENA Mask */
+
+#define ITM_TCR_TSENA_Pos                   1                                             /*!&lt; ITM TCR: TSENA Position */
+#define ITM_TCR_TSENA_Msk                  (1ul &lt;&lt; ITM_TCR_TSENA_Pos)                     /*!&lt; ITM TCR: TSENA Mask */
+
+#define ITM_TCR_ITMENA_Pos                  0                                             /*!&lt; ITM TCR: ITM Enable bit Position */
+#define ITM_TCR_ITMENA_Msk                 (1ul &lt;&lt; ITM_TCR_ITMENA_Pos)                    /*!&lt; ITM TCR: ITM Enable bit Mask */
+
+/* ITM Integration Write Register Definitions */
+#define ITM_IWR_ATVALIDM_Pos                0                                             /*!&lt; ITM IWR: ATVALIDM Position */
+#define ITM_IWR_ATVALIDM_Msk               (1ul &lt;&lt; ITM_IWR_ATVALIDM_Pos)                  /*!&lt; ITM IWR: ATVALIDM Mask */
+
+/* ITM Integration Read Register Definitions */
+#define ITM_IRR_ATREADYM_Pos                0                                             /*!&lt; ITM IRR: ATREADYM Position */
+#define ITM_IRR_ATREADYM_Msk               (1ul &lt;&lt; ITM_IRR_ATREADYM_Pos)                  /*!&lt; ITM IRR: ATREADYM Mask */
+
+/* ITM Integration Mode Control Register Definitions */
+#define ITM_IMCR_INTEGRATION_Pos            0                                             /*!&lt; ITM IMCR: INTEGRATION Position */
+#define ITM_IMCR_INTEGRATION_Msk           (1ul &lt;&lt; ITM_IMCR_INTEGRATION_Pos)              /*!&lt; ITM IMCR: INTEGRATION Mask */
+
+/* ITM Lock Status Register Definitions */
+#define ITM_LSR_ByteAcc_Pos                 2                                             /*!&lt; ITM LSR: ByteAcc Position */
+#define ITM_LSR_ByteAcc_Msk                (1ul &lt;&lt; ITM_LSR_ByteAcc_Pos)                   /*!&lt; ITM LSR: ByteAcc Mask */
+
+#define ITM_LSR_Access_Pos                  1                                             /*!&lt; ITM LSR: Access Position */
+#define ITM_LSR_Access_Msk                 (1ul &lt;&lt; ITM_LSR_Access_Pos)                    /*!&lt; ITM LSR: Access Mask */
+
+#define ITM_LSR_Present_Pos                 0                                             /*!&lt; ITM LSR: Present Position */
+#define ITM_LSR_Present_Msk                (1ul &lt;&lt; ITM_LSR_Present_Pos)                   /*!&lt; ITM LSR: Present Mask */
+/*@}*/ /* end of group CMSIS_CM3_ITM */
+
+
+/** @addtogroup CMSIS_CM3_InterruptType CMSIS CM3 Interrupt Type
+  memory mapped structure for Interrupt Type
+  @{
+ */
 typedef struct
 {
        uint32_t RESERVED0;
-  __I  uint32_t ICTR;                         /*!&lt; Interrupt Control Type Register  */
+  __I  uint32_t ICTR;                         /*!&lt; Offset: 0x04  Interrupt Control Type Register */
 #if ((defined __CM3_REV) &amp;&amp; (__CM3_REV &gt;= 0x200))
-  __IO uint32_t ACTLR;                        /*!&lt; Auxiliary Control Register       */
+  __IO uint32_t ACTLR;                        /*!&lt; Offset: 0x08  Auxiliary Control Register      */
 #else
        uint32_t RESERVED1;
 #endif
 } InterruptType_Type;
 
+/* Interrupt Controller Type Register Definitions */
+#define InterruptType_ICTR_INTLINESNUM_Pos  0                                             /*!&lt; InterruptType ICTR: INTLINESNUM Position */
+#define InterruptType_ICTR_INTLINESNUM_Msk (0x1Ful &lt;&lt; InterruptType_ICTR_INTLINESNUM_Pos) /*!&lt; InterruptType ICTR: INTLINESNUM Mask */
 
-/* Memory Protection Unit */
+/* Auxiliary Control Register Definitions */
+#define InterruptType_ACTLR_DISFOLD_Pos     2                                             /*!&lt; InterruptType ACTLR: DISFOLD Position */
+#define InterruptType_ACTLR_DISFOLD_Msk    (1ul &lt;&lt; InterruptType_ACTLR_DISFOLD_Pos)       /*!&lt; InterruptType ACTLR: DISFOLD Mask */
+
+#define InterruptType_ACTLR_DISDEFWBUF_Pos  1                                             /*!&lt; InterruptType ACTLR: DISDEFWBUF Position */
+#define InterruptType_ACTLR_DISDEFWBUF_Msk (1ul &lt;&lt; InterruptType_ACTLR_DISDEFWBUF_Pos)    /*!&lt; InterruptType ACTLR: DISDEFWBUF Mask */
+
+#define InterruptType_ACTLR_DISMCYCINT_Pos  0                                             /*!&lt; InterruptType ACTLR: DISMCYCINT Position */
+#define InterruptType_ACTLR_DISMCYCINT_Msk (1ul &lt;&lt; InterruptType_ACTLR_DISMCYCINT_Pos)    /*!&lt; InterruptType ACTLR: DISMCYCINT Mask */
+/*@}*/ /* end of group CMSIS_CM3_InterruptType */
+
+
 #if defined (__MPU_PRESENT) &amp;&amp; (__MPU_PRESENT == 1)
+/** @addtogroup CMSIS_CM3_MPU CMSIS CM3 MPU
+  memory mapped structure for Memory Protection Unit (MPU)
+  @{
+ */
 typedef struct
 {
-  __I  uint32_t TYPE;                         /*!&lt; MPU Type Register                               */
-  __IO uint32_t CTRL;                         /*!&lt; MPU Control Register                            */
-  __IO uint32_t RNR;                          /*!&lt; MPU Region RNRber Register                      */
-  __IO uint32_t RBAR;                         /*!&lt; MPU Region Base Address Register                */
-  __IO uint32_t RASR;                         /*!&lt; MPU Region Attribute and Size Register          */
-  __IO uint32_t RBAR_A1;                      /*!&lt; MPU Alias 1 Region Base Address Register        */
-  __IO uint32_t RASR_A1;                      /*!&lt; MPU Alias 1 Region Attribute and Size Register  */
-  __IO uint32_t RBAR_A2;                      /*!&lt; MPU Alias 2 Region Base Address Register        */
-  __IO uint32_t RASR_A2;                      /*!&lt; MPU Alias 2 Region Attribute and Size Register  */
-  __IO uint32_t RBAR_A3;                      /*!&lt; MPU Alias 3 Region Base Address Register        */
-  __IO uint32_t RASR_A3;                      /*!&lt; MPU Alias 3 Region Attribute and Size Register  */
+  __I  uint32_t TYPE;                         /*!&lt; Offset: 0x00  MPU Type Register                              */
+  __IO uint32_t CTRL;                         /*!&lt; Offset: 0x04  MPU Control Register                           */
+  __IO uint32_t RNR;                          /*!&lt; Offset: 0x08  MPU Region RNRber Register                     */
+  __IO uint32_t RBAR;                         /*!&lt; Offset: 0x0C  MPU Region Base Address Register               */
+  __IO uint32_t RASR;                         /*!&lt; Offset: 0x10  MPU Region Attribute and Size Register         */
+  __IO uint32_t RBAR_A1;                      /*!&lt; Offset: 0x14  MPU Alias 1 Region Base Address Register       */
+  __IO uint32_t RASR_A1;                      /*!&lt; Offset: 0x18  MPU Alias 1 Region Attribute and Size Register */
+  __IO uint32_t RBAR_A2;                      /*!&lt; Offset: 0x1C  MPU Alias 2 Region Base Address Register       */
+  __IO uint32_t RASR_A2;                      /*!&lt; Offset: 0x20  MPU Alias 2 Region Attribute and Size Register */
+  __IO uint32_t RBAR_A3;                      /*!&lt; Offset: 0x24  MPU Alias 3 Region Base Address Register       */
+  __IO uint32_t RASR_A3;                      /*!&lt; Offset: 0x28  MPU Alias 3 Region Attribute and Size Register */
 } MPU_Type;
+
+/* MPU Type Register */
+#define MPU_TYPE_IREGION_Pos               16                                             /*!&lt; MPU TYPE: IREGION Position */
+#define MPU_TYPE_IREGION_Msk               (0xFFul &lt;&lt; MPU_TYPE_IREGION_Pos)               /*!&lt; MPU TYPE: IREGION Mask */
+
+#define MPU_TYPE_DREGION_Pos                8                                             /*!&lt; MPU TYPE: DREGION Position */
+#define MPU_TYPE_DREGION_Msk               (0xFFul &lt;&lt; MPU_TYPE_DREGION_Pos)               /*!&lt; MPU TYPE: DREGION Mask */
+
+#define MPU_TYPE_SEPARATE_Pos               0                                             /*!&lt; MPU TYPE: SEPARATE Position */
+#define MPU_TYPE_SEPARATE_Msk              (1ul &lt;&lt; MPU_TYPE_SEPARATE_Pos)                 /*!&lt; MPU TYPE: SEPARATE Mask */
+
+/* MPU Control Register */
+#define MPU_CTRL_PRIVDEFENA_Pos             2                                             /*!&lt; MPU CTRL: PRIVDEFENA Position */
+#define MPU_CTRL_PRIVDEFENA_Msk            (1ul &lt;&lt; MPU_CTRL_PRIVDEFENA_Pos)               /*!&lt; MPU CTRL: PRIVDEFENA Mask */
+
+#define MPU_CTRL_HFNMIENA_Pos               1                                             /*!&lt; MPU CTRL: HFNMIENA Position */
+#define MPU_CTRL_HFNMIENA_Msk              (1ul &lt;&lt; MPU_CTRL_HFNMIENA_Pos)                 /*!&lt; MPU CTRL: HFNMIENA Mask */
+
+#define MPU_CTRL_ENABLE_Pos                 0                                             /*!&lt; MPU CTRL: ENABLE Position */
+#define MPU_CTRL_ENABLE_Msk                (1ul &lt;&lt; MPU_CTRL_ENABLE_Pos)                   /*!&lt; MPU CTRL: ENABLE Mask */
+
+/* MPU Region Number Register */
+#define MPU_RNR_REGION_Pos                  0                                             /*!&lt; MPU RNR: REGION Position */
+#define MPU_RNR_REGION_Msk                 (0xFFul &lt;&lt; MPU_RNR_REGION_Pos)                 /*!&lt; MPU RNR: REGION Mask */
+
+/* MPU Region Base Address Register */
+#define MPU_RBAR_ADDR_Pos                   5                                             /*!&lt; MPU RBAR: ADDR Position */
+#define MPU_RBAR_ADDR_Msk                  (0x7FFFFFFul &lt;&lt; MPU_RBAR_ADDR_Pos)             /*!&lt; MPU RBAR: ADDR Mask */
+
+#define MPU_RBAR_VALID_Pos                  4                                             /*!&lt; MPU RBAR: VALID Position */
+#define MPU_RBAR_VALID_Msk                 (1ul &lt;&lt; MPU_RBAR_VALID_Pos)                    /*!&lt; MPU RBAR: VALID Mask */
+
+#define MPU_RBAR_REGION_Pos                 0                                             /*!&lt; MPU RBAR: REGION Position */
+#define MPU_RBAR_REGION_Msk                (0xFul &lt;&lt; MPU_RBAR_REGION_Pos)                 /*!&lt; MPU RBAR: REGION Mask */
+
+/* MPU Region Attribute and Size Register */
+#define MPU_RASR_XN_Pos                    28                                             /*!&lt; MPU RASR: XN Position */
+#define MPU_RASR_XN_Msk                    (1ul &lt;&lt; MPU_RASR_XN_Pos)                       /*!&lt; MPU RASR: XN Mask */
+
+#define MPU_RASR_AP_Pos                    24                                             /*!&lt; MPU RASR: AP Position */
+#define MPU_RASR_AP_Msk                    (7ul &lt;&lt; MPU_RASR_AP_Pos)                       /*!&lt; MPU RASR: AP Mask */
+
+#define MPU_RASR_TEX_Pos                   19                                             /*!&lt; MPU RASR: TEX Position */
+#define MPU_RASR_TEX_Msk                   (7ul &lt;&lt; MPU_RASR_TEX_Pos)                      /*!&lt; MPU RASR: TEX Mask */
+
+#define MPU_RASR_S_Pos                     18                                             /*!&lt; MPU RASR: Shareable bit Position */
+#define MPU_RASR_S_Msk                     (1ul &lt;&lt; MPU_RASR_S_Pos)                        /*!&lt; MPU RASR: Shareable bit Mask */
+
+#define MPU_RASR_C_Pos                     17                                             /*!&lt; MPU RASR: Cacheable bit Position */
+#define MPU_RASR_C_Msk                     (1ul &lt;&lt; MPU_RASR_C_Pos)                        /*!&lt; MPU RASR: Cacheable bit Mask */
+
+#define MPU_RASR_B_Pos                     16                                             /*!&lt; MPU RASR: Bufferable bit Position */
+#define MPU_RASR_B_Msk                     (1ul &lt;&lt; MPU_RASR_B_Pos)                        /*!&lt; MPU RASR: Bufferable bit Mask */
+
+#define MPU_RASR_SRD_Pos                    8                                             /*!&lt; MPU RASR: Sub-Region Disable Position */
+#define MPU_RASR_SRD_Msk                   (0xFFul &lt;&lt; MPU_RASR_SRD_Pos)                   /*!&lt; MPU RASR: Sub-Region Disable Mask */
+
+#define MPU_RASR_SIZE_Pos                   1                                             /*!&lt; MPU RASR: Region Size Field Position */
+#define MPU_RASR_SIZE_Msk                  (0x1Ful &lt;&lt; MPU_RASR_SIZE_Pos)                  /*!&lt; MPU RASR: Region Size Field Mask */
+
+#define MPU_RASR_ENA_Pos                     0                                            /*!&lt; MPU RASR: Region enable bit Position */
+#define MPU_RASR_ENA_Msk                    (0x1Ful &lt;&lt; MPU_RASR_ENA_Pos)                  /*!&lt; MPU RASR: Region enable bit Disable Mask */
+
+/*@}*/ /* end of group CMSIS_CM3_MPU */
 #endif
 
 
-/* Core Debug Register */
+/** @addtogroup CMSIS_CM3_CoreDebug CMSIS CM3 Core Debug
+  memory mapped structure for Core Debug Register
+  @{
+ */
 typedef struct
 {
-  __IO uint32_t DHCSR;                        /*!&lt; Debug Halting Control and Status Register       */
-  __O  uint32_t DCRSR;                        /*!&lt; Debug Core Register Selector Register           */
-  __IO uint32_t DCRDR;                        /*!&lt; Debug Core Register Data Register               */
-  __IO uint32_t DEMCR;                        /*!&lt; Debug Exception and Monitor Control Register    */
+  __IO uint32_t DHCSR;                        /*!&lt; Offset: 0x00  Debug Halting Control and Status Register    */
+  __O  uint32_t DCRSR;                        /*!&lt; Offset: 0x04  Debug Core Register Selector Register        */
+  __IO uint32_t DCRDR;                        /*!&lt; Offset: 0x08  Debug Core Register Data Register            */
+  __IO uint32_t DEMCR;                        /*!&lt; Offset: 0x0C  Debug Exception and Monitor Control Register */
 } CoreDebug_Type;
 
+/* Debug Halting Control and Status Register */
+#define CoreDebug_DHCSR_DBGKEY_Pos         16                                             /*!&lt; CoreDebug DHCSR: DBGKEY Position */
+#define CoreDebug_DHCSR_DBGKEY_Msk         (0xFFFFul &lt;&lt; CoreDebug_DHCSR_DBGKEY_Pos)       /*!&lt; CoreDebug DHCSR: DBGKEY Mask */
 
+#define CoreDebug_DHCSR_S_RESET_ST_Pos     25                                             /*!&lt; CoreDebug DHCSR: S_RESET_ST Position */
+#define CoreDebug_DHCSR_S_RESET_ST_Msk     (1ul &lt;&lt; CoreDebug_DHCSR_S_RESET_ST_Pos)        /*!&lt; CoreDebug DHCSR: S_RESET_ST Mask */
+
+#define CoreDebug_DHCSR_S_RETIRE_ST_Pos    24                                             /*!&lt; CoreDebug DHCSR: S_RETIRE_ST Position */
+#define CoreDebug_DHCSR_S_RETIRE_ST_Msk    (1ul &lt;&lt; CoreDebug_DHCSR_S_RETIRE_ST_Pos)       /*!&lt; CoreDebug DHCSR: S_RETIRE_ST Mask */
+
+#define CoreDebug_DHCSR_S_LOCKUP_Pos       19                                             /*!&lt; CoreDebug DHCSR: S_LOCKUP Position */
+#define CoreDebug_DHCSR_S_LOCKUP_Msk       (1ul &lt;&lt; CoreDebug_DHCSR_S_LOCKUP_Pos)          /*!&lt; CoreDebug DHCSR: S_LOCKUP Mask */
+
+#define CoreDebug_DHCSR_S_SLEEP_Pos        18                                             /*!&lt; CoreDebug DHCSR: S_SLEEP Position */
+#define CoreDebug_DHCSR_S_SLEEP_Msk        (1ul &lt;&lt; CoreDebug_DHCSR_S_SLEEP_Pos)           /*!&lt; CoreDebug DHCSR: S_SLEEP Mask */
+
+#define CoreDebug_DHCSR_S_HALT_Pos         17                                             /*!&lt; CoreDebug DHCSR: S_HALT Position */
+#define CoreDebug_DHCSR_S_HALT_Msk         (1ul &lt;&lt; CoreDebug_DHCSR_S_HALT_Pos)            /*!&lt; CoreDebug DHCSR: S_HALT Mask */
+
+#define CoreDebug_DHCSR_S_REGRDY_Pos       16                                             /*!&lt; CoreDebug DHCSR: S_REGRDY Position */
+#define CoreDebug_DHCSR_S_REGRDY_Msk       (1ul &lt;&lt; CoreDebug_DHCSR_S_REGRDY_Pos)          /*!&lt; CoreDebug DHCSR: S_REGRDY Mask */
+
+#define CoreDebug_DHCSR_C_SNAPSTALL_Pos     5                                             /*!&lt; CoreDebug DHCSR: C_SNAPSTALL Position */
+#define CoreDebug_DHCSR_C_SNAPSTALL_Msk    (1ul &lt;&lt; CoreDebug_DHCSR_C_SNAPSTALL_Pos)       /*!&lt; CoreDebug DHCSR: C_SNAPSTALL Mask */
+
+#define CoreDebug_DHCSR_C_MASKINTS_Pos      3                                             /*!&lt; CoreDebug DHCSR: C_MASKINTS Position */
+#define CoreDebug_DHCSR_C_MASKINTS_Msk     (1ul &lt;&lt; CoreDebug_DHCSR_C_MASKINTS_Pos)        /*!&lt; CoreDebug DHCSR: C_MASKINTS Mask */
+
+#define CoreDebug_DHCSR_C_STEP_Pos          2                                             /*!&lt; CoreDebug DHCSR: C_STEP Position */
+#define CoreDebug_DHCSR_C_STEP_Msk         (1ul &lt;&lt; CoreDebug_DHCSR_C_STEP_Pos)            /*!&lt; CoreDebug DHCSR: C_STEP Mask */
+
+#define CoreDebug_DHCSR_C_HALT_Pos          1                                             /*!&lt; CoreDebug DHCSR: C_HALT Position */
+#define CoreDebug_DHCSR_C_HALT_Msk         (1ul &lt;&lt; CoreDebug_DHCSR_C_HALT_Pos)            /*!&lt; CoreDebug DHCSR: C_HALT Mask */
+
+#define CoreDebug_DHCSR_C_DEBUGEN_Pos       0                                             /*!&lt; CoreDebug DHCSR: C_DEBUGEN Position */
+#define CoreDebug_DHCSR_C_DEBUGEN_Msk      (1ul &lt;&lt; CoreDebug_DHCSR_C_DEBUGEN_Pos)         /*!&lt; CoreDebug DHCSR: C_DEBUGEN Mask */
+
+/* Debug Core Register Selector Register */
+#define CoreDebug_DCRSR_REGWnR_Pos         16                                             /*!&lt; CoreDebug DCRSR: REGWnR Position */
+#define CoreDebug_DCRSR_REGWnR_Msk         (1ul &lt;&lt; CoreDebug_DCRSR_REGWnR_Pos)            /*!&lt; CoreDebug DCRSR: REGWnR Mask */
+
+#define CoreDebug_DCRSR_REGSEL_Pos          0                                             /*!&lt; CoreDebug DCRSR: REGSEL Position */
+#define CoreDebug_DCRSR_REGSEL_Msk         (0x1Ful &lt;&lt; CoreDebug_DCRSR_REGSEL_Pos)         /*!&lt; CoreDebug DCRSR: REGSEL Mask */
+
+/* Debug Exception and Monitor Control Register */
+#define CoreDebug_DEMCR_TRCENA_Pos         24                                             /*!&lt; CoreDebug DEMCR: TRCENA Position */
+#define CoreDebug_DEMCR_TRCENA_Msk         (1ul &lt;&lt; CoreDebug_DEMCR_TRCENA_Pos)            /*!&lt; CoreDebug DEMCR: TRCENA Mask */
+
+#define CoreDebug_DEMCR_MON_REQ_Pos        19                                             /*!&lt; CoreDebug DEMCR: MON_REQ Position */
+#define CoreDebug_DEMCR_MON_REQ_Msk        (1ul &lt;&lt; CoreDebug_DEMCR_MON_REQ_Pos)           /*!&lt; CoreDebug DEMCR: MON_REQ Mask */
+
+#define CoreDebug_DEMCR_MON_STEP_Pos       18                                             /*!&lt; CoreDebug DEMCR: MON_STEP Position */
+#define CoreDebug_DEMCR_MON_STEP_Msk       (1ul &lt;&lt; CoreDebug_DEMCR_MON_STEP_Pos)          /*!&lt; CoreDebug DEMCR: MON_STEP Mask */
+
+#define CoreDebug_DEMCR_MON_PEND_Pos       17                                             /*!&lt; CoreDebug DEMCR: MON_PEND Position */
+#define CoreDebug_DEMCR_MON_PEND_Msk       (1ul &lt;&lt; CoreDebug_DEMCR_MON_PEND_Pos)          /*!&lt; CoreDebug DEMCR: MON_PEND Mask */
+
+#define CoreDebug_DEMCR_MON_EN_Pos         16                                             /*!&lt; CoreDebug DEMCR: MON_EN Position */
+#define CoreDebug_DEMCR_MON_EN_Msk         (1ul &lt;&lt; CoreDebug_DEMCR_MON_EN_Pos)            /*!&lt; CoreDebug DEMCR: MON_EN Mask */
+
+#define CoreDebug_DEMCR_VC_HARDERR_Pos     10                                             /*!&lt; CoreDebug DEMCR: VC_HARDERR Position */
+#define CoreDebug_DEMCR_VC_HARDERR_Msk     (1ul &lt;&lt; CoreDebug_DEMCR_VC_HARDERR_Pos)        /*!&lt; CoreDebug DEMCR: VC_HARDERR Mask */
+
+#define CoreDebug_DEMCR_VC_INTERR_Pos       9                                             /*!&lt; CoreDebug DEMCR: VC_INTERR Position */
+#define CoreDebug_DEMCR_VC_INTERR_Msk      (1ul &lt;&lt; CoreDebug_DEMCR_VC_INTERR_Pos)         /*!&lt; CoreDebug DEMCR: VC_INTERR Mask */
+
+#define CoreDebug_DEMCR_VC_BUSERR_Pos       8                                             /*!&lt; CoreDebug DEMCR: VC_BUSERR Position */
+#define CoreDebug_DEMCR_VC_BUSERR_Msk      (1ul &lt;&lt; CoreDebug_DEMCR_VC_BUSERR_Pos)         /*!&lt; CoreDebug DEMCR: VC_BUSERR Mask */
+
+#define CoreDebug_DEMCR_VC_STATERR_Pos      7                                             /*!&lt; CoreDebug DEMCR: VC_STATERR Position */
+#define CoreDebug_DEMCR_VC_STATERR_Msk     (1ul &lt;&lt; CoreDebug_DEMCR_VC_STATERR_Pos)        /*!&lt; CoreDebug DEMCR: VC_STATERR Mask */
+
+#define CoreDebug_DEMCR_VC_CHKERR_Pos       6                                             /*!&lt; CoreDebug DEMCR: VC_CHKERR Position */
+#define CoreDebug_DEMCR_VC_CHKERR_Msk      (1ul &lt;&lt; CoreDebug_DEMCR_VC_CHKERR_Pos)         /*!&lt; CoreDebug DEMCR: VC_CHKERR Mask */
+
+#define CoreDebug_DEMCR_VC_NOCPERR_Pos      5                                             /*!&lt; CoreDebug DEMCR: VC_NOCPERR Position */
+#define CoreDebug_DEMCR_VC_NOCPERR_Msk     (1ul &lt;&lt; CoreDebug_DEMCR_VC_NOCPERR_Pos)        /*!&lt; CoreDebug DEMCR: VC_NOCPERR Mask */
+
+#define CoreDebug_DEMCR_VC_MMERR_Pos        4                                             /*!&lt; CoreDebug DEMCR: VC_MMERR Position */
+#define CoreDebug_DEMCR_VC_MMERR_Msk       (1ul &lt;&lt; CoreDebug_DEMCR_VC_MMERR_Pos)          /*!&lt; CoreDebug DEMCR: VC_MMERR Mask */
+
+#define CoreDebug_DEMCR_VC_CORERESET_Pos    0                                             /*!&lt; CoreDebug DEMCR: VC_CORERESET Position */
+#define CoreDebug_DEMCR_VC_CORERESET_Msk   (1ul &lt;&lt; CoreDebug_DEMCR_VC_CORERESET_Pos)      /*!&lt; CoreDebug DEMCR: VC_CORERESET Mask */
+/*@}*/ /* end of group CMSIS_CM3_CoreDebug */
+
+
 /* Memory mapping of Cortex-M3 Hardware */
-#define SCS_BASE            (0xE000E000)                              /*!&lt; System Control Space Base Address    */
-#define ITM_BASE            (0xE0000000)                              /*!&lt; ITM Base Address                     */
-#define CoreDebug_BASE      (0xE000EDF0)                              /*!&lt; Core Debug Base Address              */
-#define SysTick_BASE        (SCS_BASE +  0x0010)                      /*!&lt; SysTick Base Address                 */
-#define NVIC_BASE           (SCS_BASE +  0x0100)                      /*!&lt; NVIC Base Address                    */
-#define SCB_BASE            (SCS_BASE +  0x0D00)                      /*!&lt; System Control Block Base Address    */
+#define SCS_BASE            (0xE000E000)                              /*!&lt; System Control Space Base Address */
+#define ITM_BASE            (0xE0000000)                              /*!&lt; ITM Base Address                  */
+#define CoreDebug_BASE      (0xE000EDF0)                              /*!&lt; Core Debug Base Address           */
+#define SysTick_BASE        (SCS_BASE +  0x0010)                      /*!&lt; SysTick Base Address              */
+#define NVIC_BASE           (SCS_BASE +  0x0100)                      /*!&lt; NVIC Base Address                 */
+#define SCB_BASE            (SCS_BASE +  0x0D00)                      /*!&lt; System Control Block Base Address */
 
-#define InterruptType       ((InterruptType_Type *) SCS_BASE)         /*!&lt; Interrupt Type Register              */
-#define SCB                 ((SCB_Type *)           SCB_BASE)         /*!&lt; SCB configuration struct             */
-#define SysTick             ((SysTick_Type *)       SysTick_BASE)     /*!&lt; SysTick configuration struct         */
-#define NVIC                ((NVIC_Type *)          NVIC_BASE)        /*!&lt; NVIC configuration struct            */
-#define ITM                 ((ITM_Type *)           ITM_BASE)         /*!&lt; ITM configuration struct             */
-#define CoreDebug           ((CoreDebug_Type *)     CoreDebug_BASE)   /*!&lt; Core Debug configuration struct      */
+#define InterruptType       ((InterruptType_Type *) SCS_BASE)         /*!&lt; Interrupt Type Register           */
+#define SCB                 ((SCB_Type *)           SCB_BASE)         /*!&lt; SCB configuration struct          */
+#define SysTick             ((SysTick_Type *)       SysTick_BASE)     /*!&lt; SysTick configuration struct      */
+#define NVIC                ((NVIC_Type *)          NVIC_BASE)        /*!&lt; NVIC configuration struct         */
+#define ITM                 ((ITM_Type *)           ITM_BASE)         /*!&lt; ITM configuration struct          */
+#define CoreDebug           ((CoreDebug_Type *)     CoreDebug_BASE)   /*!&lt; Core Debug configuration struct   */
 
 #if defined (__MPU_PRESENT) &amp;&amp; (__MPU_PRESENT == 1)
-  #define MPU_BASE          (SCS_BASE +  0x0D90)                      /*!&lt; Memory Protection Unit               */
-  #define MPU               ((MPU_Type*)            MPU_BASE)         /*!&lt; Memory Protection Unit               */
+  #define MPU_BASE          (SCS_BASE +  0x0D90)                      /*!&lt; Memory Protection Unit            */
+  #define MPU               ((MPU_Type*)            MPU_BASE)         /*!&lt; Memory Protection Unit            */
 #endif
 
+/*@}*/ /* end of group CMSIS_CM3_core_register */
 
 
 /*******************************************************************************
  *                Hardware Abstraction Layer
  ******************************************************************************/
 
-
 #if defined ( __CC_ARM   )
   #define __ASM            __asm                                      /*!&lt; asm keyword for ARM Compiler          */
   #define __INLINE         __inline                                   /*!&lt; inline keyword for ARM Compiler       */
 
 #elif defined ( __ICCARM__ )
-  #define __ASM           __asm                                       /*!&lt; asm keyword for IAR Compiler           */
+  #define __ASM           __asm                                       /*!&lt; asm keyword for IAR Compiler          */
   #define __INLINE        inline                                      /*!&lt; inline keyword for IAR Compiler. Only avaiable in High optimization mode! */
 
 #elif defined   (  __GNUC__  )
@@ -304,8 +751,8 @@
   #define __INLINE         inline                                     /*!&lt; inline keyword for GNU Compiler       */
 
 #elif defined   (  __TASKING__  )
-  #define __ASM            __asm                                      /*!&lt; asm keyword for TASKING Compiler          */
-  #define __INLINE         inline                                     /*!&lt; inline keyword for TASKING Compiler       */
+  #define __ASM            __asm                                      /*!&lt; asm keyword for TASKING Compiler      */
+  #define __INLINE         inline                                     /*!&lt; inline keyword for TASKING Compiler   */
 
 #endif
 
@@ -344,8 +791,7 @@
 /**
  * @brief  Return the Process Stack Pointer
  *
- * @param  none
- * @return uint32_t ProcessStackPointer
+ * @return ProcessStackPointer
  *
  * Return the actual process stack pointer
  */
@@ -354,8 +800,7 @@
 /**
  * @brief  Set the Process Stack Pointer
  *
- * @param  uint32_t Process Stack Pointer
- * @return none
+ * @param  topOfProcStack  Process Stack Pointer
  *
  * Assign the value ProcessStackPointer to the MSP
  * (process stack pointer) Cortex processor register
@@ -365,8 +810,7 @@
 /**
  * @brief  Return the Main Stack Pointer
  *
- * @param  none
- * @return uint32_t Main Stack Pointer
+ * @return Main Stack Pointer
  *
  * Return the current value of the MSP (main stack pointer)
  * Cortex processor register
@@ -376,8 +820,7 @@
 /**
  * @brief  Set the Main Stack Pointer
  *
- * @param  uint32_t Main Stack Pointer
- * @return none
+ * @param  topOfMainStack  Main Stack Pointer
  *
  * Assign the value mainStackPointer to the MSP
  * (main stack pointer) Cortex processor register
@@ -387,18 +830,18 @@
 /**
  * @brief  Reverse byte order in unsigned short value
  *
- * @param  uint16_t value to reverse
- * @return uint32_t reversed value
+ * @param   value  value to reverse
+ * @return         reversed value
  *
  * Reverse byte order in unsigned short value
  */
 extern uint32_t __REV16(uint16_t value);
 
-/*
+/**
  * @brief  Reverse byte order in signed short value with sign extension to integer
  *
- * @param  int16_t value to reverse
- * @return int32_t reversed value
+ * @param   value  value to reverse
+ * @return         reversed value
  *
  * Reverse byte order in signed short value with sign extension to integer
  */
@@ -410,9 +853,6 @@
 /**
  * @brief  Remove the exclusive lock created by ldrex
  *
- * @param  none
- * @return none
- *
  * Removes the exclusive lock which is created by ldrex.
  */
 extern void __CLREX(void);
@@ -420,8 +860,7 @@
 /**
  * @brief  Return the Base Priority value
  *
- * @param  none
- * @return uint32_t BasePriority
+ * @return BasePriority
  *
  * Return the content of the base priority register
  */
@@ -430,8 +869,7 @@
 /**
  * @brief  Set the Base Priority value
  *
- * @param  uint32_t BasePriority
- * @return none
+ * @param  basePri  BasePriority
  *
  * Set the base priority register
  */
@@ -440,19 +878,16 @@
 /**
  * @brief  Return the Priority Mask value
  *
- * @param  none
- * @return uint32_t PriMask
+ * @return PriMask
  *
- * Return the state of the priority mask bit from the priority mask
- * register
+ * Return state of the priority mask bit from the priority mask register
  */
 extern uint32_t __get_PRIMASK(void);
 
 /**
  * @brief  Set the Priority Mask value
  *
- * @param  uint32_t PriMask
- * @return none
+ * @param   priMask  PriMask
  *
  * Set the priority mask bit in the priority mask register
  */
@@ -461,8 +896,7 @@
 /**
  * @brief  Return the Fault Mask value
  *
- * @param  none
- * @return uint32_t FaultMask
+ * @return FaultMask
  *
  * Return the content of the fault mask register
  */
@@ -471,8 +905,7 @@
 /**
  * @brief  Set the Fault Mask value
  *
- * @param  uint32_t faultMask value
- * @return none
+ * @param  faultMask faultMask value
  *
  * Set the fault mask register
  */
@@ -481,8 +914,7 @@
 /**
  * @brief  Return the Control Register value
  *
- * @param  none
- * @return uint32_t Control value
+ * @return Control value
  *
  * Return the content of the control register
  */
@@ -491,8 +923,7 @@
 /**
  * @brief  Set the Control Register value
  *
- * @param  uint32_t Control value
- * @return none
+ * @param  control  Control value
  *
  * Set the control register
  */
@@ -500,13 +931,9 @@
 
 #else  /* (__ARMCC_VERSION &gt;= 400000)  */
 
-
 /**
  * @brief  Remove the exclusive lock created by ldrex
  *
- * @param  none
- * @return none
- *
  * Removes the exclusive lock which is created by ldrex.
  */
 #define __CLREX                           __clrex
@@ -514,8 +941,7 @@
 /**
  * @brief  Return the Base Priority value
  *
- * @param  none
- * @return uint32_t BasePriority
+ * @return BasePriority
  *
  * Return the content of the base priority register
  */
@@ -528,25 +954,22 @@
 /**
  * @brief  Set the Base Priority value
  *
- * @param  uint32_t BasePriority
- * @return none
+ * @param  basePri  BasePriority
  *
  * Set the base priority register
  */
 static __INLINE void __set_BASEPRI(uint32_t basePri)
 {
   register uint32_t __regBasePri         __ASM(&quot;basepri&quot;);
-  __regBasePri = (basePri &amp; 0x1ff);
+  __regBasePri = (basePri &amp; 0xff);
 }
 
 /**
  * @brief  Return the Priority Mask value
  *
- * @param  none
- * @return uint32_t PriMask
+ * @return PriMask
  *
- * Return the state of the priority mask bit from the priority mask
- * register
+ * Return state of the priority mask bit from the priority mask register
  */
 static __INLINE uint32_t __get_PRIMASK(void)
 {
@@ -557,8 +980,7 @@
 /**
  * @brief  Set the Priority Mask value
  *
- * @param  uint32_t PriMask
- * @return none
+ * @param  priMask  PriMask
  *
  * Set the priority mask bit in the priority mask register
  */
@@ -571,8 +993,7 @@
 /**
  * @brief  Return the Fault Mask value
  *
- * @param  none
- * @return uint32_t FaultMask
+ * @return FaultMask
  *
  * Return the content of the fault mask register
  */
@@ -585,8 +1006,7 @@
 /**
  * @brief  Set the Fault Mask value
  *
- * @param  uint32_t faultMask value
- * @return none
+ * @param  faultMask  faultMask value
  *
  * Set the fault mask register
  */
@@ -599,8 +1019,7 @@
 /**
  * @brief  Return the Control Register value
  *
- * @param  none
- * @return uint32_t Control value
+ * @return Control value
  *
  * Return the content of the control register
  */
@@ -613,8 +1032,7 @@
 /**
  * @brief  Set the Control Register value
  *
- * @param  uint32_t Control value
- * @return none
+ * @param  control  Control value
  *
  * Set the control register
  */
@@ -637,7 +1055,7 @@
 static __INLINE void __enable_fault_irq()         { __ASM (&quot;cpsie f&quot;); }
 static __INLINE void __disable_fault_irq()        { __ASM (&quot;cpsid f&quot;); }
 
-#define __NOP                                     __no_operation()          /*!&lt; no operation intrinsic in IAR Compiler */
+#define __NOP                                     __no_operation            /*!&lt; no operation intrinsic in IAR Compiler */
 static __INLINE  void __WFI()                     { __ASM (&quot;wfi&quot;); }
 static __INLINE  void __WFE()                     { __ASM (&quot;wfe&quot;); }
 static __INLINE  void __SEV()                     { __ASM (&quot;sev&quot;); }
@@ -659,8 +1077,7 @@
 /**
  * @brief  Return the Process Stack Pointer
  *
- * @param  none
- * @return uint32_t ProcessStackPointer
+ * @return ProcessStackPointer
  *
  * Return the actual process stack pointer
  */
@@ -669,8 +1086,7 @@
 /**
  * @brief  Set the Process Stack Pointer
  *
- * @param  uint32_t Process Stack Pointer
- * @return none
+ * @param  topOfProcStack  Process Stack Pointer
  *
  * Assign the value ProcessStackPointer to the MSP
  * (process stack pointer) Cortex processor register
@@ -680,8 +1096,7 @@
 /**
  * @brief  Return the Main Stack Pointer
  *
- * @param  none
- * @return uint32_t Main Stack Pointer
+ * @return Main Stack Pointer
  *
  * Return the current value of the MSP (main stack pointer)
  * Cortex processor register
@@ -691,8 +1106,7 @@
 /**
  * @brief  Set the Main Stack Pointer
  *
- * @param  uint32_t Main Stack Pointer
- * @return none
+ * @param  topOfMainStack  Main Stack Pointer
  *
  * Assign the value mainStackPointer to the MSP
  * (main stack pointer) Cortex processor register
@@ -702,8 +1116,8 @@
 /**
  * @brief  Reverse byte order in unsigned short value
  *
- * @param  uint16_t value to reverse
- * @return uint32_t reversed value
+ * @param  value  value to reverse
+ * @return        reversed value
  *
  * Reverse byte order in unsigned short value
  */
@@ -712,73 +1126,73 @@
 /**
  * @brief  Reverse bit order of value
  *
- * @param  uint32_t value to reverse
- * @return uint32_t reversed value
+ * @param  value  value to reverse
+ * @return        reversed value
  *
  * Reverse bit order of value
  */
 extern uint32_t __RBIT(uint32_t value);
 
 /**
- * @brief  LDR Exclusive
+ * @brief  LDR Exclusive (8 bit)
  *
- * @param  uint8_t* address
- * @return uint8_t value of (*address)
+ * @param  *addr  address pointer
+ * @return        value of (*address)
  *
- * Exclusive LDR command
+ * Exclusive LDR command for 8 bit values)
  */
 extern uint8_t __LDREXB(uint8_t *addr);
 
 /**
- * @brief  LDR Exclusive
+ * @brief  LDR Exclusive (16 bit)
  *
- * @param  uint16_t* address
- * @return uint16_t value of (*address)
+ * @param  *addr  address pointer
+ * @return        value of (*address)
  *
- * Exclusive LDR command
+ * Exclusive LDR command for 16 bit values
  */
 extern uint16_t __LDREXH(uint16_t *addr);
 
 /**
- * @brief  LDR Exclusive
+ * @brief  LDR Exclusive (32 bit)
  *
- * @param  uint32_t* address
- * @return uint32_t value of (*address)
+ * @param  *addr  address pointer
+ * @return        value of (*address)
  *
- * Exclusive LDR command
+ * Exclusive LDR command for 32 bit values
  */
 extern uint32_t __LDREXW(uint32_t *addr);
 
 /**
- * @brief  STR Exclusive
+ * @brief  STR Exclusive (8 bit)
  *
- * @param  uint8_t *address
- * @param  uint8_t value to store
- * @return uint32_t successful / failed
+ * @param  value  value to store
+ * @param  *addr  address pointer
+ * @return        successful / failed
  *
- * Exclusive STR command
+ * Exclusive STR command for 8 bit values
  */
 extern uint32_t __STREXB(uint8_t value, uint8_t *addr);
 
 /**
- * @brief  STR Exclusive
+ * @brief  STR Exclusive (16 bit)
  *
- * @param  uint16_t *address
- * @param  uint16_t value to store
- * @return uint32_t successful / failed
+ * @param  value  value to store
+ * @param  *addr  address pointer
+ * @return        successful / failed
  *
- * Exclusive STR command
+ * Exclusive STR command for 16 bit values
  */
 extern uint32_t __STREXH(uint16_t value, uint16_t *addr);
 
 /**
- * @brief  STR Exclusive
+ * @brief  STR Exclusive (32 bit)
  *
- * @param  uint32_t *address
- * @param  uint32_t value to store
- * @return uint32_t successful / failed
+ * @param  value  value to store
+ * @param  *addr  address pointer
+ * @return        successful / failed
  *
- * Exclusive STR command
+ * Exclusive STR command for 32 bit values
  */
 extern uint32_t __STREXW(uint32_t value, uint32_t *addr);
 
@@ -806,8 +1220,7 @@
 /**
  * @brief  Return the Process Stack Pointer
  *
- * @param  none
- * @return uint32_t ProcessStackPointer
+ * @return ProcessStackPointer
  *
  * Return the actual process stack pointer
  */
@@ -816,8 +1229,7 @@
 /**
  * @brief  Set the Process Stack Pointer
  *
- * @param  uint32_t Process Stack Pointer
- * @return none
+ * @param  topOfProcStack  Process Stack Pointer
  *
  * Assign the value ProcessStackPointer to the MSP
  * (process stack pointer) Cortex processor register
@@ -827,8 +1239,7 @@
 /**
  * @brief  Return the Main Stack Pointer
  *
- * @param  none
- * @return uint32_t Main Stack Pointer
+ * @return Main Stack Pointer
  *
  * Return the current value of the MSP (main stack pointer)
  * Cortex processor register
@@ -838,8 +1249,7 @@
 /**
  * @brief  Set the Main Stack Pointer
  *
- * @param  uint32_t Main Stack Pointer
- * @return none
+ * @param  topOfMainStack  Main Stack Pointer
  *
  * Assign the value mainStackPointer to the MSP
  * (main stack pointer) Cortex processor register
@@ -849,8 +1259,7 @@
 /**
  * @brief  Return the Base Priority value
  *
- * @param  none
- * @return uint32_t BasePriority
+ * @return BasePriority
  *
  * Return the content of the base priority register
  */
@@ -859,8 +1268,7 @@
 /**
  * @brief  Set the Base Priority value
  *
- * @param  uint32_t BasePriority
- * @return none
+ * @param  basePri  BasePriority
  *
  * Set the base priority register
  */
@@ -869,19 +1277,16 @@
 /**
  * @brief  Return the Priority Mask value
  *
- * @param  none
- * @return uint32_t PriMask
+ * @return PriMask
  *
- * Return the state of the priority mask bit from the priority mask
- * register
+ * Return state of the priority mask bit from the priority mask register
  */
 extern uint32_t  __get_PRIMASK(void);
 
 /**
  * @brief  Set the Priority Mask value
  *
- * @param  uint32_t PriMask
- * @return none
+ * @param  priMask  PriMask
  *
  * Set the priority mask bit in the priority mask register
  */
@@ -890,8 +1295,7 @@
 /**
  * @brief  Return the Fault Mask value
  *
- * @param  none
- * @return uint32_t FaultMask
+ * @return FaultMask
  *
  * Return the content of the fault mask register
  */
@@ -900,8 +1304,7 @@
 /**
  * @brief  Set the Fault Mask value
  *
- * @param  uint32_t faultMask value
- * @return none
+ * @param  faultMask  faultMask value
  *
  * Set the fault mask register
  */
@@ -910,8 +1313,7 @@
 /**
  * @brief  Return the Control Register value
 *
-*  @param  none
-*  @return uint32_t Control value
+*  @return Control value
  *
  * Return the content of the control register
  */
@@ -920,8 +1322,7 @@
 /**
  * @brief  Set the Control Register value
  *
- * @param  uint32_t Control value
- * @return none
+ * @param  control  Control value
  *
  * Set the control register
  */
@@ -930,8 +1331,8 @@
 /**
  * @brief  Reverse byte order in integer value
  *
- * @param  uint32_t value to reverse
- * @return uint32_t reversed value
+ * @param  value  value to reverse
+ * @return        reversed value
  *
  * Reverse byte order in integer value
  */
@@ -940,93 +1341,93 @@
 /**
  * @brief  Reverse byte order in unsigned short value
  *
- * @param  uint16_t value to reverse
- * @return uint32_t reversed value
+ * @param  value  value to reverse
+ * @return        reversed value
  *
  * Reverse byte order in unsigned short value
  */
 extern uint32_t __REV16(uint16_t value);
 
-/*
- * Reverse byte order in signed short value with sign extension to integer
+/**
+ * @brief  Reverse byte order in signed short value with sign extension to integer
  *
- * @param  int16_t value to reverse
- * @return int32_t reversed value
+ * @param  value  value to reverse
+ * @return        reversed value
  *
- * @brief  Reverse byte order in signed short value with sign extension to integer
+ * Reverse byte order in signed short value with sign extension to integer
  */
 extern int32_t __REVSH(int16_t value);
 
 /**
  * @brief  Reverse bit order of value
  *
- * @param  uint32_t value to reverse
- * @return uint32_t reversed value
+ * @param  value  value to reverse
+ * @return        reversed value
  *
  * Reverse bit order of value
  */
 extern uint32_t __RBIT(uint32_t value);
 
 /**
- * @brief  LDR Exclusive
+ * @brief  LDR Exclusive (8 bit)
  *
- * @param  uint8_t* address
- * @return uint8_t value of (*address)
+ * @param  *addr  address pointer
+ * @return        value of (*address)
  *
- * Exclusive LDR command
+ * Exclusive LDR command for 8 bit value
  */
 extern uint8_t __LDREXB(uint8_t *addr);
 
 /**
- * @brief  LDR Exclusive
+ * @brief  LDR Exclusive (16 bit)
  *
- * @param  uint16_t* address
- * @return uint16_t value of (*address)
+ * @param  *addr  address pointer
+ * @return        value of (*address)
  *
- * Exclusive LDR command
+ * Exclusive LDR command for 16 bit values
  */
 extern uint16_t __LDREXH(uint16_t *addr);
 
 /**
- * @brief  LDR Exclusive
+ * @brief  LDR Exclusive (32 bit)
  *
- * @param  uint32_t* address
- * @return uint32_t value of (*address)
+ * @param  *addr  address pointer
+ * @return        value of (*address)
  *
- * Exclusive LDR command
+ * Exclusive LDR command for 32 bit values
  */
 extern uint32_t __LDREXW(uint32_t *addr);
 
 /**
- * @brief  STR Exclusive
+ * @brief  STR Exclusive (8 bit)
  *
- * @param  uint8_t *address
- * @param  uint8_t value to store
- * @return uint32_t successful / failed
+ * @param  value  value to store
+ * @param  *addr  address pointer
+ * @return        successful / failed
  *
- * Exclusive STR command
+ * Exclusive STR command for 8 bit values
  */
 extern uint32_t __STREXB(uint8_t value, uint8_t *addr);
 
 /**
- * @brief  STR Exclusive
+ * @brief  STR Exclusive (16 bit)
  *
- * @param  uint16_t *address
- * @param  uint16_t value to store
- * @return uint32_t successful / failed
+ * @param  value  value to store
+ * @param  *addr  address pointer
+ * @return        successful / failed
  *
- * Exclusive STR command
+ * Exclusive STR command for 16 bit values
  */
 extern uint32_t __STREXH(uint16_t value, uint16_t *addr);
 
 /**
- * @brief  STR Exclusive
+ * @brief  STR Exclusive (32 bit)
  *
- * @param  uint32_t *address
- * @param  uint32_t value to store
- * @return uint32_t successful / failed
+ * @param  value  value to store
+ * @param  *addr  address pointer
+ * @return        successful / failed
  *
- * Exclusive STR command
+ * Exclusive STR command for 32 bit values
  */
 extern uint32_t __STREXW(uint32_t value, uint32_t *addr);
 
@@ -1043,15 +1444,20 @@
 #endif
 
 
+/** @addtogroup CMSIS_CM3_Core_FunctionInterface CMSIS CM3 Core Function Interface
+  Core  Function Interface containing:
+  - Core NVIC Functions
+  - Core SysTick Functions
+  - Core Reset Functions
+*/
+/*@{*/
 
 /* ##########################   NVIC functions  #################################### */
 
-
 /**
  * @brief  Set the Priority Grouping in NVIC Interrupt Controller
  *
- * @param  uint32_t priority_grouping is priority grouping field
- * @return none
+ * @param  PriorityGroup is priority grouping field
  *
  * Set the priority grouping field using the required unlock sequence.
  * The parameter priority_grouping is assigned to the field
@@ -1064,31 +1470,31 @@
   uint32_t reg_value;
   uint32_t PriorityGroupTmp = (PriorityGroup &amp; 0x07);                         /* only values 0..7 are used          */
 
-  reg_value  = SCB-&gt;AIRCR;                                                    /* read old register configuration    */
-  reg_value &amp;= ~((0xFFFFU &lt;&lt; 16) | (0x0F &lt;&lt; 8));                              /* clear bits to change               */
-  reg_value  = ((reg_value | NVIC_AIRCR_VECTKEY | (PriorityGroupTmp &lt;&lt; 8)));  /* Insert write key and priorty group */
-  SCB-&gt;AIRCR = reg_value;
+  reg_value  =  SCB-&gt;AIRCR;                                                   /* read old register configuration    */
+  reg_value &amp;= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
+  reg_value  =  (reg_value                       |
+                (0x5FA &lt;&lt; SCB_AIRCR_VECTKEY_Pos) |
+                (PriorityGroupTmp &lt;&lt; 8));                                     /* Insert write key and priorty group */
+  SCB-&gt;AIRCR =  reg_value;
 }
 
 /**
  * @brief  Get the Priority Grouping from NVIC Interrupt Controller
  *
- * @param  none
- * @return uint32_t   priority grouping field
+ * @return priority grouping field
  *
  * Get the priority grouping from NVIC Interrupt Controller.
  * priority grouping is SCB-&gt;AIRCR [10:8] PRIGROUP field.
  */
 static __INLINE uint32_t NVIC_GetPriorityGrouping(void)
 {
-  return ((SCB-&gt;AIRCR &gt;&gt; 8) &amp; 0x07);                                          /* read priority grouping field */
+  return ((SCB-&gt;AIRCR &amp; SCB_AIRCR_PRIGROUP_Msk) &gt;&gt; SCB_AIRCR_PRIGROUP_Pos);   /* read priority grouping field */
 }
 
 /**
  * @brief  Enable Interrupt in NVIC Interrupt Controller
  *
- * @param  IRQn_Type IRQn specifies the interrupt number
- * @return none
+ * @param  IRQn   The positive number of the external interrupt to enable
  *
  * Enable a device specific interupt in the NVIC interrupt controller.
  * The interrupt number cannot be a negative value.
@@ -1101,8 +1507,7 @@
 /**
  * @brief  Disable the interrupt line for external interrupt specified
  *
- * @param  IRQn_Type IRQn is the positive number of the external interrupt
- * @return none
+ * @param  IRQn   The positive number of the external interrupt to disable
  *
  * Disable a device specific interupt in the NVIC interrupt controller.
  * The interrupt number cannot be a negative value.
@@ -1115,8 +1520,8 @@
 /**
  * @brief  Read the interrupt pending bit for a device specific interrupt source
  *
- * @param  IRQn_Type IRQn is the number of the device specifc interrupt
- * @return uint32_t 1 if pending interrupt else 0
+ * @param  IRQn    The number of the device specifc interrupt
+ * @return         1 = interrupt pending, 0 = interrupt not pending
  *
  * Read the pending register in NVIC and return 1 if its status is pending,
  * otherwise it returns 0
@@ -1129,8 +1534,7 @@
 /**
  * @brief  Set the pending bit for an external interrupt
  *
- * @param  IRQn_Type IRQn is the Number of the interrupt
- * @return none
+ * @param  IRQn    The number of the interrupt for set pending
  *
  * Set the pending bit for the specified interrupt.
  * The interrupt number cannot be a negative value.
@@ -1143,8 +1547,7 @@
 /**
  * @brief  Clear the pending bit for an external interrupt
  *
- * @param  IRQn_Type IRQn is the Number of the interrupt
- * @return none
+ * @param  IRQn    The number of the interrupt for clear pending
  *
  * Clear the pending bit for the specified interrupt.
  * The interrupt number cannot be a negative value.
@@ -1157,8 +1560,8 @@
 /**
  * @brief  Read the active bit for an external interrupt
  *
- * @param  IRQn_Type  IRQn is the Number of the interrupt
- * @return uint32_t   1 if active else 0
+ * @param  IRQn    The number of the interrupt for read active bit
+ * @return         1 = interrupt active, 0 = interrupt not active
  *
  * Read the active register in NVIC and returns 1 if its status is active,
  * otherwise it returns 0.
@@ -1171,13 +1574,12 @@
 /**
  * @brief  Set the priority for an interrupt
  *
- * @param  IRQn_Type IRQn is the Number of the interrupt
- * @param  priority is the priority for the interrupt
- * @return none
+ * @param  IRQn      The number of the interrupt for set priority
+ * @param  priority  The priority to set
  *
  * Set the priority for the specified interrupt. The interrupt
  * number can be positive to specify an external (device specific)
- * interrupt, or negative to specify an internal (core) interrupt. \n
+ * interrupt, or negative to specify an internal (core) interrupt.
  *
  * Note: The priority cannot be set for every core interrupt.
  */
@@ -1186,14 +1588,14 @@
   if(IRQn &lt; 0) {
     SCB-&gt;SHP[((uint32_t)(IRQn) &amp; 0xF)-4] = ((priority &lt;&lt; (8 - __NVIC_PRIO_BITS)) &amp; 0xff); } /* set Priority for Cortex-M3 System Interrupts */
   else {
-    NVIC-&gt;IP[(uint32_t)(IRQn)] = ((priority &lt;&lt; (8 - __NVIC_PRIO_BITS)) &amp; 0xff);    }        /* set Priority for device specific Interrupts      */
+    NVIC-&gt;IP[(uint32_t)(IRQn)] = ((priority &lt;&lt; (8 - __NVIC_PRIO_BITS)) &amp; 0xff);    }        /* set Priority for device specific Interrupts  */
 }
 
 /**
  * @brief  Read the priority for an interrupt
  *
- * @param  IRQn_Type IRQn is the Number of the interrupt
- * @return uint32_t  priority is the priority for the interrupt
+ * @param  IRQn      The number of the interrupt for get priority
+ * @return           The priority for the interrupt
  *
  * Read the priority for the specified interrupt. The interrupt
  * number can be positive to specify an external (device specific)
@@ -1217,10 +1619,10 @@
 /**
  * @brief  Encode the priority for an interrupt
  *
- * @param  uint32_t PriorityGroup   is the used priority group
- * @param  uint32_t PreemptPriority is the preemptive priority value (starting from 0)
- * @param  uint32_t SubPriority     is the sub priority value (starting from 0)
- * @return uint32_t                    the priority for the interrupt
+ * @param  PriorityGroup    The used priority group
+ * @param  PreemptPriority  The preemptive priority value (starting from 0)
+ * @param  SubPriority      The sub priority value (starting from 0)
+ * @return                  The encoded priority for the interrupt
  *
  * Encode the priority for an interrupt with the given priority group,
  * preemptive priority value and sub priority value.
@@ -1231,7 +1633,7 @@
  */
 static __INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
 {
-  uint32_t PriorityGroupTmp = (PriorityGroup &amp; 0x07);                         /* only values 0..7 are used          */
+  uint32_t PriorityGroupTmp = (PriorityGroup &amp; 0x07);          /* only values 0..7 are used          */
   uint32_t PreemptPriorityBits;
   uint32_t SubPriorityBits;
 
@@ -1248,11 +1650,10 @@
 /**
  * @brief  Decode the priority of an interrupt
  *
- * @param  uint32_t   Priority       the priority for the interrupt
- * @param  uint32_t   PrioGroup   is the used priority group
- * @param  uint32_t* pPreemptPrio is the preemptive priority value (starting from 0)
- * @param  uint32_t* pSubPrio     is the sub priority value (starting from 0)
- * @return none
+ * @param  Priority           The priority for the interrupt
+ * @param  PriorityGroup      The used priority group
+ * @param  pPreemptPriority   The preemptive priority value (starting from 0)
+ * @param  pSubPriority       The sub priority value (starting from 0)
  *
  * Decode an interrupt priority value with the given priority group to
  * preemptive priority value and sub priority value.
@@ -1263,7 +1664,7 @@
  */
 static __INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* pPreemptPriority, uint32_t* pSubPriority)
 {
-  uint32_t PriorityGroupTmp = (PriorityGroup &amp; 0x07);                         /* only values 0..7 are used          */
+  uint32_t PriorityGroupTmp = (PriorityGroup &amp; 0x07);          /* only values 0..7 are used          */
   uint32_t PreemptPriorityBits;
   uint32_t SubPriorityBits;
 
@@ -1280,17 +1681,11 @@
 
 #if (!defined (__Vendor_SysTickConfig)) || (__Vendor_SysTickConfig == 0)
 
-/* SysTick constants */
-#define SYSTICK_ENABLE              0                                          /* Config-Bit to start or stop the SysTick Timer                         */
-#define SYSTICK_TICKINT             1                                          /* Config-Bit to enable or disable the SysTick interrupt                 */
-#define SYSTICK_CLKSOURCE           2                                          /* Clocksource has the offset 2 in SysTick Control and Status Register   */
-#define SYSTICK_MAXCOUNT       ((1&lt;&lt;24) -1)                                    /* SysTick MaxCount                                                      */
-
 /**
  * @brief  Initialize and start the SysTick counter and its interrupt.
  *
- * @param  uint32_t ticks is the number of ticks between two interrupts
- * @return  none
+ * @param   ticks   number of ticks between two interrupts
+ * @return  1 = failed, 0 = successful
  *
  * Initialise the system tick timer and its interrupt and start the
  * system tick timer / counter in free running mode to generate
@@ -1298,13 +1693,15 @@
  */
 static __INLINE uint32_t SysTick_Config(uint32_t ticks)
 {
-  if (ticks &gt; SYSTICK_MAXCOUNT)  return (1);                                             /* Reload value impossible */
+  if (ticks &gt; SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */
 
-  SysTick-&gt;LOAD  =  (ticks &amp; SYSTICK_MAXCOUNT) - 1;                                      /* set reload register */
-  NVIC_SetPriority (SysTick_IRQn, (1&lt;&lt;__NVIC_PRIO_BITS) - 1);                            /* set Priority for Cortex-M0 System Interrupts */
-  SysTick-&gt;VAL   =  (0x00);                                                              /* Load the SysTick Counter Value */
-  SysTick-&gt;CTRL = (1 &lt;&lt; SYSTICK_CLKSOURCE) | (1&lt;&lt;SYSTICK_ENABLE) | (1&lt;&lt;SYSTICK_TICKINT); /* Enable SysTick IRQ and SysTick Timer */
-  return (0);                                                                            /* Function successful */
+  SysTick-&gt;LOAD  = (ticks &amp; SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */
+  NVIC_SetPriority (SysTick_IRQn, (1&lt;&lt;__NVIC_PRIO_BITS) - 1);  /* set Priority for Cortex-M0 System Interrupts */
+  SysTick-&gt;VAL   = 0;                                          /* Load the SysTick Counter Value */
+  SysTick-&gt;CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
+                   SysTick_CTRL_TICKINT_Msk   |
+                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */
+  return (0);                                                  /* Function successful */
 }
 
 #endif
@@ -1312,33 +1709,45 @@
 
 
 
-
 /* ##################################    Reset function  ############################################ */
 
 /**
  * @brief  Initiate a system reset request.
  *
- * @param   none
- * @return  none
- *
- * Initialize a system reset request to reset the MCU
+ * Initiate a system reset request to reset the MCU
  */
 static __INLINE void NVIC_SystemReset(void)
 {
-  SCB-&gt;AIRCR  = (NVIC_AIRCR_VECTKEY | (SCB-&gt;AIRCR &amp; (0x700)) | (1&lt;&lt;NVIC_SYSRESETREQ)); /* Keep priority group unchanged */
-  __DSB();                                                                             /* Ensure completion of memory access */
-  while(1);                                                                            /* wait until reset */
+  SCB-&gt;AIRCR  = ((0x5FA &lt;&lt; SCB_AIRCR_VECTKEY_Pos)      |
+                 (SCB-&gt;AIRCR &amp; SCB_AIRCR_PRIGROUP_Msk) |
+                 SCB_AIRCR_SYSRESETREQ_Msk);                   /* Keep priority group unchanged */
+  __DSB();                                                     /* Ensure completion of memory access */
+  while(1);                                                    /* wait until reset */
 }
 
+/*@}*/ /* end of group CMSIS_CM3_Core_FunctionInterface */
 
-/* ##################################    Debug Output  function  ############################################ */
 
 
+/* ##################################### Debug In/Output function ########################################### */
+
+/** @addtogroup CMSIS_CM3_CoreDebugInterface CMSIS CM3 Core Debug Interface
+  Core Debug Interface containing:
+  - Core Debug Receive / Transmit Functions
+  - Core Debug Defines
+  - Core Debug Variables
+*/
+/*@{*/
+
+extern volatile int ITM_RxBuffer;                    /*!&lt; variable to receive characters                             */
+#define             ITM_RXBUFFER_EMPTY    0x5AA55AA5 /*!&lt; value identifying ITM_RxBuffer is ready for next character */
+
+
 /**
  * @brief  Outputs a character via the ITM channel 0
  *
- * @param   uint32_t character to output
- * @return  uint32_t input character
+ * @param  ch   character to output
+ * @return      character to output
  *
  * The function outputs a character via the ITM channel 0.
  * The function returns when no debugger is connected that has booked the output.
@@ -1346,11 +1755,9 @@
  */
 static __INLINE uint32_t ITM_SendChar (uint32_t ch)
 {
-  if (ch == '\n') ITM_SendChar('\r');
-
-  if ((CoreDebug-&gt;DEMCR &amp; CoreDebug_DEMCR_TRCENA)  &amp;&amp;
-      (ITM-&gt;TCR &amp; ITM_TCR_ITMENA)                  &amp;&amp;
-      (ITM-&gt;TER &amp; (1UL &lt;&lt; 0))  )
+  if ((CoreDebug-&gt;DEMCR &amp; CoreDebug_DEMCR_TRCENA_Msk)  &amp;&amp;      /* Trace enabled */
+      (ITM-&gt;TCR &amp; ITM_TCR_ITMENA_Msk)                  &amp;&amp;      /* ITM enabled */
+      (ITM-&gt;TER &amp; (1ul &lt;&lt; 0)        )                    )     /* ITM Port #0 enabled */
   {
     while (ITM-&gt;PORT[0].u32 == 0);
     ITM-&gt;PORT[0].u8 = (uint8_t) ch;
@@ -1358,10 +1765,54 @@
   return (ch);
 }
 
+
+/**
+ * @brief  Inputs a character via variable ITM_RxBuffer
+ *
+ * @return      received character, -1 = no character received
+ *
+ * The function inputs a character via variable ITM_RxBuffer.
+ * The function returns when no debugger is connected that has booked the output.
+ * It is blocking when a debugger is connected, but the previous character send is not transmitted.
+ */
+static __INLINE int ITM_ReceiveChar (void) {
+  int ch = -1;                               /* no character available */
+
+  if (ITM_RxBuffer != ITM_RXBUFFER_EMPTY) {
+    ch = ITM_RxBuffer;
+    ITM_RxBuffer = ITM_RXBUFFER_EMPTY;       /* ready for next character */
+  }
+
+  return (ch);
+}
+
+
+/**
+ * @brief  Check if a character via variable ITM_RxBuffer is available
+ *
+ * @return      1 = character available, 0 = no character available
+ *
+ * The function checks  variable ITM_RxBuffer whether a character is available or not.
+ * The function returns '1' if a character is available and '0' if no character is available.
+ */
+static __INLINE int ITM_CheckChar (void) {
+
+  if (ITM_RxBuffer == ITM_RXBUFFER_EMPTY) {
+    return (0);                                 /* no character available */
+  } else {
+    return (1);                                 /*    character available */
+  }
+}
+
+/*@}*/ /* end of group CMSIS_CM3_core_DebugInterface */
+
+
 #ifdef __cplusplus
 }
 #endif
 
+/*@}*/ /* end of group CMSIS_CM3_core_definitions */
+
 #endif /* __CM3_CORE_H__ */
 
 /*lint -restore */

Modified: trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_adc.h
===================================================================
--- trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_adc.h	2010-06-28 21:53:59 UTC (rev 759)
+++ trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_adc.h	2010-07-12 20:56:54 UTC (rev 760)
@@ -1,309 +1,299 @@
-/***********************************************************************//**
- * @file	: lpc17xx_adc.h
- * @brief	: Contains all macro definitions and function prototypes
- * 				support for ADC firmware library on LPC17xx
- * @version	: 1.0
- * @date	: 3. April. 2009
- * @author	: NgaDinh
- **************************************************************************
- * Software that is described herein is for illustrative purposes only
- * which provides customers with programming information regarding the
- * products. This software is supplied &quot;AS IS&quot; without any warranties.
- * NXP Semiconductors assumes no responsibility or liability for the
- * use of the software, conveys no license or title under any patent,
- * copyright, or mask work right to the product. NXP Semiconductors
- * reserves the right to make changes in the software without
- * notification. NXP Semiconductors also make no representation or
- * warranty that such application will be suitable for the specified
- * use without further testing or modification.
- **************************************************************************/
-
-/* Peripheral group ----------------------------------------------------------- */
-/** @defgroup ADC
- * @ingroup LPC1700CMSIS_FwLib_Drivers
- * @{
- */
-
-#ifndef LPC17XX_ADC_H_
-#define LPC17XX_ADC_H_
-
-/* Includes ------------------------------------------------------------------- */
-#include &quot;LPC17xx.h&quot;
-#include &quot;lpc_types.h&quot;
-
-
-#ifdef __cplusplus
-extern &quot;C&quot;
-{
-#endif
-
-
-/* Private Macros ------------------------------------------------------------- */
-/** @defgroup ADC_Private_Macros
- * @{
- */
-
-
-/** @defgroup ADC_REGISTER_BIT_DEFINITIONS
- * @{
- */
-
-/*********************************************************************//**
- * Macro defines for ADC  control register
- **********************************************************************/
-/**  Selects which of the AD0.0:7 pins is (are) to be sampled and converted */
-#define ADC_CR_CH_SEL(n)	((1UL &lt;&lt; n))
-/**  The APB clock (PCLK) is divided by (this value plus one)
-* to produce the clock for the A/D */
-#define ADC_CR_CLKDIV(n)	((n&lt;&lt;8))
-/**  Repeated conversions A/D enable bit */
-#define ADC_CR_BURST		((1UL&lt;&lt;16))
-/**  ADC convert in power down mode */
-#define ADC_CR_PDN			((1UL&lt;&lt;21))
-/**  Start mask bits */
-#define ADC_CR_START_MASK	((7UL&lt;&lt;24))
-/**  Select Start Mode */
-#define ADC_CR_START_MODE_SEL(SEL)	((SEL&lt;&lt;24))
-/**  Start conversion now */
-#define ADC_CR_START_NOW	((1UL&lt;&lt;24))
-/**  Start conversion when the edge selected by bit 27 occurs on P2.10/EINT0 */
-#define ADC_CR_START_EINT0	((2UL&lt;&lt;24))
-/** Start conversion when the edge selected by bit 27 occurs on P1.27/CAP0.1 */
-#define ADC_CR_START_CAP01	((3UL&lt;&lt;24))
-/**  Start conversion when the edge selected by bit 27 occurs on MAT0.1 */
-#define ADC_CR_START_MAT01	((4UL&lt;&lt;24))
-/**  Start conversion when the edge selected by bit 27 occurs on MAT0.3 */
-#define ADC_CR_START_MAT03	((5UL&lt;&lt;24))
-/**  Start conversion when the edge selected by bit 27 occurs on MAT1.0 */
-#define ADC_CR_START_MAT10	((6UL&lt;&lt;24))
-/**  Start conversion when the edge selected by bit 27 occurs on MAT1.1 */
-#define ADC_CR_START_MAT11	((7UL&lt;&lt;24))
-/**  Start conversion on a falling edge on the selected CAP/MAT signal */
-#define ADC_CR_EDGE			((1UL&lt;&lt;27))
-
-/*********************************************************************//**
- * Macro defines for ADC Global Data register
- **********************************************************************/
-/** When DONE is 1, this field contains result value of ADC conversion */
-#define ADC_GDR_RESULT(n)		(((n&gt;&gt;4)&amp;0xFFF))
-/** These bits contain the channel from which the LS bits were converted */
-#define ADC_GDR_CH(n)			(((n&gt;&gt;24)&amp;0x7))
-/** This bit is 1 in burst mode if the results of one or
- * more conversions was (were) lost */
-#define ADC_GDR_OVERRUN_FLAG	((1UL&lt;&lt;30))
-/** This bit is set to 1 when an A/D conversion completes */
-#define ADC_GDR_DONE_FLAG		((1UL&lt;&lt;31))
-
-/** This bits is used to mask for Channel */
-#define ADC_GDR_CH_MASK		((7UL&lt;&lt;24))
-/*********************************************************************//**
- * Macro defines for ADC Interrupt register
- **********************************************************************/
-/** These bits allow control over which A/D channels generate
- * interrupts for conversion completion */
-#define ADC_INTEN_CH(n)			((1UL&lt;&lt;n))
-/** When 1, enables the global DONE flag in ADDR to generate an interrupt */
-#define ADC_INTEN_GLOBAL		((1UL&lt;&lt;8))
-
-/*********************************************************************//**
- * Macro defines for ADC Data register
- **********************************************************************/
-/** When DONE is 1, this field contains result value of ADC conversion */
-#define ADC_DR_RESULT(n)		(((n&gt;&gt;4)&amp;0xFFF))
-/** These bits mirror the OVERRRUN status flags that appear in the
- * result register for each A/D channel */
-#define ADC_DR_OVERRUN_FLAG		((1UL&lt;&lt;30))
-/** This bit is set to 1 when an A/D conversion completes. It is cleared
- * when this register is read */
-#define ADC_DR_DONE_FLAG		((1UL&lt;&lt;31))
-
-/*********************************************************************//**
- * Macro defines for ADC Status register
-**********************************************************************/
-/** These bits mirror the DONE status flags that appear in the result
- * register for each A/D channel */
-#define ADC_STAT_CH_DONE_FLAG(n)		((n&amp;0xFF))
-/** These bits mirror the OVERRRUN status flags that appear in the
- * result register for each A/D channel */
-#define ADC_STAT_CH_OVERRUN_FLAG(n)		(((n&gt;&gt;8)&amp;0xFF))
-/** This bit is the A/D interrupt flag */
-#define ADC_STAT_INT_FLAG				((1UL&lt;&lt;16))
-
-/*********************************************************************//**
- * Macro defines for ADC Trim register
-**********************************************************************/
-/** Offset trim bits for ADC operation */
-#define ADC_ADCOFFS(n)		(((n&amp;0xF)&lt;&lt;4))
-/** Written to boot code*/
-#define ADC_TRIM(n)		    (((n&amp;0xF)&lt;&lt;8))
-
-/**
- * @}
- */
-
-/**
- * @}
- */
-
-
-/* Public Types --------------------------------------------------------------- */
-/** @defgroup ADC_Public_Types
- * @{
- */
-
-/*********************************************************************//**
- * @brief ADC enumeration
- **********************************************************************/
-/** @brief Channel Selection */
-typedef enum
-{
-	ADC_CHANNEL_0  = 0, /*!&lt;  Channel 0 */
-	ADC_CHANNEL_1,		/*!&lt;  Channel 1 */
-	ADC_CHANNEL_2,		/*!&lt;  Channel 2 */
-	ADC_CHANNEL_3,		/*!&lt;  Channel 3 */
-	ADC_CHANNEL_4,		/*!&lt;  Channel 4 */
-	ADC_CHANNEL_5,		/*!&lt;  Channel 5 */
-	ADC_CHANNEL_6,		/*!&lt;  Channel 6 */
-	ADC_CHANNEL_7		/*!&lt;  Channel 7 */
-}ADC_CHANNEL_SELECTION;
-
-
-
-/** @brief Type of start option */
-
-/** @brief Type of start option */
-
-typedef enum
-{
-	ADC_START_CONTINUOUS =0,	/*!&lt; Continuous mode */
-	ADC_START_NOW,				/*!&lt; Start conversion now */
-	ADC_START_ON_EINT0,			/*!&lt; Start conversion when the edge selected
-								 * by bit 27 occurs on P2.10/EINT0 */
-	ADC_START_ON_CAP01,			/*!&lt; Start conversion when the edge selected
-								 * by bit 27 occurs on P1.27/CAP0.1 */
-	ADC_START_ON_MAT01,			/*!&lt; Start conversion when the edge selected
-								 * by bit 27 occurs on MAT0.1 */
-	ADC_START_ON_MAT03,			/*!&lt; Start conversion when the edge selected
-								 * by bit 27 occurs on MAT0.3 */
-	ADC_START_ON_MAT10,			/*!&lt; Start conversion when the edge selected
-								  * by bit 27 occurs on MAT1.0 */
-	ADC_START_ON_MAT11			/*!&lt; Start conversion when the edge selected
-								  * by bit 27 occurs on MAT1.1 */
-} ADC_START_OPT;
-
-
-/** @brief Type of edge when start conversion on the selected CAP/MAT signal */
-
-typedef enum
-{
-	ADC_START_ON_RISING = 0,	/*!&lt; Start conversion on a rising edge
-								*on the selected CAP/MAT signal */
-	ADC_START_ON_FALLING		/*!&lt; Start conversion on a falling edge
-								*on the selected CAP/MAT signal */
-} ADC_START_ON_EDGE_OPT;
-
-/** @brief* ADC type interrupt enum */
-typedef enum
-{
-	ADC_ADINTEN0 = 0,		/*!&lt; Interrupt channel 0 */
-	ADC_ADINTEN1,			/*!&lt; Interrupt channel 1 */
-	ADC_ADINTEN2,			/*!&lt; Interrupt channel 2 */
-	ADC_ADINTEN3,			/*!&lt; Interrupt channel 3 */
-	ADC_ADINTEN4,			/*!&lt; Interrupt channel 4 */
-	ADC_ADINTEN5,			/*!&lt; Interrupt channel 5 */
-	ADC_ADINTEN6,			/*!&lt; Interrupt channel 6 */
-	ADC_ADINTEN7,			/*!&lt; Interrupt channel 7 */
-	ADC_ADGINTEN			/*!&lt; Individual channel/global flag done generate an interrupt */
-}ADC_TYPE_INT_OPT;
-
-/** Macro to determine if it is valid interrupt type */
-#define PARAM_ADC_TYPE_INT_OPT(OPT) ((OPT == ADC_ADINTEN0)||(OPT == ADC_ADINTEN1)\
-										||(OPT == ADC_ADINTEN2)||(OPT == ADC_ADINTEN3)\
-										||(OPT == ADC_ADINTEN4)||(OPT == ADC_ADINTEN5)\
-										||(OPT == ADC_ADINTEN6)||(OPT == ADC_ADINTEN7)\
-										||(OPT == ADC_ADGINTEN))
-
-
-/** @brief ADC Data  status */
-typedef enum
-{
-	ADC_DATA_BURST = 0,		/*Burst bit*/
-	ADC_DATA_DONE		 /*Done bit*/
-}ADC_DATA_STATUS;
-
-
-#define PARAM_ADC_START_ON_EDGE_OPT(OPT)	((OPT == ADC_START_ON_RISING)||(OPT == ADC_START_ON_FALLING))
-
-#define PARAM_ADC_DATA_STATUS(OPT) ((OPT== ADC_DATA_BURST)||(OPT== ADC_DATA_DONE))
-
-#define PARAM_ADC_FREQUENCY(FRE) (FRE &lt;= 13000000 )
-
-#define PARAM_ADC_CHANNEL_SELECTION(SEL)     ((SEL == ADC_CHANNEL_0)||(ADC_CHANNEL_1)\
-												||(SEL == ADC_CHANNEL_2)|(ADC_CHANNEL_3)\
-												||(SEL == ADC_CHANNEL_4)||(ADC_CHANNEL_5)\
-												||(SEL == ADC_CHANNEL_6)||(	ADC_CHANNEL_7))
-
-#define PARAM_ADC_START_OPT(OPT)	((OPT == ADC_START_CONTINUOUS)||(OPT == ADC_START_NOW)\
-										||(OPT == ADC_START_ON_EINT0)||(OPT == ADC_START_ON_CAP01)\
-										||(OPT == ADC_START_ON_MAT01)||(OPT == ADC_START_ON_MAT03)\
-										||(OPT == ADC_START_ON_MAT10)||(OPT == ADC_START_ON_MAT11))
-
-#define PARAM_ADC_TYPE_INT_OPT(OPT) ((OPT == ADC_ADINTEN0)||(OPT == ADC_ADINTEN1)\
-										||(OPT == ADC_ADINTEN2)||(OPT == ADC_ADINTEN3)\
-										||(OPT == ADC_ADINTEN4)||(OPT == ADC_ADINTEN5)\
-										||(OPT == ADC_ADINTEN6)||(OPT == ADC_ADINTEN7)\
-										||(OPT == ADC_ADGINTEN))
-
-#define PARAM_ADCx(n)	(((uint32_t *)n)==((uint32_t *)ADC))
-
-/**
- * @}
- */
-
-
-/* Public Macros -------------------------------------------------------------- */
-/** @defgroup ADC_Public_Macros
- * @{
- */
-
-/**
- * @}
- */
-
-
-
-/* Public Functions ----------------------------------------------------------- */
-/** @defgroup ADC_Public_Functions
- * @{
- */
-
-void ADC_Init(ADC_TypeDef *ADCx, uint32_t ConvFreq);
-void ADC_DeInit(ADC_TypeDef *ADCx);
-void ADC_BurstCmd(ADC_TypeDef *ADCx, FunctionalState NewState);
-void ADC_PowerdownCmd(ADC_TypeDef *ADCx, FunctionalState NewState);
-void ADC_StartCmd(ADC_TypeDef *ADCx, uint8_t start_mode);
-void ADC_EdgeStartConfig(ADC_TypeDef *ADCx, uint8_t EdgeOption);
-void ADC_IntConfig (ADC_TypeDef *ADCx, ADC_TYPE_INT_OPT IntType, FunctionalState NewState);
-void ADC_ChannelCmd (ADC_TypeDef *ADCx, uint8_t Channel, FunctionalState NewState);
-uint16_t ADC_ChannelGetData(ADC_TypeDef *ADCx, uint8_t channel);
-FlagStatus ADC_ChannelGetStatus(ADC_TypeDef *ADCx, uint8_t channel, uint32_t StatusType);
-uint16_t ADC_GlobalGetData(ADC_TypeDef *ADCx, uint8_t channel);
-FlagStatus	ADC_GlobalGetStatus(ADC_TypeDef *ADCx, uint32_t StatusType);
-
-/**
- * @}
- */
-
-
-#ifdef __cplusplus
-}
-#endif
-
-
-#endif /* LPC17XX_ADC_H_ */
-
-/**
- * @}
- */
-
-/* --------------------------------- End Of File ------------------------------ */
+/***********************************************************************//**
+ * @file	: lpc17xx_adc.h
+ * @brief	: Contains all macro definitions and function prototypes
+ * 				support for ADC firmware library on LPC17xx
+ * @version	: 1.0
+ * @date	: 3. April. 2009
+ * @author	: NgaDinh
+ **************************************************************************
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * products. This software is supplied &quot;AS IS&quot; without any warranties.
+ * NXP Semiconductors assumes no responsibility or liability for the
+ * use of the software, conveys no license or title under any patent,
+ * copyright, or mask work right to the product. NXP Semiconductors
+ * reserves the right to make changes in the software without
+ * notification. NXP Semiconductors also make no representation or
+ * warranty that such application will be suitable for the specified
+ * use without further testing or modification.
+ **************************************************************************/
+
+/* Peripheral group ----------------------------------------------------------- */
+/** @defgroup ADC
+ * @ingroup LPC1700CMSIS_FwLib_Drivers
+ * @{
+ */
+
+#ifndef LPC17XX_ADC_H_
+#define LPC17XX_ADC_H_
+
+/* Includes ------------------------------------------------------------------- */
+#include &quot;LPC17xx.h&quot;
+#include &quot;lpc_types.h&quot;
+
+
+#ifdef __cplusplus
+extern &quot;C&quot;
+{
+#endif
+
+
+/* Private Macros ------------------------------------------------------------- */
+/** @defgroup ADC_Private_Macros ADC_Private_Macros
+ * @{
+ */
+
+
+/** @defgroup group3 ADC_REGISTER_BIT_DEFINITIONS
+ * @{
+ */
+
+/*********************************************************************//**
+ * Macro defines for ADC  control register
+ **********************************************************************/
+/**  Selects which of the AD0.0:7 pins is (are) to be sampled and converted */
+#define ADC_CR_CH_SEL(n)	((1UL &lt;&lt; n))
+/**  The APB clock (PCLK) is divided by (this value plus one)
+* to produce the clock for the A/D */
+#define ADC_CR_CLKDIV(n)	((n&lt;&lt;8))
+/**  Repeated conversions A/D enable bit */
+#define ADC_CR_BURST		((1UL&lt;&lt;16))
+/**  ADC convert in power down mode */
+#define ADC_CR_PDN			((1UL&lt;&lt;21))
+/**  Start mask bits */
+#define ADC_CR_START_MASK	((7UL&lt;&lt;24))
+/**  Select Start Mode */
+#define ADC_CR_START_MODE_SEL(SEL)	((SEL&lt;&lt;24))
+/**  Start conversion now */
+#define ADC_CR_START_NOW	((1UL&lt;&lt;24))
+/**  Start conversion when the edge selected by bit 27 occurs on P2.10/EINT0 */
+#define ADC_CR_START_EINT0	((2UL&lt;&lt;24))
+/** Start conversion when the edge selected by bit 27 occurs on P1.27/CAP0.1 */
+#define ADC_CR_START_CAP01	((3UL&lt;&lt;24))
+/**  Start conversion when the edge selected by bit 27 occurs on MAT0.1 */
+#define ADC_CR_START_MAT01	((4UL&lt;&lt;24))
+/**  Start conversion when the edge selected by bit 27 occurs on MAT0.3 */
+#define ADC_CR_START_MAT03	((5UL&lt;&lt;24))
+/**  Start conversion when the edge selected by bit 27 occurs on MAT1.0 */
+#define ADC_CR_START_MAT10	((6UL&lt;&lt;24))
+/**  Start conversion when the edge selected by bit 27 occurs on MAT1.1 */
+#define ADC_CR_START_MAT11	((7UL&lt;&lt;24))
+/**  Start conversion on a falling edge on the selected CAP/MAT signal */
+#define ADC_CR_EDGE			((1UL&lt;&lt;27))
+
+/*********************************************************************//**
+ * Macro defines for ADC Global Data register
+ **********************************************************************/
+/** When DONE is 1, this field contains result value of ADC conversion */
+#define ADC_GDR_RESULT(n)		(((n&gt;&gt;4)&amp;0xFFF))
+/** These bits contain the channel from which the LS bits were converted */
+#define ADC_GDR_CH(n)			(((n&gt;&gt;24)&amp;0x7))
+/** This bit is 1 in burst mode if the results of one or
+ * more conversions was (were) lost */
+#define ADC_GDR_OVERRUN_FLAG	((1UL&lt;&lt;30))
+/** This bit is set to 1 when an A/D conversion completes */
+#define ADC_GDR_DONE_FLAG		((1UL&lt;&lt;31))
+
+/** This bits is used to mask for Channel */
+#define ADC_GDR_CH_MASK		((7UL&lt;&lt;24))
+/*********************************************************************//**
+ * Macro defines for ADC Interrupt register
+ **********************************************************************/
+/** These bits allow control over which A/D channels generate
+ * interrupts for conversion completion */
+#define ADC_INTEN_CH(n)			((1UL&lt;&lt;n))
+/** When 1, enables the global DONE flag in ADDR to generate an interrupt */
+#define ADC_INTEN_GLOBAL		((1UL&lt;&lt;8))
+
+/*********************************************************************//**
+ * Macro defines for ADC Data register
+ **********************************************************************/
+/** When DONE is 1, this field contains result value of ADC conversion */
+#define ADC_DR_RESULT(n)		(((n&gt;&gt;4)&amp;0xFFF))
+/** These bits mirror the OVERRRUN status flags that appear in the
+ * result register for each A/D channel */
+#define ADC_DR_OVERRUN_FLAG		((1UL&lt;&lt;30))
+/** This bit is set to 1 when an A/D conversion completes. It is cleared
+ * when this register is read */
+#define ADC_DR_DONE_FLAG		((1UL&lt;&lt;31))
+
+/*********************************************************************//**
+ * Macro defines for ADC Status register
+**********************************************************************/
+/** These bits mirror the DONE status flags that appear in the result
+ * register for each A/D channel */
+#define ADC_STAT_CH_DONE_FLAG(n)		((n&amp;0xFF))
+/** These bits mirror the OVERRRUN status flags that appear in the
+ * result register for each A/D channel */
+#define ADC_STAT_CH_OVERRUN_FLAG(n)		(((n&gt;&gt;8)&amp;0xFF))
+/** This bit is the A/D interrupt flag */
+#define ADC_STAT_INT_FLAG				((1UL&lt;&lt;16))
+
+/*********************************************************************//**
+ * Macro defines for ADC Trim register
+**********************************************************************/
+/** Offset trim bits for ADC operation */
+#define ADC_ADCOFFS(n)		(((n&amp;0xF)&lt;&lt;4))
+/** Written to boot code*/
+#define ADC_TRIM(n)		    (((n&amp;0xF)&lt;&lt;8))
+
+/**
+ * @}
+ */
+
+/**
+ * @}
+ */
+
+
+/* Public Types --------------------------------------------------------------- */
+/** @defgroup ADC_Public_Types
+ * @{
+ */
+
+/*********************************************************************//**
+ * @brief ADC enumeration
+ **********************************************************************/
+/** @brief Channel Selection */
+typedef enum
+{
+	ADC_CHANNEL_0  = 0, /*!&lt;  Channel 0 */
+	ADC_CHANNEL_1,		/*!&lt;  Channel 1 */
+	ADC_CHANNEL_2,		/*!&lt;  Channel 2 */
+	ADC_CHANNEL_3,		/*!&lt;  Channel 3 */
+	ADC_CHANNEL_4,		/*!&lt;  Channel 4 */
+	ADC_CHANNEL_5,		/*!&lt;  Channel 5 */
+	ADC_CHANNEL_6,		/*!&lt;  Channel 6 */
+	ADC_CHANNEL_7		/*!&lt;  Channel 7 */
+}ADC_CHANNEL_SELECTION;
+
+
+
+/** @brief Type of start option */
+
+/** @brief Type of start option */
+
+typedef enum
+{
+	ADC_START_CONTINUOUS =0,	/*!&lt; Continuous mode */
+	ADC_START_NOW,				/*!&lt; Start conversion now */
+	ADC_START_ON_EINT0,			/*!&lt; Start conversion when the edge selected
+								 * by bit 27 occurs on P2.10/EINT0 */
+	ADC_START_ON_CAP01,			/*!&lt; Start conversion when the edge selected
+								 * by bit 27 occurs on P1.27/CAP0.1 */
+	ADC_START_ON_MAT01,			/*!&lt; Start conversion when the edge selected
+								 * by bit 27 occurs on MAT0.1 */
+	ADC_START_ON_MAT03,			/*!&lt; Start conversion when the edge selected
+								 * by bit 27 occurs on MAT0.3 */
+	ADC_START_ON_MAT10,			/*!&lt; Start conversion when the edge selected
+								  * by bit 27 occurs on MAT1.0 */
+	ADC_START_ON_MAT11			/*!&lt; Start conversion when the edge selected
+								  * by bit 27 occurs on MAT1.1 */
+} ADC_START_OPT;
+
+
+/** @brief Type of edge when start conversion on the selected CAP/MAT signal */
+
+typedef enum
+{
+	ADC_START_ON_RISING = 0,	/*!&lt; Start conversion on a rising edge
+								*on the selected CAP/MAT signal */
+	ADC_START_ON_FALLING		/*!&lt; Start conversion on a falling edge
+								*on the selected CAP/MAT signal */
+} ADC_START_ON_EDGE_OPT;
+
+/** @brief* ADC type interrupt enum */
+typedef enum
+{
+	ADC_ADINTEN0 = 0,		/*!&lt; Interrupt channel 0 */
+	ADC_ADINTEN1,			/*!&lt; Interrupt channel 1 */
+	ADC_ADINTEN2,			/*!&lt; Interrupt channel 2 */
+	ADC_ADINTEN3,			/*!&lt; Interrupt channel 3 */
+	ADC_ADINTEN4,			/*!&lt; Interrupt channel 4 */
+	ADC_ADINTEN5,			/*!&lt; Interrupt channel 5 */
+	ADC_ADINTEN6,			/*!&lt; Interrupt channel 6 */
+	ADC_ADINTEN7,			/*!&lt; Interrupt channel 7 */
+	ADC_ADGINTEN			/*!&lt; Individual channel/global flag done generate an interrupt */
+}ADC_TYPE_INT_OPT;
+
+/** Macro to determine if it is valid interrupt type */
+#define PARAM_ADC_TYPE_INT_OPT(OPT) ((OPT == ADC_ADINTEN0)||(OPT == ADC_ADINTEN1)\
+||(OPT == ADC_ADINTEN2)||(OPT == ADC_ADINTEN3)\
+||(OPT == ADC_ADINTEN4)||(OPT == ADC_ADINTEN5)\
+||(OPT == ADC_ADINTEN6)||(OPT == ADC_ADINTEN7)\
+||(OPT == ADC_ADGINTEN))
+
+
+/** @brief ADC Data  status */
+typedef enum
+{
+	ADC_DATA_BURST = 0,		/*Burst bit*/
+	ADC_DATA_DONE		 /*Done bit*/
+}ADC_DATA_STATUS;
+
+
+#define PARAM_ADC_START_ON_EDGE_OPT(OPT)	((OPT == ADC_START_ON_RISING)||(OPT == ADC_START_ON_FALLING))
+
+#define PARAM_ADC_DATA_STATUS(OPT)	((OPT== ADC_DATA_BURST)||(OPT== ADC_DATA_DONE))
+
+#define PARAM_ADC_FREQUENCY(FRE) (FRE &lt;= 13000000 )
+
+#define PARAM_ADC_CHANNEL_SELECTION(SEL)     ((SEL == ADC_CHANNEL_0)||(ADC_CHANNEL_1)\
+||(SEL == ADC_CHANNEL_2)|(ADC_CHANNEL_3)\
+||(SEL == ADC_CHANNEL_4)||(ADC_CHANNEL_5)\
+||(SEL == ADC_CHANNEL_6)||(ADC_CHANNEL_7))
+
+#define PARAM_ADC_START_OPT(OPT)	((OPT == ADC_START_CONTINUOUS)||(OPT == ADC_START_NOW)\
+||(OPT == ADC_START_ON_EINT0)||(OPT == ADC_START_ON_CAP01)\
+||(OPT == ADC_START_ON_MAT01)||(OPT == ADC_START_ON_MAT03)\
+||(OPT == ADC_START_ON_MAT10)||(OPT == ADC_START_ON_MAT11))
+
+#define PARAM_ADC_TYPE_INT_OPT(OPT) ((OPT == ADC_ADINTEN0)||(OPT == ADC_ADINTEN1)\
+||(OPT == ADC_ADINTEN2)||(OPT == ADC_ADINTEN3)\
+||(OPT == ADC_ADINTEN4)||(OPT == ADC_ADINTEN5)\
+||(OPT == ADC_ADINTEN6)||(OPT == ADC_ADINTEN7)\
+||(OPT == ADC_ADGINTEN))
+
+#define PARAM_ADCx(n)	(((uint32_t *)n)==((uint32_t *)LPC_ADC))
+
+/**
+ * @}
+ */
+
+
+
+/* Public Functions ----------------------------------------------------------- */
+/** @defgroup ADC_Public_Functions
+ * @{
+ */
+
+void ADC_Init(LPC_ADC_TypeDef *ADCx, uint32_t ConvFreq);
+void ADC_DeInit(LPC_ADC_TypeDef *ADCx);
+void ADC_BurstCmd(LPC_ADC_TypeDef *ADCx, FunctionalState NewState);
+void ADC_PowerdownCmd(LPC_ADC_TypeDef *ADCx, FunctionalState NewState);
+void ADC_StartCmd(LPC_ADC_TypeDef *ADCx, uint8_t start_mode);
+void ADC_EdgeStartConfig(LPC_ADC_TypeDef *ADCx, uint8_t EdgeOption);
+void ADC_IntConfig (LPC_ADC_TypeDef *ADCx, ADC_TYPE_INT_OPT IntType, FunctionalState NewState);
+void ADC_ChannelCmd (LPC_ADC_TypeDef *ADCx, uint8_t Channel, FunctionalState NewState);
+uint16_t ADC_ChannelGetData(LPC_ADC_TypeDef *ADCx, uint8_t channel);
+FlagStatus ADC_ChannelGetStatus(LPC_ADC_TypeDef *ADCx, uint8_t channel, uint32_t StatusType);
+uint16_t ADC_GlobalGetData(LPC_ADC_TypeDef *ADCx, uint8_t channel);
+FlagStatus	ADC_GlobalGetStatus(LPC_ADC_TypeDef *ADCx, uint32_t StatusType);
+
+/**
+ * @}
+ */
+
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif /* LPC17XX_ADC_H_ */
+
+/**
+ * @}
+ */
+
+/* --------------------------------- End Of File ------------------------------ */


Property changes on: trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_adc.h
___________________________________________________________________
Deleted: svn:executable
   - *

Modified: trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_can.h
===================================================================
--- trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_can.h	2010-06-28 21:53:59 UTC (rev 759)
+++ trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_can.h	2010-07-12 20:56:54 UTC (rev 760)
@@ -1,854 +1,855 @@
-/***********************************************************************//**
- * @file	: lpc17xx_can.h
- * @brief	: Contains all macro definitions and function prototypes
- * 				support for CAN firmware library on LPC17xx
- * @version	: 1.0
- * @date	: 1.June.2009
- * @author	: NguyenCao
- **************************************************************************
- * Software that is described herein is for illustrative purposes only
- * which provides customers with programming information regarding the
- * products. This software is supplied &quot;AS IS&quot; without any warranties.
- * NXP Semiconductors assumes no responsibility or liability for the
- * use of the software, conveys no license or title under any patent,
- * copyright, or mask work right to the product. NXP Semiconductors
- * reserves the right to make changes in the software without
- * notification. NXP Semiconductors also make no representation or
- * warranty that such application will be suitable for the specified
- * use without further testing or modification.
- **************************************************************************/
-
-/* Peripheral group ----------------------------------------------------------- */
-/** @defgroup CAN
- * @ingroup LPC1700CMSIS_FwLib_Drivers
- * @{
- */
-
-#ifndef LPC17XX_CAN_H_
-#define LPC17XX_CAN_H_
-
-/* Includes ------------------------------------------------------------------- */
-#include &quot;LPC17xx.h&quot;
-#include &quot;lpc_types.h&quot;
-
-#ifdef __cplusplus
-extern &quot;C&quot;
-{
-#endif
-
-
-/* Private Macros ------------------------------------------------------------- */
-/** @defgroup CAN_Private_Macros
- * @{
- */
-
-#define ID_11	1
-#define MAX_HW_FULLCAN_OBJ 		64
-#define MAX_SW_FULLCAN_OBJ 		32
-
-
-/** @defgroup CAN_REGISTER_BIT_DEFINITION
- * @{
- */
-
-/** CAN Reset mode */
-#define CAN_MOD_RM			((uint32_t)(1))
-/** CAN Listen Only Mode */
-#define CAN_MOD_LOM			((uint32_t)(1&lt;&lt;1))
-/** CAN Self Test mode */
-#define CAN_MOD_STM			((uint32_t)(1&lt;&lt;2))
-/** CAN Transmit Priority mode */
-#define CAN_MOD_TPM			((uint32_t)(1&lt;&lt;3))
-/** CAN Sleep mode */
-#define CAN_MOD_SM			((uint32_t)(1&lt;&lt;4))
-/** CAN Receive Polarity mode */
-#define CAN_MOD_RPM			((uint32_t)(1&lt;&lt;5))
-/** CAN Test mode */
-#define CAN_MOD_TM			((uint32_t)(1&lt;&lt;7))
-/*********************************************************************//**
- * Macro defines for CAN Command Register
- **********************************************************************/
-/** CAN Transmission Request */
-#define CAN_CMR_TR			((uint32_t)(1))
-/** CAN Abort Transmission */
-#define CAN_CMR_AT			((uint32_t)(1&lt;&lt;1))
-/** CAN Release Receive Buffer */
-#define CAN_CMR_RRB			((uint32_t)(1&lt;&lt;2))
-/** CAN Clear Data Overrun */
-#define CAN_CMR_CDO			((uint32_t)(1&lt;&lt;3))
-/** CAN Self Reception Request */
-#define CAN_CMR_SRR			((uint32_t)(1&lt;&lt;4))
-/** CAN Select Tx Buffer 1 */
-#define CAN_CMR_STB1		((uint32_t)(1&lt;&lt;5))
-/** CAN Select Tx Buffer 2 */
-#define CAN_CMR_STB2		((uint32_t)(1&lt;&lt;6))
-/** CAN Select Tx Buffer 3 */
-#define CAN_CMR_STB3		((uint32_t)(1&lt;&lt;7))
-
-/*********************************************************************//**
- * Macro defines for CAN Global Status Register
- **********************************************************************/
-/** CAN Receive Buffer Status */
-#define CAN_GSR_RBS			((uint32_t)(1))
-/** CAN Data Overrun Status */
-#define CAN_GSR_DOS			((uint32_t)(1&lt;&lt;1))
-/** CAN Transmit Buffer Status */
-#define CAN_GSR_TBS			((uint32_t)(1&lt;&lt;2))
-/** CAN Transmit Complete Status */
-#define CAN_GSR_TCS			((uint32_t)(1&lt;&lt;3))
-/** CAN Receive Status */
-#define CAN_GSR_RS			((uint32_t)(1&lt;&lt;4))
-/** CAN Transmit Status */
-#define CAN_GSR_TS			((uint32_t)(1&lt;&lt;5))
-/** CAN Error Status */
-#define CAN_GSR_ES			((uint32_t)(1&lt;&lt;6))
-/** CAN Bus Status */
-#define CAN_GSR_BS			((uint32_t)(1&lt;&lt;7))
-/** CAN Current value of the Rx Error Counter */
-#define CAN_GSR_RXERR(n)	((uint32_t)((n&amp;0xFF)&lt;&lt;16))
-/** CAN Current value of the Tx Error Counter */
-#define CAN_GSR_TXERR(n)	((uint32_t)(n&amp;0xFF)&lt;&lt;24))
-
-/*********************************************************************//**
- * Macro defines for CAN Interrupt and Capture Register
- **********************************************************************/
-/** CAN Receive Interrupt */
-#define CAN_ICR_RI			((uint32_t)(1))
-/** CAN Transmit Interrupt 1 */
-#define CAN_ICR_TI1			((uint32_t)(1&lt;&lt;1))
-/** CAN Error Warning Interrupt */
-#define CAN_ICR_EI			((uint32_t)(1&lt;&lt;2))
-/** CAN Data Overrun Interrupt */
-#define CAN_ICR_DOI			((uint32_t)(1&lt;&lt;3))
-/** CAN Wake-Up Interrupt */
-#define CAN_ICR_WUI			((uint32_t)(1&lt;&lt;4))
-/** CAN Error Passive Interrupt */
-#define CAN_ICR_EPI			((uint32_t)(1&lt;&lt;5))
-/** CAN Arbitration Lost Interrupt */
-#define CAN_ICR_ALI			((uint32_t)(1&lt;&lt;6))
-/** CAN Bus Error Interrupt */
-#define CAN_ICR_BEI			((uint32_t)(1&lt;&lt;7))
-/** CAN ID Ready Interrupt */
-#define CAN_ICR_IDI			((uint32_t)(1&lt;&lt;8))
-/** CAN Transmit Interrupt 2 */
-#define CAN_ICR_TI2			((uint32_t)(1&lt;&lt;9))
-/** CAN Transmit Interrupt 3 */
-#define CAN_ICR_TI3			((uint32_t)(1&lt;&lt;10))
-/** CAN Error Code Capture */
-#define CAN_ICR_ERRBIT(n)	((uint32_t)((n&amp;0x1F)&lt;&lt;16))
-/** CAN Error Direction */
-#define CAN_ICR_ERRDIR		((uint32_t)(1&lt;&lt;21))
-/** CAN Error Capture */
-#define CAN_ICR_ERRC(n)		((uint32_t)((n&amp;0x3)&lt;&lt;22))
-/** CAN Arbitration Lost Capture */
-#define CAN_ICR_ALCBIT(n)		((uint32_t)((n&amp;0xFF)&lt;&lt;24))
-
-/*********************************************************************//**
- * Macro defines for CAN Interrupt Enable Register
- **********************************************************************/
-/** CAN Receive Interrupt Enable */
-#define CAN_IER_RIE			((uint32_t)(1))
-/** CAN Transmit Interrupt Enable for buffer 1 */
-#define CAN_IER_TIE1		((uint32_t)(1&lt;&lt;1))
-/** CAN Error Warning Interrupt Enable */
-#define CAN_IER_EIE			((uint32_t)(1&lt;&lt;2))
-/** CAN Data Overrun Interrupt Enable */
-#define CAN_IER_DOIE		((uint32_t)(1&lt;&lt;3))
-/** CAN Wake-Up Interrupt Enable */
-#define CAN_IER_WUIE		((uint32_t)(1&lt;&lt;4))
-/** CAN Error Passive Interrupt Enable */
-#define CAN_IER_EPIE		((uint32_t)(1&lt;&lt;5))
-/** CAN Arbitration Lost Interrupt Enable */
-#define CAN_IER_ALIE		((uint32_t)(1&lt;&lt;6))
-/** CAN Bus Error Interrupt Enable */
-#define CAN_IER_BEIE		((uint32_t)(1&lt;&lt;7))
-/** CAN ID Ready Interrupt Enable */
-#define CAN_IER_IDIE		((uint32_t)(1&lt;&lt;8))
-/** CAN Transmit Enable Interrupt for Buffer 2 */
-#define CAN_IER_TIE2		((uint32_t)(1&lt;&lt;9))
-/** CAN Transmit Enable Interrupt for Buffer 3 */
-#define CAN_IER_TIE3		((uint32_t)(1&lt;&lt;10))
-
-/*********************************************************************//**
- * Macro defines for CAN Bus Timing Register
- **********************************************************************/
-/** CAN Baudrate Prescaler */
-#define CAN_BTR_BRP(n)		((uint32_t)(n&amp;0x3FF))
-/** CAN Synchronization Jump Width */
-#define CAN_BTR_SJM(n)		((uint32_t)((n&amp;0x3)&lt;&lt;14))
-/** CAN Time Segment 1 */
-#define CAN_BTR_TESG1(n)	((uint32_t)(n&amp;0xF)&lt;&lt;16))
-/** CAN Time Segment 2 */
-#define CAN_BTR_TESG2(n)	((uint32_t)(n&amp;0xF)&lt;&lt;20))
-/** CAN Sampling */
-#define CAN_BTR_SAM(n)		((uint32_t)(1&lt;&lt;23))
-
-/*********************************************************************//**
- * Macro defines for CAN Error Warning Limit Register
- **********************************************************************/
-/** CAN Error Warning Limit */
-#define CAN_EWL_EWL(n)		((uint32_t)(n&amp;0xFF))
-
-/*********************************************************************//**
- * Macro defines for CAN Status Register
- **********************************************************************/
-/** CAN Receive Buffer Status */
-#define CAN_SR_RBS		((uint32_t)(1))
-/** CAN Data Overrun Status */
-#define CAN_SR_DOS		((uint32_t)(1&lt;&lt;1))
-/** CAN Transmit Buffer Status 1 */
-#define CAN_SR_TBS1		((uint32_t)(1&lt;&lt;2))
-/** CAN Transmission Complete Status of Buffer 1 */
-#define CAN_SR_TCS1		((uint32_t)(1&lt;&lt;3))
-/** CAN Receive Status */
-#define CAN_SR_RS		((uint32_t)(1&lt;&lt;4))
-/** CAN Transmit Status 1 */
-#define CAN_SR_TS1		((uint32_t)(1&lt;&lt;5))
-/** CAN Error Status */
-#define CAN_SR_ES		((uint32_t)(1&lt;&lt;6))
-/** CAN Bus Status */
-#define CAN_SR_BS		((uint32_t)(1&lt;&lt;7))
-/** CAN Transmit Buffer Status 2 */
-#define CAN_SR_TBS2		((uint32_t)(1&lt;&lt;10))
-/** CAN Transmission Complete Status of Buffer 2 */
-#define CAN_SR_TCS2		((uint32_t)(1&lt;&lt;11))
-/** CAN Transmit Status 2 */
-#define CAN_SR_TS2		((uint32_t)(1&lt;&lt;13))
-/** CAN Transmit Buffer Status 2 */
-#define CAN_SR_TBS3		((uint32_t)(1&lt;&lt;18))
-/** CAN Transmission Complete Status of Buffer 2 */
-#define CAN_SR_TCS3		((uint32_t)(1&lt;&lt;19))
-/** CAN Transmit Status 2 */
-#define CAN_SR_TS3		((uint32_t)(1&lt;&lt;21))
-
-/*********************************************************************//**
- * Macro defines for CAN Receive Frame Status Register
- **********************************************************************/
-/** CAN ID Index */
-#define CAN_RFS_ID_INDEX(n)	((uint32_t)(n&amp;0x3FF))
-/** CAN Bypass */
-#define CAN_RFS_BP			((uint32_t)(1&lt;&lt;10))
-/** CAN Data Length Code */
-#define CAN_RFS_DLC(n)		((uint32_t)((n&amp;0xF)&lt;&lt;16)
-/** CAN Remote Transmission Request */
-#define CAN_RFS_RTR			((uint32_t)(1&lt;&lt;30))
-/** CAN control 11 bit or 29 bit Identifier */
-#define CAN_RFS_FF			((uint32_t)(1&lt;&lt;31))
-
-/*********************************************************************//**
- * Macro defines for CAN Receive Identifier Register
- **********************************************************************/
-/** CAN 11 bit Identifier */
-#define CAN_RID_ID_11(n)		((uint32_t)(n&amp;0x7FF))
-/** CAN 29 bit Identifier */
-#define CAN_RID_ID_29(n)		((uint32_t)(n&amp;0x1FFFFFFF))
-
-/*********************************************************************//**
- * Macro defines for CAN Receive Data A Register
- **********************************************************************/
-/** CAN Receive Data 1 */
-#define CAN_RDA_DATA1(n)		((uint32_t)(n&amp;0xFF))
-/** CAN Receive Data 2 */
-#define CAN_RDA_DATA2(n)		((uint32_t)((n&amp;0xFF)&lt;&lt;8))
-/** CAN Receive Data 3 */
-#define CAN_RDA_DATA3(n)		((uint32_t)((n&amp;0xFF)&lt;&lt;16))
-/** CAN Receive Data 4 */
-#define CAN_RDA_DATA4(n)		((uint32_t)((n&amp;0xFF)&lt;&lt;24))
-
-/*********************************************************************//**
- * Macro defines for CAN Receive Data B Register
- **********************************************************************/
-/** CAN Receive Data 5 */
-#define CAN_RDB_DATA5(n)		((uint32_t)(n&amp;0xFF))
-/** CAN Receive Data 6 */
-#define CAN_RDB_DATA6(n)		((uint32_t)((n&amp;0xFF)&lt;&lt;8))
-/** CAN Receive Data 7 */
-#define CAN_RDB_DATA7(n)		((uint32_t)((n&amp;0xFF)&lt;&lt;16))
-/** CAN Receive Data 8 */
-#define CAN_RDB_DATA8(n)		((uint32_t)((n&amp;0xFF)&lt;&lt;24))
-
-/*********************************************************************//**
- * Macro defines for CAN Transmit Frame Information Register
- **********************************************************************/
-/** CAN Priority */
-#define CAN_TFI_PRIO(n)			((uint32_t)(n&amp;0xFF))
-/** CAN Data Length Code */
-#define CAN_TFI_DLC(n)			((uint32_t)((n&amp;0xF)&lt;&lt;16))
-/** CAN Remote Frame Transmission */
-#define CAN_TFI_RTR				((uint32_t)(1&lt;&lt;30))
-/** CAN control 11-bit or 29-bit Identifier */
-#define CAN_TFI_FF				((uint32_t)(1&lt;&lt;31))
-
-/*********************************************************************//**
- * Macro defines for CAN Transmit Identifier Register
- **********************************************************************/
-/** CAN 11-bit Identifier */
-#define CAN_TID_ID11(n)			((uint32_t)(n&amp;0x7FF))
-/** CAN 11-bit Identifier */
-#define CAN_TID_ID29(n)			((uint32_t)(n&amp;0x1FFFFFFF))
-
-/*********************************************************************//**
- * Macro defines for CAN Transmit Data A Register
- **********************************************************************/
-/** CAN Transmit Data 1 */
-#define CAN_TDA_DATA1(n)		((uint32_t)(n&amp;0xFF))
-/** CAN Transmit Data 2 */
-#define CAN_TDA_DATA2(n)		((uint32_t)((n&amp;0xFF)&lt;&lt;8))
-/** CAN Transmit Data 3 */
-#define CAN_TDA_DATA3(n)		((uint32_t)((n&amp;0xFF)&lt;&lt;16))
-/** CAN Transmit Data 4 */
-#define CAN_TDA_DATA4(n)		((uint32_t)((n&amp;0xFF)&lt;&lt;24))
-
-/*********************************************************************//**
- * Macro defines for CAN Transmit Data B Register
- **********************************************************************/
-/** CAN Transmit Data 5 */
-#define CAN_TDA_DATA5(n)		((uint32_t)(n&amp;0xFF))
-/** CAN Transmit Data 6 */
-#define CAN_TDA_DATA6(n)		((uint32_t)((n&amp;0xFF)&lt;&lt;8))
-/** CAN Transmit Data 7 */
-#define CAN_TDA_DATA7(n)		((uint32_t)((n&amp;0xFF)&lt;&lt;16))
-/** CAN Transmit Data 8 */
-#define CAN_TDA_DATA8(n)		((uint32_t)((n&amp;0xFF)&lt;&lt;24))
-
-/*********************************************************************//**
- * Macro defines for CAN Sleep Clear Register
- **********************************************************************/
-/** CAN1 Sleep mode */
-#define CAN1SLEEPCLR			((uint32_t)(1&lt;&lt;1))
-/** CAN2 Sleep Mode */
-#define CAN2SLEEPCLR			((uint32_t)(1&lt;&lt;2))
-
-/*********************************************************************//**
- * Macro defines for CAN Wake up Flags Register
- **********************************************************************/
-/** CAN1 Sleep mode */
-#define CAN_WAKEFLAGES_CAN1WAKE		((uint32_t)(1&lt;&lt;1))
-/** CAN2 Sleep Mode */
-#define CAN_WAKEFLAGES_CAN2WAKE		((uint32_t)(1&lt;&lt;2))
-
-/*********************************************************************//**
- * Macro defines for Central transmit Status Register
- **********************************************************************/
-/** CAN Transmit 1 */
-#define CAN_TSR_TS1			((uint32_t)(1))
-/** CAN Transmit 2 */
-#define CAN_TSR_TS2			((uint32_t)(1&lt;&lt;1))
-/** CAN Transmit Buffer Status 1 */
-#define CAN_TSR_TBS1			((uint32_t)(1&lt;&lt;8))
-/** CAN Transmit Buffer Status 2 */
-#define CAN_TSR_TBS2			((uint32_t)(1&lt;&lt;9))
-/** CAN Transmission Complete Status 1 */
-#define CAN_TSR_TCS1			((uint32_t)(1&lt;&lt;16))
-/** CAN Transmission Complete Status 2 */
-#define CAN_TSR_TCS2			((uint32_t)(1&lt;&lt;17))
-
-/*********************************************************************//**
- * Macro defines for Central Receive Status Register
- **********************************************************************/
-/** CAN Receive Status 1 */
-#define CAN_RSR_RS1				((uint32_t)(1))
-/** CAN Receive Status 1 */
-#define CAN_RSR_RS2				((uint32_t)(1&lt;&lt;1))
-/** CAN Receive Buffer Status 1*/
-#define CAN_RSR_RB1				((uint32_t)(1&lt;&lt;8))
-/** CAN Receive Buffer Status 2*/
-#define CAN_RSR_RB2				((uint32_t)(1&lt;&lt;9))
-/** CAN Data Overrun Status 1 */
-#define CAN_RSR_DOS1			((uint32_t)(1&lt;&lt;16))
-/** CAN Data Overrun Status 1 */
-#define CAN_RSR_DOS2			((uint32_t)(1&lt;&lt;17))
-
-/*********************************************************************//**
- * Macro defines for Central Miscellaneous Status Register
- **********************************************************************/
-/** Same CAN Error Status in CAN1GSR */
-#define CAN_MSR_E1		((uint32_t)(1))
-/** Same CAN Error Status in CAN2GSR */
-#define CAN_MSR_E2		((uint32_t)(1&lt;&lt;1))
-/** Same CAN Bus Status in CAN1GSR */
-#define CAN_MSR_BS1		((uint32_t)(1&lt;&lt;8))
-/** Same CAN Bus Status in CAN2GSR */
-#define CAN_MSR_BS2		((uint32_t)(1&lt;&lt;9))
-
-/*********************************************************************//**
- * Macro defines for Acceptance Filter Mode Register
- **********************************************************************/
-/** CAN Acceptance Filter Off mode */
-#define CAN_AFMR_AccOff		((uint32_t)(1))
-/** CAN Acceptance File Bypass mode */
-#define CAN_AFMR_AccBP		((uint32_t)(1&lt;&lt;1))
-/** FullCAN Mode Enhancements */
-#define CAN_AFMR_eFCAN		((uint32_t)(1&lt;&lt;2))
-
-/*********************************************************************//**
- * Macro defines for Standard Frame Individual Start Address Register
- **********************************************************************/
-/** The start address of the table of individual Standard Identifier */
-#define CAN_STT_sa(n)		((uint32_t)((n&amp;1FF)&lt;&lt;2))
-
-/*********************************************************************//**
- * Macro defines for Standard Frame Group Start Address Register
- **********************************************************************/
-/** The start address of the table of grouped Standard Identifier */
-#define CAN_SFF_GRP_sa(n)		((uint32_t)((n&amp;3FF)&lt;&lt;2))
-
-/*********************************************************************//**
- * Macro defines for Extended Frame Start Address Register
- **********************************************************************/
-/** The start address of the table of individual Extended Identifier */
-#define CAN_EFF_sa(n)		((uint32_t)((n&amp;1FF)&lt;&lt;2))
-
-/*********************************************************************//**
- * Macro defines for Extended Frame Group Start Address Register
- **********************************************************************/
-/** The start address of the table of grouped Extended Identifier */
-#define CAN_Eff_GRP_sa(n)		((uint32_t)((n&amp;3FF)&lt;&lt;2))
-
-/*********************************************************************//**
- * Macro defines for End Of AF Table Register
- **********************************************************************/
-/** The End of Table of AF LookUp Table */
-#define CAN_EndofTable(n)		((uint32_t)((n&amp;3FF)&lt;&lt;2))
-
-/*********************************************************************//**
- * Macro defines for LUT Error Address Register
- **********************************************************************/
-/** CAN Look-Up Table Error Address */
-#define CAN_LUTerrAd(n)		((uint32_t)((n&amp;1FF)&lt;&lt;2))
-
-/*********************************************************************//**
- * Macro defines for LUT Error Register
- **********************************************************************/
-/** CAN Look-Up Table Error */
-#define CAN_LUTerr		((uint32_t)(1))
-
-/*********************************************************************//**
- * Macro defines for Global FullCANInterrupt Enable Register
- **********************************************************************/
-/** Global FullCANInterrupt Enable */
-#define CAN_FCANIE		((uint32_t)(1))
-
-/*********************************************************************//**
- * Macro defines for FullCAN Interrupt and Capture Register 0
- **********************************************************************/
-/** FullCAN Interrupt and Capture (0-31)*/
-#define CAN_FCANIC0_IntPnd(n)	((uint32_t)(1&lt;&lt;n))
-
-/*********************************************************************//**
- * Macro defines for FullCAN Interrupt and Capture Register 1
- **********************************************************************/
-/** FullCAN Interrupt and Capture (0-31)*/
-#define CAN_FCANIC1_IntPnd(n)	((uint32_t)(1&lt;&lt;(n-32)))
-
-/**
- * @}
- */
-
-/**
- * @}
- */
-
-
-/* Public Types --------------------------------------------------------------- */
-/** @defgroup CAN_Public_Types
- * @{
- */
-
-/** CAN configuration structure */
-/***********************************************************************
- * CAN device configuration commands (IOCTL commands and arguments)
- **********************************************************************/
-/**
- * @brief CAN ID format definition
- */
-typedef enum {
-	STD_ID_FORMAT = 0, 	/**&lt; Use standard ID format (11 bit ID) */
-	EXT_ID_FORMAT = 1	/**&lt; Use extended ID format (29 bit ID) */
-} CAN_ID_FORMAT_Type;
-
-/**
- * @brief AFLUT Entry type definition
- */
-typedef enum {
-	FULLCAN_ENTRY = 0,
-	EXPLICIT_STANDARD_ENTRY,
-	GROUP_STANDARD_ENTRY,
-	EXPLICIT_EXTEND_ENTRY,
-	GROUP_EXTEND_ENTRY,
-} AFLUT_ENTRY_Type;
-
-/**
- * @brief Symbolic names for type of CAN message
- */
-typedef enum {
-	DATA_FRAME = 0, 	/**&lt; Data frame */
-	REMOTE_FRAME = 1	/**&lt; Remote frame */
-} CAN_FRAME_Type;
-
-/**
- * @brief CAN Control status definition
- */
-typedef enum {
-	CANCTRL_GLOBAL_STS = 0, /**&lt; CAN Global Status */
-	CANCTRL_INT_CAP, 		/**&lt; CAN Interrupt and Capture */
-	CANCTRL_ERR_WRN, 		/**&lt; CAN Error Warning Limit */
-	CANCTRL_STS				/**&lt; CAN Control Status */
-} CAN_CTRL_STS_Type;
-
-/**
- * @brief Central CAN status type definition
- */
-typedef enum {
-	CANCR_TX_STS = 0, 	/**&lt; Central CAN Tx Status */
-	CANCR_RX_STS, 		/**&lt; Central CAN Rx Status */
-	CANCR_MS			/**&lt; Central CAN Miscellaneous Status */
-} CAN_CR_STS_Type;
-
-/**
- * @brief CAN interrupt enable type definition
- */
-typedef enum {
-	CANINT_RIE = 0, 	/**&lt; CAN Receiver Interrupt Enable */
-	CANINT_TIE1, 		/**&lt; CAN Transmit Interrupt Enable */
-	CANINT_EIE, 		/**&lt; CAN Error Warning Interrupt Enable */
-	CANINT_DOIE, 		/**&lt; CAN Data Overrun Interrupt Enable */
-	CANINT_WUIE, 		/**&lt; CAN Wake-Up Interrupt Enable */
-	CANINT_EPIE, 		/**&lt; CAN Error Passive Interrupt Enable */
-	CANINT_ALIE, 		/**&lt; CAN Arbitration Lost Interrupt Enable */
-	CANINT_BEIE, 		/**&lt; CAN Bus Error Inter rupt Enable */
-	CANINT_IDIE, 		/**&lt; CAN ID Ready Interrupt Enable */
-	CANINT_TIE2, 		/**&lt; CAN Transmit Interrupt Enable for Buffer2 */
-	CANINT_TIE3, 		/**&lt; CAN Transmit Interrupt Enable for Buffer3 */
-	CANINT_FCE			/**&lt; FullCAN Interrupt Enable */
-} CAN_INT_EN_Type;
-
-/**
- * @brief Acceptance Filter Mode type definition
- */
-typedef enum {
-	CAN_Normal = 0, 	/**&lt; Normal Mode */
-	CAN_AccOff, 		/**&lt; Acceptance Filter Off Mode */
-	CAN_AccBP, 			/**&lt; Acceptance Fileter Bypass Mode */
-	CAN_eFCAN			/**&lt; FullCAN Mode Enhancement */
-} CAN_AFMODE_Type;
-
-/**
- * @brief CAN Mode Type definition
- */
-typedef enum {
-	CAN_OPERATING_MODE = 0, 	/**&lt; Operating Mode */
-	CAN_RESET_MODE, 			/**&lt; Reset Mode */
-	CAN_LISTENONLY_MODE, 		/**&lt; Listen Only Mode */
-	CAN_SELFTEST_MODE, 			/**&lt; Seft Test Mode */
-	CAN_TXPRIORITY_MODE, 		/**&lt; Transmit Priority Mode */
-	CAN_SLEEP_MODE, 			/**&lt; Sleep Mode */
-	CAN_RXPOLARITY_MODE, 		/**&lt; Receive Polarity Mode */
-	CAN_TEST_MODE				/**&lt; Test Mode */
-} CAN_MODE_Type;
-
-/**
- * @brief Error values that functions can return
- */
-typedef enum {
-	CAN_OK = 1, 				/**&lt; No error */
-	CAN_OBJECTS_FULL_ERROR, 	/**&lt; No more rx or tx objects available */
-	CAN_FULL_OBJ_NOT_RCV, 		/**&lt; Full CAN object not received */
-	CAN_NO_RECEIVE_DATA, 		/**&lt; No have receive data available */
-	CAN_AF_ENTRY_ERROR, 		/**&lt; Entry load in AFLUT is unvalid */
-	CAN_CONFLICT_ID_ERROR, 		/**&lt; Conflict ID occur */
-	CAN_ENTRY_NOT_EXIT_ERROR	/**&lt; Entry remove outo AFLUT is not exit */
-} CAN_ERROR;
-
-/**
- * @brief Pin Configuration structure
- */
-typedef struct {
-	uint8_t RD; 			/**&lt; Serial Inputs, from CAN transceivers, should be:
-							 ** For CAN1:
-							 - CAN_RD1_P0_0: RD pin is on P0.0
-							 - CAN_RD1_P0_21 : RD pin is on P0.21
-							 ** For CAN2:
-							 - CAN_RD2_P0_4: RD pin is on P0.4
-							 - CAN_RD2_P2_7: RD pin is on P2.7
-							 */
-	uint8_t TD;				/**&lt; Serial Outputs, To CAN transceivers, should be:
-							 ** For CAN1:
-							 - CAN_TD1_P0_1: TD pin is on P0.1
-							 - CAN_TD1_P0_22: TD pin is on P0.22
-							 ** For CAN2:
-							 - CAN_TD2_P0_5: TD pin is on P0.5
-							 - CAN_TD2_P2_8: TD pin is on P2.8
-							 */
-} CAN_PinCFG_Type;
-
-/**
- * @brief CAN message object structure
- */
-typedef struct {
-	uint32_t id; 			/**&lt; 29 bit identifier, it depend on &quot;format&quot; value
-								 - if format = STD_ID_FORMAT, id should be 11 bit identifier
-								 - if format = EXT_ID_FORMAT, id should be 29 bit identifier
-							 */
-	uint8_t dataA[4]; 		/**&lt; Data field A */
-	uint8_t dataB[4]; 		/**&lt; Data field B */
-	uint8_t len; 			/**&lt; Length of data field in bytes, should be:
-								 - 0000b-0111b: 0-7 bytes
-								 - 1xxxb: 8 bytes
-							*/
-	uint8_t format; 		/**&lt; Identifier Format, should be:
-								 - STD_ID_FORMAT: Standard ID - 11 bit format
-								 - EXT_ID_FORMAT: Extended ID - 29 bit format
-							*/
-	uint8_t type; 			/**&lt; Remote Frame transmission, should be:
-								 - DATA_FRAME: the number of data bytes called out by the DLC
-								 field are send from the CANxTDA and CANxTDB registers
-								 - REMOTE_FRAME: Remote Frame is sent
-							*/
-} CAN_MSG_Type;
-
-/**
- * @brief FullCAN Entry structure
- */
-typedef struct {
-	uint8_t controller;		/**&lt; CAN Controller, should be:
-								 - CAN1_CTRL: CAN1 Controller
-								 - CAN2_CTRL: CAN2 Controller
-							*/
-	uint8_t disable;		/**&lt; Disable bit, should be:
-								 - MSG_ENABLE: disable bit = 0
-								 - MSG_DISABLE: disable bit = 1
-							*/
-	uint16_t id_11;			/**&lt; Standard ID, should be 11-bit value */
-} FullCAN_Entry;
-
-/**
- * @brief Standard ID Frame Format Entry structure
- */
-typedef struct {
-	uint8_t controller; 	/**&lt; CAN Controller, should be:
-								 - CAN1_CTRL: CAN1 Controller
-								 - CAN2_CTRL: CAN2 Controller
-							*/
-	uint8_t disable; 		/**&lt; Disable bit, should be:
-								 - MSG_ENABLE: disable bit = 0
-								 - MSG_DISABLE: disable bit = 1
-							*/
-	uint16_t id_11; 		/**&lt; Standard ID, should be 11-bit value */
-} SFF_Entry;
-
-/**
- * @brief Group of Standard ID Frame Format Entry structure
- */
-typedef struct {
-	uint8_t controller1; 	/**&lt; First CAN Controller, should be:
-								 - CAN1_CTRL: CAN1 Controller
-								 - CAN2_CTRL: CAN2 Controller
-							*/
-	uint8_t disable1; 		/**&lt; First Disable bit, should be:
-								 - MSG_ENABLE: disable bit = 0)
-								 - MSG_DISABLE: disable bit = 1
-							*/
-	uint16_t lowerID; 		/**&lt; ID lower bound, should be 11-bit value */
-	uint8_t controller2; 	/**&lt; Second CAN Controller, should be:
-								 - CAN1_CTRL: CAN1 Controller
-								 - CAN2_CTRL: CAN2 Controller
-							*/
-	uint8_t disable2; 		/**&lt; Second Disable bit, should be:
-								 - MSG_ENABLE: disable bit = 0
-								 - MSG_DISABLE: disable bit = 1
-							*/
-	uint16_t upperID; 		/**&lt; ID upper bound, should be 11-bit value and
-								 equal or greater than lowerID
-							*/
-} SFF_GPR_Entry;
-
-/**
- * @brief Extended ID Frame Format Entry structure
- */
-typedef struct {
-	uint8_t controller; 	/**&lt; CAN Controller, should be:
-								 - CAN1_CTRL: CAN1 Controller
-								 - CAN2_CTRL: CAN2 Controller
-							*/
-	uint32_t ID_29; 		/**&lt; Extend ID, shoud be 29-bit value */
-} EFF_Entry;
-
-
-/**
- * @brief Group of Extended ID Frame Format Entry structure
- */
-typedef struct {
-	uint8_t controller1; 	/**&lt; First CAN Controller, should be:
-								 - CAN1_CTRL: CAN1 Controller
-								 - CAN2_CTRL: CAN2 Controller
-							*/
-	uint8_t controller2; 	/**&lt; Second Disable bit, should be:
-								 - MSG_ENABLE: disable bit = 0(default)
-								 - MSG_DISABLE: disable bit = 1
-							*/
-	uint32_t lowerEID; 		/**&lt; Extended ID lower bound, should be 29-bit value */
-	uint32_t upperEID; 		/**&lt; Extended ID upper bound, should be 29-bit value */
-} EFF_GPR_Entry;
-
-
-/**
- * @brief Acceptance Filter Section Table structure
- */
-typedef struct {
-	FullCAN_Entry* FullCAN_Sec; 	/**&lt; The pointer point to FullCAN_Entry */
-	uint8_t FC_NumEntry;			/**&lt; FullCAN Entry Number */
-	SFF_Entry* SFF_Sec; 			/**&lt; The pointer point to SFF_Entry */
-	uint8_t SFF_NumEntry;			/**&lt; Standard ID Entry Number */
-	SFF_GPR_Entry* SFF_GPR_Sec; 	/**&lt; The pointer point to SFF_GPR_Entry */
-	uint8_t SFF_GPR_NumEntry;		/**&lt; Group Standard ID Entry Number */
-	EFF_Entry* EFF_Sec; 			/**&lt; The pointer point to EFF_Entry */
-	uint8_t EFF_NumEntry;			/**&lt; Extended ID Entry Number */
-	EFF_GPR_Entry* EFF_GPR_Sec; 	/**&lt; The pointer point to EFF_GPR_Entry */
-	uint8_t EFF_GPR_NumEntry;		/**&lt; Group Extended ID Entry Number */
-} AF_SectionDef;
-
-/**
- * @brief CAN call-back function type definitions
- */
-typedef void ( fnCANCbs_Type)();
-
-
-/**
- * @}
- */
-
-
-/* Public Macros -------------------------------------------------------------- */
-/** @defgroup CAN_Public_Macros
- * @{
- */
-
-/** Macro to determine if it is valid CAN peripheral */
-#define PARAM_CANx(x)			((((uint32_t*)x)==((uint32_t *)CAN1)) \
-								||(((uint32_t*)x)==((uint32_t *)CAN2)))
-#define PARAM_CANAFx(x)			(((uint32_t*)x)== ((uint32_t*)CANAF))
-#define PARAM_CANAFRAMx(x)		(((uint32_t*)x)== (uint32_t*)CANAF_RAM)
-#define PARAM_CANCRx(x)			(((uint32_t*)x)==((uint32_t*)CANCR))
-
-/** Macro to check Data to send valid */
-#define PARAM_I2S_DATA(data) 	((data&gt;=0)&amp;&amp;(data &lt;= 0xFFFFFFFF))
-#define PRAM_I2S_FREQ(freq)		((freq&gt;=16000)&amp;&amp;(freq &lt;= 96000))
-
-/** Macro to check Pin Selection value */
-#define PARAM_RD1_PIN(n)		((n==CAN_RD1_P0_0)||(n==CAN_RD1_P0_21))
-#define PARAM_TD1_PIN(n)		((n==CAN_TD1_P0_1)||(n==CAN_TD1_P0_22))
-#define PARAM_RD2_PIN(n)		((n==CAN_RD2_P0_4)||(n==CAN_RD2_P2_7))
-#define PARAM_TD2_PIN(n)		((n==CAN_TD2_P0_5)||(n==CAN_TD2_P2_8))
-
-/** Macro to check Frame Identifier */
-#define PARAM_ID_11(n)			((n&gt;&gt;11)==0) /*-- 11 bit --*/
-#define PARAM_ID_29(n)			((n&gt;&gt;29)==0) /*-- 29 bit --*/
-
-#define PARAM_DLC(n)			((n&gt;&gt;4)==0)  /*-- 4 bit --*/
-#define PARAM_ID_FORMAT(n)		((n==STD_ID_FORMAT)||(n==EXT_ID_FORMAT))
-#define PARAM_GRP_ID(x,y)		((x&lt;=y))
-#define PARAM_FRAME_TYPE(n)		((n==DATA_FRAME)||(n==REMOTE_FRAME))
-
-/** Macro to check Control/Central Status type parameter */
-#define PARAM_CTRL_STS_TYPE(n)	((n==CANCTRL_GLOBAL_STS)||(n==CANCTRL_INT_CAP) \
-							    ||(n==CANCTRL_ERR_WRN)||(n==CANCTRL_STS))
-#define PARAM_CR_STS_TYPE(n)	((n==CANCR_TX_STS)||(n==CANCR_RX_STS) \
-							    ||(n==CANCR_MS))
-/** Macro to check AF Mode type parameter */
-#define PARAM_AFMODE_TYPE(n)	((n==CAN_Normal)||(n==CAN_AccOff) \
-								||(n==CAN_AccBP)||(n==CAN_eFCAN))
-/** Macro to check Operation Mode */
-#define PARAM_MODE_TYPE(n)		((n==CAN_OPERATING_MODE)||(n==CAN_RESET_MODE) \
-								||(n==CAN_LISTENONLY_MODE)||(n==CAN_SELFTEST_MODE) \
-								||(n==CAN_TXPRIORITY_MODE)||(n==CAN_SLEEP_MODE) \
-								||(n==CAN_RXPOLARITY_MODE)||(n==CAN_TEST_MODE))
-
-/** Macro define for struct AF_Section parameter */
-#define CAN1_CTRL				((uint8_t)(0))
-#define CAN2_CTRL				((uint8_t)(1))
-#define PARAM_CTRL(n)			((n==CAN1_CTRL)|(n==CAN2_CTRL))
-
-#define MSG_ENABLE				((uint8_t)(0))
-#define MSG_DISABLE				((uint8_t)(1))
-#define PARAM_MSG_DISABLE(n)	((n==MSG_ENABLE)|(n==MSG_DISABLE))
-
-/**Macro to check Interrupt Type parameter */
-#define PARAM_INT_EN_TYPE(n)	((n==CANINT_RIE)||(n==CANINT_TIE1) \
-								||(n==CANINT_EIE)||(n==CANINT_DOIE) \
-								||(n==CANINT_WUIE)||(n==CANINT_EPIE) \
-								||(n==CANINT_ALIE)||(n==CANINT_BEIE) \
-								||(n==CANINT_IDIE)||(n==CANINT_TIE2) \
-								||(n==CANINT_TIE3)||(n==CANINT_FCE))
-
-/** Macro to check AFLUT Entry type */
-#define PARAM_AFLUT_ENTRY_TYPE(n)	((n==FULLCAN_ENTRY)||(n==EXPLICIT_STANDARD_ENTRY)	\
-									||(n==GROUP_STANDARD_ENTRY)||(n==EXPLICIT_EXTEND_ENTRY)	\
-									||(n==GROUP_EXTEND_ENTRY))
-#define PARAM_POSITION(n)		((n&gt;=0)&amp;&amp;(n&lt;512))
-
-/** CAN function pin selection defines */
-#define CAN_RD1_P0_0		((uint8_t)(0))
-#define CAN_RD1_P0_21		((uint8_t)(1))
-#define CAN_TD1_P0_1		((uint8_t)(0))
-#define CAN_TD1_P0_22		((uint8_t)(1))
-
-#define CAN_RD2_P0_4		((uint8_t)(0))
-#define CAN_RD2_P2_7		((uint8_t)(1))
-#define CAN_TD2_P0_5		((uint8_t)(0))
-#define CAN_TD2_P2_8		((uint8_t)(1))
-
-
-/**
- * @}
- */
-
-
-/* Public Functions ----------------------------------------------------------- */
-/** @defgroup CAN_Public_Functions
- * @{
- */
-
-void CAN_Init(CAN_TypeDef *CANx, uint32_t baudrate);
-void CAN_DeInit(CAN_TypeDef *CANx);
-
-Status CAN_SendMsg(CAN_TypeDef *CANx, CAN_MSG_Type *CAN_Msg);
-Status CAN_ReceiveMsg(CAN_TypeDef *CANx, CAN_MSG_Type *CAN_Msg);
-CAN_ERROR FCAN_ReadObj(CANAF_TypeDef* CANAFx, CAN_MSG_Type *CAN_Msg);
-
-uint32_t CAN_GetCTRLStatus(CAN_TypeDef* CANx, CAN_CTRL_STS_Type arg);
-uint32_t CAN_GetCRStatus(CANCR_TypeDef* CANCRx, CAN_CR_STS_Type arg);
-void CAN_ModeConfig(CAN_TypeDef* CANx, CAN_MODE_Type mode,
-		FunctionalState NewState);
-void CAN_SetBaudRate(CAN_TypeDef *CANx, uint32_t baudrate);
-
-void CAN_SetAFMode(CANAF_TypeDef* CANAFx, CAN_AFMODE_Type AFmode);
-CAN_ERROR CAN_SetupAFLUT(CANAF_TypeDef* CANAFx, AF_SectionDef* AFSection);
-CAN_ERROR CAN_LoadFullCANEntry(CAN_TypeDef* CANx, uint16_t ID);
-CAN_ERROR CAN_LoadExplicitEntry(CAN_TypeDef* CANx, uint32_t ID,
-		CAN_ID_FORMAT_Type format);
-CAN_ERROR CAN_LoadGroupEntry(CAN_TypeDef* CANx, uint32_t lowerID,
-		uint32_t upperID, CAN_ID_FORMAT_Type format);
-CAN_ERROR CAN_RemoveEntry(AFLUT_ENTRY_Type EntryType, uint16_t position);
-
-void CAN_SetupCBS(CAN_INT_EN_Type arg, fnCANCbs_Type* pnCANCbs);
-void CAN_IRQCmd(CAN_TypeDef* CANx, CAN_INT_EN_Type arg,
-		FunctionalState NewState);
-void CAN_IntHandler(CAN_TypeDef* CANx);
-
-/**
- * @}
- */
-
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* LPC17XX_CAN_H_ */
-
-/**
- * @}
- */
-
-/* --------------------------------- End Of File ------------------------------ */
+/***********************************************************************//**
+ * @file	: lpc17xx_can.h
+ * @brief	: Contains all macro definitions and function prototypes
+ * 				support for CAN firmware library on LPC17xx
+ * @version	: 1.0
+ * @date	: 1.June.2009
+ * @author	: NguyenCao
+ **************************************************************************
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * products. This software is supplied &quot;AS IS&quot; without any warranties.
+ * NXP Semiconductors assumes no responsibility or liability for the
+ * use of the software, conveys no license or title under any patent,
+ * copyright, or mask work right to the product. NXP Semiconductors
+ * reserves the right to make changes in the software without
+ * notification. NXP Semiconductors also make no representation or
+ * warranty that such application will be suitable for the specified
+ * use without further testing or modification.
+ **************************************************************************/
+
+/* Peripheral group ----------------------------------------------------------- */
+/** @defgroup CAN
+ * @ingroup LPC1700CMSIS_FwLib_Drivers
+ * @{
+ */
+
+#ifndef LPC17XX_CAN_H_
+#define LPC17XX_CAN_H_
+
+/* Includes ------------------------------------------------------------------- */
+#include &quot;LPC17xx.h&quot;
+#include &quot;lpc_types.h&quot;
+
+#ifdef __cplusplus
+extern &quot;C&quot;
+{
+#endif
+
+
+/* Private Macros ------------------------------------------------------------- */
+/** @defgroup CAN_Private_Macros
+ * @{
+ */
+
+#define ID_11	1
+#define MAX_HW_FULLCAN_OBJ 		64
+#define MAX_SW_FULLCAN_OBJ 		32
+
+
+/** @defgroup CAN_REGISTER_BIT_DEFINITION
+ * @{
+ */
+
+/** CAN Reset mode */
+#define CAN_MOD_RM			((uint32_t)(1))
+/** CAN Listen Only Mode */
+#define CAN_MOD_LOM			((uint32_t)(1&lt;&lt;1))
+/** CAN Self Test mode */
+#define CAN_MOD_STM			((uint32_t)(1&lt;&lt;2))
+/** CAN Transmit Priority mode */
+#define CAN_MOD_TPM			((uint32_t)(1&lt;&lt;3))
+/** CAN Sleep mode */
+#define CAN_MOD_SM			((uint32_t)(1&lt;&lt;4))
+/** CAN Receive Polarity mode */
+#define CAN_MOD_RPM			((uint32_t)(1&lt;&lt;5))
+/** CAN Test mode */
+#define CAN_MOD_TM			((uint32_t)(1&lt;&lt;7))
+/*********************************************************************//**
+ * Macro defines for CAN Command Register
+ **********************************************************************/
+/** CAN Transmission Request */
+#define CAN_CMR_TR			((uint32_t)(1))
+/** CAN Abort Transmission */
+#define CAN_CMR_AT			((uint32_t)(1&lt;&lt;1))
+/** CAN Release Receive Buffer */
+#define CAN_CMR_RRB			((uint32_t)(1&lt;&lt;2))
+/** CAN Clear Data Overrun */
+#define CAN_CMR_CDO			((uint32_t)(1&lt;&lt;3))
+/** CAN Self Reception Request */
+#define CAN_CMR_SRR			((uint32_t)(1&lt;&lt;4))
+/** CAN Select Tx Buffer 1 */
+#define CAN_CMR_STB1		((uint32_t)(1&lt;&lt;5))
+/** CAN Select Tx Buffer 2 */
+#define CAN_CMR_STB2		((uint32_t)(1&lt;&lt;6))
+/** CAN Select Tx Buffer 3 */
+#define CAN_CMR_STB3		((uint32_t)(1&lt;&lt;7))
+
+/*********************************************************************//**
+ * Macro defines for CAN Global Status Register
+ **********************************************************************/
+/** CAN Receive Buffer Status */
+#define CAN_GSR_RBS			((uint32_t)(1))
+/** CAN Data Overrun Status */
+#define CAN_GSR_DOS			((uint32_t)(1&lt;&lt;1))
+/** CAN Transmit Buffer Status */
+#define CAN_GSR_TBS			((uint32_t)(1&lt;&lt;2))
+/** CAN Transmit Complete Status */
+#define CAN_GSR_TCS			((uint32_t)(1&lt;&lt;3))
+/** CAN Receive Status */
+#define CAN_GSR_RS			((uint32_t)(1&lt;&lt;4))
+/** CAN Transmit Status */
+#define CAN_GSR_TS			((uint32_t)(1&lt;&lt;5))
+/** CAN Error Status */
+#define CAN_GSR_ES			((uint32_t)(1&lt;&lt;6))
+/** CAN Bus Status */
+#define CAN_GSR_BS			((uint32_t)(1&lt;&lt;7))
+/** CAN Current value of the Rx Error Counter */
+#define CAN_GSR_RXERR(n)	((uint32_t)((n&amp;0xFF)&lt;&lt;16))
+/** CAN Current value of the Tx Error Counter */
+#define CAN_GSR_TXERR(n)	((uint32_t)(n&amp;0xFF)&lt;&lt;24))
+
+/*********************************************************************//**
+ * Macro defines for CAN Interrupt and Capture Register
+ **********************************************************************/
+/** CAN Receive Interrupt */
+#define CAN_ICR_RI			((uint32_t)(1))
+/** CAN Transmit Interrupt 1 */
+#define CAN_ICR_TI1			((uint32_t)(1&lt;&lt;1))
+/** CAN Error Warning Interrupt */
+#define CAN_ICR_EI			((uint32_t)(1&lt;&lt;2))
+/** CAN Data Overrun Interrupt */
+#define CAN_ICR_DOI			((uint32_t)(1&lt;&lt;3))
+/** CAN Wake-Up Interrupt */
+#define CAN_ICR_WUI			((uint32_t)(1&lt;&lt;4))
+/** CAN Error Passive Interrupt */
+#define CAN_ICR_EPI			((uint32_t)(1&lt;&lt;5))
+/** CAN Arbitration Lost Interrupt */
+#define CAN_ICR_ALI			((uint32_t)(1&lt;&lt;6))
+/** CAN Bus Error Interrupt */
+#define CAN_ICR_BEI			((uint32_t)(1&lt;&lt;7))
+/** CAN ID Ready Interrupt */
+#define CAN_ICR_IDI			((uint32_t)(1&lt;&lt;8))
+/** CAN Transmit Interrupt 2 */
+#define CAN_ICR_TI2			((uint32_t)(1&lt;&lt;9))
+/** CAN Transmit Interrupt 3 */
+#define CAN_ICR_TI3			((uint32_t)(1&lt;&lt;10))
+/** CAN Error Code Capture */
+#define CAN_ICR_ERRBIT(n)	((uint32_t)((n&amp;0x1F)&lt;&lt;16))
+/** CAN Error Direction */
+#define CAN_ICR_ERRDIR		((uint32_t)(1&lt;&lt;21))
+/** CAN Error Capture */
+#define CAN_ICR_ERRC(n)		((uint32_t)((n&amp;0x3)&lt;&lt;22))
+/** CAN Arbitration Lost Capture */
+#define CAN_ICR_ALCBIT(n)		((uint32_t)((n&amp;0xFF)&lt;&lt;24))
+
+/*********************************************************************//**
+ * Macro defines for CAN Interrupt Enable Register
+ **********************************************************************/
+/** CAN Receive Interrupt Enable */
+#define CAN_IER_RIE			((uint32_t)(1))
+/** CAN Transmit Interrupt Enable for buffer 1 */
+#define CAN_IER_TIE1		((uint32_t)(1&lt;&lt;1))
+/** CAN Error Warning Interrupt Enable */
+#define CAN_IER_EIE			((uint32_t)(1&lt;&lt;2))
+/** CAN Data Overrun Interrupt Enable */
+#define CAN_IER_DOIE		((uint32_t)(1&lt;&lt;3))
+/** CAN Wake-Up Interrupt Enable */
+#define CAN_IER_WUIE		((uint32_t)(1&lt;&lt;4))
+/** CAN Error Passive Interrupt Enable */
+#define CAN_IER_EPIE		((uint32_t)(1&lt;&lt;5))
+/** CAN Arbitration Lost Interrupt Enable */
+#define CAN_IER_ALIE		((uint32_t)(1&lt;&lt;6))
+/** CAN Bus Error Interrupt Enable */
+#define CAN_IER_BEIE		((uint32_t)(1&lt;&lt;7))
+/** CAN ID Ready Interrupt Enable */
+#define CAN_IER_IDIE		((uint32_t)(1&lt;&lt;8))
+/** CAN Transmit Enable Interrupt for Buffer 2 */
+#define CAN_IER_TIE2		((uint32_t)(1&lt;&lt;9))
+/** CAN Transmit Enable Interrupt for Buffer 3 */
+#define CAN_IER_TIE3		((uint32_t)(1&lt;&lt;10))
+
+/*********************************************************************//**
+ * Macro defines for CAN Bus Timing Register
+ **********************************************************************/
+/** CAN Baudrate Prescaler */
+#define CAN_BTR_BRP(n)		((uint32_t)(n&amp;0x3FF))
+/** CAN Synchronization Jump Width */
+#define CAN_BTR_SJM(n)		((uint32_t)((n&amp;0x3)&lt;&lt;14))
+/** CAN Time Segment 1 */
+#define CAN_BTR_TESG1(n)	((uint32_t)(n&amp;0xF)&lt;&lt;16))
+/** CAN Time Segment 2 */
+#define CAN_BTR_TESG2(n)	((uint32_t)(n&amp;0xF)&lt;&lt;20))
+/** CAN Sampling */
+#define CAN_BTR_SAM(n)		((uint32_t)(1&lt;&lt;23))
+
+/*********************************************************************//**
+ * Macro defines for CAN Error Warning Limit Register
+ **********************************************************************/
+/** CAN Error Warning Limit */
+#define CAN_EWL_EWL(n)		((uint32_t)(n&amp;0xFF))
+
+/*********************************************************************//**
+ * Macro defines for CAN Status Register
+ **********************************************************************/
+/** CAN Receive Buffer Status */
+#define CAN_SR_RBS		((uint32_t)(1))
+/** CAN Data Overrun Status */
+#define CAN_SR_DOS		((uint32_t)(1&lt;&lt;1))
+/** CAN Transmit Buffer Status 1 */
+#define CAN_SR_TBS1		((uint32_t)(1&lt;&lt;2))
+/** CAN Transmission Complete Status of Buffer 1 */
+#define CAN_SR_TCS1		((uint32_t)(1&lt;&lt;3))
+/** CAN Receive Status */
+#define CAN_SR_RS		((uint32_t)(1&lt;&lt;4))
+/** CAN Transmit Status 1 */
+#define CAN_SR_TS1		((uint32_t)(1&lt;&lt;5))
+/** CAN Error Status */
+#define CAN_SR_ES		((uint32_t)(1&lt;&lt;6))
+/** CAN Bus Status */
+#define CAN_SR_BS		((uint32_t)(1&lt;&lt;7))
+/** CAN Transmit Buffer Status 2 */
+#define CAN_SR_TBS2		((uint32_t)(1&lt;&lt;10))
+/** CAN Transmission Complete Status of Buffer 2 */
+#define CAN_SR_TCS2		((uint32_t)(1&lt;&lt;11))
+/** CAN Transmit Status 2 */
+#define CAN_SR_TS2		((uint32_t)(1&lt;&lt;13))
+/** CAN Transmit Buffer Status 2 */
+#define CAN_SR_TBS3		((uint32_t)(1&lt;&lt;18))
+/** CAN Transmission Complete Status of Buffer 2 */
+#define CAN_SR_TCS3		((uint32_t)(1&lt;&lt;19))
+/** CAN Transmit Status 2 */
+#define CAN_SR_TS3		((uint32_t)(1&lt;&lt;21))
+
+/*********************************************************************//**
+ * Macro defines for CAN Receive Frame Status Register
+ **********************************************************************/
+/** CAN ID Index */
+#define CAN_RFS_ID_INDEX(n)	((uint32_t)(n&amp;0x3FF))
+/** CAN Bypass */
+#define CAN_RFS_BP			((uint32_t)(1&lt;&lt;10))
+/** CAN Data Length Code */
+#define CAN_RFS_DLC(n)		((uint32_t)((n&amp;0xF)&lt;&lt;16)
+/** CAN Remote Transmission Request */
+#define CAN_RFS_RTR			((uint32_t)(1&lt;&lt;30))
+/** CAN control 11 bit or 29 bit Identifier */
+#define CAN_RFS_FF			((uint32_t)(1&lt;&lt;31))
+
+/*********************************************************************//**
+ * Macro defines for CAN Receive Identifier Register
+ **********************************************************************/
+/** CAN 11 bit Identifier */
+#define CAN_RID_ID_11(n)		((uint32_t)(n&amp;0x7FF))
+/** CAN 29 bit Identifier */
+#define CAN_RID_ID_29(n)		((uint32_t)(n&amp;0x1FFFFFFF))
+
+/*********************************************************************//**
+ * Macro defines for CAN Receive Data A Register
+ **********************************************************************/
+/** CAN Receive Data 1 */
+#define CAN_RDA_DATA1(n)		((uint32_t)(n&amp;0xFF))
+/** CAN Receive Data 2 */
+#define CAN_RDA_DATA2(n)		((uint32_t)((n&amp;0xFF)&lt;&lt;8))
+/** CAN Receive Data 3 */
+#define CAN_RDA_DATA3(n)		((uint32_t)((n&amp;0xFF)&lt;&lt;16))
+/** CAN Receive Data 4 */
+#define CAN_RDA_DATA4(n)		((uint32_t)((n&amp;0xFF)&lt;&lt;24))
+
+/*********************************************************************//**
+ * Macro defines for CAN Receive Data B Register
+ **********************************************************************/
+/** CAN Receive Data 5 */
+#define CAN_RDB_DATA5(n)		((uint32_t)(n&amp;0xFF))
+/** CAN Receive Data 6 */
+#define CAN_RDB_DATA6(n)		((uint32_t)((n&amp;0xFF)&lt;&lt;8))
+/** CAN Receive Data 7 */
+#define CAN_RDB_DATA7(n)		((uint32_t)((n&amp;0xFF)&lt;&lt;16))
+/** CAN Receive Data 8 */
+#define CAN_RDB_DATA8(n)		((uint32_t)((n&amp;0xFF)&lt;&lt;24))
+
+/*********************************************************************//**
+ * Macro defines for CAN Transmit Frame Information Register
+ **********************************************************************/
+/** CAN Priority */
+#define CAN_TFI_PRIO(n)			((uint32_t)(n&amp;0xFF))
+/** CAN Data Length Code */
+#define CAN_TFI_DLC(n)			((uint32_t)((n&amp;0xF)&lt;&lt;16))
+/** CAN Remote Frame Transmission */
+#define CAN_TFI_RTR				((uint32_t)(1&lt;&lt;30))
+/** CAN control 11-bit or 29-bit Identifier */
+#define CAN_TFI_FF				((uint32_t)(1&lt;&lt;31))
+
+/*********************************************************************//**
+ * Macro defines for CAN Transmit Identifier Register
+ **********************************************************************/
+/** CAN 11-bit Identifier */
+#define CAN_TID_ID11(n)			((uint32_t)(n&amp;0x7FF))
+/** CAN 11-bit Identifier */
+#define CAN_TID_ID29(n)			((uint32_t)(n&amp;0x1FFFFFFF))
+
+/*********************************************************************//**
+ * Macro defines for CAN Transmit Data A Register
+ **********************************************************************/
+/** CAN Transmit Data 1 */
+#define CAN_TDA_DATA1(n)		((uint32_t)(n&amp;0xFF))
+/** CAN Transmit Data 2 */
+#define CAN_TDA_DATA2(n)		((uint32_t)((n&amp;0xFF)&lt;&lt;8))
+/** CAN Transmit Data 3 */
+#define CAN_TDA_DATA3(n)		((uint32_t)((n&amp;0xFF)&lt;&lt;16))
+/** CAN Transmit Data 4 */
+#define CAN_TDA_DATA4(n)		((uint32_t)((n&amp;0xFF)&lt;&lt;24))
+
+/*********************************************************************//**
+ * Macro defines for CAN Transmit Data B Register
+ **********************************************************************/
+/** CAN Transmit Data 5 */
+#define CAN_TDA_DATA5(n)		((uint32_t)(n&amp;0xFF))
+/** CAN Transmit Data 6 */
+#define CAN_TDA_DATA6(n)		((uint32_t)((n&amp;0xFF)&lt;&lt;8))
+/** CAN Transmit Data 7 */
+#define CAN_TDA_DATA7(n)		((uint32_t)((n&amp;0xFF)&lt;&lt;16))
+/** CAN Transmit Data 8 */
+#define CAN_TDA_DATA8(n)		((uint32_t)((n&amp;0xFF)&lt;&lt;24))
+
+/*********************************************************************//**
+ * Macro defines for CAN Sleep Clear Register
+ **********************************************************************/
+/** CAN1 Sleep mode */
+#define CAN1SLEEPCLR			((uint32_t)(1&lt;&lt;1))
+/** CAN2 Sleep Mode */
+#define CAN2SLEEPCLR			((uint32_t)(1&lt;&lt;2))
+
+/*********************************************************************//**
+ * Macro defines for CAN Wake up Flags Register
+ **********************************************************************/
+/** CAN1 Sleep mode */
+#define CAN_WAKEFLAGES_CAN1WAKE		((uint32_t)(1&lt;&lt;1))
+/** CAN2 Sleep Mode */
+#define CAN_WAKEFLAGES_CAN2WAKE		((uint32_t)(1&lt;&lt;2))
+
+/*********************************************************************//**
+ * Macro defines for Central transmit Status Register
+ **********************************************************************/
+/** CAN Transmit 1 */
+#define CAN_TSR_TS1			((uint32_t)(1))
+/** CAN Transmit 2 */
+#define CAN_TSR_TS2			((uint32_t)(1&lt;&lt;1))
+/** CAN Transmit Buffer Status 1 */
+#define CAN_TSR_TBS1			((uint32_t)(1&lt;&lt;8))
+/** CAN Transmit Buffer Status 2 */
+#define CAN_TSR_TBS2			((uint32_t)(1&lt;&lt;9))
+/** CAN Transmission Complete Status 1 */
+#define CAN_TSR_TCS1			((uint32_t)(1&lt;&lt;16))
+/** CAN Transmission Complete Status 2 */
+#define CAN_TSR_TCS2			((uint32_t)(1&lt;&lt;17))
+
+/*********************************************************************//**
+ * Macro defines for Central Receive Status Register
+ **********************************************************************/
+/** CAN Receive Status 1 */
+#define CAN_RSR_RS1				((uint32_t)(1))
+/** CAN Receive Status 1 */
+#define CAN_RSR_RS2				((uint32_t)(1&lt;&lt;1))
+/** CAN Receive Buffer Status 1*/
+#define CAN_RSR_RB1				((uint32_t)(1&lt;&lt;8))
+/** CAN Receive Buffer Status 2*/
+#define CAN_RSR_RB2				((uint32_t)(1&lt;&lt;9))
+/** CAN Data Overrun Status 1 */
+#define CAN_RSR_DOS1			((uint32_t)(1&lt;&lt;16))
+/** CAN Data Overrun Status 1 */
+#define CAN_RSR_DOS2			((uint32_t)(1&lt;&lt;17))
+
+/*********************************************************************//**
+ * Macro defines for Central Miscellaneous Status Register
+ **********************************************************************/
+/** Same CAN Error Status in CAN1GSR */
+#define CAN_MSR_E1		((uint32_t)(1))
+/** Same CAN Error Status in CAN2GSR */
+#define CAN_MSR_E2		((uint32_t)(1&lt;&lt;1))
+/** Same CAN Bus Status in CAN1GSR */
+#define CAN_MSR_BS1		((uint32_t)(1&lt;&lt;8))
+/** Same CAN Bus Status in CAN2GSR */
+#define CAN_MSR_BS2		((uint32_t)(1&lt;&lt;9))
+
+/*********************************************************************//**
+ * Macro defines for Acceptance Filter Mode Register
+ **********************************************************************/
+/** CAN Acceptance Filter Off mode */
+#define CAN_AFMR_AccOff		((uint32_t)(1))
+/** CAN Acceptance File Bypass mode */
+#define CAN_AFMR_AccBP		((uint32_t)(1&lt;&lt;1))
+/** FullCAN Mode Enhancements */
+#define CAN_AFMR_eFCAN		((uint32_t)(1&lt;&lt;2))
+
+/*********************************************************************//**
+ * Macro defines for Standard Frame Individual Start Address Register
+ **********************************************************************/
+/** The start address of the table of individual Standard Identifier */
+#define CAN_STT_sa(n)		((uint32_t)((n&amp;1FF)&lt;&lt;2))
+
+/*********************************************************************//**
+ * Macro defines for Standard Frame Group Start Address Register
+ **********************************************************************/
+/** The start address of the table of grouped Standard Identifier */
+#define CAN_SFF_GRP_sa(n)		((uint32_t)((n&amp;3FF)&lt;&lt;2))
+
+/*********************************************************************//**
+ * Macro defines for Extended Frame Start Address Register
+ **********************************************************************/
+/** The start address of the table of individual Extended Identifier */
+#define CAN_EFF_sa(n)		((uint32_t)((n&amp;1FF)&lt;&lt;2))
+
+/*********************************************************************//**
+ * Macro defines for Extended Frame Group Start Address Register
+ **********************************************************************/
+/** The start address of the table of grouped Extended Identifier */
+#define CAN_Eff_GRP_sa(n)		((uint32_t)((n&amp;3FF)&lt;&lt;2))
+
+/*********************************************************************//**
+ * Macro defines for End Of AF Table Register
+ **********************************************************************/
+/** The End of Table of AF LookUp Table */
+#define CAN_EndofTable(n)		((uint32_t)((n&amp;3FF)&lt;&lt;2))
+
+/*********************************************************************//**
+ * Macro defines for LUT Error Address Register
+ **********************************************************************/
+/** CAN Look-Up Table Error Address */
+#define CAN_LUTerrAd(n)		((uint32_t)((n&amp;1FF)&lt;&lt;2))
+
+/*********************************************************************//**
+ * Macro defines for LUT Error Register
+ **********************************************************************/
+/** CAN Look-Up Table Error */
+#define CAN_LUTerr		((uint32_t)(1))
+
+/*********************************************************************//**
+ * Macro defines for Global FullCANInterrupt Enable Register
+ **********************************************************************/
+/** Global FullCANInterrupt Enable */
+#define CAN_FCANIE		((uint32_t)(1))
+
+/*********************************************************************//**
+ * Macro defines for FullCAN Interrupt and Capture Register 0
+ **********************************************************************/
+/** FullCAN Interrupt and Capture (0-31)*/
+#define CAN_FCANIC0_IntPnd(n)	((uint32_t)(1&lt;&lt;n))
+
+/*********************************************************************//**
+ * Macro defines for FullCAN Interrupt and Capture Register 1
+ **********************************************************************/
+/** FullCAN Interrupt and Capture (0-31)*/
+#define CAN_FCANIC1_IntPnd(n)	((uint32_t)(1&lt;&lt;(n-32)))
+
+/**
+ * @}
+ */
+
+/**
+ * @}
+ */
+
+
+/* Public Types --------------------------------------------------------------- */
+/** @defgroup CAN_Public_Types
+ * @{
+ */
+
+/** CAN configuration structure */
+/***********************************************************************
+ * CAN device configuration commands (IOCTL commands and arguments)
+ **********************************************************************/
+/**
+ * @brief CAN ID format definition
+ */
+typedef enum {
+	STD_ID_FORMAT = 0, 	/**&lt; Use standard ID format (11 bit ID) */
+	EXT_ID_FORMAT = 1	/**&lt; Use extended ID format (29 bit ID) */
+} CAN_ID_FORMAT_Type;
+
+/**
+ * @brief AFLUT Entry type definition
+ */
+typedef enum {
+	FULLCAN_ENTRY = 0,
+	EXPLICIT_STANDARD_ENTRY,
+	GROUP_STANDARD_ENTRY,
+	EXPLICIT_EXTEND_ENTRY,
+	GROUP_EXTEND_ENTRY,
+} AFLUT_ENTRY_Type;
+
+/**
+ * @brief Symbolic names for type of CAN message
+ */
+typedef enum {
+	DATA_FRAME = 0, 	/**&lt; Data frame */
+	REMOTE_FRAME = 1	/**&lt; Remote frame */
+} CAN_FRAME_Type;
+
+/**
+ * @brief CAN Control status definition
+ */
+typedef enum {
+	CANCTRL_GLOBAL_STS = 0, /**&lt; CAN Global Status */
+	CANCTRL_INT_CAP, 		/**&lt; CAN Interrupt and Capture */
+	CANCTRL_ERR_WRN, 		/**&lt; CAN Error Warning Limit */
+	CANCTRL_STS				/**&lt; CAN Control Status */
+} CAN_CTRL_STS_Type;
+
+/**
+ * @brief Central CAN status type definition
+ */
+typedef enum {
+	CANCR_TX_STS = 0, 	/**&lt; Central CAN Tx Status */
+	CANCR_RX_STS, 		/**&lt; Central CAN Rx Status */
+	CANCR_MS			/**&lt; Central CAN Miscellaneous Status */
+} CAN_CR_STS_Type;
+
+/**
+ * @brief CAN interrupt enable type definition
+ */
+typedef enum {
+	CANINT_RIE = 0, 	/**&lt; CAN Receiver Interrupt Enable */
+	CANINT_TIE1, 		/**&lt; CAN Transmit Interrupt Enable */
+	CANINT_EIE, 		/**&lt; CAN Error Warning Interrupt Enable */
+	CANINT_DOIE, 		/**&lt; CAN Data Overrun Interrupt Enable */
+	CANINT_WUIE, 		/**&lt; CAN Wake-Up Interrupt Enable */
+	CANINT_EPIE, 		/**&lt; CAN Error Passive Interrupt Enable */
+	CANINT_ALIE, 		/**&lt; CAN Arbitration Lost Interrupt Enable */
+	CANINT_BEIE, 		/**&lt; CAN Bus Error Inter rupt Enable */
+	CANINT_IDIE, 		/**&lt; CAN ID Ready Interrupt Enable */
+	CANINT_TIE2, 		/**&lt; CAN Transmit Interrupt Enable for Buffer2 */
+	CANINT_TIE3, 		/**&lt; CAN Transmit Interrupt Enable for Buffer3 */
+	CANINT_FCE			/**&lt; FullCAN Interrupt Enable */
+} CAN_INT_EN_Type;
+
+/**
+ * @brief Acceptance Filter Mode type definition
+ */
+typedef enum {
+	CAN_Normal = 0, 	/**&lt; Normal Mode */
+	CAN_AccOff, 		/**&lt; Acceptance Filter Off Mode */
+	CAN_AccBP, 			/**&lt; Acceptance Fileter Bypass Mode */
+	CAN_eFCAN			/**&lt; FullCAN Mode Enhancement */
+} CAN_AFMODE_Type;
+
+/**
+ * @brief CAN Mode Type definition
+ */
+typedef enum {
+	CAN_OPERATING_MODE = 0, 	/**&lt; Operating Mode */
+	CAN_RESET_MODE, 			/**&lt; Reset Mode */
+	CAN_LISTENONLY_MODE, 		/**&lt; Listen Only Mode */
+	CAN_SELFTEST_MODE, 			/**&lt; Seft Test Mode */
+	CAN_TXPRIORITY_MODE, 		/**&lt; Transmit Priority Mode */
+	CAN_SLEEP_MODE, 			/**&lt; Sleep Mode */
+	CAN_RXPOLARITY_MODE, 		/**&lt; Receive Polarity Mode */
+	CAN_TEST_MODE				/**&lt; Test Mode */
+} CAN_MODE_Type;
+
+/**
+ * @brief Error values that functions can return
+ */
+typedef enum {
+	CAN_OK = 1, 				/**&lt; No error */
+	CAN_OBJECTS_FULL_ERROR, 	/**&lt; No more rx or tx objects available */
+	CAN_FULL_OBJ_NOT_RCV, 		/**&lt; Full CAN object not received */
+	CAN_NO_RECEIVE_DATA, 		/**&lt; No have receive data available */
+	CAN_AF_ENTRY_ERROR, 		/**&lt; Entry load in AFLUT is unvalid */
+	CAN_CONFLICT_ID_ERROR, 		/**&lt; Conflict ID occur */
+	CAN_ENTRY_NOT_EXIT_ERROR	/**&lt; Entry remove outo AFLUT is not exit */
+} CAN_ERROR;
+
+/**
+ * @brief Pin Configuration structure
+ */
+typedef struct {
+	uint8_t RD; 			/**&lt; Serial Inputs, from CAN transceivers, should be:
+							 ** For CAN1:
+							 - CAN_RD1_P0_0: RD pin is on P0.0
+							 - CAN_RD1_P0_21 : RD pin is on P0.21
+							 ** For CAN2:
+							 - CAN_RD2_P0_4: RD pin is on P0.4
+							 - CAN_RD2_P2_7: RD pin is on P2.7
+							 */
+	uint8_t TD;				/**&lt; Serial Outputs, To CAN transceivers, should be:
+							 ** For CAN1:
+							 - CAN_TD1_P0_1: TD pin is on P0.1
+							 - CAN_TD1_P0_22: TD pin is on P0.22
+							 ** For CAN2:
+							 - CAN_TD2_P0_5: TD pin is on P0.5
+							 - CAN_TD2_P2_8: TD pin is on P2.8
+							 */
+} CAN_PinCFG_Type;
+
+/**
+ * @brief CAN message object structure
+ */
+typedef struct {
+	uint32_t id; 			/**&lt; 29 bit identifier, it depend on &quot;format&quot; value
+								 - if format = STD_ID_FORMAT, id should be 11 bit identifier
+								 - if format = EXT_ID_FORMAT, id should be 29 bit identifier
+							 */
+	uint8_t dataA[4]; 		/**&lt; Data field A */
+	uint8_t dataB[4]; 		/**&lt; Data field B */
+	uint8_t len; 			/**&lt; Length of data field in bytes, should be:
+								 - 0000b-0111b: 0-7 bytes
+								 - 1xxxb: 8 bytes
+							*/
+	uint8_t format; 		/**&lt; Identifier Format, should be:
+								 - STD_ID_FORMAT: Standard ID - 11 bit format
+								 - EXT_ID_FORMAT: Extended ID - 29 bit format
+							*/
+	uint8_t type; 			/**&lt; Remote Frame transmission, should be:
+								 - DATA_FRAME: the number of data bytes called out by the DLC
+								 field are send from the CANxTDA and CANxTDB registers
+								 - REMOTE_FRAME: Remote Frame is sent
+							*/
+} CAN_MSG_Type;
+
+/**
+ * @brief FullCAN Entry structure
+ */
+typedef struct {
+	uint8_t controller;		/**&lt; CAN Controller, should be:
+								 - CAN1_CTRL: CAN1 Controller
+								 - CAN2_CTRL: CAN2 Controller
+							*/
+	uint8_t disable;		/**&lt; Disable bit, should be:
+								 - MSG_ENABLE: disable bit = 0
+								 - MSG_DISABLE: disable bit = 1
+							*/
+	uint16_t id_11;			/**&lt; Standard ID, should be 11-bit value */
+} FullCAN_Entry;
+
+/**
+ * @brief Standard ID Frame Format Entry structure
+ */
+typedef struct {
+	uint8_t controller; 	/**&lt; CAN Controller, should be:
+								 - CAN1_CTRL: CAN1 Controller
+								 - CAN2_CTRL: CAN2 Controller
+							*/
+	uint8_t disable; 		/**&lt; Disable bit, should be:
+								 - MSG_ENABLE: disable bit = 0
+								 - MSG_DISABLE: disable bit = 1
+							*/
+	uint16_t id_11; 		/**&lt; Standard ID, should be 11-bit value */
+} SFF_Entry;
+
+/**
+ * @brief Group of Standard ID Frame Format Entry structure
+ */
+typedef struct {
+	uint8_t controller1; 	/**&lt; First CAN Controller, should be:
+								 - CAN1_CTRL: CAN1 Controller
+								 - CAN2_CTRL: CAN2 Controller
+							*/
+	uint8_t disable1; 		/**&lt; First Disable bit, should be:
+								 - MSG_ENABLE: disable bit = 0)
+								 - MSG_DISABLE: disable bit = 1
+							*/
+	uint16_t lowerID; 		/**&lt; ID lower bound, should be 11-bit value */
+	uint8_t controller2; 	/**&lt; Second CAN Controller, should be:
+								 - CAN1_CTRL: CAN1 Controller
+								 - CAN2_CTRL: CAN2 Controller
+							*/
+	uint8_t disable2; 		/**&lt; Second Disable bit, should be:
+								 - MSG_ENABLE: disable bit = 0
+								 - MSG_DISABLE: disable bit = 1
+							*/
+	uint16_t upperID; 		/**&lt; ID upper bound, should be 11-bit value and
+								 equal or greater than lowerID
+							*/
+} SFF_GPR_Entry;
+
+/**
+ * @brief Extended ID Frame Format Entry structure
+ */
+typedef struct {
+	uint8_t controller; 	/**&lt; CAN Controller, should be:
+								 - CAN1_CTRL: CAN1 Controller
+								 - CAN2_CTRL: CAN2 Controller
+							*/
+	uint32_t ID_29; 		/**&lt; Extend ID, shoud be 29-bit value */
+} EFF_Entry;
+
+
+/**
+ * @brief Group of Extended ID Frame Format Entry structure
+ */
+typedef struct {
+	uint8_t controller1; 	/**&lt; First CAN Controller, should be:
+								 - CAN1_CTRL: CAN1 Controller
+								 - CAN2_CTRL: CAN2 Controller
+							*/
+	uint8_t controller2; 	/**&lt; Second Disable bit, should be:
+								 - MSG_ENABLE: disable bit = 0(default)
+								 - MSG_DISABLE: disable bit = 1
+							*/
+	uint32_t lowerEID; 		/**&lt; Extended ID lower bound, should be 29-bit value */
+	uint32_t upperEID; 		/**&lt; Extended ID upper bound, should be 29-bit value */
+} EFF_GPR_Entry;
+
+
+/**
+ * @brief Acceptance Filter Section Table structure
+ */
+typedef struct {
+	FullCAN_Entry* FullCAN_Sec; 	/**&lt; The pointer point to FullCAN_Entry */
+	uint8_t FC_NumEntry;			/**&lt; FullCAN Entry Number */
+	SFF_Entry* SFF_Sec; 			/**&lt; The pointer point to SFF_Entry */
+	uint8_t SFF_NumEntry;			/**&lt; Standard ID Entry Number */
+	SFF_GPR_Entry* SFF_GPR_Sec; 	/**&lt; The pointer point to SFF_GPR_Entry */
+	uint8_t SFF_GPR_NumEntry;		/**&lt; Group Standard ID Entry Number */
+	EFF_Entry* EFF_Sec; 			/**&lt; The pointer point to EFF_Entry */
+	uint8_t EFF_NumEntry;			/**&lt; Extended ID Entry Number */
+	EFF_GPR_Entry* EFF_GPR_Sec; 	/**&lt; The pointer point to EFF_GPR_Entry */
+	uint8_t EFF_GPR_NumEntry;		/**&lt; Group Extended ID Entry Number */
+} AF_SectionDef;
+
+/**
+ * @brief CAN call-back function type definitions
+ */
+typedef void ( fnCANCbs_Type)();
+
+
+/**
+ * @}
+ */
+
+
+/* Public Macros -------------------------------------------------------------- */
+/** @defgroup CAN_Public_Macros
+ * @{
+ */
+
+/** Macro to determine if it is valid CAN peripheral */
+#define PARAM_CANx(x)			((((uint32_t*)x)==((uint32_t *)LPC_CAN1)) \
+||(((uint32_t*)x)==((uint32_t *)LPC_CAN2)))
+
+#define PARAM_CANAFx(x)			(((uint32_t*)x)== ((uint32_t*)LPC_CANAF))
+#define PARAM_CANAFRAMx(x)		(((uint32_t*)x)== (uint32_t*)LPC_CANAF_RAM)
+#define PARAM_CANCRx(x)			(((uint32_t*)x)==((uint32_t*)LPC_CANCR))
+
+/** Macro to check Data to send valid */
+#define PARAM_I2S_DATA(data) 	((data&gt;=0)&amp;&amp;(data &lt;= 0xFFFFFFFF))
+#define PRAM_I2S_FREQ(freq)		((freq&gt;=16000)&amp;&amp;(freq &lt;= 96000))
+
+/** Macro to check Pin Selection value */
+#define PARAM_RD1_PIN(n)		((n==CAN_RD1_P0_0)||(n==CAN_RD1_P0_21))
+#define PARAM_TD1_PIN(n)		((n==CAN_TD1_P0_1)||(n==CAN_TD1_P0_22))
+#define PARAM_RD2_PIN(n)		((n==CAN_RD2_P0_4)||(n==CAN_RD2_P2_7))
+#define PARAM_TD2_PIN(n)		((n==CAN_TD2_P0_5)||(n==CAN_TD2_P2_8))
+
+/** Macro to check Frame Identifier */
+#define PARAM_ID_11(n)			((n&gt;&gt;11)==0) /*-- 11 bit --*/
+#define PARAM_ID_29(n)			((n&gt;&gt;29)==0) /*-- 29 bit --*/
+
+#define PARAM_DLC(n)			((n&gt;&gt;4)==0)  /*-- 4 bit --*/
+#define PARAM_ID_FORMAT(n)		((n==STD_ID_FORMAT)||(n==EXT_ID_FORMAT))
+#define PARAM_GRP_ID(x, y)		((x&lt;=y))
+#define PARAM_FRAME_TYPE(n)		((n==DATA_FRAME)||(n==REMOTE_FRAME))
+
+/** Macro to check Control/Central Status type parameter */
+#define PARAM_CTRL_STS_TYPE(n)	((n==CANCTRL_GLOBAL_STS)||(n==CANCTRL_INT_CAP) \
+||(n==CANCTRL_ERR_WRN)||(n==CANCTRL_STS))
+#define PARAM_CR_STS_TYPE(n)	((n==CANCR_TX_STS)||(n==CANCR_RX_STS) \
+||(n==CANCR_MS))
+/** Macro to check AF Mode type parameter */
+#define PARAM_AFMODE_TYPE(n)	((n==CAN_Normal)||(n==CAN_AccOff) \
+||(n==CAN_AccBP)||(n==CAN_eFCAN))
+/** Macro to check Operation Mode */
+#define PARAM_MODE_TYPE(n)		((n==CAN_OPERATING_MODE)||(n==CAN_RESET_MODE) \
+||(n==CAN_LISTENONLY_MODE)||(n==CAN_SELFTEST_MODE) \
+||(n==CAN_TXPRIORITY_MODE)||(n==CAN_SLEEP_MODE) \
+||(n==CAN_RXPOLARITY_MODE)||(n==CAN_TEST_MODE))
+
+/** Macro define for struct AF_Section parameter */
+#define CAN1_CTRL	((uint8_t)(0))
+#define CAN2_CTRL	((uint8_t)(1))
+#define PARAM_CTRL(n)	((n==CAN1_CTRL)|(n==CAN2_CTRL))
+
+#define MSG_ENABLE				((uint8_t)(0))
+#define MSG_DISABLE				((uint8_t)(1))
+#define PARAM_MSG_DISABLE(n)	((n==MSG_ENABLE)|(n==MSG_DISABLE))
+
+/**Macro to check Interrupt Type parameter */
+#define PARAM_INT_EN_TYPE(n)	((n==CANINT_RIE)||(n==CANINT_TIE1) \
+||(n==CANINT_EIE)||(n==CANINT_DOIE) \
+||(n==CANINT_WUIE)||(n==CANINT_EPIE) \
+||(n==CANINT_ALIE)||(n==CANINT_BEIE) \
+||(n==CANINT_IDIE)||(n==CANINT_TIE2) \
+||(n==CANINT_TIE3)||(n==CANINT_FCE))
+
+/** Macro to check AFLUT Entry type */
+#define PARAM_AFLUT_ENTRY_TYPE(n)	((n==FULLCAN_ENTRY)||(n==EXPLICIT_STANDARD_ENTRY)\
+||(n==GROUP_STANDARD_ENTRY)||(n==EXPLICIT_EXTEND_ENTRY)	\
+||(n==GROUP_EXTEND_ENTRY))
+#define PARAM_POSITION(n)	((n&gt;=0)&amp;&amp;(n&lt;512))
+
+/** CAN function pin selection defines */
+#define CAN_RD1_P0_0		((uint8_t)(0))
+#define CAN_RD1_P0_21		((uint8_t)(1))
+#define CAN_TD1_P0_1		((uint8_t)(0))
+#define CAN_TD1_P0_22		((uint8_t)(1))
+
+#define CAN_RD2_P0_4		((uint8_t)(0))
+#define CAN_RD2_P2_7		((uint8_t)(1))
+#define CAN_TD2_P0_5		((uint8_t)(0))
+#define CAN_TD2_P2_8		((uint8_t)(1))
+
+
+/**
+ * @}
+ */
+
+
+/* Public Functions ----------------------------------------------------------- */
+/** @defgroup CAN_Public_Functions
+ * @{
+ */
+
+void CAN_Init(LPC_CAN_TypeDef *CANx, uint32_t baudrate);
+void CAN_DeInit(LPC_CAN_TypeDef *CANx);
+
+Status CAN_SendMsg(LPC_CAN_TypeDef *CANx, CAN_MSG_Type *CAN_Msg);
+Status CAN_ReceiveMsg(LPC_CAN_TypeDef *CANx, CAN_MSG_Type *CAN_Msg);
+CAN_ERROR FCAN_ReadObj(LPC_CANAF_TypeDef* CANAFx, CAN_MSG_Type *CAN_Msg);
+
+uint32_t CAN_GetCTRLStatus(LPC_CAN_TypeDef* CANx, CAN_CTRL_STS_Type arg);
+uint32_t CAN_GetCRStatus(LPC_CANCR_TypeDef* CANCRx, CAN_CR_STS_Type arg);
+void CAN_ModeConfig(LPC_CAN_TypeDef* CANx, CAN_MODE_Type mode,
+		FunctionalState NewState);
+void CAN_SetBaudRate(LPC_CAN_TypeDef *CANx, uint32_t baudrate);
+
+void CAN_SetAFMode(LPC_CANAF_TypeDef* CANAFx, CAN_AFMODE_Type AFmode);
+CAN_ERROR CAN_SetupAFLUT(LPC_CANAF_TypeDef* CANAFx, AF_SectionDef* AFSection);
+CAN_ERROR CAN_LoadFullCANEntry(LPC_CAN_TypeDef* CANx, uint16_t ID);
+CAN_ERROR CAN_LoadExplicitEntry(LPC_CAN_TypeDef* CANx, uint32_t ID,
+		CAN_ID_FORMAT_Type format);
+CAN_ERROR CAN_LoadGroupEntry(LPC_CAN_TypeDef* CANx, uint32_t lowerID,
+		uint32_t upperID, CAN_ID_FORMAT_Type format);
+CAN_ERROR CAN_RemoveEntry(AFLUT_ENTRY_Type EntryType, uint16_t position);
+
+void CAN_SetupCBS(CAN_INT_EN_Type arg, fnCANCbs_Type* pnCANCbs);
+void CAN_IRQCmd(LPC_CAN_TypeDef* CANx, CAN_INT_EN_Type arg,
+		FunctionalState NewState);
+void CAN_IntHandler(LPC_CAN_TypeDef* CANx);
+
+/**
+ * @}
+ */
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LPC17XX_CAN_H_ */
+
+/**
+ * @}
+ */
+
+/* --------------------------------- End Of File ------------------------------ */


Property changes on: trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_can.h
___________________________________________________________________
Deleted: svn:executable
   - *

Modified: trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_clkpwr.h
===================================================================
--- trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_clkpwr.h	2010-06-28 21:53:59 UTC (rev 759)
+++ trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_clkpwr.h	2010-07-12 20:56:54 UTC (rev 760)
@@ -1,394 +1,384 @@
-/***********************************************************************//**
- * @file	: lpc17xx_clkpwr.h
- * @brief	: Contains all macro definitions and function prototypes
- * 				support for Clock and Power Control firmware library on LPC17xx
- * @version	: 1.0
- * @date	: 18. Mar. 2009
- * @author	: HieuNguyen
- **************************************************************************
- * Software that is described herein is for illustrative purposes only
- * which provides customers with programming information regarding the
- * products. This software is supplied &quot;AS IS&quot; without any warranties.
- * NXP Semiconductors assumes no responsibility or liability for the
- * use of the software, conveys no license or title under any patent,
- * copyright, or mask work right to the product. NXP Semiconductors
- * reserves the right to make changes in the software without
- * notification. NXP Semiconductors also make no representation or
- * warranty that such application will be suitable for the specified
- * use without further testing or modification.
- **************************************************************************/
-
-/* Peripheral group ----------------------------------------------------------- */
-/** @defgroup CLKPWR
- * @ingroup LPC1700CMSIS_FwLib_Drivers
- * @{
- */
-
-#ifndef LPC17XX_CLKPWR_H_
-#define LPC17XX_CLKPWR_H_
-
-/* Includes ------------------------------------------------------------------- */
-#include &quot;LPC17xx.h&quot;
-#include &quot;lpc_types.h&quot;
-
-#ifdef __cplusplus
-extern &quot;C&quot;
-{
-#endif
-
-
-/* Private Macros ------------------------------------------------------------- */
-/** @defgroup CLKPWR_Private_Macros
- * @{
- */
-
-/** @defgroup CLKPPWR_REGISTER_BIT_DEFINITIONS
- * @{
- */
-
-/* Clock source selection multiplexer definition */
-/** Internal RC oscillator */
-#define CLKPWR_CLKSRCSEL_CLKSRC_IRC			((uint32_t)(0x00))
-/** Main oscillator */
-#define CLKPWR_CLKSRCSEL_CLKSRC_MAINOSC		((uint32_t)(0x01))
-/** RTC oscillator */
-#define CLKPWR_CLKSRCSEL_CLKSRC_RTC			((uint32_t)(0x02))
-/** Clock source selection bit mask */
-#define CLKPWR_CLKSRCSEL_BITMASK			((uint32_t)(0x03))
-
-
-/* Clock Output Configuration register definition */
-/** Selects the CPU clock as the CLKOUT source */
-#define CLKPWR_CLKOUTCFG_CLKOUTSEL_CPU		((uint32_t)(0x00))
-/** Selects the main oscillator as the CLKOUT source */
-#define CLKPWR_CLKOUTCFG_CLKOUTSEL_MAINOSC	((uint32_t)(0x01))
-/** Selects the Internal RC oscillator as the CLKOUT source */
-#define CLKPWR_CLKOUTCFG_CLKOUTSEL_RC		((uint32_t)(0x02))
-/** Selects the USB clock as the CLKOUT source */
-#define CLKPWR_CLKOUTCFG_CLKOUTSEL_USB		((uint32_t)(0x03))
-/** Selects the RTC oscillator as the CLKOUT source */
-#define CLKPWR_CLKOUTCFG_CLKOUTSEL_RTC		((uint32_t)(0x04))
-/** Integer value to divide the output clock by, minus one */
-#define CLKPWR_CLKOUTCFG_CLKOUTDIV(n)		((uint32_t)((n&amp;0x0F)&lt;&lt;4))
-/** CLKOUT enable control */
-#define CLKPWR_CLKOUTCFG_CLKOUT_EN			((uint32_t)(1&lt;&lt;8))
-/** CLKOUT activity indication */
-#define CLKPWR_CLKOUTCFG_CLKOUT_ACT			((uint32_t)(1&lt;&lt;9))
-/** Clock source selection bit mask */
-#define CLKPWR_CLKOUTCFG_BITMASK			((uint32_t)(0x3FF))
-
-
-/* PLL 0 control definition */
-/** PLL 0 control enable */
-#define CLKPWR_PLL0CON_ENABLE		((uint32_t)(0x01))
-/** PLL 0 control connect */
-#define CLKPWR_PLL0CON_CONNECT		((uint32_t)(0x02))
-/** PLL 0 control bit mask */
-#define CLKPWR_PLL0CON_BITMASK		((uint32_t)(0x03))
-
-
-/* PLL 0 Configuration register definition */
-/** PLL 0 Configuration MSEL field */
-#define CLKPWR_PLL0CFG_MSEL(n)		((uint32_t)(n&amp;0x7FFF))
-/** PLL 0 Configuration NSEL field */
-#define CLKPWR_PLL0CFG_NSEL(n)		((uint32_t)((n&lt;&lt;16)&amp;0xFF0000))
-/** PLL 0 Configuration bit mask */
-#define CLKPWR_PLL0CFG_BITMASK		((uint32_t)(0xFF7FFF))
-
-
-/* PLL 0 status definition */
-/** PLL 0 MSEL value */
-#define CLKPWR_PLL0STAT_MSEL(n)		((uint32_t)(n&amp;0x7FFF))
-/** PLL NSEL get value  */
-#define CLKPWR_PLL0STAT_NSEL(n)		((uint32_t)((n&gt;&gt;16)&amp;0xFF))
-/** PLL status enable bit */
-#define CLKPWR_PLL0STAT_PLLE		((uint32_t)(1&lt;&lt;24))
-/** PLL status Connect bit */
-#define CLKPWR_PLL0STAT_PLLC		((uint32_t)(1&lt;&lt;25))
-/** PLL status lock */
-#define CLKPWR_PLL0STAT_PLOCK		((uint32_t)(1&lt;&lt;26))
-
-
-/* PLL0 Feed register definition */
-/** PLL0 Feed bit mask */
-#define CLKPWR_PLL0FEED_BITMASK			((uint32_t)0xFF)
-
-
-/* USB PLL control definition */
-/** USB PLL control enable */
-#define CLKPWR_PLL1CON_ENABLE		((uint32_t)(0x01))
-/** USB PLL control connect */
-#define CLKPWR_PLL1CON_CONNECT		((uint32_t)(0x02))
-/** USB PLL control bit mask */
-#define CLKPWR_PLL1CON_BITMASK		((uint32_t)(0x03))
-
-
-/* USB PLL configuration definition */
-/** USB PLL MSEL set value */
-#define CLKPWR_PLL1CFG_MSEL(n)		((uint32_t)(n&amp;0x1F))
-/** USB PLL PSEL set value */
-#define CLKPWR_PLL1CFG_PSEL(n)		((uint32_t)((n&amp;0x03)&lt;&lt;5))
-/** USB PLL configuration bit mask */
-#define CLKPWR_PLL1CFG_BITMASK		((uint32_t)(0x7F))
-
-
-/* USB PLL status definition */
-/** USB PLL MSEL get value  */
-#define CLKPWR_PLL1STAT_MSEL(n)		((uint32_t)(n&amp;0x1F))
-/** USB PLL PSEL get value  */
-#define CLKPWR_PLL1STAT_PSEL(n)		((uint32_t)((n&gt;&gt;5)&amp;0x03))
-/** USB PLL status enable bit */
-#define CLKPWR_PLL1STAT_PLLE		((uint32_t)(1&lt;&lt;8))
-/** USB PLL status Connect bit */
-#define CLKPWR_PLL1STAT_PLLC		((uint32_t)(1&lt;&lt;9))
-/** USB PLL status lock */
-#define CLKPWR_PLL1STAT_PLOCK		((uint32_t)(1&lt;&lt;10))
-
-
-/* PLL1 Feed register definition */
-/** PLL1 Feed bit mask */
-#define CLKPWR_PLL1FEED_BITMASK		((uint32_t)0xFF)
-
-
-/* CPU Clock Configuration register definition */
-/** CPU Clock configuration bit mask */
-#define CLKPWR_CCLKCFG_BITMASK		((uint32_t)(0xFF))
-
-/* USB Clock Configuration register definition */
-/** USB Clock Configuration bit mask */
-#define CLKPWR_USBCLKCFG_BITMASK	((uint32_t)(0x0F))
-
-/* IRC Trim register definition */
-/** IRC Trim bit mask */
-#define CLKPWR_IRCTRIM_BITMASK		((uint32_t)(0x0F))
-
-
-/* Peripheral clock divider bit position definition */
-/** Peripheral Clock Selection 0 mask bit */
-#define CLKPWR_PCLKSEL0_BITMASK		((uint32_t)(0xFFF3F3FF))
-/** Peripheral Clock Selection 1 mask bit */
-#define CLKPWR_PCLKSEL1_BITMASK		((uint32_t)(0xFCF3F0F3))
-
-
-/** Macro to set peripheral clock of each type
- * p: position of two bits that hold divider of peripheral clock
- * n: value of divider of peripheral clock  to be set */
-#define CLKPWR_PCLKSEL_SET(p,n)		_SBF(p,n)
-/** Macro to mask peripheral clock of each type */
-#define CLKPWR_PCLKSEL_BITMASK(p)	_SBF(p,0x03)
-/** Macro to get peripheral clock of each type */
-#define CLKPWR_PCLKSEL_GET(p, n)	((uint32_t)((n&gt;&gt;p)&amp;0x03))
-
-
-/* Power Mode Control register definition */
-/** Power mode control bit 0 */
-#define CLKPWR_PCON_PM0			((uint32_t)(1&lt;&lt;0))
-/** Power mode control bit 1 */
-#define CLKPWR_PCON_PM1			((uint32_t)(1&lt;&lt;1))
-/** Brown-Out Reduced Power Mode */
-#define CLKPWR_PCON_BODPDM		((uint32_t)(1&lt;&lt;2))
-/** Brown-Out Global Disable */
-#define CLKPWR_PCON_BOGD		((uint32_t)(1&lt;&lt;3))
-/** Brown Out Reset Disable */
-#define CLKPWR_PCON_BORD		((uint32_t)(1&lt;&lt;4))
-/** Sleep Mode entry flag */
-#define CLKPWR_PCON_SMFLAG		((uint32_t)(1&lt;&lt;8))
-/** Deep Sleep entry flag */
-#define CLKPWR_PCON_DSFLAG		((uint32_t)(1&lt;&lt;9))
-/** Power-down entry flag */
-#define CLKPWR_PCON_PDFLAG		((uint32_t)(1&lt;&lt;10))
-/** Deep Power-down entry flag */
-#define CLKPWR_PCON_DPDFLAG		((uint32_t)(1&lt;&lt;11))
-
-
-/** Power Control for Peripherals bit mask */
-#define CLKPWR_PCONP_BITMASK	0xEFEFF7DE
-
-/**
- * @}
- */
-
-/**
- * @}
- */
-
-
-/* Public Types --------------------------------------------------------------- */
-/** @defgroup CLKPWR_Public_Types
- * @{
- */
-
-/**
- * @}
- */
-
-
-/* Public Macros -------------------------------------------------------------- */
-/** @defgroup CLKPWR_Public_Macros
- * @{
- */
-
-/**********************************************************************
- * Peripheral Clock Selection Definitions
- **********************************************************************/
-/** Peripheral clock divider bit position for WDT */
-#define	CLKPWR_PCLKSEL_WDT  		((uint32_t)(0))
-/** Peripheral clock divider bit position for TIMER0 */
-#define	CLKPWR_PCLKSEL_TIMER0  		((uint32_t)(2))
-/** Peripheral clock divider bit position for TIMER1 */
-#define	CLKPWR_PCLKSEL_TIMER1  		((uint32_t)(4))
-/** Peripheral clock divider bit position for UART0 */
-#define	CLKPWR_PCLKSEL_UART0  		((uint32_t)(6))
-/** Peripheral clock divider bit position for UART1 */
-#define	CLKPWR_PCLKSEL_UART1  		((uint32_t)(8))
-/** Peripheral clock divider bit position for PWM1 */
-#define	CLKPWR_PCLKSEL_PWM1  		((uint32_t)(12))
-/** Peripheral clock divider bit position for I2C0 */
-#define	CLKPWR_PCLKSEL_I2C0  		((uint32_t)(14))
-/** Peripheral clock divider bit position for SPI */
-#define	CLKPWR_PCLKSEL_SPI  		((uint32_t)(16))
-/** Peripheral clock divider bit position for SSP1 */
-#define	CLKPWR_PCLKSEL_SSP1  		((uint32_t)(20))
-/** Peripheral clock divider bit position for DAC */
-#define	CLKPWR_PCLKSEL_DAC  		((uint32_t)(22))
-/** Peripheral clock divider bit position for ADC */
-#define	CLKPWR_PCLKSEL_ADC  		((uint32_t)(24))
-/** Peripheral clock divider bit position for CAN1 */
-#define	CLKPWR_PCLKSEL_CAN1 		((uint32_t)(26))
-/** Peripheral clock divider bit position for CAN2 */
-#define	CLKPWR_PCLKSEL_CAN2 		((uint32_t)(28))
-/** Peripheral clock divider bit position for ACF */
-#define	CLKPWR_PCLKSEL_ACF  		((uint32_t)(30))
-/** Peripheral clock divider bit position for QEI */
-#define	CLKPWR_PCLKSEL_QEI	  		((uint32_t)(32))
-/** Peripheral clock divider bit position for PCB */
-#define	CLKPWR_PCLKSEL_PCB  		((uint32_t)(36))
-/** Peripheral clock divider bit position for  I2C1 */
-#define	CLKPWR_PCLKSEL_I2C1  		((uint32_t)(38))
-/** Peripheral clock divider bit position for SSP0 */
-#define	CLKPWR_PCLKSEL_SSP0  		((uint32_t)(42))
-/** Peripheral clock divider bit position for TIMER2 */
-#define	CLKPWR_PCLKSEL_TIMER2  		((uint32_t)(44))
-/** Peripheral clock divider bit position for  TIMER3 */
-#define	CLKPWR_PCLKSEL_TIMER3  		((uint32_t)(46))
-/** Peripheral clock divider bit position for UART2 */
-#define	CLKPWR_PCLKSEL_UART2  		((uint32_t)(48))
-/** Peripheral clock divider bit position for UART3 */
-#define	CLKPWR_PCLKSEL_UART3  		((uint32_t)(50))
-/** Peripheral clock divider bit position for I2C2 */
-#define	CLKPWR_PCLKSEL_I2C2  		((uint32_t)(52))
-/** Peripheral clock divider bit position for I2S */
-#define	CLKPWR_PCLKSEL_I2S  		((uint32_t)(54))
-/** Peripheral clock divider bit position for RIT */
-#define	CLKPWR_PCLKSEL_RIT  		((uint32_t)(58))
-/** Peripheral clock divider bit position for SYSCON */
-#define	CLKPWR_PCLKSEL_SYSCON  		((uint32_t)(60))
-/** Peripheral clock divider bit position for MC */
-#define	CLKPWR_PCLKSEL_MC		  	((uint32_t)(62))
-
-/** Macro for Peripheral Clock Selection register bit values
- * Note: When CCLK_DIV_8, Peripheral&#146;s clock is selected to
- * PCLK_xyz = CCLK/8 except for CAN1, CAN2, and CAN filtering
- * when &#146;11&#146;selects PCLK_xyz = CCLK/6 */
-/* Peripheral clock divider is set to 4 from CCLK */
-#define	CLKPWR_PCLKSEL_CCLK_DIV_4  ((uint32_t)(0))
-/** Peripheral clock divider is the same with CCLK */
-#define	CLKPWR_PCLKSEL_CCLK_DIV_1  ((uint32_t)(1))
-/** Peripheral clock divider is set to 2 from CCLK */
-#define	CLKPWR_PCLKSEL_CCLK_DIV_2  ((uint32_t)(2))
-
-
-/********************************************************************
-* Power Control for Peripherals Definitions
-**********************************************************************/
-/** Timer/Counter 0 power/clock control bit */
-#define	 CLKPWR_PCONP_PCTIM0	((uint32_t)(1&lt;&lt;1))
-/* Timer/Counter 1 power/clock control bit */
-#define	 CLKPWR_PCONP_PCTIM1	((uint32_t)(1&lt;&lt;2))
-/** UART0 power/clock control bit */
-#define	 CLKPWR_PCONP_PCUART0  	((uint32_t)(1&lt;&lt;3))
-/** UART1 power/clock control bit */
-#define	 CLKPWR_PCONP_PCUART1  	((uint32_t)(1&lt;&lt;4))
-/** PWM1 power/clock control bit */
-#define	 CLKPWR_PCONP_PCPWM1	((uint32_t)(1&lt;&lt;6))
-/** The I2C0 interface power/clock control bit */
-#define	 CLKPWR_PCONP_PCI2C0	((uint32_t)(1&lt;&lt;7))
-/** The SPI interface power/clock control bit */
-#define	 CLKPWR_PCONP_PCSPI  	((uint32_t)(1&lt;&lt;8))
-/** The RTC power/clock control bit */
-#define	 CLKPWR_PCONP_PCRTC  	((uint32_t)(1&lt;&lt;9))
-/** The SSP1 interface power/clock control bit */
-#define	 CLKPWR_PCONP_PCSSP1	((uint32_t)(1&lt;&lt;10))
-/** A/D converter 0 (ADC0) power/clock control bit */
-#define	 CLKPWR_PCONP_PCAD  	((uint32_t)(1&lt;&lt;12))
-/** CAN Controller 1 power/clock control bit */
-#define	 CLKPWR_PCONP_PCAN1  	((uint32_t)(1&lt;&lt;13))
-/** CAN Controller 2 power/clock control bit */
-#define	 CLKPWR_PCONP_PCAN2  	((uint32_t)(1&lt;&lt;14))
-/** GPIO power/clock control bit */
-#define	CLKPWR_PCONP_PCGPIO		((uint32_t)(1&lt;&lt;15))
-/** Repetitive Interrupt Timer power/clock control bit */
-#define	CLKPWR_PCONP_PCRIT		((uint32_t)(1&lt;&lt;16))
-/** Motor Control PWM */
-#define CLKPWR_PCONP_PCMC		((uint32_t)(1&lt;&lt;17))
-/** Quadrature Encoder Interface power/clock control bit */
-#define CLKPWR_PCONP_PCQEI		((uint32_t)(1&lt;&lt;18))
-/** The I2C1 interface power/clock control bit */
-#define	 CLKPWR_PCONP_PCI2C1  	((uint32_t)(1&lt;&lt;19))
-/** The SSP0 interface power/clock control bit */
-#define	 CLKPWR_PCONP_PCSSP0	((uint32_t)(1&lt;&lt;21))
-/** Timer 2 power/clock control bit */
-#define	 CLKPWR_PCONP_PCTIM2	((uint32_t)(1&lt;&lt;22))
-/** Timer 3 power/clock control bit */
-#define	 CLKPWR_PCONP_PCTIM3	((uint32_t)(1&lt;&lt;23))
-/** UART 2 power/clock control bit */
-#define	 CLKPWR_PCONP_PCUART2  	((uint32_t)(1&lt;&lt;24))
-/** UART 3 power/clock control bit */
-#define	 CLKPWR_PCONP_PCUART3  	((uint32_t)(1&lt;&lt;25))
-/** I2C interface 2 power/clock control bit */
-#define	 CLKPWR_PCONP_PCI2C2	((uint32_t)(1&lt;&lt;26))
-/** I2S interface power/clock control bit*/
-#define	 CLKPWR_PCONP_PCI2S  	((uint32_t)(1&lt;&lt;27))
-/** GP DMA function power/clock control bit*/
-#define	 CLKPWR_PCONP_PCGPDMA  	((uint32_t)(1&lt;&lt;29))
-/** Ethernet block power/clock control bit*/
-#define	 CLKPWR_PCONP_PCENET	((uint32_t)(1&lt;&lt;30))
-/** USB interface power/clock control bit*/
-#define	 CLKPWR_PCONP_PCUSB  	((uint32_t)(1&lt;&lt;31))
-
-
-/**
- * @}
- */
-
-
-/* Public Functions ----------------------------------------------------------- */
-/** @defgroup CLKPWR_Public_Functions
- * @{
- */
-
-void CLKPWR_SetPCLKDiv (uint32_t ClkType, uint32_t DivVal);
-uint32_t CLKPWR_GetPCLKSEL (uint32_t ClkType);
-uint32_t CLKPWR_GetPCLK (uint32_t ClkType);
-void CLKPWR_ConfigPPWR (uint32_t PPType, FunctionalState NewState);
-void CLKPWR_Sleep(void);
-void CLKPWR_DeepSleep(void);
-void CLKPWR_PowerDown(void);
-void CLKPWR_DeepPowerDown(void);
-
-/**
- * @}
- */
-
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* LPC17XX_CLKPWR_H_ */
-
-/**
- * @}
- */
-
-/* --------------------------------- End Of File ------------------------------ */
+/***********************************************************************//**
+ * @file	: lpc17xx_clkpwr.h
+ * @brief	: Contains all macro definitions and function prototypes
+ * 				support for Clock and Power Control firmware library on LPC17xx
+ * @version	: 1.0
+ * @date	: 18. Mar. 2009
+ * @author	: HieuNguyen
+ **************************************************************************
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * products. This software is supplied &quot;AS IS&quot; without any warranties.
+ * NXP Semiconductors assumes no responsibility or liability for the
+ * use of the software, conveys no license or title under any patent,
+ * copyright, or mask work right to the product. NXP Semiconductors
+ * reserves the right to make changes in the software without
+ * notification. NXP Semiconductors also make no representation or
+ * warranty that such application will be suitable for the specified
+ * use without further testing or modification.
+ **************************************************************************/
+
+/* Peripheral group ----------------------------------------------------------- */
+/** @defgroup CLKPWR
+ * @ingroup LPC1700CMSIS_FwLib_Drivers
+ * @{
+ */
+
+#ifndef LPC17XX_CLKPWR_H_
+#define LPC17XX_CLKPWR_H_
+
+/* Includes ------------------------------------------------------------------- */
+#include &quot;lpc17xx.h&quot;
+#include &quot;lpc_types.h&quot;
+
+#ifdef __cplusplus
+extern &quot;C&quot;
+{
+#endif
+
+
+/* Private Macros ------------------------------------------------------------- */
+/** @defgroup CLKPWR_Private_Macros
+ * @{
+ */
+
+/** @defgroup CLKPPWR_REGISTER_BIT_DEFINITIONS
+ * @{
+ */
+
+/* Clock source selection multiplexer definition */
+/** Internal RC oscillator */
+#define CLKPWR_CLKSRCSEL_CLKSRC_IRC			((uint32_t)(0x00))
+/** Main oscillator */
+#define CLKPWR_CLKSRCSEL_CLKSRC_MAINOSC		((uint32_t)(0x01))
+/** RTC oscillator */
+#define CLKPWR_CLKSRCSEL_CLKSRC_RTC			((uint32_t)(0x02))
+/** Clock source selection bit mask */
+#define CLKPWR_CLKSRCSEL_BITMASK			((uint32_t)(0x03))
+
+
+/* Clock Output Configuration register definition */
+/** Selects the CPU clock as the CLKOUT source */
+#define CLKPWR_CLKOUTCFG_CLKOUTSEL_CPU		((uint32_t)(0x00))
+/** Selects the main oscillator as the CLKOUT source */
+#define CLKPWR_CLKOUTCFG_CLKOUTSEL_MAINOSC	((uint32_t)(0x01))
+/** Selects the Internal RC oscillator as the CLKOUT source */
+#define CLKPWR_CLKOUTCFG_CLKOUTSEL_RC		((uint32_t)(0x02))
+/** Selects the USB clock as the CLKOUT source */
+#define CLKPWR_CLKOUTCFG_CLKOUTSEL_USB		((uint32_t)(0x03))
+/** Selects the RTC oscillator as the CLKOUT source */
+#define CLKPWR_CLKOUTCFG_CLKOUTSEL_RTC		((uint32_t)(0x04))
+/** Integer value to divide the output clock by, minus one */
+#define CLKPWR_CLKOUTCFG_CLKOUTDIV(n)		((uint32_t)((n&amp;0x0F)&lt;&lt;4))
+/** CLKOUT enable control */
+#define CLKPWR_CLKOUTCFG_CLKOUT_EN			((uint32_t)(1&lt;&lt;8))
+/** CLKOUT activity indication */
+#define CLKPWR_CLKOUTCFG_CLKOUT_ACT			((uint32_t)(1&lt;&lt;9))
+/** Clock source selection bit mask */
+#define CLKPWR_CLKOUTCFG_BITMASK			((uint32_t)(0x3FF))
+
+
+/* PLL 0 control definition */
+/** PLL 0 control enable */
+#define CLKPWR_PLL0CON_ENABLE		((uint32_t)(0x01))
+/** PLL 0 control connect */
+#define CLKPWR_PLL0CON_CONNECT		((uint32_t)(0x02))
+/** PLL 0 control bit mask */
+#define CLKPWR_PLL0CON_BITMASK		((uint32_t)(0x03))
+
+
+/* PLL 0 Configuration register definition */
+/** PLL 0 Configuration MSEL field */
+#define CLKPWR_PLL0CFG_MSEL(n)		((uint32_t)(n&amp;0x7FFF))
+/** PLL 0 Configuration NSEL field */
+#define CLKPWR_PLL0CFG_NSEL(n)		((uint32_t)((n&lt;&lt;16)&amp;0xFF0000))
+/** PLL 0 Configuration bit mask */
+#define CLKPWR_PLL0CFG_BITMASK		((uint32_t)(0xFF7FFF))
+
+
+/* PLL 0 status definition */
+/** PLL 0 MSEL value */
+#define CLKPWR_PLL0STAT_MSEL(n)		((uint32_t)(n&amp;0x7FFF))
+/** PLL NSEL get value  */
+#define CLKPWR_PLL0STAT_NSEL(n)		((uint32_t)((n&gt;&gt;16)&amp;0xFF))
+/** PLL status enable bit */
+#define CLKPWR_PLL0STAT_PLLE		((uint32_t)(1&lt;&lt;24))
+/** PLL status Connect bit */
+#define CLKPWR_PLL0STAT_PLLC		((uint32_t)(1&lt;&lt;25))
+/** PLL status lock */
+#define CLKPWR_PLL0STAT_PLOCK		((uint32_t)(1&lt;&lt;26))
+
+
+/* PLL0 Feed register definition */
+/** PLL0 Feed bit mask */
+#define CLKPWR_PLL0FEED_BITMASK			((uint32_t)0xFF)
+
+
+/* USB PLL control definition */
+/** USB PLL control enable */
+#define CLKPWR_PLL1CON_ENABLE		((uint32_t)(0x01))
+/** USB PLL control connect */
+#define CLKPWR_PLL1CON_CONNECT		((uint32_t)(0x02))
+/** USB PLL control bit mask */
+#define CLKPWR_PLL1CON_BITMASK		((uint32_t)(0x03))
+
+
+/* USB PLL configuration definition */
+/** USB PLL MSEL set value */
+#define CLKPWR_PLL1CFG_MSEL(n)		((uint32_t)(n&amp;0x1F))
+/** USB PLL PSEL set value */
+#define CLKPWR_PLL1CFG_PSEL(n)		((uint32_t)((n&amp;0x03)&lt;&lt;5))
+/** USB PLL configuration bit mask */
+#define CLKPWR_PLL1CFG_BITMASK		((uint32_t)(0x7F))
+
+
+/* USB PLL status definition */
+/** USB PLL MSEL get value  */
+#define CLKPWR_PLL1STAT_MSEL(n)		((uint32_t)(n&amp;0x1F))
+/** USB PLL PSEL get value  */
+#define CLKPWR_PLL1STAT_PSEL(n)		((uint32_t)((n&gt;&gt;5)&amp;0x03))
+/** USB PLL status enable bit */
+#define CLKPWR_PLL1STAT_PLLE		((uint32_t)(1&lt;&lt;8))
+/** USB PLL status Connect bit */
+#define CLKPWR_PLL1STAT_PLLC		((uint32_t)(1&lt;&lt;9))
+/** USB PLL status lock */
+#define CLKPWR_PLL1STAT_PLOCK		((uint32_t)(1&lt;&lt;10))
+
+
+/* PLL1 Feed register definition */
+/** PLL1 Feed bit mask */
+#define CLKPWR_PLL1FEED_BITMASK		((uint32_t)0xFF)
+
+
+/* CPU Clock Configuration register definition */
+/** CPU Clock configuration bit mask */
+#define CLKPWR_CCLKCFG_BITMASK		((uint32_t)(0xFF))
+
+/* USB Clock Configuration register definition */
+/** USB Clock Configuration bit mask */
+#define CLKPWR_USBCLKCFG_BITMASK	((uint32_t)(0x0F))
+
+/* IRC Trim register definition */
+/** IRC Trim bit mask */
+#define CLKPWR_IRCTRIM_BITMASK		((uint32_t)(0x0F))
+
+
+/* Peripheral clock divider bit position definition */
+/** Peripheral Clock Selection 0 mask bit */
+#define CLKPWR_PCLKSEL0_BITMASK		((uint32_t)(0xFFF3F3FF))
+/** Peripheral Clock Selection 1 mask bit */
+#define CLKPWR_PCLKSEL1_BITMASK		((uint32_t)(0xFCF3F0F3))
+
+
+/** Macro to set peripheral clock of each type
+ * p: position of two bits that hold divider of peripheral clock
+ * n: value of divider of peripheral clock  to be set */
+#define CLKPWR_PCLKSEL_SET(p,n)		_SBF(p,n)
+/** Macro to mask peripheral clock of each type */
+#define CLKPWR_PCLKSEL_BITMASK(p)	_SBF(p,0x03)
+/** Macro to get peripheral clock of each type */
+#define CLKPWR_PCLKSEL_GET(p, n)	((uint32_t)((n&gt;&gt;p)&amp;0x03))
+
+
+/* Power Mode Control register definition */
+/** Power mode control bit 0 */
+#define CLKPWR_PCON_PM0			((uint32_t)(1&lt;&lt;0))
+/** Power mode control bit 1 */
+#define CLKPWR_PCON_PM1			((uint32_t)(1&lt;&lt;1))
+/** Brown-Out Reduced Power Mode */
+#define CLKPWR_PCON_BODPDM		((uint32_t)(1&lt;&lt;2))
+/** Brown-Out Global Disable */
+#define CLKPWR_PCON_BOGD		((uint32_t)(1&lt;&lt;3))
+/** Brown Out Reset Disable */
+#define CLKPWR_PCON_BORD		((uint32_t)(1&lt;&lt;4))
+/** Sleep Mode entry flag */
+#define CLKPWR_PCON_SMFLAG		((uint32_t)(1&lt;&lt;8))
+/** Deep Sleep entry flag */
+#define CLKPWR_PCON_DSFLAG		((uint32_t)(1&lt;&lt;9))
+/** Power-down entry flag */
+#define CLKPWR_PCON_PDFLAG		((uint32_t)(1&lt;&lt;10))
+/** Deep Power-down entry flag */
+#define CLKPWR_PCON_DPDFLAG		((uint32_t)(1&lt;&lt;11))
+
+
+/** Power Control for Peripherals bit mask */
+#define CLKPWR_PCONP_BITMASK	0xEFEFF7DE
+
+/**
+ * @}
+ */
+
+/**
+ * @}
+ */
+
+
+/* Public Macros -------------------------------------------------------------- */
+/** @defgroup CLKPWR_Public_Macros
+ * @{
+ */
+
+/**********************************************************************
+ * Peripheral Clock Selection Definitions
+ **********************************************************************/
+/** Peripheral clock divider bit position for WDT */
+#define	CLKPWR_PCLKSEL_WDT  		((uint32_t)(0))
+/** Peripheral clock divider bit position for TIMER0 */
+#define	CLKPWR_PCLKSEL_TIMER0  		((uint32_t)(2))
+/** Peripheral clock divider bit position for TIMER1 */
+#define	CLKPWR_PCLKSEL_TIMER1  		((uint32_t)(4))
+/** Peripheral clock divider bit position for UART0 */
+#define	CLKPWR_PCLKSEL_UART0  		((uint32_t)(6))
+/** Peripheral clock divider bit position for UART1 */
+#define	CLKPWR_PCLKSEL_UART1  		((uint32_t)(8))
+/** Peripheral clock divider bit position for PWM1 */
+#define	CLKPWR_PCLKSEL_PWM1  		((uint32_t)(12))
+/** Peripheral clock divider bit position for I2C0 */
+#define	CLKPWR_PCLKSEL_I2C0  		((uint32_t)(14))
+/** Peripheral clock divider bit position for SPI */
+#define	CLKPWR_PCLKSEL_SPI  		((uint32_t)(16))
+/** Peripheral clock divider bit position for SSP1 */
+#define	CLKPWR_PCLKSEL_SSP1  		((uint32_t)(20))
+/** Peripheral clock divider bit position for DAC */
+#define	CLKPWR_PCLKSEL_DAC  		((uint32_t)(22))
+/** Peripheral clock divider bit position for ADC */
+#define	CLKPWR_PCLKSEL_ADC  		((uint32_t)(24))
+/** Peripheral clock divider bit position for CAN1 */
+#define	CLKPWR_PCLKSEL_CAN1 		((uint32_t)(26))
+/** Peripheral clock divider bit position for CAN2 */
+#define	CLKPWR_PCLKSEL_CAN2 		((uint32_t)(28))
+/** Peripheral clock divider bit position for ACF */
+#define	CLKPWR_PCLKSEL_ACF  		((uint32_t)(30))
+/** Peripheral clock divider bit position for QEI */
+#define	CLKPWR_PCLKSEL_QEI	  		((uint32_t)(32))
+/** Peripheral clock divider bit position for PCB */
+#define	CLKPWR_PCLKSEL_PCB  		((uint32_t)(36))
+/** Peripheral clock divider bit position for  I2C1 */
+#define	CLKPWR_PCLKSEL_I2C1  		((uint32_t)(38))
+/** Peripheral clock divider bit position for SSP0 */
+#define	CLKPWR_PCLKSEL_SSP0  		((uint32_t)(42))
+/** Peripheral clock divider bit position for TIMER2 */
+#define	CLKPWR_PCLKSEL_TIMER2  		((uint32_t)(44))
+/** Peripheral clock divider bit position for  TIMER3 */
+#define	CLKPWR_PCLKSEL_TIMER3  		((uint32_t)(46))
+/** Peripheral clock divider bit position for UART2 */
+#define	CLKPWR_PCLKSEL_UART2  		((uint32_t)(48))
+/** Peripheral clock divider bit position for UART3 */
+#define	CLKPWR_PCLKSEL_UART3  		((uint32_t)(50))
+/** Peripheral clock divider bit position for I2C2 */
+#define	CLKPWR_PCLKSEL_I2C2  		((uint32_t)(52))
+/** Peripheral clock divider bit position for I2S */
+#define	CLKPWR_PCLKSEL_I2S  		((uint32_t)(54))
+/** Peripheral clock divider bit position for RIT */
+#define	CLKPWR_PCLKSEL_RIT  		((uint32_t)(58))
+/** Peripheral clock divider bit position for SYSCON */
+#define	CLKPWR_PCLKSEL_SYSCON  		((uint32_t)(60))
+/** Peripheral clock divider bit position for MC */
+#define	CLKPWR_PCLKSEL_MC		  	((uint32_t)(62))
+
+/** Macro for Peripheral Clock Selection register bit values
+ * Note: When CCLK_DIV_8, Peripheral&#146;s clock is selected to
+ * PCLK_xyz = CCLK/8 except for CAN1, CAN2, and CAN filtering
+ * when &#146;11&#146;selects PCLK_xyz = CCLK/6 */
+/* Peripheral clock divider is set to 4 from CCLK */
+#define	CLKPWR_PCLKSEL_CCLK_DIV_4  ((uint32_t)(0))
+/** Peripheral clock divider is the same with CCLK */
+#define	CLKPWR_PCLKSEL_CCLK_DIV_1  ((uint32_t)(1))
+/** Peripheral clock divider is set to 2 from CCLK */
+#define	CLKPWR_PCLKSEL_CCLK_DIV_2  ((uint32_t)(2))
+
+
+/********************************************************************
+* Power Control for Peripherals Definitions
+**********************************************************************/
+/** Timer/Counter 0 power/clock control bit */
+#define	 CLKPWR_PCONP_PCTIM0	((uint32_t)(1&lt;&lt;1))
+/* Timer/Counter 1 power/clock control bit */
+#define	 CLKPWR_PCONP_PCTIM1	((uint32_t)(1&lt;&lt;2))
+/** UART0 power/clock control bit */
+#define	 CLKPWR_PCONP_PCUART0  	((uint32_t)(1&lt;&lt;3))
+/** UART1 power/clock control bit */
+#define	 CLKPWR_PCONP_PCUART1  	((uint32_t)(1&lt;&lt;4))
+/** PWM1 power/clock control bit */
+#define	 CLKPWR_PCONP_PCPWM1	((uint32_t)(1&lt;&lt;6))
+/** The I2C0 interface power/clock control bit */
+#define	 CLKPWR_PCONP_PCI2C0	((uint32_t)(1&lt;&lt;7))
+/** The SPI interface power/clock control bit */
+#define	 CLKPWR_PCONP_PCSPI  	((uint32_t)(1&lt;&lt;8))
+/** The RTC power/clock control bit */
+#define	 CLKPWR_PCONP_PCRTC  	((uint32_t)(1&lt;&lt;9))
+/** The SSP1 interface power/clock control bit */
+#define	 CLKPWR_PCONP_PCSSP1	((uint32_t)(1&lt;&lt;10))
+/** A/D converter 0 (ADC0) power/clock control bit */
+#define	 CLKPWR_PCONP_PCAD  	((uint32_t)(1&lt;&lt;12))
+/** CAN Controller 1 power/clock control bit */
+#define	 CLKPWR_PCONP_PCAN1  	((uint32_t)(1&lt;&lt;13))
+/** CAN Controller 2 power/clock control bit */
+#define	 CLKPWR_PCONP_PCAN2  	((uint32_t)(1&lt;&lt;14))
+/** GPIO power/clock control bit */
+#define	CLKPWR_PCONP_PCGPIO		((uint32_t)(1&lt;&lt;15))
+/** Repetitive Interrupt Timer power/clock control bit */
+#define	CLKPWR_PCONP_PCRIT		((uint32_t)(1&lt;&lt;16))
+/** Motor Control PWM */
+#define CLKPWR_PCONP_PCMC		((uint32_t)(1&lt;&lt;17))
+/** Quadrature Encoder Interface power/clock control bit */
+#define CLKPWR_PCONP_PCQEI		((uint32_t)(1&lt;&lt;18))
+/** The I2C1 interface power/clock control bit */
+#define	 CLKPWR_PCONP_PCI2C1  	((uint32_t)(1&lt;&lt;19))
+/** The SSP0 interface power/clock control bit */
+#define	 CLKPWR_PCONP_PCSSP0	((uint32_t)(1&lt;&lt;21))
+/** Timer 2 power/clock control bit */
+#define	 CLKPWR_PCONP_PCTIM2	((uint32_t)(1&lt;&lt;22))
+/** Timer 3 power/clock control bit */
+#define	 CLKPWR_PCONP_PCTIM3	((uint32_t)(1&lt;&lt;23))
+/** UART 2 power/clock control bit */
+#define	 CLKPWR_PCONP_PCUART2  	((uint32_t)(1&lt;&lt;24))
+/** UART 3 power/clock control bit */
+#define	 CLKPWR_PCONP_PCUART3  	((uint32_t)(1&lt;&lt;25))
+/** I2C interface 2 power/clock control bit */
+#define	 CLKPWR_PCONP_PCI2C2	((uint32_t)(1&lt;&lt;26))
+/** I2S interface power/clock control bit*/
+#define	 CLKPWR_PCONP_PCI2S  	((uint32_t)(1&lt;&lt;27))
+/** GP DMA function power/clock control bit*/
+#define	 CLKPWR_PCONP_PCGPDMA  	((uint32_t)(1&lt;&lt;29))
+/** Ethernet block power/clock control bit*/
+#define	 CLKPWR_PCONP_PCENET	((uint32_t)(1&lt;&lt;30))
+/** USB interface power/clock control bit*/
+#define	 CLKPWR_PCONP_PCUSB  	((uint32_t)(1&lt;&lt;31))
+
+
+/**
+ * @}
+ */
+
+
+/* Public Functions ----------------------------------------------------------- */
+/** @defgroup CLKPWR_Public_Functions
+ * @{
+ */
+
+void CLKPWR_SetPCLKDiv (uint32_t ClkType, uint32_t DivVal);
+uint32_t CLKPWR_GetPCLKSEL (uint32_t ClkType);
+uint32_t CLKPWR_GetPCLK (uint32_t ClkType);
+void CLKPWR_ConfigPPWR (uint32_t PPType, FunctionalState NewState);
+void CLKPWR_Sleep(void);
+void CLKPWR_DeepSleep(void);
+void CLKPWR_PowerDown(void);
+void CLKPWR_DeepPowerDown(void);
+
+/**
+ * @}
+ */
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LPC17XX_CLKPWR_H_ */
+
+/**
+ * @}
+ */
+
+/* --------------------------------- End Of File ------------------------------ */


Property changes on: trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_clkpwr.h
___________________________________________________________________
Deleted: svn:executable
   - *

Modified: trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_dac.h
===================================================================
--- trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_dac.h	2010-06-28 21:53:59 UTC (rev 759)
+++ trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_dac.h	2010-07-12 20:56:54 UTC (rev 760)
@@ -1,144 +1,144 @@
-/***********************************************************************//**
- * @file	: lpc17xx_dac.h
- * @brief	: Contains all macro definitions and function prototypes
- * 				support for DAC firmware library on LPC17xx
- * @version	: 1.0
- * @date	: 3. April. 2009
- * @author	: HieuNguyen
- **************************************************************************
- * Software that is described herein is for illustrative purposes only
- * which provides customers with programming information regarding the
- * products. This software is supplied &quot;AS IS&quot; without any warranties.
- * NXP Semiconductors assumes no responsibility or liability for the
- * use of the software, conveys no license or title under any patent,
- * copyright, or mask work right to the product. NXP Semiconductors
- * reserves the right to make changes in the software without
- * notification. NXP Semiconductors also make no representation or
- * warranty that such application will be suitable for the specified
- * use without further testing or modification.
- **************************************************************************/
-
-/* Peripheral group ----------------------------------------------------------- */
-/** @defgroup DAC
- * @ingroup LPC1700CMSIS_FwLib_Drivers
- * @{
- */
-
-#ifndef LPC17XX_DAC_H_
-#define LPC17XX_DAC_H_
-
-/* Includes ------------------------------------------------------------------- */
-#include &quot;LPC17xx.h&quot;
-#include &quot;lpc_types.h&quot;
-
-
-#ifdef __cplusplus
-extern &quot;C&quot;
-{
-#endif
-
-
-/* Public Types --------------------------------------------------------------- */
-/** @defgroup DAC_Public_Types
- * @{
- */
-
-/**
- * @brief Current option in ADC confuration option */
-typedef enum
-{
-	DAC_MAX_CURRENT_700uA = 0, 	/*!&lt; The settling time of the DAC is 1 us max,
-								and the maximum	current is 700 uA */
-	DAC_MAX_CURRENT_350uA		/*!&lt; The settling time of the DAC is 2.5 us
-								and the maximum current is 350 uA */
-} DAC_CURRENT_OPT;
-#define	PARAM_DAC_CURRENT_OPT(OPTION) ((OPTION == DAC_MAX_CURRENT_700uA)||\
-									(OPTION == DAC_MAX_CURRENT_350uA))
-
-/**
- * @brief Configuration for DA converter control register */
-typedef struct
-{
-
-	uint8_t  DBLBUF_ENA; 	/**&lt;
-	                         -0: Disable DACR double buffering
-	                         -1: when bit CNT_ENA, enable DACR double buffering feature
-							 */
-	uint8_t  CNT_ENA;		/*!&lt;
-	                         -0: Time out counter is disable
-	                         -1: Time out conter is enable
-							 */
-	uint8_t  DMA_ENA;		/*!&lt;
-		                         -0: DMA access is disable
-		                         -1: DMA burst request
-							*/
-	uint8_t RESERVED;
-
-} DAC_CONVERTER_CFG_Type;
-
-/**
- * @}
- */
-
-
-/* Public Macros -------------------------------------------------------------- */
-/** @defgroup DAC_Public_Macros
- * @{
- */
-
-/** After the selected settling time after this field is written with a
-new VALUE, the voltage on the AOUT pin (with respect to VSSA)
-is VALUE/1024 &#215; VREF */
-#define DAC_VALUE(n) 		((uint32_t)((n&amp;0x3FF)&lt;&lt;6))
-/** If this bit = 0: The settling time of the DAC is 1 microsecond max,
- * and the maximum current is 700 microAmpere
- * If this bit = 1: The settling time of the DAC is 2.5 microsecond
- * and the maximum current is 350 microAmpere */
-#define DAC_BIAS_EN			((uint32_t)(1&lt;&lt;16))
-/** Value to reload interrupt DMA counter */
-#define DAC_CCNT_VALUE(n)  ((uint32_t)(n&amp;0xff))
-
-/** DCAR double buffering */
-#define DAC_DBLBUF_ENA		((uint32_t)(1&lt;&lt;1))
-/** DCAR Time out count enable */
-#define DAC_CNT_ENA			((uint32_t)(1&lt;&lt;2))
-/** DCAR DMA access */
-#define DAC_DMA_ENA			((uint32_t)(1&lt;&lt;3))
-/** DCAR DACCTRL mask bit */
-#define DAC_DACCTRL_MASK	((uint32_t)(0x0F))
-
-/** Macro to determine if it is valid DAC peripheral */
-#define PARAM_DACx(n)	(((uint32_t *)n)==((uint32_t *)DAC))
-
-/**
- * @}
- */
-
-/* Public Functions ----------------------------------------------------------- */
-/** @defgroup DAC_Public_Functions
- * @{
- */
-
-void 	DAC_Init(DAC_TypeDef *DACx);
-void    DAC_UpdateValue (DAC_TypeDef *DACx, uint32_t dac_value);
-void    DAC_SetBias (DAC_TypeDef *DACx,uint32_t bias);
-void    DAC_ConfigDAConverterControl (DAC_TypeDef *DACx,DAC_CONVERTER_CFG_Type *DAC_ConverterConfigStruct);
-void 	DAC_SetDMATimeOut(DAC_TypeDef *DACx,uint32_t time_out);
-
-/**
- * @}
- */
-
-#ifdef __cplusplus
-}
-#endif
-
-
-#endif /* LPC17XX_DAC_H_ */
-
-/**
- * @}
- */
-
-/* --------------------------------- End Of File ------------------------------ */
-
+/***********************************************************************//**
+ * @file	: lpc17xx_dac.h
+ * @brief	: Contains all macro definitions and function prototypes
+ * 				support for DAC firmware library on LPC17xx
+ * @version	: 1.0
+ * @date	: 3. April. 2009
+ * @author	: HieuNguyen
+ **************************************************************************
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * products. This software is supplied &quot;AS IS&quot; without any warranties.
+ * NXP Semiconductors assumes no responsibility or liability for the
+ * use of the software, conveys no license or title under any patent,
+ * copyright, or mask work right to the product. NXP Semiconductors
+ * reserves the right to make changes in the software without
+ * notification. NXP Semiconductors also make no representation or
+ * warranty that such application will be suitable for the specified
+ * use without further testing or modification.
+ **************************************************************************/
+
+/* Peripheral group ----------------------------------------------------------- */
+/** @defgroup DAC
+ * @ingroup LPC1700CMSIS_FwLib_Drivers
+ * @{
+ */
+
+#ifndef LPC17XX_DAC_H_
+#define LPC17XX_DAC_H_
+
+/* Includes ------------------------------------------------------------------- */
+#include &quot;LPC17xx.h&quot;
+#include &quot;lpc_types.h&quot;
+
+
+#ifdef __cplusplus
+extern &quot;C&quot;
+{
+#endif
+
+
+/* Public Types --------------------------------------------------------------- */
+/** @defgroup DAC_Public_Types
+ * @{
+ */
+
+/**
+ * @brief Current option in ADC confuration option */
+typedef enum
+{
+	DAC_MAX_CURRENT_700uA = 0, 	/*!&lt; The settling time of the DAC is 1 us max,
+								and the maximum	current is 700 uA */
+	DAC_MAX_CURRENT_350uA		/*!&lt; The settling time of the DAC is 2.5 us
+								and the maximum current is 350 uA */
+} DAC_CURRENT_OPT;
+#define	PARAM_DAC_CURRENT_OPT(OPTION) ((OPTION == DAC_MAX_CURRENT_700uA)\
+||(OPTION == DAC_MAX_CURRENT_350uA))
+
+/**
+ * @brief Configuration for DA converter control register */
+typedef struct
+{
+
+	uint8_t  DBLBUF_ENA; 	/**&lt;
+	                         -0: Disable DACR double buffering
+	                         -1: when bit CNT_ENA, enable DACR double buffering feature
+							 */
+	uint8_t  CNT_ENA;		/*!&lt;
+	                         -0: Time out counter is disable
+	                         -1: Time out conter is enable
+							 */
+	uint8_t  DMA_ENA;		/*!&lt;
+		                         -0: DMA access is disable
+		                         -1: DMA burst request
+							*/
+	uint8_t RESERVED;
+
+} DAC_CONVERTER_CFG_Type;
+
+/**
+ * @}
+ */
+
+
+/* Public Macros -------------------------------------------------------------- */
+/** @defgroup DAC_Public_Macros
+ * @{
+ */
+
+/** After the selected settling time after this field is written with a
+new VALUE, the voltage on the AOUT pin (with respect to VSSA)
+is VALUE/1024 &#215; VREF */
+#define DAC_VALUE(n) 		((uint32_t)((n&amp;0x3FF)&lt;&lt;6))
+/** If this bit = 0: The settling time of the DAC is 1 microsecond max,
+ * and the maximum current is 700 microAmpere
+ * If this bit = 1: The settling time of the DAC is 2.5 microsecond
+ * and the maximum current is 350 microAmpere */
+#define DAC_BIAS_EN			((uint32_t)(1&lt;&lt;16))
+/** Value to reload interrupt DMA counter */
+#define DAC_CCNT_VALUE(n)  ((uint32_t)(n&amp;0xff))
+
+/** DCAR double buffering */
+#define DAC_DBLBUF_ENA		((uint32_t)(1&lt;&lt;1))
+/** DCAR Time out count enable */
+#define DAC_CNT_ENA			((uint32_t)(1&lt;&lt;2))
+/** DCAR DMA access */
+#define DAC_DMA_ENA			((uint32_t)(1&lt;&lt;3))
+/** DCAR DACCTRL mask bit */
+#define DAC_DACCTRL_MASK	((uint32_t)(0x0F))
+
+/** Macro to determine if it is valid DAC peripheral */
+#define PARAM_DACx(n)	(((uint32_t *)n)==((uint32_t *)LPC_DAC))
+
+/**
+ * @}
+ */
+
+/* Public Functions ----------------------------------------------------------- */
+/** @defgroup DAC_Public_Functions
+ * @{
+ */
+
+void 	DAC_Init(LPC_DAC_TypeDef *DACx);
+void    DAC_UpdateValue (LPC_DAC_TypeDef *DACx, uint32_t dac_value);
+void    DAC_SetBias (LPC_DAC_TypeDef *DACx,uint32_t bias);
+void    DAC_ConfigDAConverterControl (LPC_DAC_TypeDef *DACx,DAC_CONVERTER_CFG_Type *DAC_ConverterConfigStruct);
+void 	DAC_SetDMATimeOut(LPC_DAC_TypeDef *DACx,uint32_t time_out);
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif /* LPC17XX_DAC_H_ */
+
+/**
+ * @}
+ */
+
+/* --------------------------------- End Of File ------------------------------ */
+


Property changes on: trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_dac.h
___________________________________________________________________
Deleted: svn:executable
   - *

Modified: trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_emac.h
===================================================================
--- trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_emac.h	2010-06-28 21:53:59 UTC (rev 759)
+++ trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_emac.h	2010-07-12 20:56:54 UTC (rev 760)
@@ -1,582 +1,582 @@
-/***********************************************************************//**
- * @file	: lpc17xx_emac.h
- * @brief	: Contains all macro definitions and function prototypes
- * 				support for Ethernet MAC firmware library on LPC17xx
- * @version	: 1.0
- * @date	: 02. Jun. 2009
- * @author	: HieuNguyen
- **************************************************************************
- * Software that is described herein is for illustrative purposes only
- * which provides customers with programming information regarding the
- * products. This software is supplied &quot;AS IS&quot; without any warranties.
- * NXP Semiconductors assumes no responsibility or liability for the
- * use of the software, conveys no license or title under any patent,
- * copyright, or mask work right to the product. NXP Semiconductors
- * reserves the right to make changes in the software without
- * notification. NXP Semiconductors also make no representation or
- * warranty that such application will be suitable for the specified
- * use without further testing or modification.
- **************************************************************************/
-
-/* Peripheral group ----------------------------------------------------------- */
-/** @defgroup EMAC
- * @ingroup LPC1700CMSIS_FwLib_Drivers
- * @{
- */
-
-#ifndef LPC17XX_EMAC_H_
-#define LPC17XX_EMAC_H_
-
-/* Includes ------------------------------------------------------------------- */
-#include &quot;LPC17xx.h&quot;
-#include &quot;lpc_types.h&quot;
-
-
-#ifdef __cplusplus
-extern &quot;C&quot;
-{
-#endif
-
-
-/* Private Macros ------------------------------------------------------------- */
-/** @defgroup EMAC_Private_Macros
- * @{
- */
-
-
-/** @defgroup EMAC_REGISTER_BIT_DEFINITIONS
- * @{
- */
-
-
-/* EMAC Memory Buffer configuration for 16K Ethernet RAM */
-#define EMAC_NUM_RX_FRAG         4           /**&lt; Num.of RX Fragments 4*1536= 6.0kB */
-#define EMAC_NUM_TX_FRAG         3           /**&lt; Num.of TX Fragments 3*1536= 4.6kB */
-#define EMAC_ETH_MAX_FLEN        1536        /**&lt; Max. Ethernet Frame Size          */
-#define EMAC_TX_FRAME_TOUT       0x00100000  /**&lt; Frame Transmit timeout count      */
-
-/* Ethernet MAC register definitions --------------------------------------------------------------------- */
-/* MAC Configuration Register 1 */
-#define EMAC_MAC1_REC_EN         0x00000001  /**&lt; Receive Enable                    */
-#define EMAC_MAC1_PASS_ALL       0x00000002  /**&lt; Pass All Receive Frames           */
-#define EMAC_MAC1_RX_FLOWC       0x00000004  /**&lt; RX Flow Control                   */
-#define EMAC_MAC1_TX_FLOWC       0x00000008  /**&lt; TX Flow Control                   */
-#define EMAC_MAC1_LOOPB          0x00000010  /**&lt; Loop Back Mode                    */
-#define EMAC_MAC1_RES_TX         0x00000100  /**&lt; Reset TX Logic                    */
-#define EMAC_MAC1_RES_MCS_TX     0x00000200  /**&lt; Reset MAC TX Control Sublayer     */
-#define EMAC_MAC1_RES_RX         0x00000400  /**&lt; Reset RX Logic                    */
-#define EMAC_MAC1_RES_MCS_RX     0x00000800  /**&lt; Reset MAC RX Control Sublayer     */
-#define EMAC_MAC1_SIM_RES        0x00004000  /**&lt; Simulation Reset                  */
-#define EMAC_MAC1_SOFT_RES       0x00008000  /**&lt; Soft Reset MAC                    */
-
-/* MAC Configuration Register 2 */
-#define EMAC_MAC2_FULL_DUP       0x00000001  /**&lt; Full-Duplex Mode                  */
-#define EMAC_MAC2_FRM_LEN_CHK    0x00000002  /**&lt; Frame Length Checking             */
-#define EMAC_MAC2_HUGE_FRM_EN    0x00000004  /**&lt; Huge Frame Enable                 */
-#define EMAC_MAC2_DLY_CRC        0x00000008  /**&lt; Delayed CRC Mode                  */
-#define EMAC_MAC2_CRC_EN         0x00000010  /**&lt; Append CRC to every Frame         */
-#define EMAC_MAC2_PAD_EN         0x00000020  /**&lt; Pad all Short Frames              */
-#define EMAC_MAC2_VLAN_PAD_EN    0x00000040  /**&lt; VLAN Pad Enable                   */
-#define EMAC_MAC2_ADET_PAD_EN    0x00000080  /**&lt; Auto Detect Pad Enable            */
-#define EMAC_MAC2_PPREAM_ENF     0x00000100  /**&lt; Pure Preamble Enforcement         */
-#define EMAC_MAC2_LPREAM_ENF     0x00000200  /**&lt; Long Preamble Enforcement         */
-#define EMAC_MAC2_NO_BACKOFF     0x00001000  /**&lt; No Backoff Algorithm              */
-#define EMAC_MAC2_BACK_PRESSURE  0x00002000  /**&lt; Backoff Presurre / No Backoff     */
-#define EMAC_MAC2_EXCESS_DEF     0x00004000  /**&lt; Excess Defer                      */
-
-/* Back-to-Back Inter-Packet-Gap Register */
-/** Programmable field representing the nibble time offset of the minimum possible period
- * between the end of any transmitted packet to the beginning of the next */
-#define EMAC_IPGT_BBIPG(n)		(n&amp;0x7F)
-/** Recommended value for Full Duplex of Programmable field representing the nibble time
- * offset of the minimum possible period between the end of any transmitted packet to the
- * beginning of the next */
-#define EMAC_IPGT_FULL_DUP		(EMAC_IPGT_BBIPG(0x15))
-/** Recommended value for Half Duplex of Programmable field representing the nibble time
- * offset of the minimum possible period between the end of any transmitted packet to the
- * beginning of the next */
-#define EMAC_IPGT_HALF_DUP      (EMAC_IPGT_BBIPG(0x12))
-
-/* Non Back-to-Back Inter-Packet-Gap Register */
-/** Programmable field representing the Non-Back-to-Back Inter-Packet-Gap */
-#define EMAC_IPGR_NBBIPG_P2(n)	(n&amp;0x7F)
-/** Recommended value for Programmable field representing the Non-Back-to-Back Inter-Packet-Gap Part 1 */
-#define EMAC_IPGR_P2_DEF		(EMAC_IPGR_NBBIPG_P2(0x12))
-/** Programmable field representing the optional carrierSense window referenced in
- * IEEE 802.3/4.2.3.2.1 'Carrier Deference' */
-#define EMAC_IPGR_NBBIPG_P1(n)	((n&amp;0x7F)&lt;&lt;8)
-/** Recommended value for Programmable field representing the Non-Back-to-Back Inter-Packet-Gap Part 2 */
-#define EMAC_IPGR_P1_DEF        EMAC_IPGR_NBBIPG_P1(0x0C)
-
-/* Collision Window/Retry Register */
-/** Programmable field specifying the number of retransmission attempts following a collision before
- * aborting the packet due to excessive collisions */
-#define EMAC_CLRT_MAX_RETX(n)	(n&amp;0x0F)
-/** Programmable field representing the slot time or collision window during which collisions occur
- * in properly configured networks */
-#define EMAC_CLRT_COLL(n)		((n&amp;0x3F)&lt;&lt;8)
-/** Default value for Collision Window / Retry register */
-#define EMAC_CLRT_DEF           ((EMAC_CLRT_MAX_RETX(0x0F))|(EMAC_CLRT_COLL(0x37)))
-
-/* Maximum Frame Register */
-/** Represents a maximum receive frame of 1536 octets */
-#define EMAC_MAXF_MAXFRMLEN(n)	(n&amp;0xFFFF)
-
-/* PHY Support Register */
-#define EMAC_SUPP_SPEED			0x00000100  	/**&lt; Reduced MII Logic Current Speed   */
-#define EMAC_SUPP_RES_RMII      0x00000800  	/**&lt; Reset Reduced MII Logic           */
-
-/* Test Register */
-#define EMAC_TEST_SHCUT_PQUANTA  0x00000001  	/**&lt; Shortcut Pause Quanta             */
-#define EMAC_TEST_TST_PAUSE      0x00000002  	/**&lt; Test Pause                        */
-#define EMAC_TEST_TST_BACKP      0x00000004  	/**&lt; Test Back Pressure                */
-
-/* MII Management Configuration Register */
-#define EMAC_MCFG_SCAN_INC       0x00000001  	/**&lt; Scan Increment PHY Address        */
-#define EMAC_MCFG_SUPP_PREAM     0x00000002  	/**&lt; Suppress Preamble                 */
-#define EMAC_MCFG_CLK_SEL(n)     ((n&amp;0x0F)&lt;&lt;2)  /**&lt; Clock Select Field                 */
-#define EMAC_MCFG_RES_MII        0x00008000  	/**&lt; Reset MII Management Hardware     */
-#define EMAC_MCFG_MII_MAXCLK	 2500000UL		/**&lt; MII Clock max */
-
-/* MII Management Command Register */
-#define EMAC_MCMD_READ           0x00000001  	/**&lt; MII Read                          */
-#define EMAC_MCMD_SCAN           0x00000002  	/**&lt; MII Scan continuously             */
-
-#define EMAC_MII_WR_TOUT         0x00050000  	/**&lt; MII Write timeout count           */
-#define EMAC_MII_RD_TOUT         0x00050000  	/**&lt; MII Read timeout count            */
-
-/* MII Management Address Register */
-#define EMAC_MADR_REG_ADR(n)     (n&amp;0x1F)  		/**&lt; MII Register Address field         */
-#define EMAC_MADR_PHY_ADR(n)     ((n&amp;0x1F)&lt;&lt;8)  /**&lt; PHY Address Field                  */
-
-/* MII Management Write Data Register */
-#define EMAC_MWTD_DATA(n)		(n&amp;0xFFFF)		/**&lt; Data field for MMI Management Write Data register */
-
-/* MII Management Read Data Register */
-#define EMAC_MRDD_DATA(n)		(n&amp;0xFFFF)		/**&lt; Data field for MMI Management Read Data register */
-
-/* MII Management Indicators Register */
-#define EMAC_MIND_BUSY           0x00000001  	/**&lt; MII is Busy                       */
-#define EMAC_MIND_SCAN           0x00000002  	/**&lt; MII Scanning in Progress          */
-#define EMAC_MIND_NOT_VAL        0x00000004  	/**&lt; MII Read Data not valid           */
-#define EMAC_MIND_MII_LINK_FAIL  0x00000008  	/**&lt; MII Link Failed                   */
-
-/* Station Address 0 Register */
-/* Station Address 1 Register */
-/* Station Address 2 Register */
-
-
-/* Control register definitions --------------------------------------------------------------------------- */
-/* Command Register */
-#define EMAC_CR_RX_EN            0x00000001  	/**&lt; Enable Receive                    */
-#define EMAC_CR_TX_EN            0x00000002  	/**&lt; Enable Transmit                   */
-#define EMAC_CR_REG_RES          0x00000008  	/**&lt; Reset Host Registers              */
-#define EMAC_CR_TX_RES           0x00000010  	/**&lt; Reset Transmit Datapath           */
-#define EMAC_CR_RX_RES           0x00000020  	/**&lt; Reset Receive Datapath            */
-#define EMAC_CR_PASS_RUNT_FRM    0x00000040  	/**&lt; Pass Runt Frames                  */
-#define EMAC_CR_PASS_RX_FILT     0x00000080  	/**&lt; Pass RX Filter                    */
-#define EMAC_CR_TX_FLOW_CTRL     0x00000100  	/**&lt; TX Flow Control                   */
-#define EMAC_CR_RMII             0x00000200  	/**&lt; Reduced MII Interface             */
-#define EMAC_CR_FULL_DUP         0x00000400  	/**&lt; Full Duplex                       */
-
-/* Status Register */
-#define EMAC_SR_RX_EN            0x00000001  	/**&lt; Enable Receive                    */
-#define EMAC_SR_TX_EN            0x00000002  	/**&lt; Enable Transmit                   */
-
-/* Receive Descriptor Base Address Register */
-//
-
-/* Receive Status Base Address Register */
-//
-
-/* Receive Number of Descriptors Register */
-//
-
-/* Receive Produce Index Register */
-//
-
-/* Receive Consume Index Register */
-//
-
-/* Transmit Descriptor Base Address Register */
-//
-
-/* Transmit Status Base Address Register */
-//
-
-/* Transmit Number of Descriptors Register */
-//
-
-/* Transmit Produce Index Register */
-//
-
-/* Transmit Consume Index Register */
-//
-
-/* Transmit Status Vector 0 Register */
-#define EMAC_TSV0_CRC_ERR        0x00000001  /**&lt; CRC error                         */
-#define EMAC_TSV0_LEN_CHKERR     0x00000002  /**&lt; Length Check Error                */
-#define EMAC_TSV0_LEN_OUTRNG     0x00000004  /**&lt; Length Out of Range               */
-#define EMAC_TSV0_DONE           0x00000008  /**&lt; Tramsmission Completed            */
-#define EMAC_TSV0_MCAST          0x00000010  /**&lt; Multicast Destination             */
-#define EMAC_TSV0_BCAST          0x00000020  /**&lt; Broadcast Destination             */
-#define EMAC_TSV0_PKT_DEFER      0x00000040  /**&lt; Packet Deferred                   */
-#define EMAC_TSV0_EXC_DEFER      0x00000080  /**&lt; Excessive Packet Deferral         */
-#define EMAC_TSV0_EXC_COLL       0x00000100  /**&lt; Excessive Collision               */
-#define EMAC_TSV0_LATE_COLL      0x00000200  /**&lt; Late Collision Occured            */
-#define EMAC_TSV0_GIANT          0x00000400  /**&lt; Giant Frame                       */
-#define EMAC_TSV0_UNDERRUN       0x00000800  /**&lt; Buffer Underrun                   */
-#define EMAC_TSV0_BYTES          0x0FFFF000  /**&lt; Total Bytes Transferred           */
-#define EMAC_TSV0_CTRL_FRAME     0x10000000  /**&lt; Control Frame                     */
-#define EMAC_TSV0_PAUSE          0x20000000  /**&lt; Pause Frame                       */
-#define EMAC_TSV0_BACK_PRESS     0x40000000  /**&lt; Backpressure Method Applied       */
-#define EMAC_TSV0_VLAN           0x80000000  /**&lt; VLAN Frame                        */
-
-/* Transmit Status Vector 1 Register */
-#define EMAC_TSV1_BYTE_CNT       0x0000FFFF  /**&lt; Transmit Byte Count               */
-#define EMAC_TSV1_COLL_CNT       0x000F0000  /**&lt; Transmit Collision Count          */
-
-/* Receive Status Vector Register */
-#define EMAC_RSV_BYTE_CNT        0x0000FFFF  /**&lt; Receive Byte Count                */
-#define EMAC_RSV_PKT_IGNORED     0x00010000  /**&lt; Packet Previously Ignored         */
-#define EMAC_RSV_RXDV_SEEN       0x00020000  /**&lt; RXDV Event Previously Seen        */
-#define EMAC_RSV_CARR_SEEN       0x00040000  /**&lt; Carrier Event Previously Seen     */
-#define EMAC_RSV_REC_CODEV       0x00080000  /**&lt; Receive Code Violation            */
-#define EMAC_RSV_CRC_ERR         0x00100000  /**&lt; CRC Error                         */
-#define EMAC_RSV_LEN_CHKERR      0x00200000  /**&lt; Length Check Error                */
-#define EMAC_RSV_LEN_OUTRNG      0x00400000  /**&lt; Length Out of Range               */
-#define EMAC_RSV_REC_OK          0x00800000  /**&lt; Frame Received OK                 */
-#define EMAC_RSV_MCAST           0x01000000  /**&lt; Multicast Frame                   */
-#define EMAC_RSV_BCAST           0x02000000  /**&lt; Broadcast Frame                   */
-#define EMAC_RSV_DRIB_NIBB       0x04000000  /**&lt; Dribble Nibble                    */
-#define EMAC_RSV_CTRL_FRAME      0x08000000  /**&lt; Control Frame                     */
-#define EMAC_RSV_PAUSE           0x10000000  /**&lt; Pause Frame                       */
-#define EMAC_RSV_UNSUPP_OPC      0x20000000  /**&lt; Unsupported Opcode                */
-#define EMAC_RSV_VLAN            0x40000000  /**&lt; VLAN Frame                        */
-
-/* Flow Control Counter Register */
-#define EMAC_FCC_MIRR_CNT(n)        	(n&amp;0xFFFF)  		/**&lt; Mirror Counter                    */
-#define EMAC_FCC_PAUSE_TIM(n)       	((n&amp;0xFFFF)&lt;&lt;16)  	/**&lt; Pause Timer                       */
-
-/* Flow Control Status Register */
-#define EMAC_FCS_MIRR_CNT(n)        	(n&amp;0xFFFF)  		/**&lt; Mirror Counter Current            */
-
-
-/* Receive filter register definitions -------------------------------------------------------- */
-/* Receive Filter Control Register */
-#define EMAC_RFC_UCAST_EN        0x00000001  /**&lt; Accept Unicast Frames Enable      */
-#define EMAC_RFC_BCAST_EN        0x00000002  /**&lt; Accept Broadcast Frames Enable    */
-#define EMAC_RFC_MCAST_EN        0x00000004  /**&lt; Accept Multicast Frames Enable    */
-#define EMAC_RFC_UCAST_HASH_EN   0x00000008  /**&lt; Accept Unicast Hash Filter Frames */
-#define EMAC_RFC_MCAST_HASH_EN   0x00000010  /**&lt; Accept Multicast Hash Filter Fram.*/
-#define EMAC_RFC_PERFECT_EN      0x00000020  /**&lt; Accept Perfect Match Enable       */
-#define EMAC_RFC_MAGP_WOL_EN     0x00001000  /**&lt; Magic Packet Filter WoL Enable    */
-#define EMAC_RFC_PFILT_WOL_EN    0x00002000  /**&lt; Perfect Filter WoL Enable         */
-
-/* Receive Filter WoL Status/Clear Registers */
-#define EMAC_WOL_UCAST           0x00000001  /**&lt; Unicast Frame caused WoL          */
-#define EMAC_WOL_BCAST           0x00000002  /**&lt; Broadcast Frame caused WoL        */
-#define EMAC_WOL_MCAST           0x00000004  /**&lt; Multicast Frame caused WoL        */
-#define EMAC_WOL_UCAST_HASH      0x00000008  /**&lt; Unicast Hash Filter Frame WoL     */
-#define EMAC_WOL_MCAST_HASH      0x00000010  /**&lt; Multicast Hash Filter Frame WoL   */
-#define EMAC_WOL_PERFECT         0x00000020  /**&lt; Perfect Filter WoL                */
-#define EMAC_WOL_RX_FILTER       0x00000080  /**&lt; RX Filter caused WoL              */
-#define EMAC_WOL_MAG_PACKET      0x00000100  /**&lt; Magic Packet Filter caused WoL    */
-#define EMAC_WOL_BITMASK		 0x01BF		/**&lt; Receive Filter WoL Status/Clear bitmasl value */
-
-/* Hash Filter Table LSBs Register */
-//
-
-/* Hash Filter Table MSBs Register */
-//
-
-
-/* Module control register definitions ---------------------------------------------------- */
-/* Interrupt Status/Enable/Clear/Set Registers */
-#define EMAC_INT_RX_OVERRUN      0x00000001  /**&lt; Overrun Error in RX Queue         */
-#define EMAC_INT_RX_ERR          0x00000002  /**&lt; Receive Error                     */
-#define EMAC_INT_RX_FIN          0x00000004  /**&lt; RX Finished Process Descriptors   */
-#define EMAC_INT_RX_DONE         0x00000008  /**&lt; Receive Done                      */
-#define EMAC_INT_TX_UNDERRUN     0x00000010  /**&lt; Transmit Underrun                 */
-#define EMAC_INT_TX_ERR          0x00000020  /**&lt; Transmit Error                    */
-#define EMAC_INT_TX_FIN          0x00000040  /**&lt; TX Finished Process Descriptors   */
-#define EMAC_INT_TX_DONE         0x00000080  /**&lt; Transmit Done                     */
-#define EMAC_INT_SOFT_INT        0x00001000  /**&lt; Software Triggered Interrupt      */
-#define EMAC_INT_WAKEUP          0x00002000  /**&lt; Wakeup Event Interrupt            */
-
-/* Power Down Register */
-#define EMAC_PD_POWER_DOWN       0x80000000  /**&lt; Power Down MAC                    */
-
-/* RX Descriptor Control Word */
-#define EMAC_RCTRL_SIZE(n)       (n&amp;0x7FF)  	/**&lt; Buffer size field                  */
-#define EMAC_RCTRL_INT           0x80000000  	/**&lt; Generate RxDone Interrupt         */
-
-/* RX Status Hash CRC Word */
-#define EMAC_RHASH_SA            0x000001FF  	/**&lt; Hash CRC for Source Address       */
-#define EMAC_RHASH_DA            0x001FF000  	/**&lt; Hash CRC for Destination Address  */
-
-/* RX Status Information Word */
-#define EMAC_RINFO_SIZE          0x000007FF  /**&lt; Data size in bytes                */
-#define EMAC_RINFO_CTRL_FRAME    0x00040000  /**&lt; Control Frame                     */
-#define EMAC_RINFO_VLAN          0x00080000  /**&lt; VLAN Frame                        */
-#define EMAC_RINFO_FAIL_FILT     0x00100000  /**&lt; RX Filter Failed                  */
-#define EMAC_RINFO_MCAST         0x00200000  /**&lt; Multicast Frame                   */
-#define EMAC_RINFO_BCAST         0x00400000  /**&lt; Broadcast Frame                   */
-#define EMAC_RINFO_CRC_ERR       0x00800000  /**&lt; CRC Error in Frame                */
-#define EMAC_RINFO_SYM_ERR       0x01000000  /**&lt; Symbol Error from PHY             */
-#define EMAC_RINFO_LEN_ERR       0x02000000  /**&lt; Length Error                      */
-#define EMAC_RINFO_RANGE_ERR     0x04000000  /**&lt; Range Error (exceeded max. size)  */
-#define EMAC_RINFO_ALIGN_ERR     0x08000000  /**&lt; Alignment Error                   */
-#define EMAC_RINFO_OVERRUN       0x10000000  /**&lt; Receive overrun                   */
-#define EMAC_RINFO_NO_DESCR      0x20000000  /**&lt; No new Descriptor available       */
-#define EMAC_RINFO_LAST_FLAG     0x40000000  /**&lt; Last Fragment in Frame            */
-#define EMAC_RINFO_ERR           0x80000000  /**&lt; Error Occured (OR of all errors)  */
-
-/** RX Status Information word mask */
-#define EMAC_RINFO_ERR_MASK     (EMAC_RINFO_FAIL_FILT | EMAC_RINFO_CRC_ERR   | EMAC_RINFO_SYM_ERR | \
-								EMAC_RINFO_LEN_ERR   | EMAC_RINFO_ALIGN_ERR | EMAC_RINFO_OVERRUN)
-
-/* TX Descriptor Control Word */
-#define EMAC_TCTRL_SIZE          0x000007FF  /**&lt; Size of data buffer in bytes      */
-#define EMAC_TCTRL_OVERRIDE      0x04000000  /**&lt; Override Default MAC Registers    */
-#define EMAC_TCTRL_HUGE          0x08000000  /**&lt; Enable Huge Frame                 */
-#define EMAC_TCTRL_PAD           0x10000000  /**&lt; Pad short Frames to 64 bytes      */
-#define EMAC_TCTRL_CRC           0x20000000  /**&lt; Append a hardware CRC to Frame    */
-#define EMAC_TCTRL_LAST          0x40000000  /**&lt; Last Descriptor for TX Frame      */
-#define EMAC_TCTRL_INT           0x80000000  /**&lt; Generate TxDone Interrupt         */
-
-/* TX Status Information Word */
-#define EMAC_TINFO_COL_CNT       0x01E00000  /**&lt; Collision Count                   */
-#define EMAC_TINFO_DEFER         0x02000000  /**&lt; Packet Deferred (not an error)    */
-#define EMAC_TINFO_EXCESS_DEF    0x04000000  /**&lt; Excessive Deferral                */
-#define EMAC_TINFO_EXCESS_COL    0x08000000  /**&lt; Excessive Collision               */
-#define EMAC_TINFO_LATE_COL      0x10000000  /**&lt; Late Collision Occured            */
-#define EMAC_TINFO_UNDERRUN      0x20000000  /**&lt; Transmit Underrun                 */
-#define EMAC_TINFO_NO_DESCR      0x40000000  /**&lt; No new Descriptor available       */
-#define EMAC_TINFO_ERR           0x80000000  /**&lt; Error Occured (OR of all errors)  */
-
-
-/* DP83848C PHY definition ------------------------------------------------------------ */
-
-/** PHY device reset time out definition */
-#define EMAC_PHY_RESP_TOUT		0x100000UL
-
-/* ENET Device Revision ID */
-#define EMAC_OLD_EMAC_MODULE_ID  0x39022000  /**&lt; Rev. ID for first rev '-'         */
-
-/* DP83848C PHY Registers */
-#define EMAC_PHY_REG_BMCR        0x00        /**&lt; Basic Mode Control Register       */
-#define EMAC_PHY_REG_BMSR        0x01        /**&lt; Basic Mode Status Register        */
-#define EMAC_PHY_REG_IDR1        0x02        /**&lt; PHY Identifier 1                  */
-#define EMAC_PHY_REG_IDR2        0x03        /**&lt; PHY Identifier 2                  */
-#define EMAC_PHY_REG_ANAR        0x04        /**&lt; Auto-Negotiation Advertisement    */
-#define EMAC_PHY_REG_ANLPAR      0x05        /**&lt; Auto-Neg. Link Partner Abitily    */
-#define EMAC_PHY_REG_ANER        0x06        /**&lt; Auto-Neg. Expansion Register      */
-#define EMAC_PHY_REG_ANNPTR      0x07        /**&lt; Auto-Neg. Next Page TX            */
-#define EMAC_PHY_REG_LPNPA		 0x08
-
-
-/* PHY Extended Registers */
-#define EMAC_PHY_REG_STS         0x10        /**&lt; Status Register                   */
-#define EMAC_PHY_REG_MICR        0x11        /**&lt; MII Interrupt Control Register    */
-#define EMAC_PHY_REG_MISR        0x12        /**&lt; MII Interrupt Status Register     */
-#define EMAC_PHY_REG_FCSCR       0x14        /**&lt; False Carrier Sense Counter       */
-#define EMAC_PHY_REG_RECR        0x15        /**&lt; Receive Error Counter             */
-#define EMAC_PHY_REG_PCSR        0x16        /**&lt; PCS Sublayer Config. and Status   */
-#define EMAC_PHY_REG_RBR         0x17        /**&lt; RMII and Bypass Register          */
-#define EMAC_PHY_REG_LEDCR       0x18        /**&lt; LED Direct Control Register       */
-#define EMAC_PHY_REG_PHYCR       0x19        /**&lt; PHY Control Register              */
-#define EMAC_PHY_REG_10BTSCR     0x1A        /**&lt; 10Base-T Status/Control Register  */
-#define EMAC_PHY_REG_CDCTRL1     0x1B        /**&lt; CD Test Control and BIST Extens.  */
-#define EMAC_PHY_REG_EDCR        0x1D        /**&lt; Energy Detect Control Register    */
-
-
-/* PHY Basic Mode Control Register (BMCR) bitmap definitions */
-#define EMAC_PHY_BMCR_RESET     			(1&lt;&lt;15)		/**&lt; Reset bit */
-#define EMAC_PHY_BMCR_LOOPBACK      		(1&lt;&lt;14)		/**&lt; Loop back */
-#define EMAC_PHY_BMCR_SPEED_SEL     		(1&lt;&lt;13)		/**&lt; Speed selection */
-#define EMAC_PHY_BMCR_AN					(1&lt;&lt;12)		/**&lt; Auto Negotiation */
-#define EMAC_PHY_BMCR_POWERDOWN				(1&lt;&lt;11)		/**&lt; Power down mode */
-#define EMAC_PHY_BMCR_ISOLATE				(1&lt;&lt;10)		/**&lt; Isolate */
-#define EMAC_PHY_BMCR_RE_AN					(1&lt;&lt;9)		/**&lt; Restart auto negotiation */
-#define EMAC_PHY_BMCR_DUPLEX				(1&lt;&lt;8)		/**&lt; Duplex mode */
-
-/* PHY Basic Mode Status Status Register (BMSR) bitmap definitions */
-#define EMAC_PHY_BMSR_100BE_T4        	   	(1&lt;&lt;15)		/**&lt; 100 base T4 */
-#define EMAC_PHY_BMSR_100TX_FULL			(1&lt;&lt;14)		/**&lt; 100 base full duplex */
-#define EMAC_PHY_BMSR_100TX_HALF			(1&lt;&lt;13)		/**&lt; 100 base half duplex */
-#define EMAC_PHY_BMSR_10BE_FULL				(1&lt;&lt;12)		/**&lt; 10 base T full duplex */
-#define EMAC_PHY_BMSR_10BE_HALF				(1&lt;&lt;11)		/**&lt; 10 base T half duplex */
-#define EMAC_PHY_BMSR_NOPREAM				(1&lt;&lt;6)		/**&lt; MF Preamable Supress */
-#define EMAC_PHY_BMSR_AUTO_DONE				(1&lt;&lt;5)		/**&lt; Auto negotiation complete */
-#define EMAC_PHY_BMSR_REMOTE_FAULT			(1&lt;&lt;4)		/**&lt; Remote fault */
-#define EMAC_PHY_BMSR_NO_AUTO				(1&lt;&lt;3)		/**&lt; Auto Negotiation ability */
-#define EMAC_PHY_BMSR_LINK_ESTABLISHED		(1&lt;&lt;2)		/**&lt; Link status */
-
-/* PHY Status Register bitmap definitions */
-#define EMAC_PHY_SR_REMOTE_FAULT   			(1&lt;&lt;6)		/**&lt; Remote Fault */
-#define EMAC_PHY_SR_JABBER					(1&lt;&lt;5)		/**&lt; Jabber detect */
-#define EMAC_PHY_SR_AUTO_DONE				(1&lt;&lt;4)		/**&lt; Auto Negotiation complete */
-#define EMAC_PHY_SR_LOOPBACK				(1&lt;&lt;3)		/**&lt; Loop back status */
-#define EMAC_PHY_SR_DUP						(1&lt;&lt;2)		/**&lt; Duplex status */
-#define EMAC_PHY_SR_SPEED					(1&lt;&lt;1)		/**&lt; Speed status */
-#define EMAC_PHY_SR_LINK					(1&lt;&lt;0)		/**&lt; Link Status */
-
-
-#define EMAC_PHY_FULLD_100M      0x2100      /**&lt; Full Duplex 100Mbit               */
-#define EMAC_PHY_HALFD_100M      0x2000      /**&lt; Half Duplex 100Mbit               */
-#define EMAC_PHY_FULLD_10M       0x0100      /**&lt; Full Duplex 10Mbit                */
-#define EMAC_PHY_HALFD_10M       0x0000      /**&lt; Half Duplex 10MBit                */
-#define EMAC_PHY_AUTO_NEG        0x3000      /**&lt; Select Auto Negotiation           */
-
-#define EMAC_DP83848C_DEF_ADR    0x0100      /**&lt; Default PHY device address        */
-#define EMAC_DP83848C_ID         0x20005C90  /**&lt; PHY Identifier                    */
-
-
-/**
- * @}
- */
-
-/**
- * @}
- */
-
-
-/* Public Types --------------------------------------------------------------- */
-/** @defgroup EMAC_Public_Types
- * @{
- */
-
-/* Descriptor and status formats ---------------------------------------------- */
-
-/**
- * @brief RX Descriptor structure type definition
- */
-typedef struct {
-	uint32_t Packet;	/**&lt; Receive Packet Descriptor */
-	uint32_t Ctrl;		/**&lt; Receive Control Descriptor */
-} RX_Desc;
-
-/**
- * @brief RX Status structure type definition
- */
-typedef struct {
-	uint32_t Info;		/**&lt; Receive Information Status */
-	uint32_t HashCRC;	/**&lt; Receive Hash CRC Status */
-} RX_Stat;
-
-/**
- * @brief TX Descriptor structure type definition
- */
-typedef struct {
-	uint32_t Packet;	/**&lt; Transmit Packet Descriptor */
-	uint32_t Ctrl;		/**&lt; Transmit Control Descriptor */
-} TX_Desc;
-
-/**
- * @brief TX Status structure type definition
- */
-typedef struct {
-   uint32_t Info;		/**&lt; Transmit Information Status */
-} TX_Stat;
-
-
-/**
- * @brief TX Data Buffer structure definition
- */
-typedef struct {
-	uint32_t ulDataLen;			/**&lt; Data length */
-	uint32_t *pbDataBuf;		/**&lt; A word-align data pointer to data buffer */
-} EMAC_PACKETBUF_Type;
-
-/**
- * @brief EMAC configuration structure definition
- */
-typedef struct {
-	uint32_t	Mode;						/**&lt; Supported EMAC PHY device speed, should be one of the following:
-											- EMAC_MODE_AUTO
-											- EMAC_MODE_10M_FULL
-											- EMAC_MODE_10M_HALF
-											- EMAC_MODE_100M_FULL
-											- EMAC_MODE_100M_HALF
-											*/
-	uint8_t 	*pbEMAC_Addr;				/**&lt; Pointer to EMAC Station address that contains 6-bytes
-											of MAC address, it must be sorted in order (bEMAC_Addr[0]..[5])
-											*/
-} EMAC_CFG_Type;
-
-/** EMAC Call back function type definition */
-typedef void (EMAC_IntCBSType)(void);
-
-
-/**
- * @}
- */
-
-
-/* Public Macros -------------------------------------------------------------- */
-/** @defgroup EMAC_Public_Macros
- * @{
- */
-
-
-/* EMAC PHY status type definitions */
-#define EMAC_PHY_STAT_LINK			(0)		/**&lt; Link Status */
-#define EMAC_PHY_STAT_SPEED			(1)		/**&lt; Speed Status */
-#define EMAC_PHY_STAT_DUP			(2)		/**&lt; Duplex Status */
-
-/* EMAC PHY device Speed definitions */
-#define EMAC_MODE_AUTO				(0)		/**&lt; Auto-negotiation mode */
-#define EMAC_MODE_10M_FULL			(1)		/**&lt; 10Mbps FullDuplex mode */
-#define EMAC_MODE_10M_HALF			(2)		/**&lt; 10Mbps HalfDuplex mode */
-#define EMAC_MODE_100M_FULL			(3)		/**&lt; 100Mbps FullDuplex mode */
-#define EMAC_MODE_100M_HALF			(4)		/**&lt; 100Mbps HalfDuplex mode */
-
-/**
- * @}
- */
-
-
-/* Public Functions ----------------------------------------------------------- */
-/** @defgroup EMAC_Public_Functions
- * @{
- */
-
-Status EMAC_Init(EMAC_CFG_Type *EMAC_ConfigStruct);
-void EMAC_DeInit(void);
-int32_t EMAC_CheckPHYStatus(uint32_t ulPHYState);
-int32_t EMAC_SetPHYMode(uint32_t ulPHYMode);
-int32_t EMAC_UpdatePHYStatus(void);
-void EMAC_SetHashFilter(uint8_t dstMAC_addr[], FunctionalState NewState);
-int32_t EMAC_CRCCalc(uint8_t frame_no_fcs[], int32_t frame_len);
-void EMAC_SetFilterMode(uint32_t ulFilterMode, FunctionalState NewState);
-FlagStatus EMAC_GetWoLStatus(uint32_t ulWoLMode);
-void EMAC_WritePacketBuffer(EMAC_PACKETBUF_Type *pDataStruct);
-void EMAC_ReadPacketBuffer(EMAC_PACKETBUF_Type *pDataStruct);
-void EMAC_StandardIRQHandler(void);
-void EMAC_SetupIntCBS(uint32_t ulIntType, EMAC_IntCBSType *pfnIntCb);
-void EMAC_IntCmd(uint32_t ulIntType, FunctionalState NewState);
-IntStatus EMAC_IntGetStatus(uint32_t ulIntType);
-Bool EMAC_CheckReceiveIndex(void);
-Bool EMAC_CheckTransmitIndex(void);
-FlagStatus EMAC_CheckReceiveDataStatus(uint32_t ulRxStatType);
-uint32_t EMAC_GetReceiveDataSize(void);
-void EMAC_UpdateRxConsumeIndex(void);
-void EMAC_UpdateTxProduceIndex(void);
-
-
-/**
- * @}
- */
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* LPC17XX_EMAC_H_ */
-
-/**
- * @}
- */
-
-/* --------------------------------- End Of File ------------------------------ */
+/***********************************************************************//**
+ * @file	: lpc17xx_emac.h
+ * @brief	: Contains all macro definitions and function prototypes
+ * 				support for Ethernet MAC firmware library on LPC17xx
+ * @version	: 1.0
+ * @date	: 02. Jun. 2009
+ * @author	: HieuNguyen
+ **************************************************************************
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * products. This software is supplied &quot;AS IS&quot; without any warranties.
+ * NXP Semiconductors assumes no responsibility or liability for the
+ * use of the software, conveys no license or title under any patent,
+ * copyright, or mask work right to the product. NXP Semiconductors
+ * reserves the right to make changes in the software without
+ * notification. NXP Semiconductors also make no representation or
+ * warranty that such application will be suitable for the specified
+ * use without further testing or modification.
+ **************************************************************************/
+
+/* Peripheral group ----------------------------------------------------------- */
+/** @defgroup EMAC
+ * @ingroup LPC1700CMSIS_FwLib_Drivers
+ * @{
+ */
+
+#ifndef LPC17XX_EMAC_H_
+#define LPC17XX_EMAC_H_
+
+/* Includes ------------------------------------------------------------------- */
+#include &quot;LPC17xx.h&quot;
+#include &quot;lpc_types.h&quot;
+
+
+#ifdef __cplusplus
+extern &quot;C&quot;
+{
+#endif
+
+
+/* Private Macros ------------------------------------------------------------- */
+/** @defgroup EMAC_Private_Macros
+ * @{
+ */
+
+
+/** @defgroup EMAC_REGISTER_BIT_DEFINITIONS
+ * @{
+ */
+
+
+/* EMAC Memory Buffer configuration for 16K Ethernet RAM */
+#define EMAC_NUM_RX_FRAG         4           /**&lt; Num.of RX Fragments 4*1536= 6.0kB */
+#define EMAC_NUM_TX_FRAG         3           /**&lt; Num.of TX Fragments 3*1536= 4.6kB */
+#define EMAC_ETH_MAX_FLEN        1536        /**&lt; Max. Ethernet Frame Size          */
+#define EMAC_TX_FRAME_TOUT       0x00100000  /**&lt; Frame Transmit timeout count      */
+
+/* Ethernet MAC register definitions --------------------------------------------------------------------- */
+/* MAC Configuration Register 1 */
+#define EMAC_MAC1_REC_EN         0x00000001  /**&lt; Receive Enable                    */
+#define EMAC_MAC1_PASS_ALL       0x00000002  /**&lt; Pass All Receive Frames           */
+#define EMAC_MAC1_RX_FLOWC       0x00000004  /**&lt; RX Flow Control                   */
+#define EMAC_MAC1_TX_FLOWC       0x00000008  /**&lt; TX Flow Control                   */
+#define EMAC_MAC1_LOOPB          0x00000010  /**&lt; Loop Back Mode                    */
+#define EMAC_MAC1_RES_TX         0x00000100  /**&lt; Reset TX Logic                    */
+#define EMAC_MAC1_RES_MCS_TX     0x00000200  /**&lt; Reset MAC TX Control Sublayer     */
+#define EMAC_MAC1_RES_RX         0x00000400  /**&lt; Reset RX Logic                    */
+#define EMAC_MAC1_RES_MCS_RX     0x00000800  /**&lt; Reset MAC RX Control Sublayer     */
+#define EMAC_MAC1_SIM_RES        0x00004000  /**&lt; Simulation Reset                  */
+#define EMAC_MAC1_SOFT_RES       0x00008000  /**&lt; Soft Reset MAC                    */
+
+/* MAC Configuration Register 2 */
+#define EMAC_MAC2_FULL_DUP       0x00000001  /**&lt; Full-Duplex Mode                  */
+#define EMAC_MAC2_FRM_LEN_CHK    0x00000002  /**&lt; Frame Length Checking             */
+#define EMAC_MAC2_HUGE_FRM_EN    0x00000004  /**&lt; Huge Frame Enable                 */
+#define EMAC_MAC2_DLY_CRC        0x00000008  /**&lt; Delayed CRC Mode                  */
+#define EMAC_MAC2_CRC_EN         0x00000010  /**&lt; Append CRC to every Frame         */
+#define EMAC_MAC2_PAD_EN         0x00000020  /**&lt; Pad all Short Frames              */
+#define EMAC_MAC2_VLAN_PAD_EN    0x00000040  /**&lt; VLAN Pad Enable                   */
+#define EMAC_MAC2_ADET_PAD_EN    0x00000080  /**&lt; Auto Detect Pad Enable            */
+#define EMAC_MAC2_PPREAM_ENF     0x00000100  /**&lt; Pure Preamble Enforcement         */
+#define EMAC_MAC2_LPREAM_ENF     0x00000200  /**&lt; Long Preamble Enforcement         */
+#define EMAC_MAC2_NO_BACKOFF     0x00001000  /**&lt; No Backoff Algorithm              */
+#define EMAC_MAC2_BACK_PRESSURE  0x00002000  /**&lt; Backoff Presurre / No Backoff     */
+#define EMAC_MAC2_EXCESS_DEF     0x00004000  /**&lt; Excess Defer                      */
+
+/* Back-to-Back Inter-Packet-Gap Register */
+/** Programmable field representing the nibble time offset of the minimum possible period
+ * between the end of any transmitted packet to the beginning of the next */
+#define EMAC_IPGT_BBIPG(n)		(n&amp;0x7F)
+/** Recommended value for Full Duplex of Programmable field representing the nibble time
+ * offset of the minimum possible period between the end of any transmitted packet to the
+ * beginning of the next */
+#define EMAC_IPGT_FULL_DUP		(EMAC_IPGT_BBIPG(0x15))
+/** Recommended value for Half Duplex of Programmable field representing the nibble time
+ * offset of the minimum possible period between the end of any transmitted packet to the
+ * beginning of the next */
+#define EMAC_IPGT_HALF_DUP      (EMAC_IPGT_BBIPG(0x12))
+
+/* Non Back-to-Back Inter-Packet-Gap Register */
+/** Programmable field representing the Non-Back-to-Back Inter-Packet-Gap */
+#define EMAC_IPGR_NBBIPG_P2(n)	(n&amp;0x7F)
+/** Recommended value for Programmable field representing the Non-Back-to-Back Inter-Packet-Gap Part 1 */
+#define EMAC_IPGR_P2_DEF		(EMAC_IPGR_NBBIPG_P2(0x12))
+/** Programmable field representing the optional carrierSense window referenced in
+ * IEEE 802.3/4.2.3.2.1 'Carrier Deference' */
+#define EMAC_IPGR_NBBIPG_P1(n)	((n&amp;0x7F)&lt;&lt;8)
+/** Recommended value for Programmable field representing the Non-Back-to-Back Inter-Packet-Gap Part 2 */
+#define EMAC_IPGR_P1_DEF        EMAC_IPGR_NBBIPG_P1(0x0C)
+
+/* Collision Window/Retry Register */
+/** Programmable field specifying the number of retransmission attempts following a collision before
+ * aborting the packet due to excessive collisions */
+#define EMAC_CLRT_MAX_RETX(n)	(n&amp;0x0F)
+/** Programmable field representing the slot time or collision window during which collisions occur
+ * in properly configured networks */
+#define EMAC_CLRT_COLL(n)		((n&amp;0x3F)&lt;&lt;8)
+/** Default value for Collision Window / Retry register */
+#define EMAC_CLRT_DEF           ((EMAC_CLRT_MAX_RETX(0x0F))|(EMAC_CLRT_COLL(0x37)))
+
+/* Maximum Frame Register */
+/** Represents a maximum receive frame of 1536 octets */
+#define EMAC_MAXF_MAXFRMLEN(n)	(n&amp;0xFFFF)
+
+/* PHY Support Register */
+#define EMAC_SUPP_SPEED			0x00000100  	/**&lt; Reduced MII Logic Current Speed   */
+#define EMAC_SUPP_RES_RMII      0x00000800  	/**&lt; Reset Reduced MII Logic           */
+
+/* Test Register */
+#define EMAC_TEST_SHCUT_PQUANTA  0x00000001  	/**&lt; Shortcut Pause Quanta             */
+#define EMAC_TEST_TST_PAUSE      0x00000002  	/**&lt; Test Pause                        */
+#define EMAC_TEST_TST_BACKP      0x00000004  	/**&lt; Test Back Pressure                */
+
+/* MII Management Configuration Register */
+#define EMAC_MCFG_SCAN_INC       0x00000001  	/**&lt; Scan Increment PHY Address        */
+#define EMAC_MCFG_SUPP_PREAM     0x00000002  	/**&lt; Suppress Preamble                 */
+#define EMAC_MCFG_CLK_SEL(n)     ((n&amp;0x0F)&lt;&lt;2)  /**&lt; Clock Select Field                 */
+#define EMAC_MCFG_RES_MII        0x00008000  	/**&lt; Reset MII Management Hardware     */
+#define EMAC_MCFG_MII_MAXCLK	 2500000UL		/**&lt; MII Clock max */
+
+/* MII Management Command Register */
+#define EMAC_MCMD_READ           0x00000001  	/**&lt; MII Read                          */
+#define EMAC_MCMD_SCAN           0x00000002  	/**&lt; MII Scan continuously             */
+
+#define EMAC_MII_WR_TOUT         0x00050000  	/**&lt; MII Write timeout count           */
+#define EMAC_MII_RD_TOUT         0x00050000  	/**&lt; MII Read timeout count            */
+
+/* MII Management Address Register */
+#define EMAC_MADR_REG_ADR(n)     (n&amp;0x1F)  		/**&lt; MII Register Address field         */
+#define EMAC_MADR_PHY_ADR(n)     ((n&amp;0x1F)&lt;&lt;8)  /**&lt; PHY Address Field                  */
+
+/* MII Management Write Data Register */
+#define EMAC_MWTD_DATA(n)		(n&amp;0xFFFF)		/**&lt; Data field for MMI Management Write Data register */
+
+/* MII Management Read Data Register */
+#define EMAC_MRDD_DATA(n)		(n&amp;0xFFFF)		/**&lt; Data field for MMI Management Read Data register */
+
+/* MII Management Indicators Register */
+#define EMAC_MIND_BUSY           0x00000001  	/**&lt; MII is Busy                       */
+#define EMAC_MIND_SCAN           0x00000002  	/**&lt; MII Scanning in Progress          */
+#define EMAC_MIND_NOT_VAL        0x00000004  	/**&lt; MII Read Data not valid           */
+#define EMAC_MIND_MII_LINK_FAIL  0x00000008  	/**&lt; MII Link Failed                   */
+
+/* Station Address 0 Register */
+/* Station Address 1 Register */
+/* Station Address 2 Register */
+
+
+/* Control register definitions --------------------------------------------------------------------------- */
+/* Command Register */
+#define EMAC_CR_RX_EN            0x00000001  	/**&lt; Enable Receive                    */
+#define EMAC_CR_TX_EN            0x00000002  	/**&lt; Enable Transmit                   */
+#define EMAC_CR_REG_RES          0x00000008  	/**&lt; Reset Host Registers              */
+#define EMAC_CR_TX_RES           0x00000010  	/**&lt; Reset Transmit Datapath           */
+#define EMAC_CR_RX_RES           0x00000020  	/**&lt; Reset Receive Datapath            */
+#define EMAC_CR_PASS_RUNT_FRM    0x00000040  	/**&lt; Pass Runt Frames                  */
+#define EMAC_CR_PASS_RX_FILT     0x00000080  	/**&lt; Pass RX Filter                    */
+#define EMAC_CR_TX_FLOW_CTRL     0x00000100  	/**&lt; TX Flow Control                   */
+#define EMAC_CR_RMII             0x00000200  	/**&lt; Reduced MII Interface             */
+#define EMAC_CR_FULL_DUP         0x00000400  	/**&lt; Full Duplex                       */
+
+/* Status Register */
+#define EMAC_SR_RX_EN            0x00000001  	/**&lt; Enable Receive                    */
+#define EMAC_SR_TX_EN            0x00000002  	/**&lt; Enable Transmit                   */
+
+/* Receive Descriptor Base Address Register */
+//
+
+/* Receive Status Base Address Register */
+//
+
+/* Receive Number of Descriptors Register */
+//
+
+/* Receive Produce Index Register */
+//
+
+/* Receive Consume Index Register */
+//
+
+/* Transmit Descriptor Base Address Register */
+//
+
+/* Transmit Status Base Address Register */
+//
+
+/* Transmit Number of Descriptors Register */
+//
+
+/* Transmit Produce Index Register */
+//
+
+/* Transmit Consume Index Register */
+//
+
+/* Transmit Status Vector 0 Register */
+#define EMAC_TSV0_CRC_ERR        0x00000001  /**&lt; CRC error                         */
+#define EMAC_TSV0_LEN_CHKERR     0x00000002  /**&lt; Length Check Error                */
+#define EMAC_TSV0_LEN_OUTRNG     0x00000004  /**&lt; Length Out of Range               */
+#define EMAC_TSV0_DONE           0x00000008  /**&lt; Tramsmission Completed            */
+#define EMAC_TSV0_MCAST          0x00000010  /**&lt; Multicast Destination             */
+#define EMAC_TSV0_BCAST          0x00000020  /**&lt; Broadcast Destination             */
+#define EMAC_TSV0_PKT_DEFER      0x00000040  /**&lt; Packet Deferred                   */
+#define EMAC_TSV0_EXC_DEFER      0x00000080  /**&lt; Excessive Packet Deferral         */
+#define EMAC_TSV0_EXC_COLL       0x00000100  /**&lt; Excessive Collision               */
+#define EMAC_TSV0_LATE_COLL      0x00000200  /**&lt; Late Collision Occured            */
+#define EMAC_TSV0_GIANT          0x00000400  /**&lt; Giant Frame                       */
+#define EMAC_TSV0_UNDERRUN       0x00000800  /**&lt; Buffer Underrun                   */
+#define EMAC_TSV0_BYTES          0x0FFFF000  /**&lt; Total Bytes Transferred           */
+#define EMAC_TSV0_CTRL_FRAME     0x10000000  /**&lt; Control Frame                     */
+#define EMAC_TSV0_PAUSE          0x20000000  /**&lt; Pause Frame                       */
+#define EMAC_TSV0_BACK_PRESS     0x40000000  /**&lt; Backpressure Method Applied       */
+#define EMAC_TSV0_VLAN           0x80000000  /**&lt; VLAN Frame                        */
+
+/* Transmit Status Vector 1 Register */
+#define EMAC_TSV1_BYTE_CNT       0x0000FFFF  /**&lt; Transmit Byte Count               */
+#define EMAC_TSV1_COLL_CNT       0x000F0000  /**&lt; Transmit Collision Count          */
+
+/* Receive Status Vector Register */
+#define EMAC_RSV_BYTE_CNT        0x0000FFFF  /**&lt; Receive Byte Count                */
+#define EMAC_RSV_PKT_IGNORED     0x00010000  /**&lt; Packet Previously Ignored         */
+#define EMAC_RSV_RXDV_SEEN       0x00020000  /**&lt; RXDV Event Previously Seen        */
+#define EMAC_RSV_CARR_SEEN       0x00040000  /**&lt; Carrier Event Previously Seen     */
+#define EMAC_RSV_REC_CODEV       0x00080000  /**&lt; Receive Code Violation            */
+#define EMAC_RSV_CRC_ERR         0x00100000  /**&lt; CRC Error                         */
+#define EMAC_RSV_LEN_CHKERR      0x00200000  /**&lt; Length Check Error                */
+#define EMAC_RSV_LEN_OUTRNG      0x00400000  /**&lt; Length Out of Range               */
+#define EMAC_RSV_REC_OK          0x00800000  /**&lt; Frame Received OK                 */
+#define EMAC_RSV_MCAST           0x01000000  /**&lt; Multicast Frame                   */
+#define EMAC_RSV_BCAST           0x02000000  /**&lt; Broadcast Frame                   */
+#define EMAC_RSV_DRIB_NIBB       0x04000000  /**&lt; Dribble Nibble                    */
+#define EMAC_RSV_CTRL_FRAME      0x08000000  /**&lt; Control Frame                     */
+#define EMAC_RSV_PAUSE           0x10000000  /**&lt; Pause Frame                       */
+#define EMAC_RSV_UNSUPP_OPC      0x20000000  /**&lt; Unsupported Opcode                */
+#define EMAC_RSV_VLAN            0x40000000  /**&lt; VLAN Frame                        */
+
+/* Flow Control Counter Register */
+#define EMAC_FCC_MIRR_CNT(n)        	(n&amp;0xFFFF)  		/**&lt; Mirror Counter                    */
+#define EMAC_FCC_PAUSE_TIM(n)       	((n&amp;0xFFFF)&lt;&lt;16)  	/**&lt; Pause Timer                       */
+
+/* Flow Control Status Register */
+#define EMAC_FCS_MIRR_CNT(n)        	(n&amp;0xFFFF)  		/**&lt; Mirror Counter Current            */
+
+
+/* Receive filter register definitions -------------------------------------------------------- */
+/* Receive Filter Control Register */
+#define EMAC_RFC_UCAST_EN        0x00000001  /**&lt; Accept Unicast Frames Enable      */
+#define EMAC_RFC_BCAST_EN        0x00000002  /**&lt; Accept Broadcast Frames Enable    */
+#define EMAC_RFC_MCAST_EN        0x00000004  /**&lt; Accept Multicast Frames Enable    */
+#define EMAC_RFC_UCAST_HASH_EN   0x00000008  /**&lt; Accept Unicast Hash Filter Frames */
+#define EMAC_RFC_MCAST_HASH_EN   0x00000010  /**&lt; Accept Multicast Hash Filter Fram.*/
+#define EMAC_RFC_PERFECT_EN      0x00000020  /**&lt; Accept Perfect Match Enable       */
+#define EMAC_RFC_MAGP_WOL_EN     0x00001000  /**&lt; Magic Packet Filter WoL Enable    */
+#define EMAC_RFC_PFILT_WOL_EN    0x00002000  /**&lt; Perfect Filter WoL Enable         */
+
+/* Receive Filter WoL Status/Clear Registers */
+#define EMAC_WOL_UCAST           0x00000001  /**&lt; Unicast Frame caused WoL          */
+#define EMAC_WOL_BCAST           0x00000002  /**&lt; Broadcast Frame caused WoL        */
+#define EMAC_WOL_MCAST           0x00000004  /**&lt; Multicast Frame caused WoL        */
+#define EMAC_WOL_UCAST_HASH      0x00000008  /**&lt; Unicast Hash Filter Frame WoL     */
+#define EMAC_WOL_MCAST_HASH      0x00000010  /**&lt; Multicast Hash Filter Frame WoL   */
+#define EMAC_WOL_PERFECT         0x00000020  /**&lt; Perfect Filter WoL                */
+#define EMAC_WOL_RX_FILTER       0x00000080  /**&lt; RX Filter caused WoL              */
+#define EMAC_WOL_MAG_PACKET      0x00000100  /**&lt; Magic Packet Filter caused WoL    */
+#define EMAC_WOL_BITMASK		 0x01BF		/**&lt; Receive Filter WoL Status/Clear bitmasl value */
+
+/* Hash Filter Table LSBs Register */
+//
+
+/* Hash Filter Table MSBs Register */
+//
+
+
+/* Module control register definitions ---------------------------------------------------- */
+/* Interrupt Status/Enable/Clear/Set Registers */
+#define EMAC_INT_RX_OVERRUN      0x00000001  /**&lt; Overrun Error in RX Queue         */
+#define EMAC_INT_RX_ERR          0x00000002  /**&lt; Receive Error                     */
+#define EMAC_INT_RX_FIN          0x00000004  /**&lt; RX Finished Process Descriptors   */
+#define EMAC_INT_RX_DONE         0x00000008  /**&lt; Receive Done                      */
+#define EMAC_INT_TX_UNDERRUN     0x00000010  /**&lt; Transmit Underrun                 */
+#define EMAC_INT_TX_ERR          0x00000020  /**&lt; Transmit Error                    */
+#define EMAC_INT_TX_FIN          0x00000040  /**&lt; TX Finished Process Descriptors   */
+#define EMAC_INT_TX_DONE         0x00000080  /**&lt; Transmit Done                     */
+#define EMAC_INT_SOFT_INT        0x00001000  /**&lt; Software Triggered Interrupt      */
+#define EMAC_INT_WAKEUP          0x00002000  /**&lt; Wakeup Event Interrupt            */
+
+/* Power Down Register */
+#define EMAC_PD_POWER_DOWN       0x80000000  /**&lt; Power Down MAC                    */
+
+/* RX Descriptor Control Word */
+#define EMAC_RCTRL_SIZE(n)       (n&amp;0x7FF)  	/**&lt; Buffer size field                  */
+#define EMAC_RCTRL_INT           0x80000000  	/**&lt; Generate RxDone Interrupt         */
+
+/* RX Status Hash CRC Word */
+#define EMAC_RHASH_SA            0x000001FF  	/**&lt; Hash CRC for Source Address       */
+#define EMAC_RHASH_DA            0x001FF000  	/**&lt; Hash CRC for Destination Address  */
+
+/* RX Status Information Word */
+#define EMAC_RINFO_SIZE          0x000007FF  /**&lt; Data size in bytes                */
+#define EMAC_RINFO_CTRL_FRAME    0x00040000  /**&lt; Control Frame                     */
+#define EMAC_RINFO_VLAN          0x00080000  /**&lt; VLAN Frame                        */
+#define EMAC_RINFO_FAIL_FILT     0x00100000  /**&lt; RX Filter Failed                  */
+#define EMAC_RINFO_MCAST         0x00200000  /**&lt; Multicast Frame                   */
+#define EMAC_RINFO_BCAST         0x00400000  /**&lt; Broadcast Frame                   */
+#define EMAC_RINFO_CRC_ERR       0x00800000  /**&lt; CRC Error in Frame                */
+#define EMAC_RINFO_SYM_ERR       0x01000000  /**&lt; Symbol Error from PHY             */
+#define EMAC_RINFO_LEN_ERR       0x02000000  /**&lt; Length Error                      */
+#define EMAC_RINFO_RANGE_ERR     0x04000000  /**&lt; Range Error (exceeded max. size)  */
+#define EMAC_RINFO_ALIGN_ERR     0x08000000  /**&lt; Alignment Error                   */
+#define EMAC_RINFO_OVERRUN       0x10000000  /**&lt; Receive overrun                   */
+#define EMAC_RINFO_NO_DESCR      0x20000000  /**&lt; No new Descriptor available       */
+#define EMAC_RINFO_LAST_FLAG     0x40000000  /**&lt; Last Fragment in Frame            */
+#define EMAC_RINFO_ERR           0x80000000  /**&lt; Error Occured (OR of all errors)  */
+
+/** RX Status Information word mask */
+#define EMAC_RINFO_ERR_MASK     (EMAC_RINFO_FAIL_FILT | EMAC_RINFO_CRC_ERR   | EMAC_RINFO_SYM_ERR | \
+EMAC_RINFO_LEN_ERR   | EMAC_RINFO_ALIGN_ERR | EMAC_RINFO_OVERRUN)
+
+/* TX Descriptor Control Word */
+#define EMAC_TCTRL_SIZE          0x000007FF  /**&lt; Size of data buffer in bytes      */
+#define EMAC_TCTRL_OVERRIDE      0x04000000  /**&lt; Override Default MAC Registers    */
+#define EMAC_TCTRL_HUGE          0x08000000  /**&lt; Enable Huge Frame                 */
+#define EMAC_TCTRL_PAD           0x10000000  /**&lt; Pad short Frames to 64 bytes      */
+#define EMAC_TCTRL_CRC           0x20000000  /**&lt; Append a hardware CRC to Frame    */
+#define EMAC_TCTRL_LAST          0x40000000  /**&lt; Last Descriptor for TX Frame      */
+#define EMAC_TCTRL_INT           0x80000000  /**&lt; Generate TxDone Interrupt         */
+
+/* TX Status Information Word */
+#define EMAC_TINFO_COL_CNT       0x01E00000  /**&lt; Collision Count                   */
+#define EMAC_TINFO_DEFER         0x02000000  /**&lt; Packet Deferred (not an error)    */
+#define EMAC_TINFO_EXCESS_DEF    0x04000000  /**&lt; Excessive Deferral                */
+#define EMAC_TINFO_EXCESS_COL    0x08000000  /**&lt; Excessive Collision               */
+#define EMAC_TINFO_LATE_COL      0x10000000  /**&lt; Late Collision Occured            */
+#define EMAC_TINFO_UNDERRUN      0x20000000  /**&lt; Transmit Underrun                 */
+#define EMAC_TINFO_NO_DESCR      0x40000000  /**&lt; No new Descriptor available       */
+#define EMAC_TINFO_ERR           0x80000000  /**&lt; Error Occured (OR of all errors)  */
+
+
+/* DP83848C PHY definition ------------------------------------------------------------ */
+
+/** PHY device reset time out definition */
+#define EMAC_PHY_RESP_TOUT		0x100000UL
+
+/* ENET Device Revision ID */
+#define EMAC_OLD_EMAC_MODULE_ID  0x39022000  /**&lt; Rev. ID for first rev '-'         */
+
+/* DP83848C PHY Registers */
+#define EMAC_PHY_REG_BMCR        0x00        /**&lt; Basic Mode Control Register       */
+#define EMAC_PHY_REG_BMSR        0x01        /**&lt; Basic Mode Status Register        */
+#define EMAC_PHY_REG_IDR1        0x02        /**&lt; PHY Identifier 1                  */
+#define EMAC_PHY_REG_IDR2        0x03        /**&lt; PHY Identifier 2                  */
+#define EMAC_PHY_REG_ANAR        0x04        /**&lt; Auto-Negotiation Advertisement    */
+#define EMAC_PHY_REG_ANLPAR      0x05        /**&lt; Auto-Neg. Link Partner Abitily    */
+#define EMAC_PHY_REG_ANER        0x06        /**&lt; Auto-Neg. Expansion Register      */
+#define EMAC_PHY_REG_ANNPTR      0x07        /**&lt; Auto-Neg. Next Page TX            */
+#define EMAC_PHY_REG_LPNPA		 0x08
+
+
+/* PHY Extended Registers */
+#define EMAC_PHY_REG_STS         0x10        /**&lt; Status Register                   */
+#define EMAC_PHY_REG_MICR        0x11        /**&lt; MII Interrupt Control Register    */
+#define EMAC_PHY_REG_MISR        0x12        /**&lt; MII Interrupt Status Register     */
+#define EMAC_PHY_REG_FCSCR       0x14        /**&lt; False Carrier Sense Counter       */
+#define EMAC_PHY_REG_RECR        0x15        /**&lt; Receive Error Counter             */
+#define EMAC_PHY_REG_PCSR        0x16        /**&lt; PCS Sublayer Config. and Status   */
+#define EMAC_PHY_REG_RBR         0x17        /**&lt; RMII and Bypass Register          */
+#define EMAC_PHY_REG_LEDCR       0x18        /**&lt; LED Direct Control Register       */
+#define EMAC_PHY_REG_PHYCR       0x19        /**&lt; PHY Control Register              */
+#define EMAC_PHY_REG_10BTSCR     0x1A        /**&lt; 10Base-T Status/Control Register  */
+#define EMAC_PHY_REG_CDCTRL1     0x1B        /**&lt; CD Test Control and BIST Extens.  */
+#define EMAC_PHY_REG_EDCR        0x1D        /**&lt; Energy Detect Control Register    */
+
+
+/* PHY Basic Mode Control Register (BMCR) bitmap definitions */
+#define EMAC_PHY_BMCR_RESET     			(1&lt;&lt;15)		/**&lt; Reset bit */
+#define EMAC_PHY_BMCR_LOOPBACK      		(1&lt;&lt;14)		/**&lt; Loop back */
+#define EMAC_PHY_BMCR_SPEED_SEL     		(1&lt;&lt;13)		/**&lt; Speed selection */
+#define EMAC_PHY_BMCR_AN					(1&lt;&lt;12)		/**&lt; Auto Negotiation */
+#define EMAC_PHY_BMCR_POWERDOWN				(1&lt;&lt;11)		/**&lt; Power down mode */
+#define EMAC_PHY_BMCR_ISOLATE				(1&lt;&lt;10)		/**&lt; Isolate */
+#define EMAC_PHY_BMCR_RE_AN					(1&lt;&lt;9)		/**&lt; Restart auto negotiation */
+#define EMAC_PHY_BMCR_DUPLEX				(1&lt;&lt;8)		/**&lt; Duplex mode */
+
+/* PHY Basic Mode Status Status Register (BMSR) bitmap definitions */
+#define EMAC_PHY_BMSR_100BE_T4        	   	(1&lt;&lt;15)		/**&lt; 100 base T4 */
+#define EMAC_PHY_BMSR_100TX_FULL			(1&lt;&lt;14)		/**&lt; 100 base full duplex */
+#define EMAC_PHY_BMSR_100TX_HALF			(1&lt;&lt;13)		/**&lt; 100 base half duplex */
+#define EMAC_PHY_BMSR_10BE_FULL				(1&lt;&lt;12)		/**&lt; 10 base T full duplex */
+#define EMAC_PHY_BMSR_10BE_HALF				(1&lt;&lt;11)		/**&lt; 10 base T half duplex */
+#define EMAC_PHY_BMSR_NOPREAM				(1&lt;&lt;6)		/**&lt; MF Preamable Supress */
+#define EMAC_PHY_BMSR_AUTO_DONE				(1&lt;&lt;5)		/**&lt; Auto negotiation complete */
+#define EMAC_PHY_BMSR_REMOTE_FAULT			(1&lt;&lt;4)		/**&lt; Remote fault */
+#define EMAC_PHY_BMSR_NO_AUTO				(1&lt;&lt;3)		/**&lt; Auto Negotiation ability */
+#define EMAC_PHY_BMSR_LINK_ESTABLISHED		(1&lt;&lt;2)		/**&lt; Link status */
+
+/* PHY Status Register bitmap definitions */
+#define EMAC_PHY_SR_REMOTE_FAULT   			(1&lt;&lt;6)		/**&lt; Remote Fault */
+#define EMAC_PHY_SR_JABBER					(1&lt;&lt;5)		/**&lt; Jabber detect */
+#define EMAC_PHY_SR_AUTO_DONE				(1&lt;&lt;4)		/**&lt; Auto Negotiation complete */
+#define EMAC_PHY_SR_LOOPBACK				(1&lt;&lt;3)		/**&lt; Loop back status */
+#define EMAC_PHY_SR_DUP						(1&lt;&lt;2)		/**&lt; Duplex status */
+#define EMAC_PHY_SR_SPEED					(1&lt;&lt;1)		/**&lt; Speed status */
+#define EMAC_PHY_SR_LINK					(1&lt;&lt;0)		/**&lt; Link Status */
+
+
+#define EMAC_PHY_FULLD_100M      0x2100      /**&lt; Full Duplex 100Mbit               */
+#define EMAC_PHY_HALFD_100M      0x2000      /**&lt; Half Duplex 100Mbit               */
+#define EMAC_PHY_FULLD_10M       0x0100      /**&lt; Full Duplex 10Mbit                */
+#define EMAC_PHY_HALFD_10M       0x0000      /**&lt; Half Duplex 10MBit                */
+#define EMAC_PHY_AUTO_NEG        0x3000      /**&lt; Select Auto Negotiation           */
+
+#define EMAC_DP83848C_DEF_ADR    0x0100      /**&lt; Default PHY device address        */
+#define EMAC_DP83848C_ID         0x20005C90  /**&lt; PHY Identifier                    */
+
+
+/**
+ * @}
+ */
+
+/**
+ * @}
+ */
+
+
+/* Public Types --------------------------------------------------------------- */
+/** @defgroup EMAC_Public_Types
+ * @{
+ */
+
+/* Descriptor and status formats ---------------------------------------------- */
+
+/**
+ * @brief RX Descriptor structure type definition
+ */
+typedef struct {
+	uint32_t Packet;	/**&lt; Receive Packet Descriptor */
+	uint32_t Ctrl;		/**&lt; Receive Control Descriptor */
+} RX_Desc;
+
+/**
+ * @brief RX Status structure type definition
+ */
+typedef struct {
+	uint32_t Info;		/**&lt; Receive Information Status */
+	uint32_t HashCRC;	/**&lt; Receive Hash CRC Status */
+} RX_Stat;
+
+/**
+ * @brief TX Descriptor structure type definition
+ */
+typedef struct {
+	uint32_t Packet;	/**&lt; Transmit Packet Descriptor */
+	uint32_t Ctrl;		/**&lt; Transmit Control Descriptor */
+} TX_Desc;
+
+/**
+ * @brief TX Status structure type definition
+ */
+typedef struct {
+   uint32_t Info;		/**&lt; Transmit Information Status */
+} TX_Stat;
+
+
+/**
+ * @brief TX Data Buffer structure definition
+ */
+typedef struct {
+	uint32_t ulDataLen;			/**&lt; Data length */
+	uint32_t *pbDataBuf;		/**&lt; A word-align data pointer to data buffer */
+} EMAC_PACKETBUF_Type;
+
+/**
+ * @brief EMAC configuration structure definition
+ */
+typedef struct {
+	uint32_t	Mode;						/**&lt; Supported EMAC PHY device speed, should be one of the following:
+											- EMAC_MODE_AUTO
+											- EMAC_MODE_10M_FULL
+											- EMAC_MODE_10M_HALF
+											- EMAC_MODE_100M_FULL
+											- EMAC_MODE_100M_HALF
+											*/
+	uint8_t 	*pbEMAC_Addr;				/**&lt; Pointer to EMAC Station address that contains 6-bytes
+											of MAC address, it must be sorted in order (bEMAC_Addr[0]..[5])
+											*/
+} EMAC_CFG_Type;
+
+/** EMAC Call back function type definition */
+typedef void (EMAC_IntCBSType)(void);
+
+
+/**
+ * @}
+ */
+
+
+/* Public Macros -------------------------------------------------------------- */
+/** @defgroup EMAC_Public_Macros
+ * @{
+ */
+
+
+/* EMAC PHY status type definitions */
+#define EMAC_PHY_STAT_LINK			(0)		/**&lt; Link Status */
+#define EMAC_PHY_STAT_SPEED			(1)		/**&lt; Speed Status */
+#define EMAC_PHY_STAT_DUP			(2)		/**&lt; Duplex Status */
+
+/* EMAC PHY device Speed definitions */
+#define EMAC_MODE_AUTO				(0)		/**&lt; Auto-negotiation mode */
+#define EMAC_MODE_10M_FULL			(1)		/**&lt; 10Mbps FullDuplex mode */
+#define EMAC_MODE_10M_HALF			(2)		/**&lt; 10Mbps HalfDuplex mode */
+#define EMAC_MODE_100M_FULL			(3)		/**&lt; 100Mbps FullDuplex mode */
+#define EMAC_MODE_100M_HALF			(4)		/**&lt; 100Mbps HalfDuplex mode */
+
+/**
+ * @}
+ */
+
+
+/* Public Functions ----------------------------------------------------------- */
+/** @defgroup EMAC_Public_Functions
+ * @{
+ */
+
+Status EMAC_Init(EMAC_CFG_Type *EMAC_ConfigStruct);
+void EMAC_DeInit(void);
+int32_t EMAC_CheckPHYStatus(uint32_t ulPHYState);
+int32_t EMAC_SetPHYMode(uint32_t ulPHYMode);
+int32_t EMAC_UpdatePHYStatus(void);
+void EMAC_SetHashFilter(uint8_t dstMAC_addr[], FunctionalState NewState);
+int32_t EMAC_CRCCalc(uint8_t frame_no_fcs[], int32_t frame_len);
+void EMAC_SetFilterMode(uint32_t ulFilterMode, FunctionalState NewState);
+FlagStatus EMAC_GetWoLStatus(uint32_t ulWoLMode);
+void EMAC_WritePacketBuffer(EMAC_PACKETBUF_Type *pDataStruct);
+void EMAC_ReadPacketBuffer(EMAC_PACKETBUF_Type *pDataStruct);
+void EMAC_StandardIRQHandler(void);
+void EMAC_SetupIntCBS(uint32_t ulIntType, EMAC_IntCBSType *pfnIntCb);
+void EMAC_IntCmd(uint32_t ulIntType, FunctionalState NewState);
+IntStatus EMAC_IntGetStatus(uint32_t ulIntType);
+Bool EMAC_CheckReceiveIndex(void);
+Bool EMAC_CheckTransmitIndex(void);
+FlagStatus EMAC_CheckReceiveDataStatus(uint32_t ulRxStatType);
+uint32_t EMAC_GetReceiveDataSize(void);
+void EMAC_UpdateRxConsumeIndex(void);
+void EMAC_UpdateTxProduceIndex(void);
+
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LPC17XX_EMAC_H_ */
+
+/**
+ * @}
+ */
+
+/* --------------------------------- End Of File ------------------------------ */


Property changes on: trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_emac.h
___________________________________________________________________
Deleted: svn:executable
   - *

Modified: trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_gpdma.h
===================================================================
--- trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_gpdma.h	2010-06-28 21:53:59 UTC (rev 759)
+++ trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_gpdma.h	2010-07-12 20:56:54 UTC (rev 760)
@@ -1,394 +1,394 @@
-/***********************************************************************//**
- * @file	: lpc17xx_gpdma.h
- * @brief	: Contains all macro definitions and function prototypes
- * 				support for GPDMA firmware library on LPC17xx
- * @version	: 1.0
- * @date	: 20. Apr. 2009
- * @author	: HieuNguyen
- **************************************************************************
- * Software that is described herein is for illustrative purposes only
- * which provides customers with programming information regarding the
- * products. This software is supplied &quot;AS IS&quot; without any warranties.
- * NXP Semiconductors assumes no responsibility or liability for the
- * use of the software, conveys no license or title under any patent,
- * copyright, or mask work right to the product. NXP Semiconductors
- * reserves the right to make changes in the software without
- * notification. NXP Semiconductors also make no representation or
- * warranty that such application will be suitable for the specified
- * use without further testing or modification.
- **************************************************************************/
-
-/* Peripheral group ----------------------------------------------------------- */
-/** @defgroup GPDMA
- * @ingroup LPC1700CMSIS_FwLib_Drivers
- * @{
- */
-
-#ifndef LPC17XX_GPDMA_H_
-#define LPC17XX_GPDMA_H_
-
-/* Includes ------------------------------------------------------------------- */
-#include &quot;LPC17xx.h&quot;
-#include &quot;lpc_types.h&quot;
-
-
-#ifdef __cplusplus
-extern &quot;C&quot;
-{
-#endif
-
-
-/* Private Macros ------------------------------------------------------------- */
-/** @defgroup GPDMA_Private_Macros
- * @{
- */
-
-/** @defgroup DMA_REGISTER_BIT_DEFINITIONS
- * @{
- */
-
-/** Macros define for DMA interrupt */
-/** DMA Interrupt Status register */
-#define GPDMA_DMACIntStat_Ch(n)			(((1UL&lt;&lt;n)&amp;0xFF))
-#define GPDMA_DMACIntStat_BITMASK		((0xFF))
-
-/** DMA Interrupt Terminal Count Request Status register */
-#define GPDMA_DMACIntTCStat_Ch(n)		(((1UL&lt;&lt;n)&amp;0xFF))
-#define GPDMA_DMACIntTCStat_BITMASK		((0xFF))
-
-/** DMA Interrupt Terminal Count Request Clear register */
-#define GPDMA_DMACIntTCClear_Ch(n)		(((1UL&lt;&lt;n)&amp;0xFF))
-#define GPDMA_DMACIntTCClear_BITMASK	((0xFF))
-
-/** DMA Interrupt Error Status register */
-#define GPDMA_DMACIntErrStat_Ch(n)		(((1UL&lt;&lt;n)&amp;0xFF))
-#define GPDMA_DMACIntErrStat_BITMASK	((0xFF))
-
-/** DMA Interrupt Error Clear register */
-#define GPDMA_DMACIntErrClr_Ch(n)		(((1UL&lt;&lt;n)&amp;0xFF))
-#define GPDMA_DMACIntErrClr_BITMASK		((0xFF))
-
-/** DMA Raw Interrupt Terminal Count Status register */
-#define GPDMA_DMACRawIntTCStat_Ch(n)	(((1UL&lt;&lt;n)&amp;0xFF))
-#define GPDMA_DMACRawIntTCStat_BITMASK	((0xFF))
-
-/** DMA Raw Error Interrupt Status register */
-#define GPDMA_DMACRawIntErrStat_Ch(n)	(((1UL&lt;&lt;n)&amp;0xFF))
-#define GPDMA_DMACRawIntErrStat_BITMASK	((0xFF))
-
-/** DMA Enabled Channel register */
-#define GPDMA_DMACEnbldChns_Ch(n)		(((1UL&lt;&lt;n)&amp;0xFF))
-#define GPDMA_DMACEnbldChns_BITMASK		((0xFF))
-
-
-/** Macro defines for DMA Software Burst Request register */
-#define	GPDMA_DMACSoftBReq_Src(n)		(((1UL&lt;&lt;n)&amp;0xFFFF))
-#define GPDMA_DMACSoftBReq_BITMASK		((0xFFFF))
-
-/** Macro defines for DMA Software Single Request register */
-#define GPDMA_DMACSoftSReq_Src(n) 		(((1UL&lt;&lt;n)&amp;0xFFFF))
-#define GPDMA_DMACSoftSReq_BITMASK		((0xFFFF))
-
-/** Macro defines for DMA Software Last Burst Request register */
-#define GPDMA_DMACSoftLBReq_Src(n)		(((1UL&lt;&lt;n)&amp;0xFFFF))
-#define GPDMA_DMACSoftLBReq_BITMASK		((0xFFFF))
-
-/** Macro defines for DMA Software Last Single Request register */
-#define GPDMA_DMACSoftLSReq_Src(n) 		(((1UL&lt;&lt;n)&amp;0xFFFF))
-#define GPDMA_DMACSoftLSReq_BITMASK		((0xFFFF))
-
-/** DMA Configuration register bit description*/
-#define GPDMA_DMACConfig_E				((0x01))	 /**&lt; DMA Controller enable*/
-#define GPDMA_DMACConfig_M				((0x02))	 /**&lt; AHB Master endianness configuration*/
-#define GPDMA_DMACConfig_BITMASK		((0x03))
-
-
-/** Macro defines for DMA Synchronization register */
-#define GPDMA_DMACSync_Src(n)			(((1UL&lt;&lt;n)&amp;0xFFFF))
-#define GPDMA_DMACSync_BITMASK			((0xFFFF))
-
-/**  Macro defines for DMA Request Select register */
-#define GPDMA_DMAReqSel_Input(n)		(((1UL&lt;&lt;(n-8))&amp;0xFF))
-#define GPDMA_DMAReqSel_BITMASK			((0xFF))
-
-/** DMA Channel Linked List Item registers bit mask*/
-#define GPDMA_DMACCxLLI_BITMASK 		((0xFFFFFFFC))
-
-/** DMA channel control registers bit description */
-#define GPDMA_DMACCxControl_TransferSize(n) (((n&amp;0xFFF)&lt;&lt;0)) 	/**&lt; Transfer size*/
-#define GPDMA_DMACCxControl_SBSize(n)		(((n&amp;0x07)&lt;&lt;12)) 	/**&lt; Source burst size*/
-#define GPDMA_DMACCxControl_DBSize(n)		(((n&amp;0x07)&lt;&lt;15)) 	/**&lt; Destination burst size*/
-#define GPDMA_DMACCxControl_SWidth(n)		(((n&amp;0x07)&lt;&lt;18)) 	/**&lt; Source transfer width*/
-#define GPDMA_DMACCxControl_DWidth(n)		(((n&amp;0x07)&lt;&lt;21)) 	/**&lt; Destination transfer width*/
-#define GPDMA_DMACCxControl_SI				((1UL&lt;&lt;26)) 		/**&lt; Source increment*/
-#define GPDMA_DMACCxControl_DI				((1UL&lt;&lt;27)) 		/**&lt; Destination increment*/
-#define GPDMA_DMACCxControl_Prot1			((1UL&lt;&lt;28)) 		/**&lt; Indicates that the access is in user mode or privileged mode*/
-#define GPDMA_DMACCxControl_Prot2			((1UL&lt;&lt;29)) 		/**&lt; Indicates that the access is bufferable or not bufferable*/
-#define GPDMA_DMACCxControl_Prot3			((1UL&lt;&lt;30)) 		/**&lt; Indicates that the access is cacheable or not cacheable*/
-#define GPDMA_DMACCxControl_I				((1UL&lt;&lt;31)) 		/**&lt; Terminal count interrupt enable bit */
-/** DMA channel control registers bit mask */
-#define GPDMA_DMACCxControl_BITMASK			((0xFCFFFFFF))
-
-
-/** DMA Channel Configuration registers bit description*/
-#define GPDMA_DMACCxConfig_E 					((1UL&lt;&lt;0))			/**&lt; DMA control enable*/
-#define GPDMA_DMACCxConfig_SrcPeripheral(n) 	(((n&amp;0x1F)&lt;&lt;1)) 	/**&lt; Source peripheral*/
-#define GPDMA_DMACCxConfig_DestPeripheral(n) 	(((n&amp;0x1F)&lt;&lt;6)) 	/**&lt; Destination peripheral*/
-#define GPDMA_DMACCxConfig_TransferType(n) 		(((n&amp;0x7)&lt;&lt;11)) 	/**&lt; This value indicates the type of transfer*/
-#define GPDMA_DMACCxConfig_IE 					((1UL&lt;&lt;14))			/**&lt; Interrupt error mask*/
-#define GPDMA_DMACCxConfig_ITC 					((1UL&lt;&lt;15)) 		/**&lt; Terminal count interrupt mask*/
-#define GPDMA_DMACCxConfig_L 					((1UL&lt;&lt;16)) 		/**&lt; Lock*/
-#define GPDMA_DMACCxConfig_A 					((1UL&lt;&lt;17)) 		/**&lt; Active*/
-#define GPDMA_DMACCxConfig_H 					((1UL&lt;&lt;18)) 		/**&lt; Halt*/
-/** DMA Channel Configuration registers bit mask */
-#define GPDMA_DMACCxConfig_BITMASK				((0x7FFFF))
-
-
-/**
- * @}
- */
-
-/**
- * @}
- */
-
-
-/* Public Types --------------------------------------------------------------- */
-/** @defgroup GPDMA_Public_Types
- * @{
- */
-
-
-/**
- * @brief GPDMA Channel configuration structure type definition
- */
-typedef struct {
-	uint32_t ChannelNum; 	/**&lt; DMA channel number, should be in
-								range from 0 to 7.
-								Note: DMA channel 0 has the highest priority
-								and DMA channel 7 the lowest priority.
-								*/
-	uint32_t TransferSize;	/**&lt; Length/Size of transfer */
-	uint32_t TransferWidth;	/**&lt; Transfer width - used for TransferType is GPDMA_TRANSFERTYPE_M2M only */
-	uint32_t SrcMemAddr;	/**&lt; Physical Source Address, used in case TransferType is chosen as
-								 GPDMA_TRANSFERTYPE_M2M or GPDMA_TRANSFERTYPE_M2P */
-	uint32_t DstMemAddr;	/**&lt; Physical Destination Address, used in case TransferType is chosen as
-								 GPDMA_TRANSFERTYPE_M2M or GPDMA_TRANSFERTYPE_P2M */
-	uint32_t TransferType;	/**&lt; Transfer Type, should be one of the following:
-							- GPDMA_TRANSFERTYPE_M2M: Memory to memory - DMA control
-							- GPDMA_TRANSFERTYPE_M2P: Memory to peripheral - DMA control
-							- GPDMA_TRANSFERTYPE_P2M: Peripheral to memory - DMA control
-							- GPDMA_TRANSFERTYPE_P2P: Source peripheral to destination peripheral - DMA control
-							*/
-	uint32_t SrcConn;		/**&lt; Peripheral Source Connection type, used in case TransferType is chosen as
-							GPDMA_TRANSFERTYPE_P2M or GPDMA_TRANSFERTYPE_P2P, should be one of
-							following:
-							 - GPDMA_CONN_SSP0_Tx: SSP0, Tx
-							 - GPDMA_CONN_SSP0_Rx: SSP0, Rx
-							 - GPDMA_CONN_SSP1_Tx: SSP1, Tx
-							 - GPDMA_CONN_SSP1_Rx: SSP1, Rx
-							 - GPDMA_CONN_ADC: ADC
-							 - GPDMA_CONN_I2S_Channel_0: I2S Channel 0
-							 - GPDMA_CONN_I2S_Channel_1: I2S Channel 1
-							 - GPDMA_CONN_DAC: DAC
-							 - GPDMA_CONN_UART0_Tx_MAT0_0: UART0 Tx / MAT0.0
-							 - GPDMA_CONN_UART0_Rx_MAT0_1: UART0 Rx / MAT0.1
-							 - GPDMA_CONN_UART1_Tx_MAT1_0: UART1 Tx / MAT1.0
-							 - GPDMA_CONN_UART1_Rx_MAT1_1: UART1 Rx / MAT1.1
-							 - GPDMA_CONN_UART2_Tx_MAT2_0: UART2 Tx / MAT2.0
-							 - GPDMA_CONN_UART2_Rx_MAT2_1: UART2 Rx / MAT2.1
-							 - GPDMA_CONN_UART3_Tx_MAT3_0: UART3 Tx / MAT3.0
-							 - GPDMA_CONN_UART3_Rx_MAT3_1: UART3 Rx / MAT3.1
-							 */
-	uint32_t DstConn;		/**&lt; Peripheral Destination Connection type, used in case TransferType is chosen as
-							GPDMA_TRANSFERTYPE_M2P or GPDMA_TRANSFERTYPE_P2P, should be one of
-							following:
-							 - GPDMA_CONN_SSP0_Tx: SSP0, Tx
-							 - GPDMA_CONN_SSP0_Rx: SSP0, Rx
-							 - GPDMA_CONN_SSP1_Tx: SSP1, Tx
-							 - GPDMA_CONN_SSP1_Rx: SSP1, Rx
-							 - GPDMA_CONN_ADC: ADC
-							 - GPDMA_CONN_I2S_Channel_0: I2S Channel 0
-							 - GPDMA_CONN_I2S_Channel_1: I2S Channel 1
-							 - GPDMA_CONN_DAC: DAC
-							 - GPDMA_CONN_UART0_Tx_MAT0_0: UART0 Tx / MAT0.0
-							 - GPDMA_CONN_UART0_Rx_MAT0_1: UART0 Rx / MAT0.1
-							 - GPDMA_CONN_UART1_Tx_MAT1_0: UART1 Tx / MAT1.0
-							 - GPDMA_CONN_UART1_Rx_MAT1_1: UART1 Rx / MAT1.1
-							 - GPDMA_CONN_UART2_Tx_MAT2_0: UART2 Tx / MAT2.0
-							 - GPDMA_CONN_UART2_Rx_MAT2_1: UART2 Rx / MAT2.1
-							 - GPDMA_CONN_UART3_Tx_MAT3_0: UART3 Tx / MAT3.0
-							 - GPDMA_CONN_UART3_Rx_MAT3_1: UART3 Rx / MAT3.1
-							 */
-	uint32_t DMALLI;		/**&lt; Linker List Item structure data address
-							if there's no Linker List, set as '0'
-							*/
-} GPDMA_Channel_CFG_Type;
-
-
-/**
- * @brief GPDMA Linker List Item structure type definition
- */
-typedef struct {
-	uint32_t SrcAddr;	/**&lt; Source Address */
-	uint32_t DstAddr;	/**&lt; Destination address */
-	uint32_t NextLLI;	/**&lt; Next LLI address, otherwise set to '0' */
-	uint32_t Control;	/**&lt; GPDMA Control of this LLI */
-} GPDMA_LLI_Type;
-
-
-/** GPDMA call-back function type definitions */
-typedef void (fnGPDMACbs_Type)(uint32_t channelStatus);
-
-
-/**
- * @}
- */
-
-
-/* Public Macros -------------------------------------------------------------- */
-/** @defgroup GPDMA_Public_Macros
- * @{
- */
-
-#define PARAM_GPDMA_CHANNEL(n)	((n&gt;=0) &amp;&amp; (n&lt;=7))
-
-/** DMA Connection number definitions */
-#define GPDMA_CONN_SSP0_Tx 			((0UL)) 		/**&lt; SSP0 Tx */
-#define GPDMA_CONN_SSP0_Rx 			((1UL)) 		/**&lt; SSP0 Rx */
-#define GPDMA_CONN_SSP1_Tx 			((2UL)) 		/**&lt; SSP1 Tx */
-#define GPDMA_CONN_SSP1_Rx 			((3UL)) 		/**&lt; SSP1 Rx */
-#define GPDMA_CONN_ADC 				((4UL)) 		/**&lt; ADC */
-#define GPDMA_CONN_I2S_Channel_0 	((5UL)) 		/**&lt; I2S channel 0 */
-#define GPDMA_CONN_I2S_Channel_1 	((6UL)) 		/**&lt; I2S channel 1 */
-#define GPDMA_CONN_DAC 				((7UL)) 		/**&lt; DAC */
-#define GPDMA_CONN_UART0_Tx			((8UL)) 		/**&lt; UART0 Tx */
-#define GPDMA_CONN_UART0_Rx			((9UL)) 		/**&lt; UART0 Rx */
-#define GPDMA_CONN_UART1_Tx			((10UL)) 		/**&lt; UART1 Tx */
-#define GPDMA_CONN_UART1_Rx			((11UL)) 		/**&lt; UART1 Rx */
-#define GPDMA_CONN_UART2_Tx			((12UL)) 		/**&lt; UART2 Tx */
-#define GPDMA_CONN_UART2_Rx			((13UL)) 		/**&lt; UART2 Rx */
-#define GPDMA_CONN_UART3_Tx			((14UL)) 		/**&lt; UART3 Tx */
-#define GPDMA_CONN_UART3_Rx			((15UL)) 		/**&lt; UART3 Rx */
-#define GPDMA_CONN_MAT0_0 			((16UL)) 		/**&lt; MAT0.0 */
-#define GPDMA_CONN_MAT0_1 			((17UL)) 		/**&lt; MAT0.1 */
-#define GPDMA_CONN_MAT1_0 			((18UL)) 		/**&lt; MAT1.0 */
-#define GPDMA_CONN_MAT1_1   		((19UL)) 		/**&lt; MAT1.1 */
-#define GPDMA_CONN_MAT2_0   		((20UL)) 		/**&lt; MAT2.0 */
-#define GPDMA_CONN_MAT2_1   		((21UL)) 		/**&lt; MAT2.1 */
-#define GPDMA_CONN_MAT3_0 			((22UL)) 		/**&lt; MAT3.0 */
-#define GPDMA_CONN_MAT3_1   		((23UL)) 		/**&lt; MAT3.1 */
-
-#define PARAM_GPDMA_CONN(n)		((n==GPDMA_CONN_SSP0_Tx) || (n==GPDMA_CONN_SSP0_Rx) \
-							|| (n==GPDMA_CONN_SSP1_Tx) || (n==GPDMA_CONN_SSP1_Rx) \
-							|| (n==GPDMA_CONN_ADC) || (n==GPDMA_CONN_I2S_Channel_0) \
-							|| (n==GPDMA_CONN_I2S_Channel_1) || (n==GPDMA_CONN_DAC) \
-							|| (n==GPDMA_CONN_UART0_Tx) || (n==GPDMA_CONN_UART0_Rx) \
-							|| (n==GPDMA_CONN_UART1_Tx) || (n==GPDMA_CONN_UART1_Rx) \
-							|| (n==GPDMA_CONN_UART2_Tx) || (n==GPDMA_CONN_UART2_Rx) \
-							|| (n==GPDMA_CONN_UART3_Tx) || (n==GPDMA_CONN_UART3_Rx) \
-							|| (n==GPDMA_CONN_MAT0_0) || (n==GPDMA_CONN_MAT0_1) \
-							|| (n==GPDMA_CONN_MAT1_0) || (n==GPDMA_CONN_MAT1_1) \
-							|| (n==GPDMA_CONN_MAT2_0) || (n==GPDMA_CONN_MAT2_1) \
-							|| (n==GPDMA_CONN_MAT3_0) || (n==GPDMA_CONN_MAT3_1))
-
-
-/** GPDMA Transfer type definitions */
-#define GPDMA_TRANSFERTYPE_M2M 		((0UL)) 	/**&lt; Memory to memory - DMA control */
-#define GPDMA_TRANSFERTYPE_M2P 		((1UL)) 	/**&lt; Memory to peripheral - DMA control */
-#define GPDMA_TRANSFERTYPE_P2M 		((2UL)) 	/**&lt; Peripheral to memory - DMA control */
-#define GPDMA_TRANSFERTYPE_P2P 		((3UL)) 	/**&lt; Source peripheral to destination peripheral - DMA control */
-
-
-#define PARAM_GPDMA_TRANSFERTYPE(n) ((n==GPDMA_TRANSFERTYPE_M2M) || (n==GPDMA_TRANSFERTYPE_M2P) \
-							|| (n==GPDMA_TRANSFERTYPE_P2M) || (n==GPDMA_TRANSFERTYPE_P2P))
-
-
-/** Burst size in Source and Destination definitions */
-#define GPDMA_BSIZE_1 	((0UL)) /**&lt; Burst size = 1 */
-#define GPDMA_BSIZE_4 	((1UL)) /**&lt; Burst size = 4 */
-#define GPDMA_BSIZE_8 	((2UL)) /**&lt; Burst size = 8 */
-#define GPDMA_BSIZE_16 	((3UL)) /**&lt; Burst size = 16 */
-#define GPDMA_BSIZE_32 	((4UL)) /**&lt; Burst size = 32 */
-#define GPDMA_BSIZE_64 	((5UL)) /**&lt; Burst size = 64 */
-#define GPDMA_BSIZE_128 ((6UL)) /**&lt; Burst size = 128 */
-#define GPDMA_BSIZE_256 ((7UL)) /**&lt; Burst size = 256 */
-
-#define PARAM_GPDMA_BSIZE(n)	((n==GPDMA_BSIZE_1) || (n==GPDMA_BSIZE_4) \
-							|| (n==GPDMA_BSIZE_8) || (n==GPDMA_BSIZE_16) \
-							|| (n==GPDMA_BSIZE_32) || (n==GPDMA_BSIZE_64) \
-							|| (n==GPDMA_BSIZE_128) || (n==GPDMA_BSIZE_256))
-
-
-/** Width in Source transfer width and Destination transfer width definitions */
-#define GPDMA_WIDTH_BYTE 		((0UL)) /**&lt; Width = 1 byte */
-#define GPDMA_WIDTH_HALFWORD 	((1UL)) /**&lt; Width = 2 bytes */
-#define GPDMA_WIDTH_WORD 		((2UL)) /**&lt; Width = 4 bytes */
-
-#define PARAM_GPDMA_WIDTH(n) ((n==GPDMA_WIDTH_BYTE) || (n==GPDMA_WIDTH_HALFWORD) \
-							|| (n==GPDMA_WIDTH_WORD))
-
-
-/** DMA Request Select Mode definitions */
-#define GPDMA_REQSEL_UART 	((0UL)) /**&lt; UART TX/RX is selected */
-#define GPDMA_REQSEL_TIMER 	((1UL)) /**&lt; Timer match is selected */
-
-#define PARAM_GPDMA_REQSEL(n)	((n==GPDMA_REQSEL_UART) || (n==GPDMA_REQSEL_TIMER))
-
-/** GPDMA Status type definitions */
-/** GPDMA Interrupt Status */
-#define GPDMA_STAT_INT			((0UL))
-/** GPDMA Interrupt Terminal Count Request Status */
-#define GPDMA_STAT_INTTC		((1UL))
-/** GPDMA Interrupt Error Status */
-#define GPDMA_STAT_INTERR		((2UL))
-/** GPDMA Raw Interrupt Terminal Count Status */
-#define GPDMA_STAT_RAWINTTC		((3UL))
-/** GPDMA Raw Error Interrupt Status */
-#define GPDMA_STAT_RAWINTERR	((4UL))
-/** DMA Enabled Channel Status */
-#define GPDMA_STAT_ENABLED_CH	((5UL))
-
-#define PARAM_GPDMA_STAT(n)	((n==GPDMA_STAT_INT) || (n==GPDMA_STAT_INTTC) \
-						|| (n==GPDMA_STAT_INTERR) || (n==GPDMA_STAT_RAWINTTC) \
-						|| (n==GPDMA_STAT_RAWINTERR) || (n==GPDMA_STAT_ENABLED_CH))
-
-/** GPDMA status type definition that can be clear */
-/** GPDMA Interrupt Terminal Count Request Clear */
-#define GPDMA_STATCLR_INTTC		((0UL))
-/** GPDMA Interrupt Error Clear */
-#define GPDMA_STATCLR_INTERR	((1UL))
-
-#define GPDMA_STATCLR(n)	((n==GPDMA_STATCLR_INTTC) || (n==GPDMA_STATCLR_INTERR))
-
-/**
- * @}
- */
-
-
-/* Public Functions ----------------------------------------------------------- */
-/** @defgroup GPDMA_Public_Functions
- * @{
- */
-
-void GPDMA_Init(void);
-Status GPDMA_Setup(GPDMA_Channel_CFG_Type *GPDMAChannelConfig, fnGPDMACbs_Type *pfnGPDMACbs);
-void GPDMA_ChannelCmd(uint8_t channelNum, FunctionalState NewState);
-void GPDMA_IntHandler(void);
-
-/**
- * @}
- */
-
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* LPC17XX_GPDMA_H_ */
-
-/**
- * @}
- */
-
-/* --------------------------------- End Of File ------------------------------ */
+/***********************************************************************//**
+ * @file	: lpc17xx_gpdma.h
+ * @brief	: Contains all macro definitions and function prototypes
+ * 				support for GPDMA firmware library on LPC17xx
+ * @version	: 1.0
+ * @date	: 20. Apr. 2009
+ * @author	: HieuNguyen
+ **************************************************************************
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * products. This software is supplied &quot;AS IS&quot; without any warranties.
+ * NXP Semiconductors assumes no responsibility or liability for the
+ * use of the software, conveys no license or title under any patent,
+ * copyright, or mask work right to the product. NXP Semiconductors
+ * reserves the right to make changes in the software without
+ * notification. NXP Semiconductors also make no representation or
+ * warranty that such application will be suitable for the specified
+ * use without further testing or modification.
+ **************************************************************************/
+
+/* Peripheral group ----------------------------------------------------------- */
+/** @defgroup GPDMA
+ * @ingroup LPC1700CMSIS_FwLib_Drivers
+ * @{
+ */
+
+#ifndef LPC17XX_GPDMA_H_
+#define LPC17XX_GPDMA_H_
+
+/* Includes ------------------------------------------------------------------- */
+#include &quot;LPC17xx.h&quot;
+#include &quot;lpc_types.h&quot;
+
+
+#ifdef __cplusplus
+extern &quot;C&quot;
+{
+#endif
+
+
+/* Private Macros ------------------------------------------------------------- */
+/** @defgroup GPDMA_Private_Macros
+ * @{
+ */
+
+/** @defgroup DMA_REGISTER_BIT_DEFINITIONS
+ * @{
+ */
+
+/** Macros define for DMA interrupt */
+/** DMA Interrupt Status register */
+#define GPDMA_DMACIntStat_Ch(n)			(((1UL&lt;&lt;n)&amp;0xFF))
+#define GPDMA_DMACIntStat_BITMASK		((0xFF))
+
+/** DMA Interrupt Terminal Count Request Status register */
+#define GPDMA_DMACIntTCStat_Ch(n)		(((1UL&lt;&lt;n)&amp;0xFF))
+#define GPDMA_DMACIntTCStat_BITMASK		((0xFF))
+
+/** DMA Interrupt Terminal Count Request Clear register */
+#define GPDMA_DMACIntTCClear_Ch(n)		(((1UL&lt;&lt;n)&amp;0xFF))
+#define GPDMA_DMACIntTCClear_BITMASK	((0xFF))
+
+/** DMA Interrupt Error Status register */
+#define GPDMA_DMACIntErrStat_Ch(n)		(((1UL&lt;&lt;n)&amp;0xFF))
+#define GPDMA_DMACIntErrStat_BITMASK	((0xFF))
+
+/** DMA Interrupt Error Clear register */
+#define GPDMA_DMACIntErrClr_Ch(n)		(((1UL&lt;&lt;n)&amp;0xFF))
+#define GPDMA_DMACIntErrClr_BITMASK		((0xFF))
+
+/** DMA Raw Interrupt Terminal Count Status register */
+#define GPDMA_DMACRawIntTCStat_Ch(n)	(((1UL&lt;&lt;n)&amp;0xFF))
+#define GPDMA_DMACRawIntTCStat_BITMASK	((0xFF))
+
+/** DMA Raw Error Interrupt Status register */
+#define GPDMA_DMACRawIntErrStat_Ch(n)	(((1UL&lt;&lt;n)&amp;0xFF))
+#define GPDMA_DMACRawIntErrStat_BITMASK	((0xFF))
+
+/** DMA Enabled Channel register */
+#define GPDMA_DMACEnbldChns_Ch(n)		(((1UL&lt;&lt;n)&amp;0xFF))
+#define GPDMA_DMACEnbldChns_BITMASK		((0xFF))
+
+
+/** Macro defines for DMA Software Burst Request register */
+#define	GPDMA_DMACSoftBReq_Src(n)		(((1UL&lt;&lt;n)&amp;0xFFFF))
+#define GPDMA_DMACSoftBReq_BITMASK		((0xFFFF))
+
+/** Macro defines for DMA Software Single Request register */
+#define GPDMA_DMACSoftSReq_Src(n) 		(((1UL&lt;&lt;n)&amp;0xFFFF))
+#define GPDMA_DMACSoftSReq_BITMASK		((0xFFFF))
+
+/** Macro defines for DMA Software Last Burst Request register */
+#define GPDMA_DMACSoftLBReq_Src(n)		(((1UL&lt;&lt;n)&amp;0xFFFF))
+#define GPDMA_DMACSoftLBReq_BITMASK		((0xFFFF))
+
+/** Macro defines for DMA Software Last Single Request register */
+#define GPDMA_DMACSoftLSReq_Src(n) 		(((1UL&lt;&lt;n)&amp;0xFFFF))
+#define GPDMA_DMACSoftLSReq_BITMASK		((0xFFFF))
+
+/** DMA Configuration register bit description*/
+#define GPDMA_DMACConfig_E				((0x01))	 /**&lt; DMA Controller enable*/
+#define GPDMA_DMACConfig_M				((0x02))	 /**&lt; AHB Master endianness configuration*/
+#define GPDMA_DMACConfig_BITMASK		((0x03))
+
+
+/** Macro defines for DMA Synchronization register */
+#define GPDMA_DMACSync_Src(n)			(((1UL&lt;&lt;n)&amp;0xFFFF))
+#define GPDMA_DMACSync_BITMASK			((0xFFFF))
+
+/**  Macro defines for DMA Request Select register */
+#define GPDMA_DMAReqSel_Input(n)		(((1UL&lt;&lt;(n-8))&amp;0xFF))
+#define GPDMA_DMAReqSel_BITMASK			((0xFF))
+
+/** DMA Channel Linked List Item registers bit mask*/
+#define GPDMA_DMACCxLLI_BITMASK 		((0xFFFFFFFC))
+
+/** DMA channel control registers bit description */
+#define GPDMA_DMACCxControl_TransferSize(n) (((n&amp;0xFFF)&lt;&lt;0)) 	/**&lt; Transfer size*/
+#define GPDMA_DMACCxControl_SBSize(n)		(((n&amp;0x07)&lt;&lt;12)) 	/**&lt; Source burst size*/
+#define GPDMA_DMACCxControl_DBSize(n)		(((n&amp;0x07)&lt;&lt;15)) 	/**&lt; Destination burst size*/
+#define GPDMA_DMACCxControl_SWidth(n)		(((n&amp;0x07)&lt;&lt;18)) 	/**&lt; Source transfer width*/
+#define GPDMA_DMACCxControl_DWidth(n)		(((n&amp;0x07)&lt;&lt;21)) 	/**&lt; Destination transfer width*/
+#define GPDMA_DMACCxControl_SI				((1UL&lt;&lt;26)) 		/**&lt; Source increment*/
+#define GPDMA_DMACCxControl_DI				((1UL&lt;&lt;27)) 		/**&lt; Destination increment*/
+#define GPDMA_DMACCxControl_Prot1			((1UL&lt;&lt;28)) 		/**&lt; Indicates that the access is in user mode or privileged mode*/
+#define GPDMA_DMACCxControl_Prot2			((1UL&lt;&lt;29)) 		/**&lt; Indicates that the access is bufferable or not bufferable*/
+#define GPDMA_DMACCxControl_Prot3			((1UL&lt;&lt;30)) 		/**&lt; Indicates that the access is cacheable or not cacheable*/
+#define GPDMA_DMACCxControl_I				((1UL&lt;&lt;31)) 		/**&lt; Terminal count interrupt enable bit */
+/** DMA channel control registers bit mask */
+#define GPDMA_DMACCxControl_BITMASK			((0xFCFFFFFF))
+
+
+/** DMA Channel Configuration registers bit description*/
+#define GPDMA_DMACCxConfig_E 					((1UL&lt;&lt;0))			/**&lt; DMA control enable*/
+#define GPDMA_DMACCxConfig_SrcPeripheral(n) 	(((n&amp;0x1F)&lt;&lt;1)) 	/**&lt; Source peripheral*/
+#define GPDMA_DMACCxConfig_DestPeripheral(n) 	(((n&amp;0x1F)&lt;&lt;6)) 	/**&lt; Destination peripheral*/
+#define GPDMA_DMACCxConfig_TransferType(n) 		(((n&amp;0x7)&lt;&lt;11)) 	/**&lt; This value indicates the type of transfer*/
+#define GPDMA_DMACCxConfig_IE 					((1UL&lt;&lt;14))			/**&lt; Interrupt error mask*/
+#define GPDMA_DMACCxConfig_ITC 					((1UL&lt;&lt;15)) 		/**&lt; Terminal count interrupt mask*/
+#define GPDMA_DMACCxConfig_L 					((1UL&lt;&lt;16)) 		/**&lt; Lock*/
+#define GPDMA_DMACCxConfig_A 					((1UL&lt;&lt;17)) 		/**&lt; Active*/
+#define GPDMA_DMACCxConfig_H 					((1UL&lt;&lt;18)) 		/**&lt; Halt*/
+/** DMA Channel Configuration registers bit mask */
+#define GPDMA_DMACCxConfig_BITMASK				((0x7FFFF))
+
+
+/**
+ * @}
+ */
+
+/**
+ * @}
+ */
+
+
+/* Public Types --------------------------------------------------------------- */
+/** @defgroup GPDMA_Public_Types
+ * @{
+ */
+
+
+/**
+ * @brief GPDMA Channel configuration structure type definition
+ */
+typedef struct {
+	uint32_t ChannelNum; 	/**&lt; DMA channel number, should be in
+								range from 0 to 7.
+								Note: DMA channel 0 has the highest priority
+								and DMA channel 7 the lowest priority.
+								*/
+	uint32_t TransferSize;	/**&lt; Length/Size of transfer */
+	uint32_t TransferWidth;	/**&lt; Transfer width - used for TransferType is GPDMA_TRANSFERTYPE_M2M only */
+	uint32_t SrcMemAddr;	/**&lt; Physical Source Address, used in case TransferType is chosen as
+								 GPDMA_TRANSFERTYPE_M2M or GPDMA_TRANSFERTYPE_M2P */
+	uint32_t DstMemAddr;	/**&lt; Physical Destination Address, used in case TransferType is chosen as
+								 GPDMA_TRANSFERTYPE_M2M or GPDMA_TRANSFERTYPE_P2M */
+	uint32_t TransferType;	/**&lt; Transfer Type, should be one of the following:
+							- GPDMA_TRANSFERTYPE_M2M: Memory to memory - DMA control
+							- GPDMA_TRANSFERTYPE_M2P: Memory to peripheral - DMA control
+							- GPDMA_TRANSFERTYPE_P2M: Peripheral to memory - DMA control
+							- GPDMA_TRANSFERTYPE_P2P: Source peripheral to destination peripheral - DMA control
+							*/
+	uint32_t SrcConn;		/**&lt; Peripheral Source Connection type, used in case TransferType is chosen as
+							GPDMA_TRANSFERTYPE_P2M or GPDMA_TRANSFERTYPE_P2P, should be one of
+							following:
+							 - GPDMA_CONN_SSP0_Tx: SSP0, Tx
+							 - GPDMA_CONN_SSP0_Rx: SSP0, Rx
+							 - GPDMA_CONN_SSP1_Tx: SSP1, Tx
+							 - GPDMA_CONN_SSP1_Rx: SSP1, Rx
+							 - GPDMA_CONN_ADC: ADC
+							 - GPDMA_CONN_I2S_Channel_0: I2S Channel 0
+							 - GPDMA_CONN_I2S_Channel_1: I2S Channel 1
+							 - GPDMA_CONN_DAC: DAC
+							 - GPDMA_CONN_UART0_Tx_MAT0_0: UART0 Tx / MAT0.0
+							 - GPDMA_CONN_UART0_Rx_MAT0_1: UART0 Rx / MAT0.1
+							 - GPDMA_CONN_UART1_Tx_MAT1_0: UART1 Tx / MAT1.0
+							 - GPDMA_CONN_UART1_Rx_MAT1_1: UART1 Rx / MAT1.1
+							 - GPDMA_CONN_UART2_Tx_MAT2_0: UART2 Tx / MAT2.0
+							 - GPDMA_CONN_UART2_Rx_MAT2_1: UART2 Rx / MAT2.1
+							 - GPDMA_CONN_UART3_Tx_MAT3_0: UART3 Tx / MAT3.0
+							 - GPDMA_CONN_UART3_Rx_MAT3_1: UART3 Rx / MAT3.1
+							 */
+	uint32_t DstConn;		/**&lt; Peripheral Destination Connection type, used in case TransferType is chosen as
+							GPDMA_TRANSFERTYPE_M2P or GPDMA_TRANSFERTYPE_P2P, should be one of
+							following:
+							 - GPDMA_CONN_SSP0_Tx: SSP0, Tx
+							 - GPDMA_CONN_SSP0_Rx: SSP0, Rx
+							 - GPDMA_CONN_SSP1_Tx: SSP1, Tx
+							 - GPDMA_CONN_SSP1_Rx: SSP1, Rx
+							 - GPDMA_CONN_ADC: ADC
+							 - GPDMA_CONN_I2S_Channel_0: I2S Channel 0
+							 - GPDMA_CONN_I2S_Channel_1: I2S Channel 1
+							 - GPDMA_CONN_DAC: DAC
+							 - GPDMA_CONN_UART0_Tx_MAT0_0: UART0 Tx / MAT0.0
+							 - GPDMA_CONN_UART0_Rx_MAT0_1: UART0 Rx / MAT0.1
+							 - GPDMA_CONN_UART1_Tx_MAT1_0: UART1 Tx / MAT1.0
+							 - GPDMA_CONN_UART1_Rx_MAT1_1: UART1 Rx / MAT1.1
+							 - GPDMA_CONN_UART2_Tx_MAT2_0: UART2 Tx / MAT2.0
+							 - GPDMA_CONN_UART2_Rx_MAT2_1: UART2 Rx / MAT2.1
+							 - GPDMA_CONN_UART3_Tx_MAT3_0: UART3 Tx / MAT3.0
+							 - GPDMA_CONN_UART3_Rx_MAT3_1: UART3 Rx / MAT3.1
+							 */
+	uint32_t DMALLI;		/**&lt; Linker List Item structure data address
+							if there's no Linker List, set as '0'
+							*/
+} GPDMA_Channel_CFG_Type;
+
+
+/**
+ * @brief GPDMA Linker List Item structure type definition
+ */
+typedef struct {
+	uint32_t SrcAddr;	/**&lt; Source Address */
+	uint32_t DstAddr;	/**&lt; Destination address */
+	uint32_t NextLLI;	/**&lt; Next LLI address, otherwise set to '0' */
+	uint32_t Control;	/**&lt; GPDMA Control of this LLI */
+} GPDMA_LLI_Type;
+
+
+/** GPDMA call-back function type definitions */
+typedef void (fnGPDMACbs_Type)(uint32_t channelStatus);
+
+
+/**
+ * @}
+ */
+
+
+/* Public Macros -------------------------------------------------------------- */
+/** @defgroup GPDMA_Public_Macros
+ * @{
+ */
+
+#define PARAM_GPDMA_CHANNEL(n)	((n&gt;=0) &amp;&amp; (n&lt;=7))
+
+/** DMA Connection number definitions */
+#define GPDMA_CONN_SSP0_Tx 			((0UL)) 		/**&lt; SSP0 Tx */
+#define GPDMA_CONN_SSP0_Rx 			((1UL)) 		/**&lt; SSP0 Rx */
+#define GPDMA_CONN_SSP1_Tx 			((2UL)) 		/**&lt; SSP1 Tx */
+#define GPDMA_CONN_SSP1_Rx 			((3UL)) 		/**&lt; SSP1 Rx */
+#define GPDMA_CONN_ADC 				((4UL)) 		/**&lt; ADC */
+#define GPDMA_CONN_I2S_Channel_0 	((5UL)) 		/**&lt; I2S channel 0 */
+#define GPDMA_CONN_I2S_Channel_1 	((6UL)) 		/**&lt; I2S channel 1 */
+#define GPDMA_CONN_DAC 				((7UL)) 		/**&lt; DAC */
+#define GPDMA_CONN_UART0_Tx			((8UL)) 		/**&lt; UART0 Tx */
+#define GPDMA_CONN_UART0_Rx			((9UL)) 		/**&lt; UART0 Rx */
+#define GPDMA_CONN_UART1_Tx			((10UL)) 		/**&lt; UART1 Tx */
+#define GPDMA_CONN_UART1_Rx			((11UL)) 		/**&lt; UART1 Rx */
+#define GPDMA_CONN_UART2_Tx			((12UL)) 		/**&lt; UART2 Tx */
+#define GPDMA_CONN_UART2_Rx			((13UL)) 		/**&lt; UART2 Rx */
+#define GPDMA_CONN_UART3_Tx			((14UL)) 		/**&lt; UART3 Tx */
+#define GPDMA_CONN_UART3_Rx			((15UL)) 		/**&lt; UART3 Rx */
+#define GPDMA_CONN_MAT0_0 			((16UL)) 		/**&lt; MAT0.0 */
+#define GPDMA_CONN_MAT0_1 			((17UL)) 		/**&lt; MAT0.1 */
+#define GPDMA_CONN_MAT1_0 			((18UL)) 		/**&lt; MAT1.0 */
+#define GPDMA_CONN_MAT1_1   		((19UL)) 		/**&lt; MAT1.1 */
+#define GPDMA_CONN_MAT2_0   		((20UL)) 		/**&lt; MAT2.0 */
+#define GPDMA_CONN_MAT2_1   		((21UL)) 		/**&lt; MAT2.1 */
+#define GPDMA_CONN_MAT3_0 			((22UL)) 		/**&lt; MAT3.0 */
+#define GPDMA_CONN_MAT3_1   		((23UL)) 		/**&lt; MAT3.1 */
+
+#define PARAM_GPDMA_CONN(n)		((n==GPDMA_CONN_SSP0_Tx) || (n==GPDMA_CONN_SSP0_Rx) \
+|| (n==GPDMA_CONN_SSP1_Tx) || (n==GPDMA_CONN_SSP1_Rx) \
+|| (n==GPDMA_CONN_ADC) || (n==GPDMA_CONN_I2S_Channel_0) \
+|| (n==GPDMA_CONN_I2S_Channel_1) || (n==GPDMA_CONN_DAC) \
+|| (n==GPDMA_CONN_UART0_Tx) || (n==GPDMA_CONN_UART0_Rx) \
+|| (n==GPDMA_CONN_UART1_Tx) || (n==GPDMA_CONN_UART1_Rx) \
+|| (n==GPDMA_CONN_UART2_Tx) || (n==GPDMA_CONN_UART2_Rx) \
+|| (n==GPDMA_CONN_UART3_Tx) || (n==GPDMA_CONN_UART3_Rx) \
+|| (n==GPDMA_CONN_MAT0_0) || (n==GPDMA_CONN_MAT0_1) \
+|| (n==GPDMA_CONN_MAT1_0) || (n==GPDMA_CONN_MAT1_1) \
+|| (n==GPDMA_CONN_MAT2_0) || (n==GPDMA_CONN_MAT2_1) \
+|| (n==GPDMA_CONN_MAT3_0) || (n==GPDMA_CONN_MAT3_1))
+
+
+/** GPDMA Transfer type definitions */
+#define GPDMA_TRANSFERTYPE_M2M 		((0UL)) 	/**&lt; Memory to memory - DMA control */
+#define GPDMA_TRANSFERTYPE_M2P 		((1UL)) 	/**&lt; Memory to peripheral - DMA control */
+#define GPDMA_TRANSFERTYPE_P2M 		((2UL)) 	/**&lt; Peripheral to memory - DMA control */
+#define GPDMA_TRANSFERTYPE_P2P 		((3UL)) 	/**&lt; Source peripheral to destination peripheral - DMA control */
+
+
+#define PARAM_GPDMA_TRANSFERTYPE(n) ((n==GPDMA_TRANSFERTYPE_M2M)||(n==GPDMA_TRANSFERTYPE_M2P) \
+||(n==GPDMA_TRANSFERTYPE_P2M)||(n==GPDMA_TRANSFERTYPE_P2P))
+
+
+/** Burst size in Source and Destination definitions */
+#define GPDMA_BSIZE_1 	((0UL)) /**&lt; Burst size = 1 */
+#define GPDMA_BSIZE_4 	((1UL)) /**&lt; Burst size = 4 */
+#define GPDMA_BSIZE_8 	((2UL)) /**&lt; Burst size = 8 */
+#define GPDMA_BSIZE_16 	((3UL)) /**&lt; Burst size = 16 */
+#define GPDMA_BSIZE_32 	((4UL)) /**&lt; Burst size = 32 */
+#define GPDMA_BSIZE_64 	((5UL)) /**&lt; Burst size = 64 */
+#define GPDMA_BSIZE_128 ((6UL)) /**&lt; Burst size = 128 */
+#define GPDMA_BSIZE_256 ((7UL)) /**&lt; Burst size = 256 */
+
+#define PARAM_GPDMA_BSIZE(n)	((n==GPDMA_BSIZE_1) || (n==GPDMA_BSIZE_4) \
+|| (n==GPDMA_BSIZE_8) || (n==GPDMA_BSIZE_16) \
+|| (n==GPDMA_BSIZE_32) || (n==GPDMA_BSIZE_64) \
+|| (n==GPDMA_BSIZE_128) || (n==GPDMA_BSIZE_256))
+
+
+/** Width in Source transfer width and Destination transfer width definitions */
+#define GPDMA_WIDTH_BYTE 		((0UL)) /**&lt; Width = 1 byte */
+#define GPDMA_WIDTH_HALFWORD 	((1UL)) /**&lt; Width = 2 bytes */
+#define GPDMA_WIDTH_WORD 		((2UL)) /**&lt; Width = 4 bytes */
+
+#define PARAM_GPDMA_WIDTH(n) ((n==GPDMA_WIDTH_BYTE) || (n==GPDMA_WIDTH_HALFWORD) \
+|| (n==GPDMA_WIDTH_WORD))
+
+
+/** DMA Request Select Mode definitions */
+#define GPDMA_REQSEL_UART 	((0UL)) /**&lt; UART TX/RX is selected */
+#define GPDMA_REQSEL_TIMER 	((1UL)) /**&lt; Timer match is selected */
+
+#define PARAM_GPDMA_REQSEL(n)	((n==GPDMA_REQSEL_UART) || (n==GPDMA_REQSEL_TIMER))
+
+/** GPDMA Status type definitions */
+/** GPDMA Interrupt Status */
+#define GPDMA_STAT_INT			((0UL))
+/** GPDMA Interrupt Terminal Count Request Status */
+#define GPDMA_STAT_INTTC		((1UL))
+/** GPDMA Interrupt Error Status */
+#define GPDMA_STAT_INTERR		((2UL))
+/** GPDMA Raw Interrupt Terminal Count Status */
+#define GPDMA_STAT_RAWINTTC		((3UL))
+/** GPDMA Raw Error Interrupt Status */
+#define GPDMA_STAT_RAWINTERR	((4UL))
+/** DMA Enabled Channel Status */
+#define GPDMA_STAT_ENABLED_CH	((5UL))
+
+#define PARAM_GPDMA_STAT(n)	((n==GPDMA_STAT_INT) || (n==GPDMA_STAT_INTTC) \
+|| (n==GPDMA_STAT_INTERR) || (n==GPDMA_STAT_RAWINTTC) \
+|| (n==GPDMA_STAT_RAWINTERR) || (n==GPDMA_STAT_ENABLED_CH))
+
+/** GPDMA status type definition that can be clear */
+/** GPDMA Interrupt Terminal Count Request Clear */
+#define GPDMA_STATCLR_INTTC		((0UL))
+/** GPDMA Interrupt Error Clear */
+#define GPDMA_STATCLR_INTERR	((1UL))
+
+#define GPDMA_STATCLR(n)	((n==GPDMA_STATCLR_INTTC) || (n==GPDMA_STATCLR_INTERR))
+
+/**
+ * @}
+ */
+
+
+/* Public Functions ----------------------------------------------------------- */
+/** @defgroup GPDMA_Public_Functions
+ * @{
+ */
+
+void GPDMA_Init(void);
+Status GPDMA_Setup(GPDMA_Channel_CFG_Type *GPDMAChannelConfig, fnGPDMACbs_Type *pfnGPDMACbs);
+void GPDMA_ChannelCmd(uint8_t channelNum, FunctionalState NewState);
+void GPDMA_IntHandler(void);
+
+/**
+ * @}
+ */
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LPC17XX_GPDMA_H_ */
+
+/**
+ * @}
+ */
+
+/* --------------------------------- End Of File ------------------------------ */


Property changes on: trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_gpdma.h
___________________________________________________________________
Deleted: svn:executable
   - *

Modified: trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_gpio.h
===================================================================
--- trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_gpio.h	2010-06-28 21:53:59 UTC (rev 759)
+++ trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_gpio.h	2010-07-12 20:56:54 UTC (rev 760)
@@ -1,166 +1,166 @@
-/***********************************************************************//**
- * @file	: lpc17xx_gpio.h
- * @brief	: Contains all macro definitions and function prototypes
- * 				support for GPIO firmware library on LPC17xx
- * @version	: 1.0
- * @date	: 23. Apr. 2009
- * @author	: HieuNguyen
- **************************************************************************
- * Software that is described herein is for illustrative purposes only
- * which provides customers with programming information regarding the
- * products. This software is supplied &quot;AS IS&quot; without any warranties.
- * NXP Semiconductors assumes no responsibility or liability for the
- * use of the software, conveys no license or title under any patent,
- * copyright, or mask work right to the product. NXP Semiconductors
- * reserves the right to make changes in the software without
- * notification. NXP Semiconductors also make no representation or
- * warranty that such application will be suitable for the specified
- * use without further testing or modification.
- **************************************************************************/
-
-/* Peripheral group ----------------------------------------------------------- */
-/** @defgroup GPIO
- * @ingroup LPC1700CMSIS_FwLib_Drivers
- * @{
- */
-
-#ifndef LPC17XX_GPIO_H_
-#define LPC17XX_GPIO_H_
-
-/* Includes ------------------------------------------------------------------- */
-#include &quot;LPC17xx.h&quot;
-#include &quot;lpc_types.h&quot;
-
-
-#ifdef __cplusplus
-extern &quot;C&quot;
-{
-#endif
-
-
-/* Public Types --------------------------------------------------------------- */
-/** @defgroup GPIO_Public_Types
- * @{
- */
-
-/**
- * @brief Fast GPIO port byte type definition
- */
-typedef struct {
-	__IO uint8_t FIODIR[4];		/**&lt; FIO direction register in byte-align */
-	   uint32_t RESERVED0[3];	/**&lt; Reserved */
-	__IO uint8_t FIOMASK[4];	/**&lt; FIO mask register in byte-align */
-	__IO uint8_t FIOPIN[4];		/**&lt; FIO pin register in byte align */
-	__IO uint8_t FIOSET[4];		/**&lt; FIO set register in byte-align */
-	__O  uint8_t FIOCLR[4];		/**&lt; FIO clear register in byte-align */
-} GPIO_Byte_TypeDef;
-
-
-/**
- * @brief Fast GPIO port half-word type definition
- */
-typedef struct {
-	__IO uint16_t FIODIRL;		/**&lt; FIO direction register lower halfword part */
-	__IO uint16_t FIODIRU;		/**&lt; FIO direction register upper halfword part */
-	   uint32_t RESERVED0[3];	/**&lt; Reserved */
-	__IO uint16_t FIOMASKL;		/**&lt; FIO mask register lower halfword part */
-	__IO uint16_t FIOMASKU;		/**&lt; FIO mask register upper halfword part */
-	__IO uint16_t FIOPINL;		/**&lt; FIO pin register lower halfword part */
-	__IO uint16_t FIOPINU;		/**&lt; FIO pin register upper halfword part */
-	__IO uint16_t FIOSETL;		/**&lt; FIO set register lower halfword part */
-	__IO uint16_t FIOSETU;		/**&lt; FIO set register upper halfword part */
-	__O  uint16_t FIOCLRL;		/**&lt; FIO clear register lower halfword part */
-	__O  uint16_t FIOCLRU;		/**&lt; FIO clear register upper halfword part */
-} GPIO_HalfWord_TypeDef;
-
-
-/**
- * @}
- */
-
-
-/* Public Macros -------------------------------------------------------------- */
-/** @defgroup GPIO_Public_Macros
- * @{
- */
-
-/** Fast GPIO port 0 byte accessible definition */
-#define GPIO0_Byte	((GPIO_Byte_TypeDef *)(GPIO0_BASE))
-/** Fast GPIO port 1 byte accessible definition */
-#define GPIO1_Byte	((GPIO_Byte_TypeDef *)(GPIO1_BASE))
-/** Fast GPIO port 2 byte accessible definition */
-#define GPIO2_Byte	((GPIO_Byte_TypeDef *)(GPIO2_BASE))
-/** Fast GPIO port 3 byte accessible definition */
-#define GPIO3_Byte	((GPIO_Byte_TypeDef *)(GPIO3_BASE))
-/** Fast GPIO port 4 byte accessible definition */
-#define GPIO4_Byte	((GPIO_Byte_TypeDef *)(GPIO4_BASE))
-
-
-
-/** Fast GPIO port 0 half-word accessible definition */
-#define GPIO0_HalfWord	((GPIO_HalfWord_TypeDef *)(GPIO0_BASE))
-/** Fast GPIO port 1 half-word accessible definition */
-#define GPIO1_HalfWord	((GPIO_HalfWord_TypeDef *)(GPIO1_BASE))
-/** Fast GPIO port 2 half-word accessible definition */
-#define GPIO2_HalfWord	((GPIO_HalfWord_TypeDef *)(GPIO2_BASE))
-/** Fast GPIO port 3 half-word accessible definition */
-#define GPIO3_HalfWord	((GPIO_HalfWord_TypeDef *)(GPIO3_BASE))
-/** Fast GPIO port 4 half-word accessible definition */
-#define GPIO4_HalfWord	((GPIO_HalfWord_TypeDef *)(GPIO4_BASE))
-
-
-/**
- * @}
- */
-
-
-/* Public Functions ----------------------------------------------------------- */
-/** @defgroup GPIO_Public_Functions
- * @{
- */
-
-/* GPIO style ------------------------------- */
-void GPIO_SetDir(uint8_t portNum, uint32_t bitValue, uint8_t dir);
-void GPIO_SetValue(uint8_t portNum, uint32_t bitValue);
-void GPIO_ClearValue(uint8_t portNum, uint32_t bitValue);
-uint32_t GPIO_ReadValue(uint8_t portNum);
-
-/* FIO (word-accessible) style ------------------------------- */
-void FIO_SetDir(uint8_t portNum, uint32_t bitValue, uint8_t dir);
-void FIO_SetValue(uint8_t portNum, uint32_t bitValue);
-void FIO_ClearValue(uint8_t portNum, uint32_t bitValue);
-uint32_t FIO_ReadValue(uint8_t portNum);
-void FIO_SetMask(uint8_t portNum, uint32_t bitValue, uint8_t maskValue);
-
-/* FIO (halfword-accessible) style ------------------------------- */
-void FIO_HalfWordSetDir(uint8_t portNum, uint8_t halfwordNum, uint16_t bitValue, uint8_t dir);
-void FIO_HalfWordSetMask(uint8_t portNum, uint8_t halfwordNum, uint16_t bitValue, uint8_t maskValue);
-void FIO_HalfWordSetValue(uint8_t portNum, uint8_t halfwordNum, uint16_t bitValue);
-void FIO_HalfWordClearValue(uint8_t portNum, uint8_t halfwordNum, uint16_t bitValue);
-uint16_t FIO_HalfWordReadValue(uint8_t portNum, uint8_t halfwordNum);
-
-/* FIO (byte-accessible) style ------------------------------- */
-void FIO_ByteSetDir(uint8_t portNum, uint8_t byteNum, uint8_t bitValue, uint8_t dir);
-void FIO_ByteSetMask(uint8_t portNum, uint8_t byteNum, uint8_t bitValue, uint8_t maskValue);
-void FIO_ByteSetValue(uint8_t portNum, uint8_t byteNum, uint8_t bitValue);
-void FIO_ByteClearValue(uint8_t portNum, uint8_t byteNum, uint8_t bitValue);
-uint8_t FIO_ByteReadValue(uint8_t portNum, uint8_t byteNum);
-
-
-
-/**
- * @}
- */
-
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* LPC17XX_GPIO_H_ */
-
-/**
- * @}
- */
-
-/* --------------------------------- End Of File ------------------------------ */
+/***********************************************************************//**
+ * @file	: lpc17xx_gpio.h
+ * @brief	: Contains all macro definitions and function prototypes
+ * 				support for GPIO firmware library on LPC17xx
+ * @version	: 1.0
+ * @date	: 23. Apr. 2009
+ * @author	: HieuNguyen
+ **************************************************************************
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * products. This software is supplied &quot;AS IS&quot; without any warranties.
+ * NXP Semiconductors assumes no responsibility or liability for the
+ * use of the software, conveys no license or title under any patent,
+ * copyright, or mask work right to the product. NXP Semiconductors
+ * reserves the right to make changes in the software without
+ * notification. NXP Semiconductors also make no representation or
+ * warranty that such application will be suitable for the specified
+ * use without further testing or modification.
+ **************************************************************************/
+
+/* Peripheral group ----------------------------------------------------------- */
+/** @defgroup GPIO
+ * @ingroup LPC1700CMSIS_FwLib_Drivers
+ * @{
+ */
+
+#ifndef LPC17XX_GPIO_H_
+#define LPC17XX_GPIO_H_
+
+/* Includes ------------------------------------------------------------------- */
+#include &quot;LPC17xx.h&quot;
+#include &quot;lpc_types.h&quot;
+
+
+#ifdef __cplusplus
+extern &quot;C&quot;
+{
+#endif
+
+
+/* Public Types --------------------------------------------------------------- */
+/** @defgroup GPIO_Public_Types
+ * @{
+ */
+
+/**
+ * @brief Fast GPIO port byte type definition
+ */
+typedef struct {
+	__IO uint8_t FIODIR[4];		/**&lt; FIO direction register in byte-align */
+	   uint32_t RESERVED0[3];	/**&lt; Reserved */
+	__IO uint8_t FIOMASK[4];	/**&lt; FIO mask register in byte-align */
+	__IO uint8_t FIOPIN[4];		/**&lt; FIO pin register in byte align */
+	__IO uint8_t FIOSET[4];		/**&lt; FIO set register in byte-align */
+	__O  uint8_t FIOCLR[4];		/**&lt; FIO clear register in byte-align */
+} GPIO_Byte_TypeDef;
+
+
+/**
+ * @brief Fast GPIO port half-word type definition
+ */
+typedef struct {
+	__IO uint16_t FIODIRL;		/**&lt; FIO direction register lower halfword part */
+	__IO uint16_t FIODIRU;		/**&lt; FIO direction register upper halfword part */
+	   uint32_t RESERVED0[3];	/**&lt; Reserved */
+	__IO uint16_t FIOMASKL;		/**&lt; FIO mask register lower halfword part */
+	__IO uint16_t FIOMASKU;		/**&lt; FIO mask register upper halfword part */
+	__IO uint16_t FIOPINL;		/**&lt; FIO pin register lower halfword part */
+	__IO uint16_t FIOPINU;		/**&lt; FIO pin register upper halfword part */
+	__IO uint16_t FIOSETL;		/**&lt; FIO set register lower halfword part */
+	__IO uint16_t FIOSETU;		/**&lt; FIO set register upper halfword part */
+	__O  uint16_t FIOCLRL;		/**&lt; FIO clear register lower halfword part */
+	__O  uint16_t FIOCLRU;		/**&lt; FIO clear register upper halfword part */
+} GPIO_HalfWord_TypeDef;
+
+
+/**
+ * @}
+ */
+
+
+/* Public Macros -------------------------------------------------------------- */
+/** @defgroup GPIO_Public_Macros
+ * @{
+ */
+
+/** Fast GPIO port 0 byte accessible definition */
+#define GPIO0_Byte	((GPIO_Byte_TypeDef *)(LPC_GPIO0_BASE))
+/** Fast GPIO port 1 byte accessible definition */
+#define GPIO1_Byte	((GPIO_Byte_TypeDef *)(LPC_GPIO1_BASE))
+/** Fast GPIO port 2 byte accessible definition */
+#define GPIO2_Byte	((GPIO_Byte_TypeDef *)(LPC_GPIO2_BASE))
+/** Fast GPIO port 3 byte accessible definition */
+#define GPIO3_Byte	((GPIO_Byte_TypeDef *)(LPC_GPIO3_BASE))
+/** Fast GPIO port 4 byte accessible definition */
+#define GPIO4_Byte	((GPIO_Byte_TypeDef *)(LPC_GPIO4_BASE))
+
+
+
+/** Fast GPIO port 0 half-word accessible definition */
+#define GPIO0_HalfWord	((GPIO_HalfWord_TypeDef *)(LPC_GPIO0_BASE))
+/** Fast GPIO port 1 half-word accessible definition */
+#define GPIO1_HalfWord	((GPIO_HalfWord_TypeDef *)(LPC_GPIO1_BASE))
+/** Fast GPIO port 2 half-word accessible definition */
+#define GPIO2_HalfWord	((GPIO_HalfWord_TypeDef *)(LPC_GPIO2_BASE))
+/** Fast GPIO port 3 half-word accessible definition */
+#define GPIO3_HalfWord	((GPIO_HalfWord_TypeDef *)(LPC_GPIO3_BASE))
+/** Fast GPIO port 4 half-word accessible definition */
+#define GPIO4_HalfWord	((GPIO_HalfWord_TypeDef *)(LPC_GPIO4_BASE))
+
+
+/**
+ * @}
+ */
+
+
+/* Public Functions ----------------------------------------------------------- */
+/** @defgroup GPIO_Public_Functions
+ * @{
+ */
+
+/* GPIO style ------------------------------- */
+void GPIO_SetDir(uint8_t portNum, uint32_t bitValue, uint8_t dir);
+void GPIO_SetValue(uint8_t portNum, uint32_t bitValue);
+void GPIO_ClearValue(uint8_t portNum, uint32_t bitValue);
+uint32_t GPIO_ReadValue(uint8_t portNum);
+
+/* FIO (word-accessible) style ------------------------------- */
+void FIO_SetDir(uint8_t portNum, uint32_t bitValue, uint8_t dir);
+void FIO_SetValue(uint8_t portNum, uint32_t bitValue);
+void FIO_ClearValue(uint8_t portNum, uint32_t bitValue);
+uint32_t FIO_ReadValue(uint8_t portNum);
+void FIO_SetMask(uint8_t portNum, uint32_t bitValue, uint8_t maskValue);
+
+/* FIO (halfword-accessible) style ------------------------------- */
+void FIO_HalfWordSetDir(uint8_t portNum, uint8_t halfwordNum, uint16_t bitValue, uint8_t dir);
+void FIO_HalfWordSetMask(uint8_t portNum, uint8_t halfwordNum, uint16_t bitValue, uint8_t maskValue);
+void FIO_HalfWordSetValue(uint8_t portNum, uint8_t halfwordNum, uint16_t bitValue);
+void FIO_HalfWordClearValue(uint8_t portNum, uint8_t halfwordNum, uint16_t bitValue);
+uint16_t FIO_HalfWordReadValue(uint8_t portNum, uint8_t halfwordNum);
+
+/* FIO (byte-accessible) style ------------------------------- */
+void FIO_ByteSetDir(uint8_t portNum, uint8_t byteNum, uint8_t bitValue, uint8_t dir);
+void FIO_ByteSetMask(uint8_t portNum, uint8_t byteNum, uint8_t bitValue, uint8_t maskValue);
+void FIO_ByteSetValue(uint8_t portNum, uint8_t byteNum, uint8_t bitValue);
+void FIO_ByteClearValue(uint8_t portNum, uint8_t byteNum, uint8_t bitValue);
+uint8_t FIO_ByteReadValue(uint8_t portNum, uint8_t byteNum);
+
+
+
+/**
+ * @}
+ */
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LPC17XX_GPIO_H_ */
+
+/**
+ * @}
+ */
+
+/* --------------------------------- End Of File ------------------------------ */


Property changes on: trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_gpio.h
___________________________________________________________________
Deleted: svn:executable
   - *

Modified: trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_i2c.h
===================================================================
--- trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_i2c.h	2010-06-28 21:53:59 UTC (rev 759)
+++ trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_i2c.h	2010-07-12 20:56:54 UTC (rev 760)
@@ -1,386 +1,386 @@
-/***********************************************************************//**
- * @file	: lpc17xx_i2c.h
- * @brief	: Contains all macro definitions and function prototypes
- * 				support for I2C firmware library on LPC17xx
- * @version	: 1.0
- * @date	: 13. Apr. 2009
- * @author	: HieuNguyen
- **************************************************************************
- * Software that is described herein is for illustrative purposes only
- * which provides customers with programming information regarding the
- * products. This software is supplied &quot;AS IS&quot; without any warranties.
- * NXP Semiconductors assumes no responsibility or liability for the
- * use of the software, conveys no license or title under any patent,
- * copyright, or mask work right to the product. NXP Semiconductors
- * reserves the right to make changes in the software without
- * notification. NXP Semiconductors also make no representation or
- * warranty that such application will be suitable for the specified
- * use without further testing or modification.
- **************************************************************************/
-
-/* Peripheral group ----------------------------------------------------------- */
-/** @defgroup I2C
- * @ingroup LPC1700CMSIS_FwLib_Drivers
- * @{
- */
-
-#ifndef LPC17XX_I2C_H_
-#define LPC17XX_I2C_H_
-
-/* Includes ------------------------------------------------------------------- */
-#include &quot;LPC17xx.h&quot;
-#include &quot;lpc_types.h&quot;
-
-
-#ifdef __cplusplus
-extern &quot;C&quot;
-{
-#endif
-
-
-/* Private Macros ------------------------------------------------------------- */
-/** @defgroup I2C_Private_Macros
- * @{
- */
-
-/** @defgroup I2C_REGISTER_BIT_DEFINITIONS
- * @{
- */
-
-/*******************************************************************//**
- * I2C Control Set register description
- *********************************************************************/
-#define I2C_I2CONSET_AA				((0x04)) /*!&lt; Assert acknowledge flag */
-#define I2C_I2CONSET_SI				((0x08)) /*!&lt; I2C interrupt flag */
-#define I2C_I2CONSET_STO			((0x10)) /*!&lt; STOP flag */
-#define I2C_I2CONSET_STA			((0x20)) /*!&lt; START flag */
-#define I2C_I2CONSET_I2EN			((0x40)) /*!&lt; I2C interface enable */
-
-
-/*******************************************************************//**
- * I2C Control Clear register description
- *********************************************************************/
-/** Assert acknowledge Clear bit */
-#define I2C_I2CONCLR_AAC			((1&lt;&lt;2))
-/** I2C interrupt Clear bit */
-#define I2C_I2CONCLR_SIC			((1&lt;&lt;3))
-/** START flag Clear bit */
-#define I2C_I2CONCLR_STAC			((1&lt;&lt;5))
-/** I2C interface Disable bit */
-#define I2C_I2CONCLR_I2ENC			((1&lt;&lt;6))
-
-
-/********************************************************************//**
- * I2C Status Code definition (I2C Status register)
- *********************************************************************/
-/* Return Code in I2C status register */
-#define I2C_STAT_CODE_BITMASK		((0xF8))
-
-/* I2C return status code definitions ----------------------------- */
-
-/** No relevant information */
-#define I2C_I2STAT_NO_INF						((0xF8))
-
-/* Master transmit mode -------------------------------------------- */
-/** A start condition has been transmitted */
-#define I2C_I2STAT_M_TX_START					((0x08))
-/** A repeat start condition has been transmitted */
-#define I2C_I2STAT_M_TX_RESTART					((0x10))
-/** SLA+W has been transmitted, ACK has been received */
-#define I2C_I2STAT_M_TX_SLAW_ACK				((0x18))
-/** SLA+W has been transmitted, NACK has been received */
-#define I2C_I2STAT_M_TX_SLAW_NACK				((0x20))
-/** Data has been transmitted, ACK has been received */
-#define I2C_I2STAT_M_TX_DAT_ACK					((0x28))
-/** Data has been transmitted, NACK has been received */
-#define I2C_I2STAT_M_TX_DAT_NACK				((0x30))
-/** Arbitration lost in SLA+R/W or Data bytes */
-#define I2C_I2STAT_M_TX_ARB_LOST				((0x38))
-
-/* Master receive mode -------------------------------------------- */
-/** A start condition has been transmitted */
-#define I2C_I2STAT_M_RX_START					((0x08))
-/** A repeat start condition has been transmitted */
-#define I2C_I2STAT_M_RX_RESTART					((0x10))
-/** Arbitration lost */
-#define I2C_I2STAT_M_RX_ARB_LOST				((0x38))
-/** SLA+R has been transmitted, ACK has been received */
-#define I2C_I2STAT_M_RX_SLAR_ACK				((0x40))
-/** SLA+R has been transmitted, NACK has been received */
-#define I2C_I2STAT_M_RX_SLAR_NACK				((0x48))
-/** Data has been received, ACK has been returned */
-#define I2C_I2STAT_M_RX_DAT_ACK					((0x50))
-/** Data has been received, NACK has been return */
-#define I2C_I2STAT_M_RX_DAT_NACK				((0x58))
-
-/* Slave receive mode -------------------------------------------- */
-/** Own slave address has been received, ACK has been returned */
-#define I2C_I2STAT_S_RX_SLAW_ACK				((0x60))
-
-/** Arbitration lost in SLA+R/W as master */
-#define I2C_I2STAT_S_RX_ARB_LOST_M_SLA			((0x68))
-/** Own SLA+W has been received, ACK returned */
-//#define I2C_I2STAT_S_RX_SLAW_ACK				((0x68))
-
-/** General call address has been received, ACK has been returned */
-#define I2C_I2STAT_S_RX_GENCALL_ACK				((0x70))
-
-/** Arbitration lost in SLA+R/W (GENERAL CALL) as master */
-#define I2C_I2STAT_S_RX_ARB_LOST_M_GENCALL		((0x78))
-/** General call address has been received, ACK has been returned */
-//#define I2C_I2STAT_S_RX_GENCALL_ACK				((0x78))
-
-/** Previously addressed with own SLV address;
- * Data has been received, ACK has been return */
-#define I2C_I2STAT_S_RX_PRE_SLA_DAT_ACK			((0x80))
-/** Previously addressed with own SLA;
- * Data has been received and NOT ACK has been return */
-#define I2C_I2STAT_S_RX_PRE_SLA_DAT_NACK		((0x88))
-/** Previously addressed with General Call;
- * Data has been received and ACK has been return */
-#define I2C_I2STAT_S_RX_PRE_GENCALL_DAT_ACK		((0x90))
-/** Previously addressed with General Call;
- * Data has been received and NOT ACK has been return */
-#define I2C_I2STAT_S_RX_PRE_GENCALL_DAT_NACK	((0x98))
-/** A STOP condition or repeated START condition has
- * been received while still addressed as SLV/REC
- * (Slave Receive) or SLV/TRX (Slave Transmit) */
-#define I2C_I2STAT_S_RX_STA_STO_SLVREC_SLVTRX	((0xA0))
-
-/** Slave transmit mode -------------------------------------------- */
-/** Own SLA+R has been received, ACK has been returned */
-#define I2C_I2STAT_S_TX_SLAR_ACK				((0xA8))
-
-/** Arbitration lost in SLA+R/W as master */
-#define I2C_I2STAT_S_TX_ARB_LOST_M_SLA			((0xB0))
-/** Own SLA+R has been received, ACK has been returned */
-//#define I2C_I2STAT_S_TX_SLAR_ACK				((0xB0))
-
-/** Data has been transmitted, ACK has been received */
-#define I2C_I2STAT_S_TX_DAT_ACK					((0xB8))
-/** Data has been transmitted, NACK has been received */
-#define I2C_I2STAT_S_TX_DAT_NACK				((0xC0))
-/** Last data byte in I2DAT has been transmitted (AA = 0);
- ACK has been received */
-#define I2C_I2STAT_S_TX_LAST_DAT_ACK			((0xC8))
-
-/** Time out in case of using I2C slave mode */
-#define I2C_SLAVE_TIME_OUT						0x10000UL
-
-/********************************************************************//**
- * I2C Data register definition
- *********************************************************************/
-/** Mask for I2DAT register*/
-#define I2C_I2DAT_BITMASK			((0xFF))
-
-/** Idle data value will be send out in slave mode in case of the actual
- * expecting data requested from the master is greater than its sending data
- * length that can be supported */
-#define I2C_I2DAT_IDLE_CHAR			(0xFF)
-
-
-/********************************************************************//**
- * I2C Monitor mode control register description
- *********************************************************************/
-#define I2C_I2MMCTRL_MM_ENA			((1&lt;&lt;0))		/**&lt; Monitor mode enable */
-#define I2C_I2MMCTRL_ENA_SCL		((1&lt;&lt;1))		/**&lt; SCL output enable */
-#define I2C_I2MMCTRL_MATCH_ALL		((1&lt;&lt;2))		/**&lt; Select interrupt register match */
-#define I2C_I2MMCTRL_BITMASK		((0x07))		/**&lt; Mask for I2MMCTRL register */
-
-
-/********************************************************************//**
- * I2C Data buffer register description
- *********************************************************************/
-/** I2C Data buffer register bit mask */
-#define I2DATA_BUFFER_BITMASK		((0xFF))
-
-
-/********************************************************************//**
- * I2C Slave Address registers definition
- *********************************************************************/
-/** General Call enable bit */
-#define I2C_I2ADR_GC				((1&lt;&lt;0))
-/** I2C Slave Address registers bit mask */
-#define I2C_I2ADR_BITMASK			((0xFF))
-
-
-/********************************************************************//**
- * I2C Mask Register definition
- *********************************************************************/
-/** I2C Mask Register mask field */
-#define I2C_I2MASK_MASK(n)			((n&amp;0xFE))
-
-
-/********************************************************************//**
- * I2C SCL HIGH duty cycle Register definition
- *********************************************************************/
-/** I2C SCL HIGH duty cycle Register bit mask */
-#define I2C_I2SCLH_BITMASK			((0xFFFF))
-
-
-/********************************************************************//**
- * I2C SCL LOW duty cycle Register definition
- *********************************************************************/
-/** I2C SCL LOW duty cycle Register bit mask */
-#define I2C_I2SCLL_BITMASK			((0xFFFF))
-
-/**
- * @}
- */
-
-/**
- * @}
- */
-
-
-
-/* Public Types --------------------------------------------------------------- */
-/** @defgroup I2C_Public_Types
- * @{
- */
-
-/** @brief I2C Own slave address setting structure */
-typedef struct {
-	uint8_t SlaveAddrChannel;	/**&lt; Slave Address channel in I2C control,
-								should be in range from 0..3
-								*/
-	uint8_t SlaveAddr_7bit;		/**&lt; Value of 7-bit slave address */
-	uint8_t GeneralCallState;	/**&lt; Enable/Disable General Call Functionality
-								when I2C control being in Slave mode, should be:
-								- ENABLE: Enable General Call function.
-								- DISABLE: Disable General Call function.
-								*/
-	uint8_t SlaveAddrMaskValue;	/**&lt; Any bit in this 8-bit value (bit 7:1)
-								which is set to '1' will cause an automatic compare on
-								the corresponding bit of the received address when it
-								is compared to the SlaveAddr_7bit value associated with this
-								mask register. In other words, bits in SlaveAddr_7bit value
-								which are masked are not taken into account in determining
-								an address match
-								*/
-} I2C_OWNSLAVEADDR_CFG_Type;
-
-
-/** @brief Master transfer setup data structure definitions */
-typedef struct
-{
-  uint32_t          sl_addr7bit;				/**&lt; Slave address in 7bit mode */
-  uint8_t*          tx_data;					/**&lt; Pointer to Transmit data - NULL if data transmit
-													  is not used */
-  uint32_t          tx_length;					/**&lt; Transmit data length - 0 if data transmit
-													  is not used*/
-  uint32_t          tx_count;					/**&lt; Current Transmit data counter */
-  uint8_t*          rx_data;					/**&lt; Pointer to Receive data - NULL if data receive
-													  is not used */
-  uint32_t          rx_length;					/**&lt; Receive data length - 0 if data receive is
-													   not used */
-  uint32_t          rx_count;					/**&lt; Current Receive data counter */
-  uint32_t          retransmissions_max;		/**&lt; Max Re-Transmission value */
-  uint32_t          retransmissions_count;		/**&lt; Current Re-Transmission counter */
-  uint32_t          status;						/**&lt; Current status of I2C activity */
-  void 				(*callback)(void);			/**&lt; Pointer to Call back function when transmission complete
-													used in interrupt transfer mode */
-} I2C_M_SETUP_Type;
-
-
-/** @brief Slave transfer setup data structure definitions */
-typedef struct
-{
-  uint8_t*          tx_data;
-  uint32_t          tx_length;
-  uint32_t          tx_count;
-  uint8_t*          rx_data;
-  uint32_t          rx_length;
-  uint32_t          rx_count;
-  uint32_t          status;
-  void 				(*callback)(void);
-} I2C_S_SETUP_Type;
-
-/**
- * @brief Transfer option type definitions
- */
-typedef enum {
-	I2C_TRANSFER_POLLING = 0,		/**&lt; Transfer in polling mode */
-	I2C_TRANSFER_INTERRUPT			/**&lt; Transfer in interrupt mode */
-} I2C_TRANSFER_OPT_Type;
-
-
-/**
- * @}
- */
-
-
-/* Public Macros -------------------------------------------------------------- */
-/** @defgroup I2C_Public_Macros
- * @{
- */
-
-#define PARAM_I2C_SLAVEADDR_CH(n)	((n&gt;=0) &amp;&amp; (n&lt;=3))
-
-/** Macro to determine if it is valid SSP port number */
-#define PARAM_I2Cx(n)	((((uint32_t *)n)==((uint32_t *)I2C0)) \
-						|| (((uint32_t *)n)==((uint32_t *)I2C1)) \
-						|| (((uint32_t *)n)==((uint32_t *)I2C2)))
-
-/* I2C status values */
-#define I2C_SETUP_STATUS_ARBF   (1&lt;&lt;8)	/**&lt; Arbitration false */
-#define I2C_SETUP_STATUS_NOACKF (1&lt;&lt;9)	/**&lt; No ACK returned */
-#define I2C_SETUP_STATUS_DONE   (1&lt;&lt;10)	/**&lt; Status DONE */
-
-
-/*********************************************************************//**
- * I2C monitor control configuration defines
- **********************************************************************/
-#define I2C_MONITOR_CFG_SCL_OUTPUT	I2C_I2MMCTRL_ENA_SCL		/**&lt; SCL output enable */
-#define I2C_MONITOR_CFG_MATCHALL	I2C_I2MMCTRL_MATCH_ALL		/**&lt; Select interrupt register match */
-
-#define PARAM_I2C_MONITOR_CFG(n) ((n==I2C_MONITOR_CFG_SCL_OUTPUT) || (I2C_MONITOR_CFG_MATCHALL))
-
-/**
- * @}
- */
-
-
-/* Public Functions ----------------------------------------------------------- */
-/** @defgroup I2C_Public_Functions
- * @{
- */
-
-void I2C_SetClock (I2C_TypeDef *I2Cx, uint32_t target_clock);
-void I2C_DeInit(I2C_TypeDef* I2Cx);
-void I2C_Init(I2C_TypeDef *I2Cx, uint32_t clockrate);
-void I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
-
-Status I2C_MasterTransferData(I2C_TypeDef *I2Cx, \
-		I2C_M_SETUP_Type *TransferCfg, I2C_TRANSFER_OPT_Type Opt);
-Status I2C_SlaveTransferData(I2C_TypeDef *I2Cx, \
-		I2C_S_SETUP_Type *TransferCfg, I2C_TRANSFER_OPT_Type Opt);
-
-void I2C_SetOwnSlaveAddr(I2C_TypeDef *I2Cx, I2C_OWNSLAVEADDR_CFG_Type *OwnSlaveAddrConfigStruct);
-uint8_t I2C_GetLastStatusCode(I2C_TypeDef* I2Cx);
-
-void I2C_MonitorModeConfig(I2C_TypeDef *I2Cx, uint32_t MonitorCfgType, FunctionalState NewState);
-void I2C_MonitorModeCmd(I2C_TypeDef *I2Cx, FunctionalState NewState);
-uint8_t I2C_MonitorGetDatabuffer(I2C_TypeDef *I2Cx);
-
-void I2C0_StdIntHandler(void);
-void I2C1_StdIntHandler(void);
-void I2C2_StdIntHandler(void);
-
-
-/**
- * @}
- */
-
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* LPC17XX_I2C_H_ */
-
-/**
- * @}
- */
-
-/* --------------------------------- End Of File ------------------------------ */
+/***********************************************************************//**
+ * @file	: lpc17xx_i2c.h
+ * @brief	: Contains all macro definitions and function prototypes
+ * 				support for I2C firmware library on LPC17xx
+ * @version	: 1.0
+ * @date	: 13. Apr. 2009
+ * @author	: HieuNguyen
+ **************************************************************************
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * products. This software is supplied &quot;AS IS&quot; without any warranties.
+ * NXP Semiconductors assumes no responsibility or liability for the
+ * use of the software, conveys no license or title under any patent,
+ * copyright, or mask work right to the product. NXP Semiconductors
+ * reserves the right to make changes in the software without
+ * notification. NXP Semiconductors also make no representation or
+ * warranty that such application will be suitable for the specified
+ * use without further testing or modification.
+ **************************************************************************/
+
+/* Peripheral group ----------------------------------------------------------- */
+/** @defgroup I2C
+ * @ingroup LPC1700CMSIS_FwLib_Drivers
+ * @{
+ */
+
+#ifndef LPC17XX_I2C_H_
+#define LPC17XX_I2C_H_
+
+/* Includes ------------------------------------------------------------------- */
+#include &quot;LPC17xx.h&quot;
+#include &quot;lpc_types.h&quot;
+
+
+#ifdef __cplusplus
+extern &quot;C&quot;
+{
+#endif
+
+
+/* Private Macros ------------------------------------------------------------- */
+/** @defgroup I2C_Private_Macros
+ * @{
+ */
+
+/** @defgroup I2C_REGISTER_BIT_DEFINITIONS
+ * @{
+ */
+
+/*******************************************************************//**
+ * I2C Control Set register description
+ *********************************************************************/
+#define I2C_I2CONSET_AA				((0x04)) /*!&lt; Assert acknowledge flag */
+#define I2C_I2CONSET_SI				((0x08)) /*!&lt; I2C interrupt flag */
+#define I2C_I2CONSET_STO			((0x10)) /*!&lt; STOP flag */
+#define I2C_I2CONSET_STA			((0x20)) /*!&lt; START flag */
+#define I2C_I2CONSET_I2EN			((0x40)) /*!&lt; I2C interface enable */
+
+
+/*******************************************************************//**
+ * I2C Control Clear register description
+ *********************************************************************/
+/** Assert acknowledge Clear bit */
+#define I2C_I2CONCLR_AAC			((1&lt;&lt;2))
+/** I2C interrupt Clear bit */
+#define I2C_I2CONCLR_SIC			((1&lt;&lt;3))
+/** START flag Clear bit */
+#define I2C_I2CONCLR_STAC			((1&lt;&lt;5))
+/** I2C interface Disable bit */
+#define I2C_I2CONCLR_I2ENC			((1&lt;&lt;6))
+
+
+/********************************************************************//**
+ * I2C Status Code definition (I2C Status register)
+ *********************************************************************/
+/* Return Code in I2C status register */
+#define I2C_STAT_CODE_BITMASK		((0xF8))
+
+/* I2C return status code definitions ----------------------------- */
+
+/** No relevant information */
+#define I2C_I2STAT_NO_INF						((0xF8))
+
+/* Master transmit mode -------------------------------------------- */
+/** A start condition has been transmitted */
+#define I2C_I2STAT_M_TX_START					((0x08))
+/** A repeat start condition has been transmitted */
+#define I2C_I2STAT_M_TX_RESTART					((0x10))
+/** SLA+W has been transmitted, ACK has been received */
+#define I2C_I2STAT_M_TX_SLAW_ACK				((0x18))
+/** SLA+W has been transmitted, NACK has been received */
+#define I2C_I2STAT_M_TX_SLAW_NACK				((0x20))
+/** Data has been transmitted, ACK has been received */
+#define I2C_I2STAT_M_TX_DAT_ACK					((0x28))
+/** Data has been transmitted, NACK has been received */
+#define I2C_I2STAT_M_TX_DAT_NACK				((0x30))
+/** Arbitration lost in SLA+R/W or Data bytes */
+#define I2C_I2STAT_M_TX_ARB_LOST				((0x38))
+
+/* Master receive mode -------------------------------------------- */
+/** A start condition has been transmitted */
+#define I2C_I2STAT_M_RX_START					((0x08))
+/** A repeat start condition has been transmitted */
+#define I2C_I2STAT_M_RX_RESTART					((0x10))
+/** Arbitration lost */
+#define I2C_I2STAT_M_RX_ARB_LOST				((0x38))
+/** SLA+R has been transmitted, ACK has been received */
+#define I2C_I2STAT_M_RX_SLAR_ACK				((0x40))
+/** SLA+R has been transmitted, NACK has been received */
+#define I2C_I2STAT_M_RX_SLAR_NACK				((0x48))
+/** Data has been received, ACK has been returned */
+#define I2C_I2STAT_M_RX_DAT_ACK					((0x50))
+/** Data has been received, NACK has been return */
+#define I2C_I2STAT_M_RX_DAT_NACK				((0x58))
+
+/* Slave receive mode -------------------------------------------- */
+/** Own slave address has been received, ACK has been returned */
+#define I2C_I2STAT_S_RX_SLAW_ACK				((0x60))
+
+/** Arbitration lost in SLA+R/W as master */
+#define I2C_I2STAT_S_RX_ARB_LOST_M_SLA			((0x68))
+/** Own SLA+W has been received, ACK returned */
+//#define I2C_I2STAT_S_RX_SLAW_ACK				((0x68))
+
+/** General call address has been received, ACK has been returned */
+#define I2C_I2STAT_S_RX_GENCALL_ACK				((0x70))
+
+/** Arbitration lost in SLA+R/W (GENERAL CALL) as master */
+#define I2C_I2STAT_S_RX_ARB_LOST_M_GENCALL		((0x78))
+/** General call address has been received, ACK has been returned */
+//#define I2C_I2STAT_S_RX_GENCALL_ACK				((0x78))
+
+/** Previously addressed with own SLV address;
+ * Data has been received, ACK has been return */
+#define I2C_I2STAT_S_RX_PRE_SLA_DAT_ACK			((0x80))
+/** Previously addressed with own SLA;
+ * Data has been received and NOT ACK has been return */
+#define I2C_I2STAT_S_RX_PRE_SLA_DAT_NACK		((0x88))
+/** Previously addressed with General Call;
+ * Data has been received and ACK has been return */
+#define I2C_I2STAT_S_RX_PRE_GENCALL_DAT_ACK		((0x90))
+/** Previously addressed with General Call;
+ * Data has been received and NOT ACK has been return */
+#define I2C_I2STAT_S_RX_PRE_GENCALL_DAT_NACK	((0x98))
+/** A STOP condition or repeated START condition has
+ * been received while still addressed as SLV/REC
+ * (Slave Receive) or SLV/TRX (Slave Transmit) */
+#define I2C_I2STAT_S_RX_STA_STO_SLVREC_SLVTRX	((0xA0))
+
+/** Slave transmit mode */
+/** Own SLA+R has been received, ACK has been returned */
+#define I2C_I2STAT_S_TX_SLAR_ACK				((0xA8))
+
+/** Arbitration lost in SLA+R/W as master */
+#define I2C_I2STAT_S_TX_ARB_LOST_M_SLA			((0xB0))
+/** Own SLA+R has been received, ACK has been returned */
+//#define I2C_I2STAT_S_TX_SLAR_ACK				((0xB0))
+
+/** Data has been transmitted, ACK has been received */
+#define I2C_I2STAT_S_TX_DAT_ACK					((0xB8))
+/** Data has been transmitted, NACK has been received */
+#define I2C_I2STAT_S_TX_DAT_NACK				((0xC0))
+/** Last data byte in I2DAT has been transmitted (AA = 0);
+ ACK has been received */
+#define I2C_I2STAT_S_TX_LAST_DAT_ACK			((0xC8))
+
+/** Time out in case of using I2C slave mode */
+#define I2C_SLAVE_TIME_OUT						0x10000UL
+
+/********************************************************************//**
+ * I2C Data register definition
+ *********************************************************************/
+/** Mask for I2DAT register*/
+#define I2C_I2DAT_BITMASK			((0xFF))
+
+/** Idle data value will be send out in slave mode in case of the actual
+ * expecting data requested from the master is greater than its sending data
+ * length that can be supported */
+#define I2C_I2DAT_IDLE_CHAR			(0xFF)
+
+
+/********************************************************************//**
+ * I2C Monitor mode control register description
+ *********************************************************************/
+#define I2C_I2MMCTRL_MM_ENA			((1&lt;&lt;0))		/**&lt; Monitor mode enable */
+#define I2C_I2MMCTRL_ENA_SCL		((1&lt;&lt;1))		/**&lt; SCL output enable */
+#define I2C_I2MMCTRL_MATCH_ALL		((1&lt;&lt;2))		/**&lt; Select interrupt register match */
+#define I2C_I2MMCTRL_BITMASK		((0x07))		/**&lt; Mask for I2MMCTRL register */
+
+
+/********************************************************************//**
+ * I2C Data buffer register description
+ *********************************************************************/
+/** I2C Data buffer register bit mask */
+#define I2DATA_BUFFER_BITMASK		((0xFF))
+
+
+/********************************************************************//**
+ * I2C Slave Address registers definition
+ *********************************************************************/
+/** General Call enable bit */
+#define I2C_I2ADR_GC				((1&lt;&lt;0))
+/** I2C Slave Address registers bit mask */
+#define I2C_I2ADR_BITMASK			((0xFF))
+
+
+/********************************************************************//**
+ * I2C Mask Register definition
+ *********************************************************************/
+/** I2C Mask Register mask field */
+#define I2C_I2MASK_MASK(n)			((n&amp;0xFE))
+
+
+/********************************************************************//**
+ * I2C SCL HIGH duty cycle Register definition
+ *********************************************************************/
+/** I2C SCL HIGH duty cycle Register bit mask */
+#define I2C_I2SCLH_BITMASK			((0xFFFF))
+
+
+/********************************************************************//**
+ * I2C SCL LOW duty cycle Register definition
+ *********************************************************************/
+/** I2C SCL LOW duty cycle Register bit mask */
+#define I2C_I2SCLL_BITMASK			((0xFFFF))
+
+/**
+ * @}
+ */
+
+/**
+ * @}
+ */
+
+
+
+/* Public Types --------------------------------------------------------------- */
+/** @defgroup I2C_Public_Types
+ * @{
+ */
+
+/** @brief I2C Own slave address setting structure */
+typedef struct {
+	uint8_t SlaveAddrChannel;	/**&lt; Slave Address channel in I2C control,
+								should be in range from 0..3
+								*/
+	uint8_t SlaveAddr_7bit;		/**&lt; Value of 7-bit slave address */
+	uint8_t GeneralCallState;	/**&lt; Enable/Disable General Call Functionality
+								when I2C control being in Slave mode, should be:
+								- ENABLE: Enable General Call function.
+								- DISABLE: Disable General Call function.
+								*/
+	uint8_t SlaveAddrMaskValue;	/**&lt; Any bit in this 8-bit value (bit 7:1)
+								which is set to '1' will cause an automatic compare on
+								the corresponding bit of the received address when it
+								is compared to the SlaveAddr_7bit value associated with this
+								mask register. In other words, bits in SlaveAddr_7bit value
+								which are masked are not taken into account in determining
+								an address match
+								*/
+} I2C_OWNSLAVEADDR_CFG_Type;
+
+
+/** @brief Master transfer setup data structure definitions */
+typedef struct
+{
+  uint32_t          sl_addr7bit;				/**&lt; Slave address in 7bit mode */
+  uint8_t*          tx_data;					/**&lt; Pointer to Transmit data - NULL if data transmit
+													  is not used */
+  uint32_t          tx_length;					/**&lt; Transmit data length - 0 if data transmit
+													  is not used*/
+  uint32_t          tx_count;					/**&lt; Current Transmit data counter */
+  uint8_t*          rx_data;					/**&lt; Pointer to Receive data - NULL if data receive
+													  is not used */
+  uint32_t          rx_length;					/**&lt; Receive data length - 0 if data receive is
+													   not used */
+  uint32_t          rx_count;					/**&lt; Current Receive data counter */
+  uint32_t          retransmissions_max;		/**&lt; Max Re-Transmission value */
+  uint32_t          retransmissions_count;		/**&lt; Current Re-Transmission counter */
+  uint32_t          status;						/**&lt; Current status of I2C activity */
+  void 				(*callback)(void);			/**&lt; Pointer to Call back function when transmission complete
+													used in interrupt transfer mode */
+} I2C_M_SETUP_Type;
+
+
+/** @brief Slave transfer setup data structure definitions */
+typedef struct
+{
+  uint8_t*          tx_data;
+  uint32_t          tx_length;
+  uint32_t          tx_count;
+  uint8_t*          rx_data;
+  uint32_t          rx_length;
+  uint32_t          rx_count;
+  uint32_t          status;
+  void 				(*callback)(void);
+} I2C_S_SETUP_Type;
+
+/**
+ * @brief Transfer option type definitions
+ */
+typedef enum {
+	I2C_TRANSFER_POLLING = 0,		/**&lt; Transfer in polling mode */
+	I2C_TRANSFER_INTERRUPT			/**&lt; Transfer in interrupt mode */
+} I2C_TRANSFER_OPT_Type;
+
+
+/**
+ * @}
+ */
+
+
+/* Public Macros -------------------------------------------------------------- */
+/** @defgroup I2C_Public_Macros
+ * @{
+ */
+
+#define PARAM_I2C_SLAVEADDR_CH(n)	((n&gt;=0) &amp;&amp; (n&lt;=3))
+
+/** Macro to determine if it is valid SSP port number */
+#define PARAM_I2Cx(n)	((((uint32_t *)n)==((uint32_t *)LPC_I2C0)) \
+|| (((uint32_t *)n)==((uint32_t *)LPC_I2C1)) \
+|| (((uint32_t *)n)==((uint32_t *)LPC_I2C2)))
+
+/* I2C status values */
+#define I2C_SETUP_STATUS_ARBF   (1&lt;&lt;8)	/**&lt; Arbitration false */
+#define I2C_SETUP_STATUS_NOACKF (1&lt;&lt;9)	/**&lt; No ACK returned */
+#define I2C_SETUP_STATUS_DONE   (1&lt;&lt;10)	/**&lt; Status DONE */
+
+
+/*********************************************************************//**
+ * I2C monitor control configuration defines
+ **********************************************************************/
+#define I2C_MONITOR_CFG_SCL_OUTPUT	I2C_I2MMCTRL_ENA_SCL		/**&lt; SCL output enable */
+#define I2C_MONITOR_CFG_MATCHALL	I2C_I2MMCTRL_MATCH_ALL		/**&lt; Select interrupt register match */
+
+#define PARAM_I2C_MONITOR_CFG(n) ((n==I2C_MONITOR_CFG_SCL_OUTPUT) || (I2C_MONITOR_CFG_MATCHALL))
+
+/**
+ * @}
+ */
+
+
+/* Public Functions ----------------------------------------------------------- */
+/** @defgroup I2C_Public_Functions
+ * @{
+ */
+
+void I2C_SetClock (LPC_I2C_TypeDef *I2Cx, uint32_t target_clock);
+void I2C_DeInit(LPC_I2C_TypeDef* I2Cx);
+void I2C_Init(LPC_I2C_TypeDef *I2Cx, uint32_t clockrate);
+void I2C_Cmd(LPC_I2C_TypeDef* I2Cx, FunctionalState NewState);
+
+Status I2C_MasterTransferData(LPC_I2C_TypeDef *I2Cx, \
+		I2C_M_SETUP_Type *TransferCfg, I2C_TRANSFER_OPT_Type Opt);
+Status I2C_SlaveTransferData(LPC_I2C_TypeDef *I2Cx, \
+		I2C_S_SETUP_Type *TransferCfg, I2C_TRANSFER_OPT_Type Opt);
+
+void I2C_SetOwnSlaveAddr(LPC_I2C_TypeDef *I2Cx, I2C_OWNSLAVEADDR_CFG_Type *OwnSlaveAddrConfigStruct);
+uint8_t I2C_GetLastStatusCode(LPC_I2C_TypeDef* I2Cx);
+
+void I2C_MonitorModeConfig(LPC_I2C_TypeDef *I2Cx, uint32_t MonitorCfgType, FunctionalState NewState);
+void I2C_MonitorModeCmd(LPC_I2C_TypeDef *I2Cx, FunctionalState NewState);
+uint8_t I2C_MonitorGetDatabuffer(LPC_I2C_TypeDef *I2Cx);
+
+void I2C0_StdIntHandler(void);
+void I2C1_StdIntHandler(void);
+void I2C2_StdIntHandler(void);
+
+
+/**
+ * @}
+ */
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LPC17XX_I2C_H_ */
+
+/**
+ * @}
+ */
+
+/* --------------------------------- End Of File ------------------------------ */


Property changes on: trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_i2c.h
___________________________________________________________________
Deleted: svn:executable
   - *

Modified: trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_i2s.h
===================================================================
--- trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_i2s.h	2010-06-28 21:53:59 UTC (rev 759)
+++ trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_i2s.h	2010-07-12 20:56:54 UTC (rev 760)
@@ -1,434 +1,434 @@
-/***********************************************************************//**
- * @file	: lpc17xx_i2s.h
- * @brief	: Contains all macro definitions and function prototypes
- * 				support for I2S firmware library on LPC17xx
- * @version	: 1.0
- * @date	: 13. May. 2009
- * @author	: NguyenCao
- **************************************************************************
- * Software that is described herein is for illustrative purposes only
- * which provides customers with programming information regarding the
- * products. This software is supplied &quot;AS IS&quot; without any warranties.
- * NXP Semiconductors assumes no responsibility or liability for the
- * use of the software, conveys no license or title under any patent,
- * copyright, or mask work right to the product. NXP Semiconductors
- * reserves the right to make changes in the software without
- * notification. NXP Semiconductors also make no representation or
- * warranty that such application will be suitable for the specified
- * use without further testing or modification.
- **************************************************************************/
-
-/* Peripheral group ----------------------------------------------------------- */
-/** @defgroup I2S
- * @ingroup LPC1700CMSIS_FwLib_Drivers
- * @{
- */
-
-#ifndef LPC17XX_I2S_H_
-#define LPC17XX_I2S_H_
-
-/* Includes ------------------------------------------------------------------- */
-#include &quot;LPC17xx.h&quot;
-#include &quot;lpc_types.h&quot;
-
-
-#ifdef __cplusplus
-extern &quot;C&quot;
-{
-#endif
-
-
-/* Private Macros ------------------------------------------------------------- */
-/** @defgroup I2S_Private_Macros
- * @{
- */
-
-/*********************************************************************//**
- * Macro defines for DAO-Digital Audio Output register
- **********************************************************************/
-/** @defgroup I2S_REGISTER_BIT_DEFINITION
- * @{
- */
-
-/** I2S wordwide - the number of bytes in data*/
-#define I2S_DAO_WORDWIDTH_8		((uint32_t)(0))		/** 8 bit	*/
-#define I2S_DAO_WORDWIDTH_16	((uint32_t)(1))		/** 16 bit	*/
-#define I2S_DAO_WORDWIDTH_32	((uint32_t)(3))		/** 32 bit	*/
-/** I2S control mono or stereo format */
-#define I2S_DAO_MONO			((uint32_t)(1&lt;&lt;2))
-/** I2S control stop mode */
-#define I2S_DAO_STOP			((uint32_t)(1&lt;&lt;3))
-/** I2S control reset mode */
-#define I2S_DAO_RESET			((uint32_t)(1&lt;&lt;4))
-/** I2S control master/slave mode */
-#define I2S_DAO_SLAVE			((uint32_t)(1&lt;&lt;5))
-/** I2S word select half period minus one */
-#define I2S_DAO_WS_HALFPERIOD(n)	((uint32_t)(n&lt;&lt;6))
-/** I2S control mute mode */
-#define I2S_DAO_MUTE			((uint32_t)(1&lt;&lt;15))
-
-/*********************************************************************//**
- * Macro defines for DAI-Digital Audio Input register
-**********************************************************************/
-/** I2S wordwide - the number of bytes in data*/
-#define I2S_DAI_WORDWIDTH_8		((uint32_t)(0))		/** 8 bit	*/
-#define I2S_DAI_WORDWIDTH_16	((uint32_t)(1))		/** 16 bit	*/
-#define I2S_DAI_WORDWIDTH_32	((uint32_t)(3))		/** 32 bit	*/
-/** I2S control mono or stereo format */
-#define I2S_DAI_MONO			((uint32_t)(1&lt;&lt;2))
-/** I2S control stop mode */
-#define I2S_DAI_STOP			((uint32_t)(1&lt;&lt;3))
-/** I2S control reset mode */
-#define I2S_DAI_RESET			((uint32_t)(1&lt;&lt;4))
-/** I2S control master/slave mode */
-#define I2S_DAI_SLAVE			((uint32_t)(1&lt;&lt;5))
-/** I2S word select half period minus one (9 bits)*/
-#define I2S_DAI_WS_HALFPERIOD(n)	((uint32_t)((n&amp;0x1FF)&lt;&lt;6))
-/** I2S control mute mode */
-#define I2S_DAI_MUTE			((uint32_t)(1&lt;&lt;15))
-
-/*********************************************************************//**
- * Macro defines for STAT register (Status Feedback register)
-**********************************************************************/
-/** I2S Status Receive or Transmit Interrupt */
-#define I2S_STATE_IRQ		((uint32_t)(1))
-/** I2S Status Receive or Transmit DMA1 */
-#define I2S_STATE_DMA1		((uint32_t)(1&lt;&lt;1))
-/** I2S Status Receive or Transmit DMA2 */
-#define I2S_STATE_DMA2		((uint32_t)(1&lt;&lt;2))
-/** I2S Status Current level of the Receive FIFO (5 bits)*/
-#define I2S_STATE_RX_LEVEL(n)	((uint32_t)((n&amp;1F)&lt;&lt;8))
-/** I2S Status Current level of the Transmit FIFO (5 bits)*/
-#define I2S_STATE_TX_LEVEL(n)	((uint32_t)((n&amp;1F)&lt;&lt;16))
-
-/*********************************************************************//**
- * Macro defines for DMA1 register (DMA1 Configuration register)
-**********************************************************************/
-/** I2S control DMA1 for I2S receive */
-#define I2S_DMA1_RX_ENABLE		((uint32_t)(1))
-/** I2S control DMA1 for I2S transmit */
-#define I2S_DMA1_TX_ENABLE		((uint32_t)(1&lt;&lt;1))
-/** I2S set FIFO level that trigger a receive DMA request on DMA1 */
-#define I2S_DMA1_RX_DEPTH(n)	((uint32_t)((n&amp;0x1F)&lt;&lt;8))
-/** I2S set FIFO level that trigger a transmit DMA request on DMA1 */
-#define I2S_DMA1_TX_DEPTH(n)	((uint32_t)((n&amp;0x1F)&lt;&lt;16))
-
-/*********************************************************************//**
- * Macro defines for DMA2 register (DMA2 Configuration register)
-**********************************************************************/
-/** I2S control DMA2 for I2S receive */
-#define I2S_DMA2_RX_ENABLE		((uint32_t)(1))
-/** I2S control DMA1 for I2S transmit */
-#define I2S_DMA2_TX_ENABLE		((uint32_t)(1&lt;&lt;1))
-/** I2S set FIFO level that trigger a receive DMA request on DMA1 */
-#define I2S_DMA2_RX_DEPTH(n)	((uint32_t)((n&amp;0x1F)&lt;&lt;8))
-/** I2S set FIFO level that trigger a transmit DMA request on DMA1 */
-#define I2S_DMA2_TX_DEPTH(n)	((uint32_t)((n&amp;0x1F)&lt;&lt;16))
-
-/*********************************************************************//**
-* Macro defines for IRQ register (Interrupt Request Control register)
-**********************************************************************/
-/** I2S control I2S receive interrupt */
-#define I2S_IRQ_RX_ENABLE		((uint32_t)(1))
-/** I2S control I2S transmit interrupt */
-#define I2S_IRQ_TX_ENABLE		((uint32_t)(1&lt;&lt;1))
-/** I2S set the FIFO level on which to create an irq request */
-#define I2S_IRQ_RX_DEPTH(n)		((uint32_t)((n&amp;0x1F)&lt;&lt;8))
-/** I2S set the FIFO level on which to create an irq request */
-#define I2S_IRQ_TX_DEPTH(n)		((uint32_t)((n&amp;0x1F)&lt;&lt;16))
-
-/********************************************************************************//**
- * Macro defines for TXRATE/RXRATE register (Transmit/Receive Clock Rate register)
-*********************************************************************************/
-/** I2S Transmit MCLK rate denominator */
-#define I2S_TXRATE_Y_DIVIDER(n)	((uint32_t)(n&amp;0xFF))
-/** I2S Transmit MCLK rate denominator */
-#define I2S_TXRATE_X_DIVIDER(n)	((uint32_t)((n&amp;0xFF)&lt;&lt;8))
-/** I2S Receive MCLK rate denominator */
-#define I2S_RXRATE_Y_DIVIDER(n)	((uint32_t)(n&amp;0xFF))
-/** I2S Receive MCLK rate denominator */
-#define I2S_RXRATE_X_DIVIDER(n)	((uint32_t)((n&amp;0xFF)&lt;&lt;8))
-
-/*************************************************************************************//**
- * Macro defines for TXBITRATE &amp; RXBITRATE register (Transmit/Receive Bit Rate register)
-**************************************************************************************/
-#define I2S_TXBITRATE(n)	((uint32_t)(n&amp;0x3F))
-#define I2S_RXBITRATE(n)	((uint32_t)(n&amp;0x3F))
-
-/**********************************************************************************//**
- * Macro defines for TXMODE/RXMODE register (Transmit/Receive Mode Control register)
-************************************************************************************/
-/** I2S Transmit select clock source (2 bits)*/
-#define I2S_TXMODE_CLKSEL(n)	((uint32_t)(n&amp;0x03))
-/** I2S Transmit control 4-pin mode */
-#define I2S_TXMODE_4PIN_ENABLE	((uint32_t)(1&lt;&lt;2))
-/** I2S Transmit control the TX_MCLK output */
-#define I2S_TXMODE_MCENA		((uint32_t)(1&lt;&lt;3))
-/** I2S Receive select clock source */
-#define I2S_RXMODE_CLKSEL(n)	((uint32_t)(n&amp;0x03))
-/** I2S Receive control 4-pin mode */
-#define I2S_RXMODE_4PIN_ENABLE	((uint32_t)(1&lt;&lt;2))
-/** I2S Receive control the TX_MCLK output */
-#define I2S_RXMODE_MCENA		((uint32_t)(1&lt;&lt;3))
-
-/**
- * @}
- */
-
-/**
- * @}
- */
-
-
-/* Public Types --------------------------------------------------------------- */
-/** @defgroup I2S_Public_Types
- * @{
- */
-
-
-/**
- * @brief I2S configuration structure
- */
-typedef struct {
-	uint8_t CLK_Pin;		/**&lt; Clock Pin, should be:
-							- I2S_SRX_CLK_P0_4: RX_CLK pin is on P0.4
-							- I2S_SRX_CLK_P0_23: RX_CLK pin is on P0.23
-							- I2S_STX_CLK_P0_7: TX_CLK pin is on P0.7
-							- I2S_STX_CLK_P2_11: TX_CLK pin is on P2.11 */
-	uint8_t WS_Pin;			/**&lt; Word Select, should be:
-							- I2S_SRX_WS_P0_5: RX_WS pin is on P0.5
-							- I2S_SRX_WS_P0_24: RX_WS pin is on P0.24
-							- I2S_STX_WS_P0_8: TX_WS pin is on P0.8
-							- I2S_STX_WS_P2_12: TX_WS pin is on P2.12 */
-	uint8_t SDA_Pin;		/**&lt; Data, should be:
-							- I2S_SRX_SDA_P0_6: RX_SDA pin is on P0.6
-							- I2S_SRX_SDA_P0_25: RX_SDA pin is on P0.25
-							- I2S_STX_SDA_P0_9: TX_SDA pin is on P0.8
-							- I2S_STX_SDA_P2_13: TX_SDA pin is on P2.13 */
-	uint8_t MCLK_Pin;		/**&lt; Master Clock output, should be:
-							- I2S_RX_MCLK_P4_28: RX_MCLK pin is on P4.28
-							- I2S_TX_MCLK_P4_29: TX_MCLK pin is on P4.29*/
-}I2S_PinCFG_Type;
-
-/**
- * @brief I2S configuration structure definition
- */
-typedef struct {
-	uint8_t wordwidth;		/** the number of bytes in data as follow:
-							-I2S_WORDWIDTH_8: 8 bit data
-							-I2S_WORDWIDTH_16: 16 bit data
-							-I2S_WORDWIDTH_32: 32 bit data */
-	uint8_t	mono; 			/** Set mono/stereo mode, should be:
-							- I2S_STEREO: stereo mode
-							- I2S_MONO: mono mode */
-	uint8_t stop;			/** Disables accesses on FIFOs, should be:
-							- I2S_STOP_ENABLE: enable stop mode
-							- I2S_STOP_DISABLE: disable stop mode */
-	uint8_t reset;			/** Asynchronously reset tje transmit channel and FIFO, should be:
-							- I2S_RESET_ENABLE: enable reset mode
-							- I2S_RESET_DISABLE: disable reset mode */
-	uint8_t ws_sel;			/** Set Master/Slave mode, should be:
-							- I2S_MASTER_MODE: I2S master mode
-							- I2S_SLAVE_MODE: I2S slave mode */
-	uint8_t mute;			/** MUTE mode: when true, the transmit channel sends only zeroes, shoule be:
-							- I2S_MUTE_ENABLE: enable mute mode
-							- I2S_MUTE_DISABLE: disable mute mode */
-	uint8_t Reserved0[2];
-} I2S_CFG_Type;
-
-/**
- * @brief I2S DMA configuration structure definition
- */
-typedef struct {
-	uint8_t DMAIndex;		/** Select DMA1 or DMA2, should be:
-							- I2S_DMA_1: DMA1
-							- I2S_DMA_2: DMA2 */
-	uint8_t depth;			/** FIFO level that triggers a DMA request */
-	uint8_t Reserved0[2];
-}I2S_DMAConf_Type;
-
-/**
- * @brief I2S mode configuration structure definition
- */
-typedef struct{
-	uint8_t clksel;			/** Clock source selection, should be:
-							- I2S_CLKSEL_0: Select the fractional rate divider clock output
-							- I2S_CLKSEL_2: Select the MCLK signal as the clock source */
-	uint8_t fpin;			/** Select four pin mode, should be:
-							- I2S_4PIN_ENABLE: 4-pin enable
-							- I2S_4PIN_DISABLE: 4-pin disable */
-	uint8_t mcena;			/** Select MCLK mode, should be:
-							- I2S_MCLK_ENABLE: MCLK enable for output
-							- I2S_MCLK_DISABLE: MCLK disable for output */
-	uint8_t Reserved;
-}I2S_MODEConf_Type;
-
-/** I2S call-back function type definitions */
-typedef void (fnI2SCbs_Type)();
-
-/**
- * @}
- */
-
-
-/* Public Macros -------------------------------------------------------------- */
-/** @defgroup I2S_Public_Macros
- * @{
- */
-
-/** Macro to determine if it is valid I2S peripheral */
-#define PARAM_I2Sx(n)	(((uint32_t *)n)==((uint32_t *)I2S))
-
-/** Macro to check Data to send valid */
-#define PARAM_I2S_DATA(data) 	((data&gt;=0)&amp;&amp;(data &lt;= 0xFFFFFFFF))
-#define PRAM_I2S_FREQ(freq)		((freq&gt;=16000)&amp;&amp;(freq &lt;= 96000))
-
-/** SSP0 function pin selection defines */
-#define I2S_SRX_CLK_P0_4	((uint8_t)(0))
-#define I2S_SRX_WS_P0_5		((uint8_t)(0))
-#define I2S_SRX_SDA_P0_6	((uint8_t)(0))
-#define I2S_STX_CLK_P0_7	((uint8_t)(0))
-#define I2S_STX_WS_P0_8		((uint8_t)(0))
-#define I2S_STX_SDA_P0_9	((uint8_t)(0))
-
-
-#define I2S_SRX_CLK_P0_23	((uint8_t)(0))
-#define I2S_SRX_WS_P0_24	((uint8_t)(0))
-#define I2S_SRX_SDA_P0_25	((uint8_t)(0))
-
-#define I2S_STX_CLK_P2_11	((uint8_t)(2))
-#define I2S_STX_WS_P2_12	((uint8_t)(2))
-#define I2S_STX_SDA_P2_13	((uint8_t)(2))
-
-#define I2S_TX_MCLK_P4_29	((uint8_t)(4))
-#define I2S_RX_MCLK_P4_28	((uint8_t)(4))
-
-/** Macro to check PIN parameter */
-#define PARAM_RX_CLK_PIN(n)	((n==I2S_SRX_CLK_P0_4)||(n==I2S_SRX_CLK_P0_23))
-#define PARAM_TX_CLK_PIN(n)	((n==I2S_STX_CLK_P0_7)||(n==I2S_STX_CLK_P2_11))
-
-#define PARAM_RX_WS_PIN(n)	((n==I2S_SRX_WS_P0_5)||(n==I2S_SRX_WS_P0_24))
-#define PARAM_TX_WS_PIN(n)	((n==I2S_STX_WS_P0_8)||(n==I2S_STX_WS_P2_12))
-
-#define PARAM_RX_SDA_PIN(n) ((n==I2S_SRX_SDA_P0_6)||(n==I2S_SRX_SDA_P0_25))
-#define PARAM_TX_SDA_PIN(n) ((n==I2S_STX_SDA_P0_9)||(n==I2S_STX_SDA_P2_13))
-
-#define PARAM_RX_MCLK_PIN(n) (n==I2S_RX_MCLK_P4_28)
-#define PARAM_TX_MCLK_PIN(n) (n==I2S_TX_MCLK_P4_29)
-
-/*********************************************************************//**
- * I2S configuration parameter defines
- **********************************************************************/
-/** I2S Wordwidth bit */
-#define I2S_WORDWIDTH_8			I2S_DAO_WORDWIDTH_8
-#define I2S_WORDWIDTH_16		I2S_DAO_WORDWIDTH_16
-#define I2S_WORDWIDTH_32		I2S_DAO_WORDWIDTH_32
-#define PARAM_I2S_WORDWIDTH(n)	((n==I2S_WORDWIDTH_8)||(n==I2S_WORDWIDTH_16)\
-								 ||	(n==I2S_WORDWIDTH_32))
-
-/** I2S Channel bit */
-#define I2S_STEREO				((uint32_t)(0))
-#define I2S_MONO				((uint32_t)(1))
-#define PARAM_I2S_CHANNEL(n)	((n==I2S_STEREO)||(n==I2S_MONO))
-
-/** I2S Master/Slave mode bit */
-#define I2S_MASTER_MODE			((uint8_t)(0))
-#define I2S_SLAVE_MODE			((uint8_t)(1))
-#define PARAM_I2S_WS_SEL(n)		((n==I2S_MASTER_MODE)||(n=I2S_SLAVE_MODE))
-
-/** I2S Stop bit */
-#define I2S_STOP_ENABLE		((uint8_t)(1))
-#define I2S_STOP_DISABLE	((uint8_t)(0))
-#define PARAM_I2S_STOP(n)	((n==I2S_STOP_ENABLE)||(n==I2S_STOP_DISABLE))
-
-/** I2S Reset bit */
-#define I2S_RESET_ENABLE	((uint8_t)(1))
-#define I2S_RESET_DISABLE	((uint8_t)(0))
-#define PARAM_I2S_RESET(n)	((n==I2S_RESET_ENABLE)||(n==I2S_RESET_DISABLE))
-
-/** I2S Mute bit */
-#define I2S_MUTE_ENABLE		((uint8_t)(1))
-#define I2S_MUTE_DISABLE	((uint8_t)(0))
-#define PARAM_I2S_MUTE(n)	((n==I2S_MUTE_ENABLE)||(n==I2S_MUTE_DISABLE))
-
-/** I2S Transmit/Receive bit */
-#define I2S_TX_MODE		((uint8_t)(0))
-#define I2S_RX_MODE		((uint8_t)(1))
-#define PARAM_I2S_TRX(n) 		((n==I2S_TX_MODE)||(n==I2S_RX_MODE))
-
-/** I2S Clock Select bit */
-#define I2S_CLKSEL_0	((uint8_t)(0))
-#define I2S_CLKSEL_1	((uint8_t)(2))
-#define PARAM_I2S_CLKSEL(n)		((n==I2S_CLKSEL_0)||(n==I2S_CLKSEL_1))
-
-/** I2S 4-pin Mode bit */
-#define I2S_4PIN_ENABLE 	((uint8_t)(1))
-#define I2S_4PIN_DISABLE 	((uint8_t)(0))
-#define PARAM_I2S_4PIN(n)	((n==I2S_4PIN_ENABLE)||(n==I2S_4PIN_DISABLE))
-
-/** I2S MCLK Enable bit */
-#define I2S_MCLK_ENABLE		((uint8_t)(1))
-#define I2S_MCLK_DISABLE	((uint8_t)(0))
-#define PARAM_I2S_MCLK(n)	((n==I2S_MCLK_ENABLE)||(n==I2S_MCLK_DISABLE))
-
-/** I2S select DMA bit */
-#define I2S_DMA_1	((uint8_t)(0))
-#define I2S_DMA_2	((uint8_t)(1))
-#define PARAM_I2S_DMA(n)		((n==I2S_DMA_1)||(n==I2S_DMA_2))
-
-#define PARAM_I2S_DMA_DEPTH(n)	((n&gt;=0)||(n&lt;=31))
-#define PARAM_I2S_IRQ_LEVEL(n)	((n&gt;=0)||(n&lt;=31))
-
-#define PARAM_I2S_HALFPERIOD(n)	((n&gt;0)&amp;&amp;(n&lt;512))
-
-#define PARAM_I2S_BITRATE(n)	((n&gt;=1)&amp;&amp;(n&lt;=64))
-
-/**
- * @}
- */
-
-
-/* Public Functions ----------------------------------------------------------- */
-/** @defgroup I2S_Public_Functions
- * @{
- */
-
-void I2S_Init(I2S_TypeDef *I2Sx);
-void I2S_DeInit(I2S_TypeDef *I2Sx);
-
-void I2S_Config(I2S_TypeDef *I2Sx, uint8_t TRMode, I2S_CFG_Type* ConfigStruct);
-Status I2S_FreqConfig(I2S_TypeDef *I2Sx, uint32_t Freq, uint8_t TRMode);
-void I2S_SetBitRate(I2S_TypeDef *I2Sx, uint8_t bitrate, uint8_t TRMode);
-void I2S_ModeConfig(I2S_TypeDef *I2Sx, I2S_MODEConf_Type* ModeConfig, uint8_t TRMode);
-
-void I2S_Send(I2S_TypeDef *I2Sx, uint32_t BufferData);
-uint32_t I2S_Receive(I2S_TypeDef* I2Sx);
-void I2S_Start(I2S_TypeDef *I2Sx);
-void I2S_Pause(I2S_TypeDef *I2Sx, uint8_t TRMode);
-void I2S_Mute(I2S_TypeDef *I2Sx, uint8_t TRMode);
-void I2S_Stop(I2S_TypeDef *I2Sx, uint8_t TRMode);
-
-void I2S_DMAConfig(I2S_TypeDef *I2Sx, I2S_DMAConf_Type* DMAConfig, uint8_t TRMode);
-void I2S_DMACmd(I2S_TypeDef *I2Sx, uint8_t DMAIndex,uint8_t TRMode, FunctionalState NewState);
-void I2S_IRQConfig(I2S_TypeDef *I2Sx, uint8_t TRMode, uint8_t level, fnI2SCbs_Type *pfnI2SCbs);
-void I2S_IRQCmd(I2S_TypeDef *I2Sx,uint8_t TRMode, FunctionalState NewState);
-void I2S_IntHandler(void);
-uint8_t I2S_GetLevel(I2S_TypeDef *I2Sx, uint8_t TRMode);
-
-/**
- * @}
- */
-
-
-#ifdef __cplusplus
-}
-#endif
-
-
-#endif /* LPC17XX_SSP_H_ */
-
-/**
- * @}
- */
-
-/* --------------------------------- End Of File ------------------------------ */
+/***********************************************************************//**
+ * @file	: lpc17xx_i2s.h
+ * @brief	: Contains all macro definitions and function prototypes
+ * 				support for I2S firmware library on LPC17xx
+ * @version	: 1.0
+ * @date	: 13. May. 2009
+ * @author	: NguyenCao
+ **************************************************************************
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * products. This software is supplied &quot;AS IS&quot; without any warranties.
+ * NXP Semiconductors assumes no responsibility or liability for the
+ * use of the software, conveys no license or title under any patent,
+ * copyright, or mask work right to the product. NXP Semiconductors
+ * reserves the right to make changes in the software without
+ * notification. NXP Semiconductors also make no representation or
+ * warranty that such application will be suitable for the specified
+ * use without further testing or modification.
+ **************************************************************************/
+
+/* Peripheral group ----------------------------------------------------------- */
+/** @defgroup I2S
+ * @ingroup LPC1700CMSIS_FwLib_Drivers
+ * @{
+ */
+
+#ifndef LPC17XX_I2S_H_
+#define LPC17XX_I2S_H_
+
+/* Includes ------------------------------------------------------------------- */
+#include &quot;LPC17xx.h&quot;
+#include &quot;lpc_types.h&quot;
+
+
+#ifdef __cplusplus
+extern &quot;C&quot;
+{
+#endif
+
+
+/* Private Macros ------------------------------------------------------------- */
+/** @defgroup I2S_Private_Macros
+ * @{
+ */
+
+/*********************************************************************//**
+ * Macro defines for DAO-Digital Audio Output register
+ **********************************************************************/
+/** @defgroup I2S_REGISTER_BIT_DEFINITION
+ * @{
+ */
+
+/** I2S wordwide - the number of bytes in data*/
+#define I2S_DAO_WORDWIDTH_8		((uint32_t)(0))		/** 8 bit	*/
+#define I2S_DAO_WORDWIDTH_16	((uint32_t)(1))		/** 16 bit	*/
+#define I2S_DAO_WORDWIDTH_32	((uint32_t)(3))		/** 32 bit	*/
+/** I2S control mono or stereo format */
+#define I2S_DAO_MONO			((uint32_t)(1&lt;&lt;2))
+/** I2S control stop mode */
+#define I2S_DAO_STOP			((uint32_t)(1&lt;&lt;3))
+/** I2S control reset mode */
+#define I2S_DAO_RESET			((uint32_t)(1&lt;&lt;4))
+/** I2S control master/slave mode */
+#define I2S_DAO_SLAVE			((uint32_t)(1&lt;&lt;5))
+/** I2S word select half period minus one */
+#define I2S_DAO_WS_HALFPERIOD(n)	((uint32_t)(n&lt;&lt;6))
+/** I2S control mute mode */
+#define I2S_DAO_MUTE			((uint32_t)(1&lt;&lt;15))
+
+/*********************************************************************//**
+ * Macro defines for DAI-Digital Audio Input register
+**********************************************************************/
+/** I2S wordwide - the number of bytes in data*/
+#define I2S_DAI_WORDWIDTH_8		((uint32_t)(0))		/** 8 bit	*/
+#define I2S_DAI_WORDWIDTH_16	((uint32_t)(1))		/** 16 bit	*/
+#define I2S_DAI_WORDWIDTH_32	((uint32_t)(3))		/** 32 bit	*/
+/** I2S control mono or stereo format */
+#define I2S_DAI_MONO			((uint32_t)(1&lt;&lt;2))
+/** I2S control stop mode */
+#define I2S_DAI_STOP			((uint32_t)(1&lt;&lt;3))
+/** I2S control reset mode */
+#define I2S_DAI_RESET			((uint32_t)(1&lt;&lt;4))
+/** I2S control master/slave mode */
+#define I2S_DAI_SLAVE			((uint32_t)(1&lt;&lt;5))
+/** I2S word select half period minus one (9 bits)*/
+#define I2S_DAI_WS_HALFPERIOD(n)	((uint32_t)((n&amp;0x1FF)&lt;&lt;6))
+/** I2S control mute mode */
+#define I2S_DAI_MUTE			((uint32_t)(1&lt;&lt;15))
+
+/*********************************************************************//**
+ * Macro defines for STAT register (Status Feedback register)
+**********************************************************************/
+/** I2S Status Receive or Transmit Interrupt */
+#define I2S_STATE_IRQ		((uint32_t)(1))
+/** I2S Status Receive or Transmit DMA1 */
+#define I2S_STATE_DMA1		((uint32_t)(1&lt;&lt;1))
+/** I2S Status Receive or Transmit DMA2 */
+#define I2S_STATE_DMA2		((uint32_t)(1&lt;&lt;2))
+/** I2S Status Current level of the Receive FIFO (5 bits)*/
+#define I2S_STATE_RX_LEVEL(n)	((uint32_t)((n&amp;1F)&lt;&lt;8))
+/** I2S Status Current level of the Transmit FIFO (5 bits)*/
+#define I2S_STATE_TX_LEVEL(n)	((uint32_t)((n&amp;1F)&lt;&lt;16))
+
+/*********************************************************************//**
+ * Macro defines for DMA1 register (DMA1 Configuration register)
+**********************************************************************/
+/** I2S control DMA1 for I2S receive */
+#define I2S_DMA1_RX_ENABLE		((uint32_t)(1))
+/** I2S control DMA1 for I2S transmit */
+#define I2S_DMA1_TX_ENABLE		((uint32_t)(1&lt;&lt;1))
+/** I2S set FIFO level that trigger a receive DMA request on DMA1 */
+#define I2S_DMA1_RX_DEPTH(n)	((uint32_t)((n&amp;0x1F)&lt;&lt;8))
+/** I2S set FIFO level that trigger a transmit DMA request on DMA1 */
+#define I2S_DMA1_TX_DEPTH(n)	((uint32_t)((n&amp;0x1F)&lt;&lt;16))
+
+/*********************************************************************//**
+ * Macro defines for DMA2 register (DMA2 Configuration register)
+**********************************************************************/
+/** I2S control DMA2 for I2S receive */
+#define I2S_DMA2_RX_ENABLE		((uint32_t)(1))
+/** I2S control DMA1 for I2S transmit */
+#define I2S_DMA2_TX_ENABLE		((uint32_t)(1&lt;&lt;1))
+/** I2S set FIFO level that trigger a receive DMA request on DMA1 */
+#define I2S_DMA2_RX_DEPTH(n)	((uint32_t)((n&amp;0x1F)&lt;&lt;8))
+/** I2S set FIFO level that trigger a transmit DMA request on DMA1 */
+#define I2S_DMA2_TX_DEPTH(n)	((uint32_t)((n&amp;0x1F)&lt;&lt;16))
+
+/*********************************************************************//**
+* Macro defines for IRQ register (Interrupt Request Control register)
+**********************************************************************/
+/** I2S control I2S receive interrupt */
+#define I2S_IRQ_RX_ENABLE		((uint32_t)(1))
+/** I2S control I2S transmit interrupt */
+#define I2S_IRQ_TX_ENABLE		((uint32_t)(1&lt;&lt;1))
+/** I2S set the FIFO level on which to create an irq request */
+#define I2S_IRQ_RX_DEPTH(n)		((uint32_t)((n&amp;0x1F)&lt;&lt;8))
+/** I2S set the FIFO level on which to create an irq request */
+#define I2S_IRQ_TX_DEPTH(n)		((uint32_t)((n&amp;0x1F)&lt;&lt;16))
+
+/********************************************************************************//**
+ * Macro defines for TXRATE/RXRATE register (Transmit/Receive Clock Rate register)
+*********************************************************************************/
+/** I2S Transmit MCLK rate denominator */
+#define I2S_TXRATE_Y_DIVIDER(n)	((uint32_t)(n&amp;0xFF))
+/** I2S Transmit MCLK rate denominator */
+#define I2S_TXRATE_X_DIVIDER(n)	((uint32_t)((n&amp;0xFF)&lt;&lt;8))
+/** I2S Receive MCLK rate denominator */
+#define I2S_RXRATE_Y_DIVIDER(n)	((uint32_t)(n&amp;0xFF))
+/** I2S Receive MCLK rate denominator */
+#define I2S_RXRATE_X_DIVIDER(n)	((uint32_t)((n&amp;0xFF)&lt;&lt;8))
+
+/*************************************************************************************//**
+ * Macro defines for TXBITRATE &amp; RXBITRATE register (Transmit/Receive Bit Rate register)
+**************************************************************************************/
+#define I2S_TXBITRATE(n)	((uint32_t)(n&amp;0x3F))
+#define I2S_RXBITRATE(n)	((uint32_t)(n&amp;0x3F))
+
+/**********************************************************************************//**
+ * Macro defines for TXMODE/RXMODE register (Transmit/Receive Mode Control register)
+************************************************************************************/
+/** I2S Transmit select clock source (2 bits)*/
+#define I2S_TXMODE_CLKSEL(n)	((uint32_t)(n&amp;0x03))
+/** I2S Transmit control 4-pin mode */
+#define I2S_TXMODE_4PIN_ENABLE	((uint32_t)(1&lt;&lt;2))
+/** I2S Transmit control the TX_MCLK output */
+#define I2S_TXMODE_MCENA		((uint32_t)(1&lt;&lt;3))
+/** I2S Receive select clock source */
+#define I2S_RXMODE_CLKSEL(n)	((uint32_t)(n&amp;0x03))
+/** I2S Receive control 4-pin mode */
+#define I2S_RXMODE_4PIN_ENABLE	((uint32_t)(1&lt;&lt;2))
+/** I2S Receive control the TX_MCLK output */
+#define I2S_RXMODE_MCENA		((uint32_t)(1&lt;&lt;3))
+
+/**
+ * @}
+ */
+
+/**
+ * @}
+ */
+
+
+/* Public Types --------------------------------------------------------------- */
+/** @defgroup I2S_Public_Types
+ * @{
+ */
+
+
+/**
+ * @brief I2S configuration structure
+ */
+typedef struct {
+	uint8_t CLK_Pin;		/**&lt; Clock Pin, should be:
+							- I2S_SRX_CLK_P0_4: RX_CLK pin is on P0.4
+							- I2S_SRX_CLK_P0_23: RX_CLK pin is on P0.23
+							- I2S_STX_CLK_P0_7: TX_CLK pin is on P0.7
+							- I2S_STX_CLK_P2_11: TX_CLK pin is on P2.11 */
+	uint8_t WS_Pin;			/**&lt; Word Select, should be:
+							- I2S_SRX_WS_P0_5: RX_WS pin is on P0.5
+							- I2S_SRX_WS_P0_24: RX_WS pin is on P0.24
+							- I2S_STX_WS_P0_8: TX_WS pin is on P0.8
+							- I2S_STX_WS_P2_12: TX_WS pin is on P2.12 */
+	uint8_t SDA_Pin;		/**&lt; Data, should be:
+							- I2S_SRX_SDA_P0_6: RX_SDA pin is on P0.6
+							- I2S_SRX_SDA_P0_25: RX_SDA pin is on P0.25
+							- I2S_STX_SDA_P0_9: TX_SDA pin is on P0.8
+							- I2S_STX_SDA_P2_13: TX_SDA pin is on P2.13 */
+	uint8_t MCLK_Pin;		/**&lt; Master Clock output, should be:
+							- I2S_RX_MCLK_P4_28: RX_MCLK pin is on P4.28
+							- I2S_TX_MCLK_P4_29: TX_MCLK pin is on P4.29*/
+}I2S_PinCFG_Type;
+
+/**
+ * @brief I2S configuration structure definition
+ */
+typedef struct {
+	uint8_t wordwidth;		/** the number of bytes in data as follow:
+							-I2S_WORDWIDTH_8: 8 bit data
+							-I2S_WORDWIDTH_16: 16 bit data
+							-I2S_WORDWIDTH_32: 32 bit data */
+	uint8_t	mono; 			/** Set mono/stereo mode, should be:
+							- I2S_STEREO: stereo mode
+							- I2S_MONO: mono mode */
+	uint8_t stop;			/** Disables accesses on FIFOs, should be:
+							- I2S_STOP_ENABLE: enable stop mode
+							- I2S_STOP_DISABLE: disable stop mode */
+	uint8_t reset;			/** Asynchronously reset tje transmit channel and FIFO, should be:
+							- I2S_RESET_ENABLE: enable reset mode
+							- I2S_RESET_DISABLE: disable reset mode */
+	uint8_t ws_sel;			/** Set Master/Slave mode, should be:
+							- I2S_MASTER_MODE: I2S master mode
+							- I2S_SLAVE_MODE: I2S slave mode */
+	uint8_t mute;			/** MUTE mode: when true, the transmit channel sends only zeroes, shoule be:
+							- I2S_MUTE_ENABLE: enable mute mode
+							- I2S_MUTE_DISABLE: disable mute mode */
+	uint8_t Reserved0[2];
+} I2S_CFG_Type;
+
+/**
+ * @brief I2S DMA configuration structure definition
+ */
+typedef struct {
+	uint8_t DMAIndex;		/** Select DMA1 or DMA2, should be:
+							- I2S_DMA_1: DMA1
+							- I2S_DMA_2: DMA2 */
+	uint8_t depth;			/** FIFO level that triggers a DMA request */
+	uint8_t Reserved0[2];
+}I2S_DMAConf_Type;
+
+/**
+ * @brief I2S mode configuration structure definition
+ */
+typedef struct{
+	uint8_t clksel;			/** Clock source selection, should be:
+							- I2S_CLKSEL_0: Select the fractional rate divider clock output
+							- I2S_CLKSEL_2: Select the MCLK signal as the clock source */
+	uint8_t fpin;			/** Select four pin mode, should be:
+							- I2S_4PIN_ENABLE: 4-pin enable
+							- I2S_4PIN_DISABLE: 4-pin disable */
+	uint8_t mcena;			/** Select MCLK mode, should be:
+							- I2S_MCLK_ENABLE: MCLK enable for output
+							- I2S_MCLK_DISABLE: MCLK disable for output */
+	uint8_t Reserved;
+}I2S_MODEConf_Type;
+
+/** I2S call-back function type definitions */
+typedef void (fnI2SCbs_Type)();
+
+/**
+ * @}
+ */
+
+
+/* Public Macros -------------------------------------------------------------- */
+/** @defgroup I2S_Public_Macros
+ * @{
+ */
+
+/** Macro to determine if it is valid I2S peripheral */
+#define PARAM_I2Sx(n)	(((uint32_t *)n)==((uint32_t *)LPC_I2S))
+
+/** Macro to check Data to send valid */
+#define PARAM_I2S_DATA(data) 	((data&gt;=0)&amp;&amp;(data &lt;= 0xFFFFFFFF))
+#define PRAM_I2S_FREQ(freq)		((freq&gt;=16000)&amp;&amp;(freq &lt;= 96000))
+
+/** SSP0 function pin selection defines */
+#define I2S_SRX_CLK_P0_4	((uint8_t)(0))
+#define I2S_SRX_WS_P0_5		((uint8_t)(0))
+#define I2S_SRX_SDA_P0_6	((uint8_t)(0))
+#define I2S_STX_CLK_P0_7	((uint8_t)(0))
+#define I2S_STX_WS_P0_8		((uint8_t)(0))
+#define I2S_STX_SDA_P0_9	((uint8_t)(0))
+
+
+#define I2S_SRX_CLK_P0_23	((uint8_t)(0))
+#define I2S_SRX_WS_P0_24	((uint8_t)(0))
+#define I2S_SRX_SDA_P0_25	((uint8_t)(0))
+
+#define I2S_STX_CLK_P2_11	((uint8_t)(2))
+#define I2S_STX_WS_P2_12	((uint8_t)(2))
+#define I2S_STX_SDA_P2_13	((uint8_t)(2))
+
+#define I2S_TX_MCLK_P4_29	((uint8_t)(4))
+#define I2S_RX_MCLK_P4_28	((uint8_t)(4))
+
+/** Macro to check PIN parameter */
+#define PARAM_RX_CLK_PIN(n)	((n==I2S_SRX_CLK_P0_4)||(n==I2S_SRX_CLK_P0_23))
+#define PARAM_TX_CLK_PIN(n)	((n==I2S_STX_CLK_P0_7)||(n==I2S_STX_CLK_P2_11))
+
+#define PARAM_RX_WS_PIN(n)	((n==I2S_SRX_WS_P0_5)||(n==I2S_SRX_WS_P0_24))
+#define PARAM_TX_WS_PIN(n)	((n==I2S_STX_WS_P0_8)||(n==I2S_STX_WS_P2_12))
+
+#define PARAM_RX_SDA_PIN(n) ((n==I2S_SRX_SDA_P0_6)||(n==I2S_SRX_SDA_P0_25))
+#define PARAM_TX_SDA_PIN(n) ((n==I2S_STX_SDA_P0_9)||(n==I2S_STX_SDA_P2_13))
+
+#define PARAM_RX_MCLK_PIN(n) (n==I2S_RX_MCLK_P4_28)
+#define PARAM_TX_MCLK_PIN(n) (n==I2S_TX_MCLK_P4_29)
+
+/*********************************************************************//**
+ * I2S configuration parameter defines
+ **********************************************************************/
+/** I2S Wordwidth bit */
+#define I2S_WORDWIDTH_8			I2S_DAO_WORDWIDTH_8
+#define I2S_WORDWIDTH_16		I2S_DAO_WORDWIDTH_16
+#define I2S_WORDWIDTH_32		I2S_DAO_WORDWIDTH_32
+#define PARAM_I2S_WORDWIDTH(n)	((n==I2S_WORDWIDTH_8)||(n==I2S_WORDWIDTH_16)\
+||(n==I2S_WORDWIDTH_32))
+
+/** I2S Channel bit */
+#define I2S_STEREO				((uint32_t)(0))
+#define I2S_MONO				((uint32_t)(1))
+#define PARAM_I2S_CHANNEL(n)	((n==I2S_STEREO)||(n==I2S_MONO))
+
+/** I2S Master/Slave mode bit */
+#define I2S_MASTER_MODE			((uint8_t)(0))
+#define I2S_SLAVE_MODE			((uint8_t)(1))
+#define PARAM_I2S_WS_SEL(n)		((n==I2S_MASTER_MODE)||(n=I2S_SLAVE_MODE))
+
+/** I2S Stop bit */
+#define I2S_STOP_ENABLE		((uint8_t)(1))
+#define I2S_STOP_DISABLE	((uint8_t)(0))
+#define PARAM_I2S_STOP(n)	((n==I2S_STOP_ENABLE)||(n==I2S_STOP_DISABLE))
+
+/** I2S Reset bit */
+#define I2S_RESET_ENABLE	((uint8_t)(1))
+#define I2S_RESET_DISABLE	((uint8_t)(0))
+#define PARAM_I2S_RESET(n)	((n==I2S_RESET_ENABLE)||(n==I2S_RESET_DISABLE))
+
+/** I2S Mute bit */
+#define I2S_MUTE_ENABLE		((uint8_t)(1))
+#define I2S_MUTE_DISABLE	((uint8_t)(0))
+#define PARAM_I2S_MUTE(n)	((n==I2S_MUTE_ENABLE)||(n==I2S_MUTE_DISABLE))
+
+/** I2S Transmit/Receive bit */
+#define I2S_TX_MODE		((uint8_t)(0))
+#define I2S_RX_MODE		((uint8_t)(1))
+#define PARAM_I2S_TRX(n) 		((n==I2S_TX_MODE)||(n==I2S_RX_MODE))
+
+/** I2S Clock Select bit */
+#define I2S_CLKSEL_0	((uint8_t)(0))
+#define I2S_CLKSEL_1	((uint8_t)(2))
+#define PARAM_I2S_CLKSEL(n)		((n==I2S_CLKSEL_0)||(n==I2S_CLKSEL_1))
+
+/** I2S 4-pin Mode bit */
+#define I2S_4PIN_ENABLE 	((uint8_t)(1))
+#define I2S_4PIN_DISABLE 	((uint8_t)(0))
+#define PARAM_I2S_4PIN(n)	((n==I2S_4PIN_ENABLE)||(n==I2S_4PIN_DISABLE))
+
+/** I2S MCLK Enable bit */
+#define I2S_MCLK_ENABLE		((uint8_t)(1))
+#define I2S_MCLK_DISABLE	((uint8_t)(0))
+#define PARAM_I2S_MCLK(n)	((n==I2S_MCLK_ENABLE)||(n==I2S_MCLK_DISABLE))
+
+/** I2S select DMA bit */
+#define I2S_DMA_1	((uint8_t)(0))
+#define I2S_DMA_2	((uint8_t)(1))
+#define PARAM_I2S_DMA(n)		((n==I2S_DMA_1)||(n==I2S_DMA_2))
+
+#define PARAM_I2S_DMA_DEPTH(n)	((n&gt;=0)||(n&lt;=31))
+#define PARAM_I2S_IRQ_LEVEL(n)	((n&gt;=0)||(n&lt;=31))
+
+#define PARAM_I2S_HALFPERIOD(n)	((n&gt;0)&amp;&amp;(n&lt;512))
+
+#define PARAM_I2S_BITRATE(n)	((n&gt;=1)&amp;&amp;(n&lt;=64))
+
+/**
+ * @}
+ */
+
+
+/* Public Functions ----------------------------------------------------------- */
+/** @defgroup I2S_Public_Functions
+ * @{
+ */
+
+void I2S_Init(LPC_I2S_TypeDef *I2Sx);
+void I2S_DeInit(LPC_I2S_TypeDef *I2Sx);
+
+void I2S_Config(LPC_I2S_TypeDef *I2Sx, uint8_t TRMode, I2S_CFG_Type* ConfigStruct);
+Status I2S_FreqConfig(LPC_I2S_TypeDef *I2Sx, uint32_t Freq, uint8_t TRMode);
+void I2S_SetBitRate(LPC_I2S_TypeDef *I2Sx, uint8_t bitrate, uint8_t TRMode);
+void I2S_ModeConfig(LPC_I2S_TypeDef *I2Sx, I2S_MODEConf_Type* ModeConfig, uint8_t TRMode);
+
+void I2S_Send(LPC_I2S_TypeDef *I2Sx, uint32_t BufferData);
+uint32_t I2S_Receive(LPC_I2S_TypeDef* I2Sx);
+void I2S_Start(LPC_I2S_TypeDef *I2Sx);
+void I2S_Pause(LPC_I2S_TypeDef *I2Sx, uint8_t TRMode);
+void I2S_Mute(LPC_I2S_TypeDef *I2Sx, uint8_t TRMode);
+void I2S_Stop(LPC_I2S_TypeDef *I2Sx, uint8_t TRMode);
+
+void I2S_DMAConfig(LPC_I2S_TypeDef *I2Sx, I2S_DMAConf_Type* DMAConfig, uint8_t TRMode);
+void I2S_DMACmd(LPC_I2S_TypeDef *I2Sx, uint8_t DMAIndex,uint8_t TRMode, FunctionalState NewState);
+void I2S_IRQConfig(LPC_I2S_TypeDef *I2Sx, uint8_t TRMode, uint8_t level, fnI2SCbs_Type *pfnI2SCbs);
+void I2S_IRQCmd(LPC_I2S_TypeDef *I2Sx,uint8_t TRMode, FunctionalState NewState);
+void I2S_IntHandler(void);
+uint8_t I2S_GetLevel(LPC_I2S_TypeDef *I2Sx, uint8_t TRMode);
+
+/**
+ * @}
+ */
+
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif /* LPC17XX_SSP_H_ */
+
+/**
+ * @}
+ */
+
+/* --------------------------------- End Of File ------------------------------ */


Property changes on: trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_i2s.h
___________________________________________________________________
Deleted: svn:executable
   - *

Modified: trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_libcfg_default.h
===================================================================
--- trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_libcfg_default.h	2010-06-28 21:53:59 UTC (rev 759)
+++ trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_libcfg_default.h	2010-07-12 20:56:54 UTC (rev 760)
@@ -1,163 +1,163 @@
-/***********************************************************************//**
- * @file	: lpc17xx_libcfg_default.h
- * @brief	: Default Library configuration header file
- * @version	: 1.0
- * @date	: 26. Mar. 2009
- * @author	: HieuNguyen
- **************************************************************************
- * Software that is described herein is for illustrative purposes only
- * which provides customers with programming information regarding the
- * products. This software is supplied &quot;AS IS&quot; without any warranties.
- * NXP Semiconductors assumes no responsibility or liability for the
- * use of the software, conveys no license or title under any patent,
- * copyright, or mask work right to the product. NXP Semiconductors
- * reserves the right to make changes in the software without
- * notification. NXP Semiconductors also make no representation or
- * warranty that such application will be suitable for the specified
- * use without further testing or modification.
- **************************************************************************/
-
-/* Library Configuration group ----------------------------------------------------------- */
-/** @defgroup LIBCFG_DEFAULT
- * @ingroup LPC1700CMSIS_FwLib_Drivers
- * @{
- */
-
-#ifndef LPC17XX_LIBCFG_DEFAULT_H_
-#define LPC17XX_LIBCFG_DEFAULT_H_
-
-/* Includes ------------------------------------------------------------------- */
-#include &quot;lpc_types.h&quot;
-
-
-/* Public Macros -------------------------------------------------------------- */
-/** @defgroup LIBCFG_DEFAULT_Public_Macros
- * @{
- */
-
-/************************** DEBUG MODE DEFINITIONS *********************************/
-/* Un-comment the line below to compile the library in DEBUG mode, this will expanse
-   the &quot;CHECK_PARAM&quot; macro in the FW library code */
-
-#define DEBUG    1
-
-
-/******************* PERIPHERAL FW LIBRARY CONFIGURATION DEFINITIONS ***********************/
-
-/* Comment the line below to disable the specific peripheral inclusion */
-
-/* GPIO ------------------------------- */
-#define _GPIO	1
-
-/* UART ------------------------------- */
-#define _UART 	1
-#define _UART0 	1
-#define _UART1 	1
-#define _UART2 	1
-#define _UART3 	1
-
-/* SPI ------------------------------- */
-#define _SPI 	1
-
-/* SSP ------------------------------- */
-#define _SSP 	1
-#define _SSP0 	1
-#define _SSP1 	1
-
-
-/* I2C ------------------------------- */
-#define _I2C 	1
-#define _I2C0 	1
-#define _I2C1 	1
-#define _I2C2 	1
-
-/* TIMER ------------------------------- */
-#define _TIM 	1
-
-/* WDT ------------------------------- */
-#define _WDT 	1
-
-
-/* GPDMA ------------------------------- */
-#define _GPDMA 	1
-
-
-/* DAC ------------------------------- */
-#define _DAC	1
-
-/* DAC ------------------------------- */
-#define _ADC	1
-
-
-/* PWM ------------------------------- */
-#define _PWM	1
-#define _PWM1	1
-
-/* RTC ------------------------------- */
-#define _RTC	1
-
-/* I2S ------------------------------- */
-#define _I2S 	1
-
-/* USB device ------------------------------- */
-#define _USBDEV		1
-#define _USB_DMA 	1
-
-/* QEI ------------------------------- */
-#define _QEI 	1
-
-/* MCPWM ------------------------------- */
-#define _MCPWM 	1
-
-/* CAN--------------------------------*/
-#define _CAN 	1
-
-/* RIT ------------------------------- */
-#define _RIT	1
-
-/* EMAC ------------------------------ */
-#define _EMAC	1
-
-
-/************************** GLOBAL/PUBLIC MACRO DEFINITIONS *********************************/
-
-#ifdef  DEBUG
-/*******************************************************************************
-* @brief		The CHECK_PARAM macro is used for function's parameters check.
-* 				It is used only if the library is compiled in DEBUG mode.
-* @param[in]	expr - If expr is false, it calls check_failed() function
-*                    	which reports the name of the source file and the source
-*                    	line number of the call that failed.
-*                    - If expr is true, it returns no value.
-* @return		None
-*******************************************************************************/
-#define CHECK_PARAM(expr) ((expr) ? (void)0 : check_failed((uint8_t *)__FILE__, __LINE__))
-#else
-#define CHECK_PARAM(expr)
-#endif /* DEBUG */
-
-/**
- * @}
- */
-
-
-/* Public Functions ----------------------------------------------------------- */
-/** @defgroup LIBCFG_DEFAULT_Public_Functions
- * @{
- */
-
-#ifdef  DEBUG
-void check_failed(uint8_t *file, uint32_t line);
-#endif
-
-/**
- * @}
- */
-
-#endif /* LPC17XX_LIBCFG_DEFAULT_H_ */
-
-/**
- * @}
- */
-
-/* --------------------------------- End Of File ------------------------------ */
+/***********************************************************************//**
+ * @file	: lpc17xx_libcfg_default.h
+ * @brief	: Default Library configuration header file
+ * @version	: 1.0
+ * @date	: 26. Mar. 2009
+ * @author	: HieuNguyen
+ **************************************************************************
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * products. This software is supplied &quot;AS IS&quot; without any warranties.
+ * NXP Semiconductors assumes no responsibility or liability for the
+ * use of the software, conveys no license or title under any patent,
+ * copyright, or mask work right to the product. NXP Semiconductors
+ * reserves the right to make changes in the software without
+ * notification. NXP Semiconductors also make no representation or
+ * warranty that such application will be suitable for the specified
+ * use without further testing or modification.
+ **************************************************************************/
+
+/* Library Configuration group ----------------------------------------------------------- */
+/** @defgroup LIBCFG_DEFAULT
+ * @ingroup LPC1700CMSIS_FwLib_Drivers
+ * @{
+ */
+
+#ifndef LPC17XX_LIBCFG_DEFAULT_H_
+#define LPC17XX_LIBCFG_DEFAULT_H_
+
+/* Includes ------------------------------------------------------------------- */
+#include &quot;lpc_types.h&quot;
+
+
+/* Public Macros -------------------------------------------------------------- */
+/** @defgroup LIBCFG_DEFAULT_Public_Macros
+ * @{
+ */
+
+/************************** DEBUG MODE DEFINITIONS *********************************/
+/* Un-comment the line below to compile the library in DEBUG mode, this will expanse
+   the &quot;CHECK_PARAM&quot; macro in the FW library code */
+
+#define DEBUG    1
+
+
+/******************* PERIPHERAL FW LIBRARY CONFIGURATION DEFINITIONS ***********************/
+
+/* Comment the line below to disable the specific peripheral inclusion */
+
+/* GPIO ------------------------------- */
+#define _GPIO	1
+
+/* UART ------------------------------- */
+#define _UART 	1
+#define _UART0 	1
+#define _UART1 	1
+#define _UART2 	1
+#define _UART3 	1
+
+/* SPI ------------------------------- */
+#define _SPI 	1
+
+/* SSP ------------------------------- */
+#define _SSP 	1
+#define _SSP0 	1
+#define _SSP1 	1
+
+
+/* I2C ------------------------------- */
+#define _I2C 	1
+#define _I2C0 	1
+#define _I2C1 	1
+#define _I2C2 	1
+
+/* TIMER ------------------------------- */
+#define _TIM 	1
+
+/* WDT ------------------------------- */
+#define _WDT 	1
+
+
+/* GPDMA ------------------------------- */
+#define _GPDMA 	1
+
+
+/* DAC ------------------------------- */
+#define _DAC	1
+
+/* DAC ------------------------------- */
+#define _ADC	1
+
+
+/* PWM ------------------------------- */
+#define _PWM	1
+#define _PWM1	1
+
+/* RTC ------------------------------- */
+#define _RTC	1
+
+/* I2S ------------------------------- */
+#define _I2S 	1
+
+/* USB device ------------------------------- */
+#define _USBDEV		1
+#define _USB_DMA 	1
+
+/* QEI ------------------------------- */
+#define _QEI 	1
+
+/* MCPWM ------------------------------- */
+#define _MCPWM 	1
+
+/* CAN--------------------------------*/
+#define _CAN 	1
+
+/* RIT ------------------------------- */
+#define _RIT	1
+
+/* EMAC ------------------------------ */
+#define _EMAC	1
+
+
+/************************** GLOBAL/PUBLIC MACRO DEFINITIONS *********************************/
+
+#ifdef  DEBUG
+/*******************************************************************************
+* @brief		The CHECK_PARAM macro is used for function's parameters check.
+* 				It is used only if the library is compiled in DEBUG mode.
+* @param[in]	expr - If expr is false, it calls check_failed() function
+*                    	which reports the name of the source file and the source
+*                    	line number of the call that failed.
+*                    - If expr is true, it returns no value.
+* @return		None
+*******************************************************************************/
+#define CHECK_PARAM(expr) ((expr) ? (void)0 : check_failed((uint8_t *)__FILE__, __LINE__))
+#else
+#define CHECK_PARAM(expr)
+#endif /* DEBUG */
+
+/**
+ * @}
+ */
+
+
+/* Public Functions ----------------------------------------------------------- */
+/** @defgroup LIBCFG_DEFAULT_Public_Functions
+ * @{
+ */
+
+#ifdef  DEBUG
+void check_failed(uint8_t *file, uint32_t line);
+#endif
+
+/**
+ * @}
+ */
+
+#endif /* LPC17XX_LIBCFG_DEFAULT_H_ */
+
+/**
+ * @}
+ */
+
+/* --------------------------------- End Of File ------------------------------ */


Property changes on: trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_libcfg_default.h
___________________________________________________________________
Deleted: svn:executable
   - *

Modified: trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_mcpwm.h
===================================================================
--- trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_mcpwm.h	2010-06-28 21:53:59 UTC (rev 759)
+++ trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_mcpwm.h	2010-07-12 20:56:54 UTC (rev 760)
@@ -1,317 +1,317 @@
-/***********************************************************************//**
- * @file	: lpc17xx_mcpwm.h
- * @brief	: Contains all macro definitions and function prototypes
- * 				support for Motor Control PWM firmware library on LPC17xx
- * @version	: 1.0
- * @date	: 28. May. 2009
- * @author	: HieuNguyen
- **************************************************************************
- * Software that is described herein is for illustrative purposes only
- * which provides customers with programming information regarding the
- * products. This software is supplied &quot;AS IS&quot; without any warranties.
- * NXP Semiconductors assumes no responsibility or liability for the
- * use of the software, conveys no license or title under any patent,
- * copyright, or mask work right to the product. NXP Semiconductors
- * reserves the right to make changes in the software without
- * notification. NXP Semiconductors also make no representation or
- * warranty that such application will be suitable for the specified
- * use without further testing or modification.
- **************************************************************************/
-
-/* Peripheral group ----------------------------------------------------------- */
-/** @defgroup MCPWM
- * @ingroup LPC1700CMSIS_FwLib_Drivers
- * @{
- */
-
-#ifndef LPC17XX_MCPWM_H_
-#define LPC17XX_MCPWM_H_
-
-/* Includes ------------------------------------------------------------------- */
-#include &quot;LPC17xx.h&quot;
-#include &quot;lpc_types.h&quot;
-
-
-#ifdef __cplusplus
-extern &quot;C&quot;
-{
-#endif
-
-
-/* Private Macros ------------------------------------------------------------- */
-/** @defgroup MCPWM_Private_Macros
- * @{
- */
-
-/** @defgroup MCPWM_REGISTER_BIT_DEFINITIONS
- * @{
- */
-
-/* MCPWM Control register, these macro definitions below can be applied for these
- * register type:
- * - MCPWM Control read address
- * - MCPWM Control set address
- * - MCPWM Control clear address
- */
-#define MCPWM_CON_RUN(n)		(((n&gt;=0)&amp;&amp;(n&lt;=2)) ? ((uint32_t)(1&lt;&lt;((n*8)+0))) : (0))		/**&lt; Stops/starts timer channel n */
-#define MCPWM_CON_CENTER(n)		(((n&gt;=0)&amp;&amp;(n&lt;=2)) ? ((uint32_t)(1&lt;&lt;((n*8)+1))) : (0))		/**&lt; Edge/center aligned operation for channel n */
-#define MCPWM_CON_POLAR(n)		(((n&gt;=0)&amp;&amp;(n&lt;=2)) ? ((uint32_t)(1&lt;&lt;((n*8)+2))) : (0))		/**&lt; Select polarity of the MCOAn and MCOBn pin */
-#define MCPWM_CON_DTE(n)		(((n&gt;=0)&amp;&amp;(n&lt;=2)) ? ((uint32_t)(1&lt;&lt;((n*8)+3))) : (0))		/**&lt; Control the dead-time feature for channel n */
-#define MCPWM_CON_DISUP(n)		(((n&gt;=0)&amp;&amp;(n&lt;=2)) ? ((uint32_t)(1&lt;&lt;((n*8)+4))) : (0))		/**&lt; Enable/Disable update of functional register for channel n */
-#define MCPWM_CON_INVBDC		((uint32_t)(1&lt;&lt;29))										/**&lt; Control the polarity for all 3 channels */
-#define MCPWM_CON_ACMODE		((uint32_t)(1&lt;&lt;30))										/**&lt; 3-phase AC mode select */
-#define MCPWM_CON_DCMODE		((uint32_t)(1&lt;&lt;31))										/**&lt; 3-phase DC mode select */
-
-/* Capture Control register, these macro definitions below can be applied for these
- * register type:
- * - MCPWM Capture Control read address
- * - MCPWM Capture Control set address
- * - MCPWM Capture control clear address
- */
-/** Enables/Disable channel (cap) capture event on a rising edge on MCI(mci) */
-#define MCPWM_CAPCON_CAPMCI_RE(cap,mci)	(((cap&gt;=0)&amp;&amp;(cap&lt;=2)&amp;&amp;(mci&gt;=0)&amp;&amp;(mci&lt;=2)) ? ((uint32_t)(1&lt;&lt;((cap*6)+(mci*2)+0))) : (0))
-/** Enables/Disable channel (cap) capture event on a falling edge on MCI(mci) */
-#define MCPWM_CAPCON_CAPMCI_FE(cap,mci)	(((cap&gt;=0)&amp;&amp;(cap&lt;=2)&amp;&amp;(mci&gt;=0)&amp;&amp;(mci&lt;=2)) ? ((uint32_t)(1&lt;&lt;((cap*6)+(mci*2)+1))) : (0))
-/** TC(n) is reset by channel (n) capture event */
-#define MCPWM_CAPCON_RT(n)				(((n&gt;=0)&amp;&amp;(n&lt;=2)) ? ((uint32_t)(1&lt;&lt;(18+(n)))) : (0))
-/** Hardware noise filter: channel (n) capture events are delayed */
-#define MCPWM_CAPCON_HNFCAP(n)			(((n&gt;=0)&amp;&amp;(n&lt;=2)) ? ((uint32_t)(1&lt;&lt;(21+(n)))) : (0))
-
-/* Interrupt registers, these macro definitions below can be applied for these
- * register type:
- * - MCPWM Interrupt Enable read address
- * - MCPWM Interrupt Enable set address
- * - MCPWM Interrupt Enable clear address
- * - MCPWM Interrupt Flags read address
- * - MCPWM Interrupt Flags set address
- * - MCPWM Interrupt Flags clear address
- */
-/** Limit interrupt for channel (n) */
-#define MCPWM_INT_ILIM(n)	(((n&gt;=0)&amp;&amp;(n&lt;=2)) ? ((uint32_t)(1&lt;&lt;((n*4)+0))) : (0))
-/** Match interrupt for channel (n) */
-#define MCPWM_INT_IMAT(n)	(((n&gt;=0)&amp;&amp;(n&lt;=2)) ? ((uint32_t)(1&lt;&lt;((n*4)+1))) : (0))
-/** Capture interrupt for channel (n) */
-#define MCPWM_INT_ICAP(n)	(((n&gt;=0)&amp;&amp;(n&lt;=2)) ? ((uint32_t)(1&lt;&lt;((n*4)+2))) : (0))
-/** Fast abort interrupt */
-#define MCPWM_INT_ABORT		((uint32_t)(1&lt;&lt;15))
-
-/* MCPWM Count Control register, these macro definitions below can be applied for these
- * register type:
- * - MCPWM Count Control read address
- * - MCPWM Count Control set address
- * - MCPWM Count Control clear address
- */
-/** Counter(tc) advances on a rising edge on MCI(mci) pin */
-#define MCPWM_CNTCON_TCMCI_RE(tc,mci)	(((tc&gt;=0)&amp;&amp;(tc&lt;=2)&amp;&amp;(mci&gt;=0)&amp;&amp;(mci&lt;=2)) ? ((uint32_t)(1&lt;&lt;((6*tc)+(2*mci)+0))) : (0))
-/** Counter(cnt) advances on a falling edge on MCI(mci) pin */
-#define MCPWM_CNTCON_TCMCI_FE(tc,mci)	(((tc&gt;=0)&amp;&amp;(tc&lt;=2)&amp;&amp;(mci&gt;=0)&amp;&amp;(mci&lt;=2)) ? ((uint32_t)(1&lt;&lt;((6*tc)+(2*mci)+1))) : (0))
-/** Channel (n) is in counter mode */
-#define MCPWM_CNTCON_CNTR(n)			(((n&gt;=0)&amp;&amp;(n&lt;=2)) ? ((uint32_t)(1&lt;&lt;(29+n))) : (0))
-
-/* MCPWM Timer/Counter 0-2 registers --------------------------------------------------- */
-/* MCPWM Limit 0-2 registers ----------------------------------------------------------- */
-/* MCPWM Match 0-2 registers ----------------------------------------------------------- */
-
-/* MCPWM Dead-time register ------------------------------------------------------------ */
-/** Dead time value x for channel n */
-#define MCPWM_DT(n,x)		(((n&gt;=0)&amp;&amp;(n&lt;=2)) ? ((uint32_t)((x&amp;0x3FF)&lt;&lt;(n*10))) : (0))
-
-/* MCPWM Communication Pattern register ------------------------------------------------ */
-#define MCPWM_CP_A0		((uint32_t)(1&lt;&lt;0))	/**&lt; MCOA0 tracks internal MCOA0 */
-#define MCPWM_CP_B0		((uint32_t)(1&lt;&lt;1))	/**&lt; MCOB0 tracks internal MCOA0 */
-#define MCPWM_CP_A1		((uint32_t)(1&lt;&lt;2))	/**&lt; MCOA1 tracks internal MCOA0 */
-#define MCPWM_CP_B1		((uint32_t)(1&lt;&lt;3))	/**&lt; MCOB1 tracks internal MCOA0 */
-#define MCPWM_CP_A2		((uint32_t)(1&lt;&lt;4))	/**&lt; MCOA2 tracks internal MCOA0 */
-#define MCPWM_CP_B2		((uint32_t)(1&lt;&lt;5))	/**&lt; MCOB2 tracks internal MCOA0 */
-
-/* MCPWM Capture Registers ------------------------------------------------------------- */
-/* MCPWM Capture read addresses */
-
-/* MCPWM Capture clear address --------------------------------------------------------- */
-/** Clear the MCCAP (n) register */
-#define MCPWM_CAPCLR_CAP(n)		(((n&gt;=0)&amp;&amp;(n&lt;=2)) ? ((uint32_t)(1&lt;&lt;n)) : (0))
-
-
-/**
- * @}
- */
-
-/**
- * @}
- */
-
-
-/* Public Types --------------------------------------------------------------- */
-/** @defgroup MCPWM_Public_Types
- * @{
- */
-
-/**
- * @brief Motor Control PWM Channel Configuration structure type definition
- */
-typedef struct {
-	uint32_t channelType;					/**&lt; Edge/center aligned mode for this channel,
-												should be:
-												- MCPWM_CHANNEL_EDGE_MODE: Channel is in Edge mode
-												- MCPWM_CHANNEL_CENTER_MODE: Channel is in Center mode
-												*/
-	uint32_t channelPolarity;				/**&lt; Polarity of the MCOA and MCOB pins, should be:
-												- MCPWM_CHANNEL_PASSIVE_LO: Passive state is LOW, active state is HIGH
-												- MCPWM_CHANNEL_PASSIVE_HI: Passive state is HIGH, active state is LOW
-												*/
-	uint32_t channelDeadtimeEnable;			/**&lt; Enable/Disable DeadTime function for channel, should be:
-												- ENABLE.
-												- DISABLE.
-												*/
-	uint32_t channelDeadtimeValue;			/**&lt; DeadTime value, should be less than 0x3FF */
-	uint32_t channelUpdateEnable;			/**&lt; Enable/Disable updates of functional registers,
-												 should be:
-												- ENABLE.
-												- DISABLE.
-												*/
-	uint32_t channelTimercounterValue;		/**&lt; MCPWM Timer Counter value */
-	uint32_t channelPeriodValue;			/**&lt; MCPWM Period value */
-	uint32_t channelPulsewidthValue;		/**&lt; MCPWM Pulse Width value */
-} MCPWM_CHANNEL_CFG_Type;
-
-/**
- * @brief MCPWM Capture Configuration type definition
- */
-typedef struct {
-	uint32_t captureChannel;		/**&lt; Capture Channel Number, should be in range from 0 to 2 */
-	uint32_t captureRising;			/**&lt; Enable/Disable Capture on Rising Edge event, should be:
-										- ENABLE.
-										- DISABLE.
-										*/
-	uint32_t captureFalling;		/**&lt; Enable/Disable Capture on Falling Edge event, should be:
-										- ENABLE.
-										- DISABLE.
-										*/
-	uint32_t timerReset;			/**&lt; Enable/Disable Timer reset function an capture, should be:
-										- ENABLE.
-										- DISABLE.
-										*/
-	uint32_t hnfEnable;				/**&lt; Enable/Disable Hardware noise filter function, should be:
-										- ENABLE.
-										- DISABLE.
-										*/
-} MCPWM_CAPTURE_CFG_Type;
-
-
-/**
- * @brief MCPWM Count Control Configuration type definition
- */
-typedef struct {
-	uint32_t counterChannel;		/**&lt; Counter Channel Number, should be in range from 0 to 2 */
-	uint32_t countRising;			/**&lt; Enable/Disable Capture on Rising Edge event, should be:
-										- ENABLE.
-										- DISABLE.
-										*/
-	uint32_t countFalling;		/**&lt; Enable/Disable Capture on Falling Edge event, should be:
-										- ENABLE.
-										- DISABLE.
-										*/
-} MCPWM_COUNT_CFG_Type;
-
-/**
- * @}
- */
-
-
-/* Public Macros -------------------------------------------------------------- */
-/** @defgroup MCPWM_Public_Macros
- * @{
- */
-
-
-/** Edge aligned mode for channel in MCPWM */
-#define MCPWM_CHANNEL_EDGE_MODE			((uint32_t)(0))
-/** Center aligned mode for channel in MCPWM */
-#define MCPWM_CHANNEL_CENTER_MODE		((uint32_t)(1))
-
-/** Polarity of the MCOA and MCOB pins: Passive state is LOW, active state is HIGH */
-#define MCPWM_CHANNEL_PASSIVE_LO		((uint32_t)(0))
-/** Polarity of the MCOA and MCOB pins: Passive state is HIGH, active state is LOW */
-#define MCPWM_CHANNEL_PASSIVE_HI		((uint32_t)(1))
-
-/* Output Patent in 3-phase DC mode, the internal MCOA0 signal is routed to any or all of
- * the six output pins under the control of the bits in this register */
-#define MCPWM_PATENT_A0		((uint32_t)(1&lt;&lt;0))	/**&lt; MCOA0 tracks internal MCOA0 */
-#define MCPWM_PATENT_B0		((uint32_t)(1&lt;&lt;1))	/**&lt; MCOB0 tracks internal MCOA0 */
-#define MCPWM_PATENT_A1		((uint32_t)(1&lt;&lt;2))	/**&lt; MCOA1 tracks internal MCOA0 */
-#define MCPWM_PATENT_B1		((uint32_t)(1&lt;&lt;3))	/**&lt; MCOB1 tracks internal MCOA0 */
-#define MCPWM_PATENT_A2		((uint32_t)(1&lt;&lt;4))	/**&lt; MCOA2 tracks internal MCOA0 */
-#define MCPWM_PATENT_B2		((uint32_t)(1&lt;&lt;5))	/**&lt; MCOB2 tracks internal MCOA0 */
-
-/* Interrupt type in MCPWM */
-/** Limit interrupt for channel (0) */
-#define MCPWM_INTFLAG_LIM0	MCPWM_INT_ILIM(0)
-/** Match interrupt for channel (0) */
-#define MCPWM_INTFLAG_MAT0	MCPWM_INT_IMAT(0)
-/** Capture interrupt for channel (0) */
-#define MCPWM_INTFLAG_CAP0	MCPWM_INT_ICAP(0)
-
-/** Limit interrupt for channel (1) */
-#define MCPWM_INTFLAG_LIM1	MCPWM_INT_ILIM(1)
-/** Match interrupt for channel (1) */
-#define MCPWM_INTFLAG_MAT1	MCPWM_INT_IMAT(1)
-/** Capture interrupt for channel (1) */
-#define MCPWM_INTFLAG_CAP1	MCPWM_INT_ICAP(1)
-
-/** Limit interrupt for channel (2) */
-#define MCPWM_INTFLAG_LIM2	MCPWM_INT_ILIM(2)
-/** Match interrupt for channel (2) */
-#define MCPWM_INTFLAG_MAT2	MCPWM_INT_IMAT(2)
-/** Capture interrupt for channel (2) */
-#define MCPWM_INTFLAG_CAP2	MCPWM_INT_ICAP(2)
-
-/** Fast abort interrupt */
-#define MCPWM_INTFLAG_ABORT	MCPWM_INT_ABORT
-
-
-/**
- * @}
- */
-
-
-/* Public Functions ----------------------------------------------------------- */
-/** @defgroup MCPWM_Public_Functions
- * @{
- */
-
-void MCPWM_Init(MCPWM_TypeDef *MCPWMx);
-void MCPWM_ConfigChannel(MCPWM_TypeDef *MCPWMx, uint32_t channelNum,
-						MCPWM_CHANNEL_CFG_Type * channelSetup);
-void MCPWM_WriteToShadow(MCPWM_TypeDef *MCPWMx, uint32_t channelNum,
-						MCPWM_CHANNEL_CFG_Type *channelSetup);
-void MCPWM_ConfigCapture(MCPWM_TypeDef *MCPWMx, uint32_t channelNum,
-						MCPWM_CAPTURE_CFG_Type *captureConfig);
-void MCPWM_ClearCapture(MCPWM_TypeDef *MCPWMx, uint32_t captureChannel);
-uint32_t MCPWM_GetCapture(MCPWM_TypeDef *MCPWMx, uint32_t captureChannel);
-void MCPWM_CountConfig(MCPWM_TypeDef *MCPWMx, uint32_t channelNum,
-					uint32_t countMode, MCPWM_COUNT_CFG_Type *countConfig);
-void MCPWM_Start(MCPWM_TypeDef *MCPWMx,uint32_t channel0, uint32_t channel1, uint32_t channel2);
-void MCPWM_Stop(MCPWM_TypeDef *MCPWMx,uint32_t channel0, uint32_t channel1, uint32_t channel2);
-void MCPWM_ACMode(MCPWM_TypeDef *MCPWMx,uint32_t acMode);
-void MCPWM_DCMode(MCPWM_TypeDef *MCPWMx, uint32_t dcMode,
-					uint32_t outputInvered, uint32_t outputPattern);
-void MCPWM_IntConfig(MCPWM_TypeDef *MCPWMx, uint32_t ulIntType, FunctionalState NewState);
-void MCPWM_IntSet(MCPWM_TypeDef *MCPWMx, uint32_t ulIntType);
-void MCPWM_IntClear(MCPWM_TypeDef *MCPWMx, uint32_t ulIntType);
-FlagStatus MCPWM_GetIntStatus(MCPWM_TypeDef *MCPWMx, uint32_t ulIntType);
-
-/**
- * @}
- */
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* LPC17XX_MCPWM_H_ */
-
-/**
- * @}
- */
-
-/* --------------------------------- End Of File ------------------------------ */
+/***********************************************************************//**
+ * @file	: lpc17xx_mcpwm.h
+ * @brief	: Contains all macro definitions and function prototypes
+ * 				support for Motor Control PWM firmware library on LPC17xx
+ * @version	: 1.0
+ * @date	: 28. May. 2009
+ * @author	: HieuNguyen
+ **************************************************************************
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * products. This software is supplied &quot;AS IS&quot; without any warranties.
+ * NXP Semiconductors assumes no responsibility or liability for the
+ * use of the software, conveys no license or title under any patent,
+ * copyright, or mask work right to the product. NXP Semiconductors
+ * reserves the right to make changes in the software without
+ * notification. NXP Semiconductors also make no representation or
+ * warranty that such application will be suitable for the specified
+ * use without further testing or modification.
+ **************************************************************************/
+
+/* Peripheral group ----------------------------------------------------------- */
+/** @defgroup MCPWM
+ * @ingroup LPC1700CMSIS_FwLib_Drivers
+ * @{
+ */
+
+#ifndef LPC17XX_MCPWM_H_
+#define LPC17XX_MCPWM_H_
+
+/* Includes ------------------------------------------------------------------- */
+#include &quot;LPC17xx.h&quot;
+#include &quot;lpc_types.h&quot;
+
+
+#ifdef __cplusplus
+extern &quot;C&quot;
+{
+#endif
+
+
+/* Private Macros ------------------------------------------------------------- */
+/** @defgroup MCPWM_Private_Macros
+ * @{
+ */
+
+/** @defgroup MCPWM_REGISTER_BIT_DEFINITIONS
+ * @{
+ */
+
+/* MCPWM Control register, these macro definitions below can be applied for these
+ * register type:
+ * - MCPWM Control read address
+ * - MCPWM Control set address
+ * - MCPWM Control clear address
+ */
+#define MCPWM_CON_RUN(n)		(((n&gt;=0)&amp;&amp;(n&lt;=2)) ? ((uint32_t)(1&lt;&lt;((n*8)+0))) : (0))		/**&lt; Stops/starts timer channel n */
+#define MCPWM_CON_CENTER(n)		(((n&gt;=0)&amp;&amp;(n&lt;=2)) ? ((uint32_t)(1&lt;&lt;((n*8)+1))) : (0))		/**&lt; Edge/center aligned operation for channel n */
+#define MCPWM_CON_POLAR(n)		(((n&gt;=0)&amp;&amp;(n&lt;=2)) ? ((uint32_t)(1&lt;&lt;((n*8)+2))) : (0))		/**&lt; Select polarity of the MCOAn and MCOBn pin */
+#define MCPWM_CON_DTE(n)		(((n&gt;=0)&amp;&amp;(n&lt;=2)) ? ((uint32_t)(1&lt;&lt;((n*8)+3))) : (0))		/**&lt; Control the dead-time feature for channel n */
+#define MCPWM_CON_DISUP(n)		(((n&gt;=0)&amp;&amp;(n&lt;=2)) ? ((uint32_t)(1&lt;&lt;((n*8)+4))) : (0))		/**&lt; Enable/Disable update of functional register for channel n */
+#define MCPWM_CON_INVBDC		((uint32_t)(1&lt;&lt;29))										/**&lt; Control the polarity for all 3 channels */
+#define MCPWM_CON_ACMODE		((uint32_t)(1&lt;&lt;30))										/**&lt; 3-phase AC mode select */
+#define MCPWM_CON_DCMODE		((uint32_t)(1&lt;&lt;31))										/**&lt; 3-phase DC mode select */
+
+/* Capture Control register, these macro definitions below can be applied for these
+ * register type:
+ * - MCPWM Capture Control read address
+ * - MCPWM Capture Control set address
+ * - MCPWM Capture control clear address
+ */
+/** Enables/Disable channel (cap) capture event on a rising edge on MCI(mci) */
+#define MCPWM_CAPCON_CAPMCI_RE(cap,mci)	(((cap&gt;=0)&amp;&amp;(cap&lt;=2)&amp;&amp;(mci&gt;=0)&amp;&amp;(mci&lt;=2)) ? ((uint32_t)(1&lt;&lt;((cap*6)+(mci*2)+0))) : (0))
+/** Enables/Disable channel (cap) capture event on a falling edge on MCI(mci) */
+#define MCPWM_CAPCON_CAPMCI_FE(cap,mci)	(((cap&gt;=0)&amp;&amp;(cap&lt;=2)&amp;&amp;(mci&gt;=0)&amp;&amp;(mci&lt;=2)) ? ((uint32_t)(1&lt;&lt;((cap*6)+(mci*2)+1))) : (0))
+/** TC(n) is reset by channel (n) capture event */
+#define MCPWM_CAPCON_RT(n)				(((n&gt;=0)&amp;&amp;(n&lt;=2)) ? ((uint32_t)(1&lt;&lt;(18+(n)))) : (0))
+/** Hardware noise filter: channel (n) capture events are delayed */
+#define MCPWM_CAPCON_HNFCAP(n)			(((n&gt;=0)&amp;&amp;(n&lt;=2)) ? ((uint32_t)(1&lt;&lt;(21+(n)))) : (0))
+
+/* Interrupt registers, these macro definitions below can be applied for these
+ * register type:
+ * - MCPWM Interrupt Enable read address
+ * - MCPWM Interrupt Enable set address
+ * - MCPWM Interrupt Enable clear address
+ * - MCPWM Interrupt Flags read address
+ * - MCPWM Interrupt Flags set address
+ * - MCPWM Interrupt Flags clear address
+ */
+/** Limit interrupt for channel (n) */
+#define MCPWM_INT_ILIM(n)	(((n&gt;=0)&amp;&amp;(n&lt;=2)) ? ((uint32_t)(1&lt;&lt;((n*4)+0))) : (0))
+/** Match interrupt for channel (n) */
+#define MCPWM_INT_IMAT(n)	(((n&gt;=0)&amp;&amp;(n&lt;=2)) ? ((uint32_t)(1&lt;&lt;((n*4)+1))) : (0))
+/** Capture interrupt for channel (n) */
+#define MCPWM_INT_ICAP(n)	(((n&gt;=0)&amp;&amp;(n&lt;=2)) ? ((uint32_t)(1&lt;&lt;((n*4)+2))) : (0))
+/** Fast abort interrupt */
+#define MCPWM_INT_ABORT		((uint32_t)(1&lt;&lt;15))
+
+/* MCPWM Count Control register, these macro definitions below can be applied for these
+ * register type:
+ * - MCPWM Count Control read address
+ * - MCPWM Count Control set address
+ * - MCPWM Count Control clear address
+ */
+/** Counter(tc) advances on a rising edge on MCI(mci) pin */
+#define MCPWM_CNTCON_TCMCI_RE(tc,mci)	(((tc&gt;=0)&amp;&amp;(tc&lt;=2)&amp;&amp;(mci&gt;=0)&amp;&amp;(mci&lt;=2)) ? ((uint32_t)(1&lt;&lt;((6*tc)+(2*mci)+0))) : (0))
+/** Counter(cnt) advances on a falling edge on MCI(mci) pin */
+#define MCPWM_CNTCON_TCMCI_FE(tc,mci)	(((tc&gt;=0)&amp;&amp;(tc&lt;=2)&amp;&amp;(mci&gt;=0)&amp;&amp;(mci&lt;=2)) ? ((uint32_t)(1&lt;&lt;((6*tc)+(2*mci)+1))) : (0))
+/** Channel (n) is in counter mode */
+#define MCPWM_CNTCON_CNTR(n)			(((n&gt;=0)&amp;&amp;(n&lt;=2)) ? ((uint32_t)(1&lt;&lt;(29+n))) : (0))
+
+/* MCPWM Timer/Counter 0-2 registers --------------------------------------------------- */
+/* MCPWM Limit 0-2 registers ----------------------------------------------------------- */
+/* MCPWM Match 0-2 registers ----------------------------------------------------------- */
+
+/* MCPWM Dead-time register ------------------------------------------------------------ */
+/** Dead time value x for channel n */
+#define MCPWM_DT(n,x)		(((n&gt;=0)&amp;&amp;(n&lt;=2)) ? ((uint32_t)((x&amp;0x3FF)&lt;&lt;(n*10))) : (0))
+
+/* MCPWM Communication Pattern register ------------------------------------------------ */
+#define MCPWM_CP_A0		((uint32_t)(1&lt;&lt;0))	/**&lt; MCOA0 tracks internal MCOA0 */
+#define MCPWM_CP_B0		((uint32_t)(1&lt;&lt;1))	/**&lt; MCOB0 tracks internal MCOA0 */
+#define MCPWM_CP_A1		((uint32_t)(1&lt;&lt;2))	/**&lt; MCOA1 tracks internal MCOA0 */
+#define MCPWM_CP_B1		((uint32_t)(1&lt;&lt;3))	/**&lt; MCOB1 tracks internal MCOA0 */
+#define MCPWM_CP_A2		((uint32_t)(1&lt;&lt;4))	/**&lt; MCOA2 tracks internal MCOA0 */
+#define MCPWM_CP_B2		((uint32_t)(1&lt;&lt;5))	/**&lt; MCOB2 tracks internal MCOA0 */
+
+/* MCPWM Capture Registers ------------------------------------------------------------- */
+/* MCPWM Capture read addresses */
+
+/* MCPWM Capture clear address --------------------------------------------------------- */
+/** Clear the MCCAP (n) register */
+#define MCPWM_CAPCLR_CAP(n)		(((n&gt;=0)&amp;&amp;(n&lt;=2)) ? ((uint32_t)(1&lt;&lt;n)) : (0))
+
+
+/**
+ * @}
+ */
+
+/**
+ * @}
+ */
+
+
+/* Public Types --------------------------------------------------------------- */
+/** @defgroup MCPWM_Public_Types
+ * @{
+ */
+
+/**
+ * @brief Motor Control PWM Channel Configuration structure type definition
+ */
+typedef struct {
+	uint32_t channelType;					/**&lt; Edge/center aligned mode for this channel,
+												should be:
+												- MCPWM_CHANNEL_EDGE_MODE: Channel is in Edge mode
+												- MCPWM_CHANNEL_CENTER_MODE: Channel is in Center mode
+												*/
+	uint32_t channelPolarity;				/**&lt; Polarity of the MCOA and MCOB pins, should be:
+												- MCPWM_CHANNEL_PASSIVE_LO: Passive state is LOW, active state is HIGH
+												- MCPWM_CHANNEL_PASSIVE_HI: Passive state is HIGH, active state is LOW
+												*/
+	uint32_t channelDeadtimeEnable;			/**&lt; Enable/Disable DeadTime function for channel, should be:
+												- ENABLE.
+												- DISABLE.
+												*/
+	uint32_t channelDeadtimeValue;			/**&lt; DeadTime value, should be less than 0x3FF */
+	uint32_t channelUpdateEnable;			/**&lt; Enable/Disable updates of functional registers,
+												 should be:
+												- ENABLE.
+												- DISABLE.
+												*/
+	uint32_t channelTimercounterValue;		/**&lt; MCPWM Timer Counter value */
+	uint32_t channelPeriodValue;			/**&lt; MCPWM Period value */
+	uint32_t channelPulsewidthValue;		/**&lt; MCPWM Pulse Width value */
+} MCPWM_CHANNEL_CFG_Type;
+
+/**
+ * @brief MCPWM Capture Configuration type definition
+ */
+typedef struct {
+	uint32_t captureChannel;		/**&lt; Capture Channel Number, should be in range from 0 to 2 */
+	uint32_t captureRising;			/**&lt; Enable/Disable Capture on Rising Edge event, should be:
+										- ENABLE.
+										- DISABLE.
+										*/
+	uint32_t captureFalling;		/**&lt; Enable/Disable Capture on Falling Edge event, should be:
+										- ENABLE.
+										- DISABLE.
+										*/
+	uint32_t timerReset;			/**&lt; Enable/Disable Timer reset function an capture, should be:
+										- ENABLE.
+										- DISABLE.
+										*/
+	uint32_t hnfEnable;				/**&lt; Enable/Disable Hardware noise filter function, should be:
+										- ENABLE.
+										- DISABLE.
+										*/
+} MCPWM_CAPTURE_CFG_Type;
+
+
+/**
+ * @brief MCPWM Count Control Configuration type definition
+ */
+typedef struct {
+	uint32_t counterChannel;		/**&lt; Counter Channel Number, should be in range from 0 to 2 */
+	uint32_t countRising;			/**&lt; Enable/Disable Capture on Rising Edge event, should be:
+										- ENABLE.
+										- DISABLE.
+										*/
+	uint32_t countFalling;		/**&lt; Enable/Disable Capture on Falling Edge event, should be:
+										- ENABLE.
+										- DISABLE.
+										*/
+} MCPWM_COUNT_CFG_Type;
+
+/**
+ * @}
+ */
+
+
+/* Public Macros -------------------------------------------------------------- */
+/** @defgroup MCPWM_Public_Macros
+ * @{
+ */
+
+
+/** Edge aligned mode for channel in MCPWM */
+#define MCPWM_CHANNEL_EDGE_MODE			((uint32_t)(0))
+/** Center aligned mode for channel in MCPWM */
+#define MCPWM_CHANNEL_CENTER_MODE		((uint32_t)(1))
+
+/** Polarity of the MCOA and MCOB pins: Passive state is LOW, active state is HIGH */
+#define MCPWM_CHANNEL_PASSIVE_LO		((uint32_t)(0))
+/** Polarity of the MCOA and MCOB pins: Passive state is HIGH, active state is LOW */
+#define MCPWM_CHANNEL_PASSIVE_HI		((uint32_t)(1))
+
+/* Output Patent in 3-phase DC mode, the internal MCOA0 signal is routed to any or all of
+ * the six output pins under the control of the bits in this register */
+#define MCPWM_PATENT_A0		((uint32_t)(1&lt;&lt;0))	/**&lt; MCOA0 tracks internal MCOA0 */
+#define MCPWM_PATENT_B0		((uint32_t)(1&lt;&lt;1))	/**&lt; MCOB0 tracks internal MCOA0 */
+#define MCPWM_PATENT_A1		((uint32_t)(1&lt;&lt;2))	/**&lt; MCOA1 tracks internal MCOA0 */
+#define MCPWM_PATENT_B1		((uint32_t)(1&lt;&lt;3))	/**&lt; MCOB1 tracks internal MCOA0 */
+#define MCPWM_PATENT_A2		((uint32_t)(1&lt;&lt;4))	/**&lt; MCOA2 tracks internal MCOA0 */
+#define MCPWM_PATENT_B2		((uint32_t)(1&lt;&lt;5))	/**&lt; MCOB2 tracks internal MCOA0 */
+
+/* Interrupt type in MCPWM */
+/** Limit interrupt for channel (0) */
+#define MCPWM_INTFLAG_LIM0	MCPWM_INT_ILIM(0)
+/** Match interrupt for channel (0) */
+#define MCPWM_INTFLAG_MAT0	MCPWM_INT_IMAT(0)
+/** Capture interrupt for channel (0) */
+#define MCPWM_INTFLAG_CAP0	MCPWM_INT_ICAP(0)
+
+/** Limit interrupt for channel (1) */
+#define MCPWM_INTFLAG_LIM1	MCPWM_INT_ILIM(1)
+/** Match interrupt for channel (1) */
+#define MCPWM_INTFLAG_MAT1	MCPWM_INT_IMAT(1)
+/** Capture interrupt for channel (1) */
+#define MCPWM_INTFLAG_CAP1	MCPWM_INT_ICAP(1)
+
+/** Limit interrupt for channel (2) */
+#define MCPWM_INTFLAG_LIM2	MCPWM_INT_ILIM(2)
+/** Match interrupt for channel (2) */
+#define MCPWM_INTFLAG_MAT2	MCPWM_INT_IMAT(2)
+/** Capture interrupt for channel (2) */
+#define MCPWM_INTFLAG_CAP2	MCPWM_INT_ICAP(2)
+
+/** Fast abort interrupt */
+#define MCPWM_INTFLAG_ABORT	MCPWM_INT_ABORT
+
+
+/**
+ * @}
+ */
+
+
+/* Public Functions ----------------------------------------------------------- */
+/** @defgroup MCPWM_Public_Functions
+ * @{
+ */
+
+void MCPWM_Init(LPC_MCPWM_TypeDef *MCPWMx);
+void MCPWM_ConfigChannel(LPC_MCPWM_TypeDef *MCPWMx, uint32_t channelNum,
+						MCPWM_CHANNEL_CFG_Type * channelSetup);
+void MCPWM_WriteToShadow(LPC_MCPWM_TypeDef *MCPWMx, uint32_t channelNum,
+						MCPWM_CHANNEL_CFG_Type *channelSetup);
+void MCPWM_ConfigCapture(LPC_MCPWM_TypeDef *MCPWMx, uint32_t channelNum,
+						MCPWM_CAPTURE_CFG_Type *captureConfig);
+void MCPWM_ClearCapture(LPC_MCPWM_TypeDef *MCPWMx, uint32_t captureChannel);
+uint32_t MCPWM_GetCapture(LPC_MCPWM_TypeDef *MCPWMx, uint32_t captureChannel);
+void MCPWM_CountConfig(LPC_MCPWM_TypeDef *MCPWMx, uint32_t channelNum,
+					uint32_t countMode, MCPWM_COUNT_CFG_Type *countConfig);
+void MCPWM_Start(LPC_MCPWM_TypeDef *MCPWMx,uint32_t channel0, uint32_t channel1, uint32_t channel2);
+void MCPWM_Stop(LPC_MCPWM_TypeDef *MCPWMx,uint32_t channel0, uint32_t channel1, uint32_t channel2);
+void MCPWM_ACMode(LPC_MCPWM_TypeDef *MCPWMx,uint32_t acMode);
+void MCPWM_DCMode(LPC_MCPWM_TypeDef *MCPWMx, uint32_t dcMode,
+					uint32_t outputInvered, uint32_t outputPattern);
+void MCPWM_IntConfig(LPC_MCPWM_TypeDef *MCPWMx, uint32_t ulIntType, FunctionalState NewState);
+void MCPWM_IntSet(LPC_MCPWM_TypeDef *MCPWMx, uint32_t ulIntType);
+void MCPWM_IntClear(LPC_MCPWM_TypeDef *MCPWMx, uint32_t ulIntType);
+FlagStatus MCPWM_GetIntStatus(LPC_MCPWM_TypeDef *MCPWMx, uint32_t ulIntType);
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LPC17XX_MCPWM_H_ */
+
+/**
+ * @}
+ */
+
+/* --------------------------------- End Of File ------------------------------ */


Property changes on: trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_mcpwm.h
___________________________________________________________________
Deleted: svn:executable
   - *

Modified: trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_nvic.h
===================================================================
--- trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_nvic.h	2010-06-28 21:53:59 UTC (rev 759)
+++ trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_nvic.h	2010-07-12 20:56:54 UTC (rev 760)
@@ -1,64 +1,64 @@
-/***********************************************************************//**
- * @file	: lpc17xx_nvic.h
- * @brief	: Contains all macro definitions and function prototypes
- * 				support for Nesting Vectored Interrupt firmware library
- * 				on LPC17xx
- * @version	: 1.0
- * @date	: 18. Mar. 2009
- * @author	: HieuNguyen
- **************************************************************************
- * Software that is described herein is for illustrative purposes only
- * which provides customers with programming information regarding the
- * products. This software is supplied &quot;AS IS&quot; without any warranties.
- * NXP Semiconductors assumes no responsibility or liability for the
- * use of the software, conveys no license or title under any patent,
- * copyright, or mask work right to the product. NXP Semiconductors
- * reserves the right to make changes in the software without
- * notification. NXP Semiconductors also make no representation or
- * warranty that such application will be suitable for the specified
- * use without further testing or modification.
- **************************************************************************/
-
-/* Peripheral group ----------------------------------------------------------- */
-/** @defgroup NVIC
- * @ingroup LPC1700CMSIS_FwLib_Drivers
- * @{
- */
-
-#ifndef LPC17XX_NVIC_H_
-#define LPC17XX_NVIC_H_
-
-/* Includes ------------------------------------------------------------------- */
-#include &quot;LPC17xx.h&quot;
-#include &quot;lpc_types.h&quot;
-
-#ifdef __cplusplus
-extern &quot;C&quot;
-{
-#endif
-
-
-/* Public Functions ----------------------------------------------------------- */
-/** @defgroup NVIC_Public_Functions
- * @{
- */
-
-void NVIC_DeInit(void);
-void NVIC_SCBDeInit(void);
-void NVIC_SetVTOR(uint32_t offset);
-
-/**
- * @}
- */
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* LPC17XX_NVIC_H_ */
-
-/**
- * @}
- */
-
-/* --------------------------------- End Of File ------------------------------ */
+/***********************************************************************//**
+ * @file	: lpc17xx_nvic.h
+ * @brief	: Contains all macro definitions and function prototypes
+ * 				support for Nesting Vectored Interrupt firmware library
+ * 				on LPC17xx
+ * @version	: 1.0
+ * @date	: 18. Mar. 2009
+ * @author	: HieuNguyen
+ **************************************************************************
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * products. This software is supplied &quot;AS IS&quot; without any warranties.
+ * NXP Semiconductors assumes no responsibility or liability for the
+ * use of the software, conveys no license or title under any patent,
+ * copyright, or mask work right to the product. NXP Semiconductors
+ * reserves the right to make changes in the software without
+ * notification. NXP Semiconductors also make no representation or
+ * warranty that such application will be suitable for the specified
+ * use without further testing or modification.
+ **************************************************************************/
+
+/* Peripheral group ----------------------------------------------------------- */
+/** @defgroup NVIC
+ * @ingroup LPC1700CMSIS_FwLib_Drivers
+ * @{
+ */
+
+#ifndef LPC17XX_NVIC_H_
+#define LPC17XX_NVIC_H_
+
+/* Includes ------------------------------------------------------------------- */
+#include &quot;LPC17xx.h&quot;
+#include &quot;lpc_types.h&quot;
+
+#ifdef __cplusplus
+extern &quot;C&quot;
+{
+#endif
+
+
+/* Public Functions ----------------------------------------------------------- */
+/** @defgroup NVIC_Public_Functions
+ * @{
+ */
+
+void NVIC_DeInit(void);
+void NVIC_SCBDeInit(void);
+void NVIC_SetVTOR(uint32_t offset);
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LPC17XX_NVIC_H_ */
+
+/**
+ * @}
+ */
+
+/* --------------------------------- End Of File ------------------------------ */


Property changes on: trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_nvic.h
___________________________________________________________________
Deleted: svn:executable
   - *

Modified: trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_pinsel.h
===================================================================
--- trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_pinsel.h	2010-06-28 21:53:59 UTC (rev 759)
+++ trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_pinsel.h	2010-07-12 20:56:54 UTC (rev 760)
@@ -1,210 +1,210 @@
-/***********************************************************************//**
- * @file	: lpc17xx_pinsel.h
- * @brief	: Contains all macro definitions and function prototypes
- * 				support for Pin connect block firmware library on LPC17xx
- * @version	: 1.0
- * @date	: 25. Feb. 2009
- * @author	: HoanTran
- **************************************************************************
- * Software that is described herein is for illustrative purposes only
- * which provides customers with programming information regarding the
- * products. This software is supplied &quot;AS IS&quot; without any warranties.
- * NXP Semiconductors assumes no responsibility or liability for the
- * use of the software, conveys no license or title under any patent,
- * copyright, or mask work right to the product. NXP Semiconductors
- * reserves the right to make changes in the software without
- * notification. NXP Semiconductors also make no representation or
- * warranty that such application will be suitable for the specified
- * use without further testing or modification.
- **************************************************************************/
-
-/* Peripheral group ----------------------------------------------------------- */
-/** @defgroup PINSEL
- * @ingroup LPC1700CMSIS_FwLib_Drivers
- * @{
- */
-
-#ifndef LPC17XX_PINSEL_H_
-#define LPC17XX_PINSEL_H_
-
-/* Includes ------------------------------------------------------------------- */
-#include &quot;LPC17xx.h&quot;
-#include &quot;lpc_types.h&quot;
-
-#ifdef __cplusplus
-extern &quot;C&quot;
-{
-#endif
-
-
-/* Private Macros ------------------------------------------------------------- */
-/** @defgroup PINSEL_Private_Macros
- * @{
- */
-
-/** @defgroup PINSEL_REGISTER_BIT_DEFINITIONS
- * @{
- */
-
-/* Pin selection define */
-/* I2C Pin Configuration register bit description */
-#define PINSEL_I2CPADCFG_SDADRV0 	_BIT(0) /**&lt; Drive mode control for the SDA0 pin, P0.27 */
-#define PINSEL_I2CPADCFG_SDAI2C0	_BIT(1) /**&lt; I2C mode control for the SDA0 pin, P0.27 */
-#define PINSEL_I2CPADCFG_SCLDRV0	_BIT(2) /**&lt; Drive mode control for the SCL0 pin, P0.28 */
-#define PINSEL_I2CPADCFG_SCLI2C0	_BIT(3) /**&lt; I2C mode control for the SCL0 pin, P0.28 */
-
-/**
- * @}
- */
-
-/**
- * @}
- */
-
-
-/* Public Macros -------------------------------------------------------------- */
-/** @defgroup PINSEL_Public_Macros
- * @{
- */
-
-/*********************************************************************//**
- *!&lt; Macros define for PORT Selection
- ***********************************************************************/
-#define PINSEL_PORT_0 	((0))	/**&lt; PORT 0*/
-#define PINSEL_PORT_1 	((1))	/**&lt; PORT 1*/
-#define PINSEL_PORT_2 	((2))	/**&lt; PORT 2*/
-#define PINSEL_PORT_3 	((3))	/**&lt; PORT 3*/
-#define PINSEL_PORT_4 	((4))	/**&lt; PORT 4*/
-
-
-/***********************************************************************
- * Macros define for Pin Function selection
- **********************************************************************/
-#define PINSEL_FUNC_0	((0))	/**&lt; default function*/
-#define PINSEL_FUNC_1	((1))	/**&lt; first alternate function*/
-#define PINSEL_FUNC_2	((2))	/**&lt; second alternate function*/
-#define PINSEL_FUNC_3	((3))	/**&lt; third or reserved alternate function*/
-
-
-
-/***********************************************************************
- * Macros define for Pin Number of Port
- **********************************************************************/
-#define PINSEL_PIN_0 	((0)) 	/**&lt; Pin 0 */
-#define PINSEL_PIN_1 	((1)) 	/**&lt; Pin 1 */
-#define PINSEL_PIN_2 	((2)) 	/**&lt; Pin 2 */
-#define PINSEL_PIN_3 	((3)) 	/**&lt; Pin 3 */
-#define PINSEL_PIN_4 	((4)) 	/**&lt; Pin 4 */
-#define PINSEL_PIN_5 	((5)) 	/**&lt; Pin 5 */
-#define PINSEL_PIN_6 	((6)) 	/**&lt; Pin 6 */
-#define PINSEL_PIN_7 	((7)) 	/**&lt; Pin 7 */
-#define PINSEL_PIN_8 	((8)) 	/**&lt; Pin 8 */
-#define PINSEL_PIN_9 	((9)) 	/**&lt; Pin 9 */
-#define PINSEL_PIN_10 	((10)) 	/**&lt; Pin 10 */
-#define PINSEL_PIN_11 	((11)) 	/**&lt; Pin 11 */
-#define PINSEL_PIN_12 	((12)) 	/**&lt; Pin 12 */
-#define PINSEL_PIN_13 	((13)) 	/**&lt; Pin 13 */
-#define PINSEL_PIN_14 	((14)) 	/**&lt; Pin 14 */
-#define PINSEL_PIN_15 	((15)) 	/**&lt; Pin 15 */
-#define PINSEL_PIN_16 	((16)) 	/**&lt; Pin 16 */
-#define PINSEL_PIN_17 	((17)) 	/**&lt; Pin 17 */
-#define PINSEL_PIN_18 	((18)) 	/**&lt; Pin 18 */
-#define PINSEL_PIN_19 	((19)) 	/**&lt; Pin 19 */
-#define PINSEL_PIN_20 	((20)) 	/**&lt; Pin 20 */
-#define PINSEL_PIN_21 	((21)) 	/**&lt; Pin 21 */
-#define PINSEL_PIN_22 	((22)) 	/**&lt; Pin 22 */
-#define PINSEL_PIN_23 	((23)) 	/**&lt; Pin 23 */
-#define PINSEL_PIN_24 	((24)) 	/**&lt; Pin 24 */
-#define PINSEL_PIN_25 	((25)) 	/**&lt; Pin 25 */
-#define PINSEL_PIN_26 	((26)) 	/**&lt; Pin 26 */
-#define PINSEL_PIN_27 	((27)) 	/**&lt; Pin 27 */
-#define PINSEL_PIN_28 	((28)) 	/**&lt; Pin 28 */
-#define PINSEL_PIN_29 	((29)) 	/**&lt; Pin 29 */
-#define PINSEL_PIN_30 	((30)) 	/**&lt; Pin 30 */
-#define PINSEL_PIN_31 	((31)) 	/**&lt; Pin 31 */
-
-
-/***********************************************************************
- * Macros define for Pin mode
- **********************************************************************/
-#define PINSEL_PINMODE_PULLUP		((0))	/**&lt; Internal pull-up resistor*/
-#define PINSEL_PINMODE_TRISTATE 	((2))	/**&lt; Tri-state */
-#define PINSEL_PINMODE_PULLDOWN 	((3)) 	/**&lt; Internal pull-down resistor */
-
-
-/***********************************************************************
- * Macros define for Pin mode (normal/open drain)
- **********************************************************************/
-#define	PINSEL_PINMODE_NORMAL		((0))	/**&lt; Pin is in the normal (not open drain) mode.*/
-#define	PINSEL_PINMODE_OPENDRAIN	((1)) 	/**&lt; Pin is in the open drain mode */
-
-
-/***********************************************************************
- * Macros define for I2C mode
- ***********************************************************************/
-#define	PINSEL_I2C_Normal_Mode		((0))	/**&lt; The standard drive mode */
-#define	PINSEL_I2C_Fast_Mode		((1)) 	/**&lt;  Fast Mode Plus drive mode */
-
-
-/**
- * @}
- */
-
-
-/* Public Types --------------------------------------------------------------- */
-/** @defgroup PINSEL_Public_Types
- * @{
- */
-
-/** @brief Pin configuration structure */
-typedef struct
-{
-	uint8_t Portnum;	/**&lt; Port Number, should be PINSEL_PORT_x,
-						where x should be in range from 0 to 4 */
-	uint8_t Pinnum;		/**&lt; Pin Number, should be PINSEL_PIN_x,
-						where x should be in range from 0 to 31 */
-	uint8_t Funcnum;	/**&lt; Function Number, should be PINSEL_FUNC_x,
-						where x should be in range from 0 to 3 */
-	uint8_t Pinmode;	/**&lt; Pin Mode, should be:
-						- PINSEL_PINMODE_PULLUP: Internal pull-up resistor
-						- PINSEL_PINMODE_TRISTATE: Tri-state
-						- PINSEL_PINMODE_PULLDOWN: Internal pull-down resistor */
-	uint8_t OpenDrain;	/**&lt; OpenDrain mode, should be:
-						- PINSEL_PINMODE_NORMAL: Pin is in the normal (not open drain) mode
-						- PINSEL_PINMODE_OPENDRAIN: Pin is in the open drain mode */
-} PINSEL_CFG_Type;
-
-/**
- * @}
- */
-
-
-/* Public Functions ----------------------------------------------------------- */
-/** @defgroup PINSEL_Public_Functions
- * @{
- */
-
-void PINSEL_SetPinFunc ( uint8_t portnum, uint8_t pinnum, uint8_t funcnum);
-void PINSEL_ConfigTraceFunc (FunctionalState NewState);
-void PINSEL_SetResistorMode ( uint8_t portnum, uint8_t pinnum, uint8_t modenum);
-void PINSEL_SetOpenDrainMode( uint8_t portnum, uint8_t pinnum, uint8_t modenum);
-void PINSEL_SetI2C0Pins(uint8_t i2cPinMode, FunctionalState filterSlewRateEnable);
-void PINSEL_ConfigPin(PINSEL_CFG_Type *PinCfg);
-
-/**
- * @}
- */
-
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* LPC17XX_PINSEL_H_ */
-
-/**
- * @}
- */
-
-/* --------------------------------- End Of File ------------------------------ */
-
+/***********************************************************************//**
+ * @file	: lpc17xx_pinsel.h
+ * @brief	: Contains all macro definitions and function prototypes
+ * 				support for Pin connect block firmware library on LPC17xx
+ * @version	: 1.0
+ * @date	: 25. Feb. 2009
+ * @author	: HoanTran
+ **************************************************************************
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * products. This software is supplied &quot;AS IS&quot; without any warranties.
+ * NXP Semiconductors assumes no responsibility or liability for the
+ * use of the software, conveys no license or title under any patent,
+ * copyright, or mask work right to the product. NXP Semiconductors
+ * reserves the right to make changes in the software without
+ * notification. NXP Semiconductors also make no representation or
+ * warranty that such application will be suitable for the specified
+ * use without further testing or modification.
+ **************************************************************************/
+
+/* Peripheral group ----------------------------------------------------------- */
+/** @defgroup PINSEL
+ * @ingroup LPC1700CMSIS_FwLib_Drivers
+ * @{
+ */
+
+#ifndef LPC17XX_PINSEL_H_
+#define LPC17XX_PINSEL_H_
+
+/* Includes ------------------------------------------------------------------- */
+#include &quot;lpc17xx.h&quot;
+#include &quot;lpc_types.h&quot;
+
+#ifdef __cplusplus
+extern &quot;C&quot;
+{
+#endif
+
+
+/* Private Macros ------------------------------------------------------------- */
+/** @defgroup PINSEL_Private_Macros
+ * @{
+ */
+
+/** @defgroup PINSEL_REGISTER_BIT_DEFINITIONS
+ * @{
+ */
+
+/* Pin selection define */
+/* I2C Pin Configuration register bit description */
+#define PINSEL_I2CPADCFG_SDADRV0 	_BIT(0) /**&lt; Drive mode control for the SDA0 pin, P0.27 */
+#define PINSEL_I2CPADCFG_SDAI2C0	_BIT(1) /**&lt; I2C mode control for the SDA0 pin, P0.27 */
+#define PINSEL_I2CPADCFG_SCLDRV0	_BIT(2) /**&lt; Drive mode control for the SCL0 pin, P0.28 */
+#define PINSEL_I2CPADCFG_SCLI2C0	_BIT(3) /**&lt; I2C mode control for the SCL0 pin, P0.28 */
+
+/**
+ * @}
+ */
+
+/**
+ * @}
+ */
+
+
+/* Public Macros -------------------------------------------------------------- */
+/** @defgroup PINSEL_Public_Macros
+ * @{
+ */
+
+/*********************************************************************//**
+ *!&lt; Macros define for PORT Selection
+ ***********************************************************************/
+#define PINSEL_PORT_0 	((0))	/**&lt; PORT 0*/
+#define PINSEL_PORT_1 	((1))	/**&lt; PORT 1*/
+#define PINSEL_PORT_2 	((2))	/**&lt; PORT 2*/
+#define PINSEL_PORT_3 	((3))	/**&lt; PORT 3*/
+#define PINSEL_PORT_4 	((4))	/**&lt; PORT 4*/
+
+
+/***********************************************************************
+ * Macros define for Pin Function selection
+ **********************************************************************/
+#define PINSEL_FUNC_0	((0))	/**&lt; default function*/
+#define PINSEL_FUNC_1	((1))	/**&lt; first alternate function*/
+#define PINSEL_FUNC_2	((2))	/**&lt; second alternate function*/
+#define PINSEL_FUNC_3	((3))	/**&lt; third or reserved alternate function*/
+
+
+
+/***********************************************************************
+ * Macros define for Pin Number of Port
+ **********************************************************************/
+#define PINSEL_PIN_0 	((0)) 	/**&lt; Pin 0 */
+#define PINSEL_PIN_1 	((1)) 	/**&lt; Pin 1 */
+#define PINSEL_PIN_2 	((2)) 	/**&lt; Pin 2 */
+#define PINSEL_PIN_3 	((3)) 	/**&lt; Pin 3 */
+#define PINSEL_PIN_4 	((4)) 	/**&lt; Pin 4 */
+#define PINSEL_PIN_5 	((5)) 	/**&lt; Pin 5 */
+#define PINSEL_PIN_6 	((6)) 	/**&lt; Pin 6 */
+#define PINSEL_PIN_7 	((7)) 	/**&lt; Pin 7 */
+#define PINSEL_PIN_8 	((8)) 	/**&lt; Pin 8 */
+#define PINSEL_PIN_9 	((9)) 	/**&lt; Pin 9 */
+#define PINSEL_PIN_10 	((10)) 	/**&lt; Pin 10 */
+#define PINSEL_PIN_11 	((11)) 	/**&lt; Pin 11 */
+#define PINSEL_PIN_12 	((12)) 	/**&lt; Pin 12 */
+#define PINSEL_PIN_13 	((13)) 	/**&lt; Pin 13 */
+#define PINSEL_PIN_14 	((14)) 	/**&lt; Pin 14 */
+#define PINSEL_PIN_15 	((15)) 	/**&lt; Pin 15 */
+#define PINSEL_PIN_16 	((16)) 	/**&lt; Pin 16 */
+#define PINSEL_PIN_17 	((17)) 	/**&lt; Pin 17 */
+#define PINSEL_PIN_18 	((18)) 	/**&lt; Pin 18 */
+#define PINSEL_PIN_19 	((19)) 	/**&lt; Pin 19 */
+#define PINSEL_PIN_20 	((20)) 	/**&lt; Pin 20 */
+#define PINSEL_PIN_21 	((21)) 	/**&lt; Pin 21 */
+#define PINSEL_PIN_22 	((22)) 	/**&lt; Pin 22 */
+#define PINSEL_PIN_23 	((23)) 	/**&lt; Pin 23 */
+#define PINSEL_PIN_24 	((24)) 	/**&lt; Pin 24 */
+#define PINSEL_PIN_25 	((25)) 	/**&lt; Pin 25 */
+#define PINSEL_PIN_26 	((26)) 	/**&lt; Pin 26 */
+#define PINSEL_PIN_27 	((27)) 	/**&lt; Pin 27 */
+#define PINSEL_PIN_28 	((28)) 	/**&lt; Pin 28 */
+#define PINSEL_PIN_29 	((29)) 	/**&lt; Pin 29 */
+#define PINSEL_PIN_30 	((30)) 	/**&lt; Pin 30 */
+#define PINSEL_PIN_31 	((31)) 	/**&lt; Pin 31 */
+
+
+/***********************************************************************
+ * Macros define for Pin mode
+ **********************************************************************/
+#define PINSEL_PINMODE_PULLUP		((0))	/**&lt; Internal pull-up resistor*/
+#define PINSEL_PINMODE_TRISTATE 	((2))	/**&lt; Tri-state */
+#define PINSEL_PINMODE_PULLDOWN 	((3)) 	/**&lt; Internal pull-down resistor */
+
+
+/***********************************************************************
+ * Macros define for Pin mode (normal/open drain)
+ **********************************************************************/
+#define	PINSEL_PINMODE_NORMAL		((0))	/**&lt; Pin is in the normal (not open drain) mode.*/
+#define	PINSEL_PINMODE_OPENDRAIN	((1)) 	/**&lt; Pin is in the open drain mode */
+
+
+/***********************************************************************
+ * Macros define for I2C mode
+ ***********************************************************************/
+#define	PINSEL_I2C_Normal_Mode		((0))	/**&lt; The standard drive mode */
+#define	PINSEL_I2C_Fast_Mode		((1)) 	/**&lt;  Fast Mode Plus drive mode */
+
+
+/**
+ * @}
+ */
+
+
+/* Public Types --------------------------------------------------------------- */
+/** @defgroup PINSEL_Public_Types
+ * @{
+ */
+
+/** @brief Pin configuration structure */
+typedef struct
+{
+	uint8_t Portnum;	/**&lt; Port Number, should be PINSEL_PORT_x,
+						where x should be in range from 0 to 4 */
+	uint8_t Pinnum;		/**&lt; Pin Number, should be PINSEL_PIN_x,
+						where x should be in range from 0 to 31 */
+	uint8_t Funcnum;	/**&lt; Function Number, should be PINSEL_FUNC_x,
+						where x should be in range from 0 to 3 */
+	uint8_t Pinmode;	/**&lt; Pin Mode, should be:
+						- PINSEL_PINMODE_PULLUP: Internal pull-up resistor
+						- PINSEL_PINMODE_TRISTATE: Tri-state
+						- PINSEL_PINMODE_PULLDOWN: Internal pull-down resistor */
+	uint8_t OpenDrain;	/**&lt; OpenDrain mode, should be:
+						- PINSEL_PINMODE_NORMAL: Pin is in the normal (not open drain) mode
+						- PINSEL_PINMODE_OPENDRAIN: Pin is in the open drain mode */
+} PINSEL_CFG_Type;
+
+/**
+ * @}
+ */
+
+
+/* Public Functions ----------------------------------------------------------- */
+/** @defgroup PINSEL_Public_Functions
+ * @{
+ */
+
+void PINSEL_SetPinFunc ( uint8_t portnum, uint8_t pinnum, uint8_t funcnum);
+void PINSEL_ConfigTraceFunc (FunctionalState NewState);
+void PINSEL_SetResistorMode ( uint8_t portnum, uint8_t pinnum, uint8_t modenum);
+void PINSEL_SetOpenDrainMode( uint8_t portnum, uint8_t pinnum, uint8_t modenum);
+void PINSEL_SetI2C0Pins(uint8_t i2cPinMode, FunctionalState filterSlewRateEnable);
+void PINSEL_ConfigPin(PINSEL_CFG_Type *PinCfg);
+
+/**
+ * @}
+ */
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LPC17XX_PINSEL_H_ */
+
+/**
+ * @}
+ */
+
+/* --------------------------------- End Of File ------------------------------ */
+


Property changes on: trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_pinsel.h
___________________________________________________________________
Deleted: svn:executable
   - *

Modified: trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_pwm.h
===================================================================
--- trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_pwm.h	2010-06-28 21:53:59 UTC (rev 759)
+++ trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_pwm.h	2010-07-12 20:56:54 UTC (rev 760)
@@ -1,336 +1,336 @@
-/***********************************************************************//**
- * @file	: lpc17xx_pwm.h
- * @brief	: Contains all macro definitions and function prototypes
- * 				support for PWM firmware library on LPC17xx
- * @version	: 1.0
- * @date	: 22. Apr. 2009
- * @author	: HieuNguyen
- **************************************************************************
- * Software that is described herein is for illustrative purposes only
- * which provides customers with programming information regarding the
- * products. This software is supplied &quot;AS IS&quot; without any warranties.
- * NXP Semiconductors assumes no responsibility or liability for the
- * use of the software, conveys no license or title under any patent,
- * copyright, or mask work right to the product. NXP Semiconductors
- * reserves the right to make changes in the software without
- * notification. NXP Semiconductors also make no representation or
- * warranty that such application will be suitable for the specified
- * use without further testing or modification.
- **************************************************************************/
-
-/* Peripheral group ----------------------------------------------------------- */
-/** @defgroup PWM
- * @ingroup LPC1700CMSIS_FwLib_Drivers
- * @{
- */
-
-#ifndef LPC17XX_PWM_H_
-#define LPC17XX_PWM_H_
-
-/* Includes ------------------------------------------------------------------- */
-#include &quot;LPC17xx.h&quot;
-#include &quot;lpc_types.h&quot;
-
-
-#ifdef __cplusplus
-extern &quot;C&quot;
-{
-#endif
-
-
-/* Private Macros ------------------------------------------------------------- */
-/** @defgroup PWM_Private_Macros
- * @{
- */
-
-/** @defgroup PWM_REGISTER_BIT_DEFINITIONS
- * @{
- */
-
-/**********************************************************************
-* IR register definitions
-**********************************************************************/
-/** Interrupt flag for PWM match channel for 6 channel */
-#define PWM_IR_PWMMRn(n)    	((uint32_t)((n&lt;4)?(1&lt;&lt;n):(1&lt;&lt;(n+4))))
-/** Interrupt flag for capture input */
-#define PWM_IR_PWMCAPn(n)		((uint32_t)(1&lt;&lt;(n+4)))
-/**  IR register mask */
-#define PWM_IR_BITMASK			((uint32_t)(0x0000073F))
-
-
-/**********************************************************************
-* TCR register definitions
-**********************************************************************/
-/** TCR register mask */
-#define PWM_TCR_BITMASK				((uint32_t)(0x0000000B))
-#define PWM_TCR_COUNTER_ENABLE      ((uint32_t)(1&lt;&lt;0)) /*!&lt; PWM Counter Enable */
-#define PWM_TCR_COUNTER_RESET       ((uint32_t)(1&lt;&lt;1)) /*!&lt; PWM Counter Reset */
-#define PWM_TCR_PWM_ENABLE          ((uint32_t)(1&lt;&lt;3)) /*!&lt; PWM Enable */
-
-
-/**********************************************************************
-* CTCR register definitions
-**********************************************************************/
-/** CTCR register mask */
-#define PWM_CTCR_BITMASK			((uint32_t)(0x0000000F))
-/** PWM Counter-Timer Mode */
-#define PWM_CTCR_MODE(n)        	((uint32_t)(n&amp;0x03))
-/** PWM Capture input select */
-#define PWM_CTCR_SELECT_INPUT(n)	((uint32_t)((n&amp;0x03)&lt;&lt;2))
-
-
-/**********************************************************************
-* MCR register definitions
-**********************************************************************/
-/** MCR register mask */
-#define PWM_MCR_BITMASK				((uint32_t)(0x001FFFFF))
-/** generate a PWM interrupt when a MATCHn occurs */
-#define PWM_MCR_INT_ON_MATCH(n)     ((uint32_t)(1&lt;&lt;(((n&amp;0x7)&lt;&lt;1)+(n&amp;0x07))))
-/** reset the PWM when a MATCHn occurs */
-#define PWM_MCR_RESET_ON_MATCH(n)   ((uint32_t)(1&lt;&lt;(((n&amp;0x7)&lt;&lt;1)+(n&amp;0x07)+1)))
-/** stop the PWM when a MATCHn occurs */
-#define PWM_MCR_STOP_ON_MATCH(n)    ((uint32_t)(1&lt;&lt;(((n&amp;0x7)&lt;&lt;1)+(n&amp;0x07)+2)))
-
-
-/**********************************************************************
-* CCR register definitions
-**********************************************************************/
-/** CCR register mask */
-#define PWM_CCR_BITMASK				((uint32_t)(0x0000003F))
-/** PCAPn is rising edge sensitive */
-#define PWM_CCR_CAP_RISING(n) 	 	((uint32_t)(1&lt;&lt;(((n&amp;0x2)&lt;&lt;1)+(n&amp;0x1))))
-/** PCAPn is falling edge sensitive */
-#define PWM_CCR_CAP_FALLING(n) 		((uint32_t)(1&lt;&lt;(((n&amp;0x2)&lt;&lt;1)+(n&amp;0x1)+1)))
-/** PWM interrupt is generated on a PCAP event */
-#define PWM_CCR_INT_ON_CAP(n)  		((uint32_t)(1&lt;&lt;(((n&amp;0x2)&lt;&lt;1)+(n&amp;0x1)+2)))
-
-
-/**********************************************************************
-* PCR register definitions
-**********************************************************************/
-/** PCR register mask */
-#define PWM_PCR_BITMASK			(uint32_t)0x00007E7C
-/** PWM output n is a single edge controlled output */
-#define PWM_PCR_PWMSELn(n)   	((uint32_t)(((n&amp;0x7)&lt;2) ? 0 : (1&lt;&lt;n)))
-/** enable PWM output n */
-#define PWM_PCR_PWMENAn(n)   	((uint32_t)(((n&amp;0x7)&lt;1) ? 0 : (1&lt;&lt;(n+8))))
-
-
-/**********************************************************************
-* LER register definitions
-**********************************************************************/
-/** LER register mask*/
-#define PWM_LER_BITMASK				((uint32_t)(0x0000007F))
-/** PWM MATCHn register update control */
-#define PWM_LER_EN_MATCHn_LATCH(n)   ((uint32_t)((n&lt;7) ? (1&lt;&lt;n) : 0))
-
-/**
- * @}
- */
-
-/**
- * @}
- */
-
-
-/* Public Types --------------------------------------------------------------- */
-/** @defgroup PWM_Public_Types
- * @{
- */
-
-/** @brief Configuration structure in PWM TIMER mode */
-typedef struct {
-
-	uint8_t PrescaleOption;		/**&lt; Prescale option, should be:
-								- PWM_TIMER_PRESCALE_TICKVAL: Prescale in absolute value
-								- PWM_TIMER_PRESCALE_USVAL: Prescale in microsecond value
-								*/
-	uint8_t Reserved[3];
-	uint32_t PrescaleValue;		/**&lt; Prescale value, 32-bit long, should be matched
-								with PrescaleOption
-								*/
-} PWM_TIMERCFG_Type;
-
-/** @brief Configuration structure in PWM COUNTER mode */
-typedef struct {
-
-	uint8_t CounterOption;		/**&lt; Counter Option, should be:
-								- PWM_COUNTER_RISING: Rising Edge
-								- PWM_COUNTER_FALLING: Falling Edge
-								- PWM_COUNTER_ANY: Both rising and falling mode
-								*/
-	uint8_t CountInputSelect;	/**&lt; Counter input select, should be:
-								- PWM_COUNTER_PCAP1_0: PWM Counter input selected is PCAP1.0 pin
-								- PWM_COUNTER_PCAP1_1: PWM Counter input selected is PCAP1.1 pin
-								*/
-	uint8_t Reserved[2];
-} PWM_COUNTERCFG_Type;
-
-/** @brief PWM Match channel configuration structure */
-typedef struct {
-	uint8_t MatchChannel;	/**&lt; Match channel, should be in range
-							from 0..6 */
-	uint8_t IntOnMatch;		/**&lt; Interrupt On match, should be:
-							- ENABLE: Enable this function.
-							- DISABLE: Disable this function.
-							*/
-	uint8_t StopOnMatch;	/**&lt; Stop On match, should be:
-							- ENABLE: Enable this function.
-							- DISABLE: Disable this function.
-							*/
-	uint8_t ResetOnMatch;	/**&lt; Reset On match, should be:
-							- ENABLE: Enable this function.
-							- DISABLE: Disable this function.
-							*/
-} PWM_MATCHCFG_Type;
-
-
-/** @brief PWM Capture Input configuration structure */
-typedef struct {
-	uint8_t CaptureChannel;	/**&lt; Capture channel, should be in range
-							from 0..1 */
-	uint8_t RisingEdge;		/**&lt; caption rising edge, should be:
-							- ENABLE: Enable rising edge.
-							- DISABLE: Disable this function.
-							*/
-	uint8_t FallingEdge;		/**&lt; caption falling edge, should be:
-							- ENABLE: Enable falling edge.
-							- DISABLE: Disable this function.
-								*/
-	uint8_t IntOnCaption;	/**&lt; Interrupt On caption, should be:
-							- ENABLE: Enable interrupt function.
-							- DISABLE: Disable this function.
-							*/
-} PWM_CAPTURECFG_Type;
-
-
-/** Macro to determine if it is valid PWM peripheral */
-#define PARAM_PWMx(n)	(((uint32_t *)n)==((uint32_t *)PWM1))
-
-#define PARAM_PWM1_MATCH_CHANNEL(n)		((n&gt;=0) &amp;&amp; (n&lt;=6))
-#define PARAM_PWM1_CHANNEL(n)			((n&gt;=1) &amp;&amp; (n&lt;=6))
-#define PARAM_PWM1_EDGE_MODE_CHANNEL(n)			((n&gt;=2) &amp;&amp; (n&lt;=6))
-#define PARAM_PWM1_CAPTURE_CHANNEL(n)	((n==0) || (n==1))
-
-
-/* Timer/Counter in PWM configuration type definition -----------------------------------*/
-
-/** @brief PMW TC mode select option */
-typedef enum {
-	PWM_MODE_TIMER = 0,		/*!&lt; PWM using Timer mode */
-	PWM_MODE_COUNTER,		/*!&lt; PWM using Counter mode */
-} PWM_TC_MODE_OPT;
-
-#define PARAM_PWM_TC_MODE(n) ((n==PWM_MODE_TIMER) || (n==PWM_MODE_COUNTER))
-
-
-/** @brief PWM Timer/Counter prescale option */
-typedef enum
-{
-	PWM_TIMER_PRESCALE_TICKVAL = 0,			/*!&lt; Prescale in absolute value */
-	PWM_TIMER_PRESCALE_USVAL				/*!&lt; Prescale in microsecond value */
-} PWM_TIMER_PRESCALE_OPT;
-
-#define PARAM_PWM_TIMER_PRESCALE(n) ((n==PWM_TIMER_PRESCALE_TICKVAL) || (n==PWM_TIMER_PRESCALE_USVAL))
-
-
-/** @brief PWM Input Select in counter mode */
-typedef enum {
-	PWM_COUNTER_PCAP1_0 = 0,		/*!&lt; PWM Counter input selected is PCAP1.0 pin */
-	PWM_COUNTER_PCAP1_1			/*!&lt; PWM counter input selected is CAP1.1 pin */
-} PWM_COUNTER_INPUTSEL_OPT;
-
-#define PARAM_PWM_COUNTER_INPUTSEL(n) ((n==PWM_COUNTER_PCAP1_0) || (n==PWM_COUNTER_PCAP1_1))
-
-/** @brief PWM Input Edge Option in counter mode */
-typedef enum {
-    PWM_COUNTER_RISING = 1,		/*!&lt; Rising edge mode */
-    PWM_COUNTER_FALLING = 2,	/*!&lt; Falling edge mode */
-    PWM_COUNTER_ANY = 3			/*!&lt; Both rising and falling mode */
-} PWM_COUNTER_EDGE_OPT;
-
-#define PARAM_PWM_COUNTER_EDGE(n)	((n==PWM_COUNTER_RISING) || (n==PWM_COUNTER_FALLING) \
-									|| (n==PWM_COUNTER_ANY))
-
-
-/* PWM configuration type definition ----------------------------------------------------- */
-/** @brief PWM operating mode options */
-typedef enum {
-    PWM_CHANNEL_SINGLE_EDGE,	/*!&lt; PWM Channel Single edge mode */
-    PWM_CHANNEL_DUAL_EDGE		/*!&lt; PWM Channel Dual edge mode */
-} PWM_CHANNEL_EDGE_OPT;
-
-#define PARAM_PWM_CHANNEL_EDGE(n)	((n==PWM_CHANNEL_SINGLE_EDGE) || (n==PWM_CHANNEL_DUAL_EDGE))
-
-
-/** @brief PWM update type */
-typedef enum {
-	PWM_MATCH_UPDATE_NOW = 0,			/**&lt; PWM Match Channel Update Now */
-	PWM_MATCH_UPDATE_NEXT_RST			/**&lt; PWM Match Channel Update on next
-											PWM Counter resetting */
-} PWM_MATCH_UPDATE_OPT;
-
-#define PARAM_PWM_MATCH_UPDATE(n)	((n==PWM_MATCH_UPDATE_NOW) || (n==PWM_MATCH_UPDATE_NEXT_RST))
-
-
-/** @brief PWM interrupt status type definition ----------------------------------------------------- */
-/** @brief PWM Interrupt status type */
-typedef enum
-{
-	PWM_INTSTAT_MR0 = PWM_IR_PWMMRn(0), 	/**&lt; Interrupt flag for PWM match channel 0 */
-	PWM_INTSTAT_MR1 = PWM_IR_PWMMRn(1),		/**&lt; Interrupt flag for PWM match channel 1 */
-	PWM_INTSTAT_MR2 = PWM_IR_PWMMRn(2),		/**&lt; Interrupt flag for PWM match channel 2 */
-	PWM_INTSTAT_MR3 = PWM_IR_PWMMRn(3),		/**&lt; Interrupt flag for PWM match channel 3 */
-	PWM_INTSTAT_CAP0 = PWM_IR_PWMCAPn(0),	/**&lt; Interrupt flag for capture input 0 */
-	PWM_INTSTAT_CAP1 = PWM_IR_PWMCAPn(1),	/**&lt; Interrupt flag for capture input 1 */
-	PWM_INTSTAT_MR4 = PWM_IR_PWMMRn(4),		/**&lt; Interrupt flag for PWM match channel 4 */
-	PWM_INTSTAT_MR6 = PWM_IR_PWMMRn(5),		/**&lt; Interrupt flag for PWM match channel 5 */
-	PWM_INTSTAT_MR5 = PWM_IR_PWMMRn(6),		/**&lt; Interrupt flag for PWM match channel 6 */
-}PWM_INTSTAT_TYPE;
-
-#define PARAM_PWM_INTSTAT(n)	((n==PWM_INTSTAT_MR0) || (n==PWM_INTSTAT_MR1) || (n==PWM_INTSTAT_MR2) \
-						|| (n==PWM_INTSTAT_MR3) || (n==PWM_INTSTAT_MR4) || (n==PWM_INTSTAT_MR5) \
-						|| (n==PWM_INTSTAT_MR6) || (n==PWM_INTSTAT_CAP0) || (n==PWM_INTSTAT_CAP1))
-
-/**
- * @}
- */
-
-
-/* Public Functions ----------------------------------------------------------- */
-/** @defgroup PWM_Public_Functions
- * @{
- */
-
-void PWM_PinConfig(PWM_TypeDef *PWMx, uint8_t PWM_Channel, uint8_t PinselOption);
-IntStatus PWM_GetIntStatus(PWM_TypeDef *PWMx, uint32_t IntFlag);
-void PWM_ClearIntPending(PWM_TypeDef *PWMx, uint32_t IntFlag);
-void PWM_ConfigStructInit(uint8_t PWMTimerCounterMode, void *PWM_InitStruct);
-void PWM_Init(PWM_TypeDef *PWMx, uint32_t PWMTimerCounterMode, void *PWM_ConfigStruct);
-void PWM_DeInit (PWM_TypeDef *PWMx);
-void PWM_Cmd(PWM_TypeDef *PWMx, FunctionalState NewState);
-void PWM_CounterCmd(PWM_TypeDef *PWMx, FunctionalState NewState);
-void PWM_ResetCounter(PWM_TypeDef *PWMx);
-void PWM_ConfigMatch(PWM_TypeDef *PWMx, PWM_MATCHCFG_Type *PWM_MatchConfigStruct);
-void PWM_ConfigCapture(PWM_TypeDef *PWMx, PWM_CAPTURECFG_Type *PWM_CaptureConfigStruct);
-uint32_t PWM_GetCaptureValue(PWM_TypeDef *PWMx, uint8_t CaptureChannel);
-void PWM_MatchUpdate(PWM_TypeDef *PWMx, uint8_t MatchChannel, \
-					uint32_t MatchValue, uint8_t UpdateType);
-void PWM_ChannelConfig(PWM_TypeDef *PWMx, uint8_t PWMChannel, uint8_t ModeOption);
-void PWM_ChannelCmd(PWM_TypeDef *PWMx, uint8_t PWMChannel, FunctionalState NewState);
-
-/**
- * @}
- */
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* LPC17XX_PWM_H_ */
-
-/**
- * @}
- */
-
-/* --------------------------------- End Of File ------------------------------ */
+/***********************************************************************//**
+ * @file	: lpc17xx_pwm.h
+ * @brief	: Contains all macro definitions and function prototypes
+ * 				support for PWM firmware library on LPC17xx
+ * @version	: 1.0
+ * @date	: 22. Apr. 2009
+ * @author	: HieuNguyen
+ **************************************************************************
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * products. This software is supplied &quot;AS IS&quot; without any warranties.
+ * NXP Semiconductors assumes no responsibility or liability for the
+ * use of the software, conveys no license or title under any patent,
+ * copyright, or mask work right to the product. NXP Semiconductors
+ * reserves the right to make changes in the software without
+ * notification. NXP Semiconductors also make no representation or
+ * warranty that such application will be suitable for the specified
+ * use without further testing or modification.
+ **************************************************************************/
+
+/* Peripheral group ----------------------------------------------------------- */
+/** @defgroup PWM
+ * @ingroup LPC1700CMSIS_FwLib_Drivers
+ * @{
+ */
+
+#ifndef LPC17XX_PWM_H_
+#define LPC17XX_PWM_H_
+
+/* Includes ------------------------------------------------------------------- */
+#include &quot;LPC17xx.h&quot;
+#include &quot;lpc_types.h&quot;
+
+
+#ifdef __cplusplus
+extern &quot;C&quot;
+{
+#endif
+
+
+/* Private Macros ------------------------------------------------------------- */
+/** @defgroup PWM_Private_Macros
+ * @{
+ */
+
+/** @defgroup PWM_REGISTER_BIT_DEFINITIONS
+ * @{
+ */
+
+/**********************************************************************
+* IR register definitions
+**********************************************************************/
+/** Interrupt flag for PWM match channel for 6 channel */
+#define PWM_IR_PWMMRn(n)    	((uint32_t)((n&lt;4)?(1&lt;&lt;n):(1&lt;&lt;(n+4))))
+/** Interrupt flag for capture input */
+#define PWM_IR_PWMCAPn(n)		((uint32_t)(1&lt;&lt;(n+4)))
+/**  IR register mask */
+#define PWM_IR_BITMASK			((uint32_t)(0x0000073F))
+
+
+/**********************************************************************
+* TCR register definitions
+**********************************************************************/
+/** TCR register mask */
+#define PWM_TCR_BITMASK				((uint32_t)(0x0000000B))
+#define PWM_TCR_COUNTER_ENABLE      ((uint32_t)(1&lt;&lt;0)) /*!&lt; PWM Counter Enable */
+#define PWM_TCR_COUNTER_RESET       ((uint32_t)(1&lt;&lt;1)) /*!&lt; PWM Counter Reset */
+#define PWM_TCR_PWM_ENABLE          ((uint32_t)(1&lt;&lt;3)) /*!&lt; PWM Enable */
+
+
+/**********************************************************************
+* CTCR register definitions
+**********************************************************************/
+/** CTCR register mask */
+#define PWM_CTCR_BITMASK			((uint32_t)(0x0000000F))
+/** PWM Counter-Timer Mode */
+#define PWM_CTCR_MODE(n)        	((uint32_t)(n&amp;0x03))
+/** PWM Capture input select */
+#define PWM_CTCR_SELECT_INPUT(n)	((uint32_t)((n&amp;0x03)&lt;&lt;2))
+
+
+/**********************************************************************
+* MCR register definitions
+**********************************************************************/
+/** MCR register mask */
+#define PWM_MCR_BITMASK				((uint32_t)(0x001FFFFF))
+/** generate a PWM interrupt when a MATCHn occurs */
+#define PWM_MCR_INT_ON_MATCH(n)     ((uint32_t)(1&lt;&lt;(((n&amp;0x7)&lt;&lt;1)+(n&amp;0x07))))
+/** reset the PWM when a MATCHn occurs */
+#define PWM_MCR_RESET_ON_MATCH(n)   ((uint32_t)(1&lt;&lt;(((n&amp;0x7)&lt;&lt;1)+(n&amp;0x07)+1)))
+/** stop the PWM when a MATCHn occurs */
+#define PWM_MCR_STOP_ON_MATCH(n)    ((uint32_t)(1&lt;&lt;(((n&amp;0x7)&lt;&lt;1)+(n&amp;0x07)+2)))
+
+
+/**********************************************************************
+* CCR register definitions
+**********************************************************************/
+/** CCR register mask */
+#define PWM_CCR_BITMASK				((uint32_t)(0x0000003F))
+/** PCAPn is rising edge sensitive */
+#define PWM_CCR_CAP_RISING(n) 	 	((uint32_t)(1&lt;&lt;(((n&amp;0x2)&lt;&lt;1)+(n&amp;0x1))))
+/** PCAPn is falling edge sensitive */
+#define PWM_CCR_CAP_FALLING(n) 		((uint32_t)(1&lt;&lt;(((n&amp;0x2)&lt;&lt;1)+(n&amp;0x1)+1)))
+/** PWM interrupt is generated on a PCAP event */
+#define PWM_CCR_INT_ON_CAP(n)  		((uint32_t)(1&lt;&lt;(((n&amp;0x2)&lt;&lt;1)+(n&amp;0x1)+2)))
+
+
+/**********************************************************************
+* PCR register definitions
+**********************************************************************/
+/** PCR register mask */
+#define PWM_PCR_BITMASK			(uint32_t)0x00007E7C
+/** PWM output n is a single edge controlled output */
+#define PWM_PCR_PWMSELn(n)   	((uint32_t)(((n&amp;0x7)&lt;2) ? 0 : (1&lt;&lt;n)))
+/** enable PWM output n */
+#define PWM_PCR_PWMENAn(n)   	((uint32_t)(((n&amp;0x7)&lt;1) ? 0 : (1&lt;&lt;(n+8))))
+
+
+/**********************************************************************
+* LER register definitions
+**********************************************************************/
+/** LER register mask*/
+#define PWM_LER_BITMASK				((uint32_t)(0x0000007F))
+/** PWM MATCHn register update control */
+#define PWM_LER_EN_MATCHn_LATCH(n)   ((uint32_t)((n&lt;7) ? (1&lt;&lt;n) : 0))
+
+/**
+ * @}
+ */
+
+/**
+ * @}
+ */
+
+
+/* Public Types --------------------------------------------------------------- */
+/** @defgroup PWM_Public_Types
+ * @{
+ */
+
+/** @brief Configuration structure in PWM TIMER mode */
+typedef struct {
+
+	uint8_t PrescaleOption;		/**&lt; Prescale option, should be:
+								- PWM_TIMER_PRESCALE_TICKVAL: Prescale in absolute value
+								- PWM_TIMER_PRESCALE_USVAL: Prescale in microsecond value
+								*/
+	uint8_t Reserved[3];
+	uint32_t PrescaleValue;		/**&lt; Prescale value, 32-bit long, should be matched
+								with PrescaleOption
+								*/
+} PWM_TIMERCFG_Type;
+
+/** @brief Configuration structure in PWM COUNTER mode */
+typedef struct {
+
+	uint8_t CounterOption;		/**&lt; Counter Option, should be:
+								- PWM_COUNTER_RISING: Rising Edge
+								- PWM_COUNTER_FALLING: Falling Edge
+								- PWM_COUNTER_ANY: Both rising and falling mode
+								*/
+	uint8_t CountInputSelect;	/**&lt; Counter input select, should be:
+								- PWM_COUNTER_PCAP1_0: PWM Counter input selected is PCAP1.0 pin
+								- PWM_COUNTER_PCAP1_1: PWM Counter input selected is PCAP1.1 pin
+								*/
+	uint8_t Reserved[2];
+} PWM_COUNTERCFG_Type;
+
+/** @brief PWM Match channel configuration structure */
+typedef struct {
+	uint8_t MatchChannel;	/**&lt; Match channel, should be in range
+							from 0..6 */
+	uint8_t IntOnMatch;		/**&lt; Interrupt On match, should be:
+							- ENABLE: Enable this function.
+							- DISABLE: Disable this function.
+							*/
+	uint8_t StopOnMatch;	/**&lt; Stop On match, should be:
+							- ENABLE: Enable this function.
+							- DISABLE: Disable this function.
+							*/
+	uint8_t ResetOnMatch;	/**&lt; Reset On match, should be:
+							- ENABLE: Enable this function.
+							- DISABLE: Disable this function.
+							*/
+} PWM_MATCHCFG_Type;
+
+
+/** @brief PWM Capture Input configuration structure */
+typedef struct {
+	uint8_t CaptureChannel;	/**&lt; Capture channel, should be in range
+							from 0..1 */
+	uint8_t RisingEdge;		/**&lt; caption rising edge, should be:
+							- ENABLE: Enable rising edge.
+							- DISABLE: Disable this function.
+							*/
+	uint8_t FallingEdge;		/**&lt; caption falling edge, should be:
+							- ENABLE: Enable falling edge.
+							- DISABLE: Disable this function.
+								*/
+	uint8_t IntOnCaption;	/**&lt; Interrupt On caption, should be:
+							- ENABLE: Enable interrupt function.
+							- DISABLE: Disable this function.
+							*/
+} PWM_CAPTURECFG_Type;
+
+
+/** Macro to determine if it is valid PWM peripheral */
+#define PARAM_PWMx(n)	(((uint32_t *)n)==((uint32_t *)LPC_PWM1))
+
+#define PARAM_PWM1_MATCH_CHANNEL(n)		((n&gt;=0) &amp;&amp; (n&lt;=6))
+#define PARAM_PWM1_CHANNEL(n)			((n&gt;=1) &amp;&amp; (n&lt;=6))
+#define PARAM_PWM1_EDGE_MODE_CHANNEL(n)			((n&gt;=2) &amp;&amp; (n&lt;=6))
+#define PARAM_PWM1_CAPTURE_CHANNEL(n)	((n==0) || (n==1))
+
+
+/* Timer/Counter in PWM configuration type definition -----------------------------------*/
+
+/** @brief PMW TC mode select option */
+typedef enum {
+	PWM_MODE_TIMER = 0,		/*!&lt; PWM using Timer mode */
+	PWM_MODE_COUNTER,		/*!&lt; PWM using Counter mode */
+} PWM_TC_MODE_OPT;
+
+#define PARAM_PWM_TC_MODE(n) ((n==PWM_MODE_TIMER) || (n==PWM_MODE_COUNTER))
+
+
+/** @brief PWM Timer/Counter prescale option */
+typedef enum
+{
+	PWM_TIMER_PRESCALE_TICKVAL = 0,			/*!&lt; Prescale in absolute value */
+	PWM_TIMER_PRESCALE_USVAL				/*!&lt; Prescale in microsecond value */
+} PWM_TIMER_PRESCALE_OPT;
+
+#define PARAM_PWM_TIMER_PRESCALE(n) ((n==PWM_TIMER_PRESCALE_TICKVAL) || (n==PWM_TIMER_PRESCALE_USVAL))
+
+
+/** @brief PWM Input Select in counter mode */
+typedef enum {
+	PWM_COUNTER_PCAP1_0 = 0,		/*!&lt; PWM Counter input selected is PCAP1.0 pin */
+	PWM_COUNTER_PCAP1_1			/*!&lt; PWM counter input selected is CAP1.1 pin */
+} PWM_COUNTER_INPUTSEL_OPT;
+
+#define PARAM_PWM_COUNTER_INPUTSEL(n) ((n==PWM_COUNTER_PCAP1_0) || (n==PWM_COUNTER_PCAP1_1))
+
+/** @brief PWM Input Edge Option in counter mode */
+typedef enum {
+    PWM_COUNTER_RISING = 1,		/*!&lt; Rising edge mode */
+    PWM_COUNTER_FALLING = 2,	/*!&lt; Falling edge mode */
+    PWM_COUNTER_ANY = 3			/*!&lt; Both rising and falling mode */
+} PWM_COUNTER_EDGE_OPT;
+
+#define PARAM_PWM_COUNTER_EDGE(n)	((n==PWM_COUNTER_RISING) || (n==PWM_COUNTER_FALLING) \
+|| (n==PWM_COUNTER_ANY))
+
+
+/* PWM configuration type definition ----------------------------------------------------- */
+/** @brief PWM operating mode options */
+typedef enum {
+    PWM_CHANNEL_SINGLE_EDGE,	/*!&lt; PWM Channel Single edge mode */
+    PWM_CHANNEL_DUAL_EDGE		/*!&lt; PWM Channel Dual edge mode */
+} PWM_CHANNEL_EDGE_OPT;
+
+#define PARAM_PWM_CHANNEL_EDGE(n)	((n==PWM_CHANNEL_SINGLE_EDGE) || (n==PWM_CHANNEL_DUAL_EDGE))
+
+
+/** @brief PWM update type */
+typedef enum {
+	PWM_MATCH_UPDATE_NOW = 0,			/**&lt; PWM Match Channel Update Now */
+	PWM_MATCH_UPDATE_NEXT_RST			/**&lt; PWM Match Channel Update on next
+											PWM Counter resetting */
+} PWM_MATCH_UPDATE_OPT;
+
+#define PARAM_PWM_MATCH_UPDATE(n)	((n==PWM_MATCH_UPDATE_NOW) || (n==PWM_MATCH_UPDATE_NEXT_RST))
+
+
+/** @brief PWM interrupt status type definition ----------------------------------------------------- */
+/** @brief PWM Interrupt status type */
+typedef enum
+{
+	PWM_INTSTAT_MR0 = PWM_IR_PWMMRn(0), 	/**&lt; Interrupt flag for PWM match channel 0 */
+	PWM_INTSTAT_MR1 = PWM_IR_PWMMRn(1),		/**&lt; Interrupt flag for PWM match channel 1 */
+	PWM_INTSTAT_MR2 = PWM_IR_PWMMRn(2),		/**&lt; Interrupt flag for PWM match channel 2 */
+	PWM_INTSTAT_MR3 = PWM_IR_PWMMRn(3),		/**&lt; Interrupt flag for PWM match channel 3 */
+	PWM_INTSTAT_CAP0 = PWM_IR_PWMCAPn(0),	/**&lt; Interrupt flag for capture input 0 */
+	PWM_INTSTAT_CAP1 = PWM_IR_PWMCAPn(1),	/**&lt; Interrupt flag for capture input 1 */
+	PWM_INTSTAT_MR4 = PWM_IR_PWMMRn(4),		/**&lt; Interrupt flag for PWM match channel 4 */
+	PWM_INTSTAT_MR6 = PWM_IR_PWMMRn(5),		/**&lt; Interrupt flag for PWM match channel 5 */
+	PWM_INTSTAT_MR5 = PWM_IR_PWMMRn(6),		/**&lt; Interrupt flag for PWM match channel 6 */
+}PWM_INTSTAT_TYPE;
+
+#define PARAM_PWM_INTSTAT(n)	((n==PWM_INTSTAT_MR0) || (n==PWM_INTSTAT_MR1) || (n==PWM_INTSTAT_MR2) \
+|| (n==PWM_INTSTAT_MR3) || (n==PWM_INTSTAT_MR4) || (n==PWM_INTSTAT_MR5) \
+|| (n==PWM_INTSTAT_MR6) || (n==PWM_INTSTAT_CAP0) || (n==PWM_INTSTAT_CAP1))
+
+/**
+ * @}
+ */
+
+
+/* Public Functions ----------------------------------------------------------- */
+/** @defgroup PWM_Public_Functions
+ * @{
+ */
+
+void PWM_PinConfig(LPC_PWM_TypeDef *PWMx, uint8_t PWM_Channel, uint8_t PinselOption);
+IntStatus PWM_GetIntStatus(LPC_PWM_TypeDef *PWMx, uint32_t IntFlag);
+void PWM_ClearIntPending(LPC_PWM_TypeDef *PWMx, uint32_t IntFlag);
+void PWM_ConfigStructInit(uint8_t PWMTimerCounterMode, void *PWM_InitStruct);
+void PWM_Init(LPC_PWM_TypeDef *PWMx, uint32_t PWMTimerCounterMode, void *PWM_ConfigStruct);
+void PWM_DeInit (LPC_PWM_TypeDef *PWMx);
+void PWM_Cmd(LPC_PWM_TypeDef *PWMx, FunctionalState NewState);
+void PWM_CounterCmd(LPC_PWM_TypeDef *PWMx, FunctionalState NewState);
+void PWM_ResetCounter(LPC_PWM_TypeDef *PWMx);
+void PWM_ConfigMatch(LPC_PWM_TypeDef *PWMx, PWM_MATCHCFG_Type *PWM_MatchConfigStruct);
+void PWM_ConfigCapture(LPC_PWM_TypeDef *PWMx, PWM_CAPTURECFG_Type *PWM_CaptureConfigStruct);
+uint32_t PWM_GetCaptureValue(LPC_PWM_TypeDef *PWMx, uint8_t CaptureChannel);
+void PWM_MatchUpdate(LPC_PWM_TypeDef *PWMx, uint8_t MatchChannel, \
+					uint32_t MatchValue, uint8_t UpdateType);
+void PWM_ChannelConfig(LPC_PWM_TypeDef *PWMx, uint8_t PWMChannel, uint8_t ModeOption);
+void PWM_ChannelCmd(LPC_PWM_TypeDef *PWMx, uint8_t PWMChannel, FunctionalState NewState);
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LPC17XX_PWM_H_ */
+
+/**
+ * @}
+ */
+
+/* --------------------------------- End Of File ------------------------------ */


Property changes on: trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_pwm.h
___________________________________________________________________
Deleted: svn:executable
   - *

Modified: trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_qei.h
===================================================================
--- trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_qei.h	2010-06-28 21:53:59 UTC (rev 759)
+++ trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_qei.h	2010-07-12 20:56:54 UTC (rev 760)
@@ -1,414 +1,414 @@
-/***********************************************************************//**
- * @file	: lpc17xx_qei.h
- * @brief	: Contains all macro definitions and function prototypes
- * 				support for QEI firmware library on LPC17xx
- * @version	: 1.0
- * @date	: 26. May. 2009
- * @author	: HieuNguyen
- **************************************************************************
- * Software that is described herein is for illustrative purposes only
- * which provides customers with programming information regarding the
- * products. This software is supplied &quot;AS IS&quot; without any warranties.
- * NXP Semiconductors assumes no responsibility or liability for the
- * use of the software, conveys no license or title under any patent,
- * copyright, or mask work right to the product. NXP Semiconductors
- * reserves the right to make changes in the software without
- * notification. NXP Semiconductors also make no representation or
- * warranty that such application will be suitable for the specified
- * use without further testing or modification.
- **************************************************************************/
-
-/* Peripheral group ----------------------------------------------------------- */
-/** @defgroup QEI
- * @ingroup LPC1700CMSIS_FwLib_Drivers
- * @{
- */
-
-#ifndef LPC17XX_QEI_H_
-#define LPC17XX_QEI_H_
-
-/* Includes ------------------------------------------------------------------- */
-#include &quot;LPC17xx.h&quot;
-#include &quot;lpc_types.h&quot;
-
-
-#ifdef __cplusplus
-extern &quot;C&quot;
-{
-#endif
-
-
-/* Private Macros ------------------------------------------------------------- */
-/** @defgroup QEI_Private_Macros
- * @{
- */
-
-/** @defgroup QEI_REGISTER_BIT_DEFINITIONS
- * @{
- */
-
-/* Quadrature Encoder Interface Control Register Definition --------------------- */
-/* QEI Control register */
-#define QEI_CON_RESP		((uint32_t)(1&lt;&lt;0))		/**&lt; Reset position counter */
-#define QEI_CON_RESPI		((uint32_t)(1&lt;&lt;1))		/**&lt; Reset Posistion Counter on Index */
-#define QEI_CON_RESV		((uint32_t)(1&lt;&lt;2))		/**&lt; Reset Velocity */
-#define QEI_CON_RESI		((uint32_t)(1&lt;&lt;3))		/**&lt; Reset Index Counter */
-#define QEI_CON_BITMASK		((uint32_t)(0x0F))		/**&lt; QEI Control register bit-mask */
-
-/* QEI Configuration register */
-#define QEI_CONF_DIRINV		((uint32_t)(1&lt;&lt;0))		/**&lt; Direction Invert */
-#define QEI_CONF_SIGMODE	((uint32_t)(1&lt;&lt;1))		/**&lt; Signal mode */
-#define QEI_CONF_CAPMODE	((uint32_t)(1&lt;&lt;2))		/**&lt; Capture mode */
-#define QEI_CONF_INVINX		((uint32_t)(1&lt;&lt;3))		/**&lt; Invert index */
-#define QEI_CONF_BITMASK	((uint32_t)(0x0F))		/**&lt; QEI Configuration register bit-mask */
-
-/* QEI Status register */
-#define QEI_STAT_DIR		((uint32_t)(1&lt;&lt;0))		/**&lt; Direction bit */
-#define QEI_STAT_BITMASK	((uint32_t)(1&lt;&lt;0))		/**&lt; QEI status register bit-mask */
-
-/* Quadrature Encoder Interface Position, index and timer Register Definitions --- */
-/* QEI Position register */
-
-/* QEI Maximum Position register */
-
-/* QEI Position Compare register 0 */
-
-/* QEI Position Compare register 1 */
-
-/* QEI Position Compare register 2 */
-
-/* QEI Index Count register */
-
-/* QEI Index Compare register */
-
-/* QEI Timer Reload register */
-
-/* QEI Timer register */
-
-/* QEI Velocity register */
-
-/* QEI Velocity Capture register */
-
-/* QEI Velocity Compare register */
-
-/* QEI Digital Filter register */
-
-/* Quadrature Encoder Interface Interrupt registers definitions --------------------- */
-/* QEI Interrupt Status register */
-#define QEI_INTSTAT_INX_Int			((uint32_t)(1&lt;&lt;0))	/**&lt; Indicates that an index pulse was detected */
-#define QEI_INTSTAT_TIM_Int			((uint32_t)(1&lt;&lt;1))	/**&lt; Indicates that a velocity timer overflow occurred */
-#define QEI_INTSTAT_VELC_Int		((uint32_t)(1&lt;&lt;2))	/**&lt; Indicates that capture velocity is less than compare velocity */
-#define QEI_INTSTAT_DIR_Int			((uint32_t)(1&lt;&lt;3))	/**&lt; Indicates that a change of direction was detected */
-#define QEI_INTSTAT_ERR_Int			((uint32_t)(1&lt;&lt;4))	/**&lt; Indicates that an encoder phase error was detected */
-#define QEI_INTSTAT_ENCLK_Int		((uint32_t)(1&lt;&lt;5))	/**&lt; Indicates that and encoder clock pulse was detected */
-#define QEI_INTSTAT_POS0_Int		((uint32_t)(1&lt;&lt;6))	/**&lt; Indicates that the position 0 compare value is equal to the
-														current position */
-#define QEI_INTSTAT_POS1_Int		((uint32_t)(1&lt;&lt;7))	/**&lt; Indicates that the position 1compare value is equal to the
-														current position */
-#define QEI_INTSTAT_POS2_Int		((uint32_t)(1&lt;&lt;8))	/**&lt; Indicates that the position 2 compare value is equal to the
-														current position */
-#define QEI_INTSTAT_REV_Int			((uint32_t)(1&lt;&lt;9))	/**&lt; Indicates that the index compare value is equal to the current
-														index count */
-#define QEI_INTSTAT_POS0REV_Int		((uint32_t)(1&lt;&lt;10))	/**&lt; Combined position 0 and revolution count interrupt. Set when
-														both the POS0_Int bit is set and the REV_Int is set */
-#define QEI_INTSTAT_POS1REV_Int		((uint32_t)(1&lt;&lt;11))	/**&lt; Combined position 1 and revolution count interrupt. Set when
-														both the POS1_Int bit is set and the REV_Int is set */
-#define QEI_INTSTAT_POS2REV_Int		((uint32_t)(1&lt;&lt;12))	/**&lt; Combined position 2 and revolution count interrupt. Set when
-														both the POS2_Int bit is set and the REV_Int is set */
-#define QEI_INTSTAT_BITMASK			((uint32_t)(0x1FFF))	/**&lt; QEI Interrupt Status register bit-mask */
-
-/* QEI Interrupt Set register */
-#define QEI_INTSET_INX_Int			((uint32_t)(1&lt;&lt;0))	/**&lt; Set Bit Indicates that an index pulse was detected */
-#define QEI_INTSET_TIM_Int			((uint32_t)(1&lt;&lt;1))	/**&lt; Set Bit Indicates that a velocity timer overflow occurred */
-#define QEI_INTSET_VELC_Int			((uint32_t)(1&lt;&lt;2))	/**&lt; Set Bit Indicates that capture velocity is less than compare velocity */
-#define QEI_INTSET_DIR_Int			((uint32_t)(1&lt;&lt;3))	/**&lt; Set Bit Indicates that a change of direction was detected */
-#define QEI_INTSET_ERR_Int			((uint32_t)(1&lt;&lt;4))	/**&lt; Set Bit Indicates that an encoder phase error was detected */
-#define QEI_INTSET_ENCLK_Int		((uint32_t)(1&lt;&lt;5))	/**&lt; Set Bit Indicates that and encoder clock pulse was detected */
-#define QEI_INTSET_POS0_Int			((uint32_t)(1&lt;&lt;6))	/**&lt; Set Bit Indicates that the position 0 compare value is equal to the
-														current position */
-#define QEI_INTSET_POS1_Int			((uint32_t)(1&lt;&lt;7))	/**&lt; Set Bit Indicates that the position 1compare value is equal to the
-														current position */
-#define QEI_INTSET_POS2_Int			((uint32_t)(1&lt;&lt;8))	/**&lt; Set Bit Indicates that the position 2 compare value is equal to the
-														current position */
-#define QEI_INTSET_REV_Int			((uint32_t)(1&lt;&lt;9))	/**&lt; Set Bit Indicates that the index compare value is equal to the current
-														index count */
-#define QEI_INTSET_POS0REV_Int		((uint32_t)(1&lt;&lt;10))	/**&lt; Set Bit that combined position 0 and revolution count interrupt */
-#define QEI_INTSET_POS1REV_Int		((uint32_t)(1&lt;&lt;11))	/**&lt; Set Bit that Combined position 1 and revolution count interrupt */
-#define QEI_INTSET_POS2REV_Int		((uint32_t)(1&lt;&lt;12))	/**&lt; Set Bit that Combined position 2 and revolution count interrupt */
-#define QEI_INTSET_BITMASK			((uint32_t)(0x1FFF))	/**&lt; QEI Interrupt Set register bit-mask */
-
-/* QEI Interrupt Clear register */
-#define QEI_INTCLR_INX_Int			((uint32_t)(1&lt;&lt;0))	/**&lt; Clear Bit Indicates that an index pulse was detected */
-#define QEI_INTCLR_TIM_Int			((uint32_t)(1&lt;&lt;1))	/**&lt; Clear Bit Indicates that a velocity timer overflow occurred */
-#define QEI_INTCLR_VELC_Int			((uint32_t)(1&lt;&lt;2))	/**&lt; Clear Bit Indicates that capture velocity is less than compare velocity */
-#define QEI_INTCLR_DIR_Int			((uint32_t)(1&lt;&lt;3))	/**&lt; Clear Bit Indicates that a change of direction was detected */
-#define QEI_INTCLR_ERR_Int			((uint32_t)(1&lt;&lt;4))	/**&lt; Clear Bit Indicates that an encoder phase error was detected */
-#define QEI_INTCLR_ENCLK_Int		((uint32_t)(1&lt;&lt;5))	/**&lt; Clear Bit Indicates that and encoder clock pulse was detected */
-#define QEI_INTCLR_POS0_Int			((uint32_t)(1&lt;&lt;6))	/**&lt; Clear Bit Indicates that the position 0 compare value is equal to the
-														current position */
-#define QEI_INTCLR_POS1_Int			((uint32_t)(1&lt;&lt;7))	/**&lt; Clear Bit Indicates that the position 1compare value is equal to the
-														current position */
-#define QEI_INTCLR_POS2_Int			((uint32_t)(1&lt;&lt;8))	/**&lt; Clear Bit Indicates that the position 2 compare value is equal to the
-														current position */
-#define QEI_INTCLR_REV_Int			((uint32_t)(1&lt;&lt;9))	/**&lt; Clear Bit Indicates that the index compare value is equal to the current
-														index count */
-#define QEI_INTCLR_POS0REV_Int		((uint32_t)(1&lt;&lt;10))	/**&lt; Clear Bit that combined position 0 and revolution count interrupt */
-#define QEI_INTCLR_POS1REV_Int		((uint32_t)(1&lt;&lt;11))	/**&lt; Clear Bit that Combined position 1 and revolution count interrupt */
-#define QEI_INTCLR_POS2REV_Int		((uint32_t)(1&lt;&lt;12))	/**&lt; Clear Bit that Combined position 2 and revolution count interrupt */
-#define QEI_INTCLR_BITMASK			((uint32_t)(0x1FFF))	/**&lt; QEI Interrupt Clear register bit-mask */
-
-/* QEI Interrupt Enable register */
-#define QEI_INTEN_INX_Int			((uint32_t)(1&lt;&lt;0))	/**&lt; Enabled Interrupt Bit Indicates that an index pulse was detected */
-#define QEI_INTEN_TIM_Int			((uint32_t)(1&lt;&lt;1))	/**&lt; Enabled Interrupt Bit Indicates that a velocity timer overflow occurred */
-#define QEI_INTEN_VELC_Int			((uint32_t)(1&lt;&lt;2))	/**&lt; Enabled Interrupt Bit Indicates that capture velocity is less than compare velocity */
-#define QEI_INTEN_DIR_Int			((uint32_t)(1&lt;&lt;3))	/**&lt; Enabled Interrupt Bit Indicates that a change of direction was detected */
-#define QEI_INTEN_ERR_Int			((uint32_t)(1&lt;&lt;4))	/**&lt; Enabled Interrupt Bit Indicates that an encoder phase error was detected */
-#define QEI_INTEN_ENCLK_Int			((uint32_t)(1&lt;&lt;5))	/**&lt; Enabled Interrupt Bit Indicates that and encoder clock pulse was detected */
-#define QEI_INTEN_POS0_Int			((uint32_t)(1&lt;&lt;6))	/**&lt; Enabled Interrupt Bit Indicates that the position 0 compare value is equal to the
-														current position */
-#define QEI_INTEN_POS1_Int			((uint32_t)(1&lt;&lt;7))	/**&lt; Enabled Interrupt Bit Indicates that the position 1compare value is equal to the
-														current position */
-#define QEI_INTEN_POS2_Int			((uint32_t)(1&lt;&lt;8))	/**&lt; Enabled Interrupt Bit Indicates that the position 2 compare value is equal to the
-														current position */
-#define QEI_INTEN_REV_Int			((uint32_t)(1&lt;&lt;9))	/**&lt; Enabled Interrupt Bit Indicates that the index compare value is equal to the current
-														index count */
-#define QEI_INTEN_POS0REV_Int		((uint32_t)(1&lt;&lt;10))	/**&lt; Enabled Interrupt Bit that combined position 0 and revolution count interrupt */
-#define QEI_INTEN_POS1REV_Int		((uint32_t)(1&lt;&lt;11))	/**&lt; Enabled Interrupt Bit that Combined position 1 and revolution count interrupt */
-#define QEI_INTEN_POS2REV_Int		((uint32_t)(1&lt;&lt;12))	/**&lt; Enabled Interrupt Bit that Combined position 2 and revolution count interrupt */
-#define QEI_INTEN_BITMASK			((uint32_t)(0x1FFF))	/**&lt; QEI Interrupt Enable register bit-mask */
-
-/* QEI Interrupt Enable Set register */
-#define QEI_IESET_INX_Int			((uint32_t)(1&lt;&lt;0))	/**&lt; Set Enable Interrupt Bit Indicates that an index pulse was detected */
-#define QEI_IESET_TIM_Int			((uint32_t)(1&lt;&lt;1))	/**&lt; Set Enable Interrupt Bit Indicates that a velocity timer overflow occurred */
-#define QEI_IESET_VELC_Int			((uint32_t)(1&lt;&lt;2))	/**&lt; Set Enable Interrupt Bit Indicates that capture velocity is less than compare velocity */
-#define QEI_IESET_DIR_Int			((uint32_t)(1&lt;&lt;3))	/**&lt; Set Enable Interrupt Bit Indicates that a change of direction was detected */
-#define QEI_IESET_ERR_Int			((uint32_t)(1&lt;&lt;4))	/**&lt; Set Enable Interrupt Bit Indicates that an encoder phase error was detected */
-#define QEI_IESET_ENCLK_Int			((uint32_t)(1&lt;&lt;5))	/**&lt; Set Enable Interrupt Bit Indicates that and encoder clock pulse was detected */
-#define QEI_IESET_POS0_Int			((uint32_t)(1&lt;&lt;6))	/**&lt; Set Enable Interrupt Bit Indicates that the position 0 compare value is equal to the
-														current position */
-#define QEI_IESET_POS1_Int			((uint32_t)(1&lt;&lt;7))	/**&lt; Set Enable Interrupt Bit Indicates that the position 1compare value is equal to the
-														current position */
-#define QEI_IESET_POS2_Int			((uint32_t)(1&lt;&lt;8))	/**&lt; Set Enable Interrupt Bit Indicates that the position 2 compare value is equal to the
-														current position */
-#define QEI_IESET_REV_Int			((uint32_t)(1&lt;&lt;9))	/**&lt; Set Enable Interrupt Bit Indicates that the index compare value is equal to the current
-														index count */
-#define QEI_IESET_POS0REV_Int		((uint32_t)(1&lt;&lt;10))	/**&lt; Set Enable Interrupt Bit that combined position 0 and revolution count interrupt */
-#define QEI_IESET_POS1REV_Int		((uint32_t)(1&lt;&lt;11))	/**&lt; Set Enable Interrupt Bit that Combined position 1 and revolution count interrupt */
-#define QEI_IESET_POS2REV_Int		((uint32_t)(1&lt;&lt;12))	/**&lt; Set Enable Interrupt Bit that Combined position 2 and revolution count interrupt */
-#define QEI_IESET_BITMASK			((uint32_t)(0x1FFF))	/**&lt; QEI Interrupt Enable Set register bit-mask */
-
-/* QEI Interrupt Enable Clear register */
-#define QEI_IECLR_INX_Int			((uint32_t)(1&lt;&lt;0))	/**&lt; Clear Enabled Interrupt Bit Indicates that an index pulse was detected */
-#define QEI_IECLR_TIM_Int			((uint32_t)(1&lt;&lt;1))	/**&lt; Clear Enabled Interrupt Bit Indicates that a velocity timer overflow occurred */
-#define QEI_IECLR_VELC_Int			((uint32_t)(1&lt;&lt;2))	/**&lt; Clear Enabled Interrupt Bit Indicates that capture velocity is less than compare velocity */
-#define QEI_IECLR_DIR_Int			((uint32_t)(1&lt;&lt;3))	/**&lt; Clear Enabled Interrupt Bit Indicates that a change of direction was detected */
-#define QEI_IECLR_ERR_Int			((uint32_t)(1&lt;&lt;4))	/**&lt; Clear Enabled Interrupt Bit Indicates that an encoder phase error was detected */
-#define QEI_IECLR_ENCLK_Int			((uint32_t)(1&lt;&lt;5))	/**&lt; Clear Enabled Interrupt Bit Indicates that and encoder clock pulse was detected */
-#define QEI_IECLR_POS0_Int			((uint32_t)(1&lt;&lt;6))	/**&lt; Clear Enabled Interrupt Bit Indicates that the position 0 compare value is equal to the
-														current position */
-#define QEI_IECLR_POS1_Int			((uint32_t)(1&lt;&lt;7))	/**&lt; Clear Enabled Interrupt Bit Indicates that the position 1compare value is equal to the
-														current position */
-#define QEI_IECLR_POS2_Int			((uint32_t)(1&lt;&lt;8))	/**&lt; Clear Enabled Interrupt Bit Indicates that the position 2 compare value is equal to the
-														current position */
-#define QEI_IECLR_REV_Int			((uint32_t)(1&lt;&lt;9))	/**&lt; Clear Enabled Interrupt Bit Indicates that the index compare value is equal to the current
-														index count */
-#define QEI_IECLR_POS0REV_Int		((uint32_t)(1&lt;&lt;10))	/**&lt; Clear Enabled Interrupt Bit that combined position 0 and revolution count interrupt */
-#define QEI_IECLR_POS1REV_Int		((uint32_t)(1&lt;&lt;11))	/**&lt; Clear Enabled Interrupt Bit that Combined position 1 and revolution count interrupt */
-#define QEI_IECLR_POS2REV_Int		((uint32_t)(1&lt;&lt;12))	/**&lt; Clear Enabled Interrupt Bit that Combined position 2 and revolution count interrupt */
-#define QEI_IECLR_BITMASK			((uint32_t)(0x1FFF))	/**&lt; QEI Interrupt Enable Clear register bit-mask */
-
-
-/**
- * @}
- */
-
-/**
- * @}
- */
-
-
-/* Public Types --------------------------------------------------------------- */
-/** @defgroup QEI_Public_Types
- * @{
- */
-
-/**
- * @brief QEI Configuration structure type definition
- */
-typedef struct {
-	uint32_t DirectionInvert	:1; 	/**&lt; Direction invert option:
-										- QEI_DIRINV_NONE: QEI Direction is normal
-										- QEI_DIRINV_CMPL: QEI Direction is complemented
-										*/
-	uint32_t SignalMode			:1; 	/**&lt; Signal mode Option:
-										- QEI_SIGNALMODE_QUAD: Signal is in Quadrature phase mode
-										- QEI_SIGNALMODE_CLKDIR: Signal is in Clock/Direction mode
-										*/
-	uint32_t CaptureMode		:1;		/**&lt; Capture Mode Option:
-										- QEI_CAPMODE_2X: Only Phase-A edges are counted (2X)
-										- QEI_CAPMODE_4X: BOTH Phase-A and Phase-B edges are counted (4X)
-										*/
-	uint32_t InvertIndex		:1; 	/**&lt; Invert Index Option:
-										- QEI_INVINX_NONE: the sense of the index input is normal
-										- QEI_INVINX_EN: inverts the sense of the index input
-										*/
-} QEI_CFG_Type;
-
-/**
- * @brief Timer Reload Configuration structure type definition
- */
-typedef struct {
-
-	uint8_t ReloadOption;		/**&lt; Velocity Timer Reload Option, should be:
-								- QEI_TIMERRELOAD_TICKVAL: Reload value in absolute value
-								- QEI_TIMERRELOAD_USVAL: Reload value in microsecond value
-								*/
-	uint8_t Reserved[3];
-	uint32_t ReloadValue;		/**&lt; Velocity Timer Reload Value, 32-bit long, should be matched
-								with Velocity Timer Reload Option
-								*/
-} QEI_RELOADCFG_Type;
-
-/**
- * @}
- */
-
-
-/* Public Macros -------------------------------------------------------------- */
-/** @defgroup QEI_Public_Macros
- * @{
- */
-
-#define PARAM_QEIx(n)	((n==QEI))
-
-/* QEI Reset types */
-#define QEI_RESET_POS			QEI_CON_RESP		/**&lt; Reset position counter */
-#define QEI_RESET_POSOnIDX		QEI_CON_RESPI		/**&lt; Reset Posistion Counter on Index */
-#define QEI_RESET_VEL			QEI_CON_RESV		/**&lt; Reset Velocity */
-#define QEI_RESET_IDX			QEI_CON_RESI		/**&lt; Reset Index Counter */
-
-#define PARAM_QEI_RESET(n)	((n==QEI_CON_RESP) \
-							|| (n==QEI_RESET_POSOnIDX) \
-							|| (n==QEI_RESET_VEL) \
-							|| (n==QEI_RESET_IDX))
-
-/* QEI Direction Invert Type Option */
-#define QEI_DIRINV_NONE		((uint32_t)(0))		/**&lt; Direction is not inverted */
-#define QEI_DIRINV_CMPL		((uint32_t)(1))		/**&lt; Direction is complemented */
-
-#define PARAM_QEI_DIRINV(n)	((n==QEI_DIRINV_NONE) || (n==QEI_DIRINV_CMPL))
-
-/* QEI Signal Mode Option */
-#define QEI_SIGNALMODE_QUAD		((uint32_t)(0))		/**&lt; Signal operation: Quadrature phase mode */
-#define QEI_SIGNALMODE_CLKDIR	((uint32_t)(1))		/**&lt; Signal operation: Clock/Direction mode */
-
-#define PARAM_QEI_SIGNALMODE(n)	((n==QEI_SIGNALMODE_QUAD) || (n==QEI_SIGNALMODE_CLKDIR))
-
-/* QEI Capture Mode Option */
-#define QEI_CAPMODE_2X			((uint32_t)(0))		/**&lt; Capture mode: Only Phase-A edges are counted (2X) */
-#define QEI_CAPMODE_4X			((uint32_t)(1))		/**&lt; Capture mode: BOTH PhA and PhB edges are counted (4X)*/
-
-#define PARAM_QEI_CAPMODE(n)	((n==QEI_CAPMODE_2X) || (n==QEI_CAPMODE_4X))
-
-/* QEI Invert Index Signal Option */
-#define QEI_INVINX_NONE			((uint32_t)(0))		/**&lt; Invert Index signal option: None */
-#define QEI_INVINX_EN			((uint32_t)(1))		/**&lt; Invert Index signal option: Enable */
-
-#define PARAM_QEI_INVINX(n)		((n==QEI_INVINX_NONE) || (n==QEI_INVINX_EN))
-
-/* QEI timer reload option */
-#define QEI_TIMERRELOAD_TICKVAL	((uint8_t)(0))	/**&lt; Reload value in absolute value */
-#define QEI_TIMERRELOAD_USVAL	((uint8_t)(1))	/**&lt; Reload value in microsecond value */
-#define PARAM_QEI_TIMERRELOAD(n)	((n==QEI_TIMERRELOAD_TICKVAL) || (n==QEI_TIMERRELOAD_USVAL))
-
-/* QEI Flag Status type */
-#define QEI_STATUS_DIR			((uint32_t)(1&lt;&lt;0))	/**&lt; Direction status */
-#define PARAM_QEI_STATUS(n)		((n==QEI_STATUS_DIR))
-
-/* QEI Compare Position channel option */
-#define QEI_COMPPOS_CH_0			((uint8_t)(0))		/**&lt; QEI compare position channel 0 */
-#define QEI_COMPPOS_CH_1			((uint8_t)(1))		/**&lt; QEI compare position channel 1 */
-#define QEI_COMPPOS_CH_2			((uint8_t)(2))		/**&lt; QEI compare position channel 2 */
-#define PARAM_QEI_COMPPOS_CH(n)		((n==QEI_COMPPOS_CH_0) || (n==QEI_COMPPOS_CH_1) || (n==QEI_COMPPOS_CH_2))
-
-/* QEI interrupt flag type */
-#define QEI_INTFLAG_INX_Int			((uint32_t)(1&lt;&lt;0))	/**&lt; index pulse was detected interrupt */
-#define QEI_INTFLAG_TIM_Int			((uint32_t)(1&lt;&lt;1))	/**&lt; Velocity timer over flow interrupt */
-#define QEI_INTFLAG_VELC_Int		((uint32_t)(1&lt;&lt;2))	/**&lt; Capture velocity is less than compare interrupt */
-#define QEI_INTFLAG_DIR_Int			((uint32_t)(1&lt;&lt;3))	/**&lt; Change of direction interrupt */
-#define QEI_INTFLAG_ERR_Int			((uint32_t)(1&lt;&lt;4))	/**&lt; An encoder phase error interrupt */
-#define QEI_INTFLAG_ENCLK_Int		((uint32_t)(1&lt;&lt;5))	/**&lt; An encoder clock pulse was detected interrupt */
-#define QEI_INTFLAG_POS0_Int		((uint32_t)(1&lt;&lt;6))	/**&lt; position 0 compare value is equal to the
-														current position interrupt */
-#define QEI_INTFLAG_POS1_Int		((uint32_t)(1&lt;&lt;7))	/**&lt; position 1 compare value is equal to the
-														current position interrupt */
-#define QEI_INTFLAG_POS2_Int		((uint32_t)(1&lt;&lt;8))	/**&lt; position 2 compare value is equal to the
-														current position interrupt */
-#define QEI_INTFLAG_REV_Int			((uint32_t)(1&lt;&lt;9))	/**&lt; Index compare value is equal to the current
-														index count interrupt */
-#define QEI_INTFLAG_POS0REV_Int		((uint32_t)(1&lt;&lt;10))	/**&lt; Combined position 0 and revolution count interrupt */
-#define QEI_INTFLAG_POS1REV_Int		((uint32_t)(1&lt;&lt;11))	/**&lt; Combined position 1 and revolution count interrupt */
-#define QEI_INTFLAG_POS2REV_Int		((uint32_t)(1&lt;&lt;12))	/**&lt; Combined position 2 and revolution count interrupt */
-
-#define PARAM_QEI_INTFLAG(n)	((n==QEI_INTFLAG_INX_Int) \
-								|| (n==QEI_INTFLAG_TIM_Int) \
-								|| (n==QEI_INTFLAG_VELC_Int) \
-								|| (n==QEI_INTFLAG_DIR_Int) \
-								|| (n==QEI_INTFLAG_ERR_Int) \
-								|| (n==QEI_INTFLAG_ENCLK_Int) \
-								|| (n==QEI_INTFLAG_POS0_Int) \
-								|| (n==QEI_INTFLAG_POS1_Int) \
-								|| (n==QEI_INTFLAG_POS2_Int) \
-								|| (n==QEI_INTFLAG_REV_Int) \
-								|| (n==QEI_INTFLAG_POS0REV_Int) \
-								|| (n==QEI_INTFLAG_POS1REV_Int) \
-								|| (n==QEI_INTFLAG_POS2REV_Int))
-
-/**
- * @}
- */
-
-
-/* Public Functions ----------------------------------------------------------- */
-/** @defgroup QEI_Public_Functions
- * @{
- */
-
-void QEI_Reset(QEI_TypeDef *QEIx, uint32_t ulResetType);
-void QEI_Init(QEI_TypeDef *QEIx, QEI_CFG_Type *QEI_ConfigStruct);
-void QEI_ConfigStructInit(QEI_CFG_Type *QIE_InitStruct);
-void QEI_DeInit(QEI_TypeDef *QEIx);
-FlagStatus QEI_GetStatus(QEI_TypeDef *QEIx, uint32_t ulFlagType);
-uint32_t QEI_GetPosition(QEI_TypeDef *QEIx);
-void QEI_SetMaxPosition(QEI_TypeDef *QEIx, uint32_t ulMaxPos);
-void QEI_SetPositionComp(QEI_TypeDef *QEIx, uint8_t bPosCompCh, uint32_t ulPosComp);
-uint32_t QEI_GetIndex(QEI_TypeDef *QEIx);
-void QEI_SetIndexComp(QEI_TypeDef *QEIx, uint32_t ulIndexComp);
-void QEI_SetTimerReload(QEI_TypeDef *QEIx, QEI_RELOADCFG_Type *QEIReloadStruct);
-uint32_t QEI_GetTimer(QEI_TypeDef *QEIx);
-uint32_t QEI_GetVelocity(QEI_TypeDef *QEIx);
-uint32_t QEI_GetVelocityCap(QEI_TypeDef *QEIx);
-void QEI_SetVelocityComp(QEI_TypeDef *QEIx, uint32_t ulVelComp);
-void QEI_SetDigiFilter(QEI_TypeDef *QEIx, uint32_t ulSamplingPulse);
-FlagStatus QEI_GetIntStatus(QEI_TypeDef *QEIx, uint32_t ulIntType);
-void QEI_IntCmd(QEI_TypeDef *QEIx, uint32_t ulIntType, FunctionalState NewState);
-void QEI_IntSet(QEI_TypeDef *QEIx, uint32_t ulIntType);
-void QEI_IntClear(QEI_TypeDef *QEIx, uint32_t ulIntType);
-uint32_t QEI_CalculateRPM(QEI_TypeDef *QEIx, uint32_t ulVelCapValue, uint32_t ulPPR);
-
-
-/**
- * @}
- */
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* LPC17XX_QEI_H_ */
-
-/**
- * @}
- */
-
-/* --------------------------------- End Of File ------------------------------ */
+/***********************************************************************//**
+ * @file	: lpc17xx_qei.h
+ * @brief	: Contains all macro definitions and function prototypes
+ * 				support for QEI firmware library on LPC17xx
+ * @version	: 1.0
+ * @date	: 26. May. 2009
+ * @author	: HieuNguyen
+ **************************************************************************
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * products. This software is supplied &quot;AS IS&quot; without any warranties.
+ * NXP Semiconductors assumes no responsibility or liability for the
+ * use of the software, conveys no license or title under any patent,
+ * copyright, or mask work right to the product. NXP Semiconductors
+ * reserves the right to make changes in the software without
+ * notification. NXP Semiconductors also make no representation or
+ * warranty that such application will be suitable for the specified
+ * use without further testing or modification.
+ **************************************************************************/
+
+/* Peripheral group ----------------------------------------------------------- */
+/** @defgroup QEI
+ * @ingroup LPC1700CMSIS_FwLib_Drivers
+ * @{
+ */
+
+#ifndef LPC17XX_QEI_H_
+#define LPC17XX_QEI_H_
+
+/* Includes ------------------------------------------------------------------- */
+#include &quot;LPC17xx.h&quot;
+#include &quot;lpc_types.h&quot;
+
+
+#ifdef __cplusplus
+extern &quot;C&quot;
+{
+#endif
+
+
+/* Private Macros ------------------------------------------------------------- */
+/** @defgroup QEI_Private_Macros
+ * @{
+ */
+
+/** @defgroup QEI_REGISTER_BIT_DEFINITIONS
+ * @{
+ */
+
+/* Quadrature Encoder Interface Control Register Definition --------------------- */
+/* QEI Control register */
+#define QEI_CON_RESP		((uint32_t)(1&lt;&lt;0))		/**&lt; Reset position counter */
+#define QEI_CON_RESPI		((uint32_t)(1&lt;&lt;1))		/**&lt; Reset Posistion Counter on Index */
+#define QEI_CON_RESV		((uint32_t)(1&lt;&lt;2))		/**&lt; Reset Velocity */
+#define QEI_CON_RESI		((uint32_t)(1&lt;&lt;3))		/**&lt; Reset Index Counter */
+#define QEI_CON_BITMASK		((uint32_t)(0x0F))		/**&lt; QEI Control register bit-mask */
+
+/* QEI Configuration register */
+#define QEI_CONF_DIRINV		((uint32_t)(1&lt;&lt;0))		/**&lt; Direction Invert */
+#define QEI_CONF_SIGMODE	((uint32_t)(1&lt;&lt;1))		/**&lt; Signal mode */
+#define QEI_CONF_CAPMODE	((uint32_t)(1&lt;&lt;2))		/**&lt; Capture mode */
+#define QEI_CONF_INVINX		((uint32_t)(1&lt;&lt;3))		/**&lt; Invert index */
+#define QEI_CONF_BITMASK	((uint32_t)(0x0F))		/**&lt; QEI Configuration register bit-mask */
+
+/* QEI Status register */
+#define QEI_STAT_DIR		((uint32_t)(1&lt;&lt;0))		/**&lt; Direction bit */
+#define QEI_STAT_BITMASK	((uint32_t)(1&lt;&lt;0))		/**&lt; QEI status register bit-mask */
+
+/* Quadrature Encoder Interface Position, index and timer Register Definitions --- */
+/* QEI Position register */
+
+/* QEI Maximum Position register */
+
+/* QEI Position Compare register 0 */
+
+/* QEI Position Compare register 1 */
+
+/* QEI Position Compare register 2 */
+
+/* QEI Index Count register */
+
+/* QEI Index Compare register */
+
+/* QEI Timer Reload register */
+
+/* QEI Timer register */
+
+/* QEI Velocity register */
+
+/* QEI Velocity Capture register */
+
+/* QEI Velocity Compare register */
+
+/* QEI Digital Filter register */
+
+/* Quadrature Encoder Interface Interrupt registers definitions --------------------- */
+/* QEI Interrupt Status register */
+#define QEI_INTSTAT_INX_Int			((uint32_t)(1&lt;&lt;0))	/**&lt; Indicates that an index pulse was detected */
+#define QEI_INTSTAT_TIM_Int			((uint32_t)(1&lt;&lt;1))	/**&lt; Indicates that a velocity timer overflow occurred */
+#define QEI_INTSTAT_VELC_Int		((uint32_t)(1&lt;&lt;2))	/**&lt; Indicates that capture velocity is less than compare velocity */
+#define QEI_INTSTAT_DIR_Int			((uint32_t)(1&lt;&lt;3))	/**&lt; Indicates that a change of direction was detected */
+#define QEI_INTSTAT_ERR_Int			((uint32_t)(1&lt;&lt;4))	/**&lt; Indicates that an encoder phase error was detected */
+#define QEI_INTSTAT_ENCLK_Int		((uint32_t)(1&lt;&lt;5))	/**&lt; Indicates that and encoder clock pulse was detected */
+#define QEI_INTSTAT_POS0_Int		((uint32_t)(1&lt;&lt;6))	/**&lt; Indicates that the position 0 compare value is equal to the
+														current position */
+#define QEI_INTSTAT_POS1_Int		((uint32_t)(1&lt;&lt;7))	/**&lt; Indicates that the position 1compare value is equal to the
+														current position */
+#define QEI_INTSTAT_POS2_Int		((uint32_t)(1&lt;&lt;8))	/**&lt; Indicates that the position 2 compare value is equal to the
+														current position */
+#define QEI_INTSTAT_REV_Int			((uint32_t)(1&lt;&lt;9))	/**&lt; Indicates that the index compare value is equal to the current
+														index count */
+#define QEI_INTSTAT_POS0REV_Int		((uint32_t)(1&lt;&lt;10))	/**&lt; Combined position 0 and revolution count interrupt. Set when
+														both the POS0_Int bit is set and the REV_Int is set */
+#define QEI_INTSTAT_POS1REV_Int		((uint32_t)(1&lt;&lt;11))	/**&lt; Combined position 1 and revolution count interrupt. Set when
+														both the POS1_Int bit is set and the REV_Int is set */
+#define QEI_INTSTAT_POS2REV_Int		((uint32_t)(1&lt;&lt;12))	/**&lt; Combined position 2 and revolution count interrupt. Set when
+														both the POS2_Int bit is set and the REV_Int is set */
+#define QEI_INTSTAT_BITMASK			((uint32_t)(0x1FFF))	/**&lt; QEI Interrupt Status register bit-mask */
+
+/* QEI Interrupt Set register */
+#define QEI_INTSET_INX_Int			((uint32_t)(1&lt;&lt;0))	/**&lt; Set Bit Indicates that an index pulse was detected */
+#define QEI_INTSET_TIM_Int			((uint32_t)(1&lt;&lt;1))	/**&lt; Set Bit Indicates that a velocity timer overflow occurred */
+#define QEI_INTSET_VELC_Int			((uint32_t)(1&lt;&lt;2))	/**&lt; Set Bit Indicates that capture velocity is less than compare velocity */
+#define QEI_INTSET_DIR_Int			((uint32_t)(1&lt;&lt;3))	/**&lt; Set Bit Indicates that a change of direction was detected */
+#define QEI_INTSET_ERR_Int			((uint32_t)(1&lt;&lt;4))	/**&lt; Set Bit Indicates that an encoder phase error was detected */
+#define QEI_INTSET_ENCLK_Int		((uint32_t)(1&lt;&lt;5))	/**&lt; Set Bit Indicates that and encoder clock pulse was detected */
+#define QEI_INTSET_POS0_Int			((uint32_t)(1&lt;&lt;6))	/**&lt; Set Bit Indicates that the position 0 compare value is equal to the
+														current position */
+#define QEI_INTSET_POS1_Int			((uint32_t)(1&lt;&lt;7))	/**&lt; Set Bit Indicates that the position 1compare value is equal to the
+														current position */
+#define QEI_INTSET_POS2_Int			((uint32_t)(1&lt;&lt;8))	/**&lt; Set Bit Indicates that the position 2 compare value is equal to the
+														current position */
+#define QEI_INTSET_REV_Int			((uint32_t)(1&lt;&lt;9))	/**&lt; Set Bit Indicates that the index compare value is equal to the current
+														index count */
+#define QEI_INTSET_POS0REV_Int		((uint32_t)(1&lt;&lt;10))	/**&lt; Set Bit that combined position 0 and revolution count interrupt */
+#define QEI_INTSET_POS1REV_Int		((uint32_t)(1&lt;&lt;11))	/**&lt; Set Bit that Combined position 1 and revolution count interrupt */
+#define QEI_INTSET_POS2REV_Int		((uint32_t)(1&lt;&lt;12))	/**&lt; Set Bit that Combined position 2 and revolution count interrupt */
+#define QEI_INTSET_BITMASK			((uint32_t)(0x1FFF))	/**&lt; QEI Interrupt Set register bit-mask */
+
+/* QEI Interrupt Clear register */
+#define QEI_INTCLR_INX_Int			((uint32_t)(1&lt;&lt;0))	/**&lt; Clear Bit Indicates that an index pulse was detected */
+#define QEI_INTCLR_TIM_Int			((uint32_t)(1&lt;&lt;1))	/**&lt; Clear Bit Indicates that a velocity timer overflow occurred */
+#define QEI_INTCLR_VELC_Int			((uint32_t)(1&lt;&lt;2))	/**&lt; Clear Bit Indicates that capture velocity is less than compare velocity */
+#define QEI_INTCLR_DIR_Int			((uint32_t)(1&lt;&lt;3))	/**&lt; Clear Bit Indicates that a change of direction was detected */
+#define QEI_INTCLR_ERR_Int			((uint32_t)(1&lt;&lt;4))	/**&lt; Clear Bit Indicates that an encoder phase error was detected */
+#define QEI_INTCLR_ENCLK_Int		((uint32_t)(1&lt;&lt;5))	/**&lt; Clear Bit Indicates that and encoder clock pulse was detected */
+#define QEI_INTCLR_POS0_Int			((uint32_t)(1&lt;&lt;6))	/**&lt; Clear Bit Indicates that the position 0 compare value is equal to the
+														current position */
+#define QEI_INTCLR_POS1_Int			((uint32_t)(1&lt;&lt;7))	/**&lt; Clear Bit Indicates that the position 1compare value is equal to the
+														current position */
+#define QEI_INTCLR_POS2_Int			((uint32_t)(1&lt;&lt;8))	/**&lt; Clear Bit Indicates that the position 2 compare value is equal to the
+														current position */
+#define QEI_INTCLR_REV_Int			((uint32_t)(1&lt;&lt;9))	/**&lt; Clear Bit Indicates that the index compare value is equal to the current
+														index count */
+#define QEI_INTCLR_POS0REV_Int		((uint32_t)(1&lt;&lt;10))	/**&lt; Clear Bit that combined position 0 and revolution count interrupt */
+#define QEI_INTCLR_POS1REV_Int		((uint32_t)(1&lt;&lt;11))	/**&lt; Clear Bit that Combined position 1 and revolution count interrupt */
+#define QEI_INTCLR_POS2REV_Int		((uint32_t)(1&lt;&lt;12))	/**&lt; Clear Bit that Combined position 2 and revolution count interrupt */
+#define QEI_INTCLR_BITMASK			((uint32_t)(0x1FFF))	/**&lt; QEI Interrupt Clear register bit-mask */
+
+/* QEI Interrupt Enable register */
+#define QEI_INTEN_INX_Int			((uint32_t)(1&lt;&lt;0))	/**&lt; Enabled Interrupt Bit Indicates that an index pulse was detected */
+#define QEI_INTEN_TIM_Int			((uint32_t)(1&lt;&lt;1))	/**&lt; Enabled Interrupt Bit Indicates that a velocity timer overflow occurred */
+#define QEI_INTEN_VELC_Int			((uint32_t)(1&lt;&lt;2))	/**&lt; Enabled Interrupt Bit Indicates that capture velocity is less than compare velocity */
+#define QEI_INTEN_DIR_Int			((uint32_t)(1&lt;&lt;3))	/**&lt; Enabled Interrupt Bit Indicates that a change of direction was detected */
+#define QEI_INTEN_ERR_Int			((uint32_t)(1&lt;&lt;4))	/**&lt; Enabled Interrupt Bit Indicates that an encoder phase error was detected */
+#define QEI_INTEN_ENCLK_Int			((uint32_t)(1&lt;&lt;5))	/**&lt; Enabled Interrupt Bit Indicates that and encoder clock pulse was detected */
+#define QEI_INTEN_POS0_Int			((uint32_t)(1&lt;&lt;6))	/**&lt; Enabled Interrupt Bit Indicates that the position 0 compare value is equal to the
+														current position */
+#define QEI_INTEN_POS1_Int			((uint32_t)(1&lt;&lt;7))	/**&lt; Enabled Interrupt Bit Indicates that the position 1compare value is equal to the
+														current position */
+#define QEI_INTEN_POS2_Int			((uint32_t)(1&lt;&lt;8))	/**&lt; Enabled Interrupt Bit Indicates that the position 2 compare value is equal to the
+														current position */
+#define QEI_INTEN_REV_Int			((uint32_t)(1&lt;&lt;9))	/**&lt; Enabled Interrupt Bit Indicates that the index compare value is equal to the current
+														index count */
+#define QEI_INTEN_POS0REV_Int		((uint32_t)(1&lt;&lt;10))	/**&lt; Enabled Interrupt Bit that combined position 0 and revolution count interrupt */
+#define QEI_INTEN_POS1REV_Int		((uint32_t)(1&lt;&lt;11))	/**&lt; Enabled Interrupt Bit that Combined position 1 and revolution count interrupt */
+#define QEI_INTEN_POS2REV_Int		((uint32_t)(1&lt;&lt;12))	/**&lt; Enabled Interrupt Bit that Combined position 2 and revolution count interrupt */
+#define QEI_INTEN_BITMASK			((uint32_t)(0x1FFF))	/**&lt; QEI Interrupt Enable register bit-mask */
+
+/* QEI Interrupt Enable Set register */
+#define QEI_IESET_INX_Int			((uint32_t)(1&lt;&lt;0))	/**&lt; Set Enable Interrupt Bit Indicates that an index pulse was detected */
+#define QEI_IESET_TIM_Int			((uint32_t)(1&lt;&lt;1))	/**&lt; Set Enable Interrupt Bit Indicates that a velocity timer overflow occurred */
+#define QEI_IESET_VELC_Int			((uint32_t)(1&lt;&lt;2))	/**&lt; Set Enable Interrupt Bit Indicates that capture velocity is less than compare velocity */
+#define QEI_IESET_DIR_Int			((uint32_t)(1&lt;&lt;3))	/**&lt; Set Enable Interrupt Bit Indicates that a change of direction was detected */
+#define QEI_IESET_ERR_Int			((uint32_t)(1&lt;&lt;4))	/**&lt; Set Enable Interrupt Bit Indicates that an encoder phase error was detected */
+#define QEI_IESET_ENCLK_Int			((uint32_t)(1&lt;&lt;5))	/**&lt; Set Enable Interrupt Bit Indicates that and encoder clock pulse was detected */
+#define QEI_IESET_POS0_Int			((uint32_t)(1&lt;&lt;6))	/**&lt; Set Enable Interrupt Bit Indicates that the position 0 compare value is equal to the
+														current position */
+#define QEI_IESET_POS1_Int			((uint32_t)(1&lt;&lt;7))	/**&lt; Set Enable Interrupt Bit Indicates that the position 1compare value is equal to the
+														current position */
+#define QEI_IESET_POS2_Int			((uint32_t)(1&lt;&lt;8))	/**&lt; Set Enable Interrupt Bit Indicates that the position 2 compare value is equal to the
+														current position */
+#define QEI_IESET_REV_Int			((uint32_t)(1&lt;&lt;9))	/**&lt; Set Enable Interrupt Bit Indicates that the index compare value is equal to the current
+														index count */
+#define QEI_IESET_POS0REV_Int		((uint32_t)(1&lt;&lt;10))	/**&lt; Set Enable Interrupt Bit that combined position 0 and revolution count interrupt */
+#define QEI_IESET_POS1REV_Int		((uint32_t)(1&lt;&lt;11))	/**&lt; Set Enable Interrupt Bit that Combined position 1 and revolution count interrupt */
+#define QEI_IESET_POS2REV_Int		((uint32_t)(1&lt;&lt;12))	/**&lt; Set Enable Interrupt Bit that Combined position 2 and revolution count interrupt */
+#define QEI_IESET_BITMASK			((uint32_t)(0x1FFF))	/**&lt; QEI Interrupt Enable Set register bit-mask */
+
+/* QEI Interrupt Enable Clear register */
+#define QEI_IECLR_INX_Int			((uint32_t)(1&lt;&lt;0))	/**&lt; Clear Enabled Interrupt Bit Indicates that an index pulse was detected */
+#define QEI_IECLR_TIM_Int			((uint32_t)(1&lt;&lt;1))	/**&lt; Clear Enabled Interrupt Bit Indicates that a velocity timer overflow occurred */
+#define QEI_IECLR_VELC_Int			((uint32_t)(1&lt;&lt;2))	/**&lt; Clear Enabled Interrupt Bit Indicates that capture velocity is less than compare velocity */
+#define QEI_IECLR_DIR_Int			((uint32_t)(1&lt;&lt;3))	/**&lt; Clear Enabled Interrupt Bit Indicates that a change of direction was detected */
+#define QEI_IECLR_ERR_Int			((uint32_t)(1&lt;&lt;4))	/**&lt; Clear Enabled Interrupt Bit Indicates that an encoder phase error was detected */
+#define QEI_IECLR_ENCLK_Int			((uint32_t)(1&lt;&lt;5))	/**&lt; Clear Enabled Interrupt Bit Indicates that and encoder clock pulse was detected */
+#define QEI_IECLR_POS0_Int			((uint32_t)(1&lt;&lt;6))	/**&lt; Clear Enabled Interrupt Bit Indicates that the position 0 compare value is equal to the
+														current position */
+#define QEI_IECLR_POS1_Int			((uint32_t)(1&lt;&lt;7))	/**&lt; Clear Enabled Interrupt Bit Indicates that the position 1compare value is equal to the
+														current position */
+#define QEI_IECLR_POS2_Int			((uint32_t)(1&lt;&lt;8))	/**&lt; Clear Enabled Interrupt Bit Indicates that the position 2 compare value is equal to the
+														current position */
+#define QEI_IECLR_REV_Int			((uint32_t)(1&lt;&lt;9))	/**&lt; Clear Enabled Interrupt Bit Indicates that the index compare value is equal to the current
+														index count */
+#define QEI_IECLR_POS0REV_Int		((uint32_t)(1&lt;&lt;10))	/**&lt; Clear Enabled Interrupt Bit that combined position 0 and revolution count interrupt */
+#define QEI_IECLR_POS1REV_Int		((uint32_t)(1&lt;&lt;11))	/**&lt; Clear Enabled Interrupt Bit that Combined position 1 and revolution count interrupt */
+#define QEI_IECLR_POS2REV_Int		((uint32_t)(1&lt;&lt;12))	/**&lt; Clear Enabled Interrupt Bit that Combined position 2 and revolution count interrupt */
+#define QEI_IECLR_BITMASK			((uint32_t)(0x1FFF))	/**&lt; QEI Interrupt Enable Clear register bit-mask */
+
+
+/**
+ * @}
+ */
+
+/**
+ * @}
+ */
+
+
+/* Public Types --------------------------------------------------------------- */
+/** @defgroup QEI_Public_Types
+ * @{
+ */
+
+/**
+ * @brief QEI Configuration structure type definition
+ */
+typedef struct {
+	uint32_t DirectionInvert	:1; 	/**&lt; Direction invert option:
+										- QEI_DIRINV_NONE: QEI Direction is normal
+										- QEI_DIRINV_CMPL: QEI Direction is complemented
+										*/
+	uint32_t SignalMode			:1; 	/**&lt; Signal mode Option:
+										- QEI_SIGNALMODE_QUAD: Signal is in Quadrature phase mode
+										- QEI_SIGNALMODE_CLKDIR: Signal is in Clock/Direction mode
+										*/
+	uint32_t CaptureMode		:1;		/**&lt; Capture Mode Option:
+										- QEI_CAPMODE_2X: Only Phase-A edges are counted (2X)
+										- QEI_CAPMODE_4X: BOTH Phase-A and Phase-B edges are counted (4X)
+										*/
+	uint32_t InvertIndex		:1; 	/**&lt; Invert Index Option:
+										- QEI_INVINX_NONE: the sense of the index input is normal
+										- QEI_INVINX_EN: inverts the sense of the index input
+										*/
+} QEI_CFG_Type;
+
+/**
+ * @brief Timer Reload Configuration structure type definition
+ */
+typedef struct {
+
+	uint8_t ReloadOption;		/**&lt; Velocity Timer Reload Option, should be:
+								- QEI_TIMERRELOAD_TICKVAL: Reload value in absolute value
+								- QEI_TIMERRELOAD_USVAL: Reload value in microsecond value
+								*/
+	uint8_t Reserved[3];
+	uint32_t ReloadValue;		/**&lt; Velocity Timer Reload Value, 32-bit long, should be matched
+								with Velocity Timer Reload Option
+								*/
+} QEI_RELOADCFG_Type;
+
+/**
+ * @}
+ */
+
+
+/* Public Macros -------------------------------------------------------------- */
+/** @defgroup QEI_Public_Macros
+ * @{
+ */
+
+#define PARAM_QEIx(n)	((n==LPC_QEI))
+
+/* QEI Reset types */
+#define QEI_RESET_POS			QEI_CON_RESP		/**&lt; Reset position counter */
+#define QEI_RESET_POSOnIDX		QEI_CON_RESPI		/**&lt; Reset Posistion Counter on Index */
+#define QEI_RESET_VEL			QEI_CON_RESV		/**&lt; Reset Velocity */
+#define QEI_RESET_IDX			QEI_CON_RESI		/**&lt; Reset Index Counter */
+
+#define PARAM_QEI_RESET(n)	((n==QEI_CON_RESP) \
+|| (n==QEI_RESET_POSOnIDX) \
+|| (n==QEI_RESET_VEL) \
+|| (n==QEI_RESET_IDX))
+
+/* QEI Direction Invert Type Option */
+#define QEI_DIRINV_NONE		((uint32_t)(0))		/**&lt; Direction is not inverted */
+#define QEI_DIRINV_CMPL		((uint32_t)(1))		/**&lt; Direction is complemented */
+
+#define PARAM_QEI_DIRINV(n)	((n==QEI_DIRINV_NONE) || (n==QEI_DIRINV_CMPL))
+
+/* QEI Signal Mode Option */
+#define QEI_SIGNALMODE_QUAD		((uint32_t)(0))		/**&lt; Signal operation: Quadrature phase mode */
+#define QEI_SIGNALMODE_CLKDIR	((uint32_t)(1))		/**&lt; Signal operation: Clock/Direction mode */
+
+#define PARAM_QEI_SIGNALMODE(n)	((n==QEI_SIGNALMODE_QUAD) || (n==QEI_SIGNALMODE_CLKDIR))
+
+/* QEI Capture Mode Option */
+#define QEI_CAPMODE_2X			((uint32_t)(0))		/**&lt; Capture mode: Only Phase-A edges are counted (2X) */
+#define QEI_CAPMODE_4X			((uint32_t)(1))		/**&lt; Capture mode: BOTH PhA and PhB edges are counted (4X)*/
+
+#define PARAM_QEI_CAPMODE(n)	((n==QEI_CAPMODE_2X) || (n==QEI_CAPMODE_4X))
+
+/* QEI Invert Index Signal Option */
+#define QEI_INVINX_NONE			((uint32_t)(0))		/**&lt; Invert Index signal option: None */
+#define QEI_INVINX_EN			((uint32_t)(1))		/**&lt; Invert Index signal option: Enable */
+
+#define PARAM_QEI_INVINX(n)		((n==QEI_INVINX_NONE) || (n==QEI_INVINX_EN))
+
+/* QEI timer reload option */
+#define QEI_TIMERRELOAD_TICKVAL	((uint8_t)(0))	/**&lt; Reload value in absolute value */
+#define QEI_TIMERRELOAD_USVAL	((uint8_t)(1))	/**&lt; Reload value in microsecond value */
+#define PARAM_QEI_TIMERRELOAD(n)	((n==QEI_TIMERRELOAD_TICKVAL) || (n==QEI_TIMERRELOAD_USVAL))
+
+/* QEI Flag Status type */
+#define QEI_STATUS_DIR			((uint32_t)(1&lt;&lt;0))	/**&lt; Direction status */
+#define PARAM_QEI_STATUS(n)		((n==QEI_STATUS_DIR))
+
+/* QEI Compare Position channel option */
+#define QEI_COMPPOS_CH_0			((uint8_t)(0))		/**&lt; QEI compare position channel 0 */
+#define QEI_COMPPOS_CH_1			((uint8_t)(1))		/**&lt; QEI compare position channel 1 */
+#define QEI_COMPPOS_CH_2			((uint8_t)(2))		/**&lt; QEI compare position channel 2 */
+#define PARAM_QEI_COMPPOS_CH(n)		((n==QEI_COMPPOS_CH_0) || (n==QEI_COMPPOS_CH_1) || (n==QEI_COMPPOS_CH_2))
+
+/* QEI interrupt flag type */
+#define QEI_INTFLAG_INX_Int			((uint32_t)(1&lt;&lt;0))	/**&lt; index pulse was detected interrupt */
+#define QEI_INTFLAG_TIM_Int			((uint32_t)(1&lt;&lt;1))	/**&lt; Velocity timer over flow interrupt */
+#define QEI_INTFLAG_VELC_Int		((uint32_t)(1&lt;&lt;2))	/**&lt; Capture velocity is less than compare interrupt */
+#define QEI_INTFLAG_DIR_Int			((uint32_t)(1&lt;&lt;3))	/**&lt; Change of direction interrupt */
+#define QEI_INTFLAG_ERR_Int			((uint32_t)(1&lt;&lt;4))	/**&lt; An encoder phase error interrupt */
+#define QEI_INTFLAG_ENCLK_Int		((uint32_t)(1&lt;&lt;5))	/**&lt; An encoder clock pulse was detected interrupt */
+#define QEI_INTFLAG_POS0_Int		((uint32_t)(1&lt;&lt;6))	/**&lt; position 0 compare value is equal to the
+														current position interrupt */
+#define QEI_INTFLAG_POS1_Int		((uint32_t)(1&lt;&lt;7))	/**&lt; position 1 compare value is equal to the
+														current position interrupt */
+#define QEI_INTFLAG_POS2_Int		((uint32_t)(1&lt;&lt;8))	/**&lt; position 2 compare value is equal to the
+														current position interrupt */
+#define QEI_INTFLAG_REV_Int			((uint32_t)(1&lt;&lt;9))	/**&lt; Index compare value is equal to the current
+														index count interrupt */
+#define QEI_INTFLAG_POS0REV_Int		((uint32_t)(1&lt;&lt;10))	/**&lt; Combined position 0 and revolution count interrupt */
+#define QEI_INTFLAG_POS1REV_Int		((uint32_t)(1&lt;&lt;11))	/**&lt; Combined position 1 and revolution count interrupt */
+#define QEI_INTFLAG_POS2REV_Int		((uint32_t)(1&lt;&lt;12))	/**&lt; Combined position 2 and revolution count interrupt */
+
+#define PARAM_QEI_INTFLAG(n)	((n==QEI_INTFLAG_INX_Int) \
+|| (n==QEI_INTFLAG_TIM_Int) \
+|| (n==QEI_INTFLAG_VELC_Int) \
+|| (n==QEI_INTFLAG_DIR_Int) \
+|| (n==QEI_INTFLAG_ERR_Int) \
+|| (n==QEI_INTFLAG_ENCLK_Int) \
+|| (n==QEI_INTFLAG_POS0_Int) \
+|| (n==QEI_INTFLAG_POS1_Int) \
+|| (n==QEI_INTFLAG_POS2_Int) \
+|| (n==QEI_INTFLAG_REV_Int) \
+|| (n==QEI_INTFLAG_POS0REV_Int) \
+|| (n==QEI_INTFLAG_POS1REV_Int) \
+|| (n==QEI_INTFLAG_POS2REV_Int))
+
+/**
+ * @}
+ */
+
+
+/* Public Functions ----------------------------------------------------------- */
+/** @defgroup QEI_Public_Functions
+ * @{
+ */
+
+void QEI_Reset(LPC_QEI_TypeDef *QEIx, uint32_t ulResetType);
+void QEI_Init(LPC_QEI_TypeDef *QEIx, QEI_CFG_Type *QEI_ConfigStruct);
+void QEI_ConfigStructInit(QEI_CFG_Type *QIE_InitStruct);
+void QEI_DeInit(LPC_QEI_TypeDef *QEIx);
+FlagStatus QEI_GetStatus(LPC_QEI_TypeDef *QEIx, uint32_t ulFlagType);
+uint32_t QEI_GetPosition(LPC_QEI_TypeDef *QEIx);
+void QEI_SetMaxPosition(LPC_QEI_TypeDef *QEIx, uint32_t ulMaxPos);
+void QEI_SetPositionComp(LPC_QEI_TypeDef *QEIx, uint8_t bPosCompCh, uint32_t ulPosComp);
+uint32_t QEI_GetIndex(LPC_QEI_TypeDef *QEIx);
+void QEI_SetIndexComp(LPC_QEI_TypeDef *QEIx, uint32_t ulIndexComp);
+void QEI_SetTimerReload(LPC_QEI_TypeDef *QEIx, QEI_RELOADCFG_Type *QEIReloadStruct);
+uint32_t QEI_GetTimer(LPC_QEI_TypeDef *QEIx);
+uint32_t QEI_GetVelocity(LPC_QEI_TypeDef *QEIx);
+uint32_t QEI_GetVelocityCap(LPC_QEI_TypeDef *QEIx);
+void QEI_SetVelocityComp(LPC_QEI_TypeDef *QEIx, uint32_t ulVelComp);
+void QEI_SetDigiFilter(LPC_QEI_TypeDef *QEIx, uint32_t ulSamplingPulse);
+FlagStatus QEI_GetIntStatus(LPC_QEI_TypeDef *QEIx, uint32_t ulIntType);
+void QEI_IntCmd(LPC_QEI_TypeDef *QEIx, uint32_t ulIntType, FunctionalState NewState);
+void QEI_IntSet(LPC_QEI_TypeDef *QEIx, uint32_t ulIntType);
+void QEI_IntClear(LPC_QEI_TypeDef *QEIx, uint32_t ulIntType);
+uint32_t QEI_CalculateRPM(LPC_QEI_TypeDef *QEIx, uint32_t ulVelCapValue, uint32_t ulPPR);
+
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LPC17XX_QEI_H_ */
+
+/**
+ * @}
+ */
+
+/* --------------------------------- End Of File ------------------------------ */


Property changes on: trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_qei.h
___________________________________________________________________
Deleted: svn:executable
   - *

Modified: trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_rit.h
===================================================================
--- trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_rit.h	2010-06-28 21:53:59 UTC (rev 759)
+++ trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_rit.h	2010-07-12 20:56:54 UTC (rev 760)
@@ -1,122 +1,122 @@
-/***********************************************************************//**
- * @file	: lpc17xx_rit.h
- * @brief	: Contains all macro definitions and function prototypes
- * 				support for RIT firmware library on LPC17xx
- * @version	: 1.0
- * @date	: 07. May. 2009
- * @author	: NguyenCao
- **************************************************************************
- * Software that is described herein is for illustrative purposes only
- * which provides customers with programming information regarding the
- * products. This software is supplied &quot;AS IS&quot; without any warranties.
- * NXP Semiconductors assumes no responsibility or liability for the
- * use of the software, conveys no license or title under any patent,
- * copyright, or mask work right to the product. NXP Semiconductors
- * reserves the right to make changes in the software without
- * notification. NXP Semiconductors also make no representation or
- * warranty that such application will be suitable for the specified
- * use without further testing or modification.
- **************************************************************************/
-
-/* Peripheral group ----------------------------------------------------------- */
-/** @defgroup RIT
- * @ingroup LPC1700CMSIS_FwLib_Drivers
- * @{
- */
-
-#ifndef LPC17XX_RIT_H_
-#define LPC17XX_RIT_H_
-
-/* Includes ------------------------------------------------------------------- */
-#include &quot;LPC17xx.h&quot;
-#include &quot;lpc_types.h&quot;
-
-
-#ifdef __cplusplus
-extern &quot;C&quot;
-{
-#endif
-
-
-/* Private Macros ------------------------------------------------------------- */
-/** @defgroup RIT_Private_Macros
- * @{
- */
-
-/** @defgroup RIT_REGISTER_BIT_DEFINITIONS
- * @{
- */
-
-/*********************************************************************//**
- * Macro defines for RIT control register
- **********************************************************************/
-/**	Set interrupt flag when the counter value equals the masked compare value */
-#define RIT_CTRL_INTEN	((uint32_t) (1))
-/** Set timer enable clear to 0 when the counter value equals the masked compare value  */
-#define RIT_CTRL_ENCLR 	((uint32_t) _BIT(1))
-/** Set timer enable on break */
-#define RIT_CTRL_ENBR	((uint32_t) _BIT(2))
-/** Set timer enable */
-#define RIT_CTRL_TEN	((uint32_t) _BIT(3))
-
-/**
- * @}
- */
-
-/**
- * @}
- */
-
-
-/* Public Types --------------------------------------------------------------- */
-/** @defgroup RIT_Public_Types
- * @{
- */
-
-/**
- * @brief RIT compare configuration structure definition
- */
-typedef struct
-{
-	uint32_t 	CMPVAL;		/** Compare Value 	*/
-	uint32_t	MASKVAL;	/** Mask Value		*/
-	uint32_t	COUNTVAL;	/** Counter Value	*/
-}RIT_CMP_VAL;
-
-/*************************** GLOBAL/PUBLIC MACROS ***************************/
-/** Macro to determine if it is valid RIT peripheral */
-#define PARAM_RITx(n)	(((uint32_t *)n)==((uint32_t *)RIT))
-
-/**
- * @}
- */
-
-
-/* Public Functions ----------------------------------------------------------- */
-/** @defgroup RIT_Public_Functions
- * @{
- */
-
-void RIT_Init(RIT_TypeDef *RITx);
-void RIT_DeInit(RIT_TypeDef *RITx);
-void RIT_TimerConfig(RIT_TypeDef *RITx, RIT_CMP_VAL *value);
-void RIT_Cmd(RIT_TypeDef *RITx, FunctionalState NewState);
-void RIT_TimerClearCmd(RIT_TypeDef *RITx, FunctionalState NewState);
-void RIT_TimerEnableOnBreakCmd(RIT_TypeDef *RITx, FunctionalState NewState);
-IntStatus RIT_GetIntStatus(RIT_TypeDef *RITx);
-
-/**
- * @}
- */
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* LPC17XX_RIT_H_ */
-
-/**
- * @}
- */
-
-/* --------------------------------- End Of File ------------------------------ */
+/***********************************************************************//**
+ * @file	: lpc17xx_rit.h
+ * @brief	: Contains all macro definitions and function prototypes
+ * 				support for RIT firmware library on LPC17xx
+ * @version	: 1.0
+ * @date	: 07. May. 2009
+ * @author	: NguyenCao
+ **************************************************************************
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * products. This software is supplied &quot;AS IS&quot; without any warranties.
+ * NXP Semiconductors assumes no responsibility or liability for the
+ * use of the software, conveys no license or title under any patent,
+ * copyright, or mask work right to the product. NXP Semiconductors
+ * reserves the right to make changes in the software without
+ * notification. NXP Semiconductors also make no representation or
+ * warranty that such application will be suitable for the specified
+ * use without further testing or modification.
+ **************************************************************************/
+
+/* Peripheral group ----------------------------------------------------------- */
+/** @defgroup RIT
+ * @ingroup LPC1700CMSIS_FwLib_Drivers
+ * @{
+ */
+
+#ifndef LPC17XX_RIT_H_
+#define LPC17XX_RIT_H_
+
+/* Includes ------------------------------------------------------------------- */
+#include &quot;LPC17xx.h&quot;
+#include &quot;lpc_types.h&quot;
+
+
+#ifdef __cplusplus
+extern &quot;C&quot;
+{
+#endif
+
+
+/* Private Macros ------------------------------------------------------------- */
+/** @defgroup RIT_Private_Macros
+ * @{
+ */
+
+/** @defgroup RIT_REGISTER_BIT_DEFINITIONS
+ * @{
+ */
+
+/*********************************************************************//**
+ * Macro defines for RIT control register
+ **********************************************************************/
+/**	Set interrupt flag when the counter value equals the masked compare value */
+#define RIT_CTRL_INTEN	((uint32_t) (1))
+/** Set timer enable clear to 0 when the counter value equals the masked compare value  */
+#define RIT_CTRL_ENCLR 	((uint32_t) _BIT(1))
+/** Set timer enable on break */
+#define RIT_CTRL_ENBR	((uint32_t) _BIT(2))
+/** Set timer enable */
+#define RIT_CTRL_TEN	((uint32_t) _BIT(3))
+
+/**
+ * @}
+ */
+
+/**
+ * @}
+ */
+
+
+/* Public Types --------------------------------------------------------------- */
+/** @defgroup RIT_Public_Types
+ * @{
+ */
+
+/**
+ * @brief RIT compare configuration structure definition
+ */
+typedef struct
+{
+	uint32_t 	CMPVAL;		/** Compare Value 	*/
+	uint32_t	MASKVAL;	/** Mask Value		*/
+	uint32_t	COUNTVAL;	/** Counter Value	*/
+}RIT_CMP_VAL;
+
+/*************************** GLOBAL/PUBLIC MACROS ***************************/
+/** Macro to determine if it is valid RIT peripheral */
+#define PARAM_RITx(n)	(((uint32_t *)n)==((uint32_t *)LPC_RIT))
+
+/**
+ * @}
+ */
+
+
+/* Public Functions ----------------------------------------------------------- */
+/** @defgroup RIT_Public_Functions
+ * @{
+ */
+
+void RIT_Init(LPC_RIT_TypeDef *RITx);
+void RIT_DeInit(LPC_RIT_TypeDef *RITx);
+void RIT_TimerConfig(LPC_RIT_TypeDef *RITx, RIT_CMP_VAL *value);
+void RIT_Cmd(LPC_RIT_TypeDef *RITx, FunctionalState NewState);
+void RIT_TimerClearCmd(LPC_RIT_TypeDef *RITx, FunctionalState NewState);
+void RIT_TimerEnableOnBreakCmd(LPC_RIT_TypeDef *RITx, FunctionalState NewState);
+IntStatus RIT_GetIntStatus(LPC_RIT_TypeDef *RITx);
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LPC17XX_RIT_H_ */
+
+/**
+ * @}
+ */
+
+/* --------------------------------- End Of File ------------------------------ */


Property changes on: trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_rit.h
___________________________________________________________________
Deleted: svn:executable
   - *

Modified: trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_rtc.h
===================================================================
--- trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_rtc.h	2010-06-28 21:53:59 UTC (rev 759)
+++ trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_rtc.h	2010-07-12 20:56:54 UTC (rev 760)
@@ -1,307 +1,307 @@
-/***********************************************************************//**
- * @file	: lpc17xx_rtc.h
- * @brief	: Contains all macro definitions and function prototypes
- * 				support for RTC firmware library on LPC17xx
- * @version	: 1.0
- * @date	: 23. Apr. 2009
- * @author	: HieuNguyen
- **************************************************************************
- * Software that is described herein is for illustrative purposes only
- * which provides customers with programming information regarding the
- * products. This software is supplied &quot;AS IS&quot; without any warranties.
- * NXP Semiconductors assumes no responsibility or liability for the
- * use of the software, conveys no license or title under any patent,
- * copyright, or mask work right to the product. NXP Semiconductors
- * reserves the right to make changes in the software without
- * notification. NXP Semiconductors also make no representation or
- * warranty that such application will be suitable for the specified
- * use without further testing or modification.
- **************************************************************************/
-
-/* Peripheral group ----------------------------------------------------------- */
-/** @defgroup RTC
- * @ingroup LPC1700CMSIS_FwLib_Drivers
- * @{
- */
-
-#ifndef LPC17XX_RTC_H_
-#define LPC17XX_RTC_H_
-
-/* Includes ------------------------------------------------------------------- */
-#include &quot;LPC17xx.h&quot;
-#include &quot;lpc_types.h&quot;
-
-
-#ifdef __cplusplus
-extern &quot;C&quot;
-{
-#endif
-
-
-/* Private Macros ------------------------------------------------------------- */
-/** @defgroup RTC_Private_Macros
- * @{
- */
-
-/** @defgroup RTC_REGISTER_BIT_DEFINITIONS
- * @{
- */
-
-/* Miscellaneous register group --------------------------------------------- */
-
-/**********************************************************************
-* ILR register definitions
-**********************************************************************/
-/** ILR register mask */
-#define RTC_ILR_BITMASK			((0x00000003))
-/** Bit inform the source interrupt is counter increment*/
-#define RTC_IRL_RTCCIF			((1&lt;&lt;0))
-/** Bit inform the source interrupt is alarm match*/
-#define RTC_IRL_RTCALF			((1&lt;&lt;1))
-
-
-/**********************************************************************
-* CCR register definitions
-**********************************************************************/
-/** CCR register mask */
-#define RTC_CCR_BITMASK			((0x00000013))
-/** Clock enable */
-#define RTC_CCR_CLKEN			((1&lt;&lt;0))
-/** Clock reset */
-#define RTC_CCR_CTCRST			((1&lt;&lt;1))
-/** Calibration counter enable */
-#define RTC_CCR_CCALEN			((1&lt;&lt;4))
-
-
-/**********************************************************************
-* CIIR register definitions
-**********************************************************************/
-/** Counter Increment Interrupt bit for second */
-#define RTC_CIIR_IMSEC			((1&lt;&lt;0))
-/** Counter Increment Interrupt bit for minute */
-#define RTC_CIIR_IMMIN			((1&lt;&lt;1))
-/** Counter Increment Interrupt bit for hour */
-#define RTC_CIIR_IMHOUR			((1&lt;&lt;2))
-/** Counter Increment Interrupt bit for day of month */
-#define RTC_CIIR_IMDOM			((1&lt;&lt;3))
-/** Counter Increment Interrupt bit for day of week */
-#define RTC_CIIR_IMDOW			((1&lt;&lt;4))
-/** Counter Increment Interrupt bit for day of year */
-#define RTC_CIIR_IMDOY			((1&lt;&lt;5))
-/** Counter Increment Interrupt bit for month */
-#define RTC_CIIR_IMMON			((1&lt;&lt;6))
-/** Counter Increment Interrupt bit for year */
-#define RTC_CIIR_IMYEAR			((1&lt;&lt;7))
-/** CIIR bit mask */
-#define RTC_CIIR_BITMASK		((0xFF))
-
-/**********************************************************************
-* AMR register definitions
-**********************************************************************/
-/** Counter Increment Select Mask bit for second */
-#define RTC_AMR_AMRSEC			((1&lt;&lt;0))
-/** Counter Increment Select Mask bit for minute */
-#define RTC_AMR_AMRMIN			((1&lt;&lt;1))
-/** Counter Increment Select Mask bit for hour */
-#define RTC_AMR_AMRHOUR			((1&lt;&lt;2))
-/** Counter Increment Select Mask bit for day of month */
-#define RTC_AMR_AMRDOM			((1&lt;&lt;3))
-/** Counter Increment Select Mask bit for day of week */
-#define RTC_AMR_AMRDOW			((1&lt;&lt;4))
-/** Counter Increment Select Mask bit for day of year */
-#define RTC_AMR_AMRDOY			((1&lt;&lt;5))
-/** Counter Increment Select Mask bit for month */
-#define RTC_AMR_AMRMON			((1&lt;&lt;6))
-/** Counter Increment Select Mask bit for year */
-#define RTC_AMR_AMRYEAR			((1&lt;&lt;7))
-/** AMR bit mask */
-#define RTC_AMR_BITMASK			((0xFF))
-
-/**********************************************************************
-* RTC_AUX register definitions
-**********************************************************************/
-/** RTC Oscillator Fail detect flag */
-#define RTC_AUX_RTC_OSCF		((1&lt;&lt;4))
-
-/**********************************************************************
-* RTC_AUXEN register definitions
-**********************************************************************/
-/** Oscillator Fail Detect interrupt enable*/
-#define RTC_AUXEN_RTC_OSCFEN	((1&lt;&lt;4))
-
-
-/* Consolidated time register group ----------------------------------- */
-/** Consolidated Time Register 0 */
-#define RTC_CTIME0_SECONDS_MASK		((0x3F))
-#define RTC_CTIME0_MINUTES_MASK		((0x3F00))
-#define RTC_CTIME0_HOURS_MASK		((0x1F0000))
-#define RTC_CTIME0_DOW_MASK			((0x7000000))
-/** Consolidated Time Register 1 */
-#define RTC_CTIME1_DOM_MASK			((0x1F))
-#define RTC_CTIME1_MONTH_MASK		((0xF00))
-#define RTC_CTIME1_YEAR_MASK		((0xFFF0000))
-/** Consolidated Time Register 2 */
-#define RTC_CTIME2_DOY_MASK			((0xFFF))
-
-
-/* Time Counter Group and Alarm register group ----------------------------- */
-/** SEC register mask */
-#define RTC_SEC_MASK			(0x0000003F)
-/** MIN register mask */
-#define RTC_MIN_MASK			(0x0000003F)
-/** HOUR register mask */
-#define RTC_HOUR_MASK			(0x0000001F)
-/** DOM register mask */
-#define RTC_DOM_MASK			(0x0000001F)
-/** DOW register mask */
-#define RTC_DOW_MASK			(0x00000007)
-/** DOY register mask */
-#define RTC_DOY_MASK			(0x000001FF)
-/** MONTH register mask */
-#define RTC_MONTH_MASK			(0x0000000F)
-/** YEAR register mask */
-#define RTC_YEAR_MASK			(0x00000FFF)
-
-#define RTC_SECOND_MAX		59 /*!&lt; Maximum value of second */
-#define RTC_MINUTE_MAX		59 /*!&lt; Maximum value of minute*/
-#define RTC_HOUR_MAX		23 /*!&lt; Maximum value of hour*/
-#define RTC_MONTH_MIN		1 /*!&lt; Minimum value of month*/
-#define RTC_MONTH_MAX		12 /*!&lt; Maximum value of month*/
-#define RTC_DAYOFMONTH_MIN 	1 /*!&lt; Minimum value of day of month*/
-#define RTC_DAYOFMONTH_MAX 	31 /*!&lt; Maximum value of day of month*/
-#define RTC_DAYOFWEEK_MAX	6 /*!&lt; Maximum value of day of week*/
-#define RTC_DAYOFYEAR_MIN	1 /*!&lt; Minimum value of day of year*/
-#define RTC_DAYOFYEAR_MAX	366 /*!&lt; Maximum value of day of year*/
-#define RTC_YEAR_MAX		4095 /*!&lt; Maximum value of year*/
-
-/* Calibration register */
-/** Calibration value */
-#define RTC_CALIBRATION_CALVAL_MASK		((0x1FFFF))
-/** Calibration direction */
-#define RTC_CALIBRATION_LIBDIR			((1&lt;&lt;17))
-/** Calibration max value */
-#define RTC_CALIBRATION_MAX				((0x20000))
-
-/**
- * @}
- */
-
-/**
- * @}
- */
-
-
-/* Public Types --------------------------------------------------------------- */
-/** @defgroup RTC_Public_Types
- * @{
- */
-
-/** @brief Time structure definitions for easy manipulate the data */
-typedef struct {
-	uint32_t SEC; 		/*!&lt; Seconds Register */
-	uint32_t MIN; 		/*!&lt; Minutes Register */
-	uint32_t HOUR; 		/*!&lt; Hours Register */
-	uint32_t DOM;		/*!&lt; Day of Month Register */
-	uint32_t DOW; 		/*!&lt; Day of Week Register */
-	uint32_t DOY; 		/*!&lt; Day of Year Register */
-	uint32_t MONTH; 	/*!&lt; Months Register */
-	uint32_t YEAR; 		/*!&lt; Years Register */
-} RTC_TIME_Type;
-
-/** @brief RTC interrupt source */
-typedef enum {
-	RTC_INT_COUNTER_INCREASE = RTC_IRL_RTCCIF, 	/*!&lt;  Counter Increment Interrupt */
-	RTC_INT_ALARM = RTC_IRL_RTCALF, 				/*!&lt; The alarm interrupt */
-} RTC_INT_OPT;
-
-#define PARAM_RTC_INT(n)	((n==RTC_INT_COUNTER_INCREASE) || (n==RTC_INT_ALARM))
-
-
-/** @brief RTC time type option */
-typedef enum {
-	RTC_TIMETYPE_SECOND = 0, 		/*!&lt; Second */
-	RTC_TIMETYPE_MINUTE = 1, 		/*!&lt; Month */
-	RTC_TIMETYPE_HOUR = 2, 			/*!&lt; Hour */
-	RTC_TIMETYPE_DAYOFWEEK = 3, 	/*!&lt; Day of week */
-	RTC_TIMETYPE_DAYOFMONTH = 4, 	/*!&lt; Day of month */
-	RTC_TIMETYPE_DAYOFYEAR = 5, 	/*!&lt; Day of year */
-	RTC_TIMETYPE_MONTH = 6, 		/*!&lt; Month */
-	RTC_TIMETYPE_YEAR = 7, 			/*!&lt; Year */
-} RTC_TIMETYPE_Num;
-
-#define PARAM_RTC_TIMETYPE(n)	((n==RTC_TIMETYPE_SECOND) || (n==RTC_TIMETYPE_MINUTE) \
-							|| (n==RTC_TIMETYPE_HOUR) || (n==RTC_TIMETYPE_DAYOFWEEK) \
-							|| (n==RTC_TIMETYPE_DAYOFMONTH) || (n==RTC_TIMETYPE_DAYOFYEAR) \
-							|| (n==RTC_TIMETYPE_MONTH) || (n==RTC_TIMETYPE_YEAR))
-
-
-/**
- * @}
- */
-
-
-/* Public Macros -------------------------------------------------------------- */
-/** @defgroup RTC_Public_Macros
- * @{
- */
-
-/** Macro to determine if it is valid RTC peripheral */
-#define PARAM_RTCx(x)	(((uint32_t *)x)==((uint32_t *)RTC))
-
-/** Calibration definitions */
-#define RTC_CALIB_DIR_FORWARD	((uint8_t)(0))
-#define RTC_CALIB_DIR_BACKWARD	((uint8_t)(1))
-
-#define PARAM_RTC_CALIB_DIR(n)	((n==RTC_CALIB_DIR_FORWARD) || (n==RTC_CALIB_DIR_BACKWARD))
-#define PARAM_RTC_GPREG_CH(n)	((n&gt;=0) &amp;&amp; (n&lt;=4))
-
-#define PARAM_RTC_CALIBRATION_DIR(n)
-
-/**
- * @}
- */
-
-
-/* Public Functions ----------------------------------------------------------- */
-/** @defgroup RTC_Public_Functions
- * @{
- */
-
-void RTC_Init (RTC_TypeDef *RTCx);
-void RTC_DeInit(RTC_TypeDef *RTCx);
-void RTC_ResetClockTickCounter(RTC_TypeDef *RTCx);
-void RTC_Cmd (RTC_TypeDef *RTCx, FunctionalState NewState);
-void RTC_CntIncrIntConfig (RTC_TypeDef *RTCx, uint32_t CntIncrIntType, \
-								FunctionalState NewState);
-void RTC_AlarmIntConfig (RTC_TypeDef *RTCx, uint32_t AlarmTimeType, \
-								FunctionalState NewState);
-void RTC_SetTime (RTC_TypeDef *RTCx, uint32_t Timetype, uint32_t TimeValue);
-uint32_t RTC_GetTime(RTC_TypeDef *RTCx, uint32_t Timetype);
-void RTC_SetFullTime (RTC_TypeDef *RTCx, RTC_TIME_Type *pFullTime);
-void RTC_GetFullTime (RTC_TypeDef *RTCx, RTC_TIME_Type *pFullTime);
-void RTC_SetAlarmTime (RTC_TypeDef *RTCx, uint32_t Timetype, uint32_t ALValue);
-uint32_t RTC_GetAlarmTime (RTC_TypeDef *RTCx, uint32_t Timetype);
-void RTC_SetFullAlarmTime (RTC_TypeDef *RTCx, RTC_TIME_Type *pFullTime);
-void RTC_GetFullAlarmTime (RTC_TypeDef *RTCx, RTC_TIME_Type *pFullTime);
-IntStatus RTC_GetIntPending (RTC_TypeDef *RTCx, uint32_t IntType);
-void RTC_ClearIntPending (RTC_TypeDef *RTCx, uint32_t IntType);
-void RTC_CalibCounterCmd(RTC_TypeDef *RTCx, FunctionalState NewState);
-void RTC_CalibConfig(RTC_TypeDef *RTCx, uint32_t CalibValue, uint8_t CalibDir);
-void RTC_WriteGPREG (RTC_TypeDef *RTCx, uint8_t Channel, uint32_t Value);
-uint32_t RTC_ReadGPREG (RTC_TypeDef *RTCx, uint8_t Channel);
-
-/**
- * @}
- */
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* LPC17XX_RTC_H_ */
-
-/**
- * @}
- */
-
-/* --------------------------------- End Of File ------------------------------ */
+/***********************************************************************//**
+ * @file	: lpc17xx_rtc.h
+ * @brief	: Contains all macro definitions and function prototypes
+ * 				support for RTC firmware library on LPC17xx
+ * @version	: 1.0
+ * @date	: 23. Apr. 2009
+ * @author	: HieuNguyen
+ **************************************************************************
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * products. This software is supplied &quot;AS IS&quot; without any warranties.
+ * NXP Semiconductors assumes no responsibility or liability for the
+ * use of the software, conveys no license or title under any patent,
+ * copyright, or mask work right to the product. NXP Semiconductors
+ * reserves the right to make changes in the software without
+ * notification. NXP Semiconductors also make no representation or
+ * warranty that such application will be suitable for the specified
+ * use without further testing or modification.
+ **************************************************************************/
+
+/* Peripheral group ----------------------------------------------------------- */
+/** @defgroup RTC
+ * @ingroup LPC1700CMSIS_FwLib_Drivers
+ * @{
+ */
+
+#ifndef LPC17XX_RTC_H_
+#define LPC17XX_RTC_H_
+
+/* Includes ------------------------------------------------------------------- */
+#include &quot;LPC17xx.h&quot;
+#include &quot;lpc_types.h&quot;
+
+
+#ifdef __cplusplus
+extern &quot;C&quot;
+{
+#endif
+
+
+/* Private Macros ------------------------------------------------------------- */
+/** @defgroup RTC_Private_Macros
+ * @{
+ */
+
+/** @defgroup RTC_REGISTER_BIT_DEFINITIONS
+ * @{
+ */
+
+/* Miscellaneous register group --------------------------------------------- */
+
+/**********************************************************************
+* ILR register definitions
+**********************************************************************/
+/** ILR register mask */
+#define RTC_ILR_BITMASK			((0x00000003))
+/** Bit inform the source interrupt is counter increment*/
+#define RTC_IRL_RTCCIF			((1&lt;&lt;0))
+/** Bit inform the source interrupt is alarm match*/
+#define RTC_IRL_RTCALF			((1&lt;&lt;1))
+
+
+/**********************************************************************
+* CCR register definitions
+**********************************************************************/
+/** CCR register mask */
+#define RTC_CCR_BITMASK			((0x00000013))
+/** Clock enable */
+#define RTC_CCR_CLKEN			((1&lt;&lt;0))
+/** Clock reset */
+#define RTC_CCR_CTCRST			((1&lt;&lt;1))
+/** Calibration counter enable */
+#define RTC_CCR_CCALEN			((1&lt;&lt;4))
+
+
+/**********************************************************************
+* CIIR register definitions
+**********************************************************************/
+/** Counter Increment Interrupt bit for second */
+#define RTC_CIIR_IMSEC			((1&lt;&lt;0))
+/** Counter Increment Interrupt bit for minute */
+#define RTC_CIIR_IMMIN			((1&lt;&lt;1))
+/** Counter Increment Interrupt bit for hour */
+#define RTC_CIIR_IMHOUR			((1&lt;&lt;2))
+/** Counter Increment Interrupt bit for day of month */
+#define RTC_CIIR_IMDOM			((1&lt;&lt;3))
+/** Counter Increment Interrupt bit for day of week */
+#define RTC_CIIR_IMDOW			((1&lt;&lt;4))
+/** Counter Increment Interrupt bit for day of year */
+#define RTC_CIIR_IMDOY			((1&lt;&lt;5))
+/** Counter Increment Interrupt bit for month */
+#define RTC_CIIR_IMMON			((1&lt;&lt;6))
+/** Counter Increment Interrupt bit for year */
+#define RTC_CIIR_IMYEAR			((1&lt;&lt;7))
+/** CIIR bit mask */
+#define RTC_CIIR_BITMASK		((0xFF))
+
+/**********************************************************************
+* AMR register definitions
+**********************************************************************/
+/** Counter Increment Select Mask bit for second */
+#define RTC_AMR_AMRSEC			((1&lt;&lt;0))
+/** Counter Increment Select Mask bit for minute */
+#define RTC_AMR_AMRMIN			((1&lt;&lt;1))
+/** Counter Increment Select Mask bit for hour */
+#define RTC_AMR_AMRHOUR			((1&lt;&lt;2))
+/** Counter Increment Select Mask bit for day of month */
+#define RTC_AMR_AMRDOM			((1&lt;&lt;3))
+/** Counter Increment Select Mask bit for day of week */
+#define RTC_AMR_AMRDOW			((1&lt;&lt;4))
+/** Counter Increment Select Mask bit for day of year */
+#define RTC_AMR_AMRDOY			((1&lt;&lt;5))
+/** Counter Increment Select Mask bit for month */
+#define RTC_AMR_AMRMON			((1&lt;&lt;6))
+/** Counter Increment Select Mask bit for year */
+#define RTC_AMR_AMRYEAR			((1&lt;&lt;7))
+/** AMR bit mask */
+#define RTC_AMR_BITMASK			((0xFF))
+
+/**********************************************************************
+* RTC_AUX register definitions
+**********************************************************************/
+/** RTC Oscillator Fail detect flag */
+#define RTC_AUX_RTC_OSCF		((1&lt;&lt;4))
+
+/**********************************************************************
+* RTC_AUXEN register definitions
+**********************************************************************/
+/** Oscillator Fail Detect interrupt enable*/
+#define RTC_AUXEN_RTC_OSCFEN	((1&lt;&lt;4))
+
+
+/* Consolidated time register group ----------------------------------- */
+/** Consolidated Time Register 0 */
+#define RTC_CTIME0_SECONDS_MASK		((0x3F))
+#define RTC_CTIME0_MINUTES_MASK		((0x3F00))
+#define RTC_CTIME0_HOURS_MASK		((0x1F0000))
+#define RTC_CTIME0_DOW_MASK			((0x7000000))
+/** Consolidated Time Register 1 */
+#define RTC_CTIME1_DOM_MASK			((0x1F))
+#define RTC_CTIME1_MONTH_MASK		((0xF00))
+#define RTC_CTIME1_YEAR_MASK		((0xFFF0000))
+/** Consolidated Time Register 2 */
+#define RTC_CTIME2_DOY_MASK			((0xFFF))
+
+
+/* Time Counter Group and Alarm register group ----------------------------- */
+/** SEC register mask */
+#define RTC_SEC_MASK			(0x0000003F)
+/** MIN register mask */
+#define RTC_MIN_MASK			(0x0000003F)
+/** HOUR register mask */
+#define RTC_HOUR_MASK			(0x0000001F)
+/** DOM register mask */
+#define RTC_DOM_MASK			(0x0000001F)
+/** DOW register mask */
+#define RTC_DOW_MASK			(0x00000007)
+/** DOY register mask */
+#define RTC_DOY_MASK			(0x000001FF)
+/** MONTH register mask */
+#define RTC_MONTH_MASK			(0x0000000F)
+/** YEAR register mask */
+#define RTC_YEAR_MASK			(0x00000FFF)
+
+#define RTC_SECOND_MAX		59 /*!&lt; Maximum value of second */
+#define RTC_MINUTE_MAX		59 /*!&lt; Maximum value of minute*/
+#define RTC_HOUR_MAX		23 /*!&lt; Maximum value of hour*/
+#define RTC_MONTH_MIN		1 /*!&lt; Minimum value of month*/
+#define RTC_MONTH_MAX		12 /*!&lt; Maximum value of month*/
+#define RTC_DAYOFMONTH_MIN 	1 /*!&lt; Minimum value of day of month*/
+#define RTC_DAYOFMONTH_MAX 	31 /*!&lt; Maximum value of day of month*/
+#define RTC_DAYOFWEEK_MAX	6 /*!&lt; Maximum value of day of week*/
+#define RTC_DAYOFYEAR_MIN	1 /*!&lt; Minimum value of day of year*/
+#define RTC_DAYOFYEAR_MAX	366 /*!&lt; Maximum value of day of year*/
+#define RTC_YEAR_MAX		4095 /*!&lt; Maximum value of year*/
+
+/* Calibration register */
+/** Calibration value */
+#define RTC_CALIBRATION_CALVAL_MASK		((0x1FFFF))
+/** Calibration direction */
+#define RTC_CALIBRATION_LIBDIR			((1&lt;&lt;17))
+/** Calibration max value */
+#define RTC_CALIBRATION_MAX				((0x20000))
+
+/**
+ * @}
+ */
+
+/**
+ * @}
+ */
+
+
+/* Public Types --------------------------------------------------------------- */
+/** @defgroup RTC_Public_Types
+ * @{
+ */
+
+/** @brief Time structure definitions for easy manipulate the data */
+typedef struct {
+	uint32_t SEC; 		/*!&lt; Seconds Register */
+	uint32_t MIN; 		/*!&lt; Minutes Register */
+	uint32_t HOUR; 		/*!&lt; Hours Register */
+	uint32_t DOM;		/*!&lt; Day of Month Register */
+	uint32_t DOW; 		/*!&lt; Day of Week Register */
+	uint32_t DOY; 		/*!&lt; Day of Year Register */
+	uint32_t MONTH; 	/*!&lt; Months Register */
+	uint32_t YEAR; 		/*!&lt; Years Register */
+} RTC_TIME_Type;
+
+/** @brief RTC interrupt source */
+typedef enum {
+	RTC_INT_COUNTER_INCREASE = RTC_IRL_RTCCIF, 	/*!&lt;  Counter Increment Interrupt */
+	RTC_INT_ALARM = RTC_IRL_RTCALF, 				/*!&lt; The alarm interrupt */
+} RTC_INT_OPT;
+
+#define PARAM_RTC_INT(n)	((n==RTC_INT_COUNTER_INCREASE) || (n==RTC_INT_ALARM))
+
+
+/** @brief RTC time type option */
+typedef enum {
+	RTC_TIMETYPE_SECOND = 0, 		/*!&lt; Second */
+	RTC_TIMETYPE_MINUTE = 1, 		/*!&lt; Month */
+	RTC_TIMETYPE_HOUR = 2, 			/*!&lt; Hour */
+	RTC_TIMETYPE_DAYOFWEEK = 3, 	/*!&lt; Day of week */
+	RTC_TIMETYPE_DAYOFMONTH = 4, 	/*!&lt; Day of month */
+	RTC_TIMETYPE_DAYOFYEAR = 5, 	/*!&lt; Day of year */
+	RTC_TIMETYPE_MONTH = 6, 		/*!&lt; Month */
+	RTC_TIMETYPE_YEAR = 7, 			/*!&lt; Year */
+} RTC_TIMETYPE_Num;
+
+#define PARAM_RTC_TIMETYPE(n)	((n==RTC_TIMETYPE_SECOND) || (n==RTC_TIMETYPE_MINUTE) \
+|| (n==RTC_TIMETYPE_HOUR) || (n==RTC_TIMETYPE_DAYOFWEEK) \
+|| (n==RTC_TIMETYPE_DAYOFMONTH) || (n==RTC_TIMETYPE_DAYOFYEAR) \
+|| (n==RTC_TIMETYPE_MONTH) || (n==RTC_TIMETYPE_YEAR))
+
+
+/**
+ * @}
+ */
+
+
+/* Public Macros -------------------------------------------------------------- */
+/** @defgroup RTC_Public_Macros
+ * @{
+ */
+
+/** Macro to determine if it is valid RTC peripheral */
+#define PARAM_RTCx(x)	(((uint32_t *)x)==((uint32_t *)LPC_RTC))
+
+/** Calibration definitions */
+#define RTC_CALIB_DIR_FORWARD	((uint8_t)(0))
+#define RTC_CALIB_DIR_BACKWARD	((uint8_t)(1))
+
+#define PARAM_RTC_CALIB_DIR(n)	((n==RTC_CALIB_DIR_FORWARD) || (n==RTC_CALIB_DIR_BACKWARD))
+#define PARAM_RTC_GPREG_CH(n)	((n&gt;=0) &amp;&amp; (n&lt;=4))
+
+#define PARAM_RTC_CALIBRATION_DIR(n)
+
+/**
+ * @}
+ */
+
+
+/* Public Functions ----------------------------------------------------------- */
+/** @defgroup RTC_Public_Functions
+ * @{
+ */
+
+void RTC_Init (LPC_RTC_TypeDef *RTCx);
+void RTC_DeInit(LPC_RTC_TypeDef *RTCx);
+void RTC_ResetClockTickCounter(LPC_RTC_TypeDef *RTCx);
+void RTC_Cmd (LPC_RTC_TypeDef *RTCx, FunctionalState NewState);
+void RTC_CntIncrIntConfig (LPC_RTC_TypeDef *RTCx, uint32_t CntIncrIntType, \
+								FunctionalState NewState);
+void RTC_AlarmIntConfig (LPC_RTC_TypeDef *RTCx, uint32_t AlarmTimeType, \
+								FunctionalState NewState);
+void RTC_SetTime (LPC_RTC_TypeDef *RTCx, uint32_t Timetype, uint32_t TimeValue);
+uint32_t RTC_GetTime(LPC_RTC_TypeDef *RTCx, uint32_t Timetype);
+void RTC_SetFullTime (LPC_RTC_TypeDef *RTCx, RTC_TIME_Type *pFullTime);
+void RTC_GetFullTime (LPC_RTC_TypeDef *RTCx, RTC_TIME_Type *pFullTime);
+void RTC_SetAlarmTime (LPC_RTC_TypeDef *RTCx, uint32_t Timetype, uint32_t ALValue);
+uint32_t RTC_GetAlarmTime (LPC_RTC_TypeDef *RTCx, uint32_t Timetype);
+void RTC_SetFullAlarmTime (LPC_RTC_TypeDef *RTCx, RTC_TIME_Type *pFullTime);
+void RTC_GetFullAlarmTime (LPC_RTC_TypeDef *RTCx, RTC_TIME_Type *pFullTime);
+IntStatus RTC_GetIntPending (LPC_RTC_TypeDef *RTCx, uint32_t IntType);
+void RTC_ClearIntPending (LPC_RTC_TypeDef *RTCx, uint32_t IntType);
+void RTC_CalibCounterCmd(LPC_RTC_TypeDef *RTCx, FunctionalState NewState);
+void RTC_CalibConfig(LPC_RTC_TypeDef *RTCx, uint32_t CalibValue, uint8_t CalibDir);
+void RTC_WriteGPREG (LPC_RTC_TypeDef *RTCx, uint8_t Channel, uint32_t Value);
+uint32_t RTC_ReadGPREG (LPC_RTC_TypeDef *RTCx, uint8_t Channel);
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LPC17XX_RTC_H_ */
+
+/**
+ * @}
+ */
+
+/* --------------------------------- End Of File ------------------------------ */


Property changes on: trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_rtc.h
___________________________________________________________________
Deleted: svn:executable
   - *

Modified: trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_spi.h
===================================================================
--- trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_spi.h	2010-06-28 21:53:59 UTC (rev 759)
+++ trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_spi.h	2010-07-12 20:56:54 UTC (rev 760)
@@ -1,314 +1,314 @@
-/***********************************************************************//**
- * @file	: lpc17xx_spi.h
- * @brief	: Contains all macro definitions and function prototypes
- * 				support for SPI firmware library on LPC17xx
- * @version	: 1.0
- * @date	: 3. April. 2009
- * @author	: HieuNguyen
- **************************************************************************
- * Software that is described herein is for illustrative purposes only
- * which provides customers with programming information regarding the
- * products. This software is supplied &quot;AS IS&quot; without any warranties.
- * NXP Semiconductors assumes no responsibility or liability for the
- * use of the software, conveys no license or title under any patent,
- * copyright, or mask work right to the product. NXP Semiconductors
- * reserves the right to make changes in the software without
- * notification. NXP Semiconductors also make no representation or
- * warranty that such application will be suitable for the specified
- * use without further testing or modification.
- **************************************************************************/
-
-/* Peripheral group ----------------------------------------------------------- */
-/** @defgroup SPI
- * @ingroup LPC1700CMSIS_FwLib_Drivers
- * @{
- */
-
-#ifndef LPC17XX_SPI_H_
-#define LPC17XX_SPI_H_
-
-/* Includes ------------------------------------------------------------------- */
-#include &quot;LPC17xx.h&quot;
-#include &quot;lpc_types.h&quot;
-
-
-#ifdef __cplusplus
-extern &quot;C&quot;
-{
-#endif
-
-/* Private Macros ------------------------------------------------------------- */
-/** @defgroup SPI_Private_Macros
- * @{
- */
-
-/*********************************************************************//**
- * Macro defines for SPI Control Register
- **********************************************************************/
-/** @defgroup SPI_REGISTER_BIT_DEFINITION
- * @{
- */
-
-/** Bit enable, the SPI controller sends and receives the number
- * of bits selected by bits 11:8 */
-#define SPI_SPCR_BIT_EN			((uint32_t)(1&lt;&lt;2))
-/** Clock phase control bit */
-#define SPI_SPCR_CPHA_SECOND	((uint32_t)(1&lt;&lt;3))
-/** Clock polarity control bit */
-#define SPI_SPCR_CPOL_LOW 		((uint32_t)(1&lt;&lt;4))
-/** SPI master mode enable */
-#define SPI_SPCR_MSTR		 	((uint32_t)(1&lt;&lt;5))
-/** LSB enable bit */
-#define SPI_SPCR_LSBF			((uint32_t)(1&lt;&lt;6))
-/** SPI interrupt enable bit */
-#define SPI_SPCR_SPIE			((uint32_t)(1&lt;&lt;7))
-/**  When bit 2 of this register is 1, this field controls the
-number of bits per transfer */
-#define SPI_SPCR_BITS(n)		((n==0) ? ((uint32_t)0) : ((uint32_t)((n&amp;0x0F)&lt;&lt;8)))
-/** SPI Control bit mask */
-#define SPI_SPCR_BITMASK		((uint32_t)(0xFFC))
-
-
-/*********************************************************************//**
- * Macro defines for  SPI Status Register
- **********************************************************************/
-/** Slave abort */
-#define SPI_SPSR_ABRT		((uint32_t)(1&lt;&lt;3))
-/** Mode fault */
-#define SPI_SPSR_MODF		((uint32_t)(1&lt;&lt;4))
-/** Read overrun */
-#define SPI_SPSR_ROVR		((uint32_t)(1&lt;&lt;5))
-/** Write collision */
-#define SPI_SPSR_WCOL		((uint32_t)(1&lt;&lt;6))
-/** SPI transfer complete flag */
-#define SPI_SPSR_SPIF 		((uint32_t)(1&lt;&lt;7))
-/** SPI Status bit mask */
-#define SPI_SPSR_BITMASK	((uint32_t)(0xF8))
-
-
-/*********************************************************************//**
- * Macro defines for SPI Data Register
- **********************************************************************/
-/** SPI Data low bit-mask */
-#define SPI_SPDR_LO_MASK	((uint32_t)(0xFF))
-/** SPI Data high bit-mask */
-#define SPI_SPDR_HI_MASK	((uint32_t)(0xFF00))
-/** SPI Data bit-mask */
-#define SPI_SPDR_BITMASK	((uint32_t)(0xFFFF))
-
-
-/*********************************************************************//**
- * Macro defines for SPI Clock Counter Register
- **********************************************************************/
-/** SPI clock counter setting */
-#define SPI_SPCCR_COUNTER(n) 	((uint32_t)(n&amp;0xFF))
-/** SPI clock counter bit-mask */
-#define SPI_SPCCR_BITMASK		((uint32_t)(0xFF))
-
-
-/***********************************************************************
- * Macro defines for SPI Test Control Register
- **********************************************************************/
-/** SPI Test bit */
-#define SPI_SPTCR_TEST_MASK	((uint32_t)(0xFE))
-/** SPI Test register bit mask */
-#define SPI_SPTCR_BITMASK	((uint32_t)(0xFE))
-
-
-
-/*********************************************************************//**
- * Macro defines for SPI Test Status Register
- **********************************************************************/
-/** Slave abort */
-#define SPI_SPTSR_ABRT		((uint32_t)(1&lt;&lt;3))
-/** Mode fault */
-#define SPI_SPTSR_MODF		((uint32_t)(1&lt;&lt;4))
-/** Read overrun */
-#define SPI_SPTSR_ROVR		((uint32_t)(1&lt;&lt;5))
-/** Write collision */
-#define SPI_SPTSR_WCOL		((uint32_t)(1&lt;&lt;6))
-/** SPI transfer complete flag */
-#define SPI_SPTSR_SPIF 		((uint32_t)(1&lt;&lt;7))
-/** SPI Status bit mask */
-#define SPI_SPTSR_MASKBIT	((uint32_t)(0xF8))
-
-
-
-/*********************************************************************//**
- * Macro defines for SPI Interrupt Register
- **********************************************************************/
-/** SPI interrupt flag */
-#define SPI_SPINT_INTFLAG 	((uint32_t)(1&lt;&lt;0))
-/** SPI interrupt register bit mask */
-#define SPI_SPINT_BITMASK 	((uint32_t)(0x01))
-
-/**
- * @}
- */
-
-/**
- * @}
- */
-
-
-/* Public Types --------------------------------------------------------------- */
-/** @defgroup SPI_Public_Types
- * @{
- */
-
-/** @brief SPI configuration structure */
-typedef struct {
-	uint32_t Databit; 		/** Databit number, should be SPI_DATABIT_x,
-							where x is in range from 8 - 16 */
-	uint32_t CPHA;			/** Clock phase, should be:
-							- SPI_CPHA_FIRST: first clock edge
-							- SPI_CPHA_SECOND: second clock edge */
-	uint32_t CPOL;			/** Clock polarity, should be:
-							- SPI_CPOL_HI: high level
-							- SPI_CPOL_LO: low level */
-	uint32_t Mode;			/** SPI mode, should be:
-							- SPI_MASTER_MODE: Master mode
-							- SPI_SLAVE_MODE: Slave mode */
-	uint32_t DataOrder;		/** Data order, should be:
-							- SPI_DATA_MSB_FIRST: MSB first
-							- SPI_DATA_LSB_FIRST: LSB first */
-	uint32_t ClockRate;		/** Clock rate,in Hz, should not exceed
-							(SPI peripheral clock)/8 */
-} SPI_CFG_Type;
-
-
-/**
- * @brief SPI Transfer Type definitions
- */
-typedef enum {
-	SPI_TRANSFER_POLLING = 0,	/**&lt; Polling transfer */
-	SPI_TRANSFER_INTERRUPT	/**&lt; Interrupt transfer */
-} SPI_TRANSFER_Type;
-
-/**
- * @brief SPI Data configuration structure definitions
- */
-typedef struct {
-	void *tx_data;			/**&lt; Pointer to transmit data */
-	void *rx_data;			/**&lt; Pointer to transmit data */
-	uint32_t length;			/**&lt; Length of transfer data */
-	uint32_t counter;			/**&lt; Data counter index */
-	uint32_t status;			/**&lt; Current status of SPI activity */
-	void (*callback)(void);		/**&lt; Pointer to Call back function when transmission complete
-								used in interrupt transfer mode */
-} SPI_DATA_SETUP_Type;
-
-/**
- * @}
- */
-
-
-/* Public Macros -------------------------------------------------------------- */
-/** @defgroup SPI_Public_Macros
- * @{
- */
-
-/** Macro to determine if it is valid SPI port number */
-#define PARAM_SPIx(n)	(((uint32_t *)n)==((uint32_t *)SPI))
-
-/*********************************************************************//**
- * SPI configuration parameter defines
- **********************************************************************/
-/** Clock phase control bit */
-#define SPI_CPHA_FIRST			((uint32_t)(0))
-#define SPI_CPHA_SECOND			SPI_SPCR_CPHA_SECOND
-#define PARAM_SPI_CPHA(n) 	((n==SPI_CPHA_FIRST) || (n==SPI_CPHA_SECOND))
-
-/** Clock polarity control bit */
-#define SPI_CPOL_HI				((uint32_t)(0))
-#define SPI_CPOL_LO				SPI_SPCR_CPOL_LOW
-#define PARAM_SPI_CPOL(n)	((n==SPI_CPOL_HI) || (n==SPI_CPOL_LO))
-
-/** SPI master mode enable */
-#define SPI_SLAVE_MODE			((uint32_t)(0))
-#define SPI_MASTER_MODE			SPI_SPCR_MSTR
-#define PARAM_SPI_MODE(n)	((n==SPI_SLAVE_MODE) || (n==SPI_MASTER_MODE))
-
-/** LSB enable bit */
-#define SPI_DATA_MSB_FIRST		((uint32_t)(0))
-#define SPI_DATA_LSB_FIRST		SPI_SPCR_LSBF
-#define PARAM_SPI_DATA_ORDER(n) ((n==SPI_DATA_MSB_FIRST) || (n==SPI_DATA_LSB_FIRST))
-
-/** SPI data bit number defines */
-#define SPI_DATABIT_16		SPI_SPCR_BITS(0)		/*!&lt; Databit number = 16 */
-#define SPI_DATABIT_8		SPI_SPCR_BITS(0x08) 	/*!&lt; Databit number = 8 */
-#define SPI_DATABIT_9		SPI_SPCR_BITS(0x09) 	/*!&lt; Databit number = 9 */
-#define SPI_DATABIT_10		SPI_SPCR_BITS(0x0A) 	/*!&lt; Databit number = 10 */
-#define SPI_DATABIT_11		SPI_SPCR_BITS(0x0B) 	/*!&lt; Databit number = 11 */
-#define SPI_DATABIT_12		SPI_SPCR_BITS(0x0C) 	/*!&lt; Databit number = 12 */
-#define SPI_DATABIT_13		SPI_SPCR_BITS(0x0D) 	/*!&lt; Databit number = 13 */
-#define SPI_DATABIT_14		SPI_SPCR_BITS(0x0E) 	/*!&lt; Databit number = 14 */
-#define SPI_DATABIT_15		SPI_SPCR_BITS(0x0F) 	/*!&lt; Databit number = 15 */
-#define PARAM_SPI_DATABIT(n)	((n==SPI_DATABIT_16) || (n==SPI_DATABIT_8) \
-							|| (n==SPI_DATABIT_9) || (n==SPI_DATABIT_10) \
-							|| (n==SPI_DATABIT_11) || (n==SPI_DATABIT_12) \
-							|| (n==SPI_DATABIT_13) || (n==SPI_DATABIT_14) \
-							|| (n==SPI_DATABIT_15))
-
-
-/*********************************************************************//**
- * SPI Status Flag defines
- **********************************************************************/
-/** Slave abort */
-#define SPI_STAT_ABRT		SPI_SPSR_ABRT
-/** Mode fault */
-#define SPI_STAT_MODF		SPI_SPSR_MODF
-/** Read overrun */
-#define SPI_STAT_ROVR		SPI_SPSR_ROVR
-/** Write collision */
-#define SPI_STAT_WCOL		SPI_SPSR_WCOL
-/** SPI transfer complete flag */
-#define SPI_STAT_SPIF		SPI_SPSR_SPIF
-#define PARAM_SPI_STAT(n)	((n==SPI_STAT_ABRT) || (n==SPI_STAT_MODF) \
-						|| (n==SPI_STAT_ROVR) || (n==SPI_STAT_WCOL) \
-						|| (n==SPI_STAT_SPIF))
-
-
-/* SPI Status Implementation definitions */
-#define SPI_STAT_DONE		(1UL&lt;&lt;8)		/**&lt; Done */
-#define SPI_STAT_ERROR		(1UL&lt;&lt;9)		/**&lt; Error */
-
-/**
- * @}
- */
-
-
-/* Public Functions ----------------------------------------------------------- */
-/** @defgroup SPI_Public_Functions
- * @{
- */
-
-void SPI_SetClock (SPI_TypeDef *SPIx, uint32_t target_clock);
-void SPI_DeInit(SPI_TypeDef *SPIx);
-void SPI_Init(SPI_TypeDef *SPIx, SPI_CFG_Type *SPI_ConfigStruct);
-void SPI_ConfigStructInit(SPI_CFG_Type *SPI_InitStruct);
-void SPI_SendData(SPI_TypeDef *SPIx, uint16_t Data);
-uint16_t SPI_ReceiveData(SPI_TypeDef *SPIx);
-int32_t SPI_ReadWrite (SPI_TypeDef *SPIx, SPI_DATA_SETUP_Type *dataCfg, SPI_TRANSFER_Type xfType);
-void SPI_IntCmd(SPI_TypeDef *SPIx, FunctionalState NewState);
-IntStatus SPI_GetIntStatus (SPI_TypeDef *SPIx);
-void SPI_ClearIntPending(SPI_TypeDef *SPIx);
-uint32_t SPI_GetStatus(SPI_TypeDef *SPIx);
-FlagStatus SPI_CheckStatus (uint32_t inputSPIStatus,  uint8_t SPIStatus);
-void SPI_StdIntHandler(void);
-
-/**
- * @}
- */
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* LPC17XX_SPI_H_ */
-
-/**
- * @}
- */
-
-/* --------------------------------- End Of File ------------------------------ */
+/***********************************************************************//**
+ * @file	: lpc17xx_spi.h
+ * @brief	: Contains all macro definitions and function prototypes
+ * 				support for SPI firmware library on LPC17xx
+ * @version	: 1.0
+ * @date	: 3. April. 2009
+ * @author	: HieuNguyen
+ **************************************************************************
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * products. This software is supplied &quot;AS IS&quot; without any warranties.
+ * NXP Semiconductors assumes no responsibility or liability for the
+ * use of the software, conveys no license or title under any patent,
+ * copyright, or mask work right to the product. NXP Semiconductors
+ * reserves the right to make changes in the software without
+ * notification. NXP Semiconductors also make no representation or
+ * warranty that such application will be suitable for the specified
+ * use without further testing or modification.
+ **************************************************************************/
+
+/* Peripheral group ----------------------------------------------------------- */
+/** @defgroup SPI
+ * @ingroup LPC1700CMSIS_FwLib_Drivers
+ * @{
+ */
+
+#ifndef LPC17XX_SPI_H_
+#define LPC17XX_SPI_H_
+
+/* Includes ------------------------------------------------------------------- */
+#include &quot;LPC17xx.h&quot;
+#include &quot;lpc_types.h&quot;
+
+
+#ifdef __cplusplus
+extern &quot;C&quot;
+{
+#endif
+
+/* Private Macros ------------------------------------------------------------- */
+/** @defgroup SPI_Private_Macros
+ * @{
+ */
+
+/*********************************************************************//**
+ * Macro defines for SPI Control Register
+ **********************************************************************/
+/** @defgroup SPI_REGISTER_BIT_DEFINITION
+ * @{
+ */
+
+/** Bit enable, the SPI controller sends and receives the number
+ * of bits selected by bits 11:8 */
+#define SPI_SPCR_BIT_EN			((uint32_t)(1&lt;&lt;2))
+/** Clock phase control bit */
+#define SPI_SPCR_CPHA_SECOND	((uint32_t)(1&lt;&lt;3))
+/** Clock polarity control bit */
+#define SPI_SPCR_CPOL_LOW 		((uint32_t)(1&lt;&lt;4))
+/** SPI master mode enable */
+#define SPI_SPCR_MSTR		 	((uint32_t)(1&lt;&lt;5))
+/** LSB enable bit */
+#define SPI_SPCR_LSBF			((uint32_t)(1&lt;&lt;6))
+/** SPI interrupt enable bit */
+#define SPI_SPCR_SPIE			((uint32_t)(1&lt;&lt;7))
+/**  When bit 2 of this register is 1, this field controls the
+number of bits per transfer */
+#define SPI_SPCR_BITS(n)		((n==0) ? ((uint32_t)0) : ((uint32_t)((n&amp;0x0F)&lt;&lt;8)))
+/** SPI Control bit mask */
+#define SPI_SPCR_BITMASK		((uint32_t)(0xFFC))
+
+
+/*********************************************************************//**
+ * Macro defines for  SPI Status Register
+ **********************************************************************/
+/** Slave abort */
+#define SPI_SPSR_ABRT		((uint32_t)(1&lt;&lt;3))
+/** Mode fault */
+#define SPI_SPSR_MODF		((uint32_t)(1&lt;&lt;4))
+/** Read overrun */
+#define SPI_SPSR_ROVR		((uint32_t)(1&lt;&lt;5))
+/** Write collision */
+#define SPI_SPSR_WCOL		((uint32_t)(1&lt;&lt;6))
+/** SPI transfer complete flag */
+#define SPI_SPSR_SPIF 		((uint32_t)(1&lt;&lt;7))
+/** SPI Status bit mask */
+#define SPI_SPSR_BITMASK	((uint32_t)(0xF8))
+
+
+/*********************************************************************//**
+ * Macro defines for SPI Data Register
+ **********************************************************************/
+/** SPI Data low bit-mask */
+#define SPI_SPDR_LO_MASK	((uint32_t)(0xFF))
+/** SPI Data high bit-mask */
+#define SPI_SPDR_HI_MASK	((uint32_t)(0xFF00))
+/** SPI Data bit-mask */
+#define SPI_SPDR_BITMASK	((uint32_t)(0xFFFF))
+
+
+/*********************************************************************//**
+ * Macro defines for SPI Clock Counter Register
+ **********************************************************************/
+/** SPI clock counter setting */
+#define SPI_SPCCR_COUNTER(n) 	((uint32_t)(n&amp;0xFF))
+/** SPI clock counter bit-mask */
+#define SPI_SPCCR_BITMASK		((uint32_t)(0xFF))
+
+
+/***********************************************************************
+ * Macro defines for SPI Test Control Register
+ **********************************************************************/
+/** SPI Test bit */
+#define SPI_SPTCR_TEST_MASK	((uint32_t)(0xFE))
+/** SPI Test register bit mask */
+#define SPI_SPTCR_BITMASK	((uint32_t)(0xFE))
+
+
+
+/*********************************************************************//**
+ * Macro defines for SPI Test Status Register
+ **********************************************************************/
+/** Slave abort */
+#define SPI_SPTSR_ABRT		((uint32_t)(1&lt;&lt;3))
+/** Mode fault */
+#define SPI_SPTSR_MODF		((uint32_t)(1&lt;&lt;4))
+/** Read overrun */
+#define SPI_SPTSR_ROVR		((uint32_t)(1&lt;&lt;5))
+/** Write collision */
+#define SPI_SPTSR_WCOL		((uint32_t)(1&lt;&lt;6))
+/** SPI transfer complete flag */
+#define SPI_SPTSR_SPIF 		((uint32_t)(1&lt;&lt;7))
+/** SPI Status bit mask */
+#define SPI_SPTSR_MASKBIT	((uint32_t)(0xF8))
+
+
+
+/*********************************************************************//**
+ * Macro defines for SPI Interrupt Register
+ **********************************************************************/
+/** SPI interrupt flag */
+#define SPI_SPINT_INTFLAG 	((uint32_t)(1&lt;&lt;0))
+/** SPI interrupt register bit mask */
+#define SPI_SPINT_BITMASK 	((uint32_t)(0x01))
+
+/**
+ * @}
+ */
+
+/**
+ * @}
+ */
+
+
+/* Public Types --------------------------------------------------------------- */
+/** @defgroup SPI_Public_Types
+ * @{
+ */
+
+/** @brief SPI configuration structure */
+typedef struct {
+	uint32_t Databit; 		/** Databit number, should be SPI_DATABIT_x,
+							where x is in range from 8 - 16 */
+	uint32_t CPHA;			/** Clock phase, should be:
+							- SPI_CPHA_FIRST: first clock edge
+							- SPI_CPHA_SECOND: second clock edge */
+	uint32_t CPOL;			/** Clock polarity, should be:
+							- SPI_CPOL_HI: high level
+							- SPI_CPOL_LO: low level */
+	uint32_t Mode;			/** SPI mode, should be:
+							- SPI_MASTER_MODE: Master mode
+							- SPI_SLAVE_MODE: Slave mode */
+	uint32_t DataOrder;		/** Data order, should be:
+							- SPI_DATA_MSB_FIRST: MSB first
+							- SPI_DATA_LSB_FIRST: LSB first */
+	uint32_t ClockRate;		/** Clock rate,in Hz, should not exceed
+							(SPI peripheral clock)/8 */
+} SPI_CFG_Type;
+
+
+/**
+ * @brief SPI Transfer Type definitions
+ */
+typedef enum {
+	SPI_TRANSFER_POLLING = 0,	/**&lt; Polling transfer */
+	SPI_TRANSFER_INTERRUPT	/**&lt; Interrupt transfer */
+} SPI_TRANSFER_Type;
+
+/**
+ * @brief SPI Data configuration structure definitions
+ */
+typedef struct {
+	void *tx_data;			/**&lt; Pointer to transmit data */
+	void *rx_data;			/**&lt; Pointer to transmit data */
+	uint32_t length;			/**&lt; Length of transfer data */
+	uint32_t counter;			/**&lt; Data counter index */
+	uint32_t status;			/**&lt; Current status of SPI activity */
+	void (*callback)(void);		/**&lt; Pointer to Call back function when transmission complete
+								used in interrupt transfer mode */
+} SPI_DATA_SETUP_Type;
+
+/**
+ * @}
+ */
+
+
+/* Public Macros -------------------------------------------------------------- */
+/** @defgroup SPI_Public_Macros
+ * @{
+ */
+
+/** Macro to determine if it is valid SPI port number */
+#define PARAM_SPIx(n)	(((uint32_t *)n)==((uint32_t *)LPC_SPI))
+
+/*********************************************************************//**
+ * SPI configuration parameter defines
+ **********************************************************************/
+/** Clock phase control bit */
+#define SPI_CPHA_FIRST			((uint32_t)(0))
+#define SPI_CPHA_SECOND			SPI_SPCR_CPHA_SECOND
+#define PARAM_SPI_CPHA(n) 	((n==SPI_CPHA_FIRST) || (n==SPI_CPHA_SECOND))
+
+/** Clock polarity control bit */
+#define SPI_CPOL_HI				((uint32_t)(0))
+#define SPI_CPOL_LO				SPI_SPCR_CPOL_LOW
+#define PARAM_SPI_CPOL(n)	((n==SPI_CPOL_HI) || (n==SPI_CPOL_LO))
+
+/** SPI master mode enable */
+#define SPI_SLAVE_MODE			((uint32_t)(0))
+#define SPI_MASTER_MODE			SPI_SPCR_MSTR
+#define PARAM_SPI_MODE(n)	((n==SPI_SLAVE_MODE) || (n==SPI_MASTER_MODE))
+
+/** LSB enable bit */
+#define SPI_DATA_MSB_FIRST		((uint32_t)(0))
+#define SPI_DATA_LSB_FIRST		SPI_SPCR_LSBF
+#define PARAM_SPI_DATA_ORDER(n) ((n==SPI_DATA_MSB_FIRST) || (n==SPI_DATA_LSB_FIRST))
+
+/** SPI data bit number defines */
+#define SPI_DATABIT_16		SPI_SPCR_BITS(0)		/*!&lt; Databit number = 16 */
+#define SPI_DATABIT_8		SPI_SPCR_BITS(0x08) 	/*!&lt; Databit number = 8 */
+#define SPI_DATABIT_9		SPI_SPCR_BITS(0x09) 	/*!&lt; Databit number = 9 */
+#define SPI_DATABIT_10		SPI_SPCR_BITS(0x0A) 	/*!&lt; Databit number = 10 */
+#define SPI_DATABIT_11		SPI_SPCR_BITS(0x0B) 	/*!&lt; Databit number = 11 */
+#define SPI_DATABIT_12		SPI_SPCR_BITS(0x0C) 	/*!&lt; Databit number = 12 */
+#define SPI_DATABIT_13		SPI_SPCR_BITS(0x0D) 	/*!&lt; Databit number = 13 */
+#define SPI_DATABIT_14		SPI_SPCR_BITS(0x0E) 	/*!&lt; Databit number = 14 */
+#define SPI_DATABIT_15		SPI_SPCR_BITS(0x0F) 	/*!&lt; Databit number = 15 */
+#define PARAM_SPI_DATABIT(n)	((n==SPI_DATABIT_16) || (n==SPI_DATABIT_8) \
+|| (n==SPI_DATABIT_9) || (n==SPI_DATABIT_10) \
+|| (n==SPI_DATABIT_11) || (n==SPI_DATABIT_12) \
+|| (n==SPI_DATABIT_13) || (n==SPI_DATABIT_14) \
+|| (n==SPI_DATABIT_15))
+
+
+/*********************************************************************//**
+ * SPI Status Flag defines
+ **********************************************************************/
+/** Slave abort */
+#define SPI_STAT_ABRT		SPI_SPSR_ABRT
+/** Mode fault */
+#define SPI_STAT_MODF		SPI_SPSR_MODF
+/** Read overrun */
+#define SPI_STAT_ROVR		SPI_SPSR_ROVR
+/** Write collision */
+#define SPI_STAT_WCOL		SPI_SPSR_WCOL
+/** SPI transfer complete flag */
+#define SPI_STAT_SPIF		SPI_SPSR_SPIF
+#define PARAM_SPI_STAT(n)	((n==SPI_STAT_ABRT) || (n==SPI_STAT_MODF) \
+|| (n==SPI_STAT_ROVR) || (n==SPI_STAT_WCOL) \
+|| (n==SPI_STAT_SPIF))
+
+
+/* SPI Status Implementation definitions */
+#define SPI_STAT_DONE		(1UL&lt;&lt;8)		/**&lt; Done */
+#define SPI_STAT_ERROR		(1UL&lt;&lt;9)		/**&lt; Error */
+
+/**
+ * @}
+ */
+
+
+/* Public Functions ----------------------------------------------------------- */
+/** @defgroup SPI_Public_Functions
+ * @{
+ */
+
+void SPI_SetClock (LPC_SPI_TypeDef *SPIx, uint32_t target_clock);
+void SPI_DeInit(LPC_SPI_TypeDef *SPIx);
+void SPI_Init(LPC_SPI_TypeDef *SPIx, SPI_CFG_Type *SPI_ConfigStruct);
+void SPI_ConfigStructInit(SPI_CFG_Type *SPI_InitStruct);
+void SPI_SendData(LPC_SPI_TypeDef *SPIx, uint16_t Data);
+uint16_t SPI_ReceiveData(LPC_SPI_TypeDef *SPIx);
+int32_t SPI_ReadWrite (LPC_SPI_TypeDef *SPIx, SPI_DATA_SETUP_Type *dataCfg, SPI_TRANSFER_Type xfType);
+void SPI_IntCmd(LPC_SPI_TypeDef *SPIx, FunctionalState NewState);
+IntStatus SPI_GetIntStatus (LPC_SPI_TypeDef *SPIx);
+void SPI_ClearIntPending(LPC_SPI_TypeDef *SPIx);
+uint32_t SPI_GetStatus(LPC_SPI_TypeDef *SPIx);
+FlagStatus SPI_CheckStatus (uint32_t inputSPIStatus,  uint8_t SPIStatus);
+void SPI_StdIntHandler(void);
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LPC17XX_SPI_H_ */
+
+/**
+ * @}
+ */
+
+/* --------------------------------- End Of File ------------------------------ */


Property changes on: trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_spi.h
___________________________________________________________________
Deleted: svn:executable
   - *

Modified: trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_ssp.h
===================================================================
--- trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_ssp.h	2010-06-28 21:53:59 UTC (rev 759)
+++ trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_ssp.h	2010-07-12 20:56:54 UTC (rev 760)
@@ -1,456 +1,457 @@
-/***********************************************************************//**
- * @file	: lpc17xx_ssp.h
- * @brief	: Contains all macro definitions and function prototypes
- * 				support for SSP firmware library on LPC17xx
- * @version	: 1.0
- * @date	: 9. April. 2009
- * @author	: HieuNguyen
- **************************************************************************
- * Software that is described herein is for illustrative purposes only
- * which provides customers with programming information regarding the
- * products. This software is supplied &quot;AS IS&quot; without any warranties.
- * NXP Semiconductors assumes no responsibility or liability for the
- * use of the software, conveys no license or title under any patent,
- * copyright, or mask work right to the product. NXP Semiconductors
- * reserves the right to make changes in the software without
- * notification. NXP Semiconductors also make no representation or
- * warranty that such application will be suitable for the specified
- * use without further testing or modification.
- **************************************************************************/
-
-/* Peripheral group ----------------------------------------------------------- */
-/** @defgroup SSP
- * @ingroup LPC1700CMSIS_FwLib_Drivers
- * @{
- */
-
-#ifndef LPC17XX_SSP_H_
-#define LPC17XX_SSP_H_
-
-/* Includes ------------------------------------------------------------------- */
-#include &quot;LPC17xx.h&quot;
-#include &quot;lpc_types.h&quot;
-
-
-#ifdef __cplusplus
-extern &quot;C&quot;
-{
-#endif
-
-
-/* Private Macros ------------------------------------------------------------- */
-/** @defgroup SSP_Private_Macros
- * @{
- */
-
-/*********************************************************************//**
- * Macro defines for CR0 register
- **********************************************************************/
-
-/** @defgroup SSP_REGISTER_BIT_DEFINITION
- * @{
- */
-
-/** SSP data size select, must be 4 bits to 16 bits */
-#define SSP_CR0_DSS(n)   		((uint32_t)((n-1)&amp;0xF))
-/** SSP control 0 Motorola SPI mode */
-#define SSP_CR0_FRF_SPI  		((uint32_t)(0&lt;&lt;4))
-/** SSP control 0 TI synchronous serial mode */
-#define SSP_CR0_FRF_TI   		((uint32_t)(1&lt;&lt;4))
-/** SSP control 0 National Micro-wire mode */
-#define SSP_CR0_FRF_MICROWIRE  	((uint32_t)(2&lt;&lt;4))
-/** SPI clock polarity bit (used in SPI mode only), (1) = maintains the
-   bus clock high between frames, (0) = low */
-#define SSP_CR0_CPOL_HI		((uint32_t)(1&lt;&lt;6))
-/** SPI clock out phase bit (used in SPI mode only), (1) = captures data
-   on the second clock transition of the frame, (0) = first */
-#define SSP_CR0_CPHA_SECOND	((uint32_t)(1&lt;&lt;7))
-/** SSP serial clock rate value load macro, divider rate is
-   PERIPH_CLK / (cpsr * (SCR + 1)) */
-#define SSP_CR0_SCR(n)   	((uint32_t)((n&amp;0xFF)&lt;&lt;8))
-/** SSP CR0 bit mask */
-#define SSP_CR0_BITMASK		((uint32_t)(0xFFFF))
-
-
-/*********************************************************************//**
- * Macro defines for CR1 register
- **********************************************************************/
-/** SSP control 1 loopback mode enable bit */
-#define SSP_CR1_LBM_EN		((uint32_t)(1&lt;&lt;0))
-/** SSP control 1 enable bit */
-#define SSP_CR1_SSP_EN		((uint32_t)(1&lt;&lt;1))
-/** SSP control 1 slave enable */
-#define SSP_CR1_SLAVE_EN	((uint32_t)(1&lt;&lt;2))
-/** SSP control 1 slave out disable bit, disables transmit line in slave
-   mode */
-#define SSP_CR1_SO_DISABLE	((uint32_t)(1&lt;&lt;3))
-/** SSP CR1 bit mask */
-#define SSP_CR1_BITMASK		((uint32_t)(0x0F))
-
-
-/*********************************************************************//**
- * Macro defines for DR register
- **********************************************************************/
-/** SSP data bit mask */
-#define SSP_DR_BITMASK(n)   ((n)&amp;0xFFFF)
-
-/*********************************************************************//**
- * Macro defines for SR register
- **********************************************************************/
-/** SSP status TX FIFO Empty bit */
-#define SSP_SR_TFE      ((uint32_t)(1&lt;&lt;0))
-/** SSP status TX FIFO not full bit */
-#define SSP_SR_TNF      ((uint32_t)(1&lt;&lt;1))
-/** SSP status RX FIFO not empty bit */
-#define SSP_SR_RNE      ((uint32_t)(1&lt;&lt;2))
-/** SSP status RX FIFO full bit */
-#define SSP_SR_RFF      ((uint32_t)(1&lt;&lt;3))
-/** SSP status SSP Busy bit */
-#define SSP_SR_BSY      ((uint32_t)(1&lt;&lt;4))
-/** SSP SR bit mask */
-#define SSP_SR_BITMASK	((uint32_t)(0x1F))
-
-
-/*********************************************************************//**
- * Macro defines for CPSR register
- **********************************************************************/
-/** SSP clock prescaler */
-#define SSP_CPSR_CPDVSR(n) 	((uint32_t)(n&amp;0xFF))
-/** SSP CPSR bit mask */
-#define SSP_CPSR_BITMASK	((uint32_t)(0xFF))
-
-
-/*********************************************************************//**
- * Macro define for (IMSC) Interrupt Mask Set/Clear registers
- **********************************************************************/
-/** Receive Overrun */
-#define SSP_IMSC_ROR	((uint32_t)(1&lt;&lt;0))
-/** Receive TimeOut */
-#define SSP_IMSC_RT		((uint32_t)(1&lt;&lt;1))
-/** Rx FIFO is at least half full */
-#define SSP_IMSC_RX		((uint32_t)(1&lt;&lt;2))
-/** Tx FIFO is at least half empty */
-#define SSP_IMSC_TX		((uint32_t)(1&lt;&lt;3))
-/** IMSC bit mask */
-#define SSP_IMSC_BITMASK	((uint32_t)(0x0F))
-
-/*********************************************************************//**
- * Macro define for (RIS) Raw Interrupt Status registers
- **********************************************************************/
-/** Receive Overrun */
-#define SSP_RIS_ROR		((uint32_t)(1&lt;&lt;0))
-/** Receive TimeOut */
-#define SSP_RIS_RT		((uint32_t)(1&lt;&lt;1))
-/** Rx FIFO is at least half full */
-#define SSP_RIS_RX		((uint32_t)(1&lt;&lt;2))
-/** Tx FIFO is at least half empty */
-#define SSP_RIS_TX		((uint32_t)(1&lt;&lt;3))
-/** RIS bit mask */
-#define SSP_RIS_BITMASK	((uint32_t)(0x0F))
-
-
-/*********************************************************************//**
- * Macro define for (MIS) Masked Interrupt Status registers
- **********************************************************************/
-/** Receive Overrun */
-#define SSP_MIS_ROR		((uint32_t)(1&lt;&lt;0))
-/** Receive TimeOut */
-#define SSP_MIS_RT		((uint32_t)(1&lt;&lt;1))
-/** Rx FIFO is at least half full */
-#define SSP_MIS_RX		((uint32_t)(1&lt;&lt;2))
-/** Tx FIFO is at least half empty */
-#define SSP_MIS_TX		((uint32_t)(1&lt;&lt;3))
-/** MIS bit mask */
-#define SSP_MIS_BITMASK	((uint32_t)(0x0F))
-
-
-/*********************************************************************//**
- * Macro define for (ICR) Interrupt Clear registers
- **********************************************************************/
-/** Writing a 1 to this bit clears the &quot;frame was received when
- * RxFIFO was full&quot; interrupt */
-#define SSP_ICR_ROR		((uint32_t)(1&lt;&lt;0))
-/** Writing a 1 to this bit clears the &quot;Rx FIFO was not empty and
- * has not been read for a timeout period&quot; interrupt */
-#define SSP_ICR_RT		((uint32_t)(1&lt;&lt;1))
-/** ICR bit mask */
-#define SSP_ICR_BITMASK	((uint32_t)(0x03))
-
-
-/*********************************************************************//**
- * Macro defines for DMACR register
- **********************************************************************/
-/** SSP bit for enabling RX DMA */
-#define SSP_DMA_RXDMA_EN  	((uint32_t)(1&lt;&lt;0))
-/** SSP bit for enabling TX DMA */
-#define SSP_DMA_TXDMA_EN  	((uint32_t)(1&lt;&lt;1))
-/** DMACR	bit mask */
-#define SSP_DMA_BITMASK		((uint32_t)(0x03))
-
-/**
- * @}
- */
-
-/**
- * @}
- */
-
-
-/* Public Types --------------------------------------------------------------- */
-/** @defgroup SSP_Public_Types
- * @{
- */
-
-/** @brief SSP configuration structure */
-typedef struct {
-	uint32_t Databit; 		/** Databit number, should be SSP_DATABIT_x,
-							where x is in range from 4 - 16 */
-	uint32_t CPHA;			/** Clock phase, should be:
-							- SSP_CPHA_FIRST: first clock edge
-							- SSP_CPHA_SECOND: second clock edge */
-	uint32_t CPOL;			/** Clock polarity, should be:
-							- SSP_CPOL_HI: high level
-							- SSP_CPOL_LO: low level */
-	uint32_t Mode;			/** SSP mode, should be:
-							- SSP_MASTER_MODE: Master mode
-							- SSP_SLAVE_MODE: Slave mode */
-	uint32_t FrameFormat;	/** Frame Format:
-							- SSP_FRAME_SPI: Motorola SPI frame format
-							- SSP_FRAME_TI: TI frame format
-							- SSP_FRAME_MICROWIRE: National Microwire frame format */
-	uint32_t ClockRate;		/** Clock rate,in Hz */
-} SSP_CFG_Type;
-
-/**
- * @brief SSP Transfer Type definitions
- */
-typedef enum {
-	SSP_TRANSFER_POLLING = 0,	/**&lt; Polling transfer */
-	SSP_TRANSFER_INTERRUPT		/**&lt; Interrupt transfer */
-} SSP_TRANSFER_Type;
-
-/**
- * @brief SPI Data configuration structure definitions
- */
-typedef struct {
-	void *tx_data;				/**&lt; Pointer to transmit data */
-	uint32_t tx_cnt;			/**&lt; Transmit counter */
-	void *rx_data;				/**&lt; Pointer to transmit data */
-	uint32_t rx_cnt;			/**&lt; Receive counter */
-	uint32_t length;			/**&lt; Length of transfer data */
-	uint32_t status;			/**&lt; Current status of SSP activity */
-	void (*callback)(void);		/**&lt; Pointer to Call back function when transmission complete
-								used in interrupt transfer mode */
-} SSP_DATA_SETUP_Type;
-
-
-/**
- * @}
- */
-
-
-/* Public Macros -------------------------------------------------------------- */
-/** @defgroup SSP_Public_Macros
- * @{
- */
-
-/** Macro to determine if it is valid SSP port number */
-#define PARAM_SSPx(n)	((((uint32_t *)n)==((uint32_t *)SSP0)) \
-						|| (((uint32_t *)n)==((uint32_t *)SSP1)))
-
-/*********************************************************************//**
- * SSP configuration parameter defines
- **********************************************************************/
-/** Clock phase control bit */
-#define SSP_CPHA_FIRST			((uint32_t)(0))
-#define SSP_CPHA_SECOND			SSP_CR0_CPHA_SECOND
-#define PARAM_SSP_CPHA(n) 		((n==SSP_CPHA_FIRST) || (n==SSP_CPHA_SECOND))
-
-/** Clock polarity control bit */
-/* There's no bug here!!!
- * - If bit[6] in SSPnCR0 is 0: SSP controller maintains the bus clock low between frames.
- * That means the active clock is in HI state.
- * - If bit[6] in SSPnCR0 is 1 (SSP_CR0_CPOL_HI): SSP controller maintains the bus clock
- * high between frames. That means the active clock is in LO state.
- */
-#define SSP_CPOL_HI				((uint32_t)(0))
-#define SSP_CPOL_LO				SSP_CR0_CPOL_HI
-#define PARAM_SSP_CPOL(n)		((n==SSP_CPOL_HI) || (n==SSP_CPOL_LO))
-
-/** SSP master mode enable */
-#define SSP_SLAVE_MODE			SSP_CR1_SLAVE_EN
-#define SSP_MASTER_MODE			((uint32_t)(0))
-#define PARAM_SSP_MODE(n)		((n==SSP_SLAVE_MODE) || (n==SSP_MASTER_MODE))
-
-/** SSP data bit number defines */
-#define SSP_DATABIT_4		SSP_CR0_DSS(4) 			/*!&lt; Databit number = 4 */
-#define SSP_DATABIT_5		SSP_CR0_DSS(5) 			/*!&lt; Databit number = 5 */
-#define SSP_DATABIT_6		SSP_CR0_DSS(6) 			/*!&lt; Databit number = 6 */
-#define SSP_DATABIT_7		SSP_CR0_DSS(7) 			/*!&lt; Databit number = 7 */
-#define SSP_DATABIT_8		SSP_CR0_DSS(8) 			/*!&lt; Databit number = 8 */
-#define SSP_DATABIT_9		SSP_CR0_DSS(9) 			/*!&lt; Databit number = 9 */
-#define SSP_DATABIT_10		SSP_CR0_DSS(10) 		/*!&lt; Databit number = 10 */
-#define SSP_DATABIT_11		SSP_CR0_DSS(11) 		/*!&lt; Databit number = 11 */
-#define SSP_DATABIT_12		SSP_CR0_DSS(12) 		/*!&lt; Databit number = 12 */
-#define SSP_DATABIT_13		SSP_CR0_DSS(13) 		/*!&lt; Databit number = 13 */
-#define SSP_DATABIT_14		SSP_CR0_DSS(14) 		/*!&lt; Databit number = 14 */
-#define SSP_DATABIT_15		SSP_CR0_DSS(15) 		/*!&lt; Databit number = 15 */
-#define SSP_DATABIT_16		SSP_CR0_DSS(16) 		/*!&lt; Databit number = 16 */
-#define PARAM_SSP_DATABIT(n) 	((n==SSP_DATABIT_4) || (n==SSP_DATABIT_5) \
-							|| (n==SSP_DATABIT_6) || (n==SSP_DATABIT_16) \
-							|| (n==SSP_DATABIT_7) || (n==SSP_DATABIT_8) \
-							|| (n==SSP_DATABIT_9) || (n==SSP_DATABIT_10) \
-							|| (n==SSP_DATABIT_11) || (n==SSP_DATABIT_12) \
-							|| (n==SSP_DATABIT_13) || (n==SSP_DATABIT_14) \
-							|| (n==SSP_DATABIT_15))
-
-/** SSP Frame Format definition */
-/** Motorola SPI mode */
-#define SSP_FRAME_SPI		SSP_CR0_FRF_SPI
-/** TI synchronous serial mode */
-#define SSP_FRAME_TI		SSP_CR0_FRF_TI
-/** National Micro-wire mode */
-#define SSP_FRAME_MICROWIRE	SSP_CR0_FRF_MICROWIRE
-
-#define PARAM_SSP_FRAME(n) ((n==SSP_FRAME_SPI) || (n==SSP_FRAME_TI) || (n==SSP_FRAME_MICROWIRE))
-
-
-/*********************************************************************//**
- * SSP Status defines
- **********************************************************************/
-/** SSP status TX FIFO Empty bit */
-#define SSP_STAT_TXFIFO_EMPTY		SSP_SR_TFE
-/** SSP status TX FIFO not full bit */
-#define SSP_STAT_TXFIFO_NOTFULL		SSP_SR_TNF
-/** SSP status RX FIFO not empty bit */
-#define SSP_STAT_RXFIFO_NOTEMPTY	SSP_SR_RNE
-/** SSP status RX FIFO full bit */
-#define SSP_STAT_RXFIFO_FULL		SSP_SR_RFF
-/** SSP status SSP Busy bit */
-#define SSP_STAT_BUSY				SSP_SR_BSY
-
-#define PARAM_SSP_STAT(n) ((n==SSP_STAT_TXFIFO_EMPTY) || (n==SSP_STAT_TXFIFO_NOTFULL) \
-						|| (n==SSP_STAT_RXFIFO_NOTEMPTY) || (n==SSP_STAT_RXFIFO_FULL) \
-						|| (n==SSP_STAT_BUSY))
-
-
-/*********************************************************************//**
- * SSP Interrupt Configuration defines
- **********************************************************************/
-/** Receive Overrun */
-#define SSP_INTCFG_ROR		SSP_IMSC_ROR
-/** Receive TimeOut */
-#define SSP_INTCFG_RT		SSP_IMSC_RT
-/** Rx FIFO is at least half full */
-#define SSP_INTCFG_RX		SSP_IMSC_RX
-/** Tx FIFO is at least half empty */
-#define SSP_INTCFG_TX		SSP_IMSC_TX
-
-#define PARAM_SSP_INTCFG(n)	((n==SSP_INTCFG_ROR) || (n==SSP_INTCFG_RT) \
-						|| (n==SSP_INTCFG_RX) || (n==SSP_INTCFG_TX))
-
-
-/*********************************************************************//**
- * SSP Configured Interrupt Status defines
- **********************************************************************/
-/** Receive Overrun */
-#define SSP_INTSTAT_ROR		SSP_MIS_ROR
-/** Receive TimeOut */
-#define SSP_INTSTAT_RT		SSP_MIS_RT
-/** Rx FIFO is at least half full */
-#define SSP_INTSTAT_RX		SSP_MIS_RX
-/** Tx FIFO is at least half empty */
-#define SSP_INTSTAT_TX		SSP_MIS_TX
-
-#define PARAM_SSP_INTSTAT(n) ((n==SSP_INTSTAT_ROR) || (n==SSP_INTSTAT_RT) \
-							|| (n==SSP_INTSTAT_RX) || (n==SSP_INTSTAT_TX))
-
-
-/*********************************************************************//**
- * SSP Raw Interrupt Status defines
- **********************************************************************/
-/** Receive Overrun */
-#define SSP_INTSTAT_RAW_ROR		SSP_RIS_ROR
-/** Receive TimeOut */
-#define SSP_INTSTAT_RAW_RT		SSP_RIS_RT
-/** Rx FIFO is at least half full */
-#define SSP_INTSTAT_RAW_RX		SSP_RIS_RX
-/** Tx FIFO is at least half empty */
-#define SSP_INTSTAT_RAW_TX		SSP_RIS_TX
-
-#define PARAM_SSP_INTSTAT_RAW(n)	((n==SSP_INTSTAT_RAW_ROR) || (n==SSP_INTSTAT_RAW_RT) \
-								|| (n==SSP_INTSTAT_RAW_RX) || (n==SSP_INTSTAT_RAW_TX))
-
-
-/*********************************************************************//**
- * SSP Interrupt Clear defines
- **********************************************************************/
-/** Writing a 1 to this bit clears the &quot;frame was received when
- * RxFIFO was full&quot; interrupt */
-#define SSP_INTCLR_ROR		SSP_ICR_ROR
-/** Writing a 1 to this bit clears the &quot;Rx FIFO was not empty and
- * has not been read for a timeout period&quot; interrupt */
-#define SSP_INTCLR_RT		SSP_ICR_RT
-
-#define PARAM_SSP_INTCLR(n)	((n==SSP_INTCLR_ROR) || (n==SSP_INTCLR_RT))
-
-
-/*********************************************************************//**
- * SSP DMA defines
- **********************************************************************/
-/** SSP bit for enabling RX DMA */
-#define SSP_DMA_TX		SSP_DMA_RXDMA_EN
-/** SSP bit for enabling TX DMA */
-#define SSP_DMA_RX		SSP_DMA_TXDMA_EN
-
-#define PARAM_SSP_DMA(n)	((n==SSP_DMA_TX) || (n==SSP_DMA_RX))
-
-/* SSP Status Implementation definitions */
-#define SSP_STAT_DONE		(1UL&lt;&lt;8)		/**&lt; Done */
-#define SSP_STAT_ERROR		(1UL&lt;&lt;9)		/**&lt; Error */
-
-/**
- * @}
- */
-
-
-/* Public Functions ----------------------------------------------------------- */
-/** @defgroup SSP_Public_Functions
- * @{
- */
-
-void SSP_SetClock (SSP_TypeDef *SSPx, uint32_t target_clock);
-void SSP_DeInit(SSP_TypeDef* SSPx);
-void SSP_Init(SSP_TypeDef *SSPx, SSP_CFG_Type *SSP_ConfigStruct);
-void SSP_ConfigStructInit(SSP_CFG_Type *SSP_InitStruct);
-void SSP_Cmd(SSP_TypeDef* SSPx, FunctionalState NewState);
-void SSP_LoopBackCmd(SSP_TypeDef* SSPx, FunctionalState NewState);
-void SSP_SlaveOutputCmd(SSP_TypeDef* SSPx, FunctionalState NewState);
-void SSP_SendData(SSP_TypeDef* SSPx, uint16_t Data);
-uint16_t SSP_ReceiveData(SSP_TypeDef* SSPx);
-int32_t SSP_ReadWrite (SSP_TypeDef *SSPx, SSP_DATA_SETUP_Type *dataCfg, \
-						SSP_TRANSFER_Type xfType);
-FlagStatus SSP_GetStatus(SSP_TypeDef* SSPx, uint32_t FlagType);
-void SSP_IntConfig(SSP_TypeDef *SSPx, uint32_t IntType, FunctionalState NewState);
-IntStatus SSP_GetRawIntStatus(SSP_TypeDef *SSPx, uint32_t RawIntType);
-IntStatus SSP_GetIntStatus (SSP_TypeDef *SSPx, uint32_t IntType);
-void SSP_ClearIntPending(SSP_TypeDef *SSPx, uint32_t IntType);
-void SSP_DMACmd(SSP_TypeDef *SSPx, uint32_t DMAMode, FunctionalState NewState);
-void SSP0_StdIntHandler(void);
-void SSP1_StdIntHandler(void);
-
-/**
- * @}
- */
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* LPC17XX_SSP_H_ */
-
-/**
- * @}
- */
-
-/* --------------------------------- End Of File ------------------------------ */
+/***********************************************************************//**
+ * @file	: lpc17xx_ssp.h
+ * @brief	: Contains all macro definitions and function prototypes
+ * 				support for SSP firmware library on LPC17xx
+ * @version	: 1.0
+ * @date	: 9. April. 2009
+ * @author	: HieuNguyen
+ **************************************************************************
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * products. This software is supplied &quot;AS IS&quot; without any warranties.
+ * NXP Semiconductors assumes no responsibility or liability for the
+ * use of the software, conveys no license or title under any patent,
+ * copyright, or mask work right to the product. NXP Semiconductors
+ * reserves the right to make changes in the software without
+ * notification. NXP Semiconductors also make no representation or
+ * warranty that such application will be suitable for the specified
+ * use without further testing or modification.
+ **************************************************************************/
+
+/* Peripheral group ----------------------------------------------------------- */
+/** @defgroup SSP
+ * @ingroup LPC1700CMSIS_FwLib_Drivers
+ * @{
+ */
+
+#ifndef LPC17XX_SSP_H_
+#define LPC17XX_SSP_H_
+
+/* Includes ------------------------------------------------------------------- */
+#include &quot;LPC17xx.h&quot;
+#include &quot;lpc_types.h&quot;
+
+
+#ifdef __cplusplus
+extern &quot;C&quot;
+{
+#endif
+
+
+/* Private Macros ------------------------------------------------------------- */
+/** @defgroup SSP_Private_Macros
+ * @{
+ */
+
+/*********************************************************************//**
+ * Macro defines for CR0 register
+ **********************************************************************/
+
+/** @defgroup SSP_REGISTER_BIT_DEFINITION
+ * @{
+ */
+
+/** SSP data size select, must be 4 bits to 16 bits */
+#define SSP_CR0_DSS(n)   		((uint32_t)((n-1)&amp;0xF))
+/** SSP control 0 Motorola SPI mode */
+#define SSP_CR0_FRF_SPI  		((uint32_t)(0&lt;&lt;4))
+/** SSP control 0 TI synchronous serial mode */
+#define SSP_CR0_FRF_TI   		((uint32_t)(1&lt;&lt;4))
+/** SSP control 0 National Micro-wire mode */
+#define SSP_CR0_FRF_MICROWIRE  	((uint32_t)(2&lt;&lt;4))
+/** SPI clock polarity bit (used in SPI mode only), (1) = maintains the
+   bus clock high between frames, (0) = low */
+#define SSP_CR0_CPOL_HI		((uint32_t)(1&lt;&lt;6))
+/** SPI clock out phase bit (used in SPI mode only), (1) = captures data
+   on the second clock transition of the frame, (0) = first */
+#define SSP_CR0_CPHA_SECOND	((uint32_t)(1&lt;&lt;7))
+/** SSP serial clock rate value load macro, divider rate is
+   PERIPH_CLK / (cpsr * (SCR + 1)) */
+#define SSP_CR0_SCR(n)   	((uint32_t)((n&amp;0xFF)&lt;&lt;8))
+/** SSP CR0 bit mask */
+#define SSP_CR0_BITMASK		((uint32_t)(0xFFFF))
+
+
+/*********************************************************************//**
+ * Macro defines for CR1 register
+ **********************************************************************/
+/** SSP control 1 loopback mode enable bit */
+#define SSP_CR1_LBM_EN		((uint32_t)(1&lt;&lt;0))
+/** SSP control 1 enable bit */
+#define SSP_CR1_SSP_EN		((uint32_t)(1&lt;&lt;1))
+/** SSP control 1 slave enable */
+#define SSP_CR1_SLAVE_EN	((uint32_t)(1&lt;&lt;2))
+/** SSP control 1 slave out disable bit, disables transmit line in slave
+   mode */
+#define SSP_CR1_SO_DISABLE	((uint32_t)(1&lt;&lt;3))
+/** SSP CR1 bit mask */
+#define SSP_CR1_BITMASK		((uint32_t)(0x0F))
+
+
+/*********************************************************************//**
+ * Macro defines for DR register
+ **********************************************************************/
+/** SSP data bit mask */
+#define SSP_DR_BITMASK(n)   ((n)&amp;0xFFFF)
+
+/*********************************************************************//**
+ * Macro defines for SR register
+ **********************************************************************/
+/** SSP status TX FIFO Empty bit */
+#define SSP_SR_TFE      ((uint32_t)(1&lt;&lt;0))
+/** SSP status TX FIFO not full bit */
+#define SSP_SR_TNF      ((uint32_t)(1&lt;&lt;1))
+/** SSP status RX FIFO not empty bit */
+#define SSP_SR_RNE      ((uint32_t)(1&lt;&lt;2))
+/** SSP status RX FIFO full bit */
+#define SSP_SR_RFF      ((uint32_t)(1&lt;&lt;3))
+/** SSP status SSP Busy bit */
+#define SSP_SR_BSY      ((uint32_t)(1&lt;&lt;4))
+/** SSP SR bit mask */
+#define SSP_SR_BITMASK	((uint32_t)(0x1F))
+
+
+/*********************************************************************//**
+ * Macro defines for CPSR register
+ **********************************************************************/
+/** SSP clock prescaler */
+#define SSP_CPSR_CPDVSR(n) 	((uint32_t)(n&amp;0xFF))
+/** SSP CPSR bit mask */
+#define SSP_CPSR_BITMASK	((uint32_t)(0xFF))
+
+
+/*********************************************************************//**
+ * Macro define for (IMSC) Interrupt Mask Set/Clear registers
+ **********************************************************************/
+/** Receive Overrun */
+#define SSP_IMSC_ROR	((uint32_t)(1&lt;&lt;0))
+/** Receive TimeOut */
+#define SSP_IMSC_RT		((uint32_t)(1&lt;&lt;1))
+/** Rx FIFO is at least half full */
+#define SSP_IMSC_RX		((uint32_t)(1&lt;&lt;2))
+/** Tx FIFO is at least half empty */
+#define SSP_IMSC_TX		((uint32_t)(1&lt;&lt;3))
+/** IMSC bit mask */
+#define SSP_IMSC_BITMASK	((uint32_t)(0x0F))
+
+/*********************************************************************//**
+ * Macro define for (RIS) Raw Interrupt Status registers
+ **********************************************************************/
+/** Receive Overrun */
+#define SSP_RIS_ROR		((uint32_t)(1&lt;&lt;0))
+/** Receive TimeOut */
+#define SSP_RIS_RT		((uint32_t)(1&lt;&lt;1))
+/** Rx FIFO is at least half full */
+#define SSP_RIS_RX		((uint32_t)(1&lt;&lt;2))
+/** Tx FIFO is at least half empty */
+#define SSP_RIS_TX		((uint32_t)(1&lt;&lt;3))
+/** RIS bit mask */
+#define SSP_RIS_BITMASK	((uint32_t)(0x0F))
+
+
+/*********************************************************************//**
+ * Macro define for (MIS) Masked Interrupt Status registers
+ **********************************************************************/
+/** Receive Overrun */
+#define SSP_MIS_ROR		((uint32_t)(1&lt;&lt;0))
+/** Receive TimeOut */
+#define SSP_MIS_RT		((uint32_t)(1&lt;&lt;1))
+/** Rx FIFO is at least half full */
+#define SSP_MIS_RX		((uint32_t)(1&lt;&lt;2))
+/** Tx FIFO is at least half empty */
+#define SSP_MIS_TX		((uint32_t)(1&lt;&lt;3))
+/** MIS bit mask */
+#define SSP_MIS_BITMASK	((uint32_t)(0x0F))
+
+
+/*********************************************************************//**
+ * Macro define for (ICR) Interrupt Clear registers
+ **********************************************************************/
+/** Writing a 1 to this bit clears the &quot;frame was received when
+ * RxFIFO was full&quot; interrupt */
+#define SSP_ICR_ROR		((uint32_t)(1&lt;&lt;0))
+/** Writing a 1 to this bit clears the &quot;Rx FIFO was not empty and
+ * has not been read for a timeout period&quot; interrupt */
+#define SSP_ICR_RT		((uint32_t)(1&lt;&lt;1))
+/** ICR bit mask */
+#define SSP_ICR_BITMASK	((uint32_t)(0x03))
+
+
+/*********************************************************************//**
+ * Macro defines for DMACR register
+ **********************************************************************/
+/** SSP bit for enabling RX DMA */
+#define SSP_DMA_RXDMA_EN  	((uint32_t)(1&lt;&lt;0))
+/** SSP bit for enabling TX DMA */
+#define SSP_DMA_TXDMA_EN  	((uint32_t)(1&lt;&lt;1))
+/** DMACR	bit mask */
+#define SSP_DMA_BITMASK		((uint32_t)(0x03))
+
+/**
+ * @}
+ */
+
+/**
+ * @}
+ */
+
+
+/* Public Types --------------------------------------------------------------- */
+/** @defgroup SSP_Public_Types
+ * @{
+ */
+
+/** @brief SSP configuration structure */
+typedef struct {
+	uint32_t Databit; 		/** Databit number, should be SSP_DATABIT_x,
+							where x is in range from 4 - 16 */
+	uint32_t CPHA;			/** Clock phase, should be:
+							- SSP_CPHA_FIRST: first clock edge
+							- SSP_CPHA_SECOND: second clock edge */
+	uint32_t CPOL;			/** Clock polarity, should be:
+							- SSP_CPOL_HI: high level
+							- SSP_CPOL_LO: low level */
+	uint32_t Mode;			/** SSP mode, should be:
+							- SSP_MASTER_MODE: Master mode
+							- SSP_SLAVE_MODE: Slave mode */
+	uint32_t FrameFormat;	/** Frame Format:
+							- SSP_FRAME_SPI: Motorola SPI frame format
+							- SSP_FRAME_TI: TI frame format
+							- SSP_FRAME_MICROWIRE: National Microwire frame format */
+	uint32_t ClockRate;		/** Clock rate,in Hz */
+} SSP_CFG_Type;
+
+/**
+ * @brief SSP Transfer Type definitions
+ */
+typedef enum {
+	SSP_TRANSFER_POLLING = 0,	/**&lt; Polling transfer */
+	SSP_TRANSFER_INTERRUPT		/**&lt; Interrupt transfer */
+} SSP_TRANSFER_Type;
+
+/**
+ * @brief SPI Data configuration structure definitions
+ */
+typedef struct {
+	void *tx_data;				/**&lt; Pointer to transmit data */
+	uint32_t tx_cnt;			/**&lt; Transmit counter */
+	void *rx_data;				/**&lt; Pointer to transmit data */
+	uint32_t rx_cnt;			/**&lt; Receive counter */
+	uint32_t length;			/**&lt; Length of transfer data */
+	uint32_t status;			/**&lt; Current status of SSP activity */
+	void (*callback)(void);		/**&lt; Pointer to Call back function when transmission complete
+								used in interrupt transfer mode */
+} SSP_DATA_SETUP_Type;
+
+
+/**
+ * @}
+ */
+
+
+/* Public Macros -------------------------------------------------------------- */
+/** @defgroup SSP_Public_Macros
+ * @{
+ */
+
+/** Macro to determine if it is valid SSP port number */
+#define PARAM_SSPx(n)	((((uint32_t *)n)==((uint32_t *)LPC_SSP0)) \
+|| (((uint32_t *)n)==((uint32_t *)LPC_SSP1)))
+
+/*********************************************************************//**
+ * SSP configuration parameter defines
+ **********************************************************************/
+/** Clock phase control bit */
+#define SSP_CPHA_FIRST			((uint32_t)(0))
+#define SSP_CPHA_SECOND			SSP_CR0_CPHA_SECOND
+#define PARAM_SSP_CPHA(n) 		((n==SSP_CPHA_FIRST) || (n==SSP_CPHA_SECOND))
+
+/** Clock polarity control bit */
+/* There's no bug here!!!
+ * - If bit[6] in SSPnCR0 is 0: SSP controller maintains the bus clock low between frames.
+ * That means the active clock is in HI state.
+ * - If bit[6] in SSPnCR0 is 1 (SSP_CR0_CPOL_HI): SSP controller maintains the bus clock
+ * high between frames. That means the active clock is in LO state.
+ */
+#define SSP_CPOL_HI				((uint32_t)(0))
+#define SSP_CPOL_LO				SSP_CR0_CPOL_HI
+#define PARAM_SSP_CPOL(n)		((n==SSP_CPOL_HI) || (n==SSP_CPOL_LO))
+
+/** SSP master mode enable */
+#define SSP_SLAVE_MODE			SSP_CR1_SLAVE_EN
+#define SSP_MASTER_MODE			((uint32_t)(0))
+#define PARAM_SSP_MODE(n)		((n==SSP_SLAVE_MODE) || (n==SSP_MASTER_MODE))
+
+/** SSP data bit number defines */
+#define SSP_DATABIT_4		SSP_CR0_DSS(4) 			/*!&lt; Databit number = 4 */
+#define SSP_DATABIT_5		SSP_CR0_DSS(5) 			/*!&lt; Databit number = 5 */
+#define SSP_DATABIT_6		SSP_CR0_DSS(6) 			/*!&lt; Databit number = 6 */
+#define SSP_DATABIT_7		SSP_CR0_DSS(7) 			/*!&lt; Databit number = 7 */
+#define SSP_DATABIT_8		SSP_CR0_DSS(8) 			/*!&lt; Databit number = 8 */
+#define SSP_DATABIT_9		SSP_CR0_DSS(9) 			/*!&lt; Databit number = 9 */
+#define SSP_DATABIT_10		SSP_CR0_DSS(10) 		/*!&lt; Databit number = 10 */
+#define SSP_DATABIT_11		SSP_CR0_DSS(11) 		/*!&lt; Databit number = 11 */
+#define SSP_DATABIT_12		SSP_CR0_DSS(12) 		/*!&lt; Databit number = 12 */
+#define SSP_DATABIT_13		SSP_CR0_DSS(13) 		/*!&lt; Databit number = 13 */
+#define SSP_DATABIT_14		SSP_CR0_DSS(14) 		/*!&lt; Databit number = 14 */
+#define SSP_DATABIT_15		SSP_CR0_DSS(15) 		/*!&lt; Databit number = 15 */
+#define SSP_DATABIT_16		SSP_CR0_DSS(16) 		/*!&lt; Databit number = 16 */
+#define PARAM_SSP_DATABIT(n) 	((n==SSP_DATABIT_4) || (n==SSP_DATABIT_5) \
+|| (n==SSP_DATABIT_6) || (n==SSP_DATABIT_16) \
+|| (n==SSP_DATABIT_7) || (n==SSP_DATABIT_8) \
+|| (n==SSP_DATABIT_9) || (n==SSP_DATABIT_10) \
+|| (n==SSP_DATABIT_11) || (n==SSP_DATABIT_12) \
+|| (n==SSP_DATABIT_13) || (n==SSP_DATABIT_14) \
+|| (n==SSP_DATABIT_15))
+
+/** SSP Frame Format definition */
+/** Motorola SPI mode */
+#define SSP_FRAME_SPI		SSP_CR0_FRF_SPI
+/** TI synchronous serial mode */
+#define SSP_FRAME_TI		SSP_CR0_FRF_TI
+/** National Micro-wire mode */
+#define SSP_FRAME_MICROWIRE	SSP_CR0_FRF_MICROWIRE
+
+#define PARAM_SSP_FRAME(n) ((n==SSP_FRAME_SPI) || (n==SSP_FRAME_TI)\
+|| (n==SSP_FRAME_MICROWIRE))
+
+
+/*********************************************************************//**
+ * SSP Status defines
+ **********************************************************************/
+/** SSP status TX FIFO Empty bit */
+#define SSP_STAT_TXFIFO_EMPTY		SSP_SR_TFE
+/** SSP status TX FIFO not full bit */
+#define SSP_STAT_TXFIFO_NOTFULL		SSP_SR_TNF
+/** SSP status RX FIFO not empty bit */
+#define SSP_STAT_RXFIFO_NOTEMPTY	SSP_SR_RNE
+/** SSP status RX FIFO full bit */
+#define SSP_STAT_RXFIFO_FULL		SSP_SR_RFF
+/** SSP status SSP Busy bit */
+#define SSP_STAT_BUSY				SSP_SR_BSY
+
+#define PARAM_SSP_STAT(n) ((n==SSP_STAT_TXFIFO_EMPTY) || (n==SSP_STAT_TXFIFO_NOTFULL) \
+|| (n==SSP_STAT_RXFIFO_NOTEMPTY) || (n==SSP_STAT_RXFIFO_FULL) \
+|| (n==SSP_STAT_BUSY))
+
+
+/*********************************************************************//**
+ * SSP Interrupt Configuration defines
+ **********************************************************************/
+/** Receive Overrun */
+#define SSP_INTCFG_ROR		SSP_IMSC_ROR
+/** Receive TimeOut */
+#define SSP_INTCFG_RT		SSP_IMSC_RT
+/** Rx FIFO is at least half full */
+#define SSP_INTCFG_RX		SSP_IMSC_RX
+/** Tx FIFO is at least half empty */
+#define SSP_INTCFG_TX		SSP_IMSC_TX
+
+#define PARAM_SSP_INTCFG(n)	((n==SSP_INTCFG_ROR) || (n==SSP_INTCFG_RT) \
+|| (n==SSP_INTCFG_RX) || (n==SSP_INTCFG_TX))
+
+
+/*********************************************************************//**
+ * SSP Configured Interrupt Status defines
+ **********************************************************************/
+/** Receive Overrun */
+#define SSP_INTSTAT_ROR		SSP_MIS_ROR
+/** Receive TimeOut */
+#define SSP_INTSTAT_RT		SSP_MIS_RT
+/** Rx FIFO is at least half full */
+#define SSP_INTSTAT_RX		SSP_MIS_RX
+/** Tx FIFO is at least half empty */
+#define SSP_INTSTAT_TX		SSP_MIS_TX
+
+#define PARAM_SSP_INTSTAT(n) ((n==SSP_INTSTAT_ROR) || (n==SSP_INTSTAT_RT) \
+|| (n==SSP_INTSTAT_RX) || (n==SSP_INTSTAT_TX))
+
+
+/*********************************************************************//**
+ * SSP Raw Interrupt Status defines
+ **********************************************************************/
+/** Receive Overrun */
+#define SSP_INTSTAT_RAW_ROR		SSP_RIS_ROR
+/** Receive TimeOut */
+#define SSP_INTSTAT_RAW_RT		SSP_RIS_RT
+/** Rx FIFO is at least half full */
+#define SSP_INTSTAT_RAW_RX		SSP_RIS_RX
+/** Tx FIFO is at least half empty */
+#define SSP_INTSTAT_RAW_TX		SSP_RIS_TX
+
+#define PARAM_SSP_INTSTAT_RAW(n)	((n==SSP_INTSTAT_RAW_ROR) || (n==SSP_INTSTAT_RAW_RT) \
+|| (n==SSP_INTSTAT_RAW_RX) || (n==SSP_INTSTAT_RAW_TX))
+
+
+/*********************************************************************//**
+ * SSP Interrupt Clear defines
+ **********************************************************************/
+/** Writing a 1 to this bit clears the &quot;frame was received when
+ * RxFIFO was full&quot; interrupt */
+#define SSP_INTCLR_ROR		SSP_ICR_ROR
+/** Writing a 1 to this bit clears the &quot;Rx FIFO was not empty and
+ * has not been read for a timeout period&quot; interrupt */
+#define SSP_INTCLR_RT		SSP_ICR_RT
+
+#define PARAM_SSP_INTCLR(n)	((n==SSP_INTCLR_ROR) || (n==SSP_INTCLR_RT))
+
+
+/*********************************************************************//**
+ * SSP DMA defines
+ **********************************************************************/
+/** SSP bit for enabling RX DMA */
+#define SSP_DMA_TX		SSP_DMA_RXDMA_EN
+/** SSP bit for enabling TX DMA */
+#define SSP_DMA_RX		SSP_DMA_TXDMA_EN
+
+#define PARAM_SSP_DMA(n)	((n==SSP_DMA_TX) || (n==SSP_DMA_RX))
+
+/* SSP Status Implementation definitions */
+#define SSP_STAT_DONE		(1UL&lt;&lt;8)		/**&lt; Done */
+#define SSP_STAT_ERROR		(1UL&lt;&lt;9)		/**&lt; Error */
+
+/**
+ * @}
+ */
+
+
+/* Public Functions ----------------------------------------------------------- */
+/** @defgroup SSP_Public_Functions
+ * @{
+ */
+
+void SSP_SetClock (LPC_SSP_TypeDef *SSPx, uint32_t target_clock);
+void SSP_DeInit(LPC_SSP_TypeDef* SSPx);
+void SSP_Init(LPC_SSP_TypeDef *SSPx, SSP_CFG_Type *SSP_ConfigStruct);
+void SSP_ConfigStructInit(SSP_CFG_Type *SSP_InitStruct);
+void SSP_Cmd(LPC_SSP_TypeDef* SSPx, FunctionalState NewState);
+void SSP_LoopBackCmd(LPC_SSP_TypeDef* SSPx, FunctionalState NewState);
+void SSP_SlaveOutputCmd(LPC_SSP_TypeDef* SSPx, FunctionalState NewState);
+void SSP_SendData(LPC_SSP_TypeDef* SSPx, uint16_t Data);
+uint16_t SSP_ReceiveData(LPC_SSP_TypeDef* SSPx);
+int32_t SSP_ReadWrite (LPC_SSP_TypeDef *SSPx, SSP_DATA_SETUP_Type *dataCfg, \
+						SSP_TRANSFER_Type xfType);
+FlagStatus SSP_GetStatus(LPC_SSP_TypeDef* SSPx, uint32_t FlagType);
+void SSP_IntConfig(LPC_SSP_TypeDef *SSPx, uint32_t IntType, FunctionalState NewState);
+IntStatus SSP_GetRawIntStatus(LPC_SSP_TypeDef *SSPx, uint32_t RawIntType);
+IntStatus SSP_GetIntStatus (LPC_SSP_TypeDef *SSPx, uint32_t IntType);
+void SSP_ClearIntPending(LPC_SSP_TypeDef *SSPx, uint32_t IntType);
+void SSP_DMACmd(LPC_SSP_TypeDef *SSPx, uint32_t DMAMode, FunctionalState NewState);
+void SSP0_StdIntHandler(void);
+void SSP1_StdIntHandler(void);
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LPC17XX_SSP_H_ */
+
+/**
+ * @}
+ */
+
+/* --------------------------------- End Of File ------------------------------ */


Property changes on: trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_ssp.h
___________________________________________________________________
Deleted: svn:executable
   - *

Modified: trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_timer.h
===================================================================
--- trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_timer.h	2010-06-28 21:53:59 UTC (rev 759)
+++ trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_timer.h	2010-07-12 20:56:54 UTC (rev 760)
@@ -1,333 +1,324 @@
-/**
- * @file	: lpc17xx_timer.h
- * @brief	: Contains all functions support for SPI firmware library on LPC17xx
- * @version	: 1.0
- * @date	: 14. April. 2009
- * @author	:
- * *----------------------------------------------------------------------------
- * Software that is described herein is for illustrative purposes only
- * which provides customers with programming information regarding the
- * products. This software is supplied &quot;AS IS&quot; without any warranties.
- * NXP Semiconductors assumes no responsibility or liability for the
- * use of the software, conveys no license or title under any patent,
- * copyright, or mask work right to the product. NXP Semiconductors
- * reserves the right to make changes in the software without
- * notification. NXP Semiconductors also make no representation or
- * warranty that such application will be suitable for the specified
- * use without further testing or modification.
- **********************************************************************/
-
-/* Peripheral group ----------------------------------------------------------- */
-/** @defgroup TIM
- * @ingroup LPC1700CMSIS_FwLib_Drivers
- * @{
- */
-
-#ifndef __LPC17XX_TIMER_H_
-#define __LPC17XX_TIMER_H_
-
-/* Includes ------------------------------------------------------------------- */
-#include &quot;LPC17xx.h&quot;
-#include &quot;lpc_types.h&quot;
-
-
-/* Private Macros ------------------------------------------------------------- */
-/** @defgroup TIM_Private_Macros
- * @{
- */
-
-/************************** TIMER/COUNTER Control **************************/
-/** @defgroup TIM_REGISTER_BIT_DEFINITION
- * @{
- */
-
-/**********************************************************************
-** Interrupt information
-**********************************************************************/
-/** Macro to clean interrupt pending */
-#define TIM_IR_CLR(n) _BIT(n)
-
-/**********************************************************************
-** Timer interrupt register definitions
-**********************************************************************/
-/** Macro for getting a timer match interrupt bit */
-#define TIM_MATCH_INT(n)		(_BIT(n &amp; 0x0F))
-/** Macro for getting a capture event interrupt bit */
-#define TIM_CAP_INT(n)     (_BIT(((n &amp; 0x0F) + 4)))
-
-/**********************************************************************
-* Timer control register definitions
-**********************************************************************/
-/** Timer/counter enable bit */
-#define TIM_ENABLE			((uint32_t)(1&lt;&lt;0))
-/** Timer/counter reset bit */
-#define TIM_RESET			((uint32_t)(1&lt;&lt;1))
-/** Timer control bit mask */
-#define TIM_TCR_MASKBIT		((uint32_t)(3))
-
-/**********************************************************************
-* Timer match control register definitions
-**********************************************************************/
-/** Bit location for interrupt on MRx match, n = 0 to 3 */
-#define TIM_INT_ON_MATCH(n)      	(_BIT((n * 3)))
-/** Bit location for reset on MRx match, n = 0 to 3 */
-#define TIM_RESET_ON_MATCH(n)    	(_BIT(((n * 3) + 1)))
-/** Bit location for stop on MRx match, n = 0 to 3 */
-#define TIM_STOP_ON_MATCH(n)     	(_BIT(((n * 3) + 2)))
-/** Timer Match control bit mask */
-#define TIM_MCR_MASKBIT			   ((uint32_t)(0x0FFF))
-/** Timer Match control bit mask for specific channel*/
-#define	TIM_MCR_CHANNEL_MASKBIT(n)		((uint32_t)(7&lt;&lt;n))
-/**********************************************************************
-* Timer capture control register definitions
-**********************************************************************/
-/** Bit location for CAP.n on CRx rising edge, n = 0 to 3 */
-#define TIM_CAP_RISING(n)   	(_BIT((n * 3)))
-/** Bit location for CAP.n on CRx falling edge, n = 0 to 3 */
-#define TIM_CAP_FALLING(n)   	(_BIT(((n * 3) + 1)))
-/** Bit location for CAP.n on CRx interrupt enable, n = 0 to 3 */
-#define TIM_INT_ON_CAP(n)    	(_BIT(((n * 3) + 2)))
-/** Mask bit for rising and falling edge bit */
-#define TIM_EDGE_MASK(n)		(_SBF((n * 3), 0x03))
-/** Timer capture control bit mask */
-#define TIM_CCR_MASKBIT			((uint32_t)(0x3F))
-/** Timer Capture control bit mask for specific channel*/
-#define	TIM_CCR_CHANNEL_MASKBIT(n)		((uint32_t)(7&lt;&lt;n))
-
-/**********************************************************************
-* Timer external match register definitions
-**********************************************************************/
-/** Bit location for output state change of MAT.n when external match
-   happens, n = 0 to 3 */
-#define TIM_EM(n)    			_BIT(n)
-/** Output state change of MAT.n when external match happens: no change */
-#define TIM_EM_NOTHING    	((uint8_t)(0x0))
-/** Output state change of MAT.n when external match happens: low */
-#define TIM_EM_LOW         	((uint8_t)(0x1))
-/** Output state change of MAT.n when external match happens: high */
-#define TIM_EM_HIGH        	((uint8_t)(0x2))
-/** Output state change of MAT.n when external match happens: toggle */
-#define TIM_EM_TOGGLE      	((uint8_t)(0x3))
-/** Macro for setting for the MAT.n change state bits */
-#define TIM_EM_SET(n,s) 	(_SBF(((n &lt;&lt; 1) + 4), (s &amp; 0x03)))
-/** Mask for the MAT.n change state bits */
-#define TIM_EM_MASK(n) 		(_SBF(((n &lt;&lt; 1) + 4), 0x03))
-/** Timer external match bit mask */
-#define TIM_EMR_MASKBIT	0x0FFF
-/**********************************************************************
-* Timer Count Control Register definitions
-**********************************************************************/
-/** Mask to get the Counter/timer mode bits */
-#define TIM_CTCR_MODE_MASK  0x3
-/** Mask to get the count input select bits */
-#define TIM_CTCR_INPUT_MASK 0xC
-/** Timer Count control bit mask */
-#define TIM_CTCR_MASKBIT	0xF
-#define TIM_COUNTER_MODE ((uint8_t)(1))
-
-/**
- * @}
- */
-
-/**
- * @}
- */
-
-
-/* Public Types --------------------------------------------------------------- */
-/** @defgroup TIM_Public_Types
- * @{
- */
-
-/***********************************************************************
- * Timer device enumeration
-**********************************************************************/
-/** @brief interrupt  type */
-typedef enum
-{
-	TIM_MR0_INT =0, /*!&lt; interrupt for Match channel 0*/
-	TIM_MR1_INT =1, /*!&lt; interrupt for Match channel 1*/
-	TIM_MR2_INT =2, /*!&lt; interrupt for Match channel 2*/
-	TIM_MR3_INT =3, /*!&lt; interrupt for Match channel 3*/
-	TIM_CR0_INT =4, /*!&lt; interrupt for Capture channel 0*/
-	TIM_CR1_INT =5, /*!&lt; interrupt for Capture channel 1*/
-}TIM_INT_TYPE;
-#define PARAM_TIM_INT_TYPE(TYPE)	((TYPE ==TIM_MR0_INT)||\
-									 (TYPE ==TIM_MR1_INT)||\
-									 (TYPE ==TIM_MR2_INT)||\
-									 (TYPE ==TIM_MR3_INT)||\
-									 (TYPE ==TIM_CR0_INT)||\
-									 (TYPE ==TIM_CR1_INT))
-/** @brief Timer/counter operating mode */
-typedef enum
-{
-	TIM_TIMER_MODE = 0,				/*!&lt; Timer mode */
-	TIM_COUNTER_RISING_MODE,		/*!&lt; Counter rising mode */
-	TIM_COUNTER_FALLING_MODE,		/*!&lt; Counter falling mode */
-	TIM_COUNTER_ANY_MODE			/*!&lt; Counter on both edges */
-} TIM_MODE_OPT;
-#define PARAM_TIM_MODE_OPT(MODE)	((	MODE	==TIM_TIMER_MODE)|| \
-									(	MODE	==TIM_COUNTER_RISING_MODE)|| \
-									(	MODE	==TIM_COUNTER_RISING_MODE)|| \
-								    (	MODE	==TIM_COUNTER_RISING_MODE))
-/** @brief Timer/Counter prescale option */
-typedef enum
-{
-	TIM_PRESCALE_TICKVAL = 0,		/*!&lt; Prescale in absolute value */
-	TIM_PRESCALE_USVAL				/*!&lt; Prescale in microsecond value */
-} TIM_PRESCALE_OPT;
-#define PARAM_TIM_PRESCALE_OPT(OPT)	((	OPT	==	TIM_PRESCALE_TICKVAL)|| \
-										(	OPT	==	TIM_PRESCALE_USVAL))
-/** @brief Counter input option */
-typedef enum
-{
-	TIM_COUNTER_INCAP0 = 0,			/*!&lt; CAPn.0 input pin for TIMERn */
-	TIM_COUNTER_INCAP1,				/*!&lt; CAPn.1 input pin for TIMERn */
-} TIM_COUNTER_INPUT_OPT;
-#define PARAM_TIM_COUNTER_INPUT_OPT(OPT)	((	OPT	==	TIM_COUNTER_INCAP0)|| \
-											(	OPT	==	TIM_COUNTER_INCAP1))
-/** @brief Timer/Counter external match option */
-typedef enum
-{
-	TIM_EXTMATCH_NOTHING = 0,		/*!&lt; Do nothing for external output pin if match */
-	TIM_EXTMATCH_LOW,				/*!&lt; Force external output pin to low if match */
-	TIM_EXTMATCH_HIGH,				/*!&lt; Force external output pin to high if match */
-	TIM_EXTMATCH_TOGGLE				/*!&lt; Toggle external output pin if match */
-}TIM_EXTMATCH_OPT;
-#define PARAM_TIM_EXTMATCH_OPT(OPT)	((	OPT	==	TIM_EXTMATCH_NOTHING)|| \
-									(	OPT	==	TIM_EXTMATCH_LOW)|| \
-									(	OPT	==	TIM_EXTMATCH_HIGH)|| \
-									(	OPT	==	TIM_EXTMATCH_TOGGLE))
-/** @brief Timer/counter capture mode options */
-typedef enum {
-	TIM_CAPTURE_NONE = 0,	/*!&lt; No Capture */
-	TIM_CAPTURE_RISING,		/*!&lt; Rising capture mode */
-	TIM_CAPTURE_FALLING,	/*!&lt; Falling capture mode */
-	TIM_CAPTURE_ANY			/*!&lt; On both edges */
-} TIM_CAP_MODE_OPT;
-#define PARAM_TIM_CAP_MODE_OPT(OPT)	((	OPT	==	TIM_CAPTURE_NONE)|| \
-									(	OPT	==	TIM_CAPTURE_RISING)|| \
-									(	OPT	==	TIM_CAPTURE_FALLING)|| \
-									(	OPT	==	TIM_CAPTURE_ANY))
-
-/** @brief Configuration structure in TIMER mode */
-typedef struct
-{
-
-	uint8_t PrescaleOption;		/**&lt; Timer Prescale option, should be:
-									- TIM_PRESCALE_TICKVAL: Prescale in absolute value
-									- TIM_PRESCALE_USVAL: Prescale in microsecond value
-									*/
-	uint8_t Reserved[3];		/**&lt; Reserved */
-	uint32_t PrescaleValue;		/**&lt; Prescale value */
-} TIM_TIMERCFG_Type;
-
-/** @brief Configuration structure in COUNTER mode */
-typedef struct {
-
-	uint8_t CounterOption;		/**&lt; Counter Option, should be:
-								- TIM_COUNTER_INCAP0: CAPn.0 input pin for TIMERn
-								- TIM_COUNTER_INCAP1: CAPn.1 input pin for TIMERn
-								*/
-	uint8_t CountInputSelect;
-	uint8_t Reserved[2];
-} TIM_COUNTERCFG_Type;
-
-/** @brief Match channel configuration structure */
-typedef struct {
-	uint8_t MatchChannel;	/**&lt; Match channel, should be in range
-							from 0..3 */
-	uint8_t IntOnMatch;		/**&lt; Interrupt On match, should be:
-							- ENABLE: Enable this function.
-							- DISABLE: Disable this function.
-							*/
-	uint8_t StopOnMatch;	/**&lt; Stop On match, should be:
-							- ENABLE: Enable this function.
-							- DISABLE: Disable this function.
-							*/
-	uint8_t ResetOnMatch;	/**&lt; Reset On match, should be:
-							- ENABLE: Enable this function.
-							- DISABLE: Disable this function.
-							*/
-
-	uint8_t ExtMatchOutputType;	/**&lt; External Match Output type, should be:
-							 -	 0:	Do nothing for external output pin if match
-							 -   1:	Force external output pin to low if match
-							 - 	 2: Force external output pin to high if match
-							 -   3: Toggle external output pin if match.
-							*/
-	uint8_t Reserved[3];	/** Reserved */
-	uint32_t MatchValue;	/** Match value */
-} TIM_MATCHCFG_Type;
-
-
-/** @brief Capture Input configuration structure */
-typedef struct {
-	uint8_t CaptureChannel;	/**&lt; Capture channel, should be in range
-							from 0..1 */
-	uint8_t RisingEdge;		/**&lt; caption rising edge, should be:
-							- ENABLE: Enable rising edge.
-							- DISABLE: Disable this function.
-							*/
-	uint8_t FallingEdge;		/**&lt; caption falling edge, should be:
-							- ENABLE: Enable falling edge.
-							- DISABLE: Disable this function.
-								*/
-	uint8_t IntOnCaption;	/**&lt; Interrupt On caption, should be:
-							- ENABLE: Enable interrupt function.
-							- DISABLE: Disable this function.
-							*/
-
-} TIM_CAPTURECFG_Type;
-
-/**
- * @}
- */
-
-
-/* Public Macros -------------------------------------------------------------- */
-/** @defgroup TIM_Public_Macros
- * @{
- */
-
-/** Macro to determine if it is valid TIMER peripheral */
-#define PARAM_TIMx(n)	((((uint32_t *)n)==((uint32_t *)TIM0)) \
-						|| (((uint32_t *)n)==((uint32_t *)TIM1)) \
-						|| (((uint32_t *)n)==((uint32_t *)TIM2)) \
-						|| (((uint32_t *)n)==((uint32_t *)TIM3)))
-
-/**
- * @}
- */
-
-
-/* Public Functions ----------------------------------------------------------- */
-/** @defgroup TIM_Public_Functions
- * @{
- */
-
-FlagStatus TIM_GetIntStatus(TIM_TypeDef *TIMx, uint8_t IntFlag);
-FlagStatus TIM_GetIntCaptureStatus(TIM_TypeDef *TIMx, uint8_t IntFlag);
-void TIM_ClearIntPending(TIM_TypeDef *TIMx, uint8_t IntFlag);
-void TIM_ClearIntCapturePending(TIM_TypeDef *TIMx, uint8_t IntFlag);
-void TIM_Cmd(TIM_TypeDef *TIMx, FunctionalState NewState);
-void TIM_ResetCounter(TIM_TypeDef *TIMx);
-void TIM_Init(TIM_TypeDef *TIMx, uint8_t TimerCounterMode, void *TIM_ConfigStruct);
-void TIM_DeInit(TIM_TypeDef *TIMx);
-void TIM_ConfigStructInit(uint8_t TimerCounterMode, void *TIM_ConfigStruct);
-void TIM_ConfigMatch(TIM_TypeDef *TIMx, TIM_MATCHCFG_Type *TIM_MatchConfigStruct);
-void TIM_SetMatchExt(TIM_TypeDef *TIMx,TIM_EXTMATCH_OPT ext_match );
-void TIM_ConfigCapture(TIM_TypeDef *TIMx, TIM_CAPTURECFG_Type *TIM_CaptureConfigStruct);
-uint32_t TIM_GetCaptureValue(TIM_TypeDef *TIMx, uint8_t CaptureChannel);
-
-/**
- * @}
- */
-
-#endif /* __LPC17XX_TIMER_H_ */
-
-/**
- * @}
- */
-
-/* --------------------------------- End Of File ------------------------------ */
+/**
+ * @file	: lpc17xx_timer.h
+ * @brief	: Contains all functions support for Timer firmware library on LPC17xx
+ * @version	: 1.0
+ * @date	: 14. April. 2009
+ * @author	: HieuNguyen
+ **************************************************************************
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * products. This software is supplied &quot;AS IS&quot; without any warranties.
+ * NXP Semiconductors assumes no responsibility or liability for the
+ * use of the software, conveys no license or title under any patent,
+ * copyright, or mask work right to the product. NXP Semiconductors
+ * reserves the right to make changes in the software without
+ * notification. NXP Semiconductors also make no representation or
+ * warranty that such application will be suitable for the specified
+ * use without further testing or modification.
+ **********************************************************************/
+
+/* Peripheral group ----------------------------------------------------------- */
+/** @defgroup TIM
+ * @ingroup LPC1700CMSIS_FwLib_Drivers
+ * @{
+ */
+
+#ifndef __LPC17XX_TIMER_H_
+#define __LPC17XX_TIMER_H_
+
+/* Includes ------------------------------------------------------------------- */
+#include &quot;LPC17xx.h&quot;
+#include &quot;lpc_types.h&quot;
+
+
+/* Private Macros ------------------------------------------------------------- */
+/** @defgroup TIM_Private_Macros
+ * @{
+ */
+
+/************************** TIMER/COUNTER Control **************************/
+/** @defgroup TIM_REGISTER_BIT_DEFINITION
+ * @{
+ */
+
+/**********************************************************************
+** Interrupt information
+**********************************************************************/
+/** Macro to clean interrupt pending */
+#define TIM_IR_CLR(n) _BIT(n)
+
+/**********************************************************************
+** Timer interrupt register definitions
+**********************************************************************/
+/** Macro for getting a timer match interrupt bit */
+#define TIM_MATCH_INT(n)		(_BIT(n &amp; 0x0F))
+/** Macro for getting a capture event interrupt bit */
+#define TIM_CAP_INT(n)     (_BIT(((n &amp; 0x0F) + 4)))
+
+/**********************************************************************
+* Timer control register definitions
+**********************************************************************/
+/** Timer/counter enable bit */
+#define TIM_ENABLE			((uint32_t)(1&lt;&lt;0))
+/** Timer/counter reset bit */
+#define TIM_RESET			((uint32_t)(1&lt;&lt;1))
+/** Timer control bit mask */
+#define TIM_TCR_MASKBIT		((uint32_t)(3))
+
+/**********************************************************************
+* Timer match control register definitions
+**********************************************************************/
+/** Bit location for interrupt on MRx match, n = 0 to 3 */
+#define TIM_INT_ON_MATCH(n)      	(_BIT((n * 3)))
+/** Bit location for reset on MRx match, n = 0 to 3 */
+#define TIM_RESET_ON_MATCH(n)    	(_BIT(((n * 3) + 1)))
+/** Bit location for stop on MRx match, n = 0 to 3 */
+#define TIM_STOP_ON_MATCH(n)     	(_BIT(((n * 3) + 2)))
+/** Timer Match control bit mask */
+#define TIM_MCR_MASKBIT			   ((uint32_t)(0x0FFF))
+/** Timer Match control bit mask for specific channel*/
+#define	TIM_MCR_CHANNEL_MASKBIT(n)		((uint32_t)(7&lt;&lt;n))
+/**********************************************************************
+* Timer capture control register definitions
+**********************************************************************/
+/** Bit location for CAP.n on CRx rising edge, n = 0 to 3 */
+#define TIM_CAP_RISING(n)   	(_BIT((n * 3)))
+/** Bit location for CAP.n on CRx falling edge, n = 0 to 3 */
+#define TIM_CAP_FALLING(n)   	(_BIT(((n * 3) + 1)))
+/** Bit location for CAP.n on CRx interrupt enable, n = 0 to 3 */
+#define TIM_INT_ON_CAP(n)    	(_BIT(((n * 3) + 2)))
+/** Mask bit for rising and falling edge bit */
+#define TIM_EDGE_MASK(n)		(_SBF((n * 3), 0x03))
+/** Timer capture control bit mask */
+#define TIM_CCR_MASKBIT			((uint32_t)(0x3F))
+/** Timer Capture control bit mask for specific channel*/
+#define	TIM_CCR_CHANNEL_MASKBIT(n)		((uint32_t)(7&lt;&lt;n))
+
+/**********************************************************************
+* Timer external match register definitions
+**********************************************************************/
+/** Bit location for output state change of MAT.n when external match
+   happens, n = 0 to 3 */
+#define TIM_EM(n)    			_BIT(n)
+/** Output state change of MAT.n when external match happens: no change */
+#define TIM_EM_NOTHING    	((uint8_t)(0x0))
+/** Output state change of MAT.n when external match happens: low */
+#define TIM_EM_LOW         	((uint8_t)(0x1))
+/** Output state change of MAT.n when external match happens: high */
+#define TIM_EM_HIGH        	((uint8_t)(0x2))
+/** Output state change of MAT.n when external match happens: toggle */
+#define TIM_EM_TOGGLE      	((uint8_t)(0x3))
+/** Macro for setting for the MAT.n change state bits */
+#define TIM_EM_SET(n,s) 	(_SBF(((n &lt;&lt; 1) + 4), (s &amp; 0x03)))
+/** Mask for the MAT.n change state bits */
+#define TIM_EM_MASK(n) 		(_SBF(((n &lt;&lt; 1) + 4), 0x03))
+/** Timer external match bit mask */
+#define TIM_EMR_MASKBIT	0x0FFF
+/**********************************************************************
+* Timer Count Control Register definitions
+**********************************************************************/
+/** Mask to get the Counter/timer mode bits */
+#define TIM_CTCR_MODE_MASK  0x3
+/** Mask to get the count input select bits */
+#define TIM_CTCR_INPUT_MASK 0xC
+/** Timer Count control bit mask */
+#define TIM_CTCR_MASKBIT	0xF
+#define TIM_COUNTER_MODE ((uint8_t)(1))
+
+/**
+ * @}
+ */
+
+/**
+ * @}
+ */
+
+
+/* Public Types --------------------------------------------------------------- */
+/** @defgroup TIM_Public_Types
+ * @{
+ */
+
+/***********************************************************************
+ * Timer device enumeration
+**********************************************************************/
+/** @brief interrupt  type */
+typedef enum
+{
+	TIM_MR0_INT =0, /*!&lt; interrupt for Match channel 0*/
+	TIM_MR1_INT =1, /*!&lt; interrupt for Match channel 1*/
+	TIM_MR2_INT =2, /*!&lt; interrupt for Match channel 2*/
+	TIM_MR3_INT =3, /*!&lt; interrupt for Match channel 3*/
+	TIM_CR0_INT =4, /*!&lt; interrupt for Capture channel 0*/
+	TIM_CR1_INT =5, /*!&lt; interrupt for Capture channel 1*/
+}TIM_INT_TYPE;
+#define PARAM_TIM_INT_TYPE(TYPE)	((TYPE ==TIM_MR0_INT)||(TYPE ==TIM_MR1_INT)\
+||(TYPE ==TIM_MR2_INT)||(TYPE ==TIM_MR3_INT)\
+||(TYPE ==TIM_CR0_INT)||(TYPE ==TIM_CR1_INT))
+
+/** @brief Timer/counter operating mode */
+typedef enum
+{
+	TIM_TIMER_MODE = 0,				/*!&lt; Timer mode */
+	TIM_COUNTER_RISING_MODE,		/*!&lt; Counter rising mode */
+	TIM_COUNTER_FALLING_MODE,		/*!&lt; Counter falling mode */
+	TIM_COUNTER_ANY_MODE			/*!&lt; Counter on both edges */
+} TIM_MODE_OPT;
+#define PARAM_TIM_MODE_OPT(MODE)	((MODE == TIM_TIMER_MODE)||(MODE == TIM_COUNTER_RISING_MODE)\
+|| (MODE == TIM_COUNTER_RISING_MODE)||(MODE == TIM_COUNTER_RISING_MODE))
+/** @brief Timer/Counter prescale option */
+typedef enum
+{
+	TIM_PRESCALE_TICKVAL = 0,		/*!&lt; Prescale in absolute value */
+	TIM_PRESCALE_USVAL				/*!&lt; Prescale in microsecond value */
+} TIM_PRESCALE_OPT;
+#define PARAM_TIM_PRESCALE_OPT(OPT)	((OPT == TIM_PRESCALE_TICKVAL)||(OPT == TIM_PRESCALE_USVAL))
+/** @brief Counter input option */
+typedef enum
+{
+	TIM_COUNTER_INCAP0 = 0,			/*!&lt; CAPn.0 input pin for TIMERn */
+	TIM_COUNTER_INCAP1,				/*!&lt; CAPn.1 input pin for TIMERn */
+} TIM_COUNTER_INPUT_OPT;
+#define PARAM_TIM_COUNTER_INPUT_OPT(OPT)	((OPT == TIM_COUNTER_INCAP0)||(OPT == TIM_COUNTER_INCAP1))
+
+/** @brief Timer/Counter external match option */
+typedef enum
+{
+	TIM_EXTMATCH_NOTHING = 0,		/*!&lt; Do nothing for external output pin if match */
+	TIM_EXTMATCH_LOW,				/*!&lt; Force external output pin to low if match */
+	TIM_EXTMATCH_HIGH,				/*!&lt; Force external output pin to high if match */
+	TIM_EXTMATCH_TOGGLE				/*!&lt; Toggle external output pin if match */
+}TIM_EXTMATCH_OPT;
+#define PARAM_TIM_EXTMATCH_OPT(OPT)	((OPT == TIM_EXTMATCH_NOTHING)||(OPT == TIM_EXTMATCH_LOW)\
+||(OPT == TIM_EXTMATCH_HIGH)||(OPT == TIM_EXTMATCH_TOGGLE))
+
+/** @brief Timer/counter capture mode options */
+typedef enum {
+	TIM_CAPTURE_NONE = 0,	/*!&lt; No Capture */
+	TIM_CAPTURE_RISING,		/*!&lt; Rising capture mode */
+	TIM_CAPTURE_FALLING,	/*!&lt; Falling capture mode */
+	TIM_CAPTURE_ANY			/*!&lt; On both edges */
+} TIM_CAP_MODE_OPT;
+
+#define PARAM_TIM_CAP_MODE_OPT(OPT)	((OPT == TIM_CAPTURE_NONE)||(OPT == TIM_CAPTURE_RISING) \
+||(OPT == TIM_CAPTURE_FALLING)||(OPT == TIM_CAPTURE_ANY))
+
+/** @brief Configuration structure in TIMER mode */
+typedef struct
+{
+
+	uint8_t PrescaleOption;		/**&lt; Timer Prescale option, should be:
+									- TIM_PRESCALE_TICKVAL: Prescale in absolute value
+									- TIM_PRESCALE_USVAL: Prescale in microsecond value
+									*/
+	uint8_t Reserved[3];		/**&lt; Reserved */
+	uint32_t PrescaleValue;		/**&lt; Prescale value */
+} TIM_TIMERCFG_Type;
+
+/** @brief Configuration structure in COUNTER mode */
+typedef struct {
+
+	uint8_t CounterOption;		/**&lt; Counter Option, should be:
+								- TIM_COUNTER_INCAP0: CAPn.0 input pin for TIMERn
+								- TIM_COUNTER_INCAP1: CAPn.1 input pin for TIMERn
+								*/
+	uint8_t CountInputSelect;
+	uint8_t Reserved[2];
+} TIM_COUNTERCFG_Type;
+
+/** @brief Match channel configuration structure */
+typedef struct {
+	uint8_t MatchChannel;	/**&lt; Match channel, should be in range
+							from 0..3 */
+	uint8_t IntOnMatch;		/**&lt; Interrupt On match, should be:
+							- ENABLE: Enable this function.
+							- DISABLE: Disable this function.
+							*/
+	uint8_t StopOnMatch;	/**&lt; Stop On match, should be:
+							- ENABLE: Enable this function.
+							- DISABLE: Disable this function.
+							*/
+	uint8_t ResetOnMatch;	/**&lt; Reset On match, should be:
+							- ENABLE: Enable this function.
+							- DISABLE: Disable this function.
+							*/
+
+	uint8_t ExtMatchOutputType;	/**&lt; External Match Output type, should be:
+							 -	 0:	Do nothing for external output pin if match
+							 -   1:	Force external output pin to low if match
+							 - 	 2: Force external output pin to high if match
+							 -   3: Toggle external output pin if match.
+							*/
+	uint8_t Reserved[3];	/** Reserved */
+	uint32_t MatchValue;	/** Match value */
+} TIM_MATCHCFG_Type;
+
+
+/** @brief Capture Input configuration structure */
+typedef struct {
+	uint8_t CaptureChannel;	/**&lt; Capture channel, should be in range
+							from 0..1 */
+	uint8_t RisingEdge;		/**&lt; caption rising edge, should be:
+							- ENABLE: Enable rising edge.
+							- DISABLE: Disable this function.
+							*/
+	uint8_t FallingEdge;		/**&lt; caption falling edge, should be:
+							- ENABLE: Enable falling edge.
+							- DISABLE: Disable this function.
+								*/
+	uint8_t IntOnCaption;	/**&lt; Interrupt On caption, should be:
+							- ENABLE: Enable interrupt function.
+							- DISABLE: Disable this function.
+							*/
+
+} TIM_CAPTURECFG_Type;
+
+/**
+ * @}
+ */
+
+
+/* Public Macros -------------------------------------------------------------- */
+/** @defgroup TIM_Public_Macros
+ * @{
+ */
+
+/** Macro to determine if it is valid TIMER peripheral */
+#define PARAM_TIMx(n)	((((uint32_t *)n)==((uint32_t *)LPC_TIM0)) || (((uint32_t *)n)==((uint32_t *)LPC_TIM1)) \
+|| (((uint32_t *)n)==((uint32_t *)LPC_TIM2)) || (((uint32_t *)n)==((uint32_t *)LPC_TIM3)))
+
+/**
+ * @}
+ */
+
+
+/* Public Functions ----------------------------------------------------------- */
+/** @defgroup TIM_Public_Functions
+ * @{
+ */
+
+FlagStatus TIM_GetIntStatus(LPC_TIM_TypeDef *TIMx, uint8_t IntFlag);
+FlagStatus TIM_GetIntCaptureStatus(LPC_TIM_TypeDef *TIMx, uint8_t IntFlag);
+void TIM_ClearIntPending(LPC_TIM_TypeDef *TIMx, uint8_t IntFlag);
+void TIM_ClearIntCapturePending(LPC_TIM_TypeDef *TIMx, uint8_t IntFlag);
+void TIM_Cmd(LPC_TIM_TypeDef *TIMx, FunctionalState NewState);
+void TIM_ResetCounter(LPC_TIM_TypeDef *TIMx);
+void TIM_Init(LPC_TIM_TypeDef *TIMx, uint8_t TimerCounterMode, void *TIM_ConfigStruct);
+void TIM_DeInit(LPC_TIM_TypeDef *TIMx);
+void TIM_ConfigStructInit(uint8_t TimerCounterMode, void *TIM_ConfigStruct);
+void TIM_ConfigMatch(LPC_TIM_TypeDef *TIMx, TIM_MATCHCFG_Type *TIM_MatchConfigStruct);
+void TIM_SetMatchExt(LPC_TIM_TypeDef *TIMx,TIM_EXTMATCH_OPT ext_match );
+void TIM_ConfigCapture(LPC_TIM_TypeDef *TIMx, TIM_CAPTURECFG_Type *TIM_CaptureConfigStruct);
+uint32_t TIM_GetCaptureValue(LPC_TIM_TypeDef *TIMx, uint8_t CaptureChannel);
+
+/**
+ * @}
+ */
+
+#endif /* __LPC17XX_TIMER_H_ */
+
+/**
+ * @}
+ */
+
+/* --------------------------------- End Of File ------------------------------ */


Property changes on: trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_timer.h
___________________________________________________________________
Deleted: svn:executable
   - *

Modified: trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_uart.h
===================================================================
--- trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_uart.h	2010-06-28 21:53:59 UTC (rev 759)
+++ trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_uart.h	2010-07-12 20:56:54 UTC (rev 760)
@@ -1,633 +1,633 @@
-/***********************************************************************//**
- * @file	: lpc17xx_uart.h
- * @brief	: Contains all macro definitions and function prototypes
- * 				support for UART firmware library on LPC17xx
- * @version	: 1.0
- * @date	: 18. Mar. 2009
- * @author	: HieuNguyen
- **************************************************************************
- * Software that is described herein is for illustrative purposes only
- * which provides customers with programming information regarding the
- * products. This software is supplied &quot;AS IS&quot; without any warranties.
- * NXP Semiconductors assumes no responsibility or liability for the
- * use of the software, conveys no license or title under any patent,
- * copyright, or mask work right to the product. NXP Semiconductors
- * reserves the right to make changes in the software without
- * notification. NXP Semiconductors also make no representation or
- * warranty that such application will be suitable for the specified
- * use without further testing or modification.
- **************************************************************************/
-
-/* Peripheral group ----------------------------------------------------------- */
-/** @defgroup UART
- * @ingroup LPC1700CMSIS_FwLib_Drivers
- * @{
- */
-
-#ifndef __LPC17XX_UART_H
-#define __LPC17XX_UART_H
-
-/* Includes ------------------------------------------------------------------- */
-#include &quot;LPC17xx.h&quot;
-#include &quot;lpc_types.h&quot;
-
-
-#ifdef __cplusplus
-extern &quot;C&quot;
-{
-#endif
-
-
-/* Private Macros ------------------------------------------------------------- */
-/** @defgroup UART_Private_Macros
- * @{
- */
-
-
-/** @defgroup UART_REGISTER_BIT_DEFINITIONS
- * @{
- */
-
-/* Accepted Error baud rate value (in percent unit) */
-#define UART_ACCEPTED_BAUDRATE_ERROR	(3)			/*!&lt; Acceptable UART baudrate error */
-
-/* Macro defines for UARTn Receiver Buffer Register */
-#define UART_RBR_MASKBIT   	((uint8_t)0xFF) 		/*!&lt; UART Received Buffer mask bit (8 bits) */
-
-/* Macro defines for UARTn Transmit Holding Register */
-#define UART_THR_MASKBIT   	((uint8_t)0xFF) 		/*!&lt; UART Transmit Holding mask bit (8 bits) */
-
-/* Macro defines for UARTn Divisor Latch LSB register */
-#define UART_LOAD_DLL(div)	((div) &amp; 0xFF)	/**&lt; Macro for loading least significant halfs of divisors */
-#define UART_DLL_MASKBIT	((uint8_t)0xFF)	/*!&lt; Divisor latch LSB bit mask */
-
-/* Macro defines for UARTn Divisor Latch MSB register */
-#define UART_DLM_MASKBIT	((uint8_t)0xFF)			/*!&lt; Divisor latch MSB bit mask */
-#define UART_LOAD_DLM(div)  (((div) &gt;&gt; 8) &amp; 0xFF)	/**&lt; Macro for loading most significant halfs of divisors */
-
-
-/* Macro defines for UART interrupt enable register */
-#define UART_IER_RBRINT_EN		((uint32_t)(1&lt;&lt;0)) 	/*!&lt; RBR Interrupt enable*/
-#define UART_IER_THREINT_EN		((uint32_t)(1&lt;&lt;1)) 	/*!&lt; THR Interrupt enable*/
-#define UART_IER_RLSINT_EN		((uint32_t)(1&lt;&lt;2)) 	/*!&lt; RX line status interrupt enable*/
-#define UART1_IER_MSINT_EN		((uint32_t)(1&lt;&lt;3))	/*!&lt; Modem status interrupt enable */
-#define UART1_IER_CTSINT_EN		((uint32_t)(1&lt;&lt;7))	/*!&lt; CTS1 signal transition interrupt enable */
-#define UART_IER_ABEOINT_EN		((uint32_t)(1&lt;&lt;8)) 	/*!&lt; Enables the end of auto-baud interrupt */
-#define UART_IER_ABTOINT_EN		((uint32_t)(1&lt;&lt;9)) 	/*!&lt; Enables the auto-baud time-out interrupt */
-#define UART_IER_BITMASK		((uint32_t)(0x307)) /*!&lt; UART interrupt enable register bit mask */
-#define UART1_IER_BITMASK		((uint32_t)(0x38F)) /*!&lt; UART1 interrupt enable register bit mask */
-
-
-/* UART interrupt identification register defines */
-#define UART_IIR_INTSTAT_PEND	((uint32_t)(1&lt;&lt;0))	/*!&lt;Interrupt Status - Active low */
-#define UART_IIR_INTID_RLS		((uint32_t)(3&lt;&lt;1)) 	/*!&lt;Interrupt identification: Receive line status*/
-#define UART_IIR_INTID_RDA		((uint32_t)(2&lt;&lt;1)) 	/*!&lt;Interrupt identification: Receive data available*/
-#define UART_IIR_INTID_CTI		((uint32_t)(6&lt;&lt;1)) 	/*!&lt;Interrupt identification: Character time-out indicator*/
-#define UART_IIR_INTID_THRE		((uint32_t)(1&lt;&lt;1)) 	/*!&lt;Interrupt identification: THRE interrupt*/
-#define UART1_IIR_INTID_MODEM	((uint32_t)(0&lt;&lt;1)) 	/*!&lt;Interrupt identification: Modem interrupt*/
-#define UART_IIR_INTID_MASK		((uint32_t)(7&lt;&lt;1))	/*!&lt;Interrupt identification: Interrupt ID mask */
-#define UART_IIR_FIFO_EN		((uint32_t)(3&lt;&lt;6)) 	/*!&lt;These bits are equivalent to UnFCR[0] */
-#define UART_IIR_ABEO_INT		((uint32_t)(1&lt;&lt;8)) 	/*!&lt; End of auto-baud interrupt */
-#define UART_IIR_ABTO_INT		((uint32_t)(1&lt;&lt;9)) 	/*!&lt; Auto-baud time-out interrupt */
-#define UART_IIR_BITMASK		((uint32_t)(0x3CF))	/*!&lt; UART interrupt identification register bit mask */
-
-
-/* Macro defines for UART FIFO control register */
-#define UART_FCR_FIFO_EN		((uint8_t)(1&lt;&lt;0)) 	/*!&lt; UART FIFO enable */
-#define UART_FCR_RX_RS			((uint8_t)(1&lt;&lt;1)) 	/*!&lt; UART FIFO RX reset */
-#define UART_FCR_TX_RS			((uint8_t)(1&lt;&lt;2)) 	/*!&lt; UART FIFO TX reset */
-#define UART_FCR_DMAMODE_SEL 	((uint8_t)(1&lt;&lt;3)) 	/*!&lt; UART DMA mode selection */
-#define UART_FCR_TRG_LEV0		((uint8_t)(0)) 		/*!&lt; UART FIFO trigger level 0: 1 character */
-#define UART_FCR_TRG_LEV1		((uint8_t)(1&lt;&lt;6)) 	/*!&lt; UART FIFO trigger level 1: 4 character */
-#define UART_FCR_TRG_LEV2		((uint8_t)(2&lt;&lt;6)) 	/*!&lt; UART FIFO trigger level 2: 8 character */
-#define UART_FCR_TRG_LEV3		((uint8_t)(3&lt;&lt;6)) 	/*!&lt; UART FIFO trigger level 3: 14 character */
-#define UART_FCR_BITMASK		((uint8_t)(0xCF))	/*!&lt; UART FIFO control bit mask */
-#define UART_TX_FIFO_SIZE		(16)
-
-/* Macro defines for UART line control register */
-#define UART_LCR_WLEN5     		((uint8_t)(0))   		/*!&lt; UART 5 bit data mode */
-#define UART_LCR_WLEN6     		((uint8_t)(1&lt;&lt;0))   	/*!&lt; UART 6 bit data mode */
-#define UART_LCR_WLEN7     		((uint8_t)(2&lt;&lt;0))   	/*!&lt; UART 7 bit data mode */
-#define UART_LCR_WLEN8     		((uint8_t)(3&lt;&lt;0))   	/*!&lt; UART 8 bit data mode */
-#define UART_LCR_STOPBIT_SEL	((uint8_t)(1&lt;&lt;2))   	/*!&lt; UART Two Stop Bits Select */
-#define UART_LCR_PARITY_EN		((uint8_t)(1&lt;&lt;3))		/*!&lt; UART Parity Enable */
-#define UART_LCR_PARITY_ODD		((uint8_t)(0))         	/*!&lt; UART Odd Parity Select */
-#define UART_LCR_PARITY_EVEN	((uint8_t)(1&lt;&lt;4))		/*!&lt; UART Even Parity Select */
-#define UART_LCR_PARITY_F_1		((uint8_t)(2&lt;&lt;4))		/*!&lt; UART force 1 stick parity */
-#define UART_LCR_PARITY_F_0		((uint8_t)(3&lt;&lt;4))		/*!&lt; UART force 0 stick parity */
-#define UART_LCR_BREAK_EN		((uint8_t)(1&lt;&lt;6))		/*!&lt; UART Transmission Break enable */
-#define UART_LCR_DLAB_EN		((uint8_t)(1&lt;&lt;7))    	/*!&lt; UART Divisor Latches Access bit enable */
-#define UART_LCR_BITMASK		((uint8_t)(0xFF))		/*!&lt; UART line control bit mask */
-
-
-/* Macro defines for UART1 Modem Control Register */
-#define UART1_MCR_DTR_CTRL		((uint8_t)(1&lt;&lt;0))		/*!&lt; Source for modem output pin DTR */
-#define UART1_MCR_RTS_CTRL		((uint8_t)(1&lt;&lt;1))		/*!&lt; Source for modem output pin RTS */
-#define UART1_MCR_LOOPB_EN		((uint8_t)(1&lt;&lt;4))		/*!&lt; Loop back mode select */
-#define UART1_MCR_AUTO_RTS_EN	((uint8_t)(1&lt;&lt;6))		/*!&lt; Enable Auto RTS flow-control */
-#define UART1_MCR_AUTO_CTS_EN	((uint8_t)(1&lt;&lt;7))		/*!&lt; Enable Auto CTS flow-control */
-#define UART1_MCR_BITMASK		((uint8_t)(0x0F3))		/*!&lt; UART1 bit mask value */
-
-
-/* Macro defines for UART line status register */
-#define UART_LSR_RDR		((uint8_t)(1&lt;&lt;0)) 	/*!&lt;Line status register: Receive data ready*/
-#define UART_LSR_OE			((uint8_t)(1&lt;&lt;1)) 	/*!&lt;Line status register: Overrun error*/
-#define UART_LSR_PE			((uint8_t)(1&lt;&lt;2)) 	/*!&lt;Line status register: Parity error*/
-#define UART_LSR_FE			((uint8_t)(1&lt;&lt;3)) 	/*!&lt;Line status register: Framing error*/
-#define UART_LSR_BI			((uint8_t)(1&lt;&lt;4)) 	/*!&lt;Line status register: Break interrupt*/
-#define UART_LSR_THRE		((uint8_t)(1&lt;&lt;5)) 	/*!&lt;Line status register: Transmit holding register empty*/
-#define UART_LSR_TEMT		((uint8_t)(1&lt;&lt;6)) 	/*!&lt;Line status register: Transmitter empty*/
-#define UART_LSR_RXFE		((uint8_t)(1&lt;&lt;7)) 	/*!&lt;Error in RX FIFO*/
-#define UART_LSR_BITMASK	((uint8_t)(0xFF)) 	/*!&lt;UART Line status bit mask */
-
-
-/* Macro defines for UART Modem (UART1 only) status register */
-#define UART1_MSR_DELTA_CTS		((uint8_t)(1&lt;&lt;0))	/*!&lt; Set upon state change of input CTS */
-#define UART1_MSR_DELTA_DSR		((uint8_t)(1&lt;&lt;1))	/*!&lt; Set upon state change of input DSR */
-#define UART1_MSR_LO2HI_RI		((uint8_t)(1&lt;&lt;2))	/*!&lt; Set upon low to high transition of input RI */
-#define UART1_MSR_DELTA_DCD		((uint8_t)(1&lt;&lt;3))	/*!&lt; Set upon state change of input DCD */
-#define UART1_MSR_CTS			((uint8_t)(1&lt;&lt;4))	/*!&lt; Clear To Send State */
-#define UART1_MSR_DSR			((uint8_t)(1&lt;&lt;5))	/*!&lt; Data Set Ready State */
-#define UART1_MSR_RI			((uint8_t)(1&lt;&lt;6))	/*!&lt; Ring Indicator State */
-#define UART1_MSR_DCD			((uint8_t)(1&lt;&lt;7))	/*!&lt; Data Carrier Detect State */
-#define UART1_MSR_BITMASK		((uint8_t)(0xFF))	/*!&lt; MSR register bit-mask value */
-
-
-/* Macro defines for UART Scratch Pad Register */
-#define UART_SCR_BIMASK		((uint8_t)(0xFF))	/*!&lt; UART Scratch Pad bit mask */
-
-/* Macro defines for UART Auto baudrate control register */
-#define UART_ACR_START				((uint32_t)(1&lt;&lt;0))	/**&lt; UART Auto-baud start */
-#define UART_ACR_MODE				((uint32_t)(1&lt;&lt;1))	/**&lt; UART Auto baudrate Mode 1 */
-#define UART_ACR_AUTO_RESTART		((uint32_t)(1&lt;&lt;2))	/**&lt; UART Auto baudrate restart */
-#define UART_ACR_ABEOINT_CLR		((uint32_t)(1&lt;&lt;8))	/**&lt; UART End of auto-baud interrupt clear */
-#define UART_ACR_ABTOINT_CLR		((uint32_t)(1&lt;&lt;9))	/**&lt; UART Auto-baud time-out interrupt clear */
-#define UART_ACR_BITMASK			((uint32_t)(0x307))	/**&lt; UART Auto Baudrate register bit mask */
-
-/* UART IrDA control register defines */
-#define UART_ICR_IRDAEN			((uint32_t)(1&lt;&lt;0))			/**&lt; IrDA mode enable */
-#define UART_ICR_IRDAINV		((uint32_t)(1&lt;&lt;1))			/**&lt; IrDA serial input inverted */
-#define UART_ICR_FIXPULSE_EN	((uint32_t)(1&lt;&lt;2))			/**&lt; IrDA fixed pulse width mode */
-#define UART_ICR_PULSEDIV(n)	((uint32_t)((n&amp;0x07)&lt;&lt;3))	/**&lt; PulseDiv - Configures the pulse when FixPulseEn = 1 */
-#define UART_ICR_BITMASK		((uint32_t)(0x3F))			/*!&lt; UART IRDA bit mask */
-
-/* Macro defines for UART Fractional divider register */
-#define UART_FDR_DIVADDVAL(n)	((uint32_t)(n&amp;0x0F))		/**&lt; Baud-rate generation pre-scaler divisor */
-#define UART_FDR_MULVAL(n)		((uint32_t)((n&lt;&lt;4)&amp;0xF0))	/**&lt; Baud-rate pre-scaler multiplier value */
-#define UART_FDR_BITMASK		((uint32_t)(0xFF))			/**&lt; UART Fractional Divider register bit mask */
-
-/* Macro defines for UART Tx Enable register */
-#define UART_TER_TXEN			((uint8_t)(1&lt;&lt;7)) 		/*!&lt; Transmit enable bit */
-#define UART_TER_BITMASK		((uint8_t)(0x80))		/**&lt; UART Transmit Enable Register bit mask */
-
-
-/* Macro defines for UART1 RS485 Control register */
-#define UART1_RS485CTRL_NMM_EN		((uint32_t)(1&lt;&lt;0))	/*!&lt; RS-485/EIA-485 Normal Multi-drop Mode (NMM)
-														is disabled */
-#define UART1_RS485CTRL_RX_DIS		((uint32_t)(1&lt;&lt;1))	/*!&lt; The receiver is disabled */
-#define UART1_RS485CTRL_AADEN		((uint32_t)(1&lt;&lt;2))	/*!&lt; Auto Address Detect (AAD) is enabled */
-#define UART1_RS485CTRL_SEL_DTR		((uint32_t)(1&lt;&lt;3))	/*!&lt; If direction control is enabled
-														(bit DCTRL = 1), pin DTR is used for direction control */
-#define UART1_RS485CTRL_DCTRL_EN	((uint32_t)(1&lt;&lt;4))	/*!&lt; Enable Auto Direction Control */
-#define UART1_RS485CTRL_OINV_1		((uint32_t)(1&lt;&lt;5))	/*!&lt; This bit reverses the polarity of the direction
-														control signal on the RTS (or DTR) pin. The direction control pin
-														will be driven to logic &quot;1&quot; when the transmitter has data to be sent */
-#define UART1_RS485CTRL_BITMASK		((uint32_t)(0x3F))	/**&lt; RS485 control bit-mask value */
-
-
-/* Macro defines for UART1 RS-485 Address Match register */
-#define UART1_RS485ADRMATCH_BITMASK ((uint8_t)(0xFF)) 	/**&lt; Bit mask value */
-
-/* Macro defines for UART1 RS-485 Delay value register */
-#define UART1_RS485DLY_BITMASK		((uint8_t)(0xFF)) 	/** Bit mask value */
-
-
-/* Macro defines for UART FIFO Level register */
-#define UART_FIFOLVL_RXFIFOLVL(n)	((uint32_t)(n&amp;0x0F))		/**&lt; Reflects the current level of the UART receiver FIFO */
-#define UART_FIFOLVL_TXFIFOLVL(n)	((uint32_t)((n&gt;&gt;8)&amp;0x0F))	/**&lt; Reflects the current level of the UART transmitter FIFO */
-#define UART_FIFOLVL_BITMASK		((uint32_t)(0x0F0F))		/**&lt; UART FIFO Level Register bit mask */
-
-/**
- * @}
- */
-
-/**
- * @}
- */
-
-
-/* Public Types --------------------------------------------------------------- */
-/** @defgroup UART_Public_Types
- * @{
- */
-
-
-/**
- * @brief UART Databit type definitions
- */
-typedef enum {
-	UART_DATABIT_5		= 0,     		/*!&lt; UART 5 bit data mode */
-	UART_DATABIT_6,		     			/*!&lt; UART 6 bit data mode */
-	UART_DATABIT_7,		     			/*!&lt; UART 7 bit data mode */
-	UART_DATABIT_8		     			/*!&lt; UART 8 bit data mode */
-} UART_DATABIT_Type;
-
-/** Macro to check the input UART_DATABIT parameters */
-#define PARAM_UART_DATABIT(databit)	((databit==UART_DATABIT_5) || (databit==UART_DATABIT_6) \
-									|| (databit==UART_DATABIT_7) || (databit==UART_DATABIT_8))
-
-/**
- * @brief UART Stop bit type definitions
- */
-typedef enum {
-	UART_STOPBIT_1		= (0),   					/*!&lt; UART 1 Stop Bits Select */
-	UART_STOPBIT_2,		 							/*!&lt; UART Two Stop Bits Select */
-} UART_STOPBIT_Type;
-
-/** Macro to check the input UART_STOPBIT parameters */
-#define PARAM_UART_STOPBIT(stopbit)	((stopbit==UART_STOPBIT_1) || (stopbit==UART_STOPBIT_2))
-
-/**
- * @brief UART Parity type definitions
- */
-typedef enum {
-	UART_PARITY_NONE 	= 0,					/*!&lt; No parity */
-	UART_PARITY_ODD,	 						/*!&lt; Odd parity */
-	UART_PARITY_EVEN, 							/*!&lt; Even parity */
-	UART_PARITY_SP_1, 							/*!&lt; Forced &quot;1&quot; stick parity */
-	UART_PARITY_SP_0 							/*!&lt; Forced &quot;0&quot; stick parity */
-} UART_PARITY_Type;
-
-/** Macro to check the input UART_PARITY parameters */
-#define PARAM_UART_PARITY(parity)	((parity==UART_PARITY_NONE) || (parity==UART_PARITY_ODD) \
-									|| (parity==UART_PARITY_EVEN) || (parity==UART_PARITY_SP_1) \
-									|| (parity==UART_PARITY_SP_0))
-
-/**
- * @brief FIFO Level type definitions
- */
-typedef enum {
-	UART_FIFO_TRGLEV0 = 0,	/*!&lt; UART FIFO trigger level 0: 1 character */
-	UART_FIFO_TRGLEV1, 		/*!&lt; UART FIFO trigger level 1: 4 character */
-	UART_FIFO_TRGLEV2,		/*!&lt; UART FIFO trigger level 2: 8 character */
-	UART_FIFO_TRGLEV3		/*!&lt; UART FIFO trigger level 3: 14 character */
-} UART_FITO_LEVEL_Type;
-
-/** Macro to check the input UART_FIFO parameters */
-#define PARAM_UART_FIFO_LEVEL(fifo)	((fifo==UART_FIFO_TRGLEV0) \
-								|| (fifo==UART_FIFO_TRGLEV1) || (fifo==UART_FIFO_TRGLEV2) \
-								|| (fifo==UART_FIFO_TRGLEV3))
-
-/********************************************************************//**
-* @brief UART Interrupt Type definitions
-**********************************************************************/
-typedef enum {
-	UART_INTCFG_RBR = 0,	/*!&lt; RBR Interrupt enable*/
-	UART_INTCFG_THRE,		/*!&lt; THR Interrupt enable*/
-	UART_INTCFG_RLS,		/*!&lt; RX line status interrupt enable*/
-	UART1_INTCFG_MS,		/*!&lt; Modem status interrupt enable (UART1 only) */
-	UART1_INTCFG_CTS,		/*!&lt; CTS1 signal transition interrupt enable (UART1 only) */
-	UART_INTCFG_ABEO,		/*!&lt; Enables the end of auto-baud interrupt */
-	UART_INTCFG_ABTO		/*!&lt; Enables the auto-baud time-out interrupt */
-} UART_INT_Type;
-
-/** Macro to check the input UART_INTCFG parameters */
-#define PARAM_UART_INTCFG(IntCfg)	((IntCfg==UART_INTCFG_RBR) || (IntCfg==UART_INTCFG_THRE) \
-									|| (IntCfg==UART_INTCFG_RLS) || (IntCfg==UART_INTCFG_ABEO) \
-									|| (IntCfg==UART_INTCFG_ABTO))
-/** Macro to check the input UART1_INTCFG parameters - expansion input parameter for UART1 */
-#define PARAM_UART1_INTCFG(IntCfg)	((IntCfg==UART1_INTCFG_MS) || (IntCfg==UART1_INTCFG_CTS))
-
-
-/**
- * @brief UART Line Status Type definition
- */
-typedef enum {
-	UART_LINESTAT_RDR	= UART_LSR_RDR,			/*!&lt;Line status register: Receive data ready*/
-	UART_LINESTAT_OE	= UART_LSR_OE,			/*!&lt;Line status register: Overrun error*/
-	UART_LINESTAT_PE	= UART_LSR_PE,			/*!&lt;Line status register: Parity error*/
-	UART_LINESTAT_FE	= UART_LSR_FE,			/*!&lt;Line status register: Framing error*/
-	UART_LINESTAT_BI	= UART_LSR_BI,			/*!&lt;Line status register: Break interrupt*/
-	UART_LINESTAT_THRE	= UART_LSR_THRE,		/*!&lt;Line status register: Transmit holding register empty*/
-	UART_LINESTAT_TEMT	= UART_LSR_TEMT,		/*!&lt;Line status register: Transmitter empty*/
-	UART_LINESTAT_RXFE	= UART_LSR_RXFE			/*!&lt;Error in RX FIFO*/
-} UART_LS_Type;
-
-
-/**
- * @brief UART Auto-baudrate mode type definition
- */
-typedef enum {
-	UART_AUTOBAUD_MODE0				= 0,			/**&lt; UART Auto baudrate Mode 0 */
-	UART_AUTOBAUD_MODE1,							/**&lt; UART Auto baudrate Mode 1 */
-} UART_AB_MODE_Type;
-
-/** Macro to check the input UART_AUTOBAUD_MODE parameters */
-#define PARAM_UART_AUTOBAUD_MODE(ABmode)	((ABmode==UART_AUTOBAUD_MODE0) || (ABmode==UART_AUTOBAUD_MODE1))
-
-/**
- * @brief Auto Baudrate mode configuration type definition
- */
-typedef struct {
-	UART_AB_MODE_Type	ABMode;			/**&lt; Autobaudrate mode */
-	FunctionalState		AutoRestart;	/**&lt; Auto Restart state */
-} UART_AB_CFG_Type;
-
-
-/**
- * @brief UART End of Auto-baudrate type definition
- */
-typedef enum {
-	UART_AUTOBAUD_INTSTAT_ABEO		= UART_IIR_ABEO_INT,		/**&lt; UART End of auto-baud interrupt  */
-	UART_AUTOBAUD_INTSTAT_ABTO		= UART_IIR_ABTO_INT			/**&lt; UART Auto-baud time-out interrupt  */
-}UART_ABEO_Type;
-
-/** Macro to check the input UART_AUTOBAUD_INTSTAT parameters */
-#define PARAM_UART_AUTOBAUD_INTSTAT(ABIntStat)	((ABIntStat==UART_AUTOBAUD_INTSTAT_ABEO) \
-												|| (ABIntStat==UART_AUTOBAUD_INTSTAT_ABTO))
-
-/**
- * UART IrDA Control type Definition
- */
-typedef enum {
-	UART_IrDA_PULSEDIV2		= 0,		/**&lt; Pulse width = 2 * Tpclk
-										- Configures the pulse when FixPulseEn = 1 */
-	UART_IrDA_PULSEDIV4,				/**&lt; Pulse width = 4 * Tpclk
-										- Configures the pulse when FixPulseEn = 1 */
-	UART_IrDA_PULSEDIV8,				/**&lt; Pulse width = 8 * Tpclk
-										- Configures the pulse when FixPulseEn = 1 */
-	UART_IrDA_PULSEDIV16,				/**&lt; Pulse width = 16 * Tpclk
-										- Configures the pulse when FixPulseEn = 1 */
-	UART_IrDA_PULSEDIV32,				/**&lt; Pulse width = 32 * Tpclk
-										- Configures the pulse when FixPulseEn = 1 */
-	UART_IrDA_PULSEDIV64,				/**&lt; Pulse width = 64 * Tpclk
-										- Configures the pulse when FixPulseEn = 1 */
-	UART_IrDA_PULSEDIV128,				/**&lt; Pulse width = 128 * Tpclk
-										- Configures the pulse when FixPulseEn = 1 */
-	UART_IrDA_PULSEDIV256				/**&lt; Pulse width = 256 * Tpclk
-										- Configures the pulse when FixPulseEn = 1 */
-} UART_IrDA_PULSE_Type;
-
-
-/** Macro to check the input UART_IrDA_PULSEDIV parameters */
-#define PARAM_UART_IrDA_PULSEDIV(PulseDiv)	((PulseDiv==UART_IrDA_PULSEDIV2) || (PulseDiv==UART_IrDA_PULSEDIV4) \
-											|| (PulseDiv==UART_IrDA_PULSEDIV8) || (PulseDiv==UART_IrDA_PULSEDIV16) \
-											|| (PulseDiv==UART_IrDA_PULSEDIV32) || (PulseDiv==UART_IrDA_PULSEDIV64) \
-											|| (PulseDiv==UART_IrDA_PULSEDIV128) || (PulseDiv==UART_IrDA_PULSEDIV256))
-
-/********************************************************************//**
-* @brief UART1 Full modem -  Signal states definition
-**********************************************************************/
-typedef enum {
-	INACTIVE = 0,			/* In-active state */
-	ACTIVE = !INACTIVE 		/* Active state */
-}UART1_SignalState;
-
-/* Macro to check the input UART1_SignalState parameters */
-#define PARAM_UART1_SIGNALSTATE(x) ((x==INACTIVE) || (x==ACTIVE))
-
-/**
- * @brief UART modem status type definition
- */
-typedef enum {
-	UART1_MODEM_STAT_DELTA_CTS	= UART1_MSR_DELTA_CTS,		/*!&lt; Set upon state change of input CTS */
-	UART1_MODEM_STAT_DELTA_DSR	= UART1_MSR_DELTA_DSR,		/*!&lt; Set upon state change of input DSR */
-	UART1_MODEM_STAT_LO2HI_RI	= UART1_MSR_LO2HI_RI,		/*!&lt; Set upon low to high transition of input RI */
-	UART1_MODEM_STAT_DELTA_DCD	= UART1_MSR_DELTA_DCD,		/*!&lt; Set upon state change of input DCD */
-	UART1_MODEM_STAT_CTS		= UART1_MSR_CTS,			/*!&lt; Clear To Send State */
-	UART1_MODEM_STAT_DSR		= UART1_MSR_DSR,			/*!&lt; Data Set Ready State */
-	UART1_MODEM_STAT_RI			= UART1_MSR_RI,				/*!&lt; Ring Indicator State */
-	UART1_MODEM_STAT_DCD		= UART1_MSR_DCD				/*!&lt; Data Carrier Detect State */
-} UART_MODEM_STAT_type;
-
-/**
- * @brief Modem output pin type definition
- */
-typedef enum {
-	UART1_MODEM_PIN_DTR			= 0,		/*!&lt; Source for modem output pin DTR */
-	UART1_MODEM_PIN_RTS						/*!&lt; Source for modem output pin RTS */
-} UART_MODEM_PIN_Type;
-
-/** Macro to check the input PARAM_UART1_MODEM_PIN parameters */
-#define PARAM_UART1_MODEM_PIN(x) ((x==UART1_MODEM_PIN_DTR) || (x==UART1_MODEM_PIN_RTS))
-
-
-/**
- * @brief UART Modem mode type definition
- */
-typedef enum {
-	UART1_MODEM_MODE_LOOPBACK	= 0,		/*!&lt; Loop back mode select */
-	UART1_MODEM_MODE_AUTO_RTS,				/*!&lt; Enable Auto RTS flow-control */
-	UART1_MODEM_MODE_AUTO_CTS 				/*!&lt; Enable Auto CTS flow-control */
-} UART_MODEM_MODE_Type;
-
-/** Macro to check the input PARAM_UART1_MODEM_MODE parameters */
-#define PARAM_UART1_MODEM_MODE(x) ((x==UART1_MODEM_MODE_LOOPBACK) || (x==UART1_MODEM_MODE_AUTO_RTS) \
-								|| (x==UART1_MODEM_MODE_AUTO_CTS))
-
-
-/**
- * @brief UART Direction Control Pin type definition
- */
-typedef enum {
-	UART1_RS485_DIRCTRL_RTS = 0,	/**&lt; Pin RTS is used for direction control */
-	UART1_RS485_DIRCTRL_DTR			/**&lt; Pin DTR is used for direction control */
-} UART_RS485_DIRCTRL_PIN_Type;
-
-/** Macro to check the direction control pin type */
-#define PARAM_UART_RS485_DIRCTRL_PIN(x)	((x==UART1_RS485_DIRCTRL_RTS) || (x==UART1_RS485_DIRCTRL_DTR))
-
-
-/********************************************************************//**
-* @brief UART Configuration Structure definition
-**********************************************************************/
-typedef struct {
-  uint32_t Baud_rate;   		/**&lt; UART baud rate */
-  UART_PARITY_Type Parity;    	/**&lt; Parity selection, should be:
-							   - UART_PARITY_NONE: No parity
-							   - UART_PARITY_ODD: Odd parity
-							   - UART_PARITY_EVEN: Even parity
-							   - UART_PARITY_SP_1: Forced &quot;1&quot; stick parity
-							   - UART_PARITY_SP_0: Forced &quot;0&quot; stick parity
-							   */
-  UART_DATABIT_Type Databits;   /**&lt; Number of data bits, should be:
-							   - UART_DATABIT_5: UART 5 bit data mode
-							   - UART_DATABIT_6: UART 6 bit data mode
-							   - UART_DATABIT_7: UART 7 bit data mode
-							   - UART_DATABIT_8: UART 8 bit data mode
-							   */
-  UART_STOPBIT_Type Stopbits;   /**&lt; Number of stop bits, should be:
-							   - UART_STOPBIT_1: UART 1 Stop Bits Select
-							   - UART_STOPBIT_2: UART 2 Stop Bits Select
-							   */
-} UART_CFG_Type;
-
-/********************************************************************//**
-* @brief UART FIFO Configuration Structure definition
-**********************************************************************/
-
-typedef struct {
-	FunctionalState FIFO_ResetRxBuf;	/**&lt; Reset Rx FIFO command state , should be:
-										 - ENABLE: Reset Rx FIFO in UART
-										 - DISABLE: Do not reset Rx FIFO  in UART
-										 */
-	FunctionalState FIFO_ResetTxBuf;	/**&lt; Reset Tx FIFO command state , should be:
-										 - ENABLE: Reset Tx FIFO in UART
-										 - DISABLE: Do not reset Tx FIFO  in UART
-										 */
-	FunctionalState FIFO_DMAMode;		/**&lt; DMA mode, should be:
-										 - ENABLE: Enable DMA mode in UART
-										 - DISABLE: Disable DMA mode in UART
-										 */
-	UART_FITO_LEVEL_Type FIFO_Level;	/**&lt; Rx FIFO trigger level, should be:
-										- UART_FIFO_TRGLEV0: UART FIFO trigger level 0: 1 character
-										- UART_FIFO_TRGLEV1: UART FIFO trigger level 1: 4 character
-										- UART_FIFO_TRGLEV2: UART FIFO trigger level 2: 8 character
-										- UART_FIFO_TRGLEV3: UART FIFO trigger level 3: 14 character
-										*/
-} UART_FIFO_CFG_Type;
-
-
-/********************************************************************//**
-* @brief UART1 Full modem -  RS485 Control configuration type
-**********************************************************************/
-typedef struct {
-	FunctionalState NormalMultiDropMode_State; /*!&lt; Normal MultiDrop mode State:
-													- ENABLE: Enable this function.
-													- DISABLE: Disable this function. */
-	FunctionalState Rx_State;					/*!&lt; Receiver State:
-													- ENABLE: Enable Receiver.
-													- DISABLE: Disable Receiver. */
-	FunctionalState AutoAddrDetect_State;		/*!&lt; Auto Address Detect mode state:
-												- ENABLE: ENABLE this function.
-												- DISABLE: Disable this function. */
-	FunctionalState AutoDirCtrl_State;			/*!&lt; Auto Direction Control State:
-												- ENABLE: Enable this function.
-												- DISABLE: Disable this function. */
-	UART_RS485_DIRCTRL_PIN_Type DirCtrlPin;		/*!&lt; If direction control is enabled, state:
-												- UART1_RS485_DIRCTRL_RTS:
-												pin RTS is used for direction control.
-												- UART1_RS485_DIRCTRL_DTR:
-												pin DTR is used for direction control. */
-	 SetState DirCtrlPol_Level;					/*!&lt; Polarity of the direction control signal on
-												the RTS (or DTR) pin:
-												- RESET: The direction control pin will be driven
-												to logic &quot;0&quot; when the transmitter has data to be sent.
-												- SET: The direction control pin will be driven
-												to logic &quot;1&quot; when the transmitter has data to be sent. */
-	uint8_t MatchAddrValue;					/*!&lt; address match value for RS-485/EIA-485 mode, 8-bit long */
-	uint8_t DelayValue;						/*!&lt; delay time is in periods of the baud clock, 8-bit long */
-} UART1_RS485_CTRLCFG_Type;
-
-
-/* UART call-back function type definitions */
-/** UART Receive Call-back function type */
-typedef void (fnRxCbs_Type)(void);
-/** UART Transmit Call-back function type */
-typedef void (fnTxCbs_Type)(void);
-/** UART Auto-Baudrate Call-back function type */
-typedef void (fnABCbs_Type)(uint32_t bABIntType);
-/** UART Error Call-back function type */
-typedef void (fnErrCbs_Type)(uint8_t bError);
-/** UART1 modem status interrupt callback type */
-typedef void (fnModemCbs_Type)(uint8_t ModemStatus);
-
-
-/**
- * @}
- */
-
-
-/* Public Macros -------------------------------------------------------------- */
-/** @defgroup UART_Public_Macros
- * @{
- */
-
-
-/* Macro to determine if it is valid UART port number */
-#define PARAM_UARTx(x)	((((uint32_t *)x)==((uint32_t *)UART0)) \
-						|| (((uint32_t *)x)==((uint32_t *)UART1)) \
-						|| (((uint32_t *)x)==((uint32_t *)UART2)) \
-						|| (((uint32_t *)x)==((uint32_t *)UART3)))
-#define PARAM_UART_IrDA(x) (((uint32_t *)x)==((uint32_t *)UART3))
-#define PARAM_UART1_MODEM(x) (((uint32_t *)x)==((uint32_t *)UART1))
-
-
-/** Macro to check the input value for UART1_RS485_CFG_MATCHADDRVALUE parameter */
-#define PARAM_UART1_RS485_CFG_MATCHADDRVALUE(x) ((x&lt;0xFF))
-
-/** Macro to check the input value for UART1_RS485_CFG_DELAYVALUE parameter */
-#define PARAM_UART1_RS485_CFG_DELAYVALUE(x) ((x&lt;0xFF))
-
-
-/** UART time-out definitions in case of using Read() and Write function
- * with Blocking Flag mode
- */
-
-#define UART_BLOCKING_TIMEOUT			(0xFFFFFFFFUL)
-
-/**
- * @}
- */
-
-
-/* Public Functions ----------------------------------------------------------- */
-/** @defgroup UART_Public_Functions
- * @{
- */
-
-void UART_DeInit(UART_TypeDef* UARTx);
-void UART_Init(UART_TypeDef *UARTx, UART_CFG_Type *UART_ConfigStruct);
-void UART_ConfigStructInit(UART_CFG_Type *UART_InitStruct);
-void UART_SendData(UART_TypeDef* UARTx, uint8_t Data);
-uint8_t UART_ReceiveData(UART_TypeDef* UARTx);
-void UART_ForceBreak(UART_TypeDef* UARTx);
-void UART_IrDAInvtInputCmd(UART_TypeDef* UARTx, FunctionalState NewState);
-void UART_IrDACmd(UART_TypeDef* UARTx, FunctionalState NewState);
-void UART_IrDAPulseDivConfig(UART_TypeDef *UARTx, UART_IrDA_PULSE_Type PulseDiv);
-void UART_IntConfig(UART_TypeDef *UARTx, UART_INT_Type UARTIntCfg, \
-				FunctionalState NewState);
-uint8_t UART_GetLineStatus(UART_TypeDef* UARTx);
-FlagStatus UART_CheckBusy(UART_TypeDef *UARTx);
-void UART_FIFOConfig(UART_TypeDef *UARTx, UART_FIFO_CFG_Type *FIFOCfg);
-void UART_FIFOConfigStructInit(UART_FIFO_CFG_Type *UART_FIFOInitStruct);
-void UART_ABCmd(UART_TypeDef *UARTx, UART_AB_CFG_Type *ABConfigStruct, \
-				FunctionalState NewState);
-void UART_TxCmd(UART_TypeDef *UARTx, FunctionalState NewState);
-void UART_FullModemForcePinState(UART1_TypeDef *UARTx, UART_MODEM_PIN_Type Pin, \
-							UART1_SignalState NewState);
-void UART_FullModemConfigMode(UART1_TypeDef *UARTx, UART_MODEM_MODE_Type Mode, \
-							FunctionalState NewState);
-uint8_t UART_FullModemGetStatus(UART1_TypeDef *UARTx);
-void UART_RS485Config(UART1_TypeDef *UARTx, \
-		UART1_RS485_CTRLCFG_Type *RS485ConfigStruct);
-void UART_RS485ReceiverCmd(UART1_TypeDef *UARTx, FunctionalState NewState);
-void UART_RS485SendSlvAddr(UART1_TypeDef *UARTx, uint8_t SlvAddr);
-uint32_t UART_RS485SendData(UART1_TypeDef *UARTx, uint8_t *pData, uint32_t size);
-uint32_t UART_Send(UART_TypeDef *UARTx, uint8_t *txbuf,
-		uint32_t buflen, TRANSFER_BLOCK_Type flag);
-uint32_t UART_Receive(UART_TypeDef *UARTx, uint8_t *rxbuf, \
-		uint32_t buflen, TRANSFER_BLOCK_Type flag);
-void UART_SetupCbs(UART_TypeDef *UARTx, uint8_t CbType, void *pfnCbs);
-void UART0_StdIntHandler(void);
-void UART1_StdIntHandler(void);
-void UART2_StdIntHandler(void);
-void UART3_StdIntHandler(void);
-
-/**
- * @}
- */
-
-
-#ifdef __cplusplus
-}
-#endif
-
-
-#endif /* __LPC17XX_UART_H */
-
-/**
- * @}
- */
-
-/* --------------------------------- End Of File ------------------------------ */
+/***********************************************************************//**
+ * @file	: lpc17xx_uart.h
+ * @brief	: Contains all macro definitions and function prototypes
+ * 				support for UART firmware library on LPC17xx
+ * @version	: 1.0
+ * @date	: 18. Mar. 2009
+ * @author	: HieuNguyen
+ **************************************************************************
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * products. This software is supplied &quot;AS IS&quot; without any warranties.
+ * NXP Semiconductors assumes no responsibility or liability for the
+ * use of the software, conveys no license or title under any patent,
+ * copyright, or mask work right to the product. NXP Semiconductors
+ * reserves the right to make changes in the software without
+ * notification. NXP Semiconductors also make no representation or
+ * warranty that such application will be suitable for the specified
+ * use without further testing or modification.
+ **************************************************************************/
+
+/* Peripheral group ----------------------------------------------------------- */
+/** @defgroup UART
+ * @ingroup LPC1700CMSIS_FwLib_Drivers
+ * @{
+ */
+
+#ifndef __LPC17XX_UART_H
+#define __LPC17XX_UART_H
+
+/* Includes ------------------------------------------------------------------- */
+#include &quot;LPC17xx.h&quot;
+#include &quot;lpc_types.h&quot;
+
+
+#ifdef __cplusplus
+extern &quot;C&quot;
+{
+#endif
+
+
+/* Private Macros ------------------------------------------------------------- */
+/** @defgroup UART_Private_Macros
+ * @{
+ */
+
+
+/** @defgroup UART_REGISTER_BIT_DEFINITIONS
+ * @{
+ */
+
+/* Accepted Error baud rate value (in percent unit) */
+#define UART_ACCEPTED_BAUDRATE_ERROR	(3)			/*!&lt; Acceptable UART baudrate error */
+
+/* Macro defines for UARTn Receiver Buffer Register */
+#define UART_RBR_MASKBIT   	((uint8_t)0xFF) 		/*!&lt; UART Received Buffer mask bit (8 bits) */
+
+/* Macro defines for UARTn Transmit Holding Register */
+#define UART_THR_MASKBIT   	((uint8_t)0xFF) 		/*!&lt; UART Transmit Holding mask bit (8 bits) */
+
+/* Macro defines for UARTn Divisor Latch LSB register */
+#define UART_LOAD_DLL(div)	((div) &amp; 0xFF)	/**&lt; Macro for loading least significant halfs of divisors */
+#define UART_DLL_MASKBIT	((uint8_t)0xFF)	/*!&lt; Divisor latch LSB bit mask */
+
+/* Macro defines for UARTn Divisor Latch MSB register */
+#define UART_DLM_MASKBIT	((uint8_t)0xFF)			/*!&lt; Divisor latch MSB bit mask */
+#define UART_LOAD_DLM(div)  (((div) &gt;&gt; 8) &amp; 0xFF)	/**&lt; Macro for loading most significant halfs of divisors */
+
+
+/* Macro defines for UART interrupt enable register */
+#define UART_IER_RBRINT_EN		((uint32_t)(1&lt;&lt;0)) 	/*!&lt; RBR Interrupt enable*/
+#define UART_IER_THREINT_EN		((uint32_t)(1&lt;&lt;1)) 	/*!&lt; THR Interrupt enable*/
+#define UART_IER_RLSINT_EN		((uint32_t)(1&lt;&lt;2)) 	/*!&lt; RX line status interrupt enable*/
+#define UART1_IER_MSINT_EN		((uint32_t)(1&lt;&lt;3))	/*!&lt; Modem status interrupt enable */
+#define UART1_IER_CTSINT_EN		((uint32_t)(1&lt;&lt;7))	/*!&lt; CTS1 signal transition interrupt enable */
+#define UART_IER_ABEOINT_EN		((uint32_t)(1&lt;&lt;8)) 	/*!&lt; Enables the end of auto-baud interrupt */
+#define UART_IER_ABTOINT_EN		((uint32_t)(1&lt;&lt;9)) 	/*!&lt; Enables the auto-baud time-out interrupt */
+#define UART_IER_BITMASK		((uint32_t)(0x307)) /*!&lt; UART interrupt enable register bit mask */
+#define UART1_IER_BITMASK		((uint32_t)(0x38F)) /*!&lt; UART1 interrupt enable register bit mask */
+
+
+/* UART interrupt identification register defines */
+#define UART_IIR_INTSTAT_PEND	((uint32_t)(1&lt;&lt;0))	/*!&lt;Interrupt Status - Active low */
+#define UART_IIR_INTID_RLS		((uint32_t)(3&lt;&lt;1)) 	/*!&lt;Interrupt identification: Receive line status*/
+#define UART_IIR_INTID_RDA		((uint32_t)(2&lt;&lt;1)) 	/*!&lt;Interrupt identification: Receive data available*/
+#define UART_IIR_INTID_CTI		((uint32_t)(6&lt;&lt;1)) 	/*!&lt;Interrupt identification: Character time-out indicator*/
+#define UART_IIR_INTID_THRE		((uint32_t)(1&lt;&lt;1)) 	/*!&lt;Interrupt identification: THRE interrupt*/
+#define UART1_IIR_INTID_MODEM	((uint32_t)(0&lt;&lt;1)) 	/*!&lt;Interrupt identification: Modem interrupt*/
+#define UART_IIR_INTID_MASK		((uint32_t)(7&lt;&lt;1))	/*!&lt;Interrupt identification: Interrupt ID mask */
+#define UART_IIR_FIFO_EN		((uint32_t)(3&lt;&lt;6)) 	/*!&lt;These bits are equivalent to UnFCR[0] */
+#define UART_IIR_ABEO_INT		((uint32_t)(1&lt;&lt;8)) 	/*!&lt; End of auto-baud interrupt */
+#define UART_IIR_ABTO_INT		((uint32_t)(1&lt;&lt;9)) 	/*!&lt; Auto-baud time-out interrupt */
+#define UART_IIR_BITMASK		((uint32_t)(0x3CF))	/*!&lt; UART interrupt identification register bit mask */
+
+
+/* Macro defines for UART FIFO control register */
+#define UART_FCR_FIFO_EN		((uint8_t)(1&lt;&lt;0)) 	/*!&lt; UART FIFO enable */
+#define UART_FCR_RX_RS			((uint8_t)(1&lt;&lt;1)) 	/*!&lt; UART FIFO RX reset */
+#define UART_FCR_TX_RS			((uint8_t)(1&lt;&lt;2)) 	/*!&lt; UART FIFO TX reset */
+#define UART_FCR_DMAMODE_SEL 	((uint8_t)(1&lt;&lt;3)) 	/*!&lt; UART DMA mode selection */
+#define UART_FCR_TRG_LEV0		((uint8_t)(0)) 		/*!&lt; UART FIFO trigger level 0: 1 character */
+#define UART_FCR_TRG_LEV1		((uint8_t)(1&lt;&lt;6)) 	/*!&lt; UART FIFO trigger level 1: 4 character */
+#define UART_FCR_TRG_LEV2		((uint8_t)(2&lt;&lt;6)) 	/*!&lt; UART FIFO trigger level 2: 8 character */
+#define UART_FCR_TRG_LEV3		((uint8_t)(3&lt;&lt;6)) 	/*!&lt; UART FIFO trigger level 3: 14 character */
+#define UART_FCR_BITMASK		((uint8_t)(0xCF))	/*!&lt; UART FIFO control bit mask */
+#define UART_TX_FIFO_SIZE		(16)
+
+/* Macro defines for UART line control register */
+#define UART_LCR_WLEN5     		((uint8_t)(0))   		/*!&lt; UART 5 bit data mode */
+#define UART_LCR_WLEN6     		((uint8_t)(1&lt;&lt;0))   	/*!&lt; UART 6 bit data mode */
+#define UART_LCR_WLEN7     		((uint8_t)(2&lt;&lt;0))   	/*!&lt; UART 7 bit data mode */
+#define UART_LCR_WLEN8     		((uint8_t)(3&lt;&lt;0))   	/*!&lt; UART 8 bit data mode */
+#define UART_LCR_STOPBIT_SEL	((uint8_t)(1&lt;&lt;2))   	/*!&lt; UART Two Stop Bits Select */
+#define UART_LCR_PARITY_EN		((uint8_t)(1&lt;&lt;3))		/*!&lt; UART Parity Enable */
+#define UART_LCR_PARITY_ODD		((uint8_t)(0))         	/*!&lt; UART Odd Parity Select */
+#define UART_LCR_PARITY_EVEN	((uint8_t)(1&lt;&lt;4))		/*!&lt; UART Even Parity Select */
+#define UART_LCR_PARITY_F_1		((uint8_t)(2&lt;&lt;4))		/*!&lt; UART force 1 stick parity */
+#define UART_LCR_PARITY_F_0		((uint8_t)(3&lt;&lt;4))		/*!&lt; UART force 0 stick parity */
+#define UART_LCR_BREAK_EN		((uint8_t)(1&lt;&lt;6))		/*!&lt; UART Transmission Break enable */
+#define UART_LCR_DLAB_EN		((uint8_t)(1&lt;&lt;7))    	/*!&lt; UART Divisor Latches Access bit enable */
+#define UART_LCR_BITMASK		((uint8_t)(0xFF))		/*!&lt; UART line control bit mask */
+
+
+/* Macro defines for UART1 Modem Control Register */
+#define UART1_MCR_DTR_CTRL		((uint8_t)(1&lt;&lt;0))		/*!&lt; Source for modem output pin DTR */
+#define UART1_MCR_RTS_CTRL		((uint8_t)(1&lt;&lt;1))		/*!&lt; Source for modem output pin RTS */
+#define UART1_MCR_LOOPB_EN		((uint8_t)(1&lt;&lt;4))		/*!&lt; Loop back mode select */
+#define UART1_MCR_AUTO_RTS_EN	((uint8_t)(1&lt;&lt;6))		/*!&lt; Enable Auto RTS flow-control */
+#define UART1_MCR_AUTO_CTS_EN	((uint8_t)(1&lt;&lt;7))		/*!&lt; Enable Auto CTS flow-control */
+#define UART1_MCR_BITMASK		((uint8_t)(0x0F3))		/*!&lt; UART1 bit mask value */
+
+
+/* Macro defines for UART line status register */
+#define UART_LSR_RDR		((uint8_t)(1&lt;&lt;0)) 	/*!&lt;Line status register: Receive data ready*/
+#define UART_LSR_OE			((uint8_t)(1&lt;&lt;1)) 	/*!&lt;Line status register: Overrun error*/
+#define UART_LSR_PE			((uint8_t)(1&lt;&lt;2)) 	/*!&lt;Line status register: Parity error*/
+#define UART_LSR_FE			((uint8_t)(1&lt;&lt;3)) 	/*!&lt;Line status register: Framing error*/
+#define UART_LSR_BI			((uint8_t)(1&lt;&lt;4)) 	/*!&lt;Line status register: Break interrupt*/
+#define UART_LSR_THRE		((uint8_t)(1&lt;&lt;5)) 	/*!&lt;Line status register: Transmit holding register empty*/
+#define UART_LSR_TEMT		((uint8_t)(1&lt;&lt;6)) 	/*!&lt;Line status register: Transmitter empty*/
+#define UART_LSR_RXFE		((uint8_t)(1&lt;&lt;7)) 	/*!&lt;Error in RX FIFO*/
+#define UART_LSR_BITMASK	((uint8_t)(0xFF)) 	/*!&lt;UART Line status bit mask */
+
+
+/* Macro defines for UART Modem (UART1 only) status register */
+#define UART1_MSR_DELTA_CTS		((uint8_t)(1&lt;&lt;0))	/*!&lt; Set upon state change of input CTS */
+#define UART1_MSR_DELTA_DSR		((uint8_t)(1&lt;&lt;1))	/*!&lt; Set upon state change of input DSR */
+#define UART1_MSR_LO2HI_RI		((uint8_t)(1&lt;&lt;2))	/*!&lt; Set upon low to high transition of input RI */
+#define UART1_MSR_DELTA_DCD		((uint8_t)(1&lt;&lt;3))	/*!&lt; Set upon state change of input DCD */
+#define UART1_MSR_CTS			((uint8_t)(1&lt;&lt;4))	/*!&lt; Clear To Send State */
+#define UART1_MSR_DSR			((uint8_t)(1&lt;&lt;5))	/*!&lt; Data Set Ready State */
+#define UART1_MSR_RI			((uint8_t)(1&lt;&lt;6))	/*!&lt; Ring Indicator State */
+#define UART1_MSR_DCD			((uint8_t)(1&lt;&lt;7))	/*!&lt; Data Carrier Detect State */
+#define UART1_MSR_BITMASK		((uint8_t)(0xFF))	/*!&lt; MSR register bit-mask value */
+
+
+/* Macro defines for UART Scratch Pad Register */
+#define UART_SCR_BIMASK		((uint8_t)(0xFF))	/*!&lt; UART Scratch Pad bit mask */
+
+/* Macro defines for UART Auto baudrate control register */
+#define UART_ACR_START				((uint32_t)(1&lt;&lt;0))	/**&lt; UART Auto-baud start */
+#define UART_ACR_MODE				((uint32_t)(1&lt;&lt;1))	/**&lt; UART Auto baudrate Mode 1 */
+#define UART_ACR_AUTO_RESTART		((uint32_t)(1&lt;&lt;2))	/**&lt; UART Auto baudrate restart */
+#define UART_ACR_ABEOINT_CLR		((uint32_t)(1&lt;&lt;8))	/**&lt; UART End of auto-baud interrupt clear */
+#define UART_ACR_ABTOINT_CLR		((uint32_t)(1&lt;&lt;9))	/**&lt; UART Auto-baud time-out interrupt clear */
+#define UART_ACR_BITMASK			((uint32_t)(0x307))	/**&lt; UART Auto Baudrate register bit mask */
+
+/* UART IrDA control register defines */
+#define UART_ICR_IRDAEN			((uint32_t)(1&lt;&lt;0))			/**&lt; IrDA mode enable */
+#define UART_ICR_IRDAINV		((uint32_t)(1&lt;&lt;1))			/**&lt; IrDA serial input inverted */
+#define UART_ICR_FIXPULSE_EN	((uint32_t)(1&lt;&lt;2))			/**&lt; IrDA fixed pulse width mode */
+#define UART_ICR_PULSEDIV(n)	((uint32_t)((n&amp;0x07)&lt;&lt;3))	/**&lt; PulseDiv - Configures the pulse when FixPulseEn = 1 */
+#define UART_ICR_BITMASK		((uint32_t)(0x3F))			/*!&lt; UART IRDA bit mask */
+
+/* Macro defines for UART Fractional divider register */
+#define UART_FDR_DIVADDVAL(n)	((uint32_t)(n&amp;0x0F))		/**&lt; Baud-rate generation pre-scaler divisor */
+#define UART_FDR_MULVAL(n)		((uint32_t)((n&lt;&lt;4)&amp;0xF0))	/**&lt; Baud-rate pre-scaler multiplier value */
+#define UART_FDR_BITMASK		((uint32_t)(0xFF))			/**&lt; UART Fractional Divider register bit mask */
+
+/* Macro defines for UART Tx Enable register */
+#define UART_TER_TXEN			((uint8_t)(1&lt;&lt;7)) 		/*!&lt; Transmit enable bit */
+#define UART_TER_BITMASK		((uint8_t)(0x80))		/**&lt; UART Transmit Enable Register bit mask */
+
+
+/* Macro defines for UART1 RS485 Control register */
+#define UART1_RS485CTRL_NMM_EN		((uint32_t)(1&lt;&lt;0))	/*!&lt; RS-485/EIA-485 Normal Multi-drop Mode (NMM)
+														is disabled */
+#define UART1_RS485CTRL_RX_DIS		((uint32_t)(1&lt;&lt;1))	/*!&lt; The receiver is disabled */
+#define UART1_RS485CTRL_AADEN		((uint32_t)(1&lt;&lt;2))	/*!&lt; Auto Address Detect (AAD) is enabled */
+#define UART1_RS485CTRL_SEL_DTR		((uint32_t)(1&lt;&lt;3))	/*!&lt; If direction control is enabled
+														(bit DCTRL = 1), pin DTR is used for direction control */
+#define UART1_RS485CTRL_DCTRL_EN	((uint32_t)(1&lt;&lt;4))	/*!&lt; Enable Auto Direction Control */
+#define UART1_RS485CTRL_OINV_1		((uint32_t)(1&lt;&lt;5))	/*!&lt; This bit reverses the polarity of the direction
+														control signal on the RTS (or DTR) pin. The direction control pin
+														will be driven to logic &quot;1&quot; when the transmitter has data to be sent */
+#define UART1_RS485CTRL_BITMASK		((uint32_t)(0x3F))	/**&lt; RS485 control bit-mask value */
+
+
+/* Macro defines for UART1 RS-485 Address Match register */
+#define UART1_RS485ADRMATCH_BITMASK ((uint8_t)(0xFF)) 	/**&lt; Bit mask value */
+
+/* Macro defines for UART1 RS-485 Delay value register */
+#define UART1_RS485DLY_BITMASK		((uint8_t)(0xFF)) 	/** Bit mask value */
+
+
+/* Macro defines for UART FIFO Level register */
+#define UART_FIFOLVL_RXFIFOLVL(n)	((uint32_t)(n&amp;0x0F))		/**&lt; Reflects the current level of the UART receiver FIFO */
+#define UART_FIFOLVL_TXFIFOLVL(n)	((uint32_t)((n&gt;&gt;8)&amp;0x0F))	/**&lt; Reflects the current level of the UART transmitter FIFO */
+#define UART_FIFOLVL_BITMASK		((uint32_t)(0x0F0F))		/**&lt; UART FIFO Level Register bit mask */
+
+/**
+ * @}
+ */
+
+/**
+ * @}
+ */
+
+
+/* Public Types --------------------------------------------------------------- */
+/** @defgroup UART_Public_Types
+ * @{
+ */
+
+
+/**
+ * @brief UART Databit type definitions
+ */
+typedef enum {
+	UART_DATABIT_5		= 0,     		/*!&lt; UART 5 bit data mode */
+	UART_DATABIT_6,		     			/*!&lt; UART 6 bit data mode */
+	UART_DATABIT_7,		     			/*!&lt; UART 7 bit data mode */
+	UART_DATABIT_8		     			/*!&lt; UART 8 bit data mode */
+} UART_DATABIT_Type;
+
+/** Macro to check the input UART_DATABIT parameters */
+#define PARAM_UART_DATABIT(databit)	((databit==UART_DATABIT_5) || (databit==UART_DATABIT_6)\
+|| (databit==UART_DATABIT_7) || (databit==UART_DATABIT_8))
+
+/**
+ * @brief UART Stop bit type definitions
+ */
+typedef enum {
+	UART_STOPBIT_1		= (0),   					/*!&lt; UART 1 Stop Bits Select */
+	UART_STOPBIT_2,		 							/*!&lt; UART Two Stop Bits Select */
+} UART_STOPBIT_Type;
+
+/** Macro to check the input UART_STOPBIT parameters */
+#define PARAM_UART_STOPBIT(stopbit)	((stopbit==UART_STOPBIT_1) || (stopbit==UART_STOPBIT_2))
+
+/**
+ * @brief UART Parity type definitions
+ */
+typedef enum {
+	UART_PARITY_NONE 	= 0,					/*!&lt; No parity */
+	UART_PARITY_ODD,	 						/*!&lt; Odd parity */
+	UART_PARITY_EVEN, 							/*!&lt; Even parity */
+	UART_PARITY_SP_1, 							/*!&lt; Forced &quot;1&quot; stick parity */
+	UART_PARITY_SP_0 							/*!&lt; Forced &quot;0&quot; stick parity */
+} UART_PARITY_Type;
+
+/** Macro to check the input UART_PARITY parameters */
+#define PARAM_UART_PARITY(parity)	((parity==UART_PARITY_NONE) || (parity==UART_PARITY_ODD) \
+|| (parity==UART_PARITY_EVEN) || (parity==UART_PARITY_SP_1) \
+|| (parity==UART_PARITY_SP_0))
+
+/**
+ * @brief FIFO Level type definitions
+ */
+typedef enum {
+	UART_FIFO_TRGLEV0 = 0,	/*!&lt; UART FIFO trigger level 0: 1 character */
+	UART_FIFO_TRGLEV1, 		/*!&lt; UART FIFO trigger level 1: 4 character */
+	UART_FIFO_TRGLEV2,		/*!&lt; UART FIFO trigger level 2: 8 character */
+	UART_FIFO_TRGLEV3		/*!&lt; UART FIFO trigger level 3: 14 character */
+} UART_FITO_LEVEL_Type;
+
+/** Macro to check the input UART_FIFO parameters */
+#define PARAM_UART_FIFO_LEVEL(fifo)	((fifo==UART_FIFO_TRGLEV0) \
+|| (fifo==UART_FIFO_TRGLEV1) || (fifo==UART_FIFO_TRGLEV2) \
+|| (fifo==UART_FIFO_TRGLEV3))
+
+/********************************************************************//**
+* @brief UART Interrupt Type definitions
+**********************************************************************/
+typedef enum {
+	UART_INTCFG_RBR = 0,	/*!&lt; RBR Interrupt enable*/
+	UART_INTCFG_THRE,		/*!&lt; THR Interrupt enable*/
+	UART_INTCFG_RLS,		/*!&lt; RX line status interrupt enable*/
+	UART1_INTCFG_MS,		/*!&lt; Modem status interrupt enable (UART1 only) */
+	UART1_INTCFG_CTS,		/*!&lt; CTS1 signal transition interrupt enable (UART1 only) */
+	UART_INTCFG_ABEO,		/*!&lt; Enables the end of auto-baud interrupt */
+	UART_INTCFG_ABTO		/*!&lt; Enables the auto-baud time-out interrupt */
+} UART_INT_Type;
+
+/** Macro to check the input UART_INTCFG parameters */
+#define PARAM_UART_INTCFG(IntCfg)	((IntCfg==UART_INTCFG_RBR) || (IntCfg==UART_INTCFG_THRE) \
+|| (IntCfg==UART_INTCFG_RLS) || (IntCfg==UART_INTCFG_ABEO) \
+|| (IntCfg==UART_INTCFG_ABTO))
+
+/** Macro to check the input UART1_INTCFG parameters - expansion input parameter for UART1 */
+#define PARAM_UART1_INTCFG(IntCfg)	((IntCfg==UART1_INTCFG_MS) || (IntCfg==UART1_INTCFG_CTS))
+
+
+/**
+ * @brief UART Line Status Type definition
+ */
+typedef enum {
+	UART_LINESTAT_RDR	= UART_LSR_RDR,			/*!&lt;Line status register: Receive data ready*/
+	UART_LINESTAT_OE	= UART_LSR_OE,			/*!&lt;Line status register: Overrun error*/
+	UART_LINESTAT_PE	= UART_LSR_PE,			/*!&lt;Line status register: Parity error*/
+	UART_LINESTAT_FE	= UART_LSR_FE,			/*!&lt;Line status register: Framing error*/
+	UART_LINESTAT_BI	= UART_LSR_BI,			/*!&lt;Line status register: Break interrupt*/
+	UART_LINESTAT_THRE	= UART_LSR_THRE,		/*!&lt;Line status register: Transmit holding register empty*/
+	UART_LINESTAT_TEMT	= UART_LSR_TEMT,		/*!&lt;Line status register: Transmitter empty*/
+	UART_LINESTAT_RXFE	= UART_LSR_RXFE			/*!&lt;Error in RX FIFO*/
+} UART_LS_Type;
+
+
+/**
+ * @brief UART Auto-baudrate mode type definition
+ */
+typedef enum {
+	UART_AUTOBAUD_MODE0				= 0,			/**&lt; UART Auto baudrate Mode 0 */
+	UART_AUTOBAUD_MODE1,							/**&lt; UART Auto baudrate Mode 1 */
+} UART_AB_MODE_Type;
+
+/** Macro to check the input UART_AUTOBAUD_MODE parameters */
+#define PARAM_UART_AUTOBAUD_MODE(ABmode)	((ABmode==UART_AUTOBAUD_MODE0) || (ABmode==UART_AUTOBAUD_MODE1))
+
+/**
+ * @brief Auto Baudrate mode configuration type definition
+ */
+typedef struct {
+	UART_AB_MODE_Type	ABMode;			/**&lt; Autobaudrate mode */
+	FunctionalState		AutoRestart;	/**&lt; Auto Restart state */
+} UART_AB_CFG_Type;
+
+
+/**
+ * @brief UART End of Auto-baudrate type definition
+ */
+typedef enum {
+	UART_AUTOBAUD_INTSTAT_ABEO		= UART_IIR_ABEO_INT,		/**&lt; UART End of auto-baud interrupt  */
+	UART_AUTOBAUD_INTSTAT_ABTO		= UART_IIR_ABTO_INT			/**&lt; UART Auto-baud time-out interrupt  */
+}UART_ABEO_Type;
+
+/** Macro to check the input UART_AUTOBAUD_INTSTAT parameters */
+#define PARAM_UART_AUTOBAUD_INTSTAT(ABIntStat)	((ABIntStat==UART_AUTOBAUD_INTSTAT_ABEO) || (ABIntStat==UART_AUTOBAUD_INTSTAT_ABTO))
+
+/**
+ * UART IrDA Control type Definition
+ */
+typedef enum {
+	UART_IrDA_PULSEDIV2		= 0,		/**&lt; Pulse width = 2 * Tpclk
+										- Configures the pulse when FixPulseEn = 1 */
+	UART_IrDA_PULSEDIV4,				/**&lt; Pulse width = 4 * Tpclk
+										- Configures the pulse when FixPulseEn = 1 */
+	UART_IrDA_PULSEDIV8,				/**&lt; Pulse width = 8 * Tpclk
+										- Configures the pulse when FixPulseEn = 1 */
+	UART_IrDA_PULSEDIV16,				/**&lt; Pulse width = 16 * Tpclk
+										- Configures the pulse when FixPulseEn = 1 */
+	UART_IrDA_PULSEDIV32,				/**&lt; Pulse width = 32 * Tpclk
+										- Configures the pulse when FixPulseEn = 1 */
+	UART_IrDA_PULSEDIV64,				/**&lt; Pulse width = 64 * Tpclk
+										- Configures the pulse when FixPulseEn = 1 */
+	UART_IrDA_PULSEDIV128,				/**&lt; Pulse width = 128 * Tpclk
+										- Configures the pulse when FixPulseEn = 1 */
+	UART_IrDA_PULSEDIV256				/**&lt; Pulse width = 256 * Tpclk
+										- Configures the pulse when FixPulseEn = 1 */
+} UART_IrDA_PULSE_Type;
+
+
+/** Macro to check the input UART_IrDA_PULSEDIV parameters */
+#define PARAM_UART_IrDA_PULSEDIV(PulseDiv)	((PulseDiv==UART_IrDA_PULSEDIV2) || (PulseDiv==UART_IrDA_PULSEDIV4) \
+|| (PulseDiv==UART_IrDA_PULSEDIV8) || (PulseDiv==UART_IrDA_PULSEDIV16) \
+|| (PulseDiv==UART_IrDA_PULSEDIV32) || (PulseDiv==UART_IrDA_PULSEDIV64) \
+|| (PulseDiv==UART_IrDA_PULSEDIV128) || (PulseDiv==UART_IrDA_PULSEDIV256))
+
+/********************************************************************//**
+* @brief UART1 Full modem -  Signal states definition
+**********************************************************************/
+typedef enum {
+	INACTIVE = 0,			/* In-active state */
+	ACTIVE = !INACTIVE 		/* Active state */
+}UART1_SignalState;
+
+/* Macro to check the input UART1_SignalState parameters */
+#define PARAM_UART1_SIGNALSTATE(x) ((x==INACTIVE) || (x==ACTIVE))
+
+/**
+ * @brief UART modem status type definition
+ */
+typedef enum {
+	UART1_MODEM_STAT_DELTA_CTS	= UART1_MSR_DELTA_CTS,		/*!&lt; Set upon state change of input CTS */
+	UART1_MODEM_STAT_DELTA_DSR	= UART1_MSR_DELTA_DSR,		/*!&lt; Set upon state change of input DSR */
+	UART1_MODEM_STAT_LO2HI_RI	= UART1_MSR_LO2HI_RI,		/*!&lt; Set upon low to high transition of input RI */
+	UART1_MODEM_STAT_DELTA_DCD	= UART1_MSR_DELTA_DCD,		/*!&lt; Set upon state change of input DCD */
+	UART1_MODEM_STAT_CTS		= UART1_MSR_CTS,			/*!&lt; Clear To Send State */
+	UART1_MODEM_STAT_DSR		= UART1_MSR_DSR,			/*!&lt; Data Set Ready State */
+	UART1_MODEM_STAT_RI			= UART1_MSR_RI,				/*!&lt; Ring Indicator State */
+	UART1_MODEM_STAT_DCD		= UART1_MSR_DCD				/*!&lt; Data Carrier Detect State */
+} UART_MODEM_STAT_type;
+
+/**
+ * @brief Modem output pin type definition
+ */
+typedef enum {
+	UART1_MODEM_PIN_DTR			= 0,		/*!&lt; Source for modem output pin DTR */
+	UART1_MODEM_PIN_RTS						/*!&lt; Source for modem output pin RTS */
+} UART_MODEM_PIN_Type;
+
+/** Macro to check the input PARAM_UART1_MODEM_PIN parameters */
+#define PARAM_UART1_MODEM_PIN(x) ((x==UART1_MODEM_PIN_DTR) || (x==UART1_MODEM_PIN_RTS))
+
+
+/**
+ * @brief UART Modem mode type definition
+ */
+typedef enum {
+	UART1_MODEM_MODE_LOOPBACK	= 0,		/*!&lt; Loop back mode select */
+	UART1_MODEM_MODE_AUTO_RTS,				/*!&lt; Enable Auto RTS flow-control */
+	UART1_MODEM_MODE_AUTO_CTS 				/*!&lt; Enable Auto CTS flow-control */
+} UART_MODEM_MODE_Type;
+
+/** Macro to check the input PARAM_UART1_MODEM_MODE parameters */
+#define PARAM_UART1_MODEM_MODE(x) ((x==UART1_MODEM_MODE_LOOPBACK) || (x==UART1_MODEM_MODE_AUTO_RTS) \
+|| (x==UART1_MODEM_MODE_AUTO_CTS))
+
+
+/**
+ * @brief UART Direction Control Pin type definition
+ */
+typedef enum {
+	UART1_RS485_DIRCTRL_RTS = 0,	/**&lt; Pin RTS is used for direction control */
+	UART1_RS485_DIRCTRL_DTR			/**&lt; Pin DTR is used for direction control */
+} UART_RS485_DIRCTRL_PIN_Type;
+
+/** Macro to check the direction control pin type */
+#define PARAM_UART_RS485_DIRCTRL_PIN(x)	((x==UART1_RS485_DIRCTRL_RTS) || (x==UART1_RS485_DIRCTRL_DTR))
+
+
+/********************************************************************//**
+* @brief UART Configuration Structure definition
+**********************************************************************/
+typedef struct {
+  uint32_t Baud_rate;   		/**&lt; UART baud rate */
+  UART_PARITY_Type Parity;    	/**&lt; Parity selection, should be:
+							   - UART_PARITY_NONE: No parity
+							   - UART_PARITY_ODD: Odd parity
+							   - UART_PARITY_EVEN: Even parity
+							   - UART_PARITY_SP_1: Forced &quot;1&quot; stick parity
+							   - UART_PARITY_SP_0: Forced &quot;0&quot; stick parity
+							   */
+  UART_DATABIT_Type Databits;   /**&lt; Number of data bits, should be:
+							   - UART_DATABIT_5: UART 5 bit data mode
+							   - UART_DATABIT_6: UART 6 bit data mode
+							   - UART_DATABIT_7: UART 7 bit data mode
+							   - UART_DATABIT_8: UART 8 bit data mode
+							   */
+  UART_STOPBIT_Type Stopbits;   /**&lt; Number of stop bits, should be:
+							   - UART_STOPBIT_1: UART 1 Stop Bits Select
+							   - UART_STOPBIT_2: UART 2 Stop Bits Select
+							   */
+} UART_CFG_Type;
+
+/********************************************************************//**
+* @brief UART FIFO Configuration Structure definition
+**********************************************************************/
+
+typedef struct {
+	FunctionalState FIFO_ResetRxBuf;	/**&lt; Reset Rx FIFO command state , should be:
+										 - ENABLE: Reset Rx FIFO in UART
+										 - DISABLE: Do not reset Rx FIFO  in UART
+										 */
+	FunctionalState FIFO_ResetTxBuf;	/**&lt; Reset Tx FIFO command state , should be:
+										 - ENABLE: Reset Tx FIFO in UART
+										 - DISABLE: Do not reset Tx FIFO  in UART
+										 */
+	FunctionalState FIFO_DMAMode;		/**&lt; DMA mode, should be:
+										 - ENABLE: Enable DMA mode in UART
+										 - DISABLE: Disable DMA mode in UART
+										 */
+	UART_FITO_LEVEL_Type FIFO_Level;	/**&lt; Rx FIFO trigger level, should be:
+										- UART_FIFO_TRGLEV0: UART FIFO trigger level 0: 1 character
+										- UART_FIFO_TRGLEV1: UART FIFO trigger level 1: 4 character
+										- UART_FIFO_TRGLEV2: UART FIFO trigger level 2: 8 character
+										- UART_FIFO_TRGLEV3: UART FIFO trigger level 3: 14 character
+										*/
+} UART_FIFO_CFG_Type;
+
+
+/********************************************************************//**
+* @brief UART1 Full modem -  RS485 Control configuration type
+**********************************************************************/
+typedef struct {
+	FunctionalState NormalMultiDropMode_State; /*!&lt; Normal MultiDrop mode State:
+													- ENABLE: Enable this function.
+													- DISABLE: Disable this function. */
+	FunctionalState Rx_State;					/*!&lt; Receiver State:
+													- ENABLE: Enable Receiver.
+													- DISABLE: Disable Receiver. */
+	FunctionalState AutoAddrDetect_State;		/*!&lt; Auto Address Detect mode state:
+												- ENABLE: ENABLE this function.
+												- DISABLE: Disable this function. */
+	FunctionalState AutoDirCtrl_State;			/*!&lt; Auto Direction Control State:
+												- ENABLE: Enable this function.
+												- DISABLE: Disable this function. */
+	UART_RS485_DIRCTRL_PIN_Type DirCtrlPin;		/*!&lt; If direction control is enabled, state:
+												- UART1_RS485_DIRCTRL_RTS:
+												pin RTS is used for direction control.
+												- UART1_RS485_DIRCTRL_DTR:
+												pin DTR is used for direction control. */
+	 SetState DirCtrlPol_Level;					/*!&lt; Polarity of the direction control signal on
+												the RTS (or DTR) pin:
+												- RESET: The direction control pin will be driven
+												to logic &quot;0&quot; when the transmitter has data to be sent.
+												- SET: The direction control pin will be driven
+												to logic &quot;1&quot; when the transmitter has data to be sent. */
+	uint8_t MatchAddrValue;					/*!&lt; address match value for RS-485/EIA-485 mode, 8-bit long */
+	uint8_t DelayValue;						/*!&lt; delay time is in periods of the baud clock, 8-bit long */
+} UART1_RS485_CTRLCFG_Type;
+
+
+/* UART call-back function type definitions */
+/** UART Receive Call-back function type */
+typedef void (fnRxCbs_Type)(void);
+/** UART Transmit Call-back function type */
+typedef void (fnTxCbs_Type)(void);
+/** UART Auto-Baudrate Call-back function type */
+typedef void (fnABCbs_Type)(uint32_t bABIntType);
+/** UART Error Call-back function type */
+typedef void (fnErrCbs_Type)(uint8_t bError);
+/** UART1 modem status interrupt callback type */
+typedef void (fnModemCbs_Type)(uint8_t ModemStatus);
+
+
+/**
+ * @}
+ */
+
+
+/* Public Macros -------------------------------------------------------------- */
+/** @defgroup UART_Public_Macros
+ * @{
+ */
+
+
+/* Macro to determine if it is valid UART port number */
+#define PARAM_UARTx(x)	((((uint32_t *)x)==((uint32_t *)LPC_UART0)) \
+|| (((uint32_t *)x)==((uint32_t *)LPC_UART1)) \
+|| (((uint32_t *)x)==((uint32_t *)LPC_UART2)) \
+|| (((uint32_t *)x)==((uint32_t *)LPC_UART3)))
+#define PARAM_UART_IrDA(x) (((uint32_t *)x)==((uint32_t *)LPC_UART3))
+#define PARAM_UART1_MODEM(x) (((uint32_t *)x)==((uint32_t *)LPC_UART1))
+
+
+/** Macro to check the input value for UART1_RS485_CFG_MATCHADDRVALUE parameter */
+#define PARAM_UART1_RS485_CFG_MATCHADDRVALUE(x) ((x&lt;0xFF))
+
+/** Macro to check the input value for UART1_RS485_CFG_DELAYVALUE parameter */
+#define PARAM_UART1_RS485_CFG_DELAYVALUE(x) ((x&lt;0xFF))
+
+
+/** UART time-out definitions in case of using Read() and Write function
+ * with Blocking Flag mode
+ */
+
+#define UART_BLOCKING_TIMEOUT			(0xFFFFFFFFUL)
+
+/**
+ * @}
+ */
+
+
+/* Public Functions ----------------------------------------------------------- */
+/** @defgroup UART_Public_Functions
+ * @{
+ */
+
+void UART_DeInit(LPC_UART_TypeDef* UARTx);
+void UART_Init(LPC_UART_TypeDef *UARTx, UART_CFG_Type *UART_ConfigStruct);
+void UART_ConfigStructInit(UART_CFG_Type *UART_InitStruct);
+void UART_SendData(LPC_UART_TypeDef* UARTx, uint8_t Data);
+uint8_t UART_ReceiveData(LPC_UART_TypeDef* UARTx);
+void UART_ForceBreak(LPC_UART_TypeDef* UARTx);
+void UART_IrDAInvtInputCmd(LPC_UART_TypeDef* UARTx, FunctionalState NewState);
+void UART_IrDACmd(LPC_UART_TypeDef* UARTx, FunctionalState NewState);
+void UART_IrDAPulseDivConfig(LPC_UART_TypeDef *UARTx, UART_IrDA_PULSE_Type PulseDiv);
+void UART_IntConfig(LPC_UART_TypeDef *UARTx, UART_INT_Type UARTIntCfg, \
+				FunctionalState NewState);
+uint8_t UART_GetLineStatus(LPC_UART_TypeDef* UARTx);
+FlagStatus UART_CheckBusy(LPC_UART_TypeDef *UARTx);
+void UART_FIFOConfig(LPC_UART_TypeDef *UARTx, UART_FIFO_CFG_Type *FIFOCfg);
+void UART_FIFOConfigStructInit(UART_FIFO_CFG_Type *UART_FIFOInitStruct);
+void UART_ABCmd(LPC_UART_TypeDef *UARTx, UART_AB_CFG_Type *ABConfigStruct, \
+				FunctionalState NewState);
+void UART_TxCmd(LPC_UART_TypeDef *UARTx, FunctionalState NewState);
+void UART_FullModemForcePinState(LPC_UART1_TypeDef *UARTx, UART_MODEM_PIN_Type Pin, \
+							UART1_SignalState NewState);
+void UART_FullModemConfigMode(LPC_UART1_TypeDef *UARTx, UART_MODEM_MODE_Type Mode, \
+							FunctionalState NewState);
+uint8_t UART_FullModemGetStatus(LPC_UART1_TypeDef *UARTx);
+void UART_RS485Config(LPC_UART1_TypeDef *UARTx, \
+		UART1_RS485_CTRLCFG_Type *RS485ConfigStruct);
+void UART_RS485ReceiverCmd(LPC_UART1_TypeDef *UARTx, FunctionalState NewState);
+void UART_RS485SendSlvAddr(LPC_UART1_TypeDef *UARTx, uint8_t SlvAddr);
+uint32_t UART_RS485SendData(LPC_UART1_TypeDef *UARTx, uint8_t *pData, uint32_t size);
+uint32_t UART_Send(LPC_UART_TypeDef *UARTx, uint8_t *txbuf,
+		uint32_t buflen, TRANSFER_BLOCK_Type flag);
+uint32_t UART_Receive(LPC_UART_TypeDef *UARTx, uint8_t *rxbuf, \
+		uint32_t buflen, TRANSFER_BLOCK_Type flag);
+void UART_SetupCbs(LPC_UART_TypeDef *UARTx, uint8_t CbType, void *pfnCbs);
+void UART0_StdIntHandler(void);
+void UART1_StdIntHandler(void);
+void UART2_StdIntHandler(void);
+void UART3_StdIntHandler(void);
+
+/**
+ * @}
+ */
+
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif /* __LPC17XX_UART_H */
+
+/**
+ * @}
+ */
+
+/* --------------------------------- End Of File ------------------------------ */


Property changes on: trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_uart.h
___________________________________________________________________
Deleted: svn:executable
   - *

Modified: trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_wdt.h
===================================================================
--- trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_wdt.h	2010-06-28 21:53:59 UTC (rev 759)
+++ trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_wdt.h	2010-07-12 20:56:54 UTC (rev 760)
@@ -1,149 +1,147 @@
-/***********************************************************************//**
- * @file	: lpc17xx_wdt.h
- * @brief	: Contains all macro definitions and function prototypes
- * 				support for WDT firmware library on LPC17xx
- * @version	: 1.0
- * @date	: 9. April. 2009
- * @author	: HieuNguyen
- **************************************************************************
- * Software that is described herein is for illustrative purposes only
- * which provides customers with programming information regarding the
- * products. This software is supplied &quot;AS IS&quot; without any warranties.
- * NXP Semiconductors assumes no responsibility or liability for the
- * use of the software, conveys no license or title under any patent,
- * copyright, or mask work right to the product. NXP Semiconductors
- * reserves the right to make changes in the software without
- * notification. NXP Semiconductors also make no representation or
- * warranty that such application will be suitable for the specified
- * use without further testing or modification.
- **************************************************************************/
-
-/* Peripheral group ----------------------------------------------------------- */
-/** @defgroup WDT
- * @ingroup LPC1700CMSIS_FwLib_Drivers
- * @{
- */
-
-#ifndef LPC17XX_WDT_H_
-#define LPC17XX_WDT_H_
-
-/* Includes ------------------------------------------------------------------- */
-#include &quot;LPC17xx.h&quot;
-#include &quot;lpc_types.h&quot;
-
-
-#ifdef __cplusplus
-extern &quot;C&quot;
-{
-#endif
-
-
-/* Private Macros ------------------------------------------------------------- */
-/** @defgroup WDT_Private_Macros
- * @{
- */
-
-/** @defgroup WDT_REGISTER_BIT_DEFINITIONS
- * @{
- */
-/************************** WDT Control **************************/
-/** WDT interrupt enable bit */
-#define WDT_WDMOD_WDEN			    ((uint32_t)(1&lt;&lt;0))
-/** WDT interrupt enable bit */
-#define WDT_WDMOD_WDRESET			((uint32_t)(1&lt;&lt;1))
-/** WDT time out flag bit */
-#define WDT_WDMOD_WDTOF				((uint32_t)(1&lt;&lt;2))
-/** WDT Time Out flag bit */
-#define WDT_WDMOD_WDINT				((uint32_t)(1&lt;&lt;3))
-/** WDT Mode */
-#define WDT_WDMOD(n)				((uint32_t)(1&lt;&lt;1))
-
-/**************************** PRIVATE TYPES ***************************/
-/** Define divider index for microsecond ( us ) */
-#define WDT_US_INDEX	((uint32_t)(1000000))
-/** WDT Time out minimum value */
-#define WDT_TIMEOUT_MIN	((uint32_t)(0xFF))
-/** WDT Time out maximum value */
-#define WDT_TIMEOUT_MAX	((uint32_t)(0xFFFFFFFF))
-
-
-/**************************** GLOBAL/PUBLIC TYPES ***************************/
-/** Watchdog mode register mask */
-#define WDT_WDMOD_MASK			(uint8_t)(0x02)
-/** Watchdog timer constant register mask */
-#define WDT_WDTC_MASK			(uint8_t)(0xFFFFFFFF)
-/** Watchdog feed sequence register mask */
-#define WDT_WDFEED_MASK 		(uint8_t)(0x000000FF)
-/** Watchdog timer value register mask */
-#define WDT_WDCLKSEL_MASK 		(uint8_t)(0x03)
-/** Clock selected from internal RC */
-#define WDT_WDCLKSEL_RC			(uint8_t)(0x00)
-/** Clock selected from PCLK */
-#define WDT_WDCLKSEL_PCLK		(uint8_t)(0x01)
-/** Clock selected from external RTC */
-#define WDT_WDCLKSEL_RTC		(uint8_t)(0x02)
-
-/**
- * @}
- */
-
-/**
- * @}
- */
-
-
-/* Public Types --------------------------------------------------------------- */
-/** @defgroup WDT_Public_Types
- * @{
- */
-
-/** @brief Clock source option for WDT */
-typedef enum {
-	WDT_CLKSRC_IRC = 0, /*!&lt; Clock source from Internal RC oscillator */
-	WDT_CLKSRC_PCLK = 1, /*!&lt; Selects the APB peripheral clock (PCLK) */
-	WDT_CLKSRC_RTC = 2 /*!&lt; Selects the RTC oscillator */
-} WDT_CLK_OPT;
-#define PARAM_WDT_CLK_OPT(OPTION)  ((OPTION ==WDT_CLKSRC_IRC)||\
-								  (OPTION ==WDT_CLKSRC_IRC)||\
-								  (OPTION ==WDT_CLKSRC_IRC))
-/** @brief WDT operation mode */
-typedef enum {
-	WDT_MODE_INT_ONLY = 0, /*!&lt; Use WDT to generate interrupt only */
-	WDT_MODE_RESET = 1    /*!&lt; Use WDT to generate interrupt and reset MCU */
-} WDT_MODE_OPT;
-#define PARAM_WDT_MODE_OPT(OPTION)  ((OPTION ==WDT_MODE_INT_ONLY)||\
-								  (OPTION ==WDT_MODE_RESET))
-
-/**
- * @}
- */
-
-
-/* Public Functions ----------------------------------------------------------- */
-/** @defgroup WDT_Public_Functions
- * @{
- */
-
-void WDT_Init (uint32_t ClkSrc, uint32_t WDTMode);
-void WDT_Start(uint32_t TimeOut);
-void WDT_Feed (void);
-FlagStatus WDT_ReadTimeOutFlag (void);
-void WDT_ClrTimeOutFlag (void);
-void WDT_UpdateTimeOut ( uint32_t TimeOut);
-uint32_t WDT_GetCurrentCount(void);
-
-/**
- * @}
- */
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* LPC17XX_WDT_H_ */
-
-/**
- * @}
- */
-
-/* --------------------------------- End Of File ------------------------------ */
+/***********************************************************************//**
+ * @file	: lpc17xx_wdt.h
+ * @brief	: Contains all macro definitions and function prototypes
+ * 				support for WDT firmware library on LPC17xx
+ * @version	: 1.0
+ * @date	: 9. April. 2009
+ * @author	: HieuNguyen
+ **************************************************************************
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * products. This software is supplied &quot;AS IS&quot; without any warranties.
+ * NXP Semiconductors assumes no responsibility or liability for the
+ * use of the software, conveys no license or title under any patent,
+ * copyright, or mask work right to the product. NXP Semiconductors
+ * reserves the right to make changes in the software without
+ * notification. NXP Semiconductors also make no representation or
+ * warranty that such application will be suitable for the specified
+ * use without further testing or modification.
+ **************************************************************************/
+
+/* Peripheral group ----------------------------------------------------------- */
+/** @defgroup WDT
+ * @ingroup LPC1700CMSIS_FwLib_Drivers
+ * @{
+ */
+
+#ifndef LPC17XX_WDT_H_
+#define LPC17XX_WDT_H_
+
+/* Includes ------------------------------------------------------------------- */
+#include &quot;LPC17xx.h&quot;
+#include &quot;lpc_types.h&quot;
+
+
+#ifdef __cplusplus
+extern &quot;C&quot;
+{
+#endif
+
+
+/* Private Macros ------------------------------------------------------------- */
+/** @defgroup WDT_Private_Macros
+ * @{
+ */
+
+/** @defgroup WDT_REGISTER_BIT_DEFINITIONS
+ * @{
+ */
+/************************** WDT Control **************************/
+/** WDT interrupt enable bit */
+#define WDT_WDMOD_WDEN			    ((uint32_t)(1&lt;&lt;0))
+/** WDT interrupt enable bit */
+#define WDT_WDMOD_WDRESET			((uint32_t)(1&lt;&lt;1))
+/** WDT time out flag bit */
+#define WDT_WDMOD_WDTOF				((uint32_t)(1&lt;&lt;2))
+/** WDT Time Out flag bit */
+#define WDT_WDMOD_WDINT				((uint32_t)(1&lt;&lt;3))
+/** WDT Mode */
+#define WDT_WDMOD(n)				((uint32_t)(1&lt;&lt;1))
+
+/**************************** PRIVATE TYPES ***************************/
+/** Define divider index for microsecond ( us ) */
+#define WDT_US_INDEX	((uint32_t)(1000000))
+/** WDT Time out minimum value */
+#define WDT_TIMEOUT_MIN	((uint32_t)(0xFF))
+/** WDT Time out maximum value */
+#define WDT_TIMEOUT_MAX	((uint32_t)(0xFFFFFFFF))
+
+
+/**************************** GLOBAL/PUBLIC TYPES ***************************/
+/** Watchdog mode register mask */
+#define WDT_WDMOD_MASK			(uint8_t)(0x02)
+/** Watchdog timer constant register mask */
+#define WDT_WDTC_MASK			(uint8_t)(0xFFFFFFFF)
+/** Watchdog feed sequence register mask */
+#define WDT_WDFEED_MASK 		(uint8_t)(0x000000FF)
+/** Watchdog timer value register mask */
+#define WDT_WDCLKSEL_MASK 		(uint8_t)(0x03)
+/** Clock selected from internal RC */
+#define WDT_WDCLKSEL_RC			(uint8_t)(0x00)
+/** Clock selected from PCLK */
+#define WDT_WDCLKSEL_PCLK		(uint8_t)(0x01)
+/** Clock selected from external RTC */
+#define WDT_WDCLKSEL_RTC		(uint8_t)(0x02)
+
+/**
+ * @}
+ */
+
+/**
+ * @}
+ */
+
+
+/* Public Types --------------------------------------------------------------- */
+/** @defgroup WDT_Public_Types
+ * @{
+ */
+
+/** @brief Clock source option for WDT */
+typedef enum {
+	WDT_CLKSRC_IRC = 0, /*!&lt; Clock source from Internal RC oscillator */
+	WDT_CLKSRC_PCLK = 1, /*!&lt; Selects the APB peripheral clock (PCLK) */
+	WDT_CLKSRC_RTC = 2 /*!&lt; Selects the RTC oscillator */
+} WDT_CLK_OPT;
+#define PARAM_WDT_CLK_OPT(OPTION)  ((OPTION ==WDT_CLKSRC_IRC)||(OPTION ==WDT_CLKSRC_IRC)\
+||(OPTION ==WDT_CLKSRC_IRC))
+/** @brief WDT operation mode */
+typedef enum {
+	WDT_MODE_INT_ONLY = 0, /*!&lt; Use WDT to generate interrupt only */
+	WDT_MODE_RESET = 1    /*!&lt; Use WDT to generate interrupt and reset MCU */
+} WDT_MODE_OPT;
+#define PARAM_WDT_MODE_OPT(OPTION)  ((OPTION ==WDT_MODE_INT_ONLY)||(OPTION ==WDT_MODE_RESET))
+
+/**
+ * @}
+ */
+
+
+/* Public Functions ----------------------------------------------------------- */
+/** @defgroup WDT_Public_Functions
+ * @{
+ */
+
+void WDT_Init (uint32_t ClkSrc, uint32_t WDTMode);
+void WDT_Start(uint32_t TimeOut);
+void WDT_Feed (void);
+FlagStatus WDT_ReadTimeOutFlag (void);
+void WDT_ClrTimeOutFlag (void);
+void WDT_UpdateTimeOut ( uint32_t TimeOut);
+uint32_t WDT_GetCurrentCount(void);
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LPC17XX_WDT_H_ */
+
+/**
+ * @}
+ */
+
+/* --------------------------------- End Of File ------------------------------ */


Property changes on: trunk/src/platform/lpc17xx/drivers/inc/lpc17xx_wdt.h
___________________________________________________________________
Deleted: svn:executable
   - *

Modified: trunk/src/platform/lpc17xx/drivers/inc/lpc_types.h
===================================================================
--- trunk/src/platform/lpc17xx/drivers/inc/lpc_types.h	2010-06-28 21:53:59 UTC (rev 759)
+++ trunk/src/platform/lpc17xx/drivers/inc/lpc_types.h	2010-07-12 20:56:54 UTC (rev 760)
@@ -1,210 +1,197 @@
-/***********************************************************************//**
- * @file	: lpc_types.h
- * @brief	: 
- *     Contains the NXP ABL typedefs for C standard types.
- *     It is intended to be used in ISO C conforming development
- *     environments and checks for this insofar as it is possible
- *     to do so.
- *     lpc_types.h ensures that the name used to define types correctly
- *     identifies a representation size, and by direct inference the
- *     storage size, in bits. E.g., UNS_32 identifies an unsigned
- *     integer type stored in 32 bits.
- *     It requires that the basic storage unit (char) be stored in
- *     8 bits.
- *     No assumptions about Endianess are made or implied.
- *     lpc_types.h also contains NXP ABL Global Macros:
- *         _BIT
- *         _SBF
- *         _BITMAP
- *     These #defines are not strictly types, but rather Preprocessor
- *     Macros that have been found to be generally useful.
- * @version	: 1.0
- * @date	: 27 Jul. 2008
- * @author	: wellsk
- **************************************************************************
- * Software that is described herein is for illustrative purposes only
- * which provides customers with programming information regarding the
- * products. This software is supplied &quot;AS IS&quot; without any warranties.
- * NXP Semiconductors assumes no responsibility or liability for the
- * use of the software, conveys no license or title under any patent,
- * copyright, or mask work right to the product. NXP Semiconductors
- * reserves the right to make changes in the software without
- * notification. NXP Semiconductors also make no representation or
- * warranty that such application will be suitable for the specified
- * use without further testing or modification.
- **************************************************************************/
- 
-/* Type group ----------------------------------------------------------- */
-/** @defgroup LPC_Types
- * @ingroup LPC1700CMSIS_FwLib_Drivers
- * @{
- */
-
-#ifndef LPC_TYPES_H
-#define LPC_TYPES_H
-
-/* Includes ------------------------------------------------------------------- */
-#include &lt;stdint.h&gt;
-
-
-/* Public Types --------------------------------------------------------------- */
-/** @defgroup LPC_Types_Public_Types
- * @{
- */
-
-/**
- * @brief Boolean Type definition
- */
-typedef enum {FALSE = 0, TRUE = !FALSE} Bool;
-
-/**
- * @brief Flag Status and Interrupt Flag Status type definition
- */
-typedef enum {RESET = 0, SET = !RESET} FlagStatus, IntStatus, SetState;
-#define PARAM_SETSTATE(State) ((State==RESET) || (State==SET))
-
-/**
- * @brief Functional State Definition
- */
-typedef enum {DISABLE = 0, ENABLE = !DISABLE} FunctionalState;
-#define PARAM_FUNCTIONALSTATE(State) ((State==DISABLE) || (State==ENABLE))
-
-/**
- * @ Status type definition
- */
-typedef enum {ERROR = 0, SUCCESS = !ERROR} Status;
-
-
-/**
- * Read/Write transfer type mode (Block or non-block)
- */
-typedef enum
-{
-	NONE_BLOCKING = 0,		/**&lt; None Blocking type */
-	BLOCKING,				/**&lt; Blocking type */
-} TRANSFER_BLOCK_Type;
-
-
-/** Pointer to Function returning Void (any number of parameters) */
-typedef void (*PFV)();
-
-/** Pointer to Function returning int32_t (any number of parameters) */
-typedef int32_t(*PFI)();
-
-/**
- * @}
- */
-
-
-/* Public Macros -------------------------------------------------------------- */
-/** @defgroup LPC_Types_Public_Macros
- * @{
- */
-
-/* _BIT(n) sets the bit at position &quot;n&quot;
- * _BIT(n) is intended to be used in &quot;OR&quot; and &quot;AND&quot; expressions:
- * e.g., &quot;(_BIT(3) | _BIT(7))&quot;.
- */
-#undef _BIT
-/* Set bit macro */
-#define _BIT(n)	(1&lt;&lt;n)
-
-/* _SBF(f,v) sets the bit field starting at position &quot;f&quot; to value &quot;v&quot;.
- * _SBF(f,v) is intended to be used in &quot;OR&quot; and &quot;AND&quot; expressions:
- * e.g., &quot;((_SBF(5,7) | _SBF(12,0xF)) &amp; 0xFFFF)&quot;
- */
-#undef _SBF
-/* Set bit field macro */
-#define _SBF(f,v) (v&lt;&lt;f)
-
-/* _BITMASK constructs a symbol with 'field_width' least significant
- * bits set.
- * e.g., _BITMASK(5) constructs '0x1F', _BITMASK(16) == 0xFFFF
- * The symbol is intended to be used to limit the bit field width
- * thusly:
- * &lt;a_register&gt; = (any_expression) &amp; _BITMASK(x), where 0 &lt; x &lt;= 32.
- * If &quot;any_expression&quot; results in a value that is larger than can be
- * contained in 'x' bits, the bits above 'x - 1' are masked off.  When
- * used with the _SBF example above, the example would be written:
- * a_reg = ((_SBF(5,7) | _SBF(12,0xF)) &amp; _BITMASK(16))
- * This ensures that the value written to a_reg is no wider than
- * 16 bits, and makes the code easier to read and understand.
- */
-#undef _BITMASK
-/* Bitmask creation macro */
-#define _BITMASK(field_width) ( _BIT(field_width) - 1)
-
-/* NULL pointer */
-#ifndef NULL
-#define NULL ((void*) 0)
-#endif
-
-/* Number of elements in an array */
-#define NELEMENTS(array)  (sizeof (array) / sizeof (array[0]))
-
-/* Static data/function define */
-#define STATIC static
-/* External data/function define */
-#define EXTERN extern
-
-#define MAX(a, b) (((a) &gt; (b)) ? (a) : (b))
-#define MIN(a, b) (((a) &lt; (b)) ? (a) : (b))
-
-/**
- * @}
- */
-
-
-/* Old Type Definition compatibility ------------------------------------------ */
-/** @addtogroup LPC_Types_Public_Types
- * @{
- */
-
-/** SMA type for character type */
-typedef char CHAR;
-
-/** SMA type for 8 bit unsigned value */
-typedef uint8_t UNS_8;
-
-/** SMA type for 8 bit signed value */
-typedef int8_t INT_8;
-
-/** SMA type for 16 bit unsigned value */
-typedef	uint16_t UNS_16;
-
-/** SMA type for 16 bit signed value */
-typedef	int16_t INT_16;
-
-/** SMA type for 32 bit unsigned value */
-typedef	uint32_t UNS_32;
-
-/** SMA type for 32 bit signed value */
-typedef	int32_t INT_32;
-
-/** SMA type for 64 bit signed value */
-typedef int64_t INT_64;
-
-/** SMA type for 64 bit unsigned value */
-typedef uint64_t UNS_64;
-
-/** 32 bit boolean type */
-typedef Bool BOOL_32;
-
-/** 16 bit boolean type */
-typedef Bool BOOL_16;
-
-/** 8 bit boolean type */
-typedef Bool BOOL_8;
-
-/**
- * @}
- */
-
-
-#endif /* LPC_TYPES_H */
-
-/**
- * @}
- */
-
-/* --------------------------------- End Of File ------------------------------ */
+/***********************************************************************//**
+ * @file	: lpc_types.h
+ * @brief	:
+ *     Contains the NXP ABL typedefs for C standard types.
+ *     It is intended to be used in ISO C conforming development
+ *     environments and checks for this insofar as it is possible
+ *     to do so.
+ * @version	: 1.0
+ * @date	: 27 Jul. 2008
+ * @author	: wellsk
+ **************************************************************************
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * products. This software is supplied &quot;AS IS&quot; without any warranties.
+ * NXP Semiconductors assumes no responsibility or liability for the
+ * use of the software, conveys no license or title under any patent,
+ * copyright, or mask work right to the product. NXP Semiconductors
+ * reserves the right to make changes in the software without
+ * notification. NXP Semiconductors also make no representation or
+ * warranty that such application will be suitable for the specified
+ * use without further testing or modification.
+ **************************************************************************/
+
+/* Type group ----------------------------------------------------------- */
+/** @defgroup LPC_Types
+ * @ingroup LPC1700CMSIS_FwLib_Drivers
+ * @{
+ */
+
+#ifndef LPC_TYPES_H
+#define LPC_TYPES_H
+
+/* Includes ------------------------------------------------------------------- */
+#include &lt;stdint.h&gt;
+
+
+/* Public Types --------------------------------------------------------------- */
+/** @defgroup LPC_Types_Public_Types
+ * @{
+ */
+
+/**
+ * @brief Boolean Type definition
+ */
+typedef enum {FALSE = 0, TRUE = !FALSE} Bool;
+
+/**
+ * @brief Flag Status and Interrupt Flag Status type definition
+ */
+typedef enum {RESET = 0, SET = !RESET} FlagStatus, IntStatus, SetState;
+#define PARAM_SETSTATE(State) ((State==RESET) || (State==SET))
+
+/**
+ * @brief Functional State Definition
+ */
+typedef enum {DISABLE = 0, ENABLE = !DISABLE} FunctionalState;
+#define PARAM_FUNCTIONALSTATE(State) ((State==DISABLE) || (State==ENABLE))
+
+/**
+ * @ Status type definition
+ */
+typedef enum {ERROR = 0, SUCCESS = !ERROR} Status;
+
+
+/**
+ * Read/Write transfer type mode (Block or non-block)
+ */
+typedef enum
+{
+	NONE_BLOCKING = 0,		/**&lt; None Blocking type */
+	BLOCKING,				/**&lt; Blocking type */
+} TRANSFER_BLOCK_Type;
+
+
+/** Pointer to Function returning Void (any number of parameters) */
+typedef void (*PFV)();
+
+/** Pointer to Function returning int32_t (any number of parameters) */
+typedef int32_t(*PFI)();
+
+/**
+ * @}
+ */
+
+
+/* Public Macros -------------------------------------------------------------- */
+/** @defgroup LPC_Types_Public_Macros
+ * @{
+ */
+
+/* _BIT(n) sets the bit at position &quot;n&quot;
+ * _BIT(n) is intended to be used in &quot;OR&quot; and &quot;AND&quot; expressions:
+ * e.g., &quot;(_BIT(3) | _BIT(7))&quot;.
+ */
+#undef _BIT
+/* Set bit macro */
+#define _BIT(n)	(1&lt;&lt;n)
+
+/* _SBF(f,v) sets the bit field starting at position &quot;f&quot; to value &quot;v&quot;.
+ * _SBF(f,v) is intended to be used in &quot;OR&quot; and &quot;AND&quot; expressions:
+ * e.g., &quot;((_SBF(5,7) | _SBF(12,0xF)) &amp; 0xFFFF)&quot;
+ */
+#undef _SBF
+/* Set bit field macro */
+#define _SBF(f,v) (v&lt;&lt;f)
+
+/* _BITMASK constructs a symbol with 'field_width' least significant
+ * bits set.
+ * e.g., _BITMASK(5) constructs '0x1F', _BITMASK(16) == 0xFFFF
+ * The symbol is intended to be used to limit the bit field width
+ * thusly:
+ * &lt;a_register&gt; = (any_expression) &amp; _BITMASK(x), where 0 &lt; x &lt;= 32.
+ * If &quot;any_expression&quot; results in a value that is larger than can be
+ * contained in 'x' bits, the bits above 'x - 1' are masked off.  When
+ * used with the _SBF example above, the example would be written:
+ * a_reg = ((_SBF(5,7) | _SBF(12,0xF)) &amp; _BITMASK(16))
+ * This ensures that the value written to a_reg is no wider than
+ * 16 bits, and makes the code easier to read and understand.
+ */
+#undef _BITMASK
+/* Bitmask creation macro */
+#define _BITMASK(field_width) ( _BIT(field_width) - 1)
+
+/* NULL pointer */
+#ifndef NULL
+#define NULL ((void*) 0)
+#endif
+
+/* Number of elements in an array */
+#define NELEMENTS(array)  (sizeof (array) / sizeof (array[0]))
+
+/* Static data/function define */
+#define STATIC static
+/* External data/function define */
+#define EXTERN extern
+
+#define MAX(a, b) (((a) &gt; (b)) ? (a) : (b))
+#define MIN(a, b) (((a) &lt; (b)) ? (a) : (b))
+
+/**
+ * @}
+ */
+
+
+/* Old Type Definition compatibility ------------------------------------------ */
+/** @addtogroup LPC_Types_Public_Types
+ * @{
+ */
+
+/** SMA type for character type */
+typedef char CHAR;
+
+/** SMA type for 8 bit unsigned value */
+typedef uint8_t UNS_8;
+
+/** SMA type for 8 bit signed value */
+typedef int8_t INT_8;
+
+/** SMA type for 16 bit unsigned value */
+typedef	uint16_t UNS_16;
+
+/** SMA type for 16 bit signed value */
+typedef	int16_t INT_16;
+
+/** SMA type for 32 bit unsigned value */
+typedef	uint32_t UNS_32;
+
+/** SMA type for 32 bit signed value */
+typedef	int32_t INT_32;
+
+/** SMA type for 64 bit signed value */
+typedef int64_t INT_64;
+
+/** SMA type for 64 bit unsigned value */
+typedef uint64_t UNS_64;
+
+/** 32 bit boolean type */
+typedef Bool BOOL_32;
+
+/** 16 bit boolean type */
+typedef Bool BOOL_16;
+
+/** 8 bit boolean type */
+typedef Bool BOOL_8;
+
+/**
+ * @}
+ */
+
+
+#endif /* LPC_TYPES_H */
+
+/**
+ * @}
+ */
+
+/* --------------------------------- End Of File ------------------------------ */


Property changes on: trunk/src/platform/lpc17xx/drivers/inc/lpc_types.h
___________________________________________________________________
Deleted: svn:executable
   - *

Modified: trunk/src/platform/lpc17xx/drivers/src/lpc17xx_adc.c
===================================================================
--- trunk/src/platform/lpc17xx/drivers/src/lpc17xx_adc.c	2010-06-28 21:53:59 UTC (rev 759)
+++ trunk/src/platform/lpc17xx/drivers/src/lpc17xx_adc.c	2010-07-12 20:56:54 UTC (rev 760)
@@ -1,345 +1,335 @@
-/**
- * @file	: lpc17xx_adc.c
- * @brief	: Contains all functions support for ADC firmware library on LPC17xx
- * @version	: 1.0
- * @date	: 3. April. 2009
- * @author	: NgaDinh
- *----------------------------------------------------------------------------
- * Software that is described herein is for illustrative purposes only
- * which provides customers with programming information regarding the
- * products. This software is supplied &quot;AS IS&quot; without any warranties.
- * NXP Semiconductors assumes no responsibility or liability for the
- * use of the software, conveys no license or title under any patent,
- * copyright, or mask work right to the product. NXP Semiconductors
- * reserves the right to make changes in the software without
- * notification. NXP Semiconductors also make no representation or
- * warranty that such application will be suitable for the specified
- * use without further testing or modification.
- **********************************************************************/
-
-/* Peripheral group ----------------------------------------------------------- */
-/** @addtogroup ADC
- * @{
- */
-
-/* Includes ------------------------------------------------------------------- */
-#include &quot;lpc17xx_adc.h&quot;
-#include &quot;lpc17xx_clkpwr.h&quot;
-
-/* If this source file built with example, the LPC17xx FW library configuration
- * file in each example directory (&quot;lpc17xx_libcfg.h&quot;) must be included,
- * otherwise the default FW library configuration file must be included instead
- */
-#ifdef __BUILD_WITH_EXAMPLE__
-#include &quot;lpc17xx_libcfg.h&quot;
-#else
-#include &quot;lpc17xx_libcfg_default.h&quot;
-#endif /* __BUILD_WITH_EXAMPLE__ */
-
-
-#ifdef _ADC
-
-/* Public Functions ----------------------------------------------------------- */
-/** @addtogroup ADC_Public_Functions
- * @{
- */
-
-/**
- * @brief 		Initial for ADC
- * 					- Set bit PCADC
- * 					- Set clock for ADC
- * 					- Set Clock Frequency
- *
- * @param[in]	ADCx pointer to ADC_TypeDef
- * @param[in]	ConvFreq Clock frequency
- * @return 		None
- */
-void ADC_Init(ADC_TypeDef *ADCx, uint32_t ConvFreq)
-
-{
-	uint32_t temp, tmp;
-
-	CHECK_PARAM(PARAM_ADCx(ADCx));
-	CHECK_PARAM(PARAM_ADC_FREQUENCY(ConvFreq));
-
-	// Turn on power and clock
-	CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCAD, ENABLE);
-	// Set clock divider for ADC to 4 from CCLK as default
-	// CLKPWR_SetPCLKDiv(CLKPWR_PCLKSEL_ADC,CLKPWR_PCLKSEL_CCLK_DIV_4);
-
-	ADCx-&gt;ADCR = 0;
-
-	//Enable PDN bit
-	tmp = ADC_CR_PDN;
-	// Set clock frequency
-	temp = CLKPWR_GetPCLK(CLKPWR_PCLKSEL_ADC) ;
-	temp = (temp /ConvFreq) - 1;
-	tmp |=  ADC_CR_CLKDIV(temp);
-
-	ADCx-&gt;ADCR = tmp;
-}
-
-
-/**
-* @brief 		Close ADC
-* @param[in]	ADCx pointer to ADC
-* @return 		None
-*
- *********************************************************************/
-void 		ADC_DeInit(ADC_TypeDef *ADCx)
-{
-	CHECK_PARAM(PARAM_ADCx(ADCx));
-
-	// Clear PDN bit
-	ADCx-&gt;ADCR &amp;= ~ADC_CR_PDN;
-	// Turn on power and clock
-	CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCAD, DISABLE);
-}
-
-
-/**
-* @brief 		Get Result conversion from A/D data register
-* @param[in]	channel number which want to read back the result
-* @return 		Result of conversion
- *********************************************************************/
-uint32_t ADC_GetData(uint32_t channel)
-{
-	uint32_t adc_value;
-
-	CHECK_PARAM(PARAM_ADC_CHANNEL_SELECTION(channel));
-
-	adc_value = *(uint32_t *)((&amp;ADC-&gt;ADDR0) + channel);
-	return ADC_GDR_RESULT(adc_value);
-}
-
-/**
-* @brief 		Set start mode for ADC
-* @param[in]	ADCx pointer to ADC_TypeDef
-* @param[in]	start_mode Start mode choose one of modes in
-* 							'ADC_START_OPT' enumeration type definition
-* @return 		None
- *********************************************************************/
-void ADC_StartCmd(ADC_TypeDef *ADCx, uint8_t start_mode)
-{
-	CHECK_PARAM(PARAM_ADCx(ADCx));
-	CHECK_PARAM(PARAM_ADC_START_OPT(start_mode));
-
-	ADC-&gt;ADCR &amp;= ~ADC_CR_START_MASK;
-	ADC-&gt;ADCR |=ADC_CR_START_MODE_SEL((uint32_t)start_mode);
-}
-
-
-/**
-* @brief 		ADC Burst mode setting
-*
-* @param[in]	ADCx pointer to ADC
-* @param[in]	NewState
-* 				-	1: Set Burst mode
-* 				-	0: reset Burst mode
-* @return 		None
-*
- *********************************************************************/
-void ADC_BurstCmd(ADC_TypeDef *ADCx, FunctionalState NewState)
-{
-	CHECK_PARAM(PARAM_ADCx(ADCx));
-
-	ADCx-&gt;ADCR &amp;= ~ADC_CR_BURST;
-	if (NewState){
-		ADCx-&gt;ADCR |= ADC_CR_BURST;
-	}
-
-}
-
-/**
-* @brief 		Set AD conversion in power mode
-*
-* @param[in]	ADCx pointer to ADC
-* @param[in]	NewState
-* 				-	1: AD converter is optional
-* 				-	0: AD Converter is in power down mode
-* @return 		None
-*
- *********************************************************************/
-void ADC_PowerdownCmd(ADC_TypeDef *ADCx, FunctionalState NewState)
-{
-	CHECK_PARAM(PARAM_ADCx(ADCx));
-
-	ADCx-&gt;ADCR &amp;= ~ADC_CR_PDN;
-	if (NewState){
-		ADCx-&gt;ADCR |= ADC_CR_PDN;
-	}
-}
-
-/**
-* @brief 		Set Edge start configuration
-*
-* @param[in]	ADCx pointer to ADC
-* @param[in]	EdgeOption is ADC_START_ON_RISING and ADC_START_ON_FALLING
-* 					0:ADC_START_ON_RISING
-* 					1:ADC_START_ON_FALLING
-*
-* @return 		None
-*
- *********************************************************************/
-void ADC_EdgeStartConfig(ADC_TypeDef *ADCx, uint8_t EdgeOption)
-{
-	CHECK_PARAM(PARAM_ADCx(ADCx));
-	CHECK_PARAM(PARAM_ADC_START_ON_EDGE_OPT(EdgeOption));
-
-	ADCx-&gt;ADCR &amp;= ~ADC_CR_EDGE;
-	if (EdgeOption){
-		ADCx-&gt;ADCR |= ADC_CR_EDGE;
-	}
-}
-
-/**
-* @brief 		ADC interrupt configuration
-* @param[in]	ADCx pointer to ADC
-* @param[in]	IntType
-* @param[in]	NewState:
-* 					- SET : enable ADC interrupt
-* 					- RESET: disable ADC interrupt
-*
-* @return 		None
-*
- *********************************************************************/
-void ADC_IntConfig (ADC_TypeDef *ADCx, ADC_TYPE_INT_OPT IntType, FunctionalState NewState)
-{
-	CHECK_PARAM(PARAM_ADCx(ADCx));
-	CHECK_PARAM(PARAM_ADC_TYPE_INT_OPT(IntType));
-
-	ADCx-&gt;ADINTEN &amp;= ~ADC_INTEN_CH(IntType);
-	if (NewState){
-		ADCx-&gt;ADINTEN |= ADC_INTEN_CH(IntType);
-	}
-}
-
-/**
-* @brief 		Enable/Disable ADC channel number
-* @param[in]	ADCx pointer to ADC
-* @param[in]	Channel channel number
-* @param[in]	NewState Enable or Disable
-*
-* @return 		None
-*
- *********************************************************************/
-void ADC_ChannelCmd (ADC_TypeDef *ADCx, uint8_t Channel, FunctionalState NewState)
-{
-	CHECK_PARAM(PARAM_ADCx(ADCx));
-	CHECK_PARAM(PARAM_ADC_CHANNEL_SELECTION(Channel));
-
-	if (NewState == ENABLE) {
-		ADCx-&gt;ADCR |= ADC_CR_CH_SEL(Channel);
-	} else {
-		ADCx-&gt;ADCR &amp;= ~ADC_CR_CH_SEL(Channel);
-	}
-}
-
-/**
-* @brief 		Get ADC result
-* @param[in]	ADCx pointer to ADC
-* @param[in]	channel channel number
-* @return 		Data conversion
-*
- *********************************************************************/
-uint16_t ADC_ChannelGetData(ADC_TypeDef *ADCx, uint8_t channel)
-{
-	uint32_t adc_value;
-
-	CHECK_PARAM(PARAM_ADCx(ADCx));
-	CHECK_PARAM(PARAM_ADC_CHANNEL_SELECTION(channel));
-
-	adc_value = *(uint32_t *) ((&amp;ADCx-&gt;ADDR0) + channel);
-	return ADC_DR_RESULT(adc_value);
-}
-
-/**
-* @brief 		Get ADC Chanel status from ADC data register
-* @param[in]	ADCx pointer to ADC
-* @param[in]	channel channel number
-* @param[in]  	StatusType
-*              		 	0:Burst status
-*               		1:Done 	status
-* @return 		SET / RESET
-*
- *********************************************************************/
-FlagStatus ADC_ChannelGetStatus(ADC_TypeDef *ADCx, uint8_t channel, uint32_t StatusType)
-{
-	uint32_t temp;
-
-	CHECK_PARAM(PARAM_ADCx(ADCx));
-	CHECK_PARAM(PARAM_ADC_CHANNEL_SELECTION(channel));
-	CHECK_PARAM(PARAM_ADC_DATA_STATUS(StatusType));
-
-	temp =  *(uint32_t *) ((&amp;ADCx-&gt;ADDR0) + channel);
-	if (StatusType) {
-		temp &amp;= ADC_DR_DONE_FLAG;
-	}else{
-		temp &amp;= ADC_DR_OVERRUN_FLAG;
-	}
-	if (temp) {
-		return SET;
-	} else {
-		return RESET;
-	}
-
-}
-
-/**
-* @brief 		Get ADC Data from AD Global register
-* @param[in]	ADCx pointer to ADC
-* @param[in]	channel channel number
-* @return 		Result of conversion
-*
- *********************************************************************/
-uint16_t ADC_GlobalGetData(ADC_TypeDef *ADCx, uint8_t channel)
-{
-	CHECK_PARAM(PARAM_ADCx(ADCx));
-	CHECK_PARAM(PARAM_ADC_CHANNEL_SELECTION(channel));
-
-	//ADCx-&gt;ADGDR &amp;= ~ADC_GDR_CH_MASK;
-	//ADCx-&gt;ADGDR |= ADC_GDR_CH(channel);
-	return (uint16_t)(ADC_GDR_RESULT(ADCx-&gt;ADGDR));
-}
-
-/**
-* @brief 		Get ADC Chanel status from AD global data register
-* @param[in]	ADCx pointer to ADC
-* @param[in]  	StatusType
-*              		 	0:Burst status
-*               		1:Done 	status
-* @return 		SET / RESET
-*
- *********************************************************************/
-FlagStatus	ADC_GlobalGetStatus(ADC_TypeDef *ADCx, uint32_t StatusType)
-{
-	uint32_t temp;
-
-	CHECK_PARAM(PARAM_ADCx(ADCx));
-	CHECK_PARAM(PARAM_ADC_DATA_STATUS(StatusType));
-
-	temp =  ADCx-&gt;ADGDR;
-	if (StatusType){
-		temp &amp;= ADC_DR_DONE_FLAG;
-	}else{
-		temp &amp;= ADC_DR_OVERRUN_FLAG;
-	}
-	if (temp){
-		return SET;
-	}else{
-		return RESET;
-	}
-}
-
-/**
- * @}
- */
-
-#endif /* _ADC */
-
-/**
- * @}
- */
-
-/* --------------------------------- End Of File ------------------------------ */
-
+/**
+ * @file	: lpc17xx_adc.c
+ * @brief	: Contains all functions support for ADC firmware library on LPC17xx
+ * @version	: 1.0
+ * @date	: 3. April. 2009
+ * @author	: NgaDinh
+ **************************************************************************
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * products. This software is supplied &quot;AS IS&quot; without any warranties.
+ * NXP Semiconductors assumes no responsibility or liability for the
+ * use of the software, conveys no license or title under any patent,
+ * copyright, or mask work right to the product. NXP Semiconductors
+ * reserves the right to make changes in the software without
+ * notification. NXP Semiconductors also make no representation or
+ * warranty that such application will be suitable for the specified
+ * use without further testing or modification.
+ **********************************************************************/
+
+/* Peripheral group ----------------------------------------------------------- */
+/** @addtogroup ADC
+ * @{
+ */
+
+/* Includes ------------------------------------------------------------------- */
+#include &quot;lpc17xx_adc.h&quot;
+#include &quot;lpc17xx_clkpwr.h&quot;
+
+/* If this source file built with example, the LPC17xx FW library configuration
+ * file in each example directory (&quot;lpc17xx_libcfg.h&quot;) must be included,
+ * otherwise the default FW library configuration file must be included instead
+ */
+#ifdef __BUILD_WITH_EXAMPLE__
+#include &quot;lpc17xx_libcfg.h&quot;
+#else
+#include &quot;lpc17xx_libcfg_default.h&quot;
+#endif /* __BUILD_WITH_EXAMPLE__ */
+
+
+#ifdef _ADC
+
+/* Public Functions ----------------------------------------------------------- */
+/** @addtogroup ADC_Public_Functions
+ * @{
+ */
+
+/*********************************************************************//**
+ * @brief 		Initial for ADC
+ * 					- Set bit PCADC
+ * 					- Set clock for ADC
+ * 					- Set Clock Frequency
+ *
+ * @param[in]	ADCx pointer to LPC_ADC_TypeDef
+ * @param[in]	ConvFreq Clock frequency
+ * @return 		None
+ **********************************************************************/
+void ADC_Init(LPC_ADC_TypeDef *ADCx, uint32_t ConvFreq)
+
+{
+	uint32_t temp, tmp;
+
+	CHECK_PARAM(PARAM_ADCx(ADCx));
+	CHECK_PARAM(PARAM_ADC_FREQUENCY(ConvFreq));
+
+	// Turn on power and clock
+	CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCAD, ENABLE);
+	// Set clock divider for ADC to 4 from CCLK as default
+	// CLKPWR_SetPCLKDiv(CLKPWR_PCLKSEL_ADC,CLKPWR_PCLKSEL_CCLK_DIV_4);
+
+	ADCx-&gt;ADCR = 0;
+
+	//Enable PDN bit
+	tmp = ADC_CR_PDN;
+	// Set clock frequency
+	temp = CLKPWR_GetPCLK(CLKPWR_PCLKSEL_ADC) ;
+	temp = (temp /ConvFreq) - 1;
+	tmp |=  ADC_CR_CLKDIV(temp);
+
+	ADCx-&gt;ADCR = tmp;
+}
+
+
+/*********************************************************************//**
+* @brief 		Close ADC
+* @param[in]	ADCx pointer to ADC
+* @return 		None
+**********************************************************************/
+void 		ADC_DeInit(LPC_ADC_TypeDef *ADCx)
+{
+	CHECK_PARAM(PARAM_ADCx(ADCx));
+
+	// Clear PDN bit
+	ADCx-&gt;ADCR &amp;= ~ADC_CR_PDN;
+	// Turn on power and clock
+	CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCAD, DISABLE);
+}
+
+
+/*********************************************************************//**
+* @brief 		Get Result conversion from A/D data register
+* @param[in]	channel number which want to read back the result
+* @return 		Result of conversion
+*********************************************************************/
+uint32_t ADC_GetData(uint32_t channel)
+{
+	uint32_t adc_value;
+
+	CHECK_PARAM(PARAM_ADC_CHANNEL_SELECTION(channel));
+
+	adc_value = *(uint32_t *)((&amp;LPC_ADC-&gt;ADDR0) + channel);
+	return ADC_GDR_RESULT(adc_value);
+}
+
+/*********************************************************************//**
+* @brief 		Set start mode for ADC
+* @param[in]	ADCx pointer to LPC_ADC_TypeDef
+* @param[in]	start_mode Start mode choose one of modes in
+* 							'ADC_START_OPT' enumeration type definition
+* @return 		None
+*********************************************************************/
+void ADC_StartCmd(LPC_ADC_TypeDef *ADCx, uint8_t start_mode)
+{
+	CHECK_PARAM(PARAM_ADCx(ADCx));
+	CHECK_PARAM(PARAM_ADC_START_OPT(start_mode));
+
+	ADCx-&gt;ADCR &amp;= ~ADC_CR_START_MASK;
+	ADCx-&gt;ADCR |=ADC_CR_START_MODE_SEL((uint32_t)start_mode);
+}
+
+
+/*********************************************************************//**
+* @brief 		ADC Burst mode setting
+*
+* @param[in]	ADCx pointer to ADC
+* @param[in]	NewState
+* 				-	1: Set Burst mode
+* 				-	0: reset Burst mode
+* @return 		None
+**********************************************************************/
+void ADC_BurstCmd(LPC_ADC_TypeDef *ADCx, FunctionalState NewState)
+{
+	CHECK_PARAM(PARAM_ADCx(ADCx));
+
+	ADCx-&gt;ADCR &amp;= ~ADC_CR_BURST;
+	if (NewState){
+		ADCx-&gt;ADCR |= ADC_CR_BURST;
+	}
+
+}
+
+/*********************************************************************//**
+* @brief 		Set AD conversion in power mode
+*
+* @param[in]	ADCx pointer to ADC
+* @param[in]	NewState
+* 				-	1: AD converter is optional
+* 				-	0: AD Converter is in power down mode
+* @return 		None
+**********************************************************************/
+void ADC_PowerdownCmd(LPC_ADC_TypeDef *ADCx, FunctionalState NewState)
+{
+	CHECK_PARAM(PARAM_ADCx(ADCx));
+
+	ADCx-&gt;ADCR &amp;= ~ADC_CR_PDN;
+	if (NewState){
+		ADCx-&gt;ADCR |= ADC_CR_PDN;
+	}
+}
+
+/*********************************************************************//**
+* @brief 		Set Edge start configuration
+*
+* @param[in]	ADCx pointer to ADC
+* @param[in]	EdgeOption is ADC_START_ON_RISING and ADC_START_ON_FALLING
+* 					0:ADC_START_ON_RISING
+* 					1:ADC_START_ON_FALLING
+*
+* @return 		None
+**********************************************************************/
+void ADC_EdgeStartConfig(LPC_ADC_TypeDef *ADCx, uint8_t EdgeOption)
+{
+	CHECK_PARAM(PARAM_ADCx(ADCx));
+	CHECK_PARAM(PARAM_ADC_START_ON_EDGE_OPT(EdgeOption));
+
+	ADCx-&gt;ADCR &amp;= ~ADC_CR_EDGE;
+	if (EdgeOption){
+		ADCx-&gt;ADCR |= ADC_CR_EDGE;
+	}
+}
+
+/*********************************************************************//**
+* @brief 		ADC interrupt configuration
+* @param[in]	ADCx pointer to ADC
+* @param[in]	IntType
+* @param[in]	NewState:
+* 					- SET : enable ADC interrupt
+* 					- RESET: disable ADC interrupt
+*
+* @return 		None
+**********************************************************************/
+void ADC_IntConfig (LPC_ADC_TypeDef *ADCx, ADC_TYPE_INT_OPT IntType, FunctionalState NewState)
+{
+	CHECK_PARAM(PARAM_ADCx(ADCx));
+	CHECK_PARAM(PARAM_ADC_TYPE_INT_OPT(IntType));
+
+	ADCx-&gt;ADINTEN &amp;= ~ADC_INTEN_CH(IntType);
+	if (NewState){
+		ADCx-&gt;ADINTEN |= ADC_INTEN_CH(IntType);
+	}
+}
+
+/*********************************************************************//**
+* @brief 		Enable/Disable ADC channel number
+* @param[in]	ADCx pointer to ADC
+* @param[in]	Channel channel number
+* @param[in]	NewState Enable or Disable
+*
+* @return 		None
+**********************************************************************/
+void ADC_ChannelCmd (LPC_ADC_TypeDef *ADCx, uint8_t Channel, FunctionalState NewState)
+{
+	CHECK_PARAM(PARAM_ADCx(ADCx));
+	CHECK_PARAM(PARAM_ADC_CHANNEL_SELECTION(Channel));
+
+	if (NewState == ENABLE) {
+		ADCx-&gt;ADCR |= ADC_CR_CH_SEL(Channel);
+	} else {
+		ADCx-&gt;ADCR &amp;= ~ADC_CR_CH_SEL(Channel);
+	}
+}
+
+/*********************************************************************//**
+* @brief 		Get ADC result
+* @param[in]	ADCx pointer to ADC
+* @param[in]	channel channel number
+* @return 		Data conversion
+**********************************************************************/
+uint16_t ADC_ChannelGetData(LPC_ADC_TypeDef *ADCx, uint8_t channel)
+{
+	uint32_t adc_value;
+
+	CHECK_PARAM(PARAM_ADCx(ADCx));
+	CHECK_PARAM(PARAM_ADC_CHANNEL_SELECTION(channel));
+
+	adc_value = *(uint32_t *) ((&amp;ADCx-&gt;ADDR0) + channel);
+	return ADC_DR_RESULT(adc_value);
+}
+
+/*********************************************************************//**
+* @brief 		Get ADC Chanel status from ADC data register
+* @param[in]	ADCx pointer to ADC
+* @param[in]	channel channel number
+* @param[in]  	StatusType
+*              		 	0:Burst status
+*               		1:Done 	status
+* @return 		SET / RESET
+**********************************************************************/
+FlagStatus ADC_ChannelGetStatus(LPC_ADC_TypeDef *ADCx, uint8_t channel, uint32_t StatusType)
+{
+	uint32_t temp;
+
+	CHECK_PARAM(PARAM_ADCx(ADCx));
+	CHECK_PARAM(PARAM_ADC_CHANNEL_SELECTION(channel));
+	CHECK_PARAM(PARAM_ADC_DATA_STATUS(StatusType));
+
+	temp =  *(uint32_t *) ((&amp;ADCx-&gt;ADDR0) + channel);
+	if (StatusType) {
+		temp &amp;= ADC_DR_DONE_FLAG;
+	}else{
+		temp &amp;= ADC_DR_OVERRUN_FLAG;
+	}
+	if (temp) {
+		return SET;
+	} else {
+		return RESET;
+	}
+
+}
+
+/*********************************************************************//**
+* @brief 		Get ADC Data from AD Global register
+* @param[in]	ADCx pointer to ADC
+* @param[in]	channel channel number
+* @return 		Result of conversion
+**********************************************************************/
+uint16_t ADC_GlobalGetData(LPC_ADC_TypeDef *ADCx, uint8_t channel)
+{
+	CHECK_PARAM(PARAM_ADCx(ADCx));
+	CHECK_PARAM(PARAM_ADC_CHANNEL_SELECTION(channel));
+
+	//ADCx-&gt;ADGDR &amp;= ~ADC_GDR_CH_MASK;
+	//ADCx-&gt;ADGDR |= ADC_GDR_CH(channel);
+	return (uint16_t)(ADC_GDR_RESULT(ADCx-&gt;ADGDR));
+}
+
+/*********************************************************************//**
+* @brief 		Get ADC Chanel status from AD global data register
+* @param[in]	ADCx pointer to ADC
+* @param[in]  	StatusType
+*              		 	0:Burst status
+*               		1:Done 	status
+* @return 		SET / RESET
+**********************************************************************/
+FlagStatus	ADC_GlobalGetStatus(LPC_ADC_TypeDef *ADCx, uint32_t StatusType)
+{
+	uint32_t temp;
+
+	CHECK_PARAM(PARAM_ADCx(ADCx));
+	CHECK_PARAM(PARAM_ADC_DATA_STATUS(StatusType));
+
+	temp =  ADCx-&gt;ADGDR;
+	if (StatusType){
+		temp &amp;= ADC_DR_DONE_FLAG;
+	}else{
+		temp &amp;= ADC_DR_OVERRUN_FLAG;
+	}
+	if (temp){
+		return SET;
+	}else{
+		return RESET;
+	}
+}
+
+/**
+ * @}
+ */
+
+#endif /* _ADC */
+
+/**
+ * @}
+ */
+
+/* --------------------------------- End Of File ------------------------------ */
+


Property changes on: trunk/src/platform/lpc17xx/drivers/src/lpc17xx_adc.c
___________________________________________________________________
Deleted: svn:executable
   - *

Modified: trunk/src/platform/lpc17xx/drivers/src/lpc17xx_can.c
===================================================================
--- trunk/src/platform/lpc17xx/drivers/src/lpc17xx_can.c	2010-06-28 21:53:59 UTC (rev 759)
+++ trunk/src/platform/lpc17xx/drivers/src/lpc17xx_can.c	2010-07-12 20:56:54 UTC (rev 760)
@@ -1,1920 +1,1919 @@
-/**
- * @file	: lpc17xx_can.c
- * @brief	: Contains all functions support for CAN firmware library on LPC17xx
- * @version	: 1.0
- * @date	: 1.June.2009
- * @author	: NguyenCao
- *----------------------------------------------------------------------------
- * Software that is described herein is for illustrative purposes only
- * which provides customers with programming information regarding the
- * products. This software is supplied &quot;AS IS&quot; without any warranties.
- * NXP Semiconductors assumes no responsibility or liability for the
- * use of the software, conveys no license or title under any patent,
- * copyright, or mask work right to the product. NXP Semiconductors
- * reserves the right to make changes in the software without
- * notification. NXP Semiconductors also make no representation or
- * warranty that such application will be suitable for the specified
- * use without further testing or modification.
- **********************************************************************/
-
-/* Peripheral group ----------------------------------------------------------- */
-/** @addtogroup CAN
- * @{
- */
-
-/* Includes ------------------------------------------------------------------- */
-#include &quot;lpc17xx_can.h&quot;
-#include &quot;lpc17xx_clkpwr.h&quot;
-
-/* If this source file built with example, the LPC17xx FW library configuration
- * file in each example directory (&quot;lpc17xx_libcfg.h&quot;) must be included,
- * otherwise the default FW library configuration file must be included instead
- */
-#ifdef __BUILD_WITH_EXAMPLE__
-#include &quot;lpc17xx_libcfg.h&quot;
-#else
-#include &quot;lpc17xx_libcfg_default.h&quot;
-#endif /* __BUILD_WITH_EXAMPLE__ */
-
-
-#ifdef _CAN
-
-/* Private Variables ---------------------------------------------------------- */
-/** @defgroup CAN_Private_Variables
- * @{
- */
-
-FunctionalState FULLCAN_ENABLE;
-
-//use for debugging
-CAN_TypeDef *CAN1x = CAN1;
-CAN_TypeDef *CAN2x = CAN2;
-CANAF_RAM_TypeDef *CANAFRAMx = CANAF_RAM;
-CANAF_TypeDef *CANAFx = CANAF;
-
-/* Values of bit time register for different baudrates
-   NT = Nominal bit time = TSEG1 + TSEG2 + 3
-   SP = Sample point     = ((TSEG2 +1) / (TSEG1 + TSEG2 + 3)) * 100%
-                                            SAM,  SJW, TSEG1, TSEG2, NT,  SP */
-const uint32_t CAN_BIT_TIME[] = {       0, /*             not used             */
-                                      0, /*             not used             */
-                                      0, /*             not used             */
-                                      0, /*             not used             */
-                             0x0001C000, /* 0+1,  3+1,   1+1,   0+1,  4, 75% */
-                                      0, /*             not used             */
-                             0x0012C000, /* 0+1,  3+1,   2+1,   1+1,  6, 67% */
-                                      0, /*             not used             */
-                             0x0023C000, /* 0+1,  3+1,   3+1,   2+1,  8, 63% */
-                                      0, /*             not used             */
-                             0x0025C000, /* 0+1,  3+1,   5+1,   2+1, 10, 70% */
-                                      0, /*             not used             */
-                             0x0036C000, /* 0+1,  3+1,   6+1,   3+1, 12, 67% */
-                                      0, /*             not used             */
-                                      0, /*             not used             */
-                             0x0048C000, /* 0+1,  3+1,   8+1,   4+1, 15, 67% */
-                             0x0049C000, /* 0+1,  3+1,   9+1,   4+1, 16, 69% */
-                           };
-/* Counts number of filters (CAN message objects) used */
-uint16_t CANAF_FullCAN_cnt = 0;
-uint16_t CANAF_std_cnt = 0;
-uint16_t CANAF_gstd_cnt = 0;
-uint16_t CANAF_ext_cnt = 0;
-uint16_t CANAF_gext_cnt = 0;
-
-static fnCANCbs_Type* _apfnCANCbs[12]={
-		NULL, 	//CAN Recieve  Call-back funtion pointer
-		NULL,	//CAN Transmit1 Call-back funtion pointer
-		NULL,	//CAN Error Warning Call-back function pointer
-		NULL,	//CAN Data Overrun Call-back function pointer
-		NULL,	//CAN Wake-up Call-back funtion pointer
-		NULL,	//CAN Error Passive Call-back function pointer
-		NULL,	//CAN Arbitration Lost Call-back function pointer
-		NULL,	//CAN Bus Error Call-back function pointer
-		NULL,	//CAN ID Ready Call-back function pointer
-		NULL,	//CAN Transmit2 Call-back function pointer
-		NULL,	//CAN Transmit3 Call-back function pointer
-		NULL	//FullCAN Receive Call-back function pointer
-};
-
-/**
- * @}
- */
-
-
-/* Public Functions ----------------------------------------------------------- */
-/** @addtogroup CAN_Public_Functions
- * @{
- */
-
-
-/*********************************************************************//**
- * @brief 		Setting CAN baud rate (bps)
- * @param[in] 	CANx point to CAN_TypeDef object, should be:
- * 				- CAN1
- * 				- CAN2
- * @param[in]	baudrate is the baud rate value will be set
- * @return 		None
- ***********************************************************************/
-void CAN_SetBaudRate (CAN_TypeDef *CANx, uint32_t baudrate)
-{
-	uint32_t nominal_time;
-	uint32_t result = 0;
-	uint32_t CANPclk = 0;
-
-	CHECK_PARAM(PARAM_CANx(CANx));
-
-	if (CANx == CAN1)
-	{
-		CANPclk = CLKPWR_GetPCLK (CLKPWR_PCONP_PCAN1);
-	}
-	else
-	{
-		CANPclk = CLKPWR_GetPCLK (CLKPWR_PCONP_PCAN2);
-	}
-	/* Determine which nominal time to use for PCLK and baudrate */
-	if (baudrate &lt;= 500000)
-	{
-		nominal_time = 12;
-	}
-	else if (((CANPclk / 1000000) % 15) == 0)
-	{
-		nominal_time = 15;
-	}
-	else if (((CANPclk / 1000000) % 16) == 0)
-	{
-		nominal_time = 16;
-	}
-	else
-	{
-		nominal_time = 10;
-	}
-
-	/* Prepare value appropriate for bit time register                         */
-	result  = (CANPclk / nominal_time) / baudrate - 1;
-	result &amp;= 0x000003FF;
-	result |= CAN_BIT_TIME[nominal_time];
-
-	/* Enter reset mode */
-	CANx-&gt;MOD = 0x01;
-	/* Set bit timing */
-	CANx-&gt;BTR  = result;
-
-	/* Return to normal operating */
-	CANx-&gt;MOD = 0;
-}
-
-/********************************************************************//**
- * @brief		Initialize CAN peripheral with given baudrate
- * @param[in]	CANx pointer to CAN_TypeDef, should be:
- * 				- CAN1: CAN 1
- * 				- CAN2: CAN 2
- * @param[in]	baudrate: the value of CAN baudrate will be set (bps)
- * @return 		void
- *********************************************************************/
-void CAN_Init(CAN_TypeDef *CANx, uint32_t baudrate)
-{
-	uint32_t temp;
-	uint16_t i;
-	CHECK_PARAM(PARAM_CANx(CANx));
-
-	if(CANx == CAN1)
-	{
-		/* Turn on power and clock for CAN1 */
-		CLKPWR_ConfigPPWR(CLKPWR_PCONP_PCAN1, ENABLE);
-		/* Set clock divide for CAN1 */
-		CLKPWR_SetPCLKDiv (CLKPWR_PCONP_PCAN1, CLKPWR_PCLKSEL_CCLK_DIV_4);
-	}
-	else
-	{
-		/* Turn on power and clock for CAN1 */
-		CLKPWR_ConfigPPWR(CLKPWR_PCONP_PCAN2, ENABLE);
-		/* Set clock divide for CAN2 */
-		CLKPWR_SetPCLKDiv (CLKPWR_PCONP_PCAN2, CLKPWR_PCLKSEL_CCLK_DIV_4);
-	}
-
-	CANx-&gt;MOD = 1; // Enter Reset Mode
-	CANx-&gt;IER = 0; // Disable All CAN Interrupts
-	CANx-&gt;GSR = 0;
-	/* Request command to release Rx, Tx buffer and clear data overrun */
-	//CANx-&gt;CMR = CAN_CMR_AT | CAN_CMR_RRB | CAN_CMR_CDO;
-	CANx-&gt;CMR = (1&lt;&lt;1)|(1&lt;&lt;2)|(1&lt;&lt;3);
-	/* Read to clear interrupt pending in interrupt capture register */
-	temp = CANx-&gt;ICR;
-	CANx-&gt;MOD = 0;// Return Normal operating
-
-	//Reset CANAF value
-	CANAF-&gt;AFMR = 0x01;
-
-	//clear ALUT RAM
-	for (i = 0; i &lt; 512; i++) {
-		CANAF_RAM-&gt;mask[i] = 0x00;
-	}
-
-	CANAF-&gt;SFF_sa = 0x00;
-	CANAF-&gt;SFF_GRP_sa = 0x00;
-	CANAF-&gt;EFF_sa = 0x00;
-	CANAF-&gt;EFF_GRP_sa = 0x00;
-	CANAF-&gt;ENDofTable = 0x00;
-
-	CANAF-&gt;AFMR = 0x00;
-	/* Set baudrate */
-	CAN_SetBaudRate (CANx, baudrate);
-}
-/********************************************************************//**
- * @brief		CAN deInit
- * @param[in]	CANx pointer to CAN_TypeDef, should be:
- * 				- CAN1: CAN 1
- * 				- CAN2: CAN 2
- * @return 		void
- *********************************************************************/
-void CAN_DeInit(CAN_TypeDef *CANx)
-{
-	CHECK_PARAM(PARAM_CANx(CANx));
-
-	if(CANx == CAN1)
-	{
-		/* Turn on power and clock for CAN1 */
-		CLKPWR_ConfigPPWR(CLKPWR_PCONP_PCAN1, DISABLE);
-	}
-	else
-	{
-		/* Turn on power and clock for CAN1 */
-		CLKPWR_ConfigPPWR(CLKPWR_PCONP_PCAN2, DISABLE);
-	}
-}
-/********************************************************************//**
- * @brief		Setup Acceptance Filter Look-Up Table
- * @param[in]	CANx pointer to CANAF_TypeDef, should be: CANAF
- * @param[in]	AFSection is the pointer to AF_SectionDef struct
- * 				It contain information about 5 sections will be install in AFLUT
- * @return 		CAN Error, could be:
- * 				- CAN_OBJECTS_FULL_ERROR: No more rx or tx objects available
- * 				- CAN_AF_ENTRY_ERROR: table error-violation of ascending numerical order
- * 				- CAN_OK: ID is added into table successfully
- *********************************************************************/
-CAN_ERROR CAN_SetupAFLUT(CANAF_TypeDef* CANAFx, AF_SectionDef* AFSection)
-{
-	uint8_t ctrl1,ctrl2;
-	uint8_t dis1, dis2;
-	uint16_t SID, SID_temp,i, count = 0;
-	uint32_t EID, EID_temp, entry, buf;
-	uint16_t lowerSID, upperSID;
-	uint32_t lowerEID, upperEID;
-
-	CHECK_PARAM(PARAM_CANAFx(CANAFx));
-	CANAFx-&gt;AFMR = 0x01;
-
-/***** setup FullCAN Table *****/
-	if(AFSection-&gt;FullCAN_Sec == NULL)
-	{
-		FULLCAN_ENABLE = DISABLE;
-	}
-	else
-	{
-		FULLCAN_ENABLE = ENABLE;
-		for(i=0;i&lt;(AFSection-&gt;FC_NumEntry);i++)
-		{
-			if(count + 1 &gt; 64)
-			{
-				return CAN_OBJECTS_FULL_ERROR;
-			}
-			ctrl1 = AFSection-&gt;FullCAN_Sec-&gt;controller;
-			SID = AFSection-&gt;FullCAN_Sec-&gt;id_11;
-			dis1 = AFSection-&gt;FullCAN_Sec-&gt;disable;
-
-			CHECK_PARAM(PARAM_CTRL(ctrl1));
-			CHECK_PARAM(PARAM_ID_11(SID));
-			CHECK_PARAM(PARAM_MSG_DISABLE(dis1));
-			entry = 0x00; //reset entry value
-			if((CANAF_FullCAN_cnt &amp; 0x00000001)==0)
-			{
-				if(count!=0x00)
-				{
-					buf = CANAF_RAM-&gt;mask[count-1];
-					SID_temp = (buf &amp; 0x000003FF);
-					if(SID_temp &gt; SID)
-					{
-						return CAN_AF_ENTRY_ERROR;
-					}
-				}
-				entry = (ctrl1&lt;&lt;29)|(dis1&lt;&lt;28)|(SID&lt;&lt;16)|(1&lt;&lt;27);
-				CANAF_RAM-&gt;mask[count] &amp;= 0x0000FFFF;
-				CANAF_RAM-&gt;mask[count] |= entry;
-				CANAF_FullCAN_cnt++;
-			}
-			else
-			{
-				buf = CANAF_RAM-&gt;mask[count];
-				SID_temp = (buf &amp; 0x03FF0000)&gt;&gt;16;
-				if(SID_temp &gt; SID)
-				{
-					return CAN_AF_ENTRY_ERROR;
-				}
-				entry = (ctrl1&lt;&lt;13)|(dis1&lt;&lt;12)|(SID&lt;&lt;0)|(1&lt;&lt;11);
-				CANAF_RAM-&gt;mask[count] &amp;= 0xFFFF0000;
-				CANAF_RAM-&gt;mask[count]|= entry;
-				count++;
-				CANAF_FullCAN_cnt++;
-			}
-			AFSection-&gt;FullCAN_Sec = (FullCAN_Entry *)((uint32_t)(AFSection-&gt;FullCAN_Sec)+ sizeof(FullCAN_Entry));
-		}
-	}
-
-/***** Setup Explicit Standard Frame Format Section *****/
-	if(AFSection-&gt;SFF_Sec != NULL)
-	{
-		for(i=0;i&lt;(AFSection-&gt;SFF_NumEntry);i++)
-		{
-			if(count + 1 &gt; 512)
-			{
-				return CAN_OBJECTS_FULL_ERROR;
-			}
-			ctrl1 = AFSection-&gt;SFF_Sec-&gt;controller;
-			SID = AFSection-&gt;SFF_Sec-&gt;id_11;
-			dis1 = AFSection-&gt;SFF_Sec-&gt;disable;
-
-			//check parameter
-			CHECK_PARAM(PARAM_CTRL(ctrl1));
-			CHECK_PARAM(PARAM_ID_11(SID));
-			CHECK_PARAM(PARAM_MSG_DISABLE(dis1));
-
-			entry = 0x00; //reset entry value
-			if((CANAF_std_cnt &amp; 0x00000001)==0)
-			{
-				if(CANAF_std_cnt !=0 )
-				{
-					buf = CANAF_RAM-&gt;mask[count-1];
-					SID_temp = (buf &amp; 0x00000FFF);
-					if(SID_temp &gt; SID)
-					{
-						return CAN_AF_ENTRY_ERROR;
-					}
-				}
-				entry = (ctrl1&lt;&lt;29)|(dis1&lt;&lt;28)|(SID&lt;&lt;16);
-				CANAF_RAM-&gt;mask[count] &amp;= 0x0000FFFF;
-				CANAF_RAM-&gt;mask[count] |= entry;
-				CANAF_std_cnt++;
-			}
-			else
-			{
-				buf = CANAF_RAM-&gt;mask[count];
-				SID_temp = (buf &amp; 0x0FFF0000)&gt;&gt;16;
-				if(SID_temp &gt; SID)
-				{
-					return CAN_AF_ENTRY_ERROR;
-				}
-				entry = (ctrl1&lt;&lt;13)|(dis1&lt;&lt;12)|(SID&lt;&lt;0);
-				CANAF_RAM-&gt;mask[count] &amp;= 0xFFFF0000;
-				CANAF_RAM-&gt;mask[count] |= entry;
-				count++;
-				CANAF_std_cnt++;
-			}
-			AFSection-&gt;SFF_Sec = (SFF_Entry *)((uint32_t)(AFSection-&gt;SFF_Sec)+ sizeof(SFF_Entry));
-		}
-	}
-
-/***** Setup Group of Standard Frame Format Identifier Section *****/
-	if(AFSection-&gt;SFF_GPR_Sec != NULL)
-	{
-		for(i=0;i&lt;(AFSection-&gt;SFF_GPR_NumEntry);i++)
-		{
-			if(count + 1 &gt; 512)
-			{
-				return CAN_OBJECTS_FULL_ERROR;
-			}
-			ctrl1 = AFSection-&gt;SFF_GPR_Sec-&gt;controller1;
-			ctrl2 = AFSection-&gt;SFF_GPR_Sec-&gt;controller2;
-			dis1 = AFSection-&gt;SFF_GPR_Sec-&gt;disable1;
-			dis2 = AFSection-&gt;SFF_GPR_Sec-&gt;disable2;
-			lowerSID = AFSection-&gt;SFF_GPR_Sec-&gt;lowerID;
-			upperSID = AFSection-&gt;SFF_GPR_Sec-&gt;upperID;
-
-			/* check parameter */
-			CHECK_PARAM(PARAM_CTRL(ctrl1));
-			CHECK_PARAM(PARAM_CTRL(ctrl2));
-			CHECK_PARAM(PARAM_MSG_DISABLE(dis1));
-			CHECK_PARAM(PARAM_MSG_DISABLE(dis2));
-			CHECK_PARAM(PARAM_ID_11(lowerSID));
-			CHECK_PARAM(PARAM_ID_11(upperSID));
-
-			entry = 0x00;
-			if(CANAF_gstd_cnt!=0)
-			{
-				buf = CANAF_RAM-&gt;mask[count-1];
-				SID_temp = buf &amp; 0x00000FFF;
-				if(SID_temp &gt; lowerSID)
-				{
-					return CAN_AF_ENTRY_ERROR;
-				}
-			}
-			entry = (ctrl1 &lt;&lt; 29)|(dis1 &lt;&lt; 28)|(lowerSID &lt;&lt; 16)|  \
-					(ctrl2 &lt;&lt; 13)|(dis2 &lt;&lt; 12)|(upperSID &lt;&lt; 0);
-			CANAF_RAM-&gt;mask[count] = entry;
-			CANAF_gstd_cnt++;
-			count++;
-			AFSection-&gt;SFF_GPR_Sec = (SFF_GPR_Entry *)((uint32_t)(AFSection-&gt;SFF_GPR_Sec)+ sizeof(SFF_GPR_Entry));
-		}
-	}
-
-/***** Setup Explicit Extend Frame Format Identifier Section *****/
-	if(AFSection-&gt;EFF_Sec != NULL)
-	{
-		for(i=0;i&lt;(AFSection-&gt;EFF_NumEntry);i++)
-		{
-			if(count + 1 &gt; 512)
-			{
-				return CAN_OBJECTS_FULL_ERROR;
-			}
-			EID = AFSection-&gt;EFF_Sec-&gt;ID_29;
-			ctrl1 = AFSection-&gt;EFF_Sec-&gt;controller;
-
-			// check parameter
-			CHECK_PARAM(PARAM_ID_29(EID));
-			CHECK_PARAM(PARAM_CTRL(ctrl1));
-
-			entry = 0x00; //reset entry value
-			if(CANAF_ext_cnt != 0)
-			{
-				buf = CANAF_RAM-&gt;mask[count-1];
-				EID_temp = buf &amp; 0x0FFFFFFF;
-				if(EID_temp &gt; EID)
-				{
-					return CAN_AF_ENTRY_ERROR;
-				}
-			}
-			entry = (ctrl1 &lt;&lt; 29)|(EID &lt;&lt; 0);
-			CANAF_RAM-&gt;mask[count] = entry;
-			CANAF_ext_cnt ++;
-			count++;
-			AFSection-&gt;EFF_Sec = (EFF_Entry *)((uint32_t)(AFSection-&gt;EFF_Sec)+ sizeof(EFF_Entry));
-		}
-	}
-
-/***** Setup Group of Extended Frame Format Identifier Section *****/
-	if(AFSection-&gt;EFF_GPR_Sec != NULL)
-	{
-		for(i=0;i&lt;(AFSection-&gt;EFF_GPR_NumEntry);i++)
-		{
-			if(count + 2 &gt; 512)
-			{
-				return CAN_OBJECTS_FULL_ERROR;
-			}
-			ctrl1 = AFSection-&gt;EFF_GPR_Sec-&gt;controller1;
-			ctrl2 = AFSection-&gt;EFF_GPR_Sec-&gt;controller2;
-			lowerEID = AFSection-&gt;EFF_GPR_Sec-&gt;lowerEID;
-			upperEID = AFSection-&gt;EFF_GPR_Sec-&gt;upperEID;
-
-			//check parameter
-			CHECK_PARAM(PARAM_CTRL(ctrl1));
-			CHECK_PARAM(PARAM_CTRL(ctrl2));
-			CHECK_PARAM(PARAM_ID_29(lowerEID));
-			CHECK_PARAM(PARAM_ID_29(upperEID));
-
-			entry = 0x00;
-			if(CANAF_gext_cnt != 0)
-			{
-				buf = CANAF_RAM-&gt;mask[count-1];
-				EID_temp = buf &amp; 0x0FFFFFFF;
-				if(EID_temp &gt; lowerEID)
-				{
-					return CAN_AF_ENTRY_ERROR;
-				}
-			}
-			entry = (ctrl1 &lt;&lt; 29)|(lowerEID &lt;&lt; 0);
-			CANAF_RAM-&gt;mask[count++] = entry;
-			entry = (ctrl2 &lt;&lt; 29)|(upperEID &lt;&lt; 0);
-			CANAF_RAM-&gt;mask[count++] = entry;
-			CANAF_gext_cnt++;
-			AFSection-&gt;EFF_GPR_Sec = (EFF_GPR_Entry *)((uint32_t)(AFSection-&gt;EFF_GPR_Sec)+ sizeof(EFF_GPR_Entry));
-		}
-	}
-	//update address values
-	CANAF-&gt;SFF_sa = ((CANAF_FullCAN_cnt + 1)&gt;&gt;1)&lt;&lt;2;
-	CANAF-&gt;SFF_GRP_sa = CANAF-&gt;SFF_sa + (((CANAF_std_cnt+1)&gt;&gt;1)&lt;&lt; 2);
-	CANAF-&gt;EFF_sa = CANAF-&gt;SFF_GRP_sa + (CANAF_gstd_cnt &lt;&lt; 2);
-	CANAF-&gt;EFF_GRP_sa = CANAF-&gt;EFF_sa + (CANAF_ext_cnt &lt;&lt; 2);
-	CANAF-&gt;ENDofTable = CANAF-&gt;EFF_GRP_sa + (CANAF_gext_cnt &lt;&lt; 3);
-
-	if(FULLCAN_ENABLE == DISABLE)
-	{
-		CANAF-&gt;AFMR = 0x00; // Normal mode
-	}
-	else
-	{
-		CANAF-&gt;AFMR = 0x04;
-	}
-	return CAN_OK;
-}
-/********************************************************************//**
- * @brief		Add Explicit ID into AF Look-Up Table dynamically.
- * @param[in]	CANx pointer to CAN_TypeDef, should be:
- * 				- CAN1: CAN 1
- * 				- CAN2: CAN 2
- * @param[in]	id: The ID of entry will be added
- * @param[in]	format: is the type of ID Frame Format, should be:
- * 				- STD_ID_FORMAT: 11-bit ID value
- * 				- EXT_ID_FORMAT: 29-bit ID value
- * @return 		CAN Error, could be:
- * 				- CAN_OBJECTS_FULL_ERROR: No more rx or tx objects available
- * 				- CAN_ID_EXIT_ERROR: ID exited in table
- * 				- CAN_OK: ID is added into table successfully
- *********************************************************************/
-CAN_ERROR CAN_LoadExplicitEntry(CAN_TypeDef* CANx, uint32_t id, CAN_ID_FORMAT_Type format)
-{
-	uint32_t tmp0 = 0;
-	uint32_t buf0=0, buf1=0;
-	int16_t cnt1=0, cnt2=0, bound1=0, total=0;
-
-
-	CHECK_PARAM(PARAM_CANx(CANx));
-	CHECK_PARAM(PARAM_ID_FORMAT(format));
-
-	if (CANx == CAN1)
-	{
-		tmp0 = 0;
-	}
-	else if (CANx == CAN2)
-	{
-		tmp0 = 1;
-	}
-
-	/* Acceptance Filter Memory full - return */
-	total =((CANAF_FullCAN_cnt+1)&gt;&gt;1)+ CANAF_FullCAN_cnt*3 +((CANAF_std_cnt + 1) &gt;&gt; 1)+  \
-			CANAF_gstd_cnt + CANAF_ext_cnt + (CANAF_gext_cnt&lt;&lt;1);
-	if (total &gt;= 512){ //don't have enough space
-		return CAN_OBJECTS_FULL_ERROR;
-	}
-
-	/* Setup Acceptance Filter Configuration
-    Acceptance Filter Mode Register = Off */
- 	CANAF-&gt;AFMR = 0x00000001;
-
-/*********** Add Explicit Standard Identifier Frame Format entry *********/
- 	if(format == STD_ID_FORMAT)
- 	{
- 		id &amp;= 0x07FF;
- 		id |= (tmp0 &lt;&lt; 13); /* Add controller number */
-		/* Move all remaining sections one place up
-		if new entry will increase FullCAN list */
-		if ((CANAF_std_cnt &amp; 0x0001) == 0)
-		{
-			cnt1   = ((CANAF_FullCAN_cnt+1)&gt;&gt;1)+((CANAF_std_cnt+1)&gt;&gt;1);
-			bound1 = total - cnt1;
-			buf0   = CANAF_RAM-&gt;mask[cnt1];
-			while(bound1--)
-			{
-				cnt1++;
-				buf1 = CANAF_RAM-&gt;mask[cnt1];
-				CANAF_RAM-&gt;mask[cnt1] = buf0;
-				buf0 = buf1;
-			}
-		}
-		if (CANAF_std_cnt == 0)
-		{
-			cnt2 = (CANAF_FullCAN_cnt + 1)&gt;&gt;1;
-			/* For entering first ID */
-			CANAF_RAM-&gt;mask[cnt2] = 0x0000FFFF | (id &lt;&lt; 16);
-		}
-		else if (CANAF_std_cnt == 1)
-		{
-			cnt2 = (CANAF_FullCAN_cnt + 1)&gt;&gt;1;
-			/* For entering second ID */
-			if ((CANAF_RAM-&gt;mask[cnt2] &gt;&gt; 16) &gt; id)
-			{
-				CANAF_RAM-&gt;mask[cnt2] = (CANAF_RAM-&gt;mask[cnt2] &gt;&gt; 16) | (id &lt;&lt; 16);
-			}
-			else
-			{
-				CANAF_RAM-&gt;mask[cnt2] = (CANAF_RAM-&gt;mask[cnt2] &amp; 0xFFFF0000) | id;
-			}
-		}
-		else
-		{
-			/* Find where to insert new ID */
-			cnt1 = (CANAF_FullCAN_cnt+1)&gt;&gt;1;
-			cnt2 = CANAF_std_cnt;
-			bound1 = ((CANAF_FullCAN_cnt+1)&gt;&gt;1)+((CANAF_std_cnt+1)&gt;&gt;1);
-			while (cnt1 &lt; bound1)
-			{
-				/* Loop through standard existing IDs */
-				if ((CANAF_RAM-&gt;mask[cnt1] &gt;&gt; 16) &gt; id)
-				{
-					cnt2 = cnt1 * 2;
-					break;
-				}
-
-				if ((CANAF_RAM-&gt;mask[cnt1] &amp; 0x0000FFFF) &gt; id)
-				{
-					cnt2 = cnt1 * 2 + 1;
-					break;
-				}
-
-				cnt1++;
-			}
-			/* cnt1 = U32 where to insert new ID */
-			/* cnt2 = U16 where to insert new ID */
-
-			if (cnt1 == bound1)
-			{
-				/* Adding ID as last entry */
-				/* Even number of IDs exists */
-				if ((CANAF_std_cnt &amp; 0x0001) == 0)
-				{
-					CANAF_RAM-&gt;mask[cnt1]  = 0x0000FFFF | (id &lt;&lt; 16);
-				}
-				/* Odd  number of IDs exists */
-				else
-				{
-					CANAF_RAM-&gt;mask[cnt1]  = (CANAF_RAM-&gt;mask[cnt1] &amp; 0xFFFF0000) | id;
-				}
-			}
-			else
-			{
-				buf0 = CANAF_RAM-&gt;mask[cnt1]; /* Remember current entry */
-				if ((cnt2 &amp; 0x0001) == 0)
-				{
-					/* Insert new mask to even address*/
-					buf1 = (id &lt;&lt; 16) | (buf0 &gt;&gt; 16);
-				}
-				else
-				{
-					/* Insert new mask to odd  address */
-					buf1 = (buf0 &amp; 0xFFFF0000) | id;
-				}
-				CANAF_RAM-&gt;mask[cnt1] = buf1;/* Insert mask */
-				bound1 = ((CANAF_FullCAN_cnt+1)&gt;&gt;1)+((CANAF_std_cnt+1)&gt;&gt;1)-1;
-				/* Move all remaining standard mask entries one place up */
-				while (cnt1 &lt; bound1)
-				{
-					cnt1++;
-					buf1  = CANAF_RAM-&gt;mask[cnt1];
-					CANAF_RAM-&gt;mask[cnt1] = (buf1 &gt;&gt; 16) | (buf0 &lt;&lt; 16);
-					buf0  = buf1;
-				}
-
-				if ((CANAF_std_cnt &amp; 0x0001) == 0)
-				{
-					/* Even number of IDs exists */
-					CANAF_RAM-&gt;mask[cnt1+1] = (buf0 &lt;&lt;16) |(0x0000FFFF);
-				}
-			}
-		}
-		CANAF_std_cnt++;
-		//update address values
-		CANAF-&gt;SFF_GRP_sa +=0x04 ;
-		CANAF-&gt;EFF_sa     +=0x04 ;
-		CANAF-&gt;EFF_GRP_sa +=0x04;
-		CANAF-&gt;ENDofTable +=0x04;
- 	}
-
-/*********** Add Explicit Extended Identifier Frame Format entry *********/
- 	else
- 	{
- 		/* Add controller number */
- 		id |= (tmp0) &lt;&lt; 29;
-
- 		cnt1 = ((CANAF_FullCAN_cnt+1)&gt;&gt;1)+(((CANAF_std_cnt + 1) &gt;&gt; 1) + CANAF_gstd_cnt);
- 		cnt2 = 0;
- 		while (cnt2 &lt; CANAF_ext_cnt)
- 		{
- 			/* Loop through extended existing masks*/
- 			if (CANAF_RAM-&gt;mask[cnt1] &gt; id)
- 			{
- 				break;
- 			}
- 			cnt1++;/* cnt1 = U32 where to insert new mask */
-			cnt2++;
- 		}
-
- 		buf0 = CANAF_RAM-&gt;mask[cnt1];  /* Remember current entry */
- 		CANAF_RAM-&gt;mask[cnt1] = id;    /* Insert mask */
-
- 		CANAF_ext_cnt++;
-
- 		bound1 = total;
- 		/* Move all remaining extended mask entries one place up*/
- 		while (cnt2 &lt; bound1)
- 		{
- 			cnt1++;
- 			cnt2++;
- 			buf1 = CANAF_RAM-&gt;mask[cnt1];
- 			CANAF_RAM-&gt;mask[cnt1] = buf0;
- 			buf0 = buf1;
- 		}
- 		/* update address values */
-		CANAF-&gt;EFF_GRP_sa += 4;
-		CANAF-&gt;ENDofTable += 4;
- 	}
- 	if(CANAF_FullCAN_cnt == 0) //not use FullCAN mode
- 	{
- 		CANAF-&gt;AFMR = 0x00;//not use FullCAN mode
- 	}
- 	else
- 	{
- 		CANAF-&gt;AFMR = 0x04;
- 	}
-
- 	return CAN_OK;
-}
-
-/********************************************************************//**
- * @brief		Load FullCAN entry into AFLUT
- * @param[in]	CANx: CAN peripheral selected, should be:
- * 				- CAN1: CAN 1
- * 				- CAN2: CAN 2
- * @param[in]	id: identifier of entry that will be added
- * @return 		CAN_ERROR, could be:
- * 				- CAN_OK: loading is successful
- * 				- CAN_ID_EXIT_ERROR: ID exited in FullCAN Section
- * 				- CAN_OBJECTS_FULL_ERROR: no more space available
- *********************************************************************/
-CAN_ERROR CAN_LoadFullCANEntry (CAN_TypeDef* CANx, uint16_t id)
-{
-	uint32_t ctrl0 = 0;
-	uint32_t buf0=0, buf1=0, buf2=0;
-	uint32_t tmp0=0, tmp1=0, tmp2=0;
-	int16_t cnt1=0, cnt2=0, bound1=0, total=0;
-
-	CHECK_PARAM(PARAM_CANx(CANx));
-
-	if (CANx == CAN1)
-	{
-		ctrl0 = 0;
-	}
-	else if (CANx == CAN2)
-	{
-		ctrl0 = 1;
-	}
-
-	/* Acceptance Filter Memory full - return */
-	total =((CANAF_FullCAN_cnt+1)&gt;&gt;1)+ CANAF_FullCAN_cnt*3 +((CANAF_std_cnt + 1) &gt;&gt; 1)+  \
-			CANAF_gstd_cnt + CANAF_ext_cnt + (CANAF_gext_cnt&lt;&lt;1);
-	//don't have enough space for this fullCAN Entry and its Object(3*32 bytes)
-	if ((total &gt;=508)||(CANAF_FullCAN_cnt&gt;=64)){
-		return CAN_OBJECTS_FULL_ERROR;
-	}
-	/* Setup Acceptance Filter Configuration
-    Acceptance Filter Mode Register = Off */
- 	CANAF-&gt;AFMR = 0x00000001;
-
-	/* Add mask for standard identifiers   */
-	id &amp;= 0x07FF;
-	id |= (ctrl0 &lt;&lt; 13) | (1 &lt;&lt; 11); /* Add controller number */
-//	total = ((CANAF_std_cnt + 1) &gt;&gt; 1)+ CANAF_gstd_cnt + CANAF_ext_cnt + (CANAF_gext_cnt&lt;&lt;1);
-	/* Move all remaining sections one place up
-	if new entry will increase FullCAN list */
-	if (((CANAF_FullCAN_cnt &amp; 0x0001) == 0)&amp;&amp;(total!=0))
-	{
-		//then remove remaining section
-		cnt1   = (CANAF_FullCAN_cnt &gt;&gt; 1);
-		bound1 = total;
-		buf0   = CANAF_RAM-&gt;mask[cnt1];
-
-		while (bound1--)
-		{
-			cnt1++;
-			buf1 = CANAF_RAM-&gt;mask[cnt1];
-			CANAF_RAM-&gt;mask[cnt1] = buf0;
-			buf0 = buf1;
-		}
-	}
-	if (CANAF_FullCAN_cnt == 0)
-	{
-		/* For entering first ID */
-		CANAF_RAM-&gt;mask[0] = 0x0000FFFF | (id &lt;&lt; 16);
-	}
-	else if (CANAF_FullCAN_cnt == 1)
-	{
-		/* For entering second ID */
-		if ((CANAF_RAM-&gt;mask[0] &gt;&gt; 16) &gt; id)
-		{
-			CANAF_RAM-&gt;mask[0] = (CANAF_RAM-&gt;mask[0] &gt;&gt; 16) | (id &lt;&lt; 16);
-		}
-		else
-		{
-			CANAF_RAM-&gt;mask[0] = (CANAF_RAM-&gt;mask[0] &amp; 0xFFFF0000) | id;
-		}
-	}
-	else
-	{
-		/* Find where to insert new ID */
-		cnt1 = 0;
-		cnt2 = CANAF_FullCAN_cnt;
-		bound1 = (CANAF_FullCAN_cnt - 1) &gt;&gt; 1;
-		while (cnt1 &lt;= bound1)
-		{
-			/* Loop through standard existing IDs */
-			if ((CANAF_RAM-&gt;mask[cnt1] &gt;&gt; 16) &gt; id)
-			{
-				cnt2 = cnt1 * 2;
-				break;
-			}
-
-			if ((CANAF_RAM-&gt;mask[cnt1] &amp; 0x0000FFFF) &gt; id)
-			{
-				cnt2 = cnt1 * 2 + 1;
-				break;
-			}
-
-			cnt1++;
-		}
-		/* cnt1 = U32 where to insert new ID */
-		/* cnt2 = U16 where to insert new ID */
-
-		if (cnt1 &gt; bound1)
-		{
-			/* Adding ID as last entry */
-			/* Even number of IDs exists */
-			if ((CANAF_FullCAN_cnt &amp; 0x0001) == 0)
-			{
-				CANAF_RAM-&gt;mask[cnt1]  = 0x0000FFFF | (id &lt;&lt; 16);
-			}
-			/* Odd  number of IDs exists */
-			else
-			{
-				CANAF_RAM-&gt;mask[cnt1]  = (CANAF_RAM-&gt;mask[cnt1] &amp; 0xFFFF0000) | id;
-			}
-		}
-		else
-		{
-			buf0 = CANAF_RAM-&gt;mask[cnt1]; /* Remember current entry */
-			if ((cnt2 &amp; 0x0001) == 0)
-			{
-				/* Insert new mask to even address*/
-				buf1 = (id &lt;&lt; 16) | (buf0 &gt;&gt; 16);
-			}
-			else
-			{
-				/* Insert new mask to odd  address */
-				buf1 = (buf0 &amp; 0xFFFF0000) | id;
-			}
-			CANAF_RAM-&gt;mask[cnt1] = buf1;/* Insert mask */
-			bound1 = CANAF_FullCAN_cnt &gt;&gt; 1;
-			/* Move all remaining standard mask entries one place up */
-			while (cnt1 &lt; bound1)
-			{
-				cnt1++;
-				buf1  = CANAF_RAM-&gt;mask[cnt1];
-				CANAF_RAM-&gt;mask[cnt1] = (buf1 &gt;&gt; 16) | (buf0 &lt;&lt; 16);
-				buf0  = buf1;
-			}
-
-			if ((CANAF_FullCAN_cnt &amp; 0x0001) == 0)
-			{
-				/* Even number of IDs exists */
-				CANAF_RAM-&gt;mask[cnt1] = (CANAF_RAM-&gt;mask[cnt1] &amp; 0xFFFF0000)
-											| (0x0000FFFF);
-			}
-		}
-	}
-	//restruct FulCAN Object Section
-	bound1 = CANAF_FullCAN_cnt - cnt2;
-	cnt1 = total - (CANAF_FullCAN_cnt)*3 + cnt2*3 + 1;
-	buf0 = CANAF_RAM-&gt;mask[cnt1];
-	buf1 = CANAF_RAM-&gt;mask[cnt1+1];
-	buf2 = CANAF_RAM-&gt;mask[cnt1+2];
-	CANAF_RAM-&gt;mask[cnt1]=CANAF_RAM-&gt;mask[cnt1+1]= CANAF_RAM-&gt;mask[cnt1+2]=0x00;
-	cnt1+=3;
-	while(bound1--)
-	{
-		tmp0 = CANAF_RAM-&gt;mask[cnt1];
-		tmp1 = CANAF_RAM-&gt;mask[cnt1+1];
-		tmp2 = CANAF_RAM-&gt;mask[cnt1+2];
-		CANAF_RAM-&gt;mask[cnt1]= buf0;
-		CANAF_RAM-&gt;mask[cnt1+1]= buf1;
-		CANAF_RAM-&gt;mask[cnt1+2]= buf2;
-		buf0 = tmp0;
-		buf1 = tmp1;
-		buf2 = tmp2;
-		cnt1+=3;
-	}
-	CANAF_FullCAN_cnt++;
-	//update address values
-	CANAF-&gt;SFF_sa 	  +=0x04;
-	CANAF-&gt;SFF_GRP_sa +=0x04 ;
-	CANAF-&gt;EFF_sa     +=0x04 ;
-	CANAF-&gt;EFF_GRP_sa +=0x04;
-	CANAF-&gt;ENDofTable +=0x04;
-
- 	CANAF-&gt;AFMR = 0x04;
- 	return CAN_OK;
-}
-
-/********************************************************************//**
- * @brief		Load Group entry into AFLUT
- * @param[in]	CANx: CAN peripheral selected, should be:
- * 				- CAN1: CAN 1
- * 				- CAN2: CAN 2
- * @param[in]	lowerID, upperID: lower and upper identifier of entry
- * @param[in]	format: type of ID format, should be:
- * 				- STD_ID_FORMAT: Standard ID format (11-bit value)
- * 				- EXT_ID_FORMAT: Extended ID format (29-bit value)
- * @return 		CAN_ERROR, could be:
- * 				- CAN_OK: loading is successful
- * 				- CAN_CONFLICT_ID_ERROR: Conflict ID occurs
- * 				- CAN_OBJECTS_FULL_ERROR: no more space available
- *********************************************************************/
-CAN_ERROR CAN_LoadGroupEntry(CAN_TypeDef* CANx, uint32_t lowerID, \
-		uint32_t upperID, CAN_ID_FORMAT_Type format)
-{
-	uint16_t tmp = 0;
-	uint32_t buf0, buf1, entry1, entry2, LID,UID;
-	int16_t cnt1, bound1, total;
-
-	CHECK_PARAM(PARAM_CANx(CANx));
-	CHECK_PARAM(PARAM_ID_FORMAT(format));
-
-	if(lowerID &gt; upperID) return CAN_CONFLICT_ID_ERROR;
-	if(CANx == CAN1)
-	{
-		tmp = 0;
-	}
-	else
-	{
-		tmp = 1;
-	}
-
-	total =((CANAF_FullCAN_cnt+1)&gt;&gt;1)+ CANAF_FullCAN_cnt*3 +((CANAF_std_cnt + 1) &gt;&gt; 1)+  \
-			CANAF_gstd_cnt + CANAF_ext_cnt + (CANAF_gext_cnt&lt;&lt;1);
-
-	/* Setup Acceptance Filter Configuration
-	Acceptance Filter Mode Register = Off */
-	CANAF-&gt;AFMR = 0x00000001;
-
-/*********Add Group of Standard Identifier Frame Format************/
-	if(format == STD_ID_FORMAT)
-	{
-		if ((total &gt;= 512)){//don't have enough space
-			return CAN_OBJECTS_FULL_ERROR;
-		}
-		lowerID &amp;=0x7FF; //mask ID
-		upperID &amp;=0x7FF;
-		entry1  = (tmp &lt;&lt; 29)|(lowerID &lt;&lt; 16)|(tmp &lt;&lt; 13)|(upperID &lt;&lt; 0);
-		cnt1 = ((CANAF_FullCAN_cnt+1)&gt;&gt;1) + ((CANAF_std_cnt + 1) &gt;&gt; 1);
-
-		//if this is the first Group standard ID entry
-		if(CANAF_gstd_cnt == 0)
-		{
-			CANAF_RAM-&gt;mask[cnt1] = entry1;
-		}
-		else
-		{
-			//find the position to add new Group entry
-			bound1 = ((CANAF_FullCAN_cnt+1)&gt;&gt;1) + ((CANAF_std_cnt + 1) &gt;&gt; 1) + CANAF_gstd_cnt;
-			while(cnt1 &lt; bound1)
-			{
-				buf0 = CANAF_RAM-&gt;mask[cnt1];
-				LID  = (buf0 &gt;&gt; 16)&amp;0x7FF;
-				UID  = buf0 &amp; 0x7FF;
-				if (upperID &lt;= LID)
-				{
-					//add new entry before this entry
-					CANAF_RAM-&gt;mask[cnt1] = entry1;
-					break;
-				}
-				else if (lowerID &gt;= UID)
-				{
-					//load next entry to compare
-					cnt1 ++;
-				}
-				else
-					return CAN_CONFLICT_ID_ERROR;
-			}
-			if(cnt1 &gt;= bound1)
-			{
-				//add new entry at the last position in this list
-				buf0 = CANAF_RAM-&gt;mask[cnt1];
-				CANAF_RAM-&gt;mask[cnt1] = entry1;
-			}
-
-			//remove all remaining entry of this section one place up
-			bound1 = total - cnt1;
-			while(bound1--)
-			{
-				cnt1++;
-				buf1 = CANAF_RAM-&gt;mask[cnt1];
-				CANAF_RAM-&gt;mask[cnt1] = buf0;
-				buf0 = buf1;
-			}
-		}
-		CANAF_gstd_cnt++;
-		//update address values
-		CANAF-&gt;EFF_sa     +=0x04 ;
-		CANAF-&gt;EFF_GRP_sa +=0x04;
-		CANAF-&gt;ENDofTable +=0x04;
-	}
-
-
-/*********Add Group of Extended Identifier Frame Format************/
-	else
-	{
-		if ((total &gt;= 511)){//don't have enough space
-			return CAN_OBJECTS_FULL_ERROR;
-		}
-		lowerID  &amp;= 0x1FFFFFFF; //mask ID
-		upperID &amp;= 0x1FFFFFFF;
-		entry1   = (tmp &lt;&lt; 29)|(lowerID &lt;&lt; 0);
-		entry2   = (tmp &lt;&lt; 29)|(upperID &lt;&lt; 0);
-
-		cnt1 = ((CANAF_FullCAN_cnt+1)&gt;&gt;1) + ((CANAF_std_cnt + 1) &gt;&gt; 1) + CANAF_gstd_cnt + CANAF_ext_cnt;
-		//if this is the first Group standard ID entry
-		if(CANAF_gext_cnt == 0)
-		{
-			CANAF_RAM-&gt;mask[cnt1] = entry1;
-			CANAF_RAM-&gt;mask[cnt1+1] = entry2;
-		}
-		else
-		{
-			//find the position to add new Group entry
-			bound1 = ((CANAF_FullCAN_cnt+1)&gt;&gt;1) + ((CANAF_std_cnt + 1) &gt;&gt; 1) + CANAF_gstd_cnt \
-						+ CANAF_ext_cnt + (CANAF_gext_cnt&lt;&lt;1);
-			while(cnt1 &lt; bound1)
-			{
-				buf0 = CANAF_RAM-&gt;mask[cnt1];
-				buf1 = CANAF_RAM-&gt;mask[cnt1+1];
-				LID  = buf0 &amp; 0x1FFFFFFF; //mask ID
-				UID  = buf1 &amp; 0x1FFFFFFF;
-				if (upperID &lt;= LID)
-				{
-					//add new entry before this entry
-					CANAF_RAM-&gt;mask[cnt1] = entry1;
-					CANAF_RAM-&gt;mask[++cnt1] = entry2;
-					break;
-				}
-				else if (lowerID &gt;= UID)
-				{
-					//load next entry to compare
-					cnt1 +=2;
-				}
-				else
-					return CAN_CONFLICT_ID_ERROR;
-			}
-			if(cnt1 &gt;= bound1)
-			{
-				//add new entry at the last position in this list
-				buf0 = CANAF_RAM-&gt;mask[cnt1];
-				buf1 = CANAF_RAM-&gt;mask[cnt1+1];
-				CANAF_RAM-&gt;mask[cnt1]   = entry1;
-				CANAF_RAM-&gt;mask[++cnt1] = entry2;
-			}
-			//remove all remaining entry of this section two place up
-			bound1 = total - cnt1 + 1;
-			cnt1++;
-			while(bound1&gt;0)
-			{
-				entry1 = CANAF_RAM-&gt;mask[cnt1];
-				entry2 = CANAF_RAM-&gt;mask[cnt1+1];
-				CANAF_RAM-&gt;mask[cnt1]   = buf0;
-				CANAF_RAM-&gt;mask[cnt1+1] = buf1;
-				buf0 = entry1;
-				buf1 = entry2;
-				cnt1   +=2;
-				bound1 -=2;
-			}
-		}
-		CANAF_gext_cnt++;
-		//update address values
-		CANAF-&gt;ENDofTable +=0x08;
-	}
- 	CANAF-&gt;AFMR = 0x04;
- 	return CAN_OK;
-}
-
-/********************************************************************//**
- * @brief		Remove AFLUT entry (FullCAN entry and Explicit Standard entry)
- * @param[in]	EntryType: the type of entry that want to remove, should be:
- * 				- FULLCAN_ENTRY
- * 				- EXPLICIT_STANDARD_ENTRY
- * 				- GROUP_STANDARD_ENTRY
- * 				- EXPLICIT_EXTEND_ENTRY
- * 				- GROUP_EXTEND_ENTRY
- * @param[in]	position: the position of this entry in its section
- * Note: the first position is 0
- * @return 		CAN_ERROR, could be:
- * 				- CAN_OK: removing is successful
- * 				- CAN_ENTRY_NOT_EXIT_ERROR: entry want to remove is not exit
- *********************************************************************/
-CAN_ERROR CAN_RemoveEntry(AFLUT_ENTRY_Type EntryType, uint16_t position)
-{
-	uint16_t cnt, bound, total;
-	uint32_t buf0, buf1;
-	CHECK_PARAM(PARAM_AFLUT_ENTRY_TYPE(EntryType));
-	CHECK_PARAM(PARAM_POSITION(position));
-
-	/* Setup Acceptance Filter Configuration
-	Acceptance Filter Mode Register = Off */
-	CANAF-&gt;AFMR = 0x00000001;
-	total = ((CANAF_FullCAN_cnt+1)&gt;&gt;1)+((CANAF_std_cnt + 1) &gt;&gt; 1) + \
-			CANAF_gstd_cnt + CANAF_ext_cnt + (CANAF_gext_cnt&lt;&lt;1);
-
-
-/************** Remove FullCAN Entry *************/
-	if(EntryType == FULLCAN_ENTRY)
-	{
-		if((CANAF_FullCAN_cnt==0)||(position &gt;= CANAF_FullCAN_cnt))
-		{
-			return CAN_ENTRY_NOT_EXIT_ERROR;
-		}
-		else
-		{
-			cnt = position &gt;&gt; 1;
-			buf0 = CANAF_RAM-&gt;mask[cnt];
-			bound = (CANAF_FullCAN_cnt - position -1)&gt;&gt;1;
-			if((position &amp; 0x0001) == 0) //event position
-			{
-				while(bound--)
-				{
-					//remove all remaining FullCAN entry one place down
-					buf1  = CANAF_RAM-&gt;mask[cnt+1];
-					CANAF_RAM-&gt;mask[cnt] = (buf1 &gt;&gt; 16) | (buf0 &lt;&lt; 16);
-					buf0  = buf1;
-					cnt++;
-				}
-			}
-			else //odd position
-			{
-				while(bound--)
-				{
-					//remove all remaining FullCAN entry one place down
-					buf1  = CANAF_RAM-&gt;mask[cnt+1];
-					CANAF_RAM-&gt;mask[cnt] = (buf0 &amp; 0xFFFF0000)|(buf1 &gt;&gt; 16);
-					CANAF_RAM-&gt;mask[cnt+1] = CANAF_RAM-&gt;mask[cnt+1] &lt;&lt; 16;
-					buf0  = buf1&lt;&lt;16;
-					cnt++;
-				}
-			}
-			if((CANAF_FullCAN_cnt &amp; 0x0001) == 0)
-			{
-				if((position &amp; 0x0001)==0)
-					CANAF_RAM-&gt;mask[cnt] = (buf0 &lt;&lt; 16) | (0x0000FFFF);
-				else
-					CANAF_RAM-&gt;mask[cnt] = buf0 | 0x0000FFFF;
-			}
-			else
-			{
-				//remove all remaining section one place down
-				cnt = (CANAF_FullCAN_cnt + 1)&gt;&gt;1;
-				bound = total + CANAF_FullCAN_cnt * 3;
-				while(bound&gt;cnt)
-				{
-					CANAF_RAM-&gt;mask[cnt-1] = CANAF_RAM-&gt;mask[cnt];
-					cnt++;
-				}
-				CANAF_RAM-&gt;mask[cnt-1]=0x00;
-				//update address values
-				CANAF-&gt;SFF_sa 	  -=0x04;
-				CANAF-&gt;SFF_GRP_sa -=0x04 ;
-				CANAF-&gt;EFF_sa     -=0x04 ;
-				CANAF-&gt;EFF_GRP_sa -=0x04;
-				CANAF-&gt;ENDofTable -=0x04;
-			}
-			CANAF_FullCAN_cnt--;
-
-			//delete its FullCAN Object in the FullCAN Object section
-			//remove all remaining FullCAN Object three place down
-			cnt = total + position * 3;
-			bound = (CANAF_FullCAN_cnt - position + 1) * 3;
-
-			while(bound)
-			{
-				CANAF_RAM-&gt;mask[cnt]=CANAF_RAM-&gt;mask[cnt+3];;
-				CANAF_RAM-&gt;mask[cnt+1]=CANAF_RAM-&gt;mask[cnt+4];
-				CANAF_RAM-&gt;mask[cnt+2]=CANAF_RAM-&gt;mask[cnt+5];
-				bound -=3;
-				cnt   +=3;
-			}
-		}
-	}
-
-/************** Remove Explicit Standard ID Entry *************/
-	else if(EntryType == EXPLICIT_STANDARD_ENTRY)
-	{
-		if((CANAF_std_cnt==0)||(position &gt;= CANAF_std_cnt))
-		{
-			return CAN_ENTRY_NOT_EXIT_ERROR;
-		}
-		else
-		{
-			cnt = ((CANAF_FullCAN_cnt+1)&gt;&gt;1)+ (position &gt;&gt; 1);
-			buf0 = CANAF_RAM-&gt;mask[cnt];
-			bound = (CANAF_std_cnt - position - 1)&gt;&gt;1;
-			if((position &amp; 0x0001) == 0) //event position
-			{
-				while(bound--)
-				{
-					//remove all remaining FullCAN entry one place down
-					buf1  = CANAF_RAM-&gt;mask[cnt+1];
-					CANAF_RAM-&gt;mask[cnt] = (buf1 &gt;&gt; 16) | (buf0 &lt;&lt; 16);
-					buf0  = buf1;
-					cnt++;
-				}
-			}
-			else //odd position
-			{
-				while(bound--)
-				{
-					//remove all remaining FullCAN entry one place down
-					buf1  = CANAF_RAM-&gt;mask[cnt+1];
-					CANAF_RAM-&gt;mask[cnt] = (buf0 &amp; 0xFFFF0000)|(buf1 &gt;&gt; 16);
-					CANAF_RAM-&gt;mask[cnt+1] = CANAF_RAM-&gt;mask[cnt+1] &lt;&lt; 16;
-					buf0  = buf1&lt;&lt;16;
-					cnt++;
-				}
-			}
-			if((CANAF_std_cnt &amp; 0x0001) == 0)
-			{
-				if((position &amp; 0x0001)==0)
-					CANAF_RAM-&gt;mask[cnt] = (buf0 &lt;&lt; 16) | (0x0000FFFF);
-				else
-					CANAF_RAM-&gt;mask[cnt] = buf0 | 0x0000FFFF;
-			}
-			else
-			{
-				//remove all remaining section one place down
-				cnt = ((CANAF_FullCAN_cnt + 1)&gt;&gt;1) + ((CANAF_std_cnt + 1) &gt;&gt; 1);
-				bound = total + CANAF_FullCAN_cnt * 3;
-				while(bound&gt;cnt)
-				{
-					CANAF_RAM-&gt;mask[cnt-1] = CANAF_RAM-&gt;mask[cnt];
-					cnt++;
-				}
-				CANAF_RAM-&gt;mask[cnt-1]=0x00;
-				//update address value
-				CANAF-&gt;SFF_GRP_sa -=0x04 ;
-				CANAF-&gt;EFF_sa     -=0x04 ;
-				CANAF-&gt;EFF_GRP_sa -=0x04;
-				CANAF-&gt;ENDofTable -=0x04;
-			}
-			CANAF_std_cnt--;
-		}
-	}
-
-/************** Remove Group of Standard ID Entry *************/
-	else if(EntryType == GROUP_STANDARD_ENTRY)
-	{
-		if((CANAF_gstd_cnt==0)||(position &gt;= CANAF_gstd_cnt))
-		{
-			return CAN_ENTRY_NOT_EXIT_ERROR;
-		}
-		else
-		{
-			cnt = ((CANAF_FullCAN_cnt + 1)&gt;&gt;1) + ((CANAF_std_cnt + 1) &gt;&gt; 1)+ position + 1;
-			bound = total + CANAF_FullCAN_cnt * 3;
-			while (cnt&lt;bound)
-			{
-				CANAF_RAM-&gt;mask[cnt-1] = CANAF_RAM-&gt;mask[cnt];
-				cnt++;
-			}
-			CANAF_RAM-&gt;mask[cnt-1]=0x00;
-		}
-		CANAF_gstd_cnt--;
-		//update address value
-		CANAF-&gt;EFF_sa     -=0x04;
-		CANAF-&gt;EFF_GRP_sa -=0x04;
-		CANAF-&gt;ENDofTable -=0x04;
-	}
-
-/************** Remove Explicit Extended ID Entry *************/
-	else if(EntryType == EXPLICIT_EXTEND_ENTRY)
-	{
-		if((CANAF_ext_cnt==0)||(position &gt;= CANAF_ext_cnt))
-		{
-			return CAN_ENTRY_NOT_EXIT_ERROR;
-		}
-		else
-		{
-			cnt = ((CANAF_FullCAN_cnt + 1)&gt;&gt;1) + ((CANAF_std_cnt + 1) &gt;&gt; 1)+ CANAF_gstd_cnt + position + 1;
-			bound = total + CANAF_FullCAN_cnt * 3;
-			while (cnt&lt;bound)
-			{
-				CANAF_RAM-&gt;mask[cnt-1] = CANAF_RAM-&gt;mask[cnt];
-				cnt++;
-			}
-			CANAF_RAM-&gt;mask[cnt-1]=0x00;
-		}
-		CANAF_ext_cnt--;
-		CANAF-&gt;EFF_GRP_sa -=0x04;
-		CANAF-&gt;ENDofTable -=0x04;
-	}
-
-/************** Remove Group of Extended ID Entry *************/
-	else
-	{
-		if((CANAF_gext_cnt==0)||(position &gt;= CANAF_gext_cnt))
-		{
-			return CAN_ENTRY_NOT_EXIT_ERROR;
-		}
-		else
-		{
-			cnt = total - (CANAF_gext_cnt&lt;&lt;1) + (position&lt;&lt;1);
-			bound = total + CANAF_FullCAN_cnt * 3;
-			while (cnt&lt;bound)
-			{
-				//remove all remaining entry two place up
-				CANAF_RAM-&gt;mask[cnt] = CANAF_RAM-&gt;mask[cnt+2];
-				CANAF_RAM-&gt;mask[cnt+1] = CANAF_RAM-&gt;mask[cnt+3];
-				cnt+=2;
-			}
-		}
-		CANAF_gext_cnt--;
-		CANAF-&gt;ENDofTable -=0x08;
-	}
-	CANAF-&gt;AFMR = 0x04;
-	return CAN_OK;
-}
-
-/********************************************************************//**
- * @brief		Send message data
- * @param[in]	CANx pointer to CAN_TypeDef, should be:
- * 				- CAN1: CAN 1
- * 				- CAN2: CAN 2
- * @param[in]	CAN_Msg point to the CAN_MSG_Type Structure, it contains message
- * 				information such as: ID, DLC, RTR, ID Format
- * @return 		Status:
- * 				- SUCCESS: send message successfully
- * 				- ERROR: send message unsuccessfully
- *********************************************************************/
-Status CAN_SendMsg (CAN_TypeDef *CANx, CAN_MSG_Type *CAN_Msg)
-{
-	uint32_t data;
-	CHECK_PARAM(PARAM_CANx(CANx));
-	CHECK_PARAM(PARAM_ID_FORMAT(CAN_Msg-&gt;format));
-	if(CAN_Msg-&gt;format==STD_ID_FORMAT)
-	{
-		CHECK_PARAM(PARAM_ID_11(CAN_Msg-&gt;id));
-	}
-	else
-	{
-		CHECK_PARAM(PARAM_ID_29(CAN_Msg-&gt;id));
-	}
-	CHECK_PARAM(PARAM_DLC(CAN_Msg-&gt;len));
-	CHECK_PARAM(PARAM_FRAME_TYPE(CAN_Msg-&gt;type));
-
-	//Check status of Transmit Buffer 1
-	if ((CANx-&gt;SR &amp; 0x00000004)&gt;&gt;2)
-	{
-		/* Transmit Channel 1 is available */
-		/* Write frame informations and frame data into its CANxTFI1,
-		 * CANxTID1, CANxTDA1, CANxTDB1 register */
-		CANx-&gt;TFI1 &amp;= ~0x000F000;
-		CANx-&gt;TFI1 |= (CAN_Msg-&gt;len)&lt;&lt;16;
-		if(CAN_Msg-&gt;type == REMOTE_FRAME)
-		{
-			CANx-&gt;TFI1 |= (1&lt;&lt;30); //set bit RTR
-		}
-		else
-		{
-			CANx-&gt;TFI1 &amp;= ~(1&lt;&lt;30);
-		}
-		if(CAN_Msg-&gt;format == EXT_ID_FORMAT)
-		{
-			CANx-&gt;TFI1 |= (1&lt;&lt;31); //set bit FF
-		}
-		else
-		{
-			CANx-&gt;TFI1 &amp;= ~(1&lt;&lt;31);
-		}
-
-		/* Write CAN ID*/
-		CANx-&gt;TID1 = CAN_Msg-&gt;id;
-
-		/*Write first 4 data bytes*/
-		data = (CAN_Msg-&gt;dataA[0])|(((CAN_Msg-&gt;dataA[1]))&lt;&lt;8)|((CAN_Msg-&gt;dataA[2])&lt;&lt;16)|((CAN_Msg-&gt;dataA[3])&lt;&lt;24);
-//		CANx-&gt;TDA1 = *((uint32_t *) &amp;(CAN_Msg-&gt;dataA));
-		CANx-&gt;TDA1 = data;
-
-		/*Write second 4 data bytes*/
-		data = (CAN_Msg-&gt;dataB[0])|(((CAN_Msg-&gt;dataB[1]))&lt;&lt;8)|((CAN_Msg-&gt;dataB[2])&lt;&lt;16)|((CAN_Msg-&gt;dataB[3])&lt;&lt;24);
-//		CANx-&gt;TDB1 = *((uint32_t *) &amp;(CAN_Msg-&gt;dataB));
-		CANx-&gt;TDB1 = data;
-
-		 /*Write transmission request*/
-		 CANx-&gt;CMR = 0x21;
-		 return SUCCESS;
-	}
-	//check status of Transmit Buffer 2
-	else if((CANx-&gt;SR &amp; 0x00000004)&gt;&gt;10)
-	{
-		/* Transmit Channel 2 is available */
-		/* Write frame informations and frame data into its CANxTFI2,
-		 * CANxTID2, CANxTDA2, CANxTDB2 register */
-		CANx-&gt;TFI2 &amp;= ~0x000F000;
-		CANx-&gt;TFI2 |= (CAN_Msg-&gt;len)&lt;&lt;16;
-		if(CAN_Msg-&gt;type == REMOTE_FRAME)
-		{
-			CANx-&gt;TFI2 |= (1&lt;&lt;30); //set bit RTR
-		}
-		else
-		{
-			CANx-&gt;TFI2 &amp;= ~(1&lt;&lt;30);
-		}
-		if(CAN_Msg-&gt;format == EXT_ID_FORMAT)
-		{
-			CANx-&gt;TFI2 |= (1&lt;&lt;31); //set bit FF
-		}
-		else
-		{
-			CANx-&gt;TFI2 &amp;= ~(1&lt;&lt;31);
-		}
-
-		/* Write CAN ID*/
-		CANx-&gt;TID2 = CAN_Msg-&gt;id;
-
-		/*Write first 4 data bytes*/
-		data = (CAN_Msg-&gt;dataA[0])|(((CAN_Msg-&gt;dataA[1]))&lt;&lt;8)|((CAN_Msg-&gt;dataA[2])&lt;&lt;16)|((CAN_Msg-&gt;dataA[3])&lt;&lt;24);
-//		CANx-&gt;TDA2 = *((uint32_t *) &amp;(CAN_Msg-&gt;dataA));
-		CANx-&gt;TDA2 = data;
-
-		/*Write second 4 data bytes*/
-		data = (CAN_Msg-&gt;dataB[0])|(((CAN_Msg-&gt;dataB[1]))&lt;&lt;8)|((CAN_Msg-&gt;dataB[2])&lt;&lt;16)|((CAN_Msg-&gt;dataB[3])&lt;&lt;24);
-//		CANx-&gt;TDB2 = *((uint32_t *) &amp;(CAN_Msg-&gt;dataB));
-		CANx-&gt;TDB2 = data;
-
-		/*Write transmission request*/
-		CANx-&gt;CMR = 0x41;
-		return SUCCESS;
-	}
-	//check status of Transmit Buffer 3
-	else if ((CANx-&gt;SR &amp; 0x00000004)&gt;&gt;18)
-	{
-		/* Transmit Channel 3 is available */
-		/* Write frame informations and frame data into its CANxTFI3,
-		 * CANxTID3, CANxTDA3, CANxTDB3 register */
-		CANx-&gt;TFI3 &amp;= ~0x000F000;
-		CANx-&gt;TFI3 |= (CAN_Msg-&gt;len)&lt;&lt;16;
-		if(CAN_Msg-&gt;type == REMOTE_FRAME)
-		{
-			CANx-&gt;TFI3 |= (1&lt;&lt;30); //set bit RTR
-		}
-		else
-		{
-			CANx-&gt;TFI3 &amp;= ~(1&lt;&lt;30);
-		}
-		if(CAN_Msg-&gt;format == EXT_ID_FORMAT)
-		{
-			CANx-&gt;TFI3 |= (1&lt;&lt;31); //set bit FF
-		}
-		else
-		{
-			CANx-&gt;TFI3 &amp;= ~(1&lt;&lt;31);
-		}
-
-		/* Write CAN ID*/
-		CANx-&gt;TID3 = CAN_Msg-&gt;id;
-
-		/*Write first 4 data bytes*/
-		data = (CAN_Msg-&gt;dataA[0])|(((CAN_Msg-&gt;dataA[1]))&lt;&lt;8)|((CAN_Msg-&gt;dataA[2])&lt;&lt;16)|((CAN_Msg-&gt;dataA[3])&lt;&lt;24);
-//		CANx-&gt;TDA3 = *((uint32_t *) &amp;(CAN_Msg-&gt;dataA));
-		CANx-&gt;TDA3 = data;
-
-		/*Write second 4 data bytes*/
-		data = (CAN_Msg-&gt;dataB[0])|(((CAN_Msg-&gt;dataB[1]))&lt;&lt;8)|((CAN_Msg-&gt;dataB[2])&lt;&lt;16)|((CAN_Msg-&gt;dataB[3])&lt;&lt;24);
-//		CANx-&gt;TDB3 = *((uint32_t *) &amp;(CAN_Msg-&gt;dataB));
-		CANx-&gt;TDB3 = data;
-
-		/*Write transmission request*/
-		CANx-&gt;CMR = 0x81;
-		return SUCCESS;
-	}
-	else
-	{
-		return ERROR;
-	}
-}
-
-/********************************************************************//**
- * @brief		Receive message data
- * @param[in]	CANx pointer to CAN_TypeDef, should be:
- * 				- CAN1: CAN 1
- * 				- CAN2: CAN 2
- * @param[in]	CAN_Msg point to the CAN_MSG_Type Struct, it will contain received
- *  			message information such as: ID, DLC, RTR, ID Format
- * @return 		Status:
- * 				- SUCCESS: receive message successfully
- * 				- ERROR: receive message unsuccessfully
- *********************************************************************/
-Status CAN_ReceiveMsg (CAN_TypeDef *CANx, CAN_MSG_Type *CAN_Msg)
-{
-	uint32_t data;
-
-	CHECK_PARAM(PARAM_CANx(CANx));
-
-	//check status of Receive Buffer
-	if((CANx-&gt;SR &amp;0x00000001))
-	{
-		/* Receive message is available */
-		/* Read frame informations */
-		CAN_Msg-&gt;format   = (uint8_t)(((CANx-&gt;RFS) &amp; 0x80000000)&gt;&gt;31);
-		CAN_Msg-&gt;type     = (uint8_t)(((CANx-&gt;RFS) &amp; 0x40000000)&gt;&gt;30);
-		CAN_Msg-&gt;len      = (uint8_t)(((CANx-&gt;RFS) &amp; 0x000F0000)&gt;&gt;16);
-
-
-		/* Read CAN message identifier */
-		CAN_Msg-&gt;id = CANx-&gt;RID;
-
-		/* Read the data if received message was DATA FRAME */
-		if (CAN_Msg-&gt;type == DATA_FRAME)
-		{
-			/* Read first 4 data bytes */
-//			*((uint32_t *) &amp;CAN_Msg-&gt;dataA) = CANx-&gt;RDA;
-			data = CANx-&gt;RDA;
-			*((uint8_t *) &amp;CAN_Msg-&gt;dataA[0])= data &amp; 0x000000FF;
-			*((uint8_t *) &amp;CAN_Msg-&gt;dataA[1])= (data &amp; 0x0000FF00)&gt;&gt;8;;
-			*((uint8_t *) &amp;CAN_Msg-&gt;dataA[2])= (data &amp; 0x00FF0000)&gt;&gt;16;
-			*((uint8_t *) &amp;CAN_Msg-&gt;dataA[3])= (data &amp; 0xFF000000)&gt;&gt;24;
-
-			/* Read second 4 data bytes */
-//			*((uint32_t *) &amp;CAN_Msg-&gt;dataB) = CANx-&gt;RDB;
-			data = CANx-&gt;RDB;
-			*((uint8_t *) &amp;CAN_Msg-&gt;dataB[0])= data &amp; 0x000000FF;
-			*((uint8_t *) &amp;CAN_Msg-&gt;dataB[1])= (data &amp; 0x0000FF00)&gt;&gt;8;
-			*((uint8_t *) &amp;CAN_Msg-&gt;dataB[2])= (data &amp; 0x00FF0000)&gt;&gt;16;
-			*((uint8_t *) &amp;CAN_Msg-&gt;dataB[3])= (data &amp; 0xFF000000)&gt;&gt;24;
-
-		/*release receive buffer*/
-		CANx-&gt;CMR = 0x04;
-		}
-		else
-		{
-			/* Received Frame is a Remote Frame, not have data, we just receive
-			 * message information only */
-			return SUCCESS;
-		}
-	}
-	else
-	{
-		// no receive message available
-		return ERROR;
-	}
-	return SUCCESS;
-}
-
-/********************************************************************//**
- * @brief		Receive FullCAN Object
- * @param[in]	CANx pointer to CAN_TypeDef, should be:
- * 				- CAN1: CAN 1
- * 				- CAN2: CAN 2
- * @param[in]	CAN_Msg point to the CAN_MSG_Type Struct, it will contain received
- *  			message information such as: ID, DLC, RTR, ID Format
- * @return 		CAN_ERROR, could be:
- * 				- CAN_FULL_OBJ_NOT_RCV: FullCAN Object is not be received
- * 				- CAN_OK: Received FullCAN Object successful
- *
- *********************************************************************/
-CAN_ERROR FCAN_ReadObj (CANAF_TypeDef* CANAFx, CAN_MSG_Type *CAN_Msg)
-{
-	uint32_t *pSrc, data;
-	uint32_t interrut_word, msg_idx, test_bit, head_idx, tail_idx;
-
-	CHECK_PARAM(PARAM_CANAFx(CANAFx));
-
-	interrut_word = 0;
-
-	if (CANAF-&gt;FCANIC0 != 0)
-	{
-		interrut_word = CANAF-&gt;FCANIC0;
-		head_idx = 0;
-		tail_idx = 31;
-	}
-	else if (CANAF-&gt;FCANIC1 != 0)
-	{
-		interrut_word = CANAF-&gt;FCANIC1;
-		head_idx = 32;
-		tail_idx = 63;
-	}
-
-	if (interrut_word != 0)
-	{
-		/* Detect for interrupt pending */
-		msg_idx = 0;
-		for (msg_idx = head_idx; msg_idx &lt;= tail_idx; msg_idx++)
-		{
-			test_bit = interrut_word &amp; 0x1;
-			interrut_word = interrut_word &gt;&gt; 1;
-
-			if (test_bit)
-			{
-				pSrc = (uint32_t *) (CANAF-&gt;ENDofTable + CANAF_RAM_BASE + msg_idx * 12);
-
-	    	 	/* Has been finished updating the content */
-	    	 	if ((*pSrc &amp; 0x03000000L) == 0x03000000L)
-	    	 	{
-	    	 		/*clear semaphore*/
-	    	 		*pSrc &amp;= 0xFCFFFFFF;
-
-	    	 		/*Set to DatA*/
-	    	 		pSrc++;
-	    	 		/* Copy to dest buf */
-//	    	 		*((uint32_t *) &amp;CAN_Msg-&gt;dataA) = *pSrc;
-	    	 		data = *pSrc;
-	    			*((uint8_t *) &amp;CAN_Msg-&gt;dataA[0])= data &amp; 0x000000FF;
-	    			*((uint8_t *) &amp;CAN_Msg-&gt;dataA[1])= (data &amp; 0x0000FF00)&gt;&gt;8;
-	    			*((uint8_t *) &amp;CAN_Msg-&gt;dataA[2])= (data &amp; 0x00FF0000)&gt;&gt;16;
-	    			*((uint8_t *) &amp;CAN_Msg-&gt;dataA[3])= (data &amp; 0xFF000000)&gt;&gt;24;
-
-	    	 		/*Set to DatB*/
-	    	 		pSrc++;
-	    	 		/* Copy to dest buf */
-//	    	 		*((uint32_t *) &amp;CAN_Msg-&gt;dataB) = *pSrc;
-	    	 		data = *pSrc;
-	    			*((uint8_t *) &amp;CAN_Msg-&gt;dataB[0])= data &amp; 0x000000FF;
-	    			*((uint8_t *) &amp;CAN_Msg-&gt;dataB[1])= (data &amp; 0x0000FF00)&gt;&gt;8;
-	    			*((uint8_t *) &amp;CAN_Msg-&gt;dataB[2])= (data &amp; 0x00FF0000)&gt;&gt;16;
-	    			*((uint8_t *) &amp;CAN_Msg-&gt;dataB[3])= (data &amp; 0xFF000000)&gt;&gt;24;
-	    	 		/*Back to Dat1*/
-	    	 		pSrc -= 2;
-
-	    	 		CAN_Msg-&gt;id = *pSrc &amp; 0x7FF;
-	    	 		CAN_Msg-&gt;len = (uint8_t) (*pSrc &gt;&gt; 16) &amp; 0x0F;
-					CAN_Msg-&gt;format = 0; //FullCAN Object ID always is 11-bit value
-					CAN_Msg-&gt;type = (uint8_t)(*pSrc &gt;&gt; 30) &amp;0x01;
-	    	 		/*Re-read semaphore*/
-	    	 		if ((*pSrc &amp; 0x03000000L) == 0)
-	    	 		{
-	    	 			return CAN_OK;
-	    	 		}
-	    	 	}
-			}
-		}
-	}
-	return CAN_FULL_OBJ_NOT_RCV;
-}
-/********************************************************************//**
- * @brief		Get CAN Control Status
- * @param[in]	CANx pointer to CAN_TypeDef, should be:
- * 				- CAN1: CAN 1
- * 				- CAN2: CAN 2
- * @param[in]	arg: type of CAN status to get from CAN status register
- * 				Should be:
- * 				- CANCTRL_GLOBAL_STS: CAN Global Status
- * 				- CANCTRL_INT_CAP: CAN Interrupt and Capture
- * 				- CANCTRL_ERR_WRN: CAN Error Warning Limit
- * 				- CANCTRL_STS: CAN Control Status
- * @return 		Current Control Status that you want to get value
- *********************************************************************/
-uint32_t CAN_GetCTRLStatus (CAN_TypeDef* CANx, CAN_CTRL_STS_Type arg)
-{
-	CHECK_PARAM(PARAM_CANx(CANx));
-	CHECK_PARAM(PARAM_CTRL_STS_TYPE(arg));
-
-	switch (arg)
-	{
-	case CANCTRL_GLOBAL_STS:
-		return CANx-&gt;GSR;
-
-	case CANCTRL_INT_CAP:
-		return CANx-&gt;ICR;
-
-	case CANCTRL_ERR_WRN:
-		return CANx-&gt;EWL;
-
-	default: // CANCTRL_STS
-		return CANx-&gt;SR;
-	}
-}
-/********************************************************************//**
- * @brief		Get CAN Central Status
- * @param[in]	CANCRx point to CANCR_TypeDef
- * @param[in]	arg: type of CAN status to get from CAN Central status register
- * 				Should be:
- * 				- CANCR_TX_STS: Central CAN Tx Status
- * 				- CANCR_RX_STS: Central CAN Rx Status
- * 				- CANCR_MS: Central CAN Miscellaneous Status
- * @return 		Current Central Status that you want to get value
- *********************************************************************/
-uint32_t CAN_GetCRStatus (CANCR_TypeDef* CANCRx, CAN_CR_STS_Type arg)
-{
-	CHECK_PARAM(PARAM_CANCRx(CANCRx));
-	CHECK_PARAM(PARAM_CR_STS_TYPE(arg));
-
-	switch (arg)
-	{
-	case CANCR_TX_STS:
-		return CANCRx-&gt;CANTxSR;
-
-	case CANCR_RX_STS:
-		return CANCRx-&gt;CANRxSR;
-
-	default:	// CANCR_MS
-		return CANCRx-&gt;CANMSR;
-	}
-}
-/********************************************************************//**
- * @brief		Enable/Disable CAN Interrupt
- * @param[in]	CANx pointer to CAN_TypeDef, should be:
- * 				- CAN1: CAN 1
- * 				- CAN2: CAN 2
- * @param[in]	arg: type of CAN interrupt that you want to enable/disable
- * 				Should be:
- * 				- CANINT_RIE: CAN Receiver Interrupt Enable
- * 				- CANINT_TIE1: CAN Transmit Interrupt Enable
- * 				- CANINT_EIE: CAN Error Warning Interrupt Enable
- * 				- CANINT_DOIE: CAN Data Overrun Interrupt Enable
- * 				- CANINT_WUIE: CAN Wake-Up Interrupt Enable
- * 				- CANINT_EPIE: CAN Error Passive Interrupt Enable
- * 				- CANINT_ALIE: CAN Arbitration Lost Interrupt Enable
- * 				- CANINT_BEIE: CAN Bus Error Interrupt Enable
- * 				- CANINT_IDIE: CAN ID Ready Interrupt Enable
- * 				- CANINT_TIE2: CAN Transmit Interrupt Enable for Buffer2
- * 				- CANINT_TIE3: CAN Transmit Interrupt Enable for Buffer3
- * 				- CANINT_FCE: FullCAN Interrupt Enable
- * @param[in]	NewState: New state of this function, should be:
- * 				- ENABLE
- * 				- DISABLE
- * @return 		none
- *********************************************************************/
-void CAN_IRQCmd (CAN_TypeDef* CANx, CAN_INT_EN_Type arg, FunctionalState NewState)
-{
-	CHECK_PARAM(PARAM_CANx(CANx));
-	CHECK_PARAM(PARAM_INT_EN_TYPE(arg));
-	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
-
-	if(NewState == ENABLE)
-	{
-		if(arg==CANINT_FCE)
-		{
-			CANAF-&gt;AFMR = 0x01;
-			CANAF-&gt;FCANIE = 0x01;
-			CANAF-&gt;AFMR = 0x04;
-		}
-		else
-			CANx-&gt;IER |= (1 &lt;&lt; arg);
-	}
-	else
-	{
-		if(arg==CANINT_FCE){
-			CANAF-&gt;AFMR = 0x01;
-			CANAF-&gt;FCANIE = 0x01;
-			CANAF-&gt;AFMR = 0x00;
-		}
-		else
-			CANx-&gt;IER &amp;= ~(1 &lt;&lt; arg);
-	}
-}
-/*********************************************************************//**
- * @brief		Install interrupt call-back function
- * @param[in]	arg: CAN interrupt type, should be:
- * 	  			- CANINT_RIE: CAN Receiver Interrupt Enable
- * 				- CANINT_TIE1: CAN Transmit Interrupt Enable
- * 				- CANINT_EIE: CAN Error Warning Interrupt Enable
- * 				- CANINT_DOIE: CAN Data Overrun Interrupt Enable
- * 				- CANINT_WUIE: CAN Wake-Up Interrupt Enable
- * 				- CANINT_EPIE: CAN Error Passive Interrupt Enable
- * 				- CANINT_ALIE: CAN Arbitration Lost Interrupt Enable
- * 				- CANINT_BEIE: CAN Bus Error Interrupt Enable
- * 				- CANINT_IDIE: CAN ID Ready Interrupt Enable
- * 				- CANINT_TIE2: CAN Transmit Interrupt Enable for Buffer2
- * 				- CANINT_TIE3: CAN Transmit Interrupt Enable for Buffer3
- * 				- CANINT_FCE: FullCAN Interrupt Enable
- * @param[in]	pnCANCbs: pointer point to call-back function
- * @return		None
- **********************************************************************/
-void CAN_SetupCBS(CAN_INT_EN_Type arg,fnCANCbs_Type* pnCANCbs)
-{
-	CHECK_PARAM(PARAM_INT_EN_TYPE(arg));
-	_apfnCANCbs[arg] = pnCANCbs;
-}
-/********************************************************************//**
- * @brief		Setting Acceptance Filter mode
- * @param[in]	CANAFx point to CANAF_TypeDef object, should be: CANAF
- * @param[in]	AFMode: type of AF mode that you want to set, should be:
- * 				- CAN_Normal: Normal mode
- * 				- CAN_AccOff: Acceptance Filter Off Mode
- * 				- CAN_AccBP: Acceptance Fileter Bypass Mode
- * 				- CAN_eFCAN: FullCAN Mode Enhancement
- * @return 		none
- *********************************************************************/
-void CAN_SetAFMode (CANAF_TypeDef* CANAFx, CAN_AFMODE_Type AFMode)
-{
-	CHECK_PARAM(PARAM_CANAFx(CANAFx));
-	CHECK_PARAM(PARAM_AFMODE_TYPE(AFMode));
-
-	switch(AFMode)
-	{
-	case CAN_Normal:
-		CANAFx-&gt;AFMR = 0x00;
-		break;
-	case CAN_AccOff:
-		CANAFx-&gt;AFMR = 0x01;
-		break;
-	case CAN_AccBP:
-		CANAFx-&gt;AFMR = 0x02;
-		break;
-	case CAN_eFCAN:
-		CANAFx-&gt;AFMR = 0x04;
-		break;
-	}
-}
-
-/********************************************************************//**
- * @brief		Enable/Disable CAN Mode
- * @param[in]	CANx pointer to CAN_TypeDef, should be:
- * 				- CAN1: CAN 1
- * 				- CAN2: CAN 2
- * @param[in]	mode: type of CAN mode that you want to enable/disable, should be:
- * 				- CAN_OPERATING_MODE: Normal Operating Mode
- * 				- CAN_RESET_MODE: Reset Mode
- * 				- CAN_LISTENONLY_MODE: Listen Only Mode
- * 				- CAN_SELFTEST_MODE: Self Test Mode
- * 				- CAN_TXPRIORITY_MODE: Transmit Priority Mode
- * 				- CAN_SLEEP_MODE: Sleep Mode
- * 				- CAN_RXPOLARITY_MODE: Receive Polarity Mode
- * 				- CAN_TEST_MODE: Test Mode
- * @param[in]	NewState: New State of this function, should be:
- * 				- ENABLE
- * 				- DISABLE
- * @return 		none
- *********************************************************************/
-void CAN_ModeConfig(CAN_TypeDef* CANx, CAN_MODE_Type mode, FunctionalState NewState)
-{
-	CHECK_PARAM(PARAM_CANx(CANx));
-	CHECK_PARAM(PARAM_MODE_TYPE(mode));
-	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
-
-	switch(mode)
-	{
-	case CAN_OPERATING_MODE:
-		CANx-&gt;MOD = 0x00;
-		break;
-	case CAN_RESET_MODE:
-		if(NewState == ENABLE)
-			CANx-&gt;MOD |=CAN_MOD_RM;
-		else
-			CANx-&gt;MOD &amp;= ~CAN_MOD_RM;
-		break;
-	case CAN_LISTENONLY_MODE:
-		CANx-&gt;MOD |=CAN_MOD_RM;
-		if(NewState == ENABLE)
-			CANx-&gt;MOD |=CAN_MOD_LOM;
-		else
-			CANx-&gt;MOD &amp;=~CAN_MOD_LOM;
-		break;
-	case CAN_SELFTEST_MODE:
-		CANx-&gt;MOD |=CAN_MOD_RM;
-		if(NewState == ENABLE)
-			CANx-&gt;MOD |=CAN_MOD_STM;
-		else
-			CANx-&gt;MOD &amp;=~CAN_MOD_STM;
-		break;
-	case CAN_TXPRIORITY_MODE:
-		if(NewState == ENABLE)
-			CANx-&gt;MOD |=CAN_MOD_TPM;
-		else
-			CANx-&gt;MOD &amp;=~CAN_MOD_TPM;
-		break;
-	case CAN_SLEEP_MODE:
-		if(NewState == ENABLE)
-			CANx-&gt;MOD |=CAN_MOD_SM;
-		else
-			CANx-&gt;MOD &amp;=~CAN_MOD_SM;
-		break;
-	case CAN_RXPOLARITY_MODE:
-		if(NewState == ENABLE)
-			CANx-&gt;MOD |=CAN_MOD_RPM;
-		else
-			CANx-&gt;MOD &amp;=~CAN_MOD_RPM;
-		break;
-	case CAN_TEST_MODE:
-		if(NewState == ENABLE)
-			CANx-&gt;MOD |=CAN_MOD_TM;
-		else
-			CANx-&gt;MOD &amp;=~CAN_MOD_TM;
-		break;
-	}
-}
-/*********************************************************************//**
- * @brief		Standard CAN interrupt handler, this function will check
- * 				all interrupt status of CAN channels, then execute the call
- * 				back function if they're already installed
- * @param[in]	CANx point to CAN peripheral selected, should be: CAN1 or CAN2
- * @return		None
- **********************************************************************/
-void CAN_IntHandler(CAN_TypeDef* CANx)
-{
-	uint8_t t;
-	//scan interrupt pending
-	if(CANAF-&gt;FCANIE)
-	{
-		_apfnCANCbs[11]();
-	}
-	//scan interrupt channels
-	for(t=0;t&lt;11;t++)
-	{
-		if(((CANx-&gt;ICR)&gt;&gt;t)&amp;0x01)
-		{
-			_apfnCANCbs[t]();
-		}
-	}
-}
-
-/**
- * @}
- */
-
-#endif /* _CAN */
-
-/**
- * @}
- */
-
-/* --------------------------------- End Of File ------------------------------ */
+/**
+ * @file	: lpc17xx_can.c
+ * @brief	: Contains all functions support for CAN firmware library on LPC17xx
+ * @version	: 1.0
+ * @date	: 1.June.2009
+ * @author	: NguyenCao
+ **************************************************************************
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * products. This software is supplied &quot;AS IS&quot; without any warranties.
+ * NXP Semiconductors assumes no responsibility or liability for the
+ * use of the software, conveys no license or title under any patent,
+ * copyright, or mask work right to the product. NXP Semiconductors
+ * reserves the right to make changes in the software without
+ * notification. NXP Semiconductors also make no representation or
+ * warranty that such application will be suitable for the specified
+ * use without further testing or modification.
+ **********************************************************************/
+
+/* Peripheral group ----------------------------------------------------------- */
+/** @addtogroup CAN
+ * @{
+ */
+
+/* Includes ------------------------------------------------------------------- */
+#include &quot;lpc17xx_can.h&quot;
+#include &quot;lpc17xx_clkpwr.h&quot;
+
+/* If this source file built with example, the LPC17xx FW library configuration
+ * file in each example directory (&quot;lpc17xx_libcfg.h&quot;) must be included,
+ * otherwise the default FW library configuration file must be included instead
+ */
+#ifdef __BUILD_WITH_EXAMPLE__
+#include &quot;lpc17xx_libcfg.h&quot;
+#else
+#include &quot;lpc17xx_libcfg_default.h&quot;
+#endif /* __BUILD_WITH_EXAMPLE__ */
+
+
+#ifdef _CAN
+
+/* Private Variables ---------------------------------------------------------- */
+/** @defgroup CAN_Private_Variables
+ * @{
+ */
+
+FunctionalState FULLCAN_ENABLE;
+
+//use for debugging
+LPC_CAN_TypeDef *CAN1x = LPC_CAN1;
+LPC_CAN_TypeDef *CAN2x = LPC_CAN2;
+LPC_CANAF_RAM_TypeDef *CANAFRAMx = LPC_CANAF_RAM;
+LPC_CANAF_TypeDef *CANAFx = LPC_CANAF;
+
+/* Values of bit time register for different baudrates
+   NT = Nominal bit time = TSEG1 + TSEG2 + 3
+   SP = Sample point     = ((TSEG2 +1) / (TSEG1 + TSEG2 + 3)) * 100%
+                                            SAM,  SJW, TSEG1, TSEG2, NT,  SP */
+const uint32_t CAN_BIT_TIME[] ={0, /*             not used             */
+0, /*             not used             */
+0, /*             not used             */
+0, /*             not used             */
+0x0001C000, /* 0+1,  3+1,   1+1,   0+1,  4, 75% */
+0, /*             not used             */
+0x0012C000, /* 0+1,  3+1,   2+1,   1+1,  6, 67% */
+0, /*             not used             */
+0x0023C000, /* 0+1,  3+1,   3+1,   2+1,  8, 63% */
+0, /*             not used             */
+0x0025C000, /* 0+1,  3+1,   5+1,   2+1, 10, 70% */
+0, /*             not used             */
+0x0036C000, /* 0+1,  3+1,   6+1,   3+1, 12, 67% */
+0, /*             not used             */
+0, /*             not used             */
+0x0048C000, /* 0+1,  3+1,   8+1,   4+1, 15, 67% */
+0x0049C000, /* 0+1,  3+1,   9+1,   4+1, 16, 69% */
+};
+
+/* Counts number of filters (CAN message objects) used */
+uint16_t CANAF_FullCAN_cnt = 0;
+uint16_t CANAF_std_cnt = 0;
+uint16_t CANAF_gstd_cnt = 0;
+uint16_t CANAF_ext_cnt = 0;
+uint16_t CANAF_gext_cnt = 0;
+
+static fnCANCbs_Type* _apfnCANCbs[12]={
+		NULL, 	//CAN Recieve  Call-back funtion pointer
+		NULL,	//CAN Transmit1 Call-back funtion pointer
+		NULL,	//CAN Error Warning Call-back function pointer
+		NULL,	//CAN Data Overrun Call-back function pointer
+		NULL,	//CAN Wake-up Call-back funtion pointer
+		NULL,	//CAN Error Passive Call-back function pointer
+		NULL,	//CAN Arbitration Lost Call-back function pointer
+		NULL,	//CAN Bus Error Call-back function pointer
+		NULL,	//CAN ID Ready Call-back function pointer
+		NULL,	//CAN Transmit2 Call-back function pointer
+		NULL,	//CAN Transmit3 Call-back function pointer
+		NULL	//FullCAN Receive Call-back function pointer
+};
+
+/**
+ * @}
+ */
+
+
+/* Public Functions ----------------------------------------------------------- */
+/** @addtogroup CAN_Public_Functions
+ * @{
+ */
+
+
+/*********************************************************************//**
+ * @brief 		Setting CAN baud rate (bps)
+ * @param[in] 	CANx point to LPC_CAN_TypeDef object, should be:
+ * 				- CAN1
+ * 				- CAN2
+ * @param[in]	baudrate is the baud rate value will be set
+ * @return 		None
+ ***********************************************************************/
+void CAN_SetBaudRate (LPC_CAN_TypeDef *CANx, uint32_t baudrate)
+{
+	uint32_t nominal_time;
+	uint32_t result = 0;
+	uint32_t CANPclk = 0;
+
+	CHECK_PARAM(PARAM_CANx(CANx));
+
+	if (CANx == LPC_CAN1)
+	{
+		CANPclk = CLKPWR_GetPCLK (CLKPWR_PCONP_PCAN1);
+	}
+	else
+	{
+		CANPclk = CLKPWR_GetPCLK (CLKPWR_PCONP_PCAN2);
+	}
+	/* Determine which nominal time to use for PCLK and baudrate */
+	if (baudrate &lt;= 500000)
+	{
+		nominal_time = 12;
+	}
+	else if (((CANPclk / 1000000) % 15) == 0)
+	{
+		nominal_time = 15;
+	}
+	else if (((CANPclk / 1000000) % 16) == 0)
+	{
+		nominal_time = 16;
+	}
+	else
+	{
+		nominal_time = 10;
+	}
+
+	/* Prepare value appropriate for bit time register                         */
+	result  = (CANPclk / nominal_time) / baudrate - 1;
+	result &amp;= 0x000003FF;
+	result |= CAN_BIT_TIME[nominal_time];
+
+	/* Enter reset mode */
+	CANx-&gt;MOD = 0x01;
+	/* Set bit timing */
+	CANx-&gt;BTR  = result;
+
+	/* Return to normal operating */
+	CANx-&gt;MOD = 0;
+}
+
+/********************************************************************//**
+ * @brief		Initialize CAN peripheral with given baudrate
+ * @param[in]	CANx pointer to LPC_CAN_TypeDef, should be:
+ * 				- CAN1: CAN 1
+ * 				- CAN2: CAN 2
+ * @param[in]	baudrate: the value of CAN baudrate will be set (bps)
+ * @return 		void
+ *********************************************************************/
+void CAN_Init(LPC_CAN_TypeDef *CANx, uint32_t baudrate)
+{
+	uint32_t temp;
+	uint16_t i;
+	CHECK_PARAM(PARAM_CANx(CANx));
+
+	if(CANx == LPC_CAN1)
+	{
+		/* Turn on power and clock for CAN1 */
+		CLKPWR_ConfigPPWR(CLKPWR_PCONP_PCAN1, ENABLE);
+		/* Set clock divide for CAN1 */
+		CLKPWR_SetPCLKDiv (CLKPWR_PCONP_PCAN1, CLKPWR_PCLKSEL_CCLK_DIV_4);
+	}
+	else
+	{
+		/* Turn on power and clock for CAN1 */
+		CLKPWR_ConfigPPWR(CLKPWR_PCONP_PCAN2, ENABLE);
+		/* Set clock divide for CAN2 */
+		CLKPWR_SetPCLKDiv (CLKPWR_PCONP_PCAN2, CLKPWR_PCLKSEL_CCLK_DIV_4);
+	}
+
+	CANx-&gt;MOD = 1; // Enter Reset Mode
+	CANx-&gt;IER = 0; // Disable All CAN Interrupts
+	CANx-&gt;GSR = 0;
+	/* Request command to release Rx, Tx buffer and clear data overrun */
+	//CANx-&gt;CMR = CAN_CMR_AT | CAN_CMR_RRB | CAN_CMR_CDO;
+	CANx-&gt;CMR = (1&lt;&lt;1)|(1&lt;&lt;2)|(1&lt;&lt;3);
+	/* Read to clear interrupt pending in interrupt capture register */
+	temp = CANx-&gt;ICR;
+	CANx-&gt;MOD = 0;// Return Normal operating
+
+	//Reset CANAF value
+	LPC_CANAF-&gt;AFMR = 0x01;
+
+	//clear ALUT RAM
+	for (i = 0; i &lt; 512; i++) {
+		LPC_CANAF_RAM-&gt;mask[i] = 0x00;
+	}
+
+	LPC_CANAF-&gt;SFF_sa = 0x00;
+	LPC_CANAF-&gt;SFF_GRP_sa = 0x00;
+	LPC_CANAF-&gt;EFF_sa = 0x00;
+	LPC_CANAF-&gt;EFF_GRP_sa = 0x00;
+	LPC_CANAF-&gt;ENDofTable = 0x00;
+
+	LPC_CANAF-&gt;AFMR = 0x00;
+	/* Set baudrate */
+	CAN_SetBaudRate (CANx, baudrate);
+}
+/********************************************************************//**
+ * @brief		CAN deInit
+ * @param[in]	CANx pointer to LPC_CAN_TypeDef, should be:
+ * 				- CAN1: CAN 1
+ * 				- CAN2: CAN 2
+ * @return 		void
+ *********************************************************************/
+void CAN_DeInit(LPC_CAN_TypeDef *CANx)
+{
+	CHECK_PARAM(PARAM_CANx(CANx));
+
+	if(CANx == LPC_CAN1)
+	{
+		/* Turn on power and clock for CAN1 */
+		CLKPWR_ConfigPPWR(CLKPWR_PCONP_PCAN1, DISABLE);
+	}
+	else
+	{
+		/* Turn on power and clock for CAN1 */
+		CLKPWR_ConfigPPWR(CLKPWR_PCONP_PCAN2, DISABLE);
+	}
+}
+/********************************************************************//**
+ * @brief		Setup Acceptance Filter Look-Up Table
+ * @param[in]	CANAFx	pointer to LPC_CANAF_TypeDef, should be: CANAF
+ * @param[in]	AFSection	the pointer to AF_SectionDef struct
+ * 				It contain information about 5 sections will be install in AFLUT
+ * @return 		CAN Error	could be:
+ * 				- CAN_OBJECTS_FULL_ERROR: No more rx or tx objects available
+ * 				- CAN_AF_ENTRY_ERROR: table error-violation of ascending numerical order
+ * 				- CAN_OK: ID is added into table successfully
+ *********************************************************************/
+CAN_ERROR CAN_SetupAFLUT(LPC_CANAF_TypeDef* CANAFx, AF_SectionDef* AFSection)
+{
+	uint8_t ctrl1,ctrl2;
+	uint8_t dis1, dis2;
+	uint16_t SID, SID_temp,i, count = 0;
+	uint32_t EID, EID_temp, entry, buf;
+	uint16_t lowerSID, upperSID;
+	uint32_t lowerEID, upperEID;
+
+	CHECK_PARAM(PARAM_CANAFx(CANAFx));
+	CANAFx-&gt;AFMR = 0x01;
+
+/***** setup FullCAN Table *****/
+	if(AFSection-&gt;FullCAN_Sec == NULL)
+	{
+		FULLCAN_ENABLE = DISABLE;
+	}
+	else
+	{
+		FULLCAN_ENABLE = ENABLE;
+		for(i=0;i&lt;(AFSection-&gt;FC_NumEntry);i++)
+		{
+			if(count + 1 &gt; 64)
+			{
+				return CAN_OBJECTS_FULL_ERROR;
+			}
+			ctrl1 = AFSection-&gt;FullCAN_Sec-&gt;controller;
+			SID = AFSection-&gt;FullCAN_Sec-&gt;id_11;
+			dis1 = AFSection-&gt;FullCAN_Sec-&gt;disable;
+
+			CHECK_PARAM(PARAM_CTRL(ctrl1));
+			CHECK_PARAM(PARAM_ID_11(SID));
+			CHECK_PARAM(PARAM_MSG_DISABLE(dis1));
+			entry = 0x00; //reset entry value
+			if((CANAF_FullCAN_cnt &amp; 0x00000001)==0)
+			{
+				if(count!=0x00)
+				{
+					buf = LPC_CANAF_RAM-&gt;mask[count-1];
+					SID_temp = (buf &amp; 0x000003FF);
+					if(SID_temp &gt; SID)
+					{
+						return CAN_AF_ENTRY_ERROR;
+					}
+				}
+				entry = (ctrl1&lt;&lt;29)|(dis1&lt;&lt;28)|(SID&lt;&lt;16)|(1&lt;&lt;27);
+				LPC_CANAF_RAM-&gt;mask[count] &amp;= 0x0000FFFF;
+				LPC_CANAF_RAM-&gt;mask[count] |= entry;
+				CANAF_FullCAN_cnt++;
+			}
+			else
+			{
+				buf = LPC_CANAF_RAM-&gt;mask[count];
+				SID_temp = (buf &amp; 0x03FF0000)&gt;&gt;16;
+				if(SID_temp &gt; SID)
+				{
+					return CAN_AF_ENTRY_ERROR;
+				}
+				entry = (ctrl1&lt;&lt;13)|(dis1&lt;&lt;12)|(SID&lt;&lt;0)|(1&lt;&lt;11);
+				LPC_CANAF_RAM-&gt;mask[count] &amp;= 0xFFFF0000;
+				LPC_CANAF_RAM-&gt;mask[count]|= entry;
+				count++;
+				CANAF_FullCAN_cnt++;
+			}
+			AFSection-&gt;FullCAN_Sec = (FullCAN_Entry *)((uint32_t)(AFSection-&gt;FullCAN_Sec)+ sizeof(FullCAN_Entry));
+		}
+	}
+
+/***** Setup Explicit Standard Frame Format Section *****/
+	if(AFSection-&gt;SFF_Sec != NULL)
+	{
+		for(i=0;i&lt;(AFSection-&gt;SFF_NumEntry);i++)
+		{
+			if(count + 1 &gt; 512)
+			{
+				return CAN_OBJECTS_FULL_ERROR;
+			}
+			ctrl1 = AFSection-&gt;SFF_Sec-&gt;controller;
+			SID = AFSection-&gt;SFF_Sec-&gt;id_11;
+			dis1 = AFSection-&gt;SFF_Sec-&gt;disable;
+
+			//check parameter
+			CHECK_PARAM(PARAM_CTRL(ctrl1));
+			CHECK_PARAM(PARAM_ID_11(SID));
+			CHECK_PARAM(PARAM_MSG_DISABLE(dis1));
+
+			entry = 0x00; //reset entry value
+			if((CANAF_std_cnt &amp; 0x00000001)==0)
+			{
+				if(CANAF_std_cnt !=0 )
+				{
+					buf = LPC_CANAF_RAM-&gt;mask[count-1];
+					SID_temp = (buf &amp; 0x00000FFF);
+					if(SID_temp &gt; SID)
+					{
+						return CAN_AF_ENTRY_ERROR;
+					}
+				}
+				entry = (ctrl1&lt;&lt;29)|(dis1&lt;&lt;28)|(SID&lt;&lt;16);
+				LPC_CANAF_RAM-&gt;mask[count] &amp;= 0x0000FFFF;
+				LPC_CANAF_RAM-&gt;mask[count] |= entry;
+				CANAF_std_cnt++;
+			}
+			else
+			{
+				buf = LPC_CANAF_RAM-&gt;mask[count];
+				SID_temp = (buf &amp; 0x0FFF0000)&gt;&gt;16;
+				if(SID_temp &gt; SID)
+				{
+					return CAN_AF_ENTRY_ERROR;
+				}
+				entry = (ctrl1&lt;&lt;13)|(dis1&lt;&lt;12)|(SID&lt;&lt;0);
+				LPC_CANAF_RAM-&gt;mask[count] &amp;= 0xFFFF0000;
+				LPC_CANAF_RAM-&gt;mask[count] |= entry;
+				count++;
+				CANAF_std_cnt++;
+			}
+			AFSection-&gt;SFF_Sec = (SFF_Entry *)((uint32_t)(AFSection-&gt;SFF_Sec)+ sizeof(SFF_Entry));
+		}
+	}
+
+/***** Setup Group of Standard Frame Format Identifier Section *****/
+	if(AFSection-&gt;SFF_GPR_Sec != NULL)
+	{
+		for(i=0;i&lt;(AFSection-&gt;SFF_GPR_NumEntry);i++)
+		{
+			if(count + 1 &gt; 512)
+			{
+				return CAN_OBJECTS_FULL_ERROR;
+			}
+			ctrl1 = AFSection-&gt;SFF_GPR_Sec-&gt;controller1;
+			ctrl2 = AFSection-&gt;SFF_GPR_Sec-&gt;controller2;
+			dis1 = AFSection-&gt;SFF_GPR_Sec-&gt;disable1;
+			dis2 = AFSection-&gt;SFF_GPR_Sec-&gt;disable2;
+			lowerSID = AFSection-&gt;SFF_GPR_Sec-&gt;lowerID;
+			upperSID = AFSection-&gt;SFF_GPR_Sec-&gt;upperID;
+
+			/* check parameter */
+			CHECK_PARAM(PARAM_CTRL(ctrl1));
+			CHECK_PARAM(PARAM_CTRL(ctrl2));
+			CHECK_PARAM(PARAM_MSG_DISABLE(dis1));
+			CHECK_PARAM(PARAM_MSG_DISABLE(dis2));
+			CHECK_PARAM(PARAM_ID_11(lowerSID));
+			CHECK_PARAM(PARAM_ID_11(upperSID));
+
+			entry = 0x00;
+			if(CANAF_gstd_cnt!=0)
+			{
+				buf = LPC_CANAF_RAM-&gt;mask[count-1];
+				SID_temp = buf &amp; 0x00000FFF;
+				if(SID_temp &gt; lowerSID)
+				{
+					return CAN_AF_ENTRY_ERROR;
+				}
+			}
+			entry = (ctrl1 &lt;&lt; 29)|(dis1 &lt;&lt; 28)|(lowerSID &lt;&lt; 16)|  \
+					(ctrl2 &lt;&lt; 13)|(dis2 &lt;&lt; 12)|(upperSID &lt;&lt; 0);
+			LPC_CANAF_RAM-&gt;mask[count] = entry;
+			CANAF_gstd_cnt++;
+			count++;
+			AFSection-&gt;SFF_GPR_Sec = (SFF_GPR_Entry *)((uint32_t)(AFSection-&gt;SFF_GPR_Sec)+ sizeof(SFF_GPR_Entry));
+		}
+	}
+
+/***** Setup Explicit Extend Frame Format Identifier Section *****/
+	if(AFSection-&gt;EFF_Sec != NULL)
+	{
+		for(i=0;i&lt;(AFSection-&gt;EFF_NumEntry);i++)
+		{
+			if(count + 1 &gt; 512)
+			{
+				return CAN_OBJECTS_FULL_ERROR;
+			}
+			EID = AFSection-&gt;EFF_Sec-&gt;ID_29;
+			ctrl1 = AFSection-&gt;EFF_Sec-&gt;controller;
+
+			// check parameter
+			CHECK_PARAM(PARAM_ID_29(EID));
+			CHECK_PARAM(PARAM_CTRL(ctrl1));
+
+			entry = 0x00; //reset entry value
+			if(CANAF_ext_cnt != 0)
+			{
+				buf = LPC_CANAF_RAM-&gt;mask[count-1];
+				EID_temp = buf &amp; 0x0FFFFFFF;
+				if(EID_temp &gt; EID)
+				{
+					return CAN_AF_ENTRY_ERROR;
+				}
+			}
+			entry = (ctrl1 &lt;&lt; 29)|(EID &lt;&lt; 0);
+			LPC_CANAF_RAM-&gt;mask[count] = entry;
+			CANAF_ext_cnt ++;
+			count++;
+			AFSection-&gt;EFF_Sec = (EFF_Entry *)((uint32_t)(AFSection-&gt;EFF_Sec)+ sizeof(EFF_Entry));
+		}
+	}
+
+/***** Setup Group of Extended Frame Format Identifier Section *****/
+	if(AFSection-&gt;EFF_GPR_Sec != NULL)
+	{
+		for(i=0;i&lt;(AFSection-&gt;EFF_GPR_NumEntry);i++)
+		{
+			if(count + 2 &gt; 512)
+			{
+				return CAN_OBJECTS_FULL_ERROR;
+			}
+			ctrl1 = AFSection-&gt;EFF_GPR_Sec-&gt;controller1;
+			ctrl2 = AFSection-&gt;EFF_GPR_Sec-&gt;controller2;
+			lowerEID = AFSection-&gt;EFF_GPR_Sec-&gt;lowerEID;
+			upperEID = AFSection-&gt;EFF_GPR_Sec-&gt;upperEID;
+
+			//check parameter
+			CHECK_PARAM(PARAM_CTRL(ctrl1));
+			CHECK_PARAM(PARAM_CTRL(ctrl2));
+			CHECK_PARAM(PARAM_ID_29(lowerEID));
+			CHECK_PARAM(PARAM_ID_29(upperEID));
+
+			entry = 0x00;
+			if(CANAF_gext_cnt != 0)
+			{
+				buf = LPC_CANAF_RAM-&gt;mask[count-1];
+				EID_temp = buf &amp; 0x0FFFFFFF;
+				if(EID_temp &gt; lowerEID)
+				{
+					return CAN_AF_ENTRY_ERROR;
+				}
+			}
+			entry = (ctrl1 &lt;&lt; 29)|(lowerEID &lt;&lt; 0);
+			LPC_CANAF_RAM-&gt;mask[count++] = entry;
+			entry = (ctrl2 &lt;&lt; 29)|(upperEID &lt;&lt; 0);
+			LPC_CANAF_RAM-&gt;mask[count++] = entry;
+			CANAF_gext_cnt++;
+			AFSection-&gt;EFF_GPR_Sec = (EFF_GPR_Entry *)((uint32_t)(AFSection-&gt;EFF_GPR_Sec)+ sizeof(EFF_GPR_Entry));
+		}
+	}
+	//update address values
+	LPC_CANAF-&gt;SFF_sa = ((CANAF_FullCAN_cnt + 1)&gt;&gt;1)&lt;&lt;2;
+	LPC_CANAF-&gt;SFF_GRP_sa = LPC_CANAF-&gt;SFF_sa + (((CANAF_std_cnt+1)&gt;&gt;1)&lt;&lt; 2);
+	LPC_CANAF-&gt;EFF_sa = LPC_CANAF-&gt;SFF_GRP_sa + (CANAF_gstd_cnt &lt;&lt; 2);
+	LPC_CANAF-&gt;EFF_GRP_sa = LPC_CANAF-&gt;EFF_sa + (CANAF_ext_cnt &lt;&lt; 2);
+	LPC_CANAF-&gt;ENDofTable = LPC_CANAF-&gt;EFF_GRP_sa + (CANAF_gext_cnt &lt;&lt; 3);
+
+	if(FULLCAN_ENABLE == DISABLE)
+	{
+		LPC_CANAF-&gt;AFMR = 0x00; // Normal mode
+	}
+	else
+	{
+		LPC_CANAF-&gt;AFMR = 0x04;
+	}
+	return CAN_OK;
+}
+/********************************************************************//**
+ * @brief		Add Explicit ID into AF Look-Up Table dynamically.
+ * @param[in]	CANx pointer to LPC_CAN_TypeDef, should be:
+ * 				- CAN1: CAN 1
+ * 				- CAN2: CAN 2
+ * @param[in]	id: The ID of entry will be added
+ * @param[in]	format: is the type of ID Frame Format, should be:
+ * 				- STD_ID_FORMAT: 11-bit ID value
+ * 				- EXT_ID_FORMAT: 29-bit ID value
+ * @return 		CAN Error, could be:
+ * 				- CAN_OBJECTS_FULL_ERROR: No more rx or tx objects available
+ * 				- CAN_ID_EXIT_ERROR: ID exited in table
+ * 				- CAN_OK: ID is added into table successfully
+ *********************************************************************/
+CAN_ERROR CAN_LoadExplicitEntry(LPC_CAN_TypeDef* CANx, uint32_t id, CAN_ID_FORMAT_Type format)
+{
+	uint32_t tmp0 = 0;
+	uint32_t buf0=0, buf1=0;
+	int16_t cnt1=0, cnt2=0, bound1=0, total=0;
+
+
+	CHECK_PARAM(PARAM_CANx(CANx));
+	CHECK_PARAM(PARAM_ID_FORMAT(format));
+
+	if (CANx == LPC_CAN1)
+	{
+		tmp0 = 0;
+	}
+	else if (CANx == LPC_CAN2)
+	{
+		tmp0 = 1;
+	}
+
+	/* Acceptance Filter Memory full - return */
+	total =((CANAF_FullCAN_cnt+1)&gt;&gt;1)+ CANAF_FullCAN_cnt*3 +((CANAF_std_cnt + 1) &gt;&gt; 1)+  \
+			CANAF_gstd_cnt + CANAF_ext_cnt + (CANAF_gext_cnt&lt;&lt;1);
+	if (total &gt;= 512){ //don't have enough space
+		return CAN_OBJECTS_FULL_ERROR;
+	}
+
+	/* Setup Acceptance Filter Configuration
+    Acceptance Filter Mode Register = Off */
+	LPC_CANAF-&gt;AFMR = 0x00000001;
+
+/*********** Add Explicit Standard Identifier Frame Format entry *********/
+ 	if(format == STD_ID_FORMAT)
+ 	{
+ 		id &amp;= 0x07FF;
+ 		id |= (tmp0 &lt;&lt; 13); /* Add controller number */
+		/* Move all remaining sections one place up
+		if new entry will increase FullCAN list */
+		if ((CANAF_std_cnt &amp; 0x0001) == 0)
+		{
+			cnt1   = ((CANAF_FullCAN_cnt+1)&gt;&gt;1)+((CANAF_std_cnt+1)&gt;&gt;1);
+			bound1 = total - cnt1;
+			buf0   = LPC_CANAF_RAM-&gt;mask[cnt1];
+			while(bound1--)
+			{
+				cnt1++;
+				buf1 = LPC_CANAF_RAM-&gt;mask[cnt1];
+				LPC_CANAF_RAM-&gt;mask[cnt1] = buf0;
+				buf0 = buf1;
+			}
+		}
+		if (CANAF_std_cnt == 0)
+		{
+			cnt2 = (CANAF_FullCAN_cnt + 1)&gt;&gt;1;
+			/* For entering first ID */
+			LPC_CANAF_RAM-&gt;mask[cnt2] = 0x0000FFFF | (id &lt;&lt; 16);
+		}
+		else if (CANAF_std_cnt == 1)
+		{
+			cnt2 = (CANAF_FullCAN_cnt + 1)&gt;&gt;1;
+			/* For entering second ID */
+			if ((LPC_CANAF_RAM-&gt;mask[cnt2] &gt;&gt; 16) &gt; id)
+			{
+				LPC_CANAF_RAM-&gt;mask[cnt2] = (LPC_CANAF_RAM-&gt;mask[cnt2] &gt;&gt; 16) | (id &lt;&lt; 16);
+			}
+			else
+			{
+				LPC_CANAF_RAM-&gt;mask[cnt2] = (LPC_CANAF_RAM-&gt;mask[cnt2] &amp; 0xFFFF0000) | id;
+			}
+		}
+		else
+		{
+			/* Find where to insert new ID */
+			cnt1 = (CANAF_FullCAN_cnt+1)&gt;&gt;1;
+			cnt2 = CANAF_std_cnt;
+			bound1 = ((CANAF_FullCAN_cnt+1)&gt;&gt;1)+((CANAF_std_cnt+1)&gt;&gt;1);
+			while (cnt1 &lt; bound1)
+			{
+				/* Loop through standard existing IDs */
+				if ((LPC_CANAF_RAM-&gt;mask[cnt1] &gt;&gt; 16) &gt; id)
+				{
+					cnt2 = cnt1 * 2;
+					break;
+				}
+
+				if ((LPC_CANAF_RAM-&gt;mask[cnt1] &amp; 0x0000FFFF) &gt; id)
+				{
+					cnt2 = cnt1 * 2 + 1;
+					break;
+				}
+
+				cnt1++;
+			}
+			/* cnt1 = U32 where to insert new ID */
+			/* cnt2 = U16 where to insert new ID */
+
+			if (cnt1 == bound1)
+			{
+				/* Adding ID as last entry */
+				/* Even number of IDs exists */
+				if ((CANAF_std_cnt &amp; 0x0001) == 0)
+				{
+					LPC_CANAF_RAM-&gt;mask[cnt1]  = 0x0000FFFF | (id &lt;&lt; 16);
+				}
+				/* Odd  number of IDs exists */
+				else
+				{
+					LPC_CANAF_RAM-&gt;mask[cnt1]  = (LPC_CANAF_RAM-&gt;mask[cnt1] &amp; 0xFFFF0000) | id;
+				}
+			}
+			else
+			{
+				buf0 = LPC_CANAF_RAM-&gt;mask[cnt1]; /* Remember current entry */
+				if ((cnt2 &amp; 0x0001) == 0)
+				{
+					/* Insert new mask to even address*/
+					buf1 = (id &lt;&lt; 16) | (buf0 &gt;&gt; 16);
+				}
+				else
+				{
+					/* Insert new mask to odd  address */
+					buf1 = (buf0 &amp; 0xFFFF0000) | id;
+				}
+				LPC_CANAF_RAM-&gt;mask[cnt1] = buf1;/* Insert mask */
+				bound1 = ((CANAF_FullCAN_cnt+1)&gt;&gt;1)+((CANAF_std_cnt+1)&gt;&gt;1)-1;
+				/* Move all remaining standard mask entries one place up */
+				while (cnt1 &lt; bound1)
+				{
+					cnt1++;
+					buf1  = LPC_CANAF_RAM-&gt;mask[cnt1];
+					LPC_CANAF_RAM-&gt;mask[cnt1] = (buf1 &gt;&gt; 16) | (buf0 &lt;&lt; 16);
+					buf0  = buf1;
+				}
+
+				if ((CANAF_std_cnt &amp; 0x0001) == 0)
+				{
+					/* Even number of IDs exists */
+					LPC_CANAF_RAM-&gt;mask[cnt1+1] = (buf0 &lt;&lt;16) |(0x0000FFFF);
+				}
+			}
+		}
+		CANAF_std_cnt++;
+		//update address values
+		LPC_CANAF-&gt;SFF_GRP_sa +=0x04 ;
+		LPC_CANAF-&gt;EFF_sa     +=0x04 ;
+		LPC_CANAF-&gt;EFF_GRP_sa +=0x04;
+		LPC_CANAF-&gt;ENDofTable +=0x04;
+ 	}
+
+/*********** Add Explicit Extended Identifier Frame Format entry *********/
+ 	else
+ 	{
+ 		/* Add controller number */
+ 		id |= (tmp0) &lt;&lt; 29;
+
+ 		cnt1 = ((CANAF_FullCAN_cnt+1)&gt;&gt;1)+(((CANAF_std_cnt + 1) &gt;&gt; 1) + CANAF_gstd_cnt);
+ 		cnt2 = 0;
+ 		while (cnt2 &lt; CANAF_ext_cnt)
+ 		{
+ 			/* Loop through extended existing masks*/
+ 			if (LPC_CANAF_RAM-&gt;mask[cnt1] &gt; id)
+ 			{
+ 				break;
+ 			}
+ 			cnt1++;/* cnt1 = U32 where to insert new mask */
+			cnt2++;
+ 		}
+
+ 		buf0 = LPC_CANAF_RAM-&gt;mask[cnt1];  /* Remember current entry */
+ 		LPC_CANAF_RAM-&gt;mask[cnt1] = id;    /* Insert mask */
+
+ 		CANAF_ext_cnt++;
+
+ 		bound1 = total;
+ 		/* Move all remaining extended mask entries one place up*/
+ 		while (cnt2 &lt; bound1)
+ 		{
+ 			cnt1++;
+ 			cnt2++;
+ 			buf1 = LPC_CANAF_RAM-&gt;mask[cnt1];
+ 			LPC_CANAF_RAM-&gt;mask[cnt1] = buf0;
+ 			buf0 = buf1;
+ 		}
+ 		/* update address values */
+ 		LPC_CANAF-&gt;EFF_GRP_sa += 4;
+ 		LPC_CANAF-&gt;ENDofTable += 4;
+ 	}
+ 	if(CANAF_FullCAN_cnt == 0) //not use FullCAN mode
+ 	{
+ 		LPC_CANAF-&gt;AFMR = 0x00;//not use FullCAN mode
+ 	}
+ 	else
+ 	{
+ 		LPC_CANAF-&gt;AFMR = 0x04;
+ 	}
+
+ 	return CAN_OK;
+}
+
+/********************************************************************//**
+ * @brief		Load FullCAN entry into AFLUT
+ * @param[in]	CANx: CAN peripheral selected, should be:
+ * 				- CAN1: CAN 1
+ * 				- CAN2: CAN 2
+ * @param[in]	id: identifier of entry that will be added
+ * @return 		CAN_ERROR, could be:
+ * 				- CAN_OK: loading is successful
+ * 				- CAN_ID_EXIT_ERROR: ID exited in FullCAN Section
+ * 				- CAN_OBJECTS_FULL_ERROR: no more space available
+ *********************************************************************/
+CAN_ERROR CAN_LoadFullCANEntry (LPC_CAN_TypeDef* CANx, uint16_t id)
+{
+	uint32_t ctrl0 = 0;
+	uint32_t buf0=0, buf1=0, buf2=0;
+	uint32_t tmp0=0, tmp1=0, tmp2=0;
+	int16_t cnt1=0, cnt2=0, bound1=0, total=0;
+
+	CHECK_PARAM(PARAM_CANx(CANx));
+
+	if (CANx == LPC_CAN1)
+	{
+		ctrl0 = 0;
+	}
+	else if (CANx == LPC_CAN2)
+	{
+		ctrl0 = 1;
+	}
+
+	/* Acceptance Filter Memory full - return */
+	total =((CANAF_FullCAN_cnt+1)&gt;&gt;1)+ CANAF_FullCAN_cnt*3 +((CANAF_std_cnt + 1) &gt;&gt; 1)+  \
+			CANAF_gstd_cnt + CANAF_ext_cnt + (CANAF_gext_cnt&lt;&lt;1);
+	//don't have enough space for this fullCAN Entry and its Object(3*32 bytes)
+	if ((total &gt;=508)||(CANAF_FullCAN_cnt&gt;=64)){
+		return CAN_OBJECTS_FULL_ERROR;
+	}
+	/* Setup Acceptance Filter Configuration
+    Acceptance Filter Mode Register = Off */
+	LPC_CANAF-&gt;AFMR = 0x00000001;
+
+	/* Add mask for standard identifiers   */
+	id &amp;= 0x07FF;
+	id |= (ctrl0 &lt;&lt; 13) | (1 &lt;&lt; 11); /* Add controller number */
+//	total = ((CANAF_std_cnt + 1) &gt;&gt; 1)+ CANAF_gstd_cnt + CANAF_ext_cnt + (CANAF_gext_cnt&lt;&lt;1);
+	/* Move all remaining sections one place up
+	if new entry will increase FullCAN list */
+	if (((CANAF_FullCAN_cnt &amp; 0x0001) == 0)&amp;&amp;(total!=0))
+	{
+		//then remove remaining section
+		cnt1   = (CANAF_FullCAN_cnt &gt;&gt; 1);
+		bound1 = total;
+		buf0   = LPC_CANAF_RAM-&gt;mask[cnt1];
+
+		while (bound1--)
+		{
+			cnt1++;
+			buf1 = LPC_CANAF_RAM-&gt;mask[cnt1];
+			LPC_CANAF_RAM-&gt;mask[cnt1] = buf0;
+			buf0 = buf1;
+		}
+	}
+	if (CANAF_FullCAN_cnt == 0)
+	{
+		/* For entering first ID */
+		LPC_CANAF_RAM-&gt;mask[0] = 0x0000FFFF | (id &lt;&lt; 16);
+	}
+	else if (CANAF_FullCAN_cnt == 1)
+	{
+		/* For entering second ID */
+		if ((LPC_CANAF_RAM-&gt;mask[0] &gt;&gt; 16) &gt; id)
+		{
+			LPC_CANAF_RAM-&gt;mask[0] = (LPC_CANAF_RAM-&gt;mask[0] &gt;&gt; 16) | (id &lt;&lt; 16);
+		}
+		else
+		{
+			LPC_CANAF_RAM-&gt;mask[0] = (LPC_CANAF_RAM-&gt;mask[0] &amp; 0xFFFF0000) | id;
+		}
+	}
+	else
+	{
+		/* Find where to insert new ID */
+		cnt1 = 0;
+		cnt2 = CANAF_FullCAN_cnt;
+		bound1 = (CANAF_FullCAN_cnt - 1) &gt;&gt; 1;
+		while (cnt1 &lt;= bound1)
+		{
+			/* Loop through standard existing IDs */
+			if ((LPC_CANAF_RAM-&gt;mask[cnt1] &gt;&gt; 16) &gt; id)
+			{
+				cnt2 = cnt1 * 2;
+				break;
+			}
+
+			if ((LPC_CANAF_RAM-&gt;mask[cnt1] &amp; 0x0000FFFF) &gt; id)
+			{
+				cnt2 = cnt1 * 2 + 1;
+				break;
+			}
+
+			cnt1++;
+		}
+		/* cnt1 = U32 where to insert new ID */
+		/* cnt2 = U16 where to insert new ID */
+
+		if (cnt1 &gt; bound1)
+		{
+			/* Adding ID as last entry */
+			/* Even number of IDs exists */
+			if ((CANAF_FullCAN_cnt &amp; 0x0001) == 0)
+			{
+				LPC_CANAF_RAM-&gt;mask[cnt1]  = 0x0000FFFF | (id &lt;&lt; 16);
+			}
+			/* Odd  number of IDs exists */
+			else
+			{
+				LPC_CANAF_RAM-&gt;mask[cnt1]  = (LPC_CANAF_RAM-&gt;mask[cnt1] &amp; 0xFFFF0000) | id;
+			}
+		}
+		else
+		{
+			buf0 = LPC_CANAF_RAM-&gt;mask[cnt1]; /* Remember current entry */
+			if ((cnt2 &amp; 0x0001) == 0)
+			{
+				/* Insert new mask to even address*/
+				buf1 = (id &lt;&lt; 16) | (buf0 &gt;&gt; 16);
+			}
+			else
+			{
+				/* Insert new mask to odd  address */
+				buf1 = (buf0 &amp; 0xFFFF0000) | id;
+			}
+			LPC_CANAF_RAM-&gt;mask[cnt1] = buf1;/* Insert mask */
+			bound1 = CANAF_FullCAN_cnt &gt;&gt; 1;
+			/* Move all remaining standard mask entries one place up */
+			while (cnt1 &lt; bound1)
+			{
+				cnt1++;
+				buf1  = LPC_CANAF_RAM-&gt;mask[cnt1];
+				LPC_CANAF_RAM-&gt;mask[cnt1] = (buf1 &gt;&gt; 16) | (buf0 &lt;&lt; 16);
+				buf0  = buf1;
+			}
+
+			if ((CANAF_FullCAN_cnt &amp; 0x0001) == 0)
+			{
+				/* Even number of IDs exists */
+				LPC_CANAF_RAM-&gt;mask[cnt1] = (LPC_CANAF_RAM-&gt;mask[cnt1] &amp; 0xFFFF0000)
+											| (0x0000FFFF);
+			}
+		}
+	}
+	//restruct FulCAN Object Section
+	bound1 = CANAF_FullCAN_cnt - cnt2;
+	cnt1 = total - (CANAF_FullCAN_cnt)*3 + cnt2*3 + 1;
+	buf0 = LPC_CANAF_RAM-&gt;mask[cnt1];
+	buf1 = LPC_CANAF_RAM-&gt;mask[cnt1+1];
+	buf2 = LPC_CANAF_RAM-&gt;mask[cnt1+2];
+	LPC_CANAF_RAM-&gt;mask[cnt1]=LPC_CANAF_RAM-&gt;mask[cnt1+1]= LPC_CANAF_RAM-&gt;mask[cnt1+2]=0x00;
+	cnt1+=3;
+	while(bound1--)
+	{
+		tmp0 = LPC_CANAF_RAM-&gt;mask[cnt1];
+		tmp1 = LPC_CANAF_RAM-&gt;mask[cnt1+1];
+		tmp2 = LPC_CANAF_RAM-&gt;mask[cnt1+2];
+		LPC_CANAF_RAM-&gt;mask[cnt1]= buf0;
+		LPC_CANAF_RAM-&gt;mask[cnt1+1]= buf1;
+		LPC_CANAF_RAM-&gt;mask[cnt1+2]= buf2;
+		buf0 = tmp0;
+		buf1 = tmp1;
+		buf2 = tmp2;
+		cnt1+=3;
+	}
+	CANAF_FullCAN_cnt++;
+	//update address values
+	LPC_CANAF-&gt;SFF_sa 	  +=0x04;
+	LPC_CANAF-&gt;SFF_GRP_sa +=0x04 ;
+	LPC_CANAF-&gt;EFF_sa     +=0x04 ;
+	LPC_CANAF-&gt;EFF_GRP_sa +=0x04;
+	LPC_CANAF-&gt;ENDofTable +=0x04;
+
+	LPC_CANAF-&gt;AFMR = 0x04;
+ 	return CAN_OK;
+}
+
+/********************************************************************//**
+ * @brief		Load Group entry into AFLUT
+ * @param[in]	CANx: CAN peripheral selected, should be:
+ * 				- CAN1: CAN 1
+ * 				- CAN2: CAN 2
+ * @param[in]	lowerID, upperID: lower and upper identifier of entry
+ * @param[in]	format: type of ID format, should be:
+ * 				- STD_ID_FORMAT: Standard ID format (11-bit value)
+ * 				- EXT_ID_FORMAT: Extended ID format (29-bit value)
+ * @return 		CAN_ERROR, could be:
+ * 				- CAN_OK: loading is successful
+ * 				- CAN_CONFLICT_ID_ERROR: Conflict ID occurs
+ * 				- CAN_OBJECTS_FULL_ERROR: no more space available
+ *********************************************************************/
+CAN_ERROR CAN_LoadGroupEntry(LPC_CAN_TypeDef* CANx, uint32_t lowerID, \
+		uint32_t upperID, CAN_ID_FORMAT_Type format)
+{
+	uint16_t tmp = 0;
+	uint32_t buf0, buf1, entry1, entry2, LID,UID;
+	int16_t cnt1, bound1, total;
+
+	CHECK_PARAM(PARAM_CANx(CANx));
+	CHECK_PARAM(PARAM_ID_FORMAT(format));
+
+	if(lowerID &gt; upperID) return CAN_CONFLICT_ID_ERROR;
+	if(CANx == LPC_CAN1)
+	{
+		tmp = 0;
+	}
+	else
+	{
+		tmp = 1;
+	}
+
+	total =((CANAF_FullCAN_cnt+1)&gt;&gt;1)+ CANAF_FullCAN_cnt*3 +((CANAF_std_cnt + 1) &gt;&gt; 1)+  \
+			CANAF_gstd_cnt + CANAF_ext_cnt + (CANAF_gext_cnt&lt;&lt;1);
+
+	/* Setup Acceptance Filter Configuration
+	Acceptance Filter Mode Register = Off */
+	LPC_CANAF-&gt;AFMR = 0x00000001;
+
+/*********Add Group of Standard Identifier Frame Format************/
+	if(format == STD_ID_FORMAT)
+	{
+		if ((total &gt;= 512)){//don't have enough space
+			return CAN_OBJECTS_FULL_ERROR;
+		}
+		lowerID &amp;=0x7FF; //mask ID
+		upperID &amp;=0x7FF;
+		entry1  = (tmp &lt;&lt; 29)|(lowerID &lt;&lt; 16)|(tmp &lt;&lt; 13)|(upperID &lt;&lt; 0);
+		cnt1 = ((CANAF_FullCAN_cnt+1)&gt;&gt;1) + ((CANAF_std_cnt + 1) &gt;&gt; 1);
+
+		//if this is the first Group standard ID entry
+		if(CANAF_gstd_cnt == 0)
+		{
+			LPC_CANAF_RAM-&gt;mask[cnt1] = entry1;
+		}
+		else
+		{
+			//find the position to add new Group entry
+			bound1 = ((CANAF_FullCAN_cnt+1)&gt;&gt;1) + ((CANAF_std_cnt + 1) &gt;&gt; 1) + CANAF_gstd_cnt;
+			while(cnt1 &lt; bound1)
+			{
+				buf0 = LPC_CANAF_RAM-&gt;mask[cnt1];
+				LID  = (buf0 &gt;&gt; 16)&amp;0x7FF;
+				UID  = buf0 &amp; 0x7FF;
+				if (upperID &lt;= LID)
+				{
+					//add new entry before this entry
+					LPC_CANAF_RAM-&gt;mask[cnt1] = entry1;
+					break;
+				}
+				else if (lowerID &gt;= UID)
+				{
+					//load next entry to compare
+					cnt1 ++;
+				}
+				else
+					return CAN_CONFLICT_ID_ERROR;
+			}
+			if(cnt1 &gt;= bound1)
+			{
+				//add new entry at the last position in this list
+				buf0 = LPC_CANAF_RAM-&gt;mask[cnt1];
+				LPC_CANAF_RAM-&gt;mask[cnt1] = entry1;
+			}
+
+			//remove all remaining entry of this section one place up
+			bound1 = total - cnt1;
+			while(bound1--)
+			{
+				cnt1++;
+				buf1 = LPC_CANAF_RAM-&gt;mask[cnt1];
+				LPC_CANAF_RAM-&gt;mask[cnt1] = buf0;
+				buf0 = buf1;
+			}
+		}
+		CANAF_gstd_cnt++;
+		//update address values
+		LPC_CANAF-&gt;EFF_sa     +=0x04 ;
+		LPC_CANAF-&gt;EFF_GRP_sa +=0x04;
+		LPC_CANAF-&gt;ENDofTable +=0x04;
+	}
+
+
+/*********Add Group of Extended Identifier Frame Format************/
+	else
+	{
+		if ((total &gt;= 511)){//don't have enough space
+			return CAN_OBJECTS_FULL_ERROR;
+		}
+		lowerID  &amp;= 0x1FFFFFFF; //mask ID
+		upperID &amp;= 0x1FFFFFFF;
+		entry1   = (tmp &lt;&lt; 29)|(lowerID &lt;&lt; 0);
+		entry2   = (tmp &lt;&lt; 29)|(upperID &lt;&lt; 0);
+
+		cnt1 = ((CANAF_FullCAN_cnt+1)&gt;&gt;1) + ((CANAF_std_cnt + 1) &gt;&gt; 1) + CANAF_gstd_cnt + CANAF_ext_cnt;
+		//if this is the first Group standard ID entry
+		if(CANAF_gext_cnt == 0)
+		{
+			LPC_CANAF_RAM-&gt;mask[cnt1] = entry1;
+			LPC_CANAF_RAM-&gt;mask[cnt1+1] = entry2;
+		}
+		else
+		{
+			//find the position to add new Group entry
+			bound1 = ((CANAF_FullCAN_cnt+1)&gt;&gt;1) + ((CANAF_std_cnt + 1) &gt;&gt; 1) + CANAF_gstd_cnt \
+						+ CANAF_ext_cnt + (CANAF_gext_cnt&lt;&lt;1);
+			while(cnt1 &lt; bound1)
+			{
+				buf0 = LPC_CANAF_RAM-&gt;mask[cnt1];
+				buf1 = LPC_CANAF_RAM-&gt;mask[cnt1+1];
+				LID  = buf0 &amp; 0x1FFFFFFF; //mask ID
+				UID  = buf1 &amp; 0x1FFFFFFF;
+				if (upperID &lt;= LID)
+				{
+					//add new entry before this entry
+					LPC_CANAF_RAM-&gt;mask[cnt1] = entry1;
+					LPC_CANAF_RAM-&gt;mask[++cnt1] = entry2;
+					break;
+				}
+				else if (lowerID &gt;= UID)
+				{
+					//load next entry to compare
+					cnt1 +=2;
+				}
+				else
+					return CAN_CONFLICT_ID_ERROR;
+			}
+			if(cnt1 &gt;= bound1)
+			{
+				//add new entry at the last position in this list
+				buf0 = LPC_CANAF_RAM-&gt;mask[cnt1];
+				buf1 = LPC_CANAF_RAM-&gt;mask[cnt1+1];
+				LPC_CANAF_RAM-&gt;mask[cnt1]   = entry1;
+				LPC_CANAF_RAM-&gt;mask[++cnt1] = entry2;
+			}
+			//remove all remaining entry of this section two place up
+			bound1 = total - cnt1 + 1;
+			cnt1++;
+			while(bound1&gt;0)
+			{
+				entry1 = LPC_CANAF_RAM-&gt;mask[cnt1];
+				entry2 = LPC_CANAF_RAM-&gt;mask[cnt1+1];
+				LPC_CANAF_RAM-&gt;mask[cnt1]   = buf0;
+				LPC_CANAF_RAM-&gt;mask[cnt1+1] = buf1;
+				buf0 = entry1;
+				buf1 = entry2;
+				cnt1   +=2;
+				bound1 -=2;
+			}
+		}
+		CANAF_gext_cnt++;
+		//update address values
+		LPC_CANAF-&gt;ENDofTable +=0x08;
+	}
+	LPC_CANAF-&gt;AFMR = 0x04;
+ 	return CAN_OK;
+}
+
+/********************************************************************//**
+ * @brief		Remove AFLUT entry (FullCAN entry and Explicit Standard entry)
+ * @param[in]	EntryType: the type of entry that want to remove, should be:
+ * 				- FULLCAN_ENTRY
+ * 				- EXPLICIT_STANDARD_ENTRY
+ * 				- GROUP_STANDARD_ENTRY
+ * 				- EXPLICIT_EXTEND_ENTRY
+ * 				- GROUP_EXTEND_ENTRY
+ * @param[in]	position: the position of this entry in its section
+ * Note: the first position is 0
+ * @return 		CAN_ERROR, could be:
+ * 				- CAN_OK: removing is successful
+ * 				- CAN_ENTRY_NOT_EXIT_ERROR: entry want to remove is not exit
+ *********************************************************************/
+CAN_ERROR CAN_RemoveEntry(AFLUT_ENTRY_Type EntryType, uint16_t position)
+{
+	uint16_t cnt, bound, total;
+	uint32_t buf0, buf1;
+	CHECK_PARAM(PARAM_AFLUT_ENTRY_TYPE(EntryType));
+	CHECK_PARAM(PARAM_POSITION(position));
+
+	/* Setup Acceptance Filter Configuration
+	Acceptance Filter Mode Register = Off */
+	LPC_CANAF-&gt;AFMR = 0x00000001;
+	total = ((CANAF_FullCAN_cnt+1)&gt;&gt;1)+((CANAF_std_cnt + 1) &gt;&gt; 1) + \
+			CANAF_gstd_cnt + CANAF_ext_cnt + (CANAF_gext_cnt&lt;&lt;1);
+
+
+/************** Remove FullCAN Entry *************/
+	if(EntryType == FULLCAN_ENTRY)
+	{
+		if((CANAF_FullCAN_cnt==0)||(position &gt;= CANAF_FullCAN_cnt))
+		{
+			return CAN_ENTRY_NOT_EXIT_ERROR;
+		}
+		else
+		{
+			cnt = position &gt;&gt; 1;
+			buf0 = LPC_CANAF_RAM-&gt;mask[cnt];
+			bound = (CANAF_FullCAN_cnt - position -1)&gt;&gt;1;
+			if((position &amp; 0x0001) == 0) //event position
+			{
+				while(bound--)
+				{
+					//remove all remaining FullCAN entry one place down
+					buf1  = LPC_CANAF_RAM-&gt;mask[cnt+1];
+					LPC_CANAF_RAM-&gt;mask[cnt] = (buf1 &gt;&gt; 16) | (buf0 &lt;&lt; 16);
+					buf0  = buf1;
+					cnt++;
+				}
+			}
+			else //odd position
+			{
+				while(bound--)
+				{
+					//remove all remaining FullCAN entry one place down
+					buf1  = LPC_CANAF_RAM-&gt;mask[cnt+1];
+					LPC_CANAF_RAM-&gt;mask[cnt] = (buf0 &amp; 0xFFFF0000)|(buf1 &gt;&gt; 16);
+					LPC_CANAF_RAM-&gt;mask[cnt+1] = LPC_CANAF_RAM-&gt;mask[cnt+1] &lt;&lt; 16;
+					buf0  = buf1&lt;&lt;16;
+					cnt++;
+				}
+			}
+			if((CANAF_FullCAN_cnt &amp; 0x0001) == 0)
+			{
+				if((position &amp; 0x0001)==0)
+					LPC_CANAF_RAM-&gt;mask[cnt] = (buf0 &lt;&lt; 16) | (0x0000FFFF);
+				else
+					LPC_CANAF_RAM-&gt;mask[cnt] = buf0 | 0x0000FFFF;
+			}
+			else
+			{
+				//remove all remaining section one place down
+				cnt = (CANAF_FullCAN_cnt + 1)&gt;&gt;1;
+				bound = total + CANAF_FullCAN_cnt * 3;
+				while(bound&gt;cnt)
+				{
+					LPC_CANAF_RAM-&gt;mask[cnt-1] = LPC_CANAF_RAM-&gt;mask[cnt];
+					cnt++;
+				}
+				LPC_CANAF_RAM-&gt;mask[cnt-1]=0x00;
+				//update address values
+				LPC_CANAF-&gt;SFF_sa 	  -=0x04;
+				LPC_CANAF-&gt;SFF_GRP_sa -=0x04 ;
+				LPC_CANAF-&gt;EFF_sa     -=0x04 ;
+				LPC_CANAF-&gt;EFF_GRP_sa -=0x04;
+				LPC_CANAF-&gt;ENDofTable -=0x04;
+			}
+			CANAF_FullCAN_cnt--;
+
+			//delete its FullCAN Object in the FullCAN Object section
+			//remove all remaining FullCAN Object three place down
+			cnt = total + position * 3;
+			bound = (CANAF_FullCAN_cnt - position + 1) * 3;
+
+			while(bound)
+			{
+				LPC_CANAF_RAM-&gt;mask[cnt]=LPC_CANAF_RAM-&gt;mask[cnt+3];;
+				LPC_CANAF_RAM-&gt;mask[cnt+1]=LPC_CANAF_RAM-&gt;mask[cnt+4];
+				LPC_CANAF_RAM-&gt;mask[cnt+2]=LPC_CANAF_RAM-&gt;mask[cnt+5];
+				bound -=3;
+				cnt   +=3;
+			}
+		}
+	}
+
+/************** Remove Explicit Standard ID Entry *************/
+	else if(EntryType == EXPLICIT_STANDARD_ENTRY)
+	{
+		if((CANAF_std_cnt==0)||(position &gt;= CANAF_std_cnt))
+		{
+			return CAN_ENTRY_NOT_EXIT_ERROR;
+		}
+		else
+		{
+			cnt = ((CANAF_FullCAN_cnt+1)&gt;&gt;1)+ (position &gt;&gt; 1);
+			buf0 = LPC_CANAF_RAM-&gt;mask[cnt];
+			bound = (CANAF_std_cnt - position - 1)&gt;&gt;1;
+			if((position &amp; 0x0001) == 0) //event position
+			{
+				while(bound--)
+				{
+					//remove all remaining FullCAN entry one place down
+					buf1  = LPC_CANAF_RAM-&gt;mask[cnt+1];
+					LPC_CANAF_RAM-&gt;mask[cnt] = (buf1 &gt;&gt; 16) | (buf0 &lt;&lt; 16);
+					buf0  = buf1;
+					cnt++;
+				}
+			}
+			else //odd position
+			{
+				while(bound--)
+				{
+					//remove all remaining FullCAN entry one place down
+					buf1  = LPC_CANAF_RAM-&gt;mask[cnt+1];
+					LPC_CANAF_RAM-&gt;mask[cnt] = (buf0 &amp; 0xFFFF0000)|(buf1 &gt;&gt; 16);
+					LPC_CANAF_RAM-&gt;mask[cnt+1] = LPC_CANAF_RAM-&gt;mask[cnt+1] &lt;&lt; 16;
+					buf0  = buf1&lt;&lt;16;
+					cnt++;
+				}
+			}
+			if((CANAF_std_cnt &amp; 0x0001) == 0)
+			{
+				if((position &amp; 0x0001)==0)
+					LPC_CANAF_RAM-&gt;mask[cnt] = (buf0 &lt;&lt; 16) | (0x0000FFFF);
+				else
+					LPC_CANAF_RAM-&gt;mask[cnt] = buf0 | 0x0000FFFF;
+			}
+			else
+			{
+				//remove all remaining section one place down
+				cnt = ((CANAF_FullCAN_cnt + 1)&gt;&gt;1) + ((CANAF_std_cnt + 1) &gt;&gt; 1);
+				bound = total + CANAF_FullCAN_cnt * 3;
+				while(bound&gt;cnt)
+				{
+					LPC_CANAF_RAM-&gt;mask[cnt-1] = LPC_CANAF_RAM-&gt;mask[cnt];
+					cnt++;
+				}
+				LPC_CANAF_RAM-&gt;mask[cnt-1]=0x00;
+				//update address value
+				LPC_CANAF-&gt;SFF_GRP_sa -=0x04 ;
+				LPC_CANAF-&gt;EFF_sa     -=0x04 ;
+				LPC_CANAF-&gt;EFF_GRP_sa -=0x04;
+				LPC_CANAF-&gt;ENDofTable -=0x04;
+			}
+			CANAF_std_cnt--;
+		}
+	}
+
+/************** Remove Group of Standard ID Entry *************/
+	else if(EntryType == GROUP_STANDARD_ENTRY)
+	{
+		if((CANAF_gstd_cnt==0)||(position &gt;= CANAF_gstd_cnt))
+		{
+			return CAN_ENTRY_NOT_EXIT_ERROR;
+		}
+		else
+		{
+			cnt = ((CANAF_FullCAN_cnt + 1)&gt;&gt;1) + ((CANAF_std_cnt + 1) &gt;&gt; 1)+ position + 1;
+			bound = total + CANAF_FullCAN_cnt * 3;
+			while (cnt&lt;bound)
+			{
+				LPC_CANAF_RAM-&gt;mask[cnt-1] = LPC_CANAF_RAM-&gt;mask[cnt];
+				cnt++;
+			}
+			LPC_CANAF_RAM-&gt;mask[cnt-1]=0x00;
+		}
+		CANAF_gstd_cnt--;
+		//update address value
+		LPC_CANAF-&gt;EFF_sa     -=0x04;
+		LPC_CANAF-&gt;EFF_GRP_sa -=0x04;
+		LPC_CANAF-&gt;ENDofTable -=0x04;
+	}
+
+/************** Remove Explicit Extended ID Entry *************/
+	else if(EntryType == EXPLICIT_EXTEND_ENTRY)
+	{
+		if((CANAF_ext_cnt==0)||(position &gt;= CANAF_ext_cnt))
+		{
+			return CAN_ENTRY_NOT_EXIT_ERROR;
+		}
+		else
+		{
+			cnt = ((CANAF_FullCAN_cnt + 1)&gt;&gt;1) + ((CANAF_std_cnt + 1) &gt;&gt; 1)+ CANAF_gstd_cnt + position + 1;
+			bound = total + CANAF_FullCAN_cnt * 3;
+			while (cnt&lt;bound)
+			{
+				LPC_CANAF_RAM-&gt;mask[cnt-1] = LPC_CANAF_RAM-&gt;mask[cnt];
+				cnt++;
+			}
+			LPC_CANAF_RAM-&gt;mask[cnt-1]=0x00;
+		}
+		CANAF_ext_cnt--;
+		LPC_CANAF-&gt;EFF_GRP_sa -=0x04;
+		LPC_CANAF-&gt;ENDofTable -=0x04;
+	}
+
+/************** Remove Group of Extended ID Entry *************/
+	else
+	{
+		if((CANAF_gext_cnt==0)||(position &gt;= CANAF_gext_cnt))
+		{
+			return CAN_ENTRY_NOT_EXIT_ERROR;
+		}
+		else
+		{
+			cnt = total - (CANAF_gext_cnt&lt;&lt;1) + (position&lt;&lt;1);
+			bound = total + CANAF_FullCAN_cnt * 3;
+			while (cnt&lt;bound)
+			{
+				//remove all remaining entry two place up
+				LPC_CANAF_RAM-&gt;mask[cnt] = LPC_CANAF_RAM-&gt;mask[cnt+2];
+				LPC_CANAF_RAM-&gt;mask[cnt+1] = LPC_CANAF_RAM-&gt;mask[cnt+3];
+				cnt+=2;
+			}
+		}
+		CANAF_gext_cnt--;
+		LPC_CANAF-&gt;ENDofTable -=0x08;
+	}
+	LPC_CANAF-&gt;AFMR = 0x04;
+	return CAN_OK;
+}
+
+/********************************************************************//**
+ * @brief		Send message data
+ * @param[in]	CANx pointer to LPC_CAN_TypeDef, should be:
+ * 				- CAN1: CAN 1
+ * 				- CAN2: CAN 2
+ * @param[in]	CAN_Msg point to the CAN_MSG_Type Structure, it contains message
+ * 				information such as: ID, DLC, RTR, ID Format
+ * @return 		Status:
+ * 				- SUCCESS: send message successfully
+ * 				- ERROR: send message unsuccessfully
+ *********************************************************************/
+Status CAN_SendMsg (LPC_CAN_TypeDef *CANx, CAN_MSG_Type *CAN_Msg)
+{
+	uint32_t data;
+	CHECK_PARAM(PARAM_CANx(CANx));
+	CHECK_PARAM(PARAM_ID_FORMAT(CAN_Msg-&gt;format));
+	if(CAN_Msg-&gt;format==STD_ID_FORMAT)
+	{
+		CHECK_PARAM(PARAM_ID_11(CAN_Msg-&gt;id));
+	}
+	else
+	{
+		CHECK_PARAM(PARAM_ID_29(CAN_Msg-&gt;id));
+	}
+	CHECK_PARAM(PARAM_DLC(CAN_Msg-&gt;len));
+	CHECK_PARAM(PARAM_FRAME_TYPE(CAN_Msg-&gt;type));
+
+	//Check status of Transmit Buffer 1
+	if ((CANx-&gt;SR &amp; 0x00000004)&gt;&gt;2)
+	{
+		/* Transmit Channel 1 is available */
+		/* Write frame informations and frame data into its CANxTFI1,
+		 * CANxTID1, CANxTDA1, CANxTDB1 register */
+		CANx-&gt;TFI1 &amp;= ~0x000F000;
+		CANx-&gt;TFI1 |= (CAN_Msg-&gt;len)&lt;&lt;16;
+		if(CAN_Msg-&gt;type == REMOTE_FRAME)
+		{
+			CANx-&gt;TFI1 |= (1&lt;&lt;30); //set bit RTR
+		}
+		else
+		{
+			CANx-&gt;TFI1 &amp;= ~(1&lt;&lt;30);
+		}
+		if(CAN_Msg-&gt;format == EXT_ID_FORMAT)
+		{
+			CANx-&gt;TFI1 |= (1&lt;&lt;31); //set bit FF
+		}
+		else
+		{
+			CANx-&gt;TFI1 &amp;= ~(1&lt;&lt;31);
+		}
+
+		/* Write CAN ID*/
+		CANx-&gt;TID1 = CAN_Msg-&gt;id;
+
+		/*Write first 4 data bytes*/
+		data = (CAN_Msg-&gt;dataA[0])|(((CAN_Msg-&gt;dataA[1]))&lt;&lt;8)|((CAN_Msg-&gt;dataA[2])&lt;&lt;16)|((CAN_Msg-&gt;dataA[3])&lt;&lt;24);
+//		CANx-&gt;TDA1 = *((uint32_t *) &amp;(CAN_Msg-&gt;dataA));
+		CANx-&gt;TDA1 = data;
+
+		/*Write second 4 data bytes*/
+		data = (CAN_Msg-&gt;dataB[0])|(((CAN_Msg-&gt;dataB[1]))&lt;&lt;8)|((CAN_Msg-&gt;dataB[2])&lt;&lt;16)|((CAN_Msg-&gt;dataB[3])&lt;&lt;24);
+//		CANx-&gt;TDB1 = *((uint32_t *) &amp;(CAN_Msg-&gt;dataB));
+		CANx-&gt;TDB1 = data;
+
+		 /*Write transmission request*/
+		 CANx-&gt;CMR = 0x21;
+		 return SUCCESS;
+	}
+	//check status of Transmit Buffer 2
+	else if((CANx-&gt;SR &amp; 0x00000004)&gt;&gt;10)
+	{
+		/* Transmit Channel 2 is available */
+		/* Write frame informations and frame data into its CANxTFI2,
+		 * CANxTID2, CANxTDA2, CANxTDB2 register */
+		CANx-&gt;TFI2 &amp;= ~0x000F000;
+		CANx-&gt;TFI2 |= (CAN_Msg-&gt;len)&lt;&lt;16;
+		if(CAN_Msg-&gt;type == REMOTE_FRAME)
+		{
+			CANx-&gt;TFI2 |= (1&lt;&lt;30); //set bit RTR
+		}
+		else
+		{
+			CANx-&gt;TFI2 &amp;= ~(1&lt;&lt;30);
+		}
+		if(CAN_Msg-&gt;format == EXT_ID_FORMAT)
+		{
+			CANx-&gt;TFI2 |= (1&lt;&lt;31); //set bit FF
+		}
+		else
+		{
+			CANx-&gt;TFI2 &amp;= ~(1&lt;&lt;31);
+		}
+
+		/* Write CAN ID*/
+		CANx-&gt;TID2 = CAN_Msg-&gt;id;
+
+		/*Write first 4 data bytes*/
+		data = (CAN_Msg-&gt;dataA[0])|(((CAN_Msg-&gt;dataA[1]))&lt;&lt;8)|((CAN_Msg-&gt;dataA[2])&lt;&lt;16)|((CAN_Msg-&gt;dataA[3])&lt;&lt;24);
+//		CANx-&gt;TDA2 = *((uint32_t *) &amp;(CAN_Msg-&gt;dataA));
+		CANx-&gt;TDA2 = data;
+
+		/*Write second 4 data bytes*/
+		data = (CAN_Msg-&gt;dataB[0])|(((CAN_Msg-&gt;dataB[1]))&lt;&lt;8)|((CAN_Msg-&gt;dataB[2])&lt;&lt;16)|((CAN_Msg-&gt;dataB[3])&lt;&lt;24);
+//		CANx-&gt;TDB2 = *((uint32_t *) &amp;(CAN_Msg-&gt;dataB));
+		CANx-&gt;TDB2 = data;
+
+		/*Write transmission request*/
+		CANx-&gt;CMR = 0x41;
+		return SUCCESS;
+	}
+	//check status of Transmit Buffer 3
+	else if ((CANx-&gt;SR &amp; 0x00000004)&gt;&gt;18)
+	{
+		/* Transmit Channel 3 is available */
+		/* Write frame informations and frame data into its CANxTFI3,
+		 * CANxTID3, CANxTDA3, CANxTDB3 register */
+		CANx-&gt;TFI3 &amp;= ~0x000F000;
+		CANx-&gt;TFI3 |= (CAN_Msg-&gt;len)&lt;&lt;16;
+		if(CAN_Msg-&gt;type == REMOTE_FRAME)
+		{
+			CANx-&gt;TFI3 |= (1&lt;&lt;30); //set bit RTR
+		}
+		else
+		{
+			CANx-&gt;TFI3 &amp;= ~(1&lt;&lt;30);
+		}
+		if(CAN_Msg-&gt;format == EXT_ID_FORMAT)
+		{
+			CANx-&gt;TFI3 |= (1&lt;&lt;31); //set bit FF
+		}
+		else
+		{
+			CANx-&gt;TFI3 &amp;= ~(1&lt;&lt;31);
+		}
+
+		/* Write CAN ID*/
+		CANx-&gt;TID3 = CAN_Msg-&gt;id;
+
+		/*Write first 4 data bytes*/
+		data = (CAN_Msg-&gt;dataA[0])|(((CAN_Msg-&gt;dataA[1]))&lt;&lt;8)|((CAN_Msg-&gt;dataA[2])&lt;&lt;16)|((CAN_Msg-&gt;dataA[3])&lt;&lt;24);
+//		CANx-&gt;TDA3 = *((uint32_t *) &amp;(CAN_Msg-&gt;dataA));
+		CANx-&gt;TDA3 = data;
+
+		/*Write second 4 data bytes*/
+		data = (CAN_Msg-&gt;dataB[0])|(((CAN_Msg-&gt;dataB[1]))&lt;&lt;8)|((CAN_Msg-&gt;dataB[2])&lt;&lt;16)|((CAN_Msg-&gt;dataB[3])&lt;&lt;24);
+//		CANx-&gt;TDB3 = *((uint32_t *) &amp;(CAN_Msg-&gt;dataB));
+		CANx-&gt;TDB3 = data;
+
+		/*Write transmission request*/
+		CANx-&gt;CMR = 0x81;
+		return SUCCESS;
+	}
+	else
+	{
+		return ERROR;
+	}
+}
+
+/********************************************************************//**
+ * @brief		Receive message data
+ * @param[in]	CANx pointer to LPC_CAN_TypeDef, should be:
+ * 				- CAN1: CAN 1
+ * 				- CAN2: CAN 2
+ * @param[in]	CAN_Msg point to the CAN_MSG_Type Struct, it will contain received
+ *  			message information such as: ID, DLC, RTR, ID Format
+ * @return 		Status:
+ * 				- SUCCESS: receive message successfully
+ * 				- ERROR: receive message unsuccessfully
+ *********************************************************************/
+Status CAN_ReceiveMsg (LPC_CAN_TypeDef *CANx, CAN_MSG_Type *CAN_Msg)
+{
+	uint32_t data;
+
+	CHECK_PARAM(PARAM_CANx(CANx));
+
+	//check status of Receive Buffer
+	if((CANx-&gt;SR &amp;0x00000001))
+	{
+		/* Receive message is available */
+		/* Read frame informations */
+		CAN_Msg-&gt;format   = (uint8_t)(((CANx-&gt;RFS) &amp; 0x80000000)&gt;&gt;31);
+		CAN_Msg-&gt;type     = (uint8_t)(((CANx-&gt;RFS) &amp; 0x40000000)&gt;&gt;30);
+		CAN_Msg-&gt;len      = (uint8_t)(((CANx-&gt;RFS) &amp; 0x000F0000)&gt;&gt;16);
+
+
+		/* Read CAN message identifier */
+		CAN_Msg-&gt;id = CANx-&gt;RID;
+
+		/* Read the data if received message was DATA FRAME */
+		if (CAN_Msg-&gt;type == DATA_FRAME)
+		{
+			/* Read first 4 data bytes */
+//			*((uint32_t *) &amp;CAN_Msg-&gt;dataA) = CANx-&gt;RDA;
+			data = CANx-&gt;RDA;
+			*((uint8_t *) &amp;CAN_Msg-&gt;dataA[0])= data &amp; 0x000000FF;
+			*((uint8_t *) &amp;CAN_Msg-&gt;dataA[1])= (data &amp; 0x0000FF00)&gt;&gt;8;;
+			*((uint8_t *) &amp;CAN_Msg-&gt;dataA[2])= (data &amp; 0x00FF0000)&gt;&gt;16;
+			*((uint8_t *) &amp;CAN_Msg-&gt;dataA[3])= (data &amp; 0xFF000000)&gt;&gt;24;
+
+			/* Read second 4 data bytes */
+//			*((uint32_t *) &amp;CAN_Msg-&gt;dataB) = CANx-&gt;RDB;
+			data = CANx-&gt;RDB;
+			*((uint8_t *) &amp;CAN_Msg-&gt;dataB[0])= data &amp; 0x000000FF;
+			*((uint8_t *) &amp;CAN_Msg-&gt;dataB[1])= (data &amp; 0x0000FF00)&gt;&gt;8;
+			*((uint8_t *) &amp;CAN_Msg-&gt;dataB[2])= (data &amp; 0x00FF0000)&gt;&gt;16;
+			*((uint8_t *) &amp;CAN_Msg-&gt;dataB[3])= (data &amp; 0xFF000000)&gt;&gt;24;
+
+		/*release receive buffer*/
+		CANx-&gt;CMR = 0x04;
+		}
+		else
+		{
+			/* Received Frame is a Remote Frame, not have data, we just receive
+			 * message information only */
+			return SUCCESS;
+		}
+	}
+	else
+	{
+		// no receive message available
+		return ERROR;
+	}
+	return SUCCESS;
+}
+
+/********************************************************************//**
+ * @brief		Receive FullCAN Object
+ * @param[in]	CANAFx: CAN Acceptance Filter register, should be LPC_CANAF
+ * @param[in]	CAN_Msg point to the CAN_MSG_Type Struct, it will contain received
+ *  			message information such as: ID, DLC, RTR, ID Format
+ * @return 		CAN_ERROR, could be:
+ * 				- CAN_FULL_OBJ_NOT_RCV: FullCAN Object is not be received
+ * 				- CAN_OK: Received FullCAN Object successful
+ *
+ *********************************************************************/
+CAN_ERROR FCAN_ReadObj (LPC_CANAF_TypeDef* CANAFx, CAN_MSG_Type *CAN_Msg)
+{
+	uint32_t *pSrc, data;
+	uint32_t interrut_word, msg_idx, test_bit, head_idx, tail_idx;
+
+	CHECK_PARAM(PARAM_CANAFx(CANAFx));
+
+	interrut_word = 0;
+
+	if (LPC_CANAF-&gt;FCANIC0 != 0)
+	{
+		interrut_word = LPC_CANAF-&gt;FCANIC0;
+		head_idx = 0;
+		tail_idx = 31;
+	}
+	else if (LPC_CANAF-&gt;FCANIC1 != 0)
+	{
+		interrut_word = LPC_CANAF-&gt;FCANIC1;
+		head_idx = 32;
+		tail_idx = 63;
+	}
+
+	if (interrut_word != 0)
+	{
+		/* Detect for interrupt pending */
+		msg_idx = 0;
+		for (msg_idx = head_idx; msg_idx &lt;= tail_idx; msg_idx++)
+		{
+			test_bit = interrut_word &amp; 0x1;
+			interrut_word = interrut_word &gt;&gt; 1;
+
+			if (test_bit)
+			{
+				pSrc = (uint32_t *) (LPC_CANAF-&gt;ENDofTable + LPC_CANAF_RAM_BASE + msg_idx * 12);
+
+	    	 	/* Has been finished updating the content */
+	    	 	if ((*pSrc &amp; 0x03000000L) == 0x03000000L)
+	    	 	{
+	    	 		/*clear semaphore*/
+	    	 		*pSrc &amp;= 0xFCFFFFFF;
+
+	    	 		/*Set to DatA*/
+	    	 		pSrc++;
+	    	 		/* Copy to dest buf */
+//	    	 		*((uint32_t *) &amp;CAN_Msg-&gt;dataA) = *pSrc;
+	    	 		data = *pSrc;
+	    			*((uint8_t *) &amp;CAN_Msg-&gt;dataA[0])= data &amp; 0x000000FF;
+	    			*((uint8_t *) &amp;CAN_Msg-&gt;dataA[1])= (data &amp; 0x0000FF00)&gt;&gt;8;
+	    			*((uint8_t *) &amp;CAN_Msg-&gt;dataA[2])= (data &amp; 0x00FF0000)&gt;&gt;16;
+	    			*((uint8_t *) &amp;CAN_Msg-&gt;dataA[3])= (data &amp; 0xFF000000)&gt;&gt;24;
+
+	    	 		/*Set to DatB*/
+	    	 		pSrc++;
+	    	 		/* Copy to dest buf */
+//	    	 		*((uint32_t *) &amp;CAN_Msg-&gt;dataB) = *pSrc;
+	    	 		data = *pSrc;
+	    			*((uint8_t *) &amp;CAN_Msg-&gt;dataB[0])= data &amp; 0x000000FF;
+	    			*((uint8_t *) &amp;CAN_Msg-&gt;dataB[1])= (data &amp; 0x0000FF00)&gt;&gt;8;
+	    			*((uint8_t *) &amp;CAN_Msg-&gt;dataB[2])= (data &amp; 0x00FF0000)&gt;&gt;16;
+	    			*((uint8_t *) &amp;CAN_Msg-&gt;dataB[3])= (data &amp; 0xFF000000)&gt;&gt;24;
+	    	 		/*Back to Dat1*/
+	    	 		pSrc -= 2;
+
+	    	 		CAN_Msg-&gt;id = *pSrc &amp; 0x7FF;
+	    	 		CAN_Msg-&gt;len = (uint8_t) (*pSrc &gt;&gt; 16) &amp; 0x0F;
+					CAN_Msg-&gt;format = 0; //FullCAN Object ID always is 11-bit value
+					CAN_Msg-&gt;type = (uint8_t)(*pSrc &gt;&gt; 30) &amp;0x01;
+	    	 		/*Re-read semaphore*/
+	    	 		if ((*pSrc &amp; 0x03000000L) == 0)
+	    	 		{
+	    	 			return CAN_OK;
+	    	 		}
+	    	 	}
+			}
+		}
+	}
+	return CAN_FULL_OBJ_NOT_RCV;
+}
+/********************************************************************//**
+ * @brief		Get CAN Control Status
+ * @param[in]	CANx pointer to LPC_CAN_TypeDef, should be:
+ * 				- CAN1: CAN 1
+ * 				- CAN2: CAN 2
+ * @param[in]	arg: type of CAN status to get from CAN status register
+ * 				Should be:
+ * 				- CANCTRL_GLOBAL_STS: CAN Global Status
+ * 				- CANCTRL_INT_CAP: CAN Interrupt and Capture
+ * 				- CANCTRL_ERR_WRN: CAN Error Warning Limit
+ * 				- CANCTRL_STS: CAN Control Status
+ * @return 		Current Control Status that you want to get value
+ *********************************************************************/
+uint32_t CAN_GetCTRLStatus (LPC_CAN_TypeDef* CANx, CAN_CTRL_STS_Type arg)
+{
+	CHECK_PARAM(PARAM_CANx(CANx));
+	CHECK_PARAM(PARAM_CTRL_STS_TYPE(arg));
+
+	switch (arg)
+	{
+	case CANCTRL_GLOBAL_STS:
+		return CANx-&gt;GSR;
+
+	case CANCTRL_INT_CAP:
+		return CANx-&gt;ICR;
+
+	case CANCTRL_ERR_WRN:
+		return CANx-&gt;EWL;
+
+	default: // CANCTRL_STS
+		return CANx-&gt;SR;
+	}
+}
+/********************************************************************//**
+ * @brief		Get CAN Central Status
+ * @param[in]	CANCRx point to LPC_CANCR_TypeDef
+ * @param[in]	arg: type of CAN status to get from CAN Central status register
+ * 				Should be:
+ * 				- CANCR_TX_STS: Central CAN Tx Status
+ * 				- CANCR_RX_STS: Central CAN Rx Status
+ * 				- CANCR_MS: Central CAN Miscellaneous Status
+ * @return 		Current Central Status that you want to get value
+ *********************************************************************/
+uint32_t CAN_GetCRStatus (LPC_CANCR_TypeDef* CANCRx, CAN_CR_STS_Type arg)
+{
+	CHECK_PARAM(PARAM_CANCRx(CANCRx));
+	CHECK_PARAM(PARAM_CR_STS_TYPE(arg));
+
+	switch (arg)
+	{
+	case CANCR_TX_STS:
+		return CANCRx-&gt;CANTxSR;
+
+	case CANCR_RX_STS:
+		return CANCRx-&gt;CANRxSR;
+
+	default:	// CANCR_MS
+		return CANCRx-&gt;CANMSR;
+	}
+}
+/********************************************************************//**
+ * @brief		Enable/Disable CAN Interrupt
+ * @param[in]	CANx pointer to LPC_CAN_TypeDef, should be:
+ * 				- CAN1: CAN 1
+ * 				- CAN2: CAN 2
+ * @param[in]	arg: type of CAN interrupt that you want to enable/disable
+ * 				Should be:
+ * 				- CANINT_RIE: CAN Receiver Interrupt Enable
+ * 				- CANINT_TIE1: CAN Transmit Interrupt Enable
+ * 				- CANINT_EIE: CAN Error Warning Interrupt Enable
+ * 				- CANINT_DOIE: CAN Data Overrun Interrupt Enable
+ * 				- CANINT_WUIE: CAN Wake-Up Interrupt Enable
+ * 				- CANINT_EPIE: CAN Error Passive Interrupt Enable
+ * 				- CANINT_ALIE: CAN Arbitration Lost Interrupt Enable
+ * 				- CANINT_BEIE: CAN Bus Error Interrupt Enable
+ * 				- CANINT_IDIE: CAN ID Ready Interrupt Enable
+ * 				- CANINT_TIE2: CAN Transmit Interrupt Enable for Buffer2
+ * 				- CANINT_TIE3: CAN Transmit Interrupt Enable for Buffer3
+ * 				- CANINT_FCE: FullCAN Interrupt Enable
+ * @param[in]	NewState: New state of this function, should be:
+ * 				- ENABLE
+ * 				- DISABLE
+ * @return 		none
+ *********************************************************************/
+void CAN_IRQCmd (LPC_CAN_TypeDef* CANx, CAN_INT_EN_Type arg, FunctionalState NewState)
+{
+	CHECK_PARAM(PARAM_CANx(CANx));
+	CHECK_PARAM(PARAM_INT_EN_TYPE(arg));
+	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
+
+	if(NewState == ENABLE)
+	{
+		if(arg==CANINT_FCE)
+		{
+			LPC_CANAF-&gt;AFMR = 0x01;
+			LPC_CANAF-&gt;FCANIE = 0x01;
+			LPC_CANAF-&gt;AFMR = 0x04;
+		}
+		else
+			CANx-&gt;IER |= (1 &lt;&lt; arg);
+	}
+	else
+	{
+		if(arg==CANINT_FCE){
+			LPC_CANAF-&gt;AFMR = 0x01;
+			LPC_CANAF-&gt;FCANIE = 0x01;
+			LPC_CANAF-&gt;AFMR = 0x00;
+		}
+		else
+			CANx-&gt;IER &amp;= ~(1 &lt;&lt; arg);
+	}
+}
+/*********************************************************************//**
+ * @brief		Install interrupt call-back function
+ * @param[in]	arg: CAN interrupt type, should be:
+ * 	  			- CANINT_RIE: CAN Receiver Interrupt Enable
+ * 				- CANINT_TIE1: CAN Transmit Interrupt Enable
+ * 				- CANINT_EIE: CAN Error Warning Interrupt Enable
+ * 				- CANINT_DOIE: CAN Data Overrun Interrupt Enable
+ * 				- CANINT_WUIE: CAN Wake-Up Interrupt Enable
+ * 				- CANINT_EPIE: CAN Error Passive Interrupt Enable
+ * 				- CANINT_ALIE: CAN Arbitration Lost Interrupt Enable
+ * 				- CANINT_BEIE: CAN Bus Error Interrupt Enable
+ * 				- CANINT_IDIE: CAN ID Ready Interrupt Enable
+ * 				- CANINT_TIE2: CAN Transmit Interrupt Enable for Buffer2
+ * 				- CANINT_TIE3: CAN Transmit Interrupt Enable for Buffer3
+ * 				- CANINT_FCE: FullCAN Interrupt Enable
+ * @param[in]	pnCANCbs: pointer point to call-back function
+ * @return		None
+ **********************************************************************/
+void CAN_SetupCBS(CAN_INT_EN_Type arg,fnCANCbs_Type* pnCANCbs)
+{
+	CHECK_PARAM(PARAM_INT_EN_TYPE(arg));
+	_apfnCANCbs[arg] = pnCANCbs;
+}
+/********************************************************************//**
+ * @brief		Setting Acceptance Filter mode
+ * @param[in]	CANAFx point to LPC_CANAF_TypeDef object, should be: CANAF
+ * @param[in]	AFMode: type of AF mode that you want to set, should be:
+ * 				- CAN_Normal: Normal mode
+ * 				- CAN_AccOff: Acceptance Filter Off Mode
+ * 				- CAN_AccBP: Acceptance Fileter Bypass Mode
+ * 				- CAN_eFCAN: FullCAN Mode Enhancement
+ * @return 		none
+ *********************************************************************/
+void CAN_SetAFMode (LPC_CANAF_TypeDef* CANAFx, CAN_AFMODE_Type AFMode)
+{
+	CHECK_PARAM(PARAM_CANAFx(CANAFx));
+	CHECK_PARAM(PARAM_AFMODE_TYPE(AFMode));
+
+	switch(AFMode)
+	{
+	case CAN_Normal:
+		CANAFx-&gt;AFMR = 0x00;
+		break;
+	case CAN_AccOff:
+		CANAFx-&gt;AFMR = 0x01;
+		break;
+	case CAN_AccBP:
+		CANAFx-&gt;AFMR = 0x02;
+		break;
+	case CAN_eFCAN:
+		CANAFx-&gt;AFMR = 0x04;
+		break;
+	}
+}
+
+/********************************************************************//**
+ * @brief		Enable/Disable CAN Mode
+ * @param[in]	CANx pointer to LPC_CAN_TypeDef, should be:
+ * 				- CAN1: CAN 1
+ * 				- CAN2: CAN 2
+ * @param[in]	mode: type of CAN mode that you want to enable/disable, should be:
+ * 				- CAN_OPERATING_MODE: Normal Operating Mode
+ * 				- CAN_RESET_MODE: Reset Mode
+ * 				- CAN_LISTENONLY_MODE: Listen Only Mode
+ * 				- CAN_SELFTEST_MODE: Self Test Mode
+ * 				- CAN_TXPRIORITY_MODE: Transmit Priority Mode
+ * 				- CAN_SLEEP_MODE: Sleep Mode
+ * 				- CAN_RXPOLARITY_MODE: Receive Polarity Mode
+ * 				- CAN_TEST_MODE: Test Mode
+ * @param[in]	NewState: New State of this function, should be:
+ * 				- ENABLE
+ * 				- DISABLE
+ * @return 		none
+ *********************************************************************/
+void CAN_ModeConfig(LPC_CAN_TypeDef* CANx, CAN_MODE_Type mode, FunctionalState NewState)
+{
+	CHECK_PARAM(PARAM_CANx(CANx));
+	CHECK_PARAM(PARAM_MODE_TYPE(mode));
+	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
+
+	switch(mode)
+	{
+	case CAN_OPERATING_MODE:
+		CANx-&gt;MOD = 0x00;
+		break;
+	case CAN_RESET_MODE:
+		if(NewState == ENABLE)
+			CANx-&gt;MOD |=CAN_MOD_RM;
+		else
+			CANx-&gt;MOD &amp;= ~CAN_MOD_RM;
+		break;
+	case CAN_LISTENONLY_MODE:
+		CANx-&gt;MOD |=CAN_MOD_RM;
+		if(NewState == ENABLE)
+			CANx-&gt;MOD |=CAN_MOD_LOM;
+		else
+			CANx-&gt;MOD &amp;=~CAN_MOD_LOM;
+		break;
+	case CAN_SELFTEST_MODE:
+		CANx-&gt;MOD |=CAN_MOD_RM;
+		if(NewState == ENABLE)
+			CANx-&gt;MOD |=CAN_MOD_STM;
+		else
+			CANx-&gt;MOD &amp;=~CAN_MOD_STM;
+		break;
+	case CAN_TXPRIORITY_MODE:
+		if(NewState == ENABLE)
+			CANx-&gt;MOD |=CAN_MOD_TPM;
+		else
+			CANx-&gt;MOD &amp;=~CAN_MOD_TPM;
+		break;
+	case CAN_SLEEP_MODE:
+		if(NewState == ENABLE)
+			CANx-&gt;MOD |=CAN_MOD_SM;
+		else
+			CANx-&gt;MOD &amp;=~CAN_MOD_SM;
+		break;
+	case CAN_RXPOLARITY_MODE:
+		if(NewState == ENABLE)
+			CANx-&gt;MOD |=CAN_MOD_RPM;
+		else
+			CANx-&gt;MOD &amp;=~CAN_MOD_RPM;
+		break;
+	case CAN_TEST_MODE:
+		if(NewState == ENABLE)
+			CANx-&gt;MOD |=CAN_MOD_TM;
+		else
+			CANx-&gt;MOD &amp;=~CAN_MOD_TM;
+		break;
+	}
+}
+/*********************************************************************//**
+ * @brief		Standard CAN interrupt handler, this function will check
+ * 				all interrupt status of CAN channels, then execute the call
+ * 				back function if they're already installed
+ * @param[in]	CANx point to CAN peripheral selected, should be: CAN1 or CAN2
+ * @return		None
+ **********************************************************************/
+void CAN_IntHandler(LPC_CAN_TypeDef* CANx)
+{
+	uint8_t t;
+	//scan interrupt pending
+	if(LPC_CANAF-&gt;FCANIE)
+	{
+		_apfnCANCbs[11]();
+	}
+	//scan interrupt channels
+	for(t=0;t&lt;11;t++)
+	{
+		if(((CANx-&gt;ICR)&gt;&gt;t)&amp;0x01)
+		{
+			_apfnCANCbs[t]();
+		}
+	}
+}
+
+/**
+ * @}
+ */
+
+#endif /* _CAN */
+
+/**
+ * @}
+ */
+
+/* --------------------------------- End Of File ------------------------------ */


Property changes on: trunk/src/platform/lpc17xx/drivers/src/lpc17xx_can.c
___________________________________________________________________
Deleted: svn:executable
   - *

Modified: trunk/src/platform/lpc17xx/drivers/src/lpc17xx_clkpwr.c
===================================================================
--- trunk/src/platform/lpc17xx/drivers/src/lpc17xx_clkpwr.c	2010-06-28 21:53:59 UTC (rev 759)
+++ trunk/src/platform/lpc17xx/drivers/src/lpc17xx_clkpwr.c	2010-07-12 20:56:54 UTC (rev 760)
@@ -1,344 +1,344 @@
-/**
- * @file	: lpc17xx_clkpwr.c
- * @brief	: Contains all functions support for Clock and Power Control
- * 				firmware library on LPC17xx
- * @version	: 1.0
- * @date	: 18. Mar. 2009
- * @author	: HieuNguyen
- *----------------------------------------------------------------------------
- * Software that is described herein is for illustrative purposes only
- * which provides customers with programming information regarding the
- * products. This software is supplied &quot;AS IS&quot; without any warranties.
- * NXP Semiconductors assumes no responsibility or liability for the
- * use of the software, conveys no license or title under any patent,
- * copyright, or mask work right to the product. NXP Semiconductors
- * reserves the right to make changes in the software without
- * notification. NXP Semiconductors also make no representation or
- * warranty that such application will be suitable for the specified
- * use without further testing or modification.
- **********************************************************************/
-
-/* Peripheral group ----------------------------------------------------------- */
-/** @addtogroup CLKPWR
- * @{
- */
-
-/* Includes ------------------------------------------------------------------- */
-#include &quot;lpc17xx_clkpwr.h&quot;
-
-
-/* Public Functions ----------------------------------------------------------- */
-/** @addtogroup CLKPWR_Public_Functions
- * @{
- */
-
-/*********************************************************************//**
- * @brief 		Set value of each Peripheral Clock Selection
- * @param[in]	ClkType	Peripheral Clock Selection of each type,
- * 				should be one of the following:
- *				- CLKPWR_PCLKSEL_WDT   		: WDT
-				- CLKPWR_PCLKSEL_TIMER0   	: Timer 0
-				- CLKPWR_PCLKSEL_TIMER1   	: Timer 1
-				- CLKPWR_PCLKSEL_UART0   	: UART 0
-				- CLKPWR_PCLKSEL_UART1  	: UART 1
-				- CLKPWR_PCLKSEL_PWM1   	: PWM 1
-				- CLKPWR_PCLKSEL_I2C0   	: I2C 0
-				- CLKPWR_PCLKSEL_SPI   		: SPI
-				- CLKPWR_PCLKSEL_SSP1   	: SSP 1
-				- CLKPWR_PCLKSEL_DAC   		: DAC
-				- CLKPWR_PCLKSEL_ADC   		: ADC
-				- CLKPWR_PCLKSEL_CAN1  		: CAN 1
-				- CLKPWR_PCLKSEL_CAN2  		: CAN 2
-				- CLKPWR_PCLKSEL_ACF   		: ACF
-				- CLKPWR_PCLKSEL_QEI 		: QEI
-				- CLKPWR_PCLKSEL_PCB   		: PCB
-				- CLKPWR_PCLKSEL_I2C1   	: I2C 1
-				- CLKPWR_PCLKSEL_SSP0   	: SSP 0
-				- CLKPWR_PCLKSEL_TIMER2   	: Timer 2
-				- CLKPWR_PCLKSEL_TIMER3   	: Timer 3
-				- CLKPWR_PCLKSEL_UART2   	: UART 2
-				- CLKPWR_PCLKSEL_UART3   	: UART 3
-				- CLKPWR_PCLKSEL_I2C2   	: I2C 2
-				- CLKPWR_PCLKSEL_I2S   		: I2S
-				- CLKPWR_PCLKSEL_RIT   		: RIT
-				- CLKPWR_PCLKSEL_SYSCON   	: SYSCON
-				- CLKPWR_PCLKSEL_MC 		: MC
-
- * @param[in]	DivVal	Value of divider, should be:
- * 				- CLKPWR_PCLKSEL_CCLK_DIV_4 : PCLK_peripheral = CCLK/4
- * 				- CLKPWR_PCLKSEL_CCLK_DIV_1 : PCLK_peripheral = CCLK/1
- *				- CLKPWR_PCLKSEL_CCLK_DIV_2 : PCLK_peripheral = CCLK/2
- *
- * @return none
- **********************************************************************/
-void CLKPWR_SetPCLKDiv (uint32_t ClkType, uint32_t DivVal)
-{
-	uint32_t bitpos;
-
-	bitpos = (ClkType &lt; 32) ? (ClkType) : (ClkType - 32);
-
-	/* PCLKSEL0 selected */
-	if (ClkType &lt; 32)
-	{
-		/* Clear two bit at bit position */
-		SC-&gt;PCLKSEL0 &amp;= (~(CLKPWR_PCLKSEL_BITMASK(bitpos)));
-
-		/* Set two selected bit */
-		SC-&gt;PCLKSEL0 |= (CLKPWR_PCLKSEL_SET(bitpos, DivVal));
-	}
-	/* PCLKSEL1 selected */
-	else
-	{
-		/* Clear two bit at bit position */
-		SC-&gt;PCLKSEL1 &amp;= ~(CLKPWR_PCLKSEL_BITMASK(bitpos));
-
-		/* Set two selected bit */
-		SC-&gt;PCLKSEL1 |= (CLKPWR_PCLKSEL_SET(bitpos, DivVal));
-	}
-}
-
-
-/*********************************************************************//**
- * @brief		Get current value of each Peripheral Clock Selection
- * @param[in]	ClkType	Peripheral Clock Selection of each type,
- * 				should be one of the following:
- *				- CLKPWR_PCLKSEL_WDT   		: WDT
-				- CLKPWR_PCLKSEL_TIMER0   	: Timer 0
-				- CLKPWR_PCLKSEL_TIMER1   	: Timer 1
-				- CLKPWR_PCLKSEL_UART0   	: UART 0
-				- CLKPWR_PCLKSEL_UART1  	: UART 1
-				- CLKPWR_PCLKSEL_PWM1   	: PWM 1
-				- CLKPWR_PCLKSEL_I2C0   	: I2C 0
-				- CLKPWR_PCLKSEL_SPI   		: SPI
-				- CLKPWR_PCLKSEL_SSP1   	: SSP 1
-				- CLKPWR_PCLKSEL_DAC   		: DAC
-				- CLKPWR_PCLKSEL_ADC   		: ADC
-				- CLKPWR_PCLKSEL_CAN1  		: CAN 1
-				- CLKPWR_PCLKSEL_CAN2  		: CAN 2
-				- CLKPWR_PCLKSEL_ACF   		: ACF
-				- CLKPWR_PCLKSEL_QEI 		: QEI
-				- CLKPWR_PCLKSEL_PCB   		: PCB
-				- CLKPWR_PCLKSEL_I2C1   	: I2C 1
-				- CLKPWR_PCLKSEL_SSP0   	: SSP 0
-				- CLKPWR_PCLKSEL_TIMER2   	: Timer 2
-				- CLKPWR_PCLKSEL_TIMER3   	: Timer 3
-				- CLKPWR_PCLKSEL_UART2   	: UART 2
-				- CLKPWR_PCLKSEL_UART3   	: UART 3
-				- CLKPWR_PCLKSEL_I2C2   	: I2C 2
-				- CLKPWR_PCLKSEL_I2S   		: I2S
-				- CLKPWR_PCLKSEL_RIT   		: RIT
-				- CLKPWR_PCLKSEL_SYSCON   	: SYSCON
-				- CLKPWR_PCLKSEL_MC 		: MC
-
- * @return		Value of Selected Peripheral Clock Selection
- **********************************************************************/
-uint32_t CLKPWR_GetPCLKSEL (uint32_t ClkType)
-{
-	uint32_t bitpos, retval;
-
-	if (ClkType &lt; 32)
-	{
-		bitpos = ClkType;
-		retval = SC-&gt;PCLKSEL0;
-	}
-	else
-	{
-		bitpos = ClkType - 32;
-		retval = SC-&gt;PCLKSEL1;
-	}
-
-	retval = CLKPWR_PCLKSEL_GET(bitpos, retval);
-	return retval;
-}
-
-
-
-/*********************************************************************//**
- * @brief 		Get current value of each Peripheral Clock
- * @param[in]	ClkType	Peripheral Clock Selection of each type,
- * 				should be one of the following:
- *				- CLKPWR_PCLKSEL_WDT   		: WDT
-				- CLKPWR_PCLKSEL_TIMER0   	: Timer 0
-				- CLKPWR_PCLKSEL_TIMER1   	: Timer 1
-				- CLKPWR_PCLKSEL_UART0   	: UART 0
-				- CLKPWR_PCLKSEL_UART1  	: UART 1
-				- CLKPWR_PCLKSEL_PWM1   	: PWM 1
-				- CLKPWR_PCLKSEL_I2C0   	: I2C 0
-				- CLKPWR_PCLKSEL_SPI   		: SPI
-				- CLKPWR_PCLKSEL_SSP1   	: SSP 1
-				- CLKPWR_PCLKSEL_DAC   		: DAC
-				- CLKPWR_PCLKSEL_ADC   		: ADC
-				- CLKPWR_PCLKSEL_CAN1  		: CAN 1
-				- CLKPWR_PCLKSEL_CAN2  		: CAN 2
-				- CLKPWR_PCLKSEL_ACF   		: ACF
-				- CLKPWR_PCLKSEL_QEI 		: QEI
-				- CLKPWR_PCLKSEL_PCB   		: PCB
-				- CLKPWR_PCLKSEL_I2C1   	: I2C 1
-				- CLKPWR_PCLKSEL_SSP0   	: SSP 0
-				- CLKPWR_PCLKSEL_TIMER2   	: Timer 2
-				- CLKPWR_PCLKSEL_TIMER3   	: Timer 3
-				- CLKPWR_PCLKSEL_UART2   	: UART 2
-				- CLKPWR_PCLKSEL_UART3   	: UART 3
-				- CLKPWR_PCLKSEL_I2C2   	: I2C 2
-				- CLKPWR_PCLKSEL_I2S   		: I2S
-				- CLKPWR_PCLKSEL_RIT   		: RIT
-				- CLKPWR_PCLKSEL_SYSCON   	: SYSCON
-				- CLKPWR_PCLKSEL_MC 		: MC
-
- * @return		Value of Selected Peripheral Clock
- **********************************************************************/
-uint32_t CLKPWR_GetPCLK (uint32_t ClkType)
-{
-	uint32_t retval, div;
-
-	retval = SystemFrequency;
-	div = CLKPWR_GetPCLKSEL(ClkType);
-
-	switch (div)
-	{
-	case 0:
-		div = 4;
-		break;
-
-	case 1:
-		div = 1;
-		break;
-
-	case 2:
-		div = 2;
-		break;
-
-	case 3:
-		div = 8;
-		break;
-	}
-	retval /= div;
-
-	return retval;
-}
-
-
-
-/*********************************************************************//**
- * @brief 		Configure power supply for each peripheral according to NewState
- * @param[in]	PPType	Type of peripheral used to enable power,
- *     					should be one of the following:
- *     			-  CLKPWR_PCONP_PCTIM0 		: Timer 0
-				-  CLKPWR_PCONP_PCTIM1 		: Timer 1
-				-  CLKPWR_PCONP_PCUART0  	: UART 0
-				-  CLKPWR_PCONP_PCUART1   	: UART 1
-				-  CLKPWR_PCONP_PCPWM1 		: PWM 1
-				-  CLKPWR_PCONP_PCI2C0 		: I2C 0
-				-  CLKPWR_PCONP_PCSPI   	: SPI
-				-  CLKPWR_PCONP_PCRTC   	: RTC
-				-  CLKPWR_PCONP_PCSSP1 		: SSP 1
-				-  CLKPWR_PCONP_PCAD   		: ADC
-				-  CLKPWR_PCONP_PCAN1   	: CAN 1
-				-  CLKPWR_PCONP_PCAN2   	: CAN 2
-				-  CLKPWR_PCONP_PCGPIO 		: GPIO
-				-  CLKPWR_PCONP_PCRIT 		: RIT
-				-  CLKPWR_PCONP_PCMC 		: MC
-				-  CLKPWR_PCONP_PCQEI 		: QEI
-				-  CLKPWR_PCONP_PCI2C1   	: I2C 1
-				-  CLKPWR_PCONP_PCSSP0 		: SSP 0
-				-  CLKPWR_PCONP_PCTIM2 		: Timer 2
-				-  CLKPWR_PCONP_PCTIM3 		: Timer 3
-				-  CLKPWR_PCONP_PCUART2  	: UART 2
-				-  CLKPWR_PCONP_PCUART3   	: UART 3
-				-  CLKPWR_PCONP_PCI2C2 		: I2C 2
-				-  CLKPWR_PCONP_PCI2S   	: I2S
-				-  CLKPWR_PCONP_PCGPDMA   	: GPDMA
-				-  CLKPWR_PCONP_PCENET 		: Ethernet
-				-  CLKPWR_PCONP_PCUSB   	: USB
- *
- * @param[in]	NewState	New state of Peripheral Power, should be:
- * 				- ENABLE	: Enable power for this peripheral
- * 				- DISABLE	: Disable power for this peripheral
- *
- * @return none
- **********************************************************************/
-void CLKPWR_ConfigPPWR (uint32_t PPType, FunctionalState NewState)
-{
-	if (NewState == ENABLE)
-	{
-		SC-&gt;PCONP |= PPType &amp; CLKPWR_PCONP_BITMASK;
-	}
-	else if (NewState == DISABLE)
-	{
-		SC-&gt;PCONP &amp;= (~PPType) &amp; CLKPWR_PCONP_BITMASK;
-	}
-}
-
-
-/**
- * @brief 		Enter Sleep mode with co-operated instruction by the Cortex-M3.
- * @param[in]	None
- * @return		None
- */
-void CLKPWR_Sleep(void)
-{
-	SC-&gt;PCON = 0x00;
-	/* Sleep Mode*/
-	__WFI();
-}
-
-
-/**
- * @brief 		Enter Deep Sleep mode with co-operated instruction by the Cortex-M3.
- * @param[in]	None
- * @return		None
- */
-void CLKPWR_DeepSleep(void)
-{
-    /* Deep-Sleep Mode, set SLEEPDEEP bit */
-	SCB-&gt;SCR = 0x4;
-	SC-&gt;PCON = 0x00;
-	/* Sleep Mode*/
-	__WFI();
-}
-
-
-/**
- * @brief 		Enter Power Down mode with co-operated instruction by the Cortex-M3.
- * @param[in]	None
- * @return		None
- */
-void CLKPWR_PowerDown(void)
-{
-    /* Deep-Sleep Mode, set SLEEPDEEP bit */
-	SCB-&gt;SCR = 0x4;
-	SC-&gt;PCON = 0x01;
-	/* Sleep Mode*/
-	__WFI();
-}
-
-
-/**
- * @brief 		Enter Deep Power Down mode with co-operated instruction by the Cortex-M3.
- * @param[in]	None
- * @return		None
- */
-void CLKPWR_DeepPowerDown(void)
-{
-    /* Deep-Sleep Mode, set SLEEPDEEP bit */
-	SCB-&gt;SCR = 0x4;
-	SC-&gt;PCON = 0x03;
-	/* Sleep Mode*/
-	__WFI();
-}
-
-
-/**
- * @brief 		Configure Brown-Out function in
- */
-
-
-/**
- * @}
- */
-
-/**
- * @}
- */
-
-/* --------------------------------- End Of File ------------------------------ */
+/**
+ * @file	: lpc17xx_clkpwr.c
+ * @brief	: Contains all functions support for Clock and Power Control
+ * 				firmware library on LPC17xx
+ * @version	: 1.0
+ * @date	: 18. Mar. 2009
+ * @author	: HieuNguyen
+ **************************************************************************
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * products. This software is supplied &quot;AS IS&quot; without any warranties.
+ * NXP Semiconductors assumes no responsibility or liability for the
+ * use of the software, conveys no license or title under any patent,
+ * copyright, or mask work right to the product. NXP Semiconductors
+ * reserves the right to make changes in the software without
+ * notification. NXP Semiconductors also make no representation or
+ * warranty that such application will be suitable for the specified
+ * use without further testing or modification.
+ **********************************************************************/
+
+/* Peripheral group ----------------------------------------------------------- */
+/** @addtogroup CLKPWR
+ * @{
+ */
+
+/* Includes ------------------------------------------------------------------- */
+#include &quot;lpc17xx_clkpwr.h&quot;
+
+
+/* Public Functions ----------------------------------------------------------- */
+/** @addtogroup CLKPWR_Public_Functions
+ * @{
+ */
+
+/*********************************************************************//**
+ * @brief 		Set value of each Peripheral Clock Selection
+ * @param[in]	ClkType	Peripheral Clock Selection of each type,
+ * 				should be one of the following:
+ *				- CLKPWR_PCLKSEL_WDT   		: WDT
+				- CLKPWR_PCLKSEL_TIMER0   	: Timer 0
+				- CLKPWR_PCLKSEL_TIMER1   	: Timer 1
+				- CLKPWR_PCLKSEL_UART0   	: UART 0
+				- CLKPWR_PCLKSEL_UART1  	: UART 1
+				- CLKPWR_PCLKSEL_PWM1   	: PWM 1
+				- CLKPWR_PCLKSEL_I2C0   	: I2C 0
+				- CLKPWR_PCLKSEL_SPI   		: SPI
+				- CLKPWR_PCLKSEL_SSP1   	: SSP 1
+				- CLKPWR_PCLKSEL_DAC   		: DAC
+				- CLKPWR_PCLKSEL_ADC   		: ADC
+				- CLKPWR_PCLKSEL_CAN1  		: CAN 1
+				- CLKPWR_PCLKSEL_CAN2  		: CAN 2
+				- CLKPWR_PCLKSEL_ACF   		: ACF
+				- CLKPWR_PCLKSEL_QEI 		: QEI
+				- CLKPWR_PCLKSEL_PCB   		: PCB
+				- CLKPWR_PCLKSEL_I2C1   	: I2C 1
+				- CLKPWR_PCLKSEL_SSP0   	: SSP 0
+				- CLKPWR_PCLKSEL_TIMER2   	: Timer 2
+				- CLKPWR_PCLKSEL_TIMER3   	: Timer 3
+				- CLKPWR_PCLKSEL_UART2   	: UART 2
+				- CLKPWR_PCLKSEL_UART3   	: UART 3
+				- CLKPWR_PCLKSEL_I2C2   	: I2C 2
+				- CLKPWR_PCLKSEL_I2S   		: I2S
+				- CLKPWR_PCLKSEL_RIT   		: RIT
+				- CLKPWR_PCLKSEL_SYSCON   	: SYSCON
+				- CLKPWR_PCLKSEL_MC 		: MC
+
+ * @param[in]	DivVal	Value of divider, should be:
+ * 				- CLKPWR_PCLKSEL_CCLK_DIV_4 : PCLK_peripheral = CCLK/4
+ * 				- CLKPWR_PCLKSEL_CCLK_DIV_1 : PCLK_peripheral = CCLK/1
+ *				- CLKPWR_PCLKSEL_CCLK_DIV_2 : PCLK_peripheral = CCLK/2
+ *
+ * @return none
+ **********************************************************************/
+void CLKPWR_SetPCLKDiv (uint32_t ClkType, uint32_t DivVal)
+{
+	uint32_t bitpos;
+
+	bitpos = (ClkType &lt; 32) ? (ClkType) : (ClkType - 32);
+
+	/* PCLKSEL0 selected */
+	if (ClkType &lt; 32)
+	{
+		/* Clear two bit at bit position */
+		LPC_SC-&gt;PCLKSEL0 &amp;= (~(CLKPWR_PCLKSEL_BITMASK(bitpos)));
+
+		/* Set two selected bit */
+		LPC_SC-&gt;PCLKSEL0 |= (CLKPWR_PCLKSEL_SET(bitpos, DivVal));
+	}
+	/* PCLKSEL1 selected */
+	else
+	{
+		/* Clear two bit at bit position */
+		LPC_SC-&gt;PCLKSEL1 &amp;= ~(CLKPWR_PCLKSEL_BITMASK(bitpos));
+
+		/* Set two selected bit */
+		LPC_SC-&gt;PCLKSEL1 |= (CLKPWR_PCLKSEL_SET(bitpos, DivVal));
+	}
+}
+
+
+/*********************************************************************//**
+ * @brief		Get current value of each Peripheral Clock Selection
+ * @param[in]	ClkType	Peripheral Clock Selection of each type,
+ * 				should be one of the following:
+ *				- CLKPWR_PCLKSEL_WDT   		: WDT
+				- CLKPWR_PCLKSEL_TIMER0   	: Timer 0
+				- CLKPWR_PCLKSEL_TIMER1   	: Timer 1
+				- CLKPWR_PCLKSEL_UART0   	: UART 0
+				- CLKPWR_PCLKSEL_UART1  	: UART 1
+				- CLKPWR_PCLKSEL_PWM1   	: PWM 1
+				- CLKPWR_PCLKSEL_I2C0   	: I2C 0
+				- CLKPWR_PCLKSEL_SPI   		: SPI
+				- CLKPWR_PCLKSEL_SSP1   	: SSP 1
+				- CLKPWR_PCLKSEL_DAC   		: DAC
+				- CLKPWR_PCLKSEL_ADC   		: ADC
+				- CLKPWR_PCLKSEL_CAN1  		: CAN 1
+				- CLKPWR_PCLKSEL_CAN2  		: CAN 2
+				- CLKPWR_PCLKSEL_ACF   		: ACF
+				- CLKPWR_PCLKSEL_QEI 		: QEI
+				- CLKPWR_PCLKSEL_PCB   		: PCB
+				- CLKPWR_PCLKSEL_I2C1   	: I2C 1
+				- CLKPWR_PCLKSEL_SSP0   	: SSP 0
+				- CLKPWR_PCLKSEL_TIMER2   	: Timer 2
+				- CLKPWR_PCLKSEL_TIMER3   	: Timer 3
+				- CLKPWR_PCLKSEL_UART2   	: UART 2
+				- CLKPWR_PCLKSEL_UART3   	: UART 3
+				- CLKPWR_PCLKSEL_I2C2   	: I2C 2
+				- CLKPWR_PCLKSEL_I2S   		: I2S
+				- CLKPWR_PCLKSEL_RIT   		: RIT
+				- CLKPWR_PCLKSEL_SYSCON   	: SYSCON
+				- CLKPWR_PCLKSEL_MC 		: MC
+
+ * @return		Value of Selected Peripheral Clock Selection
+ **********************************************************************/
+uint32_t CLKPWR_GetPCLKSEL (uint32_t ClkType)
+{
+	uint32_t bitpos, retval;
+
+	if (ClkType &lt; 32)
+	{
+		bitpos = ClkType;
+		retval = LPC_SC-&gt;PCLKSEL0;
+	}
+	else
+	{
+		bitpos = ClkType - 32;
+		retval = LPC_SC-&gt;PCLKSEL1;
+	}
+
+	retval = CLKPWR_PCLKSEL_GET(bitpos, retval);
+	return retval;
+}
+
+
+
+/*********************************************************************//**
+ * @brief 		Get current value of each Peripheral Clock
+ * @param[in]	ClkType	Peripheral Clock Selection of each type,
+ * 				should be one of the following:
+ *				- CLKPWR_PCLKSEL_WDT   		: WDT
+				- CLKPWR_PCLKSEL_TIMER0   	: Timer 0
+				- CLKPWR_PCLKSEL_TIMER1   	: Timer 1
+				- CLKPWR_PCLKSEL_UART0   	: UART 0
+				- CLKPWR_PCLKSEL_UART1  	: UART 1
+				- CLKPWR_PCLKSEL_PWM1   	: PWM 1
+				- CLKPWR_PCLKSEL_I2C0   	: I2C 0
+				- CLKPWR_PCLKSEL_SPI   		: SPI
+				- CLKPWR_PCLKSEL_SSP1   	: SSP 1
+				- CLKPWR_PCLKSEL_DAC   		: DAC
+				- CLKPWR_PCLKSEL_ADC   		: ADC
+				- CLKPWR_PCLKSEL_CAN1  		: CAN 1
+				- CLKPWR_PCLKSEL_CAN2  		: CAN 2
+				- CLKPWR_PCLKSEL_ACF   		: ACF
+				- CLKPWR_PCLKSEL_QEI 		: QEI
+				- CLKPWR_PCLKSEL_PCB   		: PCB
+				- CLKPWR_PCLKSEL_I2C1   	: I2C 1
+				- CLKPWR_PCLKSEL_SSP0   	: SSP 0
+				- CLKPWR_PCLKSEL_TIMER2   	: Timer 2
+				- CLKPWR_PCLKSEL_TIMER3   	: Timer 3
+				- CLKPWR_PCLKSEL_UART2   	: UART 2
+				- CLKPWR_PCLKSEL_UART3   	: UART 3
+				- CLKPWR_PCLKSEL_I2C2   	: I2C 2
+				- CLKPWR_PCLKSEL_I2S   		: I2S
+				- CLKPWR_PCLKSEL_RIT   		: RIT
+				- CLKPWR_PCLKSEL_SYSCON   	: SYSCON
+				- CLKPWR_PCLKSEL_MC 		: MC
+
+ * @return		Value of Selected Peripheral Clock
+ **********************************************************************/
+uint32_t CLKPWR_GetPCLK (uint32_t ClkType)
+{
+	uint32_t retval, div;
+
+	retval = SystemCoreClock;
+	div = CLKPWR_GetPCLKSEL(ClkType);
+
+	switch (div)
+	{
+	case 0:
+		div = 4;
+		break;
+
+	case 1:
+		div = 1;
+		break;
+
+	case 2:
+		div = 2;
+		break;
+
+	case 3:
+		div = 8;
+		break;
+	}
+	retval /= div;
+
+	return retval;
+}
+
+
+
+/*********************************************************************//**
+ * @brief 		Configure power supply for each peripheral according to NewState
+ * @param[in]	PPType	Type of peripheral used to enable power,
+ *     					should be one of the following:
+ *     			-  CLKPWR_PCONP_PCTIM0 		: Timer 0
+				-  CLKPWR_PCONP_PCTIM1 		: Timer 1
+				-  CLKPWR_PCONP_PCUART0  	: UART 0
+				-  CLKPWR_PCONP_PCUART1   	: UART 1
+				-  CLKPWR_PCONP_PCPWM1 		: PWM 1
+				-  CLKPWR_PCONP_PCI2C0 		: I2C 0
+				-  CLKPWR_PCONP_PCSPI   	: SPI
+				-  CLKPWR_PCONP_PCRTC   	: RTC
+				-  CLKPWR_PCONP_PCSSP1 		: SSP 1
+				-  CLKPWR_PCONP_PCAD   		: ADC
+				-  CLKPWR_PCONP_PCAN1   	: CAN 1
+				-  CLKPWR_PCONP_PCAN2   	: CAN 2
+				-  CLKPWR_PCONP_PCGPIO 		: GPIO
+				-  CLKPWR_PCONP_PCRIT 		: RIT
+				-  CLKPWR_PCONP_PCMC 		: MC
+				-  CLKPWR_PCONP_PCQEI 		: QEI
+				-  CLKPWR_PCONP_PCI2C1   	: I2C 1
+				-  CLKPWR_PCONP_PCSSP0 		: SSP 0
+				-  CLKPWR_PCONP_PCTIM2 		: Timer 2
+				-  CLKPWR_PCONP_PCTIM3 		: Timer 3
+				-  CLKPWR_PCONP_PCUART2  	: UART 2
+				-  CLKPWR_PCONP_PCUART3   	: UART 3
+				-  CLKPWR_PCONP_PCI2C2 		: I2C 2
+				-  CLKPWR_PCONP_PCI2S   	: I2S
+				-  CLKPWR_PCONP_PCGPDMA   	: GPDMA
+				-  CLKPWR_PCONP_PCENET 		: Ethernet
+				-  CLKPWR_PCONP_PCUSB   	: USB
+ *
+ * @param[in]	NewState	New state of Peripheral Power, should be:
+ * 				- ENABLE	: Enable power for this peripheral
+ * 				- DISABLE	: Disable power for this peripheral
+ *
+ * @return none
+ **********************************************************************/
+void CLKPWR_ConfigPPWR (uint32_t PPType, FunctionalState NewState)
+{
+	if (NewState == ENABLE)
+	{
+		LPC_SC-&gt;PCONP |= PPType &amp; CLKPWR_PCONP_BITMASK;
+	}
+	else if (NewState == DISABLE)
+	{
+		LPC_SC-&gt;PCONP &amp;= (~PPType) &amp; CLKPWR_PCONP_BITMASK;
+	}
+}
+
+
+/**
+ * @brief 		Enter Sleep mode with co-operated instruction by the Cortex-M3.
+ * @param[in]	None
+ * @return		None
+ */
+void CLKPWR_Sleep(void)
+{
+	LPC_SC-&gt;PCON = 0x00;
+	/* Sleep Mode*/
+	__WFI();
+}
+
+
+/**
+ * @brief 		Enter Deep Sleep mode with co-operated instruction by the Cortex-M3.
+ * @param[in]	None
+ * @return		None
+ */
+void CLKPWR_DeepSleep(void)
+{
+    /* Deep-Sleep Mode, set SLEEPDEEP bit */
+	SCB-&gt;SCR = 0x4;
+	LPC_SC-&gt;PCON = 0x00;
+	/* Sleep Mode*/
+	__WFI();
+}
+
+
+/**
+ * @brief 		Enter Power Down mode with co-operated instruction by the Cortex-M3.
+ * @param[in]	None
+ * @return		None
+ */
+void CLKPWR_PowerDown(void)
+{
+    /* Deep-Sleep Mode, set SLEEPDEEP bit */
+	SCB-&gt;SCR = 0x4;
+	LPC_SC-&gt;PCON = 0x01;
+	/* Sleep Mode*/
+	__WFI();
+}
+
+
+/**
+ * @brief 		Enter Deep Power Down mode with co-operated instruction by the Cortex-M3.
+ * @param[in]	None
+ * @return		None
+ */
+void CLKPWR_DeepPowerDown(void)
+{
+    /* Deep-Sleep Mode, set SLEEPDEEP bit */
+	SCB-&gt;SCR = 0x4;
+	LPC_SC-&gt;PCON = 0x03;
+	/* Sleep Mode*/
+	__WFI();
+}
+
+
+/**
+ * @brief 		Configure Brown-Out function in
+ */
+
+
+/**
+ * @}
+ */
+
+/**
+ * @}
+ */
+
+/* --------------------------------- End Of File ------------------------------ */


Property changes on: trunk/src/platform/lpc17xx/drivers/src/lpc17xx_clkpwr.c
___________________________________________________________________
Deleted: svn:executable
   - *

Modified: trunk/src/platform/lpc17xx/drivers/src/lpc17xx_dac.c
===================================================================
--- trunk/src/platform/lpc17xx/drivers/src/lpc17xx_dac.c	2010-06-28 21:53:59 UTC (rev 759)
+++ trunk/src/platform/lpc17xx/drivers/src/lpc17xx_dac.c	2010-07-12 20:56:54 UTC (rev 760)
@@ -1,141 +1,141 @@
-/**
- * @file	: lpc17xx_dac.c
- * @brief	: Contains all functions support for DAC firmware library on LPC17xx
- * @version	: 1.0
- * @date	: 3. April. 2009
- * @author	: HieuNguyen
- *----------------------------------------------------------------------------
- * Software that is described herein is for illustrative purposes only
- * which provides customers with programming information regarding the
- * products. This software is supplied &quot;AS IS&quot; without any warranties.
- * NXP Semiconductors assumes no responsibility or liability for the
- * use of the software, conveys no license or title under any patent,
- * copyright, or mask work right to the product. NXP Semiconductors
- * reserves the right to make changes in the software without
- * notification. NXP Semiconductors also make no representation or
- * warranty that such application will be suitable for the specified
- * use without further testing or modification.
- **********************************************************************/
-
-/* Peripheral group ----------------------------------------------------------- */
-/** @addtogroup DAC
- * @{
- */
-
-/* Includes ------------------------------------------------------------------- */
-#include &quot;lpc17xx_dac.h&quot;
-#include &quot;lpc17xx_clkpwr.h&quot;
-
-/* If this source file built with example, the LPC17xx FW library configuration
- * file in each example directory (&quot;lpc17xx_libcfg.h&quot;) must be included,
- * otherwise the default FW library configuration file must be included instead
- */
-#ifdef __BUILD_WITH_EXAMPLE__
-#include &quot;lpc17xx_libcfg.h&quot;
-#else
-#include &quot;lpc17xx_libcfg_default.h&quot;
-#endif /* __BUILD_WITH_EXAMPLE__ */
-
-
-#ifdef _DAC
-
-/* Public Functions ----------------------------------------------------------- */
-/** @addtogroup DAC_Public_Functions
- * @{
- */
-
-/*********************************************************************//**
- * @brief 		Initial ADC configuration
- * 					- Maximum	current is 700 uA
- * 					- Value to AOUT is 0
- * @param[in] 	DACx pointer to DAC_TypeDef
- * @return 		None
- ***********************************************************************/
-void 	DAC_Init(DAC_TypeDef *DACx)
-{
-	CHECK_PARAM(PARAM_DACx(DACx));
-	/* Set default clock divider for DAC */
-	// CLKPWR_SetPCLKDiv (CLKPWR_PCLKSEL_DAC, CLKPWR_PCLKSEL_CCLK_DIV_4);
-	//Set maximum current output
-	DAC_SetBias(DAC,DAC_MAX_CURRENT_700uA);
-
-
-}
-
-/*********************************************************************//**
- * @brief 		Update value to DAC
- * @param[in] 	DACx pointer to DAC_TypeDef
- * @param[in] 	dac_value : value 10 bit to be converted to output
- * @return 		None
- ***********************************************************************/
-void    DAC_UpdateValue (DAC_TypeDef *DACx,uint32_t dac_value)
-{
-	uint32_t tmp;
-	CHECK_PARAM(PARAM_DACx(DACx));
-	tmp = DACx-&gt;DACR &amp; DAC_BIAS_EN;
-	tmp |= DAC_VALUE(dac_value);
-	//DACx-&gt;DACR	&amp;= ~DAC_VALUE(0x3FF);
-	//DACx-&gt;DACR 	|=  DAC_VALUE(dac_value);
-	// Update value
-	DACx-&gt;DACR = tmp;
-}
-
-/*********************************************************************//**
- * @brief 		Set Maximum current for DAC
- * @param[in] 	DACx pointer to DAC_TypeDef
- * @param[in] 	bias : 0 is 700 uA
- * 					   1    350 uA
- * @return 		None
- ***********************************************************************/
-void    DAC_SetBias (DAC_TypeDef *DACx,uint32_t bias)
-{
-	CHECK_PARAM(PARAM_DAC_CURRENT_OPT(bias));
-	DACx-&gt;DACR &amp;=~DAC_BIAS_EN;
-	if (bias  == DAC_MAX_CURRENT_350uA)
-	{
-		DACx-&gt;DACR |= DAC_BIAS_EN;
-	}
-}
-/*********************************************************************//**
- * @brief 		To enable the DMA operation and control DMA timer
- * @param[in] 	DACx pointer to DAC_TypeDef
- * @param[in] 	DAC_ConverterConfigStruct pointer to DAC_CONVERTER_CFG_Type
- * 				- DBLBUF_ENA :  enable/disable DACR double buffering feature
- * 				- CNT_ENA    :  enable/disable timer out counter
- *              - DMA_ENA    :	enable/disable DMA access
- * @return 		None
- ***********************************************************************/
-void    DAC_ConfigDAConverterControl (DAC_TypeDef *DACx,DAC_CONVERTER_CFG_Type *DAC_ConverterConfigStruct)
-{
-	CHECK_PARAM(PARAM_DACx(DACx));
-	DACx-&gt;DACCTRL &amp;= ~DAC_DACCTRL_MASK;
-	if (DAC_ConverterConfigStruct-&gt;DBLBUF_ENA)
-		DACx-&gt;DACCTRL	|= DAC_DBLBUF_ENA;
-	if (DAC_ConverterConfigStruct-&gt;CNT_ENA)
-		DACx-&gt;DACCTRL	|= DAC_CNT_ENA;
-	if (DAC_ConverterConfigStruct-&gt;DMA_ENA)
-		DACx-&gt;DACCTRL	|= DAC_DMA_ENA;
-}
-/*********************************************************************//**
- * @brief 		Set reload value for interrupt/DMA counter
- * @param[in] 	DACx pointer to DAC_TypeDef
- * @param[in] 	time_out time out to reload for interrupt/DMA counter
- * @return 		None
- ***********************************************************************/
-void 	DAC_SetDMATimeOut(DAC_TypeDef *DACx, uint32_t time_out)
-{
-	CHECK_PARAM(PARAM_DACx(DACx));
-	DACx-&gt;DACCNTVAL = DAC_CCNT_VALUE(time_out);
-}
-
-/**
- * @}
- */
-
-#endif /* _DAC */
-
-/**
- * @}
- */
-
-/* --------------------------------- End Of File ------------------------------ */
+/**
+ * @file	: lpc17xx_dac.c
+ * @brief	: Contains all functions support for DAC firmware library on LPC17xx
+ * @version	: 1.0
+ * @date	: 3. April. 2009
+ * @author	: HieuNguyen
+ **************************************************************************
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * products. This software is supplied &quot;AS IS&quot; without any warranties.
+ * NXP Semiconductors assumes no responsibility or liability for the
+ * use of the software, conveys no license or title under any patent,
+ * copyright, or mask work right to the product. NXP Semiconductors
+ * reserves the right to make changes in the software without
+ * notification. NXP Semiconductors also make no representation or
+ * warranty that such application will be suitable for the specified
+ * use without further testing or modification.
+ **********************************************************************/
+
+/* Peripheral group ----------------------------------------------------------- */
+/** @addtogroup DAC
+ * @{
+ */
+
+/* Includes ------------------------------------------------------------------- */
+#include &quot;lpc17xx_dac.h&quot;
+#include &quot;lpc17xx_clkpwr.h&quot;
+
+/* If this source file built with example, the LPC17xx FW library configuration
+ * file in each example directory (&quot;lpc17xx_libcfg.h&quot;) must be included,
+ * otherwise the default FW library configuration file must be included instead
+ */
+#ifdef __BUILD_WITH_EXAMPLE__
+#include &quot;lpc17xx_libcfg.h&quot;
+#else
+#include &quot;lpc17xx_libcfg_default.h&quot;
+#endif /* __BUILD_WITH_EXAMPLE__ */
+
+
+#ifdef _DAC
+
+/* Public Functions ----------------------------------------------------------- */
+/** @addtogroup DAC_Public_Functions
+ * @{
+ */
+
+/*********************************************************************//**
+ * @brief 		Initial ADC configuration
+ * 					- Maximum	current is 700 uA
+ * 					- Value to AOUT is 0
+ * @param[in] 	DACx pointer to LPC_DAC_TypeDef
+ * @return 		None
+ ***********************************************************************/
+void 	DAC_Init(LPC_DAC_TypeDef *DACx)
+{
+	CHECK_PARAM(PARAM_DACx(DACx));
+	/* Set default clock divider for DAC */
+	// CLKPWR_SetPCLKDiv (CLKPWR_PCLKSEL_DAC, CLKPWR_PCLKSEL_CCLK_DIV_4);
+	//Set maximum current output
+	DAC_SetBias(LPC_DAC,DAC_MAX_CURRENT_700uA);
+
+
+}
+
+/*********************************************************************//**
+ * @brief 		Update value to DAC
+ * @param[in] 	DACx pointer to LPC_DAC_TypeDef
+ * @param[in] 	dac_value : value 10 bit to be converted to output
+ * @return 		None
+ ***********************************************************************/
+void    DAC_UpdateValue (LPC_DAC_TypeDef *DACx,uint32_t dac_value)
+{
+	uint32_t tmp;
+	CHECK_PARAM(PARAM_DACx(DACx));
+	tmp = DACx-&gt;DACR &amp; DAC_BIAS_EN;
+	tmp |= DAC_VALUE(dac_value);
+	//DACx-&gt;DACR	&amp;= ~DAC_VALUE(0x3FF);
+	//DACx-&gt;DACR 	|=  DAC_VALUE(dac_value);
+	// Update value
+	DACx-&gt;DACR = tmp;
+}
+
+/*********************************************************************//**
+ * @brief 		Set Maximum current for DAC
+ * @param[in] 	DACx pointer to LPC_DAC_TypeDef
+ * @param[in] 	bias : 0 is 700 uA
+ * 					   1    350 uA
+ * @return 		None
+ ***********************************************************************/
+void    DAC_SetBias (LPC_DAC_TypeDef *DACx,uint32_t bias)
+{
+	CHECK_PARAM(PARAM_DAC_CURRENT_OPT(bias));
+	DACx-&gt;DACR &amp;=~DAC_BIAS_EN;
+	if (bias  == DAC_MAX_CURRENT_350uA)
+	{
+		DACx-&gt;DACR |= DAC_BIAS_EN;
+	}
+}
+/*********************************************************************//**
+ * @brief 		To enable the DMA operation and control DMA timer
+ * @param[in]	DACx pointer to LPC_DAC_TypeDef
+ * @param[in] 	DAC_ConverterConfigStruct pointer to DAC_CONVERTER_CFG_Type
+ * 					- DBLBUF_ENA :  enable/disable DACR double buffering feature
+ * 					- CNT_ENA    :  enable/disable timer out counter
+ * 					- DMA_ENA    :	enable/disable DMA access
+ * @return 		None
+ ***********************************************************************/
+void    DAC_ConfigDAConverterControl (LPC_DAC_TypeDef *DACx,DAC_CONVERTER_CFG_Type *DAC_ConverterConfigStruct)
+{
+	CHECK_PARAM(PARAM_DACx(DACx));
+	DACx-&gt;DACCTRL &amp;= ~DAC_DACCTRL_MASK;
+	if (DAC_ConverterConfigStruct-&gt;DBLBUF_ENA)
+		DACx-&gt;DACCTRL	|= DAC_DBLBUF_ENA;
+	if (DAC_ConverterConfigStruct-&gt;CNT_ENA)
+		DACx-&gt;DACCTRL	|= DAC_CNT_ENA;
+	if (DAC_ConverterConfigStruct-&gt;DMA_ENA)
+		DACx-&gt;DACCTRL	|= DAC_DMA_ENA;
+}
+/*********************************************************************//**
+ * @brief 		Set reload value for interrupt/DMA counter
+ * @param[in] 	DACx pointer to LPC_DAC_TypeDef
+ * @param[in] 	time_out time out to reload for interrupt/DMA counter
+ * @return 		None
+ ***********************************************************************/
+void 	DAC_SetDMATimeOut(LPC_DAC_TypeDef *DACx, uint32_t time_out)
+{
+	CHECK_PARAM(PARAM_DACx(DACx));
+	DACx-&gt;DACCNTVAL = DAC_CCNT_VALUE(time_out);
+}
+
+/**
+ * @}
+ */
+
+#endif /* _DAC */
+
+/**
+ * @}
+ */
+
+/* --------------------------------- End Of File ------------------------------ */


Property changes on: trunk/src/platform/lpc17xx/drivers/src/lpc17xx_dac.c
___________________________________________________________________
Deleted: svn:executable
   - *

Modified: trunk/src/platform/lpc17xx/drivers/src/lpc17xx_emac.c
===================================================================
--- trunk/src/platform/lpc17xx/drivers/src/lpc17xx_emac.c	2010-06-28 21:53:59 UTC (rev 759)
+++ trunk/src/platform/lpc17xx/drivers/src/lpc17xx_emac.c	2010-07-12 20:56:54 UTC (rev 760)
@@ -1,989 +1,989 @@
-/**
- * @file	: lpc17xx_emac.c
- * @brief	: Contains all functions support for Ethernet MAC firmware library on LPC17xx
- * @version	: 1.0
- * @date	: 02. Jun. 2009
- * @author	: HieuNguyen
- *----------------------------------------------------------------------------
- * Software that is described herein is for illustrative purposes only
- * which provides customers with programming information regarding the
- * products. This software is supplied &quot;AS IS&quot; without any warranties.
- * NXP Semiconductors assumes no responsibility or liability for the
- * use of the software, conveys no license or title under any patent,
- * copyright, or mask work right to the product. NXP Semiconductors
- * reserves the right to make changes in the software without
- * notification. NXP Semiconductors also make no representation or
- * warranty that such application will be suitable for the specified
- * use without further testing or modification.
- **********************************************************************/
-
-/* Peripheral group ----------------------------------------------------------- */
-/** @addtogroup EMAC
- * @{
- */
-
-/* Includes ------------------------------------------------------------------- */
-#include &quot;lpc17xx_emac.h&quot;
-#include &quot;lpc17xx_clkpwr.h&quot;
-
-/* If this source file built with example, the LPC17xx FW library configuration
- * file in each example directory (&quot;lpc17xx_libcfg.h&quot;) must be included,
- * otherwise the default FW library configuration file must be included instead
- */
-#ifdef __BUILD_WITH_EXAMPLE__
-#include &quot;lpc17xx_libcfg.h&quot;
-#else
-#include &quot;lpc17xx_libcfg_default.h&quot;
-#endif /* __BUILD_WITH_EXAMPLE__ */
-
-
-#ifdef _EMAC
-
-/* Private Variables ---------------------------------------------------------- */
-/** @defgroup EMAC_Private_Variables
- * @{
- */
-
-/* MII Mgmt Configuration register - Clock divider setting */
-const uint8_t EMAC_clkdiv[] = { 4, 6, 8, 10, 14, 20, 28 };
-
-/* EMAC local DMA Descriptors */
-
-/** Rx Descriptor data array */
-static RX_Desc Rx_Desc[EMAC_NUM_RX_FRAG];
-
-/** Rx Status data array - Must be 8-Byte aligned */
-#if defined ( __CC_ARM   )
-static __align(8) RX_Stat Rx_Stat[EMAC_NUM_RX_FRAG];
-#elif defined ( __ICCARM__ )
-#pragma data_alignment=8
-static RX_Stat Rx_Stat[EMAC_NUM_RX_FRAG];
-#elif defined   (  __GNUC__  )
-static __attribute__ ((aligned (8))) RX_Stat Rx_Stat[EMAC_NUM_RX_FRAG];
-#endif
-
-/** Tx Descriptor data array */
-static TX_Desc Tx_Desc[EMAC_NUM_TX_FRAG];
-/** Tx Status data array */
-static TX_Stat Tx_Stat[EMAC_NUM_TX_FRAG];
-
-/* EMAC local DMA buffers */
-/** Rx buffer data */
-static uint32_t rx_buf[EMAC_NUM_RX_FRAG][EMAC_ETH_MAX_FLEN&gt;&gt;2];
-/** Tx buffer data */
-static uint32_t tx_buf[EMAC_NUM_TX_FRAG][EMAC_ETH_MAX_FLEN&gt;&gt;2];
-
-/* EMAC call-back function pointer data */
-static EMAC_IntCBSType *_pfnIntCbDat[10];
-
-/**
- * @}
- */
-
-
-/* Private Functions ---------------------------------------------------------- */
-/** @defgroup EMAC_Private_Functions
- * @{
- */
-
-static void rx_descr_init (void);
-static void tx_descr_init (void);
-static int32_t write_PHY (uint32_t PhyReg, uint16_t Value);
-static int32_t  read_PHY (uint32_t PhyReg);
-
-
-/*--------------------------- rx_descr_init ---------------------------------*/
-
-/**
- * @brief 		Initializes RX Descriptor
- * @param[in]	None
- * @return		None
- */
-static void rx_descr_init (void)
-{
-	/* Initialize Receive Descriptor and Status array. */
-	uint32_t i;
-
-	for (i = 0; i &lt; EMAC_NUM_RX_FRAG; i++) {
-		Rx_Desc[i].Packet  = (uint32_t)&amp;rx_buf[i];
-		Rx_Desc[i].Ctrl    = EMAC_RCTRL_INT | (EMAC_ETH_MAX_FLEN - 1);
-		Rx_Stat[i].Info    = 0;
-		Rx_Stat[i].HashCRC = 0;
-	}
-
-	/* Set EMAC Receive Descriptor Registers. */
-	EMAC-&gt;RxDescriptor       = (uint32_t)&amp;Rx_Desc[0];
-	EMAC-&gt;RxStatus           = (uint32_t)&amp;Rx_Stat[0];
-	EMAC-&gt;RxDescriptorNumber = EMAC_NUM_RX_FRAG - 1;
-
-	/* Rx Descriptors Point to 0 */
-	EMAC-&gt;RxConsumeIndex  = 0;
-}
-
-
-/*--------------------------- tx_descr_init ---- ----------------------------*/
-/**
- * @brief 		Initializes TX Descriptor
- * @param[in]	None
- * @return		None
- */
-static void tx_descr_init (void) {
-	/* Initialize Transmit Descriptor and Status array. */
-	uint32_t i;
-
-	for (i = 0; i &lt; EMAC_NUM_TX_FRAG; i++) {
-		Tx_Desc[i].Packet = (uint32_t)&amp;tx_buf[i];
-		Tx_Desc[i].Ctrl   = 0;
-		Tx_Stat[i].Info   = 0;
-	}
-
-	/* Set EMAC Transmit Descriptor Registers. */
-	EMAC-&gt;TxDescriptor       = (uint32_t)&amp;Tx_Desc[0];
-	EMAC-&gt;TxStatus           = (uint32_t)&amp;Tx_Stat[0];
-	EMAC-&gt;TxDescriptorNumber = EMAC_NUM_TX_FRAG - 1;
-
-	/* Tx Descriptors Point to 0 */
-	EMAC-&gt;TxProduceIndex  = 0;
-}
-
-
-/*--------------------------- write_PHY -------------------------------------*/
-/**
- * @brief 		Write value to PHY device
- * @param[in]	PhyReg PHY Register address
- * @param[in]	Value Value to write
- * @return		(0) if sucess, otherwise return (-1)
- */
-static int32_t write_PHY (uint32_t PhyReg, uint16_t Value)
-{
-	/* Write a data 'Value' to PHY register 'PhyReg'. */
-	uint32_t tout;
-
-	EMAC-&gt;MADR = EMAC_DP83848C_DEF_ADR | PhyReg;
-	EMAC-&gt;MWTD = Value;
-
-	/* Wait until operation completed */
-	tout = 0;
-	for (tout = 0; tout &lt; EMAC_MII_WR_TOUT; tout++) {
-		if ((EMAC-&gt;MIND &amp; EMAC_MIND_BUSY) == 0) {
-			return (0);
-		}
-	}
-	// Time out!
-	return (-1);
-}
-
-
-/*--------------------------- read_PHY --------------------------------------*/
-/**
- * @brief 		Read value from PHY device
- * @param[in]	PhyReg PHY Register address
- * @return		Return value if success, otherwise return (-1)
- */
-static int32_t read_PHY (uint32_t PhyReg)
-{
-	/* Read a PHY register 'PhyReg'. */
-	uint32_t tout;
-
-	EMAC-&gt;MADR = EMAC_DP83848C_DEF_ADR | PhyReg;
-	EMAC-&gt;MCMD = EMAC_MCMD_READ;
-
-	/* Wait until operation completed */
-	tout = 0;
-	for (tout = 0; tout &lt; EMAC_MII_RD_TOUT; tout++) {
-		if ((EMAC-&gt;MIND &amp; EMAC_MIND_BUSY) == 0) {
-			EMAC-&gt;MCMD = 0;
-			return (EMAC-&gt;MRDD);
-		}
-	}
-	// Time out!
-	return (-1);
-}
-
-/*********************************************************************//**
- * @brief		Set Station MAC address for EMAC module
- * @param[in]	abStationAddr Pointer to Station address that contains 6-bytes
- * 				of MAC address (should be in order from MAC Address 1 to MAC Address 6)
- * @return		None
- **********************************************************************/
-void setEmacAddr(uint8_t abStationAddr[])
-{
-	/* Set the Ethernet MAC Address registers */
-	EMAC-&gt;SA0 = ((uint32_t)abStationAddr[5] &lt;&lt; 8) | (uint32_t)abStationAddr[4];
-	EMAC-&gt;SA1 = ((uint32_t)abStationAddr[3] &lt;&lt; 8) | (uint32_t)abStationAddr[2];
-	EMAC-&gt;SA2 = ((uint32_t)abStationAddr[1] &lt;&lt; 8) | (uint32_t)abStationAddr[0];
-}
-
-/**
- * @}
- */
-
-
-/* Public Functions ----------------------------------------------------------- */
-/** @addtogroup EMAC_Public_Functions
- * @{
- */
-
-
-/*********************************************************************//**
- * @brief		Initializes the EMAC peripheral according to the specified
-*               parameters in the EMAC_ConfigStruct.
- * @param[in]	EMAC_ConfigStruct Pointer to a EMAC_CFG_Type structure
-*                    that contains the configuration information for the
-*                    specified EMAC peripheral.
- * @return		None
- *
- * Note: This function will initialize EMAC module according to procedure below:
- *  - Remove the soft reset condition from the MAC
- *  - Configure the PHY via the MIIM interface of the MAC
- *  - Select RMII mode
- *  - Configure the transmit and receive DMA engines, including the descriptor arrays
- *  - Configure the host registers (MAC1,MAC2 etc.) in the MAC
- *  - Enable the receive and transmit data paths
- *  In default state after initializing, only Rx Done and Tx Done interrupt are enabled,
- *  all remain interrupts are disabled
- *  (Ref. from LPC17xx UM)
- **********************************************************************/
-Status EMAC_Init(EMAC_CFG_Type *EMAC_ConfigStruct)
-{
-	/* Initialize the EMAC Ethernet controller. */
-	int32_t regv,tout, tmp;
-
-	/* Set up clock and power for Ethernet module */
-	CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCENET, ENABLE);
-
-	/* Reset all EMAC internal modules */
-	EMAC-&gt;MAC1    = EMAC_MAC1_RES_TX | EMAC_MAC1_RES_MCS_TX | EMAC_MAC1_RES_RX |
-					EMAC_MAC1_RES_MCS_RX | EMAC_MAC1_SIM_RES | EMAC_MAC1_SOFT_RES;
-
-	EMAC-&gt;Command = EMAC_CR_REG_RES | EMAC_CR_TX_RES | EMAC_CR_RX_RES | EMAC_CR_PASS_RUNT_FRM;
-
-	/* A short delay after reset. */
-	for (tout = 100; tout; tout--);
-
-	/* Initialize MAC control registers. */
-	EMAC-&gt;MAC1 = EMAC_MAC1_PASS_ALL;
-	EMAC-&gt;MAC2 = EMAC_MAC2_CRC_EN | EMAC_MAC2_PAD_EN;
-	EMAC-&gt;MAXF = EMAC_ETH_MAX_FLEN;
-	/*
-	 * Find the clock that close to desired target clock
-	 */
-	tmp = SystemFrequency / EMAC_MCFG_MII_MAXCLK;
-	for (tout = 0; tout &lt; sizeof (EMAC_clkdiv); tout++){
-		if (EMAC_clkdiv[tout] &gt;= tmp) break;
-	}
-	tout++;
-	// Write to MAC configuration register and reset
-	EMAC-&gt;MCFG = EMAC_MCFG_CLK_SEL(tout) | EMAC_MCFG_RES_MII;
-	// release reset
-	EMAC-&gt;MCFG &amp;= ~(EMAC_MCFG_RES_MII);
-	EMAC-&gt;CLRT = EMAC_CLRT_DEF;
-	EMAC-&gt;IPGR = EMAC_IPGR_P2_DEF;
-
-	/* Enable Reduced MII interface. */
-	EMAC-&gt;Command = EMAC_CR_RMII | EMAC_CR_PASS_RUNT_FRM;
-
-	/* Reset Reduced MII Logic. */
-	EMAC-&gt;SUPP = EMAC_SUPP_RES_RMII;
-
-	for (tout = 100; tout; tout--);
-	EMAC-&gt;SUPP = 0;
-
-	/* Put the DP83848C in reset mode */
-	write_PHY (EMAC_PHY_REG_BMCR, EMAC_PHY_BMCR_RESET);
-
-	/* Wait for hardware reset to end. */
-	for (tout = EMAC_PHY_RESP_TOUT; tout; tout--) {
-		regv = read_PHY (EMAC_PHY_REG_BMCR);
-		if (!(regv &amp; (EMAC_PHY_BMCR_RESET | EMAC_PHY_BMCR_POWERDOWN))) {
-			/* Reset complete, device not Power Down. */
-			break;
-		}
-		if (tout == 0){
-			// Time out, return ERROR
-			return (ERROR);
-		}
-	}
-
-	// Set PHY mode
-	if (EMAC_SetPHYMode(EMAC_ConfigStruct-&gt;Mode) &lt; 0){
-		return (ERROR);
-	}
-
-	// Set EMAC address
-	setEmacAddr(EMAC_ConfigStruct-&gt;pbEMAC_Addr);
-
-	/* Initialize Tx and Rx DMA Descriptors */
-	rx_descr_init ();
-	tx_descr_init ();
-
-	// Set Receive Filter register: enable broadcast and multicast
-	EMAC-&gt;RxFilterCtrl = EMAC_RFC_MCAST_EN | EMAC_RFC_BCAST_EN | EMAC_RFC_PERFECT_EN;
-
-	/* Enable Rx Done and Tx Done interrupt for EMAC */
-	EMAC-&gt;IntEnable = EMAC_INT_RX_DONE | EMAC_INT_TX_DONE;
-
-	/* Reset all interrupts */
-	EMAC-&gt;IntClear  = 0xFFFF;
-
-	/* Enable receive and transmit mode of MAC Ethernet core */
-	EMAC-&gt;Command  |= (EMAC_CR_RX_EN | EMAC_CR_TX_EN);
-	EMAC-&gt;MAC1     |= EMAC_MAC1_REC_EN;
-
-	return SUCCESS;
-}
-
-
-/*********************************************************************//**
- * @brief		De-initializes the EMAC peripheral registers to their
-*                  default reset values.
- * @param[in]	None
- * @return 		None
- **********************************************************************/
-void EMAC_DeInit(void)
-{
-	// Disable all interrupt
-	EMAC-&gt;IntEnable = 0x00;
-	// Clear all pending interrupt
-	EMAC-&gt;IntClear = (0xFF) | (EMAC_INT_SOFT_INT | EMAC_INT_WAKEUP);
-
-	/* TurnOff clock and power for Ethernet module */
-	CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCENET, DISABLE);
-}
-
-
-/*********************************************************************//**
- * @brief		Check specified PHY status in EMAC peripheral
- * @param[in]	ulPHYState	Specified PHY Status Type, should be:
- * 							- EMAC_PHY_STAT_LINK: Link Status
- * 							- EMAC_PHY_STAT_SPEED: Speed Status
- * 							- EMAC_PHY_STAT_DUP: Duplex Status
- * @return		Status of specified PHY status (0 or 1).
- * 				(-1) if error.
- *
- * Note:
- * For EMAC_PHY_STAT_LINK, return value:
- * - 0: Link Down
- * - 1: Link Up
- * For EMAC_PHY_STAT_SPEED, return value:
- * - 0: 10Mbps
- * - 1: 100Mbps
- * For EMAC_PHY_STAT_DUP, return value:
- * - 0: Half-Duplex
- * - 1: Full-Duplex
- **********************************************************************/
-int32_t EMAC_CheckPHYStatus(uint32_t ulPHYState)
-{
-	int32_t regv, tmp;
-
-	regv = read_PHY (EMAC_PHY_REG_STS);
-	switch(ulPHYState){
-	case EMAC_PHY_STAT_LINK:
-		tmp = (regv &amp; EMAC_PHY_SR_LINK) ? 1 : 0;
-		break;
-	case EMAC_PHY_STAT_SPEED:
-		tmp = (regv &amp; EMAC_PHY_SR_SPEED) ? 0 : 1;
-		break;
-	case EMAC_PHY_STAT_DUP:
-		tmp = (regv &amp; EMAC_PHY_SR_DUP) ? 1 : 0;
-		break;
-	default:
-		tmp = -1;
-		break;
-	}
-	return (tmp);
-}
-
-
-/*********************************************************************//**
- * @brief		Set specified PHY mode in EMAC peripheral
- * @param[in]	ulPHYState	Specified PHY mode, should be:
- * 							- EMAC_MODE_AUTO
- * 							- EMAC_MODE_10M_FULL
- * 							- EMAC_MODE_10M_HALF
- * 							- EMAC_MODE_100M_FULL
- * 							- EMAC_MODE_100M_HALF
- * @return		Return (0) if no error, otherwise return (-1)
- **********************************************************************/
-int32_t EMAC_SetPHYMode(uint32_t ulPHYMode)
-{
-	int32_t id1, id2, tout, regv;
-
-	/* Check if this is a DP83848C PHY. */
-	id1 = read_PHY (EMAC_PHY_REG_IDR1);
-	id2 = read_PHY (EMAC_PHY_REG_IDR2);
-
-	if (((id1 &lt;&lt; 16) | (id2 &amp; 0xFFF0)) == EMAC_DP83848C_ID) {
-		/* Configure the PHY device */
-		switch(ulPHYMode){
-		case EMAC_MODE_AUTO:
-			/* Use auto-negotiation about the link speed. */
-			write_PHY (EMAC_PHY_REG_BMCR, EMAC_PHY_AUTO_NEG);
-			/* Wait to complete Auto_Negotiation */
-			for (tout = EMAC_PHY_RESP_TOUT; tout; tout--) {
-				regv = read_PHY (EMAC_PHY_REG_BMSR);
-				if (regv &amp; EMAC_PHY_BMSR_AUTO_DONE) {
-					/* Auto-negotiation Complete. */
-					break;
-				}
-				if (tout == 0){
-					// Time out, return error
-					return (-1);
-				}
-			}
-			break;
-		case EMAC_MODE_10M_FULL:
-			/* Connect at 10MBit full-duplex */
-			write_PHY (EMAC_PHY_REG_BMCR, EMAC_PHY_FULLD_10M);
-			break;
-		case EMAC_MODE_10M_HALF:
-			/* Connect at 10MBit half-duplex */
-			write_PHY (EMAC_PHY_REG_BMCR, EMAC_PHY_HALFD_10M);
-			break;
-		case EMAC_MODE_100M_FULL:
-			/* Connect at 100MBit full-duplex */
-			write_PHY (EMAC_PHY_REG_BMCR, EMAC_PHY_FULLD_100M);
-			break;
-		case EMAC_MODE_100M_HALF:
-			/* Connect at 100MBit half-duplex */
-			write_PHY (EMAC_PHY_REG_BMCR, EMAC_PHY_HALFD_100M);
-			break;
-		default:
-			// un-supported
-			return (-1);
-		}
-	}
-	// It's not correct module ID
-	else {
-		return (-1);
-	}
-
-	// Update EMAC configuration with current PHY status
-	if (EMAC_UpdatePHYStatus() &lt; 0){
-		return (-1);
-	}
-
-	// Complete
-	return (0);
-}
-
-
-/*********************************************************************//**
- * @brief		Auto-Configures value for the EMAC configuration register to
- * 				match with current PHY mode
- * @param[in]	None
- * @return		Return (0) if no error, otherwise return (-1)
- *
- * Note: The EMAC configuration will be auto-configured:
- * 		- Speed mode.
- * 		- Half/Full duplex mode
- **********************************************************************/
-int32_t EMAC_UpdatePHYStatus(void)
-{
-	int32_t regv, tout;
-
-	/* Check the link status. */
-	for (tout = EMAC_PHY_RESP_TOUT; tout; tout--) {
-		regv = read_PHY (EMAC_PHY_REG_STS);
-		if (regv &amp; EMAC_PHY_SR_LINK) {
-			/* Link is on. */
-			break;
-		}
-		if (tout == 0){
-			// time out
-			return (-1);
-		}
-	}
-
-	/* Configure Full/Half Duplex mode. */
-	if (regv &amp; EMAC_PHY_SR_DUP) {
-		/* Full duplex is enabled. */
-		EMAC-&gt;MAC2    |= EMAC_MAC2_FULL_DUP;
-		EMAC-&gt;Command |= EMAC_CR_FULL_DUP;
-		EMAC-&gt;IPGT     = EMAC_IPGT_FULL_DUP;
-	} else {
-		/* Half duplex mode. */
-		EMAC-&gt;IPGT = EMAC_IPGT_HALF_DUP;
-	}
-
-	/* Configure 100MBit/10MBit mode. */
-	if (regv &amp; EMAC_PHY_SR_SPEED) {
-		/* 10MBit mode. */
-		EMAC-&gt;SUPP = 0;
-	} else {
-		/* 100MBit mode. */
-		EMAC-&gt;SUPP = EMAC_SUPP_SPEED;
-	}
-
-	// Complete
-	return (0);
-}
-
-
-/*********************************************************************//**
- * @brief		Enable/Disable hash filter functionality for specified destination
- * 				MAC address in EMAC module
- * @param[in]	dstMAC_addr		Pointer to the first MAC destination address, should
- * 								be 6-bytes length, in order LSB to the MSB
- * @param[in]	NewState		New State of this command, should be:
- *									- ENABLE.
- *									- DISABLE.
- * @return		None
- *
- * Note:
- * The standard Ethernet cyclic redundancy check (CRC) function is calculated from
- * the 6 byte destination address in the Ethernet frame (this CRC is calculated
- * anyway as part of calculating the CRC of the whole frame), then bits [28:23] out of
- * the 32 bits CRC result are taken to form the hash. The 6 bit hash is used to access
- * the hash table: it is used as an index in the 64 bit HashFilter register that has been
- * programmed with accept values. If the selected accept value is 1, the frame is
- * accepted.
- **********************************************************************/
-void EMAC_SetHashFilter(uint8_t dstMAC_addr[], FunctionalState NewState)
-{
-	uint32_t *pReg;
-	uint32_t tmp;
-	int32_t crc;
-
-	// Calculate the CRC from the destination MAC address
-	crc = EMAC_CRCCalc(dstMAC_addr, 6);
-	// Extract the value from CRC to get index value for hash filter table
-	crc = (crc &gt;&gt; 23) &amp; 0x3F;
-
-	pReg = (crc &gt; 31) ? ((uint32_t *)&amp;EMAC-&gt;HashFilterH) \
-								: ((uint32_t *)&amp;EMAC-&gt;HashFilterL);
-	tmp = (crc &gt; 31) ? (crc - 32) : crc;
-	if (NewState == ENABLE) {
-		(*pReg) |= (1UL &lt;&lt; tmp);
-	} else {
-		(*pReg) &amp;= ~(1UL &lt;&lt; tmp);
-	}
-	// Enable Rx Filter
-	EMAC-&gt;Command &amp;= ~EMAC_CR_PASS_RX_FILT;
-}
-
-
-/*********************************************************************//**
- * @brief		Calculates CRC code for number of bytes in the frame
- * @param[in]	frame_no_fcs	Pointer to the first byte of the frame
- * @param[in]	frame_len		length of the frame without the FCS
- * @return		the CRC as a 32 bit integer
- **********************************************************************/
-int32_t EMAC_CRCCalc(uint8_t frame_no_fcs[], int32_t frame_len)
-{
-	int i; 		// iterator
-	int j; 		// another iterator
-	char byte; 	// current byte
-	int crc; 	// CRC result
-	int q0, q1, q2, q3; // temporary variables
-	crc = 0xFFFFFFFF;
-	for (i = 0; i &lt; frame_len; i++) {
-		byte = *frame_no_fcs++;
-		for (j = 0; j &lt; 2; j++) {
-			if (((crc &gt;&gt; 28) ^ (byte &gt;&gt; 3)) &amp; 0x00000001) {
-				q3 = 0x04C11DB7;
-			} else {
-				q3 = 0x00000000;
-			}
-			if (((crc &gt;&gt; 29) ^ (byte &gt;&gt; 2)) &amp; 0x00000001) {
-				q2 = 0x09823B6E;
-			} else {
-				q2 = 0x00000000;
-			}
-			if (((crc &gt;&gt; 30) ^ (byte &gt;&gt; 1)) &amp; 0x00000001) {
-				q1 = 0x130476DC;
-			} else {
-				q1 = 0x00000000;
-			}
-			if (((crc &gt;&gt; 31) ^ (byte &gt;&gt; 0)) &amp; 0x00000001) {
-				q0 = 0x2608EDB8;
-			} else {
-				q0 = 0x00000000;
-			}
-			crc = (crc &lt;&lt; 4) ^ q3 ^ q2 ^ q1 ^ q0;
-			byte &gt;&gt;= 4;
-		}
-	}
-	return crc;
-}
-
-/*********************************************************************//**
- * @brief		Enable/Disable Filter mode for each specified type EMAC peripheral
- * @param[in]	ulFilterMode	Filter mode, should be:
- * 								- EMAC_RFC_UCAST_EN: all frames of unicast types
- * 								will be accepted
- * 								- EMAC_RFC_BCAST_EN: broadcast frame will be
- * 								accepted
- * 								- EMAC_RFC_MCAST_EN: all frames of multicast
- * 								types will be accepted
- * 								- EMAC_RFC_UCAST_HASH_EN: The imperfect hash
- * 								filter will be applied to unicast addresses
- * 								- EMAC_RFC_MCAST_HASH_EN: The imperfect hash
- * 								filter will be applied to multicast addresses
- * 								- EMAC_RFC_PERFECT_EN: the destination address
- * 								will be compared with the 6 byte station address
- * 								programmed in the station address by the filter
- * 								- EMAC_RFC_MAGP_WOL_EN: the result of the magic
- * 								packet filter will generate a WoL interrupt when
- * 								there is a match
- * 								- EMAC_RFC_PFILT_WOL_EN: the result of the perfect address
- * 								matching filter and the imperfect hash filter will
- * 								generate a WoL interrupt when there is a match
- * @param[in]	NewState	New State of this command, should be:
- * 								- ENABLE
- * 								- DISABLE
- * @return		None
- **********************************************************************/
-void EMAC_SetFilterMode(uint32_t ulFilterMode, FunctionalState NewState)
-{
-	if (NewState == ENABLE){
-		EMAC-&gt;RxFilterCtrl |= ulFilterMode;
-	} else {
-		EMAC-&gt;RxFilterCtrl &amp;= ~ulFilterMode;
-	}
-}
-
-/*********************************************************************//**
- * @brief		Get status of Wake On LAN Filter for each specified
- * 				type in EMAC peripheral, clear this status if it is set
- * @param[in]	ulFilterMode	WoL Filter mode, should be:
- * 								- EMAC_WOL_UCAST: unicast frames caused WoL
- * 								- EMAC_WOL_UCAST: broadcast frame caused WoL
- * 								- EMAC_WOL_MCAST: multicast frame caused WoL
- * 								- EMAC_WOL_UCAST_HASH: unicast frame that passes the
- * 								imperfect hash filter caused WoL
- * 								- EMAC_WOL_MCAST_HASH: multicast frame that passes the
- * 								imperfect hash filter caused WoL
- * 								- EMAC_WOL_PERFECT:perfect address matching filter
- * 								caused WoL
- * 								- EMAC_WOL_RX_FILTER: the receive filter caused WoL
- * 								- EMAC_WOL_MAG_PACKET: the magic packet filter caused WoL
- * @return		SET/RESET
- **********************************************************************/
-FlagStatus EMAC_GetWoLStatus(uint32_t ulWoLMode)
-{
-	if (EMAC-&gt;RxFilterWoLStatus &amp; ulWoLMode) {
-		EMAC-&gt;RxFilterWoLClear = ulWoLMode;
-		return SET;
-	} else {
-		return RESET;
-	}
-}
-
-
-/*********************************************************************//**
- * @brief		Write data to Tx packet data buffer at current index due to
- * 				TxProduceIndex
- * @param[in]	pDataStruct		Pointer to a EMAC_PACKETBUF_Type structure
- * 							data that contain specified information about
- * 							Packet data buffer.
- * @return		None
- **********************************************************************/
-void EMAC_WritePacketBuffer(EMAC_PACKETBUF_Type *pDataStruct)
-{
-	uint32_t idx,len;
-	uint32_t *sp,*dp;
-
-	idx = EMAC-&gt;TxProduceIndex;
-	sp  = (uint32_t *)pDataStruct-&gt;pbDataBuf;
-	dp  = (uint32_t *)Tx_Desc[idx].Packet;
-	/* Copy frame data to EMAC packet buffers. */
-	for (len = (pDataStruct-&gt;ulDataLen + 3) &gt;&gt; 2; len; len--) {
-		*dp++ = *sp++;
-	}
-	Tx_Desc[idx].Ctrl = (pDataStruct-&gt;ulDataLen - 1) | (EMAC_TCTRL_INT | EMAC_TCTRL_LAST);
-}
-
-/*********************************************************************//**
- * @brief		Read data from Rx packet data buffer at current index due
- * 				to RxConsumeIndex
- * @param[in]	pDataStruct		Pointer to a EMAC_PACKETBUF_Type structure
- * 							data that contain specified information about
- * 							Packet data buffer.
- * @return		None
- **********************************************************************/
-void EMAC_ReadPacketBuffer(EMAC_PACKETBUF_Type *pDataStruct)
-{
-	uint32_t idx, len;
-	uint32_t *dp, *sp;
-
-	idx = EMAC-&gt;RxConsumeIndex;
-	dp = (uint32_t *)pDataStruct-&gt;pbDataBuf;
-	sp = (uint32_t *)Rx_Desc[idx].Packet;
-
-	if (pDataStruct-&gt;pbDataBuf != NULL) {
-		for (len = (pDataStruct-&gt;ulDataLen + 3) &gt;&gt; 2; len; len--) {
-			*dp++ = *sp++;
-		}
-	}
-}
-
-/*********************************************************************//**
- * @brief		Standard EMAC IRQ Handler. This sub-routine will check
- * 				these following interrupt and call the call-back function
- * 				if they're already installed:
- * 				- Overrun Error interrupt in RX Queue
- * 				- Receive Error interrupt: AlignmentError, RangeError,
- * 				LengthError, SymbolError, CRCError or NoDescriptor or Overrun
- * 				- RX Finished Process Descriptors interrupt (ProduceIndex == ConsumeIndex)
- * 				- Receive Done interrupt
- * 				- Transmit Under-run interrupt
- * 				- Transmit errors interrupt : LateCollision, ExcessiveCollision
- * 				and ExcessiveDefer, NoDescriptor or Under-run
- * 				- TX Finished Process Descriptors interrupt (ProduceIndex == ConsumeIndex)
- * 				- Transmit Done interrupt
- * 				- Interrupt triggered by software
- *				- Interrupt triggered by a Wakeup event detected by the receive filter
- * @param[in]	None
- * @return		None
- **********************************************************************/
-void EMAC_StandardIRQHandler(void)
-{
-	/* EMAC Ethernet Controller Interrupt function. */
-	uint32_t n, int_stat;
-
-	// Get EMAC interrupt status
-	while ((int_stat = (EMAC-&gt;IntStatus &amp; EMAC-&gt;IntEnable)) != 0) {
-		// Clear interrupt status
-		EMAC-&gt;IntClear = int_stat;
-		// Execute call-back function
-		for (n = 0; n &lt;= 7; n++) {
-			if ((int_stat &amp; (1 &lt;&lt; n)) &amp;&amp; (_pfnIntCbDat[n] != NULL)) {
-				_pfnIntCbDat[n]();
-			}
-		}
-		// Soft interrupt
-		if ((int_stat &amp; EMAC_INT_SOFT_INT) &amp;&amp; (_pfnIntCbDat[8] != NULL)) {
-			_pfnIntCbDat[8]();
-		}
-		// WakeUp interrupt
-		if ((int_stat &amp; EMAC_INT_WAKEUP) &amp;&amp; (_pfnIntCbDat[9] != NULL)) {
-			// Clear WoL interrupt
-			EMAC-&gt;RxFilterWoLClear = EMAC_WOL_BITMASK;
-			_pfnIntCbDat[9]();
-		}
-	}
-}
-
-
-/*********************************************************************//**
- * @brief		Setup/register Call-back function for each interrupt type
- * 				in EMAC module.
- * @param[in]	ulIntType	Interrupt type, should be one of the following:
- * 							- EMAC_INT_RX_OVERRUN: Receive Overrun
- * 							- EMAC_INT_RX_ERR: Receive Error
- * 							- EMAC_INT_RX_FIN: Receive Descriptor Finish
- * 							- EMAC_INT_RX_DONE: Receive Done
- * 							- EMAC_INT_TX_UNDERRUN: Transmit Under-run
- * 							- EMAC_INT_TX_ERR: Transmit Error
- * 							- EMAC_INT_TX_FIN: Transmit descriptor finish
- * 							- EMAC_INT_TX_DONE: Transmit Done
- * 							- EMAC_INT_SOFT_INT: Software interrupt
- * 							- EMAC_INT_WAKEUP: Wakeup interrupt
- * @param[in]	pfnIntCb	Pointer to Call-back function used for this
- * 							interrupt type
- * @return		None
- **********************************************************************/
-void EMAC_SetupIntCBS(uint32_t ulIntType, EMAC_IntCBSType *pfnIntCb)
-{
-	/* EMAC Ethernet Controller Interrupt function. */
-	uint32_t n;
-
-	if (ulIntType &lt;= EMAC_INT_TX_DONE){
-		for (n = 0; n &lt;= 7; n++) {
-			// Found it, install cbs now
-			if (ulIntType &amp; (1 &lt;&lt; n)) {
-				_pfnIntCbDat[n] = pfnIntCb;
-				// Don't install cbs any more
-				break;
-			}
-		}
-	} else if (ulIntType &amp; EMAC_INT_SOFT_INT) {
-		_pfnIntCbDat[8] = pfnIntCb;
-	} else if (ulIntType &amp; EMAC_INT_WAKEUP) {
-		_pfnIntCbDat[9] = pfnIntCb;
-	}
-}
-
-/*********************************************************************//**
- * @brief 		Enable/Disable interrupt for each type in EMAC
- * @param[in]	ulIntType	Interrupt Type, should be:
- * 							- EMAC_INT_RX_OVERRUN: Receive Overrun
- * 							- EMAC_INT_RX_ERR: Receive Error
- * 							- EMAC_INT_RX_FIN: Receive Descriptor Finish
- * 							- EMAC_INT_RX_DONE: Receive Done
- * 							- EMAC_INT_TX_UNDERRUN: Transmit Under-run
- * 							- EMAC_INT_TX_ERR: Transmit Error
- * 							- EMAC_INT_TX_FIN: Transmit descriptor finish
- * 							- EMAC_INT_TX_DONE: Transmit Done
- * 							- EMAC_INT_SOFT_INT: Software interrupt
- * 							- EMAC_INT_WAKEUP: Wakeup interrupt
- * @param[in]	NewState	New State of this function, should be:
- * 							- ENABLE.
- * 							- DISABLE.
- * @return		None
- **********************************************************************/
-void EMAC_IntCmd(uint32_t ulIntType, FunctionalState NewState)
-{
-	if (NewState == ENABLE) {
-		EMAC-&gt;IntEnable |= ulIntType;
-	} else {
-		EMAC-&gt;IntEnable &amp;= ~(ulIntType);
-	}
-}
-
-/*********************************************************************//**
- * @brief 		Check whether if specified interrupt flag is set or not
- * 				for each interrupt type in EMAC and clear interrupt pending
- * 				if it is set.
- * @param[in]	ulIntType	Interrupt Type, should be:
- * 							- EMAC_INT_RX_OVERRUN: Receive Overrun
- * 							- EMAC_INT_RX_ERR: Receive Error
- * 							- EMAC_INT_RX_FIN: Receive Descriptor Finish
- * 							- EMAC_INT_RX_DONE: Receive Done
- * 							- EMAC_INT_TX_UNDERRUN: Transmit Under-run
- * 							- EMAC_INT_TX_ERR: Transmit Error
- * 							- EMAC_INT_TX_FIN: Transmit descriptor finish
- * 							- EMAC_INT_TX_DONE: Transmit Done
- * 							- EMAC_INT_SOFT_INT: Software interrupt
- * 							- EMAC_INT_WAKEUP: Wakeup interrupt
- * @return		New state of specified interrupt (SET or RESET)
- **********************************************************************/
-IntStatus EMAC_IntGetStatus(uint32_t ulIntType)
-{
-	if (EMAC-&gt;IntStatus &amp; ulIntType) {
-		EMAC-&gt;IntClear = ulIntType;
-		return SET;
-	} else {
-		return RESET;
-	}
-}
-
-
-/*********************************************************************//**
- * @brief		Check whether if the current RxConsumeIndex is not equal to the
- * 				current RxProduceIndex.
- * @param[in]	None
- * @return		TRUE if they're not equal, otherwise return FALSE
- *
- * Note: In case the RxConsumeIndex is not equal to the RxProduceIndex,
- * it means there're available data has been received. They should be read
- * out and released the Receive Data Buffer by updating the RxConsumeIndex value.
- **********************************************************************/
-Bool EMAC_CheckReceiveIndex(void)
-{
-	if (EMAC-&gt;RxConsumeIndex != EMAC-&gt;RxProduceIndex) {
-		return TRUE;
-	} else {
-		return FALSE;
-	}
-}
-
-
-/*********************************************************************//**
- * @brief		Check whether if the current TxProduceIndex is not equal to the
- * 				current RxProduceIndex - 1.
- * @param[in]	None
- * @return		TRUE if they're not equal, otherwise return FALSE
- *
- * Note: In case the RxConsumeIndex is equal to the RxProduceIndex - 1,
- * it means the transmit buffer is available and data can be written to transmit
- * buffer to be sent.
- **********************************************************************/
-Bool EMAC_CheckTransmitIndex(void)
-{
-	uint32_t tmp = EMAC-&gt;TxConsumeIndex -1;
-	if (EMAC-&gt;TxProduceIndex == tmp) {
-		return FALSE;
-	} else {
-		return TRUE;
-	}
-}
-
-
-/*********************************************************************//**
- * @brief		Get current status value of receive data (due to RxConsumeIndex)
- * @param[in]	ulRxDatStat	Received Status type, should be one of following:
- * 							- EMAC_RINFO_CTRL_FRAME: Control Frame
- * 							- EMAC_RINFO_VLAN: VLAN Frame
- * 							- EMAC_RINFO_FAIL_FILT: RX Filter Failed
- * 							- EMAC_RINFO_MCAST: Multicast Frame
- * 							- EMAC_RINFO_BCAST: Broadcast Frame
- * 							- EMAC_RINFO_CRC_ERR: CRC Error in Frame
- * 							- EMAC_RINFO_SYM_ERR: Symbol Error from PHY
- * 							- EMAC_RINFO_LEN_ERR: Length Error
- * 							- EMAC_RINFO_RANGE_ERR: Range error(exceeded max size)
- * 							- EMAC_RINFO_ALIGN_ERR: Alignment error
- * 							- EMAC_RINFO_OVERRUN: Receive overrun
- * 							- EMAC_RINFO_NO_DESCR: No new Descriptor available
- * 							- EMAC_RINFO_LAST_FLAG: last Fragment in Frame
- * 							- EMAC_RINFO_ERR: Error Occurred (OR of all error)
- * @return		Current value of receive data (due to RxConsumeIndex)
- **********************************************************************/
-FlagStatus EMAC_CheckReceiveDataStatus(uint32_t ulRxStatType)
-{
-	uint32_t idx;
-	idx = EMAC-&gt;RxConsumeIndex;
-	return (((Rx_Stat[idx].Info) &amp; ulRxStatType) ? SET : RESET);
-}
-
-
-/*********************************************************************//**
- * @brief		Get size of current Received data in received buffer (due to
- * 				RxConsumeIndex)
- * @param[in]	None
- * @return		Size of received data
- **********************************************************************/
-uint32_t EMAC_GetReceiveDataSize(void)
-{
-	uint32_t idx;
-	idx = EMAC-&gt;RxConsumeIndex;
-	return ((Rx_Stat[idx].Info) &amp; EMAC_RINFO_SIZE);
-}
-
-/*********************************************************************//**
- * @brief		Increase the RxConsumeIndex (after reading the Receive buffer
- * 				to release the Receive buffer) and wrap-around the index if
- * 				it reaches the maximum Receive Number
- * @param[in]	None
- * @return		None
- **********************************************************************/
-void EMAC_UpdateRxConsumeIndex(void)
-{
-	// Get current Rx consume index
-	uint32_t idx = EMAC-&gt;RxConsumeIndex;
-
-	/* Release frame from EMAC buffer */
-	if (++idx == EMAC_NUM_RX_FRAG) idx = 0;
-	EMAC-&gt;RxConsumeIndex = idx;
-}
-
-/*********************************************************************//**
- * @brief		Increase the TxProduceIndex (after writting to the Transmit buffer
- * 				to enable the Transmit buffer) and wrap-around the index if
- * 				it reaches the maximum Transmit Number
- * @param[in]	None
- * @return		None
- **********************************************************************/
-void EMAC_UpdateTxProduceIndex(void)
-{
-	// Get current Tx produce index
-	uint32_t idx = EMAC-&gt;TxProduceIndex;
-
-	/* Start frame transmission */
-	if (++idx == EMAC_NUM_TX_FRAG) idx = 0;
-	EMAC-&gt;TxProduceIndex = idx;
-}
-
-
-/**
- * @}
- */
-
-#endif /* _EMAC */
-
-/**
- * @}
- */
-
-/* --------------------------------- End Of File ------------------------------ */
+/**
+ * @file	: lpc17xx_emac.c
+ * @brief	: Contains all functions support for Ethernet MAC firmware library on LPC17xx
+ * @version	: 1.0
+ * @date	: 02. Jun. 2009
+ * @author	: HieuNguyen
+ **************************************************************************
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * products. This software is supplied &quot;AS IS&quot; without any warranties.
+ * NXP Semiconductors assumes no responsibility or liability for the
+ * use of the software, conveys no license or title under any patent,
+ * copyright, or mask work right to the product. NXP Semiconductors
+ * reserves the right to make changes in the software without
+ * notification. NXP Semiconductors also make no representation or
+ * warranty that such application will be suitable for the specified
+ * use without further testing or modification.
+ **********************************************************************/
+
+/* Peripheral group ----------------------------------------------------------- */
+/** @addtogroup EMAC
+ * @{
+ */
+
+/* Includes ------------------------------------------------------------------- */
+#include &quot;lpc17xx_emac.h&quot;
+#include &quot;lpc17xx_clkpwr.h&quot;
+
+/* If this source file built with example, the LPC17xx FW library configuration
+ * file in each example directory (&quot;lpc17xx_libcfg.h&quot;) must be included,
+ * otherwise the default FW library configuration file must be included instead
+ */
+#ifdef __BUILD_WITH_EXAMPLE__
+#include &quot;lpc17xx_libcfg.h&quot;
+#else
+#include &quot;lpc17xx_libcfg_default.h&quot;
+#endif /* __BUILD_WITH_EXAMPLE__ */
+
+
+#ifdef _EMAC
+
+/* Private Variables ---------------------------------------------------------- */
+/** @defgroup EMAC_Private_Variables
+ * @{
+ */
+
+/* MII Mgmt Configuration register - Clock divider setting */
+const uint8_t EMAC_clkdiv[] = { 4, 6, 8, 10, 14, 20, 28 };
+
+/* EMAC local DMA Descriptors */
+
+/** Rx Descriptor data array */
+static RX_Desc Rx_Desc[EMAC_NUM_RX_FRAG];
+
+/** Rx Status data array - Must be 8-Byte aligned */
+#if defined ( __CC_ARM   )
+static __align(8) RX_Stat Rx_Stat[EMAC_NUM_RX_FRAG];
+#elif defined ( __ICCARM__ )
+#pragma data_alignment=8
+static RX_Stat Rx_Stat[EMAC_NUM_RX_FRAG];
+#elif defined   (  __GNUC__  )
+static __attribute__ ((aligned (8))) RX_Stat Rx_Stat[EMAC_NUM_RX_FRAG];
+#endif
+
+/** Tx Descriptor data array */
+static TX_Desc Tx_Desc[EMAC_NUM_TX_FRAG];
+/** Tx Status data array */
+static TX_Stat Tx_Stat[EMAC_NUM_TX_FRAG];
+
+/* EMAC local DMA buffers */
+/** Rx buffer data */
+static uint32_t rx_buf[EMAC_NUM_RX_FRAG][EMAC_ETH_MAX_FLEN&gt;&gt;2];
+/** Tx buffer data */
+static uint32_t tx_buf[EMAC_NUM_TX_FRAG][EMAC_ETH_MAX_FLEN&gt;&gt;2];
+
+/* EMAC call-back function pointer data */
+static EMAC_IntCBSType *_pfnIntCbDat[10];
+
+/**
+ * @}
+ */
+
+
+/* Private Functions ---------------------------------------------------------- */
+/** @defgroup EMAC_Private_Functions
+ * @{
+ */
+
+static void rx_descr_init (void);
+static void tx_descr_init (void);
+static int32_t write_PHY (uint32_t PhyReg, uint16_t Value);
+static int32_t  read_PHY (uint32_t PhyReg);
+
+
+/*--------------------------- rx_descr_init ---------------------------------*/
+
+/**
+ * @brief 		Initializes RX Descriptor
+ * @param[in]	None
+ * @return		None
+ */
+static void rx_descr_init (void)
+{
+	/* Initialize Receive Descriptor and Status array. */
+	uint32_t i;
+
+	for (i = 0; i &lt; EMAC_NUM_RX_FRAG; i++) {
+		Rx_Desc[i].Packet  = (uint32_t)&amp;rx_buf[i];
+		Rx_Desc[i].Ctrl    = EMAC_RCTRL_INT | (EMAC_ETH_MAX_FLEN - 1);
+		Rx_Stat[i].Info    = 0;
+		Rx_Stat[i].HashCRC = 0;
+	}
+
+	/* Set EMAC Receive Descriptor Registers. */
+	LPC_EMAC-&gt;RxDescriptor       = (uint32_t)&amp;Rx_Desc[0];
+	LPC_EMAC-&gt;RxStatus           = (uint32_t)&amp;Rx_Stat[0];
+	LPC_EMAC-&gt;RxDescriptorNumber = EMAC_NUM_RX_FRAG - 1;
+
+	/* Rx Descriptors Point to 0 */
+	LPC_EMAC-&gt;RxConsumeIndex  = 0;
+}
+
+
+/*--------------------------- tx_descr_init ---- ----------------------------*/
+/**
+ * @brief 		Initializes TX Descriptor
+ * @param[in]	None
+ * @return		None
+ */
+static void tx_descr_init (void) {
+	/* Initialize Transmit Descriptor and Status array. */
+	uint32_t i;
+
+	for (i = 0; i &lt; EMAC_NUM_TX_FRAG; i++) {
+		Tx_Desc[i].Packet = (uint32_t)&amp;tx_buf[i];
+		Tx_Desc[i].Ctrl   = 0;
+		Tx_Stat[i].Info   = 0;
+	}
+
+	/* Set EMAC Transmit Descriptor Registers. */
+	LPC_EMAC-&gt;TxDescriptor       = (uint32_t)&amp;Tx_Desc[0];
+	LPC_EMAC-&gt;TxStatus           = (uint32_t)&amp;Tx_Stat[0];
+	LPC_EMAC-&gt;TxDescriptorNumber = EMAC_NUM_TX_FRAG - 1;
+
+	/* Tx Descriptors Point to 0 */
+	LPC_EMAC-&gt;TxProduceIndex  = 0;
+}
+
+
+/*--------------------------- write_PHY -------------------------------------*/
+/**
+ * @brief 		Write value to PHY device
+ * @param[in]	PhyReg PHY Register address
+ * @param[in]	Value Value to write
+ * @return		(0) if sucess, otherwise return (-1)
+ */
+static int32_t write_PHY (uint32_t PhyReg, uint16_t Value)
+{
+	/* Write a data 'Value' to PHY register 'PhyReg'. */
+	uint32_t tout;
+
+	LPC_EMAC-&gt;MADR = EMAC_DP83848C_DEF_ADR | PhyReg;
+	LPC_EMAC-&gt;MWTD = Value;
+
+	/* Wait until operation completed */
+	tout = 0;
+	for (tout = 0; tout &lt; EMAC_MII_WR_TOUT; tout++) {
+		if ((LPC_EMAC-&gt;MIND &amp; EMAC_MIND_BUSY) == 0) {
+			return (0);
+		}
+	}
+	// Time out!
+	return (-1);
+}
+
+
+/*--------------------------- read_PHY --------------------------------------*/
+/**
+ * @brief 		Read value from PHY device
+ * @param[in]	PhyReg PHY Register address
+ * @return		Return value if success, otherwise return (-1)
+ */
+static int32_t read_PHY (uint32_t PhyReg)
+{
+	/* Read a PHY register 'PhyReg'. */
+	uint32_t tout;
+
+	LPC_EMAC-&gt;MADR = EMAC_DP83848C_DEF_ADR | PhyReg;
+	LPC_EMAC-&gt;MCMD = EMAC_MCMD_READ;
+
+	/* Wait until operation completed */
+	tout = 0;
+	for (tout = 0; tout &lt; EMAC_MII_RD_TOUT; tout++) {
+		if ((LPC_EMAC-&gt;MIND &amp; EMAC_MIND_BUSY) == 0) {
+			LPC_EMAC-&gt;MCMD = 0;
+			return (LPC_EMAC-&gt;MRDD);
+		}
+	}
+	// Time out!
+	return (-1);
+}
+
+/*********************************************************************//**
+ * @brief		Set Station MAC address for EMAC module
+ * @param[in]	abStationAddr Pointer to Station address that contains 6-bytes
+ * 				of MAC address (should be in order from MAC Address 1 to MAC Address 6)
+ * @return		None
+ **********************************************************************/
+void setEmacAddr(uint8_t abStationAddr[])
+{
+	/* Set the Ethernet MAC Address registers */
+	LPC_EMAC-&gt;SA0 = ((uint32_t)abStationAddr[5] &lt;&lt; 8) | (uint32_t)abStationAddr[4];
+	LPC_EMAC-&gt;SA1 = ((uint32_t)abStationAddr[3] &lt;&lt; 8) | (uint32_t)abStationAddr[2];
+	LPC_EMAC-&gt;SA2 = ((uint32_t)abStationAddr[1] &lt;&lt; 8) | (uint32_t)abStationAddr[0];
+}
+
+/**
+ * @}
+ */
+
+
+/* Public Functions ----------------------------------------------------------- */
+/** @addtogroup EMAC_Public_Functions
+ * @{
+ */
+
+
+/*********************************************************************//**
+ * @brief		Initializes the EMAC peripheral according to the specified
+*               parameters in the EMAC_ConfigStruct.
+ * @param[in]	EMAC_ConfigStruct Pointer to a EMAC_CFG_Type structure
+*                    that contains the configuration information for the
+*                    specified EMAC peripheral.
+ * @return		None
+ *
+ * Note: This function will initialize EMAC module according to procedure below:
+ *  - Remove the soft reset condition from the MAC
+ *  - Configure the PHY via the MIIM interface of the MAC
+ *  - Select RMII mode
+ *  - Configure the transmit and receive DMA engines, including the descriptor arrays
+ *  - Configure the host registers (MAC1,MAC2 etc.) in the MAC
+ *  - Enable the receive and transmit data paths
+ *  In default state after initializing, only Rx Done and Tx Done interrupt are enabled,
+ *  all remain interrupts are disabled
+ *  (Ref. from LPC17xx UM)
+ **********************************************************************/
+Status EMAC_Init(EMAC_CFG_Type *EMAC_ConfigStruct)
+{
+	/* Initialize the EMAC Ethernet controller. */
+	int32_t regv,tout, tmp;
+
+	/* Set up clock and power for Ethernet module */
+	CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCENET, ENABLE);
+
+	/* Reset all EMAC internal modules */
+	LPC_EMAC-&gt;MAC1    = EMAC_MAC1_RES_TX | EMAC_MAC1_RES_MCS_TX | EMAC_MAC1_RES_RX |
+					EMAC_MAC1_RES_MCS_RX | EMAC_MAC1_SIM_RES | EMAC_MAC1_SOFT_RES;
+
+	LPC_EMAC-&gt;Command = EMAC_CR_REG_RES | EMAC_CR_TX_RES | EMAC_CR_RX_RES | EMAC_CR_PASS_RUNT_FRM;
+
+	/* A short delay after reset. */
+	for (tout = 100; tout; tout--);
+
+	/* Initialize MAC control registers. */
+	LPC_EMAC-&gt;MAC1 = EMAC_MAC1_PASS_ALL;
+	LPC_EMAC-&gt;MAC2 = EMAC_MAC2_CRC_EN | EMAC_MAC2_PAD_EN;
+	LPC_EMAC-&gt;MAXF = EMAC_ETH_MAX_FLEN;
+	/*
+	 * Find the clock that close to desired target clock
+	 */
+	tmp = SystemCoreClock / EMAC_MCFG_MII_MAXCLK;
+	for (tout = 0; tout &lt; sizeof (EMAC_clkdiv); tout++){
+		if (EMAC_clkdiv[tout] &gt;= tmp) break;
+	}
+	tout++;
+	// Write to MAC configuration register and reset
+	LPC_EMAC-&gt;MCFG = EMAC_MCFG_CLK_SEL(tout) | EMAC_MCFG_RES_MII;
+	// release reset
+	LPC_EMAC-&gt;MCFG &amp;= ~(EMAC_MCFG_RES_MII);
+	LPC_EMAC-&gt;CLRT = EMAC_CLRT_DEF;
+	LPC_EMAC-&gt;IPGR = EMAC_IPGR_P2_DEF;
+
+	/* Enable Reduced MII interface. */
+	LPC_EMAC-&gt;Command = EMAC_CR_RMII | EMAC_CR_PASS_RUNT_FRM;
+
+	/* Reset Reduced MII Logic. */
+	LPC_EMAC-&gt;SUPP = EMAC_SUPP_RES_RMII;
+
+	for (tout = 100; tout; tout--);
+	LPC_EMAC-&gt;SUPP = 0;
+
+	/* Put the DP83848C in reset mode */
+	write_PHY (EMAC_PHY_REG_BMCR, EMAC_PHY_BMCR_RESET);
+
+	/* Wait for hardware reset to end. */
+	for (tout = EMAC_PHY_RESP_TOUT; tout; tout--) {
+		regv = read_PHY (EMAC_PHY_REG_BMCR);
+		if (!(regv &amp; (EMAC_PHY_BMCR_RESET | EMAC_PHY_BMCR_POWERDOWN))) {
+			/* Reset complete, device not Power Down. */
+			break;
+		}
+		if (tout == 0){
+			// Time out, return ERROR
+			return (ERROR);
+		}
+	}
+
+	// Set PHY mode
+	if (EMAC_SetPHYMode(EMAC_ConfigStruct-&gt;Mode) &lt; 0){
+		return (ERROR);
+	}
+
+	// Set EMAC address
+	setEmacAddr(EMAC_ConfigStruct-&gt;pbEMAC_Addr);
+
+	/* Initialize Tx and Rx DMA Descriptors */
+	rx_descr_init ();
+	tx_descr_init ();
+
+	// Set Receive Filter register: enable broadcast and multicast
+	LPC_EMAC-&gt;RxFilterCtrl = EMAC_RFC_MCAST_EN | EMAC_RFC_BCAST_EN | EMAC_RFC_PERFECT_EN;
+
+	/* Enable Rx Done and Tx Done interrupt for EMAC */
+	LPC_EMAC-&gt;IntEnable = EMAC_INT_RX_DONE | EMAC_INT_TX_DONE;
+
+	/* Reset all interrupts */
+	LPC_EMAC-&gt;IntClear  = 0xFFFF;
+
+	/* Enable receive and transmit mode of MAC Ethernet core */
+	LPC_EMAC-&gt;Command  |= (EMAC_CR_RX_EN | EMAC_CR_TX_EN);
+	LPC_EMAC-&gt;MAC1     |= EMAC_MAC1_REC_EN;
+
+	return SUCCESS;
+}
+
+
+/*********************************************************************//**
+ * @brief		De-initializes the EMAC peripheral registers to their
+*                  default reset values.
+ * @param[in]	None
+ * @return 		None
+ **********************************************************************/
+void EMAC_DeInit(void)
+{
+	// Disable all interrupt
+	LPC_EMAC-&gt;IntEnable = 0x00;
+	// Clear all pending interrupt
+	LPC_EMAC-&gt;IntClear = (0xFF) | (EMAC_INT_SOFT_INT | EMAC_INT_WAKEUP);
+
+	/* TurnOff clock and power for Ethernet module */
+	CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCENET, DISABLE);
+}
+
+
+/*********************************************************************//**
+ * @brief		Check specified PHY status in EMAC peripheral
+ * @param[in]	ulPHYState	Specified PHY Status Type, should be:
+ * 							- EMAC_PHY_STAT_LINK: Link Status
+ * 							- EMAC_PHY_STAT_SPEED: Speed Status
+ * 							- EMAC_PHY_STAT_DUP: Duplex Status
+ * @return		Status of specified PHY status (0 or 1).
+ * 				(-1) if error.
+ *
+ * Note:
+ * For EMAC_PHY_STAT_LINK, return value:
+ * - 0: Link Down
+ * - 1: Link Up
+ * For EMAC_PHY_STAT_SPEED, return value:
+ * - 0: 10Mbps
+ * - 1: 100Mbps
+ * For EMAC_PHY_STAT_DUP, return value:
+ * - 0: Half-Duplex
+ * - 1: Full-Duplex
+ **********************************************************************/
+int32_t EMAC_CheckPHYStatus(uint32_t ulPHYState)
+{
+	int32_t regv, tmp;
+
+	regv = read_PHY (EMAC_PHY_REG_STS);
+	switch(ulPHYState){
+	case EMAC_PHY_STAT_LINK:
+		tmp = (regv &amp; EMAC_PHY_SR_LINK) ? 1 : 0;
+		break;
+	case EMAC_PHY_STAT_SPEED:
+		tmp = (regv &amp; EMAC_PHY_SR_SPEED) ? 0 : 1;
+		break;
+	case EMAC_PHY_STAT_DUP:
+		tmp = (regv &amp; EMAC_PHY_SR_DUP) ? 1 : 0;
+		break;
+	default:
+		tmp = -1;
+		break;
+	}
+	return (tmp);
+}
+
+
+/*********************************************************************//**
+ * @brief		Set specified PHY mode in EMAC peripheral
+ * @param[in]	ulPHYMode	Specified PHY mode, should be:
+ * 							- EMAC_MODE_AUTO
+ * 							- EMAC_MODE_10M_FULL
+ * 							- EMAC_MODE_10M_HALF
+ * 							- EMAC_MODE_100M_FULL
+ * 							- EMAC_MODE_100M_HALF
+ * @return		Return (0) if no error, otherwise return (-1)
+ **********************************************************************/
+int32_t EMAC_SetPHYMode(uint32_t ulPHYMode)
+{
+	int32_t id1, id2, tout, regv;
+
+	/* Check if this is a DP83848C PHY. */
+	id1 = read_PHY (EMAC_PHY_REG_IDR1);
+	id2 = read_PHY (EMAC_PHY_REG_IDR2);
+
+	if (((id1 &lt;&lt; 16) | (id2 &amp; 0xFFF0)) == EMAC_DP83848C_ID) {
+		/* Configure the PHY device */
+		switch(ulPHYMode){
+		case EMAC_MODE_AUTO:
+			/* Use auto-negotiation about the link speed. */
+			write_PHY (EMAC_PHY_REG_BMCR, EMAC_PHY_AUTO_NEG);
+			/* Wait to complete Auto_Negotiation */
+			for (tout = EMAC_PHY_RESP_TOUT; tout; tout--) {
+				regv = read_PHY (EMAC_PHY_REG_BMSR);
+				if (regv &amp; EMAC_PHY_BMSR_AUTO_DONE) {
+					/* Auto-negotiation Complete. */
+					break;
+				}
+				if (tout == 0){
+					// Time out, return error
+					return (-1);
+				}
+			}
+			break;
+		case EMAC_MODE_10M_FULL:
+			/* Connect at 10MBit full-duplex */
+			write_PHY (EMAC_PHY_REG_BMCR, EMAC_PHY_FULLD_10M);
+			break;
+		case EMAC_MODE_10M_HALF:
+			/* Connect at 10MBit half-duplex */
+			write_PHY (EMAC_PHY_REG_BMCR, EMAC_PHY_HALFD_10M);
+			break;
+		case EMAC_MODE_100M_FULL:
+			/* Connect at 100MBit full-duplex */
+			write_PHY (EMAC_PHY_REG_BMCR, EMAC_PHY_FULLD_100M);
+			break;
+		case EMAC_MODE_100M_HALF:
+			/* Connect at 100MBit half-duplex */
+			write_PHY (EMAC_PHY_REG_BMCR, EMAC_PHY_HALFD_100M);
+			break;
+		default:
+			// un-supported
+			return (-1);
+		}
+	}
+	// It's not correct module ID
+	else {
+		return (-1);
+	}
+
+	// Update EMAC configuration with current PHY status
+	if (EMAC_UpdatePHYStatus() &lt; 0){
+		return (-1);
+	}
+
+	// Complete
+	return (0);
+}
+
+
+/*********************************************************************//**
+ * @brief		Auto-Configures value for the EMAC configuration register to
+ * 				match with current PHY mode
+ * @param[in]	None
+ * @return		Return (0) if no error, otherwise return (-1)
+ *
+ * Note: The EMAC configuration will be auto-configured:
+ * 		- Speed mode.
+ * 		- Half/Full duplex mode
+ **********************************************************************/
+int32_t EMAC_UpdatePHYStatus(void)
+{
+	int32_t regv, tout;
+
+	/* Check the link status. */
+	for (tout = EMAC_PHY_RESP_TOUT; tout; tout--) {
+		regv = read_PHY (EMAC_PHY_REG_STS);
+		if (regv &amp; EMAC_PHY_SR_LINK) {
+			/* Link is on. */
+			break;
+		}
+		if (tout == 0){
+			// time out
+			return (-1);
+		}
+	}
+
+	/* Configure Full/Half Duplex mode. */
+	if (regv &amp; EMAC_PHY_SR_DUP) {
+		/* Full duplex is enabled. */
+		LPC_EMAC-&gt;MAC2    |= EMAC_MAC2_FULL_DUP;
+		LPC_EMAC-&gt;Command |= EMAC_CR_FULL_DUP;
+		LPC_EMAC-&gt;IPGT     = EMAC_IPGT_FULL_DUP;
+	} else {
+		/* Half duplex mode. */
+		LPC_EMAC-&gt;IPGT = EMAC_IPGT_HALF_DUP;
+	}
+
+	/* Configure 100MBit/10MBit mode. */
+	if (regv &amp; EMAC_PHY_SR_SPEED) {
+		/* 10MBit mode. */
+		LPC_EMAC-&gt;SUPP = 0;
+	} else {
+		/* 100MBit mode. */
+		LPC_EMAC-&gt;SUPP = EMAC_SUPP_SPEED;
+	}
+
+	// Complete
+	return (0);
+}
+
+
+/*********************************************************************//**
+ * @brief		Enable/Disable hash filter functionality for specified destination
+ * 				MAC address in EMAC module
+ * @param[in]	dstMAC_addr		Pointer to the first MAC destination address, should
+ * 								be 6-bytes length, in order LSB to the MSB
+ * @param[in]	NewState		New State of this command, should be:
+ *									- ENABLE.
+ *									- DISABLE.
+ * @return		None
+ *
+ * Note:
+ * The standard Ethernet cyclic redundancy check (CRC) function is calculated from
+ * the 6 byte destination address in the Ethernet frame (this CRC is calculated
+ * anyway as part of calculating the CRC of the whole frame), then bits [28:23] out of
+ * the 32 bits CRC result are taken to form the hash. The 6 bit hash is used to access
+ * the hash table: it is used as an index in the 64 bit HashFilter register that has been
+ * programmed with accept values. If the selected accept value is 1, the frame is
+ * accepted.
+ **********************************************************************/
+void EMAC_SetHashFilter(uint8_t dstMAC_addr[], FunctionalState NewState)
+{
+	uint32_t *pReg;
+	uint32_t tmp;
+	int32_t crc;
+
+	// Calculate the CRC from the destination MAC address
+	crc = EMAC_CRCCalc(dstMAC_addr, 6);
+	// Extract the value from CRC to get index value for hash filter table
+	crc = (crc &gt;&gt; 23) &amp; 0x3F;
+
+	pReg = (crc &gt; 31) ? ((uint32_t *)&amp;LPC_EMAC-&gt;HashFilterH) \
+								: ((uint32_t *)&amp;LPC_EMAC-&gt;HashFilterL);
+	tmp = (crc &gt; 31) ? (crc - 32) : crc;
+	if (NewState == ENABLE) {
+		(*pReg) |= (1UL &lt;&lt; tmp);
+	} else {
+		(*pReg) &amp;= ~(1UL &lt;&lt; tmp);
+	}
+	// Enable Rx Filter
+	LPC_EMAC-&gt;Command &amp;= ~EMAC_CR_PASS_RX_FILT;
+}
+
+
+/*********************************************************************//**
+ * @brief		Calculates CRC code for number of bytes in the frame
+ * @param[in]	frame_no_fcs	Pointer to the first byte of the frame
+ * @param[in]	frame_len		length of the frame without the FCS
+ * @return		the CRC as a 32 bit integer
+ **********************************************************************/
+int32_t EMAC_CRCCalc(uint8_t frame_no_fcs[], int32_t frame_len)
+{
+	int i; 		// iterator
+	int j; 		// another iterator
+	char byte; 	// current byte
+	int crc; 	// CRC result
+	int q0, q1, q2, q3; // temporary variables
+	crc = 0xFFFFFFFF;
+	for (i = 0; i &lt; frame_len; i++) {
+		byte = *frame_no_fcs++;
+		for (j = 0; j &lt; 2; j++) {
+			if (((crc &gt;&gt; 28) ^ (byte &gt;&gt; 3)) &amp; 0x00000001) {
+				q3 = 0x04C11DB7;
+			} else {
+				q3 = 0x00000000;
+			}
+			if (((crc &gt;&gt; 29) ^ (byte &gt;&gt; 2)) &amp; 0x00000001) {
+				q2 = 0x09823B6E;
+			} else {
+				q2 = 0x00000000;
+			}
+			if (((crc &gt;&gt; 30) ^ (byte &gt;&gt; 1)) &amp; 0x00000001) {
+				q1 = 0x130476DC;
+			} else {
+				q1 = 0x00000000;
+			}
+			if (((crc &gt;&gt; 31) ^ (byte &gt;&gt; 0)) &amp; 0x00000001) {
+				q0 = 0x2608EDB8;
+			} else {
+				q0 = 0x00000000;
+			}
+			crc = (crc &lt;&lt; 4) ^ q3 ^ q2 ^ q1 ^ q0;
+			byte &gt;&gt;= 4;
+		}
+	}
+	return crc;
+}
+
+/*********************************************************************//**
+ * @brief		Enable/Disable Filter mode for each specified type EMAC peripheral
+ * @param[in]	ulFilterMode	Filter mode, should be:
+ * 								- EMAC_RFC_UCAST_EN: all frames of unicast types
+ * 								will be accepted
+ * 								- EMAC_RFC_BCAST_EN: broadcast frame will be
+ * 								accepted
+ * 								- EMAC_RFC_MCAST_EN: all frames of multicast
+ * 								types will be accepted
+ * 								- EMAC_RFC_UCAST_HASH_EN: The imperfect hash
+ * 								filter will be applied to unicast addresses
+ * 								- EMAC_RFC_MCAST_HASH_EN: The imperfect hash
+ * 								filter will be applied to multicast addresses
+ * 								- EMAC_RFC_PERFECT_EN: the destination address
+ * 								will be compared with the 6 byte station address
+ * 								programmed in the station address by the filter
+ * 								- EMAC_RFC_MAGP_WOL_EN: the result of the magic
+ * 								packet filter will generate a WoL interrupt when
+ * 								there is a match
+ * 								- EMAC_RFC_PFILT_WOL_EN: the result of the perfect address
+ * 								matching filter and the imperfect hash filter will
+ * 								generate a WoL interrupt when there is a match
+ * @param[in]	NewState	New State of this command, should be:
+ * 								- ENABLE
+ * 								- DISABLE
+ * @return		None
+ **********************************************************************/
+void EMAC_SetFilterMode(uint32_t ulFilterMode, FunctionalState NewState)
+{
+	if (NewState == ENABLE){
+		LPC_EMAC-&gt;RxFilterCtrl |= ulFilterMode;
+	} else {
+		LPC_EMAC-&gt;RxFilterCtrl &amp;= ~ulFilterMode;
+	}
+}
+
+/*********************************************************************//**
+ * @brief		Get status of Wake On LAN Filter for each specified
+ * 				type in EMAC peripheral, clear this status if it is set
+ * @param[in]	ulWoLMode	WoL Filter mode, should be:
+ * 								- EMAC_WOL_UCAST: unicast frames caused WoL
+ * 								- EMAC_WOL_UCAST: broadcast frame caused WoL
+ * 								- EMAC_WOL_MCAST: multicast frame caused WoL
+ * 								- EMAC_WOL_UCAST_HASH: unicast frame that passes the
+ * 								imperfect hash filter caused WoL
+ * 								- EMAC_WOL_MCAST_HASH: multicast frame that passes the
+ * 								imperfect hash filter caused WoL
+ * 								- EMAC_WOL_PERFECT:perfect address matching filter
+ * 								caused WoL
+ * 								- EMAC_WOL_RX_FILTER: the receive filter caused WoL
+ * 								- EMAC_WOL_MAG_PACKET: the magic packet filter caused WoL
+ * @return		SET/RESET
+ **********************************************************************/
+FlagStatus EMAC_GetWoLStatus(uint32_t ulWoLMode)
+{
+	if (LPC_EMAC-&gt;RxFilterWoLStatus &amp; ulWoLMode) {
+		LPC_EMAC-&gt;RxFilterWoLClear = ulWoLMode;
+		return SET;
+	} else {
+		return RESET;
+	}
+}
+
+
+/*********************************************************************//**
+ * @brief		Write data to Tx packet data buffer at current index due to
+ * 				TxProduceIndex
+ * @param[in]	pDataStruct		Pointer to a EMAC_PACKETBUF_Type structure
+ * 							data that contain specified information about
+ * 							Packet data buffer.
+ * @return		None
+ **********************************************************************/
+void EMAC_WritePacketBuffer(EMAC_PACKETBUF_Type *pDataStruct)
+{
+	uint32_t idx,len;
+	uint32_t *sp,*dp;
+
+	idx = LPC_EMAC-&gt;TxProduceIndex;
+	sp  = (uint32_t *)pDataStruct-&gt;pbDataBuf;
+	dp  = (uint32_t *)Tx_Desc[idx].Packet;
+	/* Copy frame data to EMAC packet buffers. */
+	for (len = (pDataStruct-&gt;ulDataLen + 3) &gt;&gt; 2; len; len--) {
+		*dp++ = *sp++;
+	}
+	Tx_Desc[idx].Ctrl = (pDataStruct-&gt;ulDataLen - 1) | (EMAC_TCTRL_INT | EMAC_TCTRL_LAST);
+}
+
+/*********************************************************************//**
+ * @brief		Read data from Rx packet data buffer at current index due
+ * 				to RxConsumeIndex
+ * @param[in]	pDataStruct		Pointer to a EMAC_PACKETBUF_Type structure
+ * 							data that contain specified information about
+ * 							Packet data buffer.
+ * @return		None
+ **********************************************************************/
+void EMAC_ReadPacketBuffer(EMAC_PACKETBUF_Type *pDataStruct)
+{
+	uint32_t idx, len;
+	uint32_t *dp, *sp;
+
+	idx = LPC_EMAC-&gt;RxConsumeIndex;
+	dp = (uint32_t *)pDataStruct-&gt;pbDataBuf;
+	sp = (uint32_t *)Rx_Desc[idx].Packet;
+
+	if (pDataStruct-&gt;pbDataBuf != NULL) {
+		for (len = (pDataStruct-&gt;ulDataLen + 3) &gt;&gt; 2; len; len--) {
+			*dp++ = *sp++;
+		}
+	}
+}
+
+/*********************************************************************//**
+ * @brief		Standard EMAC IRQ Handler. This sub-routine will check
+ * 				these following interrupt and call the call-back function
+ * 				if they're already installed:
+ * 				- Overrun Error interrupt in RX Queue
+ * 				- Receive Error interrupt: AlignmentError, RangeError,
+ * 				LengthError, SymbolError, CRCError or NoDescriptor or Overrun
+ * 				- RX Finished Process Descriptors interrupt (ProduceIndex == ConsumeIndex)
+ * 				- Receive Done interrupt
+ * 				- Transmit Under-run interrupt
+ * 				- Transmit errors interrupt : LateCollision, ExcessiveCollision
+ * 				and ExcessiveDefer, NoDescriptor or Under-run
+ * 				- TX Finished Process Descriptors interrupt (ProduceIndex == ConsumeIndex)
+ * 				- Transmit Done interrupt
+ * 				- Interrupt triggered by software
+ *				- Interrupt triggered by a Wakeup event detected by the receive filter
+ * @param[in]	None
+ * @return		None
+ **********************************************************************/
+void EMAC_StandardIRQHandler(void)
+{
+	/* EMAC Ethernet Controller Interrupt function. */
+	uint32_t n, int_stat;
+
+	// Get EMAC interrupt status
+	while ((int_stat = (LPC_EMAC-&gt;IntStatus &amp; LPC_EMAC-&gt;IntEnable)) != 0) {
+		// Clear interrupt status
+		LPC_EMAC-&gt;IntClear = int_stat;
+		// Execute call-back function
+		for (n = 0; n &lt;= 7; n++) {
+			if ((int_stat &amp; (1 &lt;&lt; n)) &amp;&amp; (_pfnIntCbDat[n] != NULL)) {
+				_pfnIntCbDat[n]();
+			}
+		}
+		// Soft interrupt
+		if ((int_stat &amp; EMAC_INT_SOFT_INT) &amp;&amp; (_pfnIntCbDat[8] != NULL)) {
+			_pfnIntCbDat[8]();
+		}
+		// WakeUp interrupt
+		if ((int_stat &amp; EMAC_INT_WAKEUP) &amp;&amp; (_pfnIntCbDat[9] != NULL)) {
+			// Clear WoL interrupt
+			LPC_EMAC-&gt;RxFilterWoLClear = EMAC_WOL_BITMASK;
+			_pfnIntCbDat[9]();
+		}
+	}
+}
+
+
+/*********************************************************************//**
+ * @brief		Setup/register Call-back function for each interrupt type
+ * 				in EMAC module.
+ * @param[in]	ulIntType	Interrupt type, should be one of the following:
+ * 							- EMAC_INT_RX_OVERRUN: Receive Overrun
+ * 							- EMAC_INT_RX_ERR: Receive Error
+ * 							- EMAC_INT_RX_FIN: Receive Descriptor Finish
+ * 							- EMAC_INT_RX_DONE: Receive Done
+ * 							- EMAC_INT_TX_UNDERRUN: Transmit Under-run
+ * 							- EMAC_INT_TX_ERR: Transmit Error
+ * 							- EMAC_INT_TX_FIN: Transmit descriptor finish
+ * 							- EMAC_INT_TX_DONE: Transmit Done
+ * 							- EMAC_INT_SOFT_INT: Software interrupt
+ * 							- EMAC_INT_WAKEUP: Wakeup interrupt
+ * @param[in]	pfnIntCb	Pointer to Call-back function used for this
+ * 							interrupt type
+ * @return		None
+ **********************************************************************/
+void EMAC_SetupIntCBS(uint32_t ulIntType, EMAC_IntCBSType *pfnIntCb)
+{
+	/* EMAC Ethernet Controller Interrupt function. */
+	uint32_t n;
+
+	if (ulIntType &lt;= EMAC_INT_TX_DONE){
+		for (n = 0; n &lt;= 7; n++) {
+			// Found it, install cbs now
+			if (ulIntType &amp; (1 &lt;&lt; n)) {
+				_pfnIntCbDat[n] = pfnIntCb;
+				// Don't install cbs any more
+				break;
+			}
+		}
+	} else if (ulIntType &amp; EMAC_INT_SOFT_INT) {
+		_pfnIntCbDat[8] = pfnIntCb;
+	} else if (ulIntType &amp; EMAC_INT_WAKEUP) {
+		_pfnIntCbDat[9] = pfnIntCb;
+	}
+}
+
+/*********************************************************************//**
+ * @brief 		Enable/Disable interrupt for each type in EMAC
+ * @param[in]	ulIntType	Interrupt Type, should be:
+ * 							- EMAC_INT_RX_OVERRUN: Receive Overrun
+ * 							- EMAC_INT_RX_ERR: Receive Error
+ * 							- EMAC_INT_RX_FIN: Receive Descriptor Finish
+ * 							- EMAC_INT_RX_DONE: Receive Done
+ * 							- EMAC_INT_TX_UNDERRUN: Transmit Under-run
+ * 							- EMAC_INT_TX_ERR: Transmit Error
+ * 							- EMAC_INT_TX_FIN: Transmit descriptor finish
+ * 							- EMAC_INT_TX_DONE: Transmit Done
+ * 							- EMAC_INT_SOFT_INT: Software interrupt
+ * 							- EMAC_INT_WAKEUP: Wakeup interrupt
+ * @param[in]	NewState	New State of this function, should be:
+ * 							- ENABLE.
+ * 							- DISABLE.
+ * @return		None
+ **********************************************************************/
+void EMAC_IntCmd(uint32_t ulIntType, FunctionalState NewState)
+{
+	if (NewState == ENABLE) {
+		LPC_EMAC-&gt;IntEnable |= ulIntType;
+	} else {
+		LPC_EMAC-&gt;IntEnable &amp;= ~(ulIntType);
+	}
+}
+
+/*********************************************************************//**
+ * @brief 		Check whether if specified interrupt flag is set or not
+ * 				for each interrupt type in EMAC and clear interrupt pending
+ * 				if it is set.
+ * @param[in]	ulIntType	Interrupt Type, should be:
+ * 							- EMAC_INT_RX_OVERRUN: Receive Overrun
+ * 							- EMAC_INT_RX_ERR: Receive Error
+ * 							- EMAC_INT_RX_FIN: Receive Descriptor Finish
+ * 							- EMAC_INT_RX_DONE: Receive Done
+ * 							- EMAC_INT_TX_UNDERRUN: Transmit Under-run
+ * 							- EMAC_INT_TX_ERR: Transmit Error
+ * 							- EMAC_INT_TX_FIN: Transmit descriptor finish
+ * 							- EMAC_INT_TX_DONE: Transmit Done
+ * 							- EMAC_INT_SOFT_INT: Software interrupt
+ * 							- EMAC_INT_WAKEUP: Wakeup interrupt
+ * @return		New state of specified interrupt (SET or RESET)
+ **********************************************************************/
+IntStatus EMAC_IntGetStatus(uint32_t ulIntType)
+{
+	if (LPC_EMAC-&gt;IntStatus &amp; ulIntType) {
+		LPC_EMAC-&gt;IntClear = ulIntType;
+		return SET;
+	} else {
+		return RESET;
+	}
+}
+
+
+/*********************************************************************//**
+ * @brief		Check whether if the current RxConsumeIndex is not equal to the
+ * 				current RxProduceIndex.
+ * @param[in]	None
+ * @return		TRUE if they're not equal, otherwise return FALSE
+ *
+ * Note: In case the RxConsumeIndex is not equal to the RxProduceIndex,
+ * it means there're available data has been received. They should be read
+ * out and released the Receive Data Buffer by updating the RxConsumeIndex value.
+ **********************************************************************/
+Bool EMAC_CheckReceiveIndex(void)
+{
+	if (LPC_EMAC-&gt;RxConsumeIndex != LPC_EMAC-&gt;RxProduceIndex) {
+		return TRUE;
+	} else {
+		return FALSE;
+	}
+}
+
+
+/*********************************************************************//**
+ * @brief		Check whether if the current TxProduceIndex is not equal to the
+ * 				current RxProduceIndex - 1.
+ * @param[in]	None
+ * @return		TRUE if they're not equal, otherwise return FALSE
+ *
+ * Note: In case the RxConsumeIndex is equal to the RxProduceIndex - 1,
+ * it means the transmit buffer is available and data can be written to transmit
+ * buffer to be sent.
+ **********************************************************************/
+Bool EMAC_CheckTransmitIndex(void)
+{
+	uint32_t tmp = LPC_EMAC-&gt;TxConsumeIndex -1;
+	if (LPC_EMAC-&gt;TxProduceIndex == tmp) {
+		return FALSE;
+	} else {
+		return TRUE;
+	}
+}
+
+
+/*********************************************************************//**
+ * @brief		Get current status value of receive data (due to RxConsumeIndex)
+ * @param[in]	ulRxStatType	Received Status type, should be one of following:
+ * 							- EMAC_RINFO_CTRL_FRAME: Control Frame
+ * 							- EMAC_RINFO_VLAN: VLAN Frame
+ * 							- EMAC_RINFO_FAIL_FILT: RX Filter Failed
+ * 							- EMAC_RINFO_MCAST: Multicast Frame
+ * 							- EMAC_RINFO_BCAST: Broadcast Frame
+ * 							- EMAC_RINFO_CRC_ERR: CRC Error in Frame
+ * 							- EMAC_RINFO_SYM_ERR: Symbol Error from PHY
+ * 							- EMAC_RINFO_LEN_ERR: Length Error
+ * 							- EMAC_RINFO_RANGE_ERR: Range error(exceeded max size)
+ * 							- EMAC_RINFO_ALIGN_ERR: Alignment error
+ * 							- EMAC_RINFO_OVERRUN: Receive overrun
+ * 							- EMAC_RINFO_NO_DESCR: No new Descriptor available
+ * 							- EMAC_RINFO_LAST_FLAG: last Fragment in Frame
+ * 							- EMAC_RINFO_ERR: Error Occurred (OR of all error)
+ * @return		Current value of receive data (due to RxConsumeIndex)
+ **********************************************************************/
+FlagStatus EMAC_CheckReceiveDataStatus(uint32_t ulRxStatType)
+{
+	uint32_t idx;
+	idx = LPC_EMAC-&gt;RxConsumeIndex;
+	return (((Rx_Stat[idx].Info) &amp; ulRxStatType) ? SET : RESET);
+}
+
+
+/*********************************************************************//**
+ * @brief		Get size of current Received data in received buffer (due to
+ * 				RxConsumeIndex)
+ * @param[in]	None
+ * @return		Size of received data
+ **********************************************************************/
+uint32_t EMAC_GetReceiveDataSize(void)
+{
+	uint32_t idx;
+	idx =LPC_EMAC-&gt;RxConsumeIndex;
+	return ((Rx_Stat[idx].Info) &amp; EMAC_RINFO_SIZE);
+}
+
+/*********************************************************************//**
+ * @brief		Increase the RxConsumeIndex (after reading the Receive buffer
+ * 				to release the Receive buffer) and wrap-around the index if
+ * 				it reaches the maximum Receive Number
+ * @param[in]	None
+ * @return		None
+ **********************************************************************/
+void EMAC_UpdateRxConsumeIndex(void)
+{
+	// Get current Rx consume index
+	uint32_t idx = LPC_EMAC-&gt;RxConsumeIndex;
+
+	/* Release frame from EMAC buffer */
+	if (++idx == EMAC_NUM_RX_FRAG) idx = 0;
+	LPC_EMAC-&gt;RxConsumeIndex = idx;
+}
+
+/*********************************************************************//**
+ * @brief		Increase the TxProduceIndex (after writting to the Transmit buffer
+ * 				to enable the Transmit buffer) and wrap-around the index if
+ * 				it reaches the maximum Transmit Number
+ * @param[in]	None
+ * @return		None
+ **********************************************************************/
+void EMAC_UpdateTxProduceIndex(void)
+{
+	// Get current Tx produce index
+	uint32_t idx = LPC_EMAC-&gt;TxProduceIndex;
+
+	/* Start frame transmission */
+	if (++idx == EMAC_NUM_TX_FRAG) idx = 0;
+	LPC_EMAC-&gt;TxProduceIndex = idx;
+}
+
+
+/**
+ * @}
+ */
+
+#endif /* _EMAC */
+
+/**
+ * @}
+ */
+
+/* --------------------------------- End Of File ------------------------------ */


Property changes on: trunk/src/platform/lpc17xx/drivers/src/lpc17xx_emac.c
___________________________________________________________________
Deleted: svn:executable
   - *

Modified: trunk/src/platform/lpc17xx/drivers/src/lpc17xx_gpdma.c
===================================================================
--- trunk/src/platform/lpc17xx/drivers/src/lpc17xx_gpdma.c	2010-06-28 21:53:59 UTC (rev 759)
+++ trunk/src/platform/lpc17xx/drivers/src/lpc17xx_gpdma.c	2010-07-12 20:56:54 UTC (rev 760)
@@ -1,434 +1,435 @@
-/**
- * @file	: lpc17xx_gpdma.c
- * @brief	: Contains all functions support for GPDMA firmware library on LPC17xx
- * @version	: 1.0
- * @date	: 20. Apr. 2009
- * @author	: HieuNguyen
- *----------------------------------------------------------------------------
- * Software that is described herein is for illustrative purposes only
- * which provides customers with programming information regarding the
- * products. This software is supplied &quot;AS IS&quot; without any warranties.
- * NXP Semiconductors assumes no responsibility or liability for the
- * use of the software, conveys no license or title under any patent,
- * copyright, or mask work right to the product. NXP Semiconductors
- * reserves the right to make changes in the software without
- * notification. NXP Semiconductors also make no representation or
- * warranty that such application will be suitable for the specified
- * use without further testing or modification.
- **********************************************************************/
-
-/* Peripheral group ----------------------------------------------------------- */
-/** @addtogroup GPDMA
- * @{
- */
-
-/* Includes ------------------------------------------------------------------- */
-#include &quot;lpc17xx_gpdma.h&quot;
-#include &quot;lpc17xx_clkpwr.h&quot;
-
-/* If this source file built with example, the LPC17xx FW library configuration
- * file in each example directory (&quot;lpc17xx_libcfg.h&quot;) must be included,
- * otherwise the default FW library configuration file must be included instead
- */
-#ifdef __BUILD_WITH_EXAMPLE__
-#include &quot;lpc17xx_libcfg.h&quot;
-#else
-#include &quot;lpc17xx_libcfg_default.h&quot;
-#endif /* __BUILD_WITH_EXAMPLE__ */
-
-#ifdef _GPDMA
-
-
-/* Private Variables ---------------------------------------------------------- */
-/** @defgroup GPDMA_Private_Variables
- * @{
- */
-
-/**
- * @brief Lookup Table of Connection Type matched with
- * Peripheral Data (FIFO) register base address
- */
-#ifdef __IAR_SYSTEMS_ICC__
-volatile const void *GPDMA_LUTPerAddr[] = {
-		(&amp;SSP0-&gt;DR),				// SSP0 Tx
-		(&amp;SSP0-&gt;DR),				// SSP0 Rx
-		(&amp;SSP1-&gt;DR),				// SSP1 Tx
-		(&amp;SSP1-&gt;DR),				// SSP1 Rx
-		(&amp;ADC-&gt;ADGDR),			// ADC
-		(&amp;I2S-&gt;I2STXFIFO), 		// I2S Tx
-		(&amp;I2S-&gt;I2SRXFIFO), 		// I2S Rx
-		(&amp;DAC-&gt;DACR),				// DAC
-		(&amp;UART0-&gt;/*RBTHDLR.*/THR),	// UART0 Tx
-		(&amp;UART0-&gt;/*RBTHDLR.*/RBR),	// UART0 Rx
-		(&amp;UART1-&gt;/*RBTHDLR.*/THR),	// UART1 Tx
-		(&amp;UART1-&gt;/*RBTHDLR.*/RBR),	// UART1 Rx
-		(&amp;UART2-&gt;/*RBTHDLR.*/THR),	// UART2 Tx
-		(&amp;UART2-&gt;/*RBTHDLR.*/RBR),	// UART2 Rx
-		(&amp;UART3-&gt;/*RBTHDLR.*/THR),	// UART3 Tx
-		(&amp;UART3-&gt;/*RBTHDLR.*/RBR),	// UART3 Rx
-		(&amp;TIM0-&gt;MR0),				// MAT0.0
-		(&amp;TIM0-&gt;MR1),				// MAT0.1
-		(&amp;TIM1-&gt;MR0),				// MAT1.0
-		(&amp;TIM1-&gt;MR1),				// MAT1.1
-		(&amp;TIM2-&gt;MR0),				// MAT2.0
-		(&amp;TIM2-&gt;MR1),				// MAT2.1
-		(&amp;TIM3-&gt;MR0),				// MAT3.0
-		(&amp;TIM3-&gt;MR1),				// MAT3.1
-};
-#else
-const uint32_t GPDMA_LUTPerAddr[] = {
-		((uint32_t)&amp;SSP0-&gt;DR),				// SSP0 Tx
-		((uint32_t)&amp;SSP0-&gt;DR),				// SSP0 Rx
-		((uint32_t)&amp;SSP1-&gt;DR),				// SSP1 Tx
-		((uint32_t)&amp;SSP1-&gt;DR),				// SSP1 Rx
-		((uint32_t)&amp;ADC-&gt;ADGDR),			// ADC
-		((uint32_t)&amp;I2S-&gt;I2STXFIFO), 		// I2S Tx
-		((uint32_t)&amp;I2S-&gt;I2SRXFIFO), 		// I2S Rx
-		((uint32_t)&amp;DAC-&gt;DACR),				// DAC
-		((uint32_t)&amp;UART0-&gt;/*RBTHDLR.*/THR),	// UART0 Tx
-		((uint32_t)&amp;UART0-&gt;/*RBTHDLR.*/RBR),	// UART0 Rx
-		((uint32_t)&amp;UART1-&gt;/*RBTHDLR.*/THR),	// UART1 Tx
-		((uint32_t)&amp;UART1-&gt;/*RBTHDLR.*/RBR),	// UART1 Rx
-		((uint32_t)&amp;UART2-&gt;/*RBTHDLR.*/THR),	// UART2 Tx
-		((uint32_t)&amp;UART2-&gt;/*RBTHDLR.*/RBR),	// UART2 Rx
-		((uint32_t)&amp;UART3-&gt;/*RBTHDLR.*/THR),	// UART3 Tx
-		((uint32_t)&amp;UART3-&gt;/*RBTHDLR.*/RBR),	// UART3 Rx
-		((uint32_t)&amp;TIM0-&gt;MR0),				// MAT0.0
-		((uint32_t)&amp;TIM0-&gt;MR1),				// MAT0.1
-		((uint32_t)&amp;TIM1-&gt;MR0),				// MAT1.0
-		((uint32_t)&amp;TIM1-&gt;MR1),				// MAT1.1
-		((uint32_t)&amp;TIM2-&gt;MR0),				// MAT2.0
-		((uint32_t)&amp;TIM2-&gt;MR1),				// MAT2.1
-		((uint32_t)&amp;TIM3-&gt;MR0),				// MAT3.0
-		((uint32_t)&amp;TIM3-&gt;MR1),				// MAT3.1
-};
-#endif
-
-/**
- * @brief Lookup Table of GPDMA Channel Number matched with
- * GPDMA channel pointer
- */
-const GPDMACH_TypeDef *pGPDMACh[8] = {
-		GPDMACH0,	// GPDMA Channel 0
-		GPDMACH1,	// GPDMA Channel 1
-		GPDMACH2,	// GPDMA Channel 2
-		GPDMACH3,	// GPDMA Channel 3
-		GPDMACH4,	// GPDMA Channel 4
-		GPDMACH5,	// GPDMA Channel 5
-		GPDMACH6,	// GPDMA Channel 6
-		GPDMACH7,	// GPDMA Channel 7
-};
-
-/** Optimized Peripheral Source and Destination burst size */
-const uint8_t GPDMA_LUTPerBurst[] = {
-		GPDMA_BSIZE_4,				// SSP0 Tx
-		GPDMA_BSIZE_4,				// SSP0 Rx
-		GPDMA_BSIZE_4,				// SSP1 Tx
-		GPDMA_BSIZE_4,				// SSP1 Rx
-		GPDMA_BSIZE_4,				// ADC
-		GPDMA_BSIZE_32, 			// I2S channel 0
-		GPDMA_BSIZE_32, 			// I2S channel 1
-		GPDMA_BSIZE_1,				// DAC
-		GPDMA_BSIZE_1,				// UART0 Tx
-		GPDMA_BSIZE_1,				// UART0 Rx
-		GPDMA_BSIZE_1,				// UART1 Tx
-		GPDMA_BSIZE_1,				// UART1 Rx
-		GPDMA_BSIZE_1,				// UART2 Tx
-		GPDMA_BSIZE_1,				// UART2 Rx
-		GPDMA_BSIZE_1,				// UART3 Tx
-		GPDMA_BSIZE_1,				// UART3 Rx
-		GPDMA_BSIZE_1,				// MAT0.0
-		GPDMA_BSIZE_1,				// MAT0.1
-		GPDMA_BSIZE_1,				// MAT1.0
-		GPDMA_BSIZE_1,				// MAT1.1
-		GPDMA_BSIZE_1,				// MAT2.0
-		GPDMA_BSIZE_1,				// MAT2.1
-		GPDMA_BSIZE_1,				// MAT3.0
-		GPDMA_BSIZE_1,				// MAT3.1
-};
-
-/** Optimized Peripheral Source and Destination transfer width */
-const uint8_t GPDMA_LUTPerWid[] = {
-		GPDMA_WIDTH_BYTE,				// SSP0 Tx
-		GPDMA_WIDTH_BYTE,				// SSP0 Rx
-		GPDMA_WIDTH_BYTE,				// SSP1 Tx
-		GPDMA_WIDTH_BYTE,				// SSP1 Rx
-		GPDMA_WIDTH_WORD,				// ADC
-		GPDMA_WIDTH_WORD, 				// I2S channel 0
-		GPDMA_WIDTH_WORD, 				// I2S channel 1
-		GPDMA_WIDTH_BYTE,				// DAC
-		GPDMA_WIDTH_BYTE,				// UART0 Tx
-		GPDMA_WIDTH_BYTE,				// UART0 Rx
-		GPDMA_WIDTH_BYTE,				// UART1 Tx
-		GPDMA_WIDTH_BYTE,				// UART1 Rx
-		GPDMA_WIDTH_BYTE,				// UART2 Tx
-		GPDMA_WIDTH_BYTE,				// UART2 Rx
-		GPDMA_WIDTH_BYTE,				// UART3 Tx
-		GPDMA_WIDTH_BYTE,				// UART3 Rx
-		GPDMA_WIDTH_WORD,				// MAT0.0
-		GPDMA_WIDTH_WORD,				// MAT0.1
-		GPDMA_WIDTH_WORD,				// MAT1.0
-		GPDMA_WIDTH_WORD,				// MAT1.1
-		GPDMA_WIDTH_WORD,				// MAT2.0
-		GPDMA_WIDTH_WORD,				// MAT2.1
-		GPDMA_WIDTH_WORD,				// MAT3.0
-		GPDMA_WIDTH_WORD,				// MAT3.1
-};
-
-/** Interrupt Call-back function pointer data for each GPDMA channel */
-static fnGPDMACbs_Type *_apfnGPDMACbs[8] = {
-		NULL, 	// GPDMA Call-back function pointer for Channel 0
-		NULL, 	// GPDMA Call-back function pointer for Channel 1
-		NULL, 	// GPDMA Call-back function pointer for Channel 2
-		NULL, 	// GPDMA Call-back function pointer for Channel 3
-		NULL, 	// GPDMA Call-back function pointer for Channel 4
-		NULL, 	// GPDMA Call-back function pointer for Channel 5
-		NULL, 	// GPDMA Call-back function pointer for Channel 6
-		NULL, 	// GPDMA Call-back function pointer for Channel 7
-};
-
-/**
- * @}
- */
-
-/* Public Functions ----------------------------------------------------------- */
-/** @addtogroup GPDMA_Public_Functions
- * @{
- */
-
-/********************************************************************//**
- * @brief 		Initialize GPDMA controller
- * @param 		None
- * @return 		None
- *********************************************************************/
-void GPDMA_Init(void)
-{
-	/* Enable GPDMA clock */
-	CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCGPDMA, ENABLE);
-
-	// Reset all channel configuration register
-	GPDMACH0-&gt;DMACCConfig = 0;
-	GPDMACH1-&gt;DMACCConfig = 0;
-	GPDMACH2-&gt;DMACCConfig = 0;
-	GPDMACH3-&gt;DMACCConfig = 0;
-	GPDMACH4-&gt;DMACCConfig = 0;
-	GPDMACH5-&gt;DMACCConfig = 0;
-	GPDMACH6-&gt;DMACCConfig = 0;
-	GPDMACH7-&gt;DMACCConfig = 0;
-
-	/* Clear all DMA interrupt and error flag */
-	GPDMA-&gt;DMACIntTCClear = 0xFF;
-	GPDMA-&gt;DMACIntErrClr = 0xFF;
-}
-
-/********************************************************************//**
- * @brief 		Setup GPDMA channel peripheral according to the specified
- *               parameters in the GPDMAChannelConfig.
- * @param[in]	GPDMAChannelConfig Pointer to a GPDMA_CH_CFG_Type
- * 									structure that contains the configuration
- * 									information for the specified GPDMA channel peripheral.
- * @param[in]	pfnGPDMAC			Pointer to a GPDMA interrupt call-back function
- * @return		ERROR if selected channel is enabled before
- * 				or SUCCESS if channel is configured successfully
- *********************************************************************/
-Status GPDMA_Setup(GPDMA_Channel_CFG_Type *GPDMAChannelConfig, fnGPDMACbs_Type *pfnGPDMACbs)
-{
-	GPDMACH_TypeDef *pDMAch;
-	uint32_t tmp1, tmp2;
-
-	if (GPDMA-&gt;DMACEnbldChns &amp; (GPDMA_DMACEnbldChns_Ch(GPDMAChannelConfig-&gt;ChannelNum))) {
-		// This channel is enabled, return ERROR, need to release this channel first
-		return ERROR;
-	}
-
-	// Get Channel pointer
-	pDMAch = (GPDMACH_TypeDef *) pGPDMACh[GPDMAChannelConfig-&gt;ChannelNum];
-
-	// Setup call back function for this channel
-	_apfnGPDMACbs[GPDMAChannelConfig-&gt;ChannelNum] = pfnGPDMACbs;
-
-	// Reset the Interrupt status
-	GPDMA-&gt;DMACIntTCClear = GPDMA_DMACIntTCClear_Ch(GPDMAChannelConfig-&gt;ChannelNum);
-	GPDMA-&gt;DMACIntErrClr = GPDMA_DMACIntErrClr_Ch(GPDMAChannelConfig-&gt;ChannelNum);
-
-	// Clear DMA configure
-	pDMAch-&gt;DMACCControl = 0x00;
-	pDMAch-&gt;DMACCConfig = 0x00;
-
-	/* Assign Linker List Item value */
-	pDMAch-&gt;DMACCLLI = GPDMAChannelConfig-&gt;DMALLI;
-
-	/* Set value to Channel Control Registers */
-	switch (GPDMAChannelConfig-&gt;TransferType)
-	{
-	// Memory to memory
-	case GPDMA_TRANSFERTYPE_M2M:
-		// Assign physical source and destination address
-		pDMAch-&gt;DMACCSrcAddr = GPDMAChannelConfig-&gt;SrcMemAddr;
-		pDMAch-&gt;DMACCDestAddr = GPDMAChannelConfig-&gt;DstMemAddr;
-		pDMAch-&gt;DMACCControl
-				= GPDMA_DMACCxControl_TransferSize(GPDMAChannelConfig-&gt;TransferSize) \
-						| GPDMA_DMACCxControl_SBSize(GPDMA_BSIZE_32) \
-						| GPDMA_DMACCxControl_DBSize(GPDMA_BSIZE_32) \
-						| GPDMA_DMACCxControl_SWidth(GPDMAChannelConfig-&gt;TransferWidth) \
-						| GPDMA_DMACCxControl_DWidth(GPDMAChannelConfig-&gt;TransferWidth) \
-						| GPDMA_DMACCxControl_SI \
-						| GPDMA_DMACCxControl_DI \
-						| GPDMA_DMACCxControl_I;
-		break;
-	// Memory to peripheral
-	case GPDMA_TRANSFERTYPE_M2P:
-		// Assign physical source
-		pDMAch-&gt;DMACCSrcAddr = GPDMAChannelConfig-&gt;SrcMemAddr;
-		// Assign peripheral destination address
-		pDMAch-&gt;DMACCDestAddr = (uint32_t)GPDMA_LUTPerAddr[GPDMAChannelConfig-&gt;DstConn];
-		pDMAch-&gt;DMACCControl
-				= GPDMA_DMACCxControl_TransferSize((uint32_t)GPDMAChannelConfig-&gt;TransferSize) \
-						| GPDMA_DMACCxControl_SBSize((uint32_t)GPDMA_LUTPerBurst[GPDMAChannelConfig-&gt;DstConn]) \
-						| GPDMA_DMACCxControl_DBSize((uint32_t)GPDMA_LUTPerBurst[GPDMAChannelConfig-&gt;DstConn]) \
-						| GPDMA_DMACCxControl_SWidth((uint32_t)GPDMA_LUTPerWid[GPDMAChannelConfig-&gt;DstConn]) \
-						| GPDMA_DMACCxControl_DWidth((uint32_t)GPDMA_LUTPerWid[GPDMAChannelConfig-&gt;DstConn]) \
-						| GPDMA_DMACCxControl_SI \
-						| GPDMA_DMACCxControl_I;
-		break;
-	// Peripheral to memory
-	case GPDMA_TRANSFERTYPE_P2M:
-		// Assign peripheral source address
-		pDMAch-&gt;DMACCSrcAddr = (uint32_t)GPDMA_LUTPerAddr[GPDMAChannelConfig-&gt;SrcConn];
-		// Assign memory destination address
-		pDMAch-&gt;DMACCDestAddr = GPDMAChannelConfig-&gt;DstMemAddr;
-		pDMAch-&gt;DMACCControl
-				= GPDMA_DMACCxControl_TransferSize((uint32_t)GPDMAChannelConfig-&gt;TransferSize) \
-						| GPDMA_DMACCxControl_SBSize((uint32_t)GPDMA_LUTPerBurst[GPDMAChannelConfig-&gt;SrcConn]) \
-						| GPDMA_DMACCxControl_DBSize((uint32_t)GPDMA_LUTPerBurst[GPDMAChannelConfig-&gt;SrcConn]) \
-						| GPDMA_DMACCxControl_SWidth((uint32_t)GPDMA_LUTPerWid[GPDMAChannelConfig-&gt;SrcConn]) \
-						| GPDMA_DMACCxControl_DWidth((uint32_t)GPDMA_LUTPerWid[GPDMAChannelConfig-&gt;SrcConn]) \
-						| GPDMA_DMACCxControl_DI \
-						| GPDMA_DMACCxControl_I;
-		break;
-	// Peripheral to peripheral
-	case GPDMA_TRANSFERTYPE_P2P:
-		// Assign peripheral source address
-		pDMAch-&gt;DMACCSrcAddr = (uint32_t)GPDMA_LUTPerAddr[GPDMAChannelConfig-&gt;SrcConn];
-		// Assign peripheral destination address
-		pDMAch-&gt;DMACCDestAddr = (uint32_t)GPDMA_LUTPerAddr[GPDMAChannelConfig-&gt;DstConn];
-		pDMAch-&gt;DMACCControl
-				= GPDMA_DMACCxControl_TransferSize((uint32_t)GPDMAChannelConfig-&gt;TransferSize) \
-						| GPDMA_DMACCxControl_SBSize((uint32_t)GPDMA_LUTPerBurst[GPDMAChannelConfig-&gt;SrcConn]) \
-						| GPDMA_DMACCxControl_DBSize((uint32_t)GPDMA_LUTPerBurst[GPDMAChannelConfig-&gt;DstConn]) \
-						| GPDMA_DMACCxControl_SWidth((uint32_t)GPDMA_LUTPerWid[GPDMAChannelConfig-&gt;SrcConn]) \
-						| GPDMA_DMACCxControl_DWidth((uint32_t)GPDMA_LUTPerWid[GPDMAChannelConfig-&gt;DstConn]) \
-						| GPDMA_DMACCxControl_I;
-		break;
-	// Do not support any more transfer type, return ERROR
-	default:
-		return ERROR;
-		break;
-	}
-
-	/* Re-Configure DMA Request Select for source peripheral */
-	if (GPDMAChannelConfig-&gt;SrcConn &gt; 15)
-	{
-		DMAREQSEL |= (1&lt;&lt;(GPDMAChannelConfig-&gt;SrcConn - 16));
-	} else {
-		DMAREQSEL &amp;= ~(1&lt;&lt;(GPDMAChannelConfig-&gt;SrcConn - 8));
-	}
-
-	/* Re-Configure DMA Request Select for Destination peripheral */
-	if (GPDMAChannelConfig-&gt;DstConn &gt; 15)
-	{
-		DMAREQSEL |= (1&lt;&lt;(GPDMAChannelConfig-&gt;DstConn - 16));
-	} else {
-		DMAREQSEL &amp;= ~(1&lt;&lt;(GPDMAChannelConfig-&gt;DstConn - 8));
-	}
-
-	/* Enable DMA channels, little endian */
-	GPDMA-&gt;DMACConfig = GPDMA_DMACConfig_E;
-	while (!(GPDMA-&gt;DMACConfig &amp; GPDMA_DMACConfig_E));
-
-	// Calculate absolute value for Connection number
-	tmp1 = GPDMAChannelConfig-&gt;SrcConn;
-	tmp1 = ((tmp1 &gt; 15) ? (tmp1 - 8) : tmp1);
-	tmp2 = GPDMAChannelConfig-&gt;DstConn;
-	tmp2 = ((tmp2 &gt; 15) ? (tmp2 - 8) : tmp2);
-
-	// Configure DMA Channel, enable Error Counter and Terminate counter
-	pDMAch-&gt;DMACCConfig = GPDMA_DMACCxConfig_IE | GPDMA_DMACCxConfig_ITC /*| GPDMA_DMACCxConfig_E*/ \
-		| GPDMA_DMACCxConfig_TransferType((uint32_t)GPDMAChannelConfig-&gt;TransferType) \
-		| GPDMA_DMACCxConfig_SrcPeripheral(tmp1) \
-		| GPDMA_DMACCxConfig_DestPeripheral(tmp2);
-
-	return SUCCESS;
-}
-
-
-/*********************************************************************//**
- * @brief		Enable/Disable DMA channel
- * @param[in]	channelNum	GPDMA channel, should be in range from 0 to 7
- * @param[in]	NewState	New State of this command, should be:
- * 							- ENABLE.
- * 							- DISABLE.
- * @return		None
- **********************************************************************/
-void GPDMA_ChannelCmd(uint8_t channelNum, FunctionalState NewState)
-{
-	GPDMACH_TypeDef *pDMAch;
-
-	// Get Channel pointer
-	pDMAch = (GPDMACH_TypeDef *) pGPDMACh[channelNum];
-
-	if (NewState == ENABLE) {
-		pDMAch-&gt;DMACCConfig |= GPDMA_DMACCxConfig_E;
-	} else {
-		pDMAch-&gt;DMACCConfig &amp;= ~GPDMA_DMACCxConfig_E;
-	}
-}
-
-/*********************************************************************//**
- * @brief		Standard GPDMA interrupt handler, this function will check
- * 				all interrupt status of GPDMA channels, then execute the call
- * 				back function id they're already installed
- * @param[in]	None
- * @return		None
- **********************************************************************/
-void GPDMA_IntHandler(void)
-{
-	uint32_t tmp;
-	// Scan interrupt pending
-	for (tmp = 0; tmp &lt;= 7; tmp++) {
-		if (GPDMA-&gt;DMACIntStat &amp; GPDMA_DMACIntStat_Ch(tmp)) {
-			// Check counter terminal status
-			if (GPDMA-&gt;DMACIntTCStat &amp; GPDMA_DMACIntTCStat_Ch(tmp)) {
-				// Clear terminate counter Interrupt pending
-				GPDMA-&gt;DMACIntTCClear = GPDMA_DMACIntTCClear_Ch(tmp);
-				// Execute call-back function if it is already installed
-				if(_apfnGPDMACbs[tmp] != NULL) {
-					_apfnGPDMACbs[tmp](GPDMA_STAT_INTTC);
-				}
-			}
-			// Check error terminal status
-			if (GPDMA-&gt;DMACIntErrStat &amp; GPDMA_DMACIntErrStat_Ch(tmp)) {
-				// Clear error counter Interrupt pending
-				GPDMA-&gt;DMACIntErrClr = GPDMA_DMACIntErrClr_Ch(tmp);
-				// Execute call-back function if it is already installed
-				if(_apfnGPDMACbs[tmp] != NULL) {
-					_apfnGPDMACbs[tmp](GPDMA_STAT_INTERR);
-				}
-			}
-		}
-	}
-}
-
-
-/**
- * @}
- */
-
-#endif /* _GPDMA */
-
-/**
- * @}
- */
-
-/* --------------------------------- End Of File ------------------------------ */
-
+/**
+ * @file	: lpc17xx_gpdma.c
+ * @brief	: Contains all functions support for GPDMA firmware library on LPC17xx
+ * @version	: 1.0
+ * @date	: 20. Apr. 2009
+ * @author	: HieuNguyen
+ **************************************************************************
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * products. This software is supplied &quot;AS IS&quot; without any warranties.
+ * NXP Semiconductors assumes no responsibility or liability for the
+ * use of the software, conveys no license or title under any patent,
+ * copyright, or mask work right to the product. NXP Semiconductors
+ * reserves the right to make changes in the software without
+ * notification. NXP Semiconductors also make no representation or
+ * warranty that such application will be suitable for the specified
+ * use without further testing or modification.
+ **********************************************************************/
+
+/* Peripheral group ----------------------------------------------------------- */
+/** @addtogroup GPDMA
+ * @{
+ */
+
+/* Includes ------------------------------------------------------------------- */
+#include &quot;lpc17xx_gpdma.h&quot;
+#include &quot;lpc17xx_clkpwr.h&quot;
+
+/* If this source file built with example, the LPC17xx FW library configuration
+ * file in each example directory (&quot;lpc17xx_libcfg.h&quot;) must be included,
+ * otherwise the default FW library configuration file must be included instead
+ */
+#ifdef __BUILD_WITH_EXAMPLE__
+#include &quot;lpc17xx_libcfg.h&quot;
+#else
+#include &quot;lpc17xx_libcfg_default.h&quot;
+#endif /* __BUILD_WITH_EXAMPLE__ */
+
+#ifdef _GPDMA
+
+
+/* Private Variables ---------------------------------------------------------- */
+/** @defgroup GPDMA_Private_Variables
+ * @{
+ */
+
+/**
+ * @brief Lookup Table of Connection Type matched with
+ * Peripheral Data (FIFO) register base address
+ */
+#ifdef __IAR_SYSTEMS_ICC__
+volatile const void *GPDMA_LUTPerAddr[] = {
+		(&amp;LPC_SSP0-&gt;DR),				// SSP0 Tx
+		(&amp;LPC_SSP0-&gt;DR),				// SSP0 Rx
+		(&amp;LPC_SSP1-&gt;DR),				// SSP1 Tx
+		(&amp;LPC_SSP1-&gt;DR),				// SSP1 Rx
+		(&amp;LPC_ADC-&gt;ADGDR),			// ADC
+		(&amp;LPC_I2S-&gt;I2STXFIFO), 		// I2S Tx
+		(&amp;LPC_I2S-&gt;I2SRXFIFO), 		// I2S Rx
+		(&amp;LPC_DAC-&gt;DACR),				// DAC
+		(&amp;LPC_UART0-&gt;/*RBTHDLR.*/THR),	// UART0 Tx
+		(&amp;LPC_UART0-&gt;/*RBTHDLR.*/RBR),	// UART0 Rx
+		(&amp;LPC_UART1-&gt;/*RBTHDLR.*/THR),	// UART1 Tx
+		(&amp;LPC_UART1-&gt;/*RBTHDLR.*/RBR),	// UART1 Rx
+		(&amp;LPC_UART2-&gt;/*RBTHDLR.*/THR),	// UART2 Tx
+		(&amp;LPC_UART2-&gt;/*RBTHDLR.*/RBR),	// UART2 Rx
+		(&amp;LPC_UART3-&gt;/*RBTHDLR.*/THR),	// UART3 Tx
+		(&amp;LPC_UART3-&gt;/*RBTHDLR.*/RBR),	// UART3 Rx
+		(&amp;LPC_TIM0-&gt;MR0),				// MAT0.0
+		(&amp;LPC_TIM0-&gt;MR1),				// MAT0.1
+		(&amp;LPC_TIM1-&gt;MR0),				// MAT1.0
+		(&amp;LPC_TIM1-&gt;MR1),				// MAT1.1
+		(&amp;LPC_TIM2-&gt;MR0),				// MAT2.0
+		(&amp;LPC_TIM2-&gt;MR1),				// MAT2.1
+		(&amp;LPC_TIM3-&gt;MR0),				// MAT3.0
+		(&amp;LPC_TIM3-&gt;MR1),				// MAT3.1
+};
+#else
+const uint32_t GPDMA_LUTPerAddr[] = {
+		((uint32_t)&amp;LPC_SSP0-&gt;DR),				// SSP0 Tx
+		((uint32_t)&amp;LPC_SSP0-&gt;DR),				// SSP0 Rx
+		((uint32_t)&amp;LPC_SSP1-&gt;DR),				// SSP1 Tx
+		((uint32_t)&amp;LPC_SSP1-&gt;DR),				// SSP1 Rx
+		((uint32_t)&amp;LPC_ADC-&gt;ADGDR),			// ADC
+		((uint32_t)&amp;LPC_I2S-&gt;I2STXFIFO), 		// I2S Tx
+		((uint32_t)&amp;LPC_I2S-&gt;I2SRXFIFO), 		// I2S Rx
+		((uint32_t)&amp;LPC_DAC-&gt;DACR),				// DAC
+		((uint32_t)&amp;LPC_UART0-&gt;/*RBTHDLR.*/THR),	// UART0 Tx
+		((uint32_t)&amp;LPC_UART0-&gt;/*RBTHDLR.*/RBR),	// UART0 Rx
+		((uint32_t)&amp;LPC_UART1-&gt;/*RBTHDLR.*/THR),	// UART1 Tx
+		((uint32_t)&amp;LPC_UART1-&gt;/*RBTHDLR.*/RBR),	// UART1 Rx
+		((uint32_t)&amp;LPC_UART2-&gt;/*RBTHDLR.*/THR),	// UART2 Tx
+		((uint32_t)&amp;LPC_UART2-&gt;/*RBTHDLR.*/RBR),	// UART2 Rx
+		((uint32_t)&amp;LPC_UART3-&gt;/*RBTHDLR.*/THR),	// UART3 Tx
+		((uint32_t)&amp;LPC_UART3-&gt;/*RBTHDLR.*/RBR),	// UART3 Rx
+		((uint32_t)&amp;LPC_TIM0-&gt;MR0),				// MAT0.0
+		((uint32_t)&amp;LPC_TIM0-&gt;MR1),				// MAT0.1
+		((uint32_t)&amp;LPC_TIM1-&gt;MR0),				// MAT1.0
+		((uint32_t)&amp;LPC_TIM1-&gt;MR1),				// MAT1.1
+		((uint32_t)&amp;LPC_TIM2-&gt;MR0),				// MAT2.0
+		((uint32_t)&amp;LPC_TIM2-&gt;MR1),				// MAT2.1
+		((uint32_t)&amp;LPC_TIM3-&gt;MR0),				// MAT3.0
+		((uint32_t)&amp;LPC_TIM3-&gt;MR1),				// MAT3.1
+};
+#endif
+/**
+ * @brief Lookup Table of GPDMA Channel Number matched with
+ * GPDMA channel pointer
+ */
+const LPC_GPDMACH_TypeDef *pGPDMACh[8] = {
+		LPC_GPDMACH0,	// GPDMA Channel 0
+		LPC_GPDMACH1,	// GPDMA Channel 1
+		LPC_GPDMACH2,	// GPDMA Channel 2
+		LPC_GPDMACH3,	// GPDMA Channel 3
+		LPC_GPDMACH4,	// GPDMA Channel 4
+		LPC_GPDMACH5,	// GPDMA Channel 5
+		LPC_GPDMACH6,	// GPDMA Channel 6
+		LPC_GPDMACH7,	// GPDMA Channel 7
+};
+/**
+ * @brief Optimized Peripheral Source and Destination burst size
+ */
+const uint8_t GPDMA_LUTPerBurst[] = {
+		GPDMA_BSIZE_4,				// SSP0 Tx
+		GPDMA_BSIZE_4,				// SSP0 Rx
+		GPDMA_BSIZE_4,				// SSP1 Tx
+		GPDMA_BSIZE_4,				// SSP1 Rx
+		GPDMA_BSIZE_4,				// ADC
+		GPDMA_BSIZE_32, 			// I2S channel 0
+		GPDMA_BSIZE_32, 			// I2S channel 1
+		GPDMA_BSIZE_1,				// DAC
+		GPDMA_BSIZE_1,				// UART0 Tx
+		GPDMA_BSIZE_1,				// UART0 Rx
+		GPDMA_BSIZE_1,				// UART1 Tx
+		GPDMA_BSIZE_1,				// UART1 Rx
+		GPDMA_BSIZE_1,				// UART2 Tx
+		GPDMA_BSIZE_1,				// UART2 Rx
+		GPDMA_BSIZE_1,				// UART3 Tx
+		GPDMA_BSIZE_1,				// UART3 Rx
+		GPDMA_BSIZE_1,				// MAT0.0
+		GPDMA_BSIZE_1,				// MAT0.1
+		GPDMA_BSIZE_1,				// MAT1.0
+		GPDMA_BSIZE_1,				// MAT1.1
+		GPDMA_BSIZE_1,				// MAT2.0
+		GPDMA_BSIZE_1,				// MAT2.1
+		GPDMA_BSIZE_1,				// MAT3.0
+		GPDMA_BSIZE_1,				// MAT3.1
+};
+/**
+ * @brief Optimized Peripheral Source and Destination transfer width
+ */
+const uint8_t GPDMA_LUTPerWid[] = {
+		GPDMA_WIDTH_BYTE,				// SSP0 Tx
+		GPDMA_WIDTH_BYTE,				// SSP0 Rx
+		GPDMA_WIDTH_BYTE,				// SSP1 Tx
+		GPDMA_WIDTH_BYTE,				// SSP1 Rx
+		GPDMA_WIDTH_WORD,				// ADC
+		GPDMA_WIDTH_WORD, 				// I2S channel 0
+		GPDMA_WIDTH_WORD, 				// I2S channel 1
+		GPDMA_WIDTH_BYTE,				// DAC
+		GPDMA_WIDTH_BYTE,				// UART0 Tx
+		GPDMA_WIDTH_BYTE,				// UART0 Rx
+		GPDMA_WIDTH_BYTE,				// UART1 Tx
+		GPDMA_WIDTH_BYTE,				// UART1 Rx
+		GPDMA_WIDTH_BYTE,				// UART2 Tx
+		GPDMA_WIDTH_BYTE,				// UART2 Rx
+		GPDMA_WIDTH_BYTE,				// UART3 Tx
+		GPDMA_WIDTH_BYTE,				// UART3 Rx
+		GPDMA_WIDTH_WORD,				// MAT0.0
+		GPDMA_WIDTH_WORD,				// MAT0.1
+		GPDMA_WIDTH_WORD,				// MAT1.0
+		GPDMA_WIDTH_WORD,				// MAT1.1
+		GPDMA_WIDTH_WORD,				// MAT2.0
+		GPDMA_WIDTH_WORD,				// MAT2.1
+		GPDMA_WIDTH_WORD,				// MAT3.0
+		GPDMA_WIDTH_WORD,				// MAT3.1
+};
+
+/** Interrupt Call-back function pointer data for each GPDMA channel */
+static fnGPDMACbs_Type *_apfnGPDMACbs[8] = {
+		NULL, 	// GPDMA Call-back function pointer for Channel 0
+		NULL, 	// GPDMA Call-back function pointer for Channel 1
+		NULL, 	// GPDMA Call-back function pointer for Channel 2
+		NULL, 	// GPDMA Call-back function pointer for Channel 3
+		NULL, 	// GPDMA Call-back function pointer for Channel 4
+		NULL, 	// GPDMA Call-back function pointer for Channel 5
+		NULL, 	// GPDMA Call-back function pointer for Channel 6
+		NULL, 	// GPDMA Call-back function pointer for Channel 7
+};
+
+/**
+ * @}
+ */
+
+/* Public Functions ----------------------------------------------------------- */
+/** @addtogroup GPDMA_Public_Functions
+ * @{
+ */
+
+/********************************************************************//**
+ * @brief 		Initialize GPDMA controller
+ * @param 		None
+ * @return 		None
+ *********************************************************************/
+void GPDMA_Init(void)
+{
+	/* Enable GPDMA clock */
+	CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCGPDMA, ENABLE);
+
+	// Reset all channel configuration register
+	LPC_GPDMACH0-&gt;DMACCConfig = 0;
+	LPC_GPDMACH1-&gt;DMACCConfig = 0;
+	LPC_GPDMACH2-&gt;DMACCConfig = 0;
+	LPC_GPDMACH3-&gt;DMACCConfig = 0;
+	LPC_GPDMACH4-&gt;DMACCConfig = 0;
+	LPC_GPDMACH5-&gt;DMACCConfig = 0;
+	LPC_GPDMACH6-&gt;DMACCConfig = 0;
+	LPC_GPDMACH7-&gt;DMACCConfig = 0;
+
+	/* Clear all DMA interrupt and error flag */
+	LPC_GPDMA-&gt;DMACIntTCClear = 0xFF;
+	LPC_GPDMA-&gt;DMACIntErrClr = 0xFF;
+}
+
+/********************************************************************//**
+ * @brief 		Setup GPDMA channel peripheral according to the specified
+ *               parameters in the GPDMAChannelConfig.
+ * @param[in]	GPDMAChannelConfig Pointer to a GPDMA_CH_CFG_Type
+ * 									structure that contains the configuration
+ * 									information for the specified GPDMA channel peripheral.
+ * @param[in]	pfnGPDMACbs			Pointer to a GPDMA interrupt call-back function
+ * @return		ERROR if selected channel is enabled before
+ * 				or SUCCESS if channel is configured successfully
+ *********************************************************************/
+Status GPDMA_Setup(GPDMA_Channel_CFG_Type *GPDMAChannelConfig, fnGPDMACbs_Type *pfnGPDMACbs)
+{
+	LPC_GPDMACH_TypeDef *pDMAch;
+	uint32_t tmp1, tmp2;
+
+	if (LPC_GPDMA-&gt;DMACEnbldChns &amp; (GPDMA_DMACEnbldChns_Ch(GPDMAChannelConfig-&gt;ChannelNum))) {
+		// This channel is enabled, return ERROR, need to release this channel first
+		return ERROR;
+	}
+
+	// Get Channel pointer
+	pDMAch = (LPC_GPDMACH_TypeDef *) pGPDMACh[GPDMAChannelConfig-&gt;ChannelNum];
+
+	// Setup call back function for this channel
+	_apfnGPDMACbs[GPDMAChannelConfig-&gt;ChannelNum] = pfnGPDMACbs;
+
+	// Reset the Interrupt status
+	LPC_GPDMA-&gt;DMACIntTCClear = GPDMA_DMACIntTCClear_Ch(GPDMAChannelConfig-&gt;ChannelNum);
+	LPC_GPDMA-&gt;DMACIntErrClr = GPDMA_DMACIntErrClr_Ch(GPDMAChannelConfig-&gt;ChannelNum);
+
+	// Clear DMA configure
+	pDMAch-&gt;DMACCControl = 0x00;
+	pDMAch-&gt;DMACCConfig = 0x00;
+
+	/* Assign Linker List Item value */
+	pDMAch-&gt;DMACCLLI = GPDMAChannelConfig-&gt;DMALLI;
+
+	/* Set value to Channel Control Registers */
+	switch (GPDMAChannelConfig-&gt;TransferType)
+	{
+	// Memory to memory
+	case GPDMA_TRANSFERTYPE_M2M:
+		// Assign physical source and destination address
+		pDMAch-&gt;DMACCSrcAddr = GPDMAChannelConfig-&gt;SrcMemAddr;
+		pDMAch-&gt;DMACCDestAddr = GPDMAChannelConfig-&gt;DstMemAddr;
+		pDMAch-&gt;DMACCControl
+				= GPDMA_DMACCxControl_TransferSize(GPDMAChannelConfig-&gt;TransferSize) \
+						| GPDMA_DMACCxControl_SBSize(GPDMA_BSIZE_32) \
+						| GPDMA_DMACCxControl_DBSize(GPDMA_BSIZE_32) \
+						| GPDMA_DMACCxControl_SWidth(GPDMAChannelConfig-&gt;TransferWidth) \
+						| GPDMA_DMACCxControl_DWidth(GPDMAChannelConfig-&gt;TransferWidth) \
+						| GPDMA_DMACCxControl_SI \
+						| GPDMA_DMACCxControl_DI \
+						| GPDMA_DMACCxControl_I;
+		break;
+	// Memory to peripheral
+	case GPDMA_TRANSFERTYPE_M2P:
+		// Assign physical source
+		pDMAch-&gt;DMACCSrcAddr = GPDMAChannelConfig-&gt;SrcMemAddr;
+		// Assign peripheral destination address
+		pDMAch-&gt;DMACCDestAddr = (uint32_t)GPDMA_LUTPerAddr[GPDMAChannelConfig-&gt;DstConn];
+		pDMAch-&gt;DMACCControl
+				= GPDMA_DMACCxControl_TransferSize((uint32_t)GPDMAChannelConfig-&gt;TransferSize) \
+						| GPDMA_DMACCxControl_SBSize((uint32_t)GPDMA_LUTPerBurst[GPDMAChannelConfig-&gt;DstConn]) \
+						| GPDMA_DMACCxControl_DBSize((uint32_t)GPDMA_LUTPerBurst[GPDMAChannelConfig-&gt;DstConn]) \
+						| GPDMA_DMACCxControl_SWidth((uint32_t)GPDMA_LUTPerWid[GPDMAChannelConfig-&gt;DstConn]) \
+						| GPDMA_DMACCxControl_DWidth((uint32_t)GPDMA_LUTPerWid[GPDMAChannelConfig-&gt;DstConn]) \
+						| GPDMA_DMACCxControl_SI \
+						| GPDMA_DMACCxControl_I;
+		break;
+	// Peripheral to memory
+	case GPDMA_TRANSFERTYPE_P2M:
+		// Assign peripheral source address
+		pDMAch-&gt;DMACCSrcAddr = (uint32_t)GPDMA_LUTPerAddr[GPDMAChannelConfig-&gt;SrcConn];
+		// Assign memory destination address
+		pDMAch-&gt;DMACCDestAddr = GPDMAChannelConfig-&gt;DstMemAddr;
+		pDMAch-&gt;DMACCControl
+				= GPDMA_DMACCxControl_TransferSize((uint32_t)GPDMAChannelConfig-&gt;TransferSize) \
+						| GPDMA_DMACCxControl_SBSize((uint32_t)GPDMA_LUTPerBurst[GPDMAChannelConfig-&gt;SrcConn]) \
+						| GPDMA_DMACCxControl_DBSize((uint32_t)GPDMA_LUTPerBurst[GPDMAChannelConfig-&gt;SrcConn]) \
+						| GPDMA_DMACCxControl_SWidth((uint32_t)GPDMA_LUTPerWid[GPDMAChannelConfig-&gt;SrcConn]) \
+						| GPDMA_DMACCxControl_DWidth((uint32_t)GPDMA_LUTPerWid[GPDMAChannelConfig-&gt;SrcConn]) \
+						| GPDMA_DMACCxControl_DI \
+						| GPDMA_DMACCxControl_I;
+		break;
+	// Peripheral to peripheral
+	case GPDMA_TRANSFERTYPE_P2P:
+		// Assign peripheral source address
+		pDMAch-&gt;DMACCSrcAddr = (uint32_t)GPDMA_LUTPerAddr[GPDMAChannelConfig-&gt;SrcConn];
+		// Assign peripheral destination address
+		pDMAch-&gt;DMACCDestAddr = (uint32_t)GPDMA_LUTPerAddr[GPDMAChannelConfig-&gt;DstConn];
+		pDMAch-&gt;DMACCControl
+				= GPDMA_DMACCxControl_TransferSize((uint32_t)GPDMAChannelConfig-&gt;TransferSize) \
+						| GPDMA_DMACCxControl_SBSize((uint32_t)GPDMA_LUTPerBurst[GPDMAChannelConfig-&gt;SrcConn]) \
+						| GPDMA_DMACCxControl_DBSize((uint32_t)GPDMA_LUTPerBurst[GPDMAChannelConfig-&gt;DstConn]) \
+						| GPDMA_DMACCxControl_SWidth((uint32_t)GPDMA_LUTPerWid[GPDMAChannelConfig-&gt;SrcConn]) \
+						| GPDMA_DMACCxControl_DWidth((uint32_t)GPDMA_LUTPerWid[GPDMAChannelConfig-&gt;DstConn]) \
+						| GPDMA_DMACCxControl_I;
+		break;
+	// Do not support any more transfer type, return ERROR
+	default:
+		return ERROR;
+		break;
+	}
+
+	/* Re-Configure DMA Request Select for source peripheral */
+	if (GPDMAChannelConfig-&gt;SrcConn &gt; 15)
+	{
+		DMAREQSEL |= (1&lt;&lt;(GPDMAChannelConfig-&gt;SrcConn - 16));
+	} else {
+		DMAREQSEL &amp;= ~(1&lt;&lt;(GPDMAChannelConfig-&gt;SrcConn - 8));
+	}
+
+	/* Re-Configure DMA Request Select for Destination peripheral */
+	if (GPDMAChannelConfig-&gt;DstConn &gt; 15)
+	{
+		DMAREQSEL |= (1&lt;&lt;(GPDMAChannelConfig-&gt;DstConn - 16));
+	} else {
+		DMAREQSEL &amp;= ~(1&lt;&lt;(GPDMAChannelConfig-&gt;DstConn - 8));
+	}
+
+	/* Enable DMA channels, little endian */
+	LPC_GPDMA-&gt;DMACConfig = GPDMA_DMACConfig_E;
+	while (!(LPC_GPDMA-&gt;DMACConfig &amp; GPDMA_DMACConfig_E));
+
+	// Calculate absolute value for Connection number
+	tmp1 = GPDMAChannelConfig-&gt;SrcConn;
+	tmp1 = ((tmp1 &gt; 15) ? (tmp1 - 8) : tmp1);
+	tmp2 = GPDMAChannelConfig-&gt;DstConn;
+	tmp2 = ((tmp2 &gt; 15) ? (tmp2 - 8) : tmp2);
+
+	// Configure DMA Channel, enable Error Counter and Terminate counter
+	pDMAch-&gt;DMACCConfig = GPDMA_DMACCxConfig_IE | GPDMA_DMACCxConfig_ITC /*| GPDMA_DMACCxConfig_E*/ \
+		| GPDMA_DMACCxConfig_TransferType((uint32_t)GPDMAChannelConfig-&gt;TransferType) \
+		| GPDMA_DMACCxConfig_SrcPeripheral(tmp1) \
+		| GPDMA_DMACCxConfig_DestPeripheral(tmp2);
+
+	return SUCCESS;
+}
+
+
+/*********************************************************************//**
+ * @brief		Enable/Disable DMA channel
+ * @param[in]	channelNum	GPDMA channel, should be in range from 0 to 7
+ * @param[in]	NewState	New State of this command, should be:
+ * 					- ENABLE.
+ * 					- DISABLE.
+ * @return		None
+ **********************************************************************/
+void GPDMA_ChannelCmd(uint8_t channelNum, FunctionalState NewState)
+{
+	LPC_GPDMACH_TypeDef *pDMAch;
+
+	// Get Channel pointer
+	pDMAch = (LPC_GPDMACH_TypeDef *) pGPDMACh[channelNum];
+
+	if (NewState == ENABLE) {
+		pDMAch-&gt;DMACCConfig |= GPDMA_DMACCxConfig_E;
+	} else {
+		pDMAch-&gt;DMACCConfig &amp;= ~GPDMA_DMACCxConfig_E;
+	}
+}
+
+/*********************************************************************//**
+ * @brief		Standard GPDMA interrupt handler, this function will check
+ * 				all interrupt status of GPDMA channels, then execute the call
+ * 				back function id they're already installed
+ * @param[in]	None
+ * @return		None
+ **********************************************************************/
+void GPDMA_IntHandler(void)
+{
+	uint32_t tmp;
+	// Scan interrupt pending
+	for (tmp = 0; tmp &lt;= 7; tmp++) {
+		if (LPC_GPDMA-&gt;DMACIntStat &amp; GPDMA_DMACIntStat_Ch(tmp)) {
+			// Check counter terminal status
+			if (LPC_GPDMA-&gt;DMACIntTCStat &amp; GPDMA_DMACIntTCStat_Ch(tmp)) {
+				// Clear terminate counter Interrupt pending
+				LPC_GPDMA-&gt;DMACIntTCClear = GPDMA_DMACIntTCClear_Ch(tmp);
+				// Execute call-back function if it is already installed
+				if(_apfnGPDMACbs[tmp] != NULL) {
+					_apfnGPDMACbs[tmp](GPDMA_STAT_INTTC);
+				}
+			}
+			// Check error terminal status
+			if (LPC_GPDMA-&gt;DMACIntErrStat &amp; GPDMA_DMACIntErrStat_Ch(tmp)) {
+				// Clear error counter Interrupt pending
+				LPC_GPDMA-&gt;DMACIntErrClr = GPDMA_DMACIntErrClr_Ch(tmp);
+				// Execute call-back function if it is already installed
+				if(_apfnGPDMACbs[tmp] != NULL) {
+					_apfnGPDMACbs[tmp](GPDMA_STAT_INTERR);
+				}
+			}
+		}
+	}
+}
+
+
+/**
+ * @}
+ */
+
+#endif /* _GPDMA */
+
+/**
+ * @}
+ */
+
+/* --------------------------------- End Of File ------------------------------ */
+


Property changes on: trunk/src/platform/lpc17xx/drivers/src/lpc17xx_gpdma.c
___________________________________________________________________
Deleted: svn:executable
   - *

Modified: trunk/src/platform/lpc17xx/drivers/src/lpc17xx_gpio.c
===================================================================
--- trunk/src/platform/lpc17xx/drivers/src/lpc17xx_gpio.c	2010-06-28 21:53:59 UTC (rev 759)
+++ trunk/src/platform/lpc17xx/drivers/src/lpc17xx_gpio.c	2010-07-12 20:56:54 UTC (rev 760)
@@ -1,658 +1,657 @@
-/**
- * @file	: lpc17xx_gpio.c
- * @brief	: Contains all functions support for GPIO firmware library on LPC17xx
- * @version	: 1.0
- * @date	: 11. Jun. 2009
- * @author	: HieuNguyen
- *----------------------------------------------------------------------------
- * Software that is described herein is for illustrative purposes only
- * which provides customers with programming information regarding the
- * products. This software is supplied &quot;AS IS&quot; without any warranties.
- * NXP Semiconductors assumes no responsibility or liability for the
- * use of the software, conveys no license or title under any patent,
- * copyright, or mask work right to the product. NXP Semiconductors
- * reserves the right to make changes in the software without
- * notification. NXP Semiconductors also make no representation or
- * warranty that such application will be suitable for the specified
- * use without further testing or modification.
- **********************************************************************/
-
-/* Peripheral group ----------------------------------------------------------- */
-/** @addtogroup GPIO
- * @{
- */
-
-/* Includes ------------------------------------------------------------------- */
-#include &quot;lpc17xx_gpio.h&quot;
-
-/* If this source file built with example, the LPC17xx FW library configuration
- * file in each example directory (&quot;lpc17xx_libcfg.h&quot;) must be included,
- * otherwise the default FW library configuration file must be included instead
- */
-#ifdef __BUILD_WITH_EXAMPLE__
-#include &quot;lpc17xx_libcfg.h&quot;
-#else
-#include &quot;lpc17xx_libcfg_default.h&quot;
-#endif /* __BUILD_WITH_EXAMPLE__ */
-
-
-#ifdef _GPIO
-
-/* Private Functions ---------------------------------------------------------- */
-/** @defgroup GPIO_Private_Functions
- * @{
- */
-
-/*********************************************************************//**
- * @brief		Get pointer to GPIO peripheral due to GPIO port
- * @param[in]	portNum		Port Number value, should be in range from 0 to 4.
- * @return		Pointer to GPIO peripheral
- **********************************************************************/
-static GPIO_TypeDef *GPIO_GetPointer(uint8_t portNum)
-{
-	GPIO_TypeDef *pGPIO = NULL;
-
-	switch (portNum) {
-	case 0:
-		pGPIO = GPIO0;
-		break;
-	case 1:
-		pGPIO = GPIO1;
-		break;
-	case 2:
-		pGPIO = GPIO2;
-		break;
-	case 3:
-		pGPIO = GPIO3;
-		break;
-	case 4:
-		pGPIO = GPIO4;
-		break;
-	default:
-		break;
-	}
-
-	return pGPIO;
-}
-
-/*********************************************************************//**
- * @brief		Get pointer to FIO peripheral in halfword accessible style
- * 				due to FIO port
- * @param[in]	portNum		Port Number value, should be in range from 0 to 4.
- * @return		Pointer to FIO peripheral
- **********************************************************************/
-static GPIO_HalfWord_TypeDef *FIO_HalfWordGetPointer(uint8_t portNum)
-{
-	GPIO_HalfWord_TypeDef *pFIO = NULL;
-
-	switch (portNum) {
-	case 0:
-		pFIO = GPIO0_HalfWord;
-		break;
-	case 1:
-		pFIO = GPIO1_HalfWord;
-		break;
-	case 2:
-		pFIO = GPIO2_HalfWord;
-		break;
-	case 3:
-		pFIO = GPIO3_HalfWord;
-		break;
-	case 4:
-		pFIO = GPIO4_HalfWord;
-		break;
-	default:
-		break;
-	}
-
-	return pFIO;
-}
-
-/*********************************************************************//**
- * @brief		Get pointer to FIO peripheral in byte accessible style
- * 				due to FIO port
- * @param[in]	portNum		Port Number value, should be in range from 0 to 4.
- * @return		Pointer to FIO peripheral
- **********************************************************************/
-static GPIO_Byte_TypeDef *FIO_ByteGetPointer(uint8_t portNum)
-{
-	GPIO_Byte_TypeDef *pFIO = NULL;
-
-	switch (portNum) {
-	case 0:
-		pFIO = GPIO0_Byte;
-		break;
-	case 1:
-		pFIO = GPIO1_Byte;
-		break;
-	case 2:
-		pFIO = GPIO2_Byte;
-		break;
-	case 3:
-		pFIO = GPIO3_Byte;
-		break;
-	case 4:
-		pFIO = GPIO4_Byte;
-		break;
-	default:
-		break;
-	}
-
-	return pFIO;
-}
-
-/**
- * @}
- */
-
-
-/* Public Functions ----------------------------------------------------------- */
-/** @addtogroup GPIO_Public_Functions
- * @{
- */
-
-
-/* GPIO ------------------------------------------------------------------------------ */
-
-/*********************************************************************//**
- * @brief		Set Direction for GPIO port.
- * @param[in]	portNum		Port Number value, should be in range from 0 to 4
- * @param[in]	bitValue	Value that contains all bits to set direction,
- * 							in range from 0 to 0xFFFFFFFF.
- * 							example: value 0x5 to set direction for bit 0 and bit 1.
- * @param[in]	dir			Direction value, should be:
- * 							- 0: Input.
- * 							- 1: Output.
- * @return		None
- *
- * Note: All remaining bits that are not activated in bitValue (value '0')
- * will not be effected by this function.
- **********************************************************************/
-void GPIO_SetDir(uint8_t portNum, uint32_t bitValue, uint8_t dir)
-{
-	GPIO_TypeDef *pGPIO = GPIO_GetPointer(portNum);
-
-	if (pGPIO != NULL) {
-		// Enable Output
-		if (dir) {
-			pGPIO-&gt;FIODIR |= bitValue;
-		}
-		// Enable Input
-		else {
-			pGPIO-&gt;FIODIR &amp;= ~bitValue;
-		}
-	}
-}
-
-
-/*********************************************************************//**
- * @brief		Set Value for bits that have output direction on GPIO port.
- * @param[in]	portNum		Port number value, should be in range from 0 to 4
- * @param[in]	bitValue	Value that contains all bits on GPIO to set,
- * 							in range from 0 to 0xFFFFFFFF.
- * 							example: value 0x5 to set bit 0 and bit 1.
- * @return		None
- *
- * Note:
- * - For all bits that has been set as input direction, this function will
- * not effect.
- * - For all remaining bits that are not activated in bitValue (value '0')
- * will not be effected by this function.
- **********************************************************************/
-void GPIO_SetValue(uint8_t portNum, uint32_t bitValue)
-{
-	GPIO_TypeDef *pGPIO = GPIO_GetPointer(portNum);
-
-	if (pGPIO != NULL) {
-		pGPIO-&gt;FIOSET = bitValue;
-	}
-}
-
-/*********************************************************************//**
- * @brief		Clear Value for bits that have output direction on GPIO port.
- * @param[in]	portNum		Port number value, should be in range from 0 to 4
- * @param[in]	bitValue	Value that contains all bits on GPIO to clear,
- * 							in range from 0 to 0xFFFFFFFF.
- * 							example: value 0x5 to clear bit 0 and bit 1.
- * @return		None
- *
- * Note:
- * - For all bits that has been set as input direction, this function will
- * not effect.
- * - For all remaining bits that are not activated in bitValue (value '0')
- * will not be effected by this function.
- **********************************************************************/
-void GPIO_ClearValue(uint8_t portNum, uint32_t bitValue)
-{
-	GPIO_TypeDef *pGPIO = GPIO_GetPointer(portNum);
-
-	if (pGPIO != NULL) {
-		pGPIO-&gt;FIOCLR = bitValue;
-	}
-}
-
-/*********************************************************************//**
- * @brief		Read Current state on port pin that have input direction of GPIO
- * @param[in]	portNum		Port number to read value, in range from 0 to 4
- * @return		Current value of GPIO port.
- *
- * Note: Return value contain state of each port pin (bit) on that GPIO regardless
- * its direction is input or output.
- **********************************************************************/
-uint32_t GPIO_ReadValue(uint8_t portNum)
-{
-	GPIO_TypeDef *pGPIO = GPIO_GetPointer(portNum);
-
-	if (pGPIO != NULL) {
-		return pGPIO-&gt;FIOPIN;
-	}
-
-	return (0);
-}
-
-/* FIO word accessible ----------------------------------------------------------------- */
-/* Stub function for FIO (word-accessible) style */
-
-/**
- * @brief The same with GPIO_SetDir()
- */
-void FIO_SetDir(uint8_t portNum, uint32_t bitValue, uint8_t dir)
-{
-	GPIO_SetDir(portNum, bitValue, dir);
-}
-
-/**
- * @brief The same with GPIO_SetValue()
- */
-void FIO_SetValue(uint8_t portNum, uint32_t bitValue)
-{
-	GPIO_SetValue(portNum, bitValue);
-}
-
-/**
- * @brief The same with GPIO_ClearValue()
- */
-void FIO_ClearValue(uint8_t portNum, uint32_t bitValue)
-{
-	GPIO_ClearValue(portNum, bitValue);
-}
-
-/**
- * @brief The same with GPIO_ReadValue()
- */
-uint32_t FIO_ReadValue(uint8_t portNum)
-{
-	return (GPIO_ReadValue(portNum));
-}
-
-
-/*********************************************************************//**
- * @brief		Set mask value for bits in FIO port
- * @param[in]	portNum		Port number, in range from 0 to 4
- * @param[in]	bitValue	Value that contains all bits in to set,
- * 							in range from 0 to 0xFFFFFFFF.
- * @param[in]	maskValue	Mask value contains state value for each bit:
- * 							- 0: not mask.
- * 							- 1: mask.
- * @return		None
- *
- * Note:
- * - All remaining bits that are not activated in bitValue (value '0')
- * will not be effected by this function.
- * - After executing this function, in mask register, value '0' on each bit
- * enables an access to the corresponding physical pin via a read or write access,
- * while value '1' on bit (masked) that corresponding pin will not be changed
- * with write access and if read, will not be reflected in the updated pin.
- **********************************************************************/
-void FIO_SetMask(uint8_t portNum, uint32_t bitValue, uint8_t maskValue)
-{
-	GPIO_TypeDef *pFIO = GPIO_GetPointer(portNum);
-	if(pFIO != NULL) {
-		// Mask
-		if (maskValue){
-			pFIO-&gt;FIOMASK |= bitValue;
-		}
-		// Un-mask
-		else {
-			pFIO-&gt;FIOMASK &amp;= ~bitValue;
-		}
-	}
-}
-
-
-/* FIO halfword accessible ------------------------------------------------------------- */
-
-/*********************************************************************//**
- * @brief		Set direction for FIO port in halfword accessible style
- * @param[in]	portNum		Port number, in range from 0 to 4
- * @param[in]	halfwordNum	HalfWord part number, should be 0 (lower) or 1(upper)
- * @param[in]	bitValue	Value that contains all bits in to set direction,
- * 							in range from 0 to 0xFFFF.
- * @param[in]	dir			Direction value, should be:
- * 							- 0: Input.
- * 							- 1: Output.
- * @return		None
- *
- * Note: All remaining bits that are not activated in bitValue (value '0')
- * will not be effected by this function.
- **********************************************************************/
-void FIO_HalfWordSetDir(uint8_t portNum, uint8_t halfwordNum, uint16_t bitValue, uint8_t dir)
-{
-	GPIO_HalfWord_TypeDef *pFIO = FIO_HalfWordGetPointer(portNum);
-	if(pFIO != NULL) {
-		// Output direction
-		if (dir) {
-			// Upper
-			if(halfwordNum) {
-				pFIO-&gt;FIODIRU |= bitValue;
-			}
-			// lower
-			else {
-				pFIO-&gt;FIODIRL |= bitValue;
-			}
-		}
-		// Input direction
-		else {
-			// Upper
-			if(halfwordNum) {
-				pFIO-&gt;FIODIRU &amp;= ~bitValue;
-			}
-			// lower
-			else {
-				pFIO-&gt;FIODIRL &amp;= ~bitValue;
-			}
-		}
-	}
-}
-
-
-/*********************************************************************//**
- * @brief		Set mask value for bits in FIO port in halfword accessible style
- * @param[in]	portNum		Port number, in range from 0 to 4
- * @param[in]	halfwordNum	HalfWord part number, should be 0 (lower) or 1(upper)
- * @param[in]	bitValue	Value that contains all bits in to set,
- * 							in range from 0 to 0xFFFF.
- * @param[in]	maskValue	Mask value contains state value for each bit:
- * 							- 0: not mask.
- * 							- 1: mask.
- * @return		None
- *
- * Note:
- * - All remaining bits that are not activated in bitValue (value '0')
- * will not be effected by this function.
- * - After executing this function, in mask register, value '0' on each bit
- * enables an access to the corresponding physical pin via a read or write access,
- * while value '1' on bit (masked) that corresponding pin will not be changed
- * with write access and if read, will not be reflected in the updated pin.
- **********************************************************************/
-void FIO_HalfWordSetMask(uint8_t portNum, uint8_t halfwordNum, uint16_t bitValue, uint8_t maskValue)
-{
-	GPIO_HalfWord_TypeDef *pFIO = FIO_HalfWordGetPointer(portNum);
-	if(pFIO != NULL) {
-		// Mask
-		if (maskValue){
-			// Upper
-			if(halfwordNum) {
-				pFIO-&gt;FIOMASKU |= bitValue;
-			}
-			// lower
-			else {
-				pFIO-&gt;FIOMASKL |= bitValue;
-			}
-		}
-		// Un-mask
-		else {
-			// Upper
-			if(halfwordNum) {
-				pFIO-&gt;FIOMASKU &amp;= ~bitValue;
-			}
-			// lower
-			else {
-				pFIO-&gt;FIOMASKL &amp;= ~bitValue;
-			}
-		}
-	}
-}
-
-
-/*********************************************************************//**
- * @brief		Set bits for FIO port in halfword accessible style
- * @param[in]	portNum		Port number, in range from 0 to 4
- * @param[in]	halfwordNum	HalfWord part number, should be 0 (lower) or 1(upper)
- * @param[in]	bitValue	Value that contains all bits in to set,
- * 							in range from 0 to 0xFFFF.
- * @return		None
- *
- * Note:
- * - For all bits that has been set as input direction, this function will
- * not effect.
- * - For all remaining bits that are not activated in bitValue (value '0')
- * will not be effected by this function.
- **********************************************************************/
-void FIO_HalfWordSetValue(uint8_t portNum, uint8_t halfwordNum, uint16_t bitValue)
-{
-	GPIO_HalfWord_TypeDef *pFIO = FIO_HalfWordGetPointer(portNum);
-	if(pFIO != NULL) {
-		// Upper
-		if(halfwordNum) {
-			pFIO-&gt;FIOSETU = bitValue;
-		}
-		// lower
-		else {
-			pFIO-&gt;FIOSETL = bitValue;
-		}
-	}
-}
-
-
-/*********************************************************************//**
- * @brief		Clear bits for FIO port in halfword accessible style
- * @param[in]	portNum		Port number, in range from 0 to 4
- * @param[in]	halfwordNum	HalfWord part number, should be 0 (lower) or 1(upper)
- * @param[in]	bitValue	Value that contains all bits in to clear,
- * 							in range from 0 to 0xFFFF.
- * @return		None
- *
- * Note:
- * - For all bits that has been set as input direction, this function will
- * not effect.
- * - For all remaining bits that are not activated in bitValue (value '0')
- * will not be effected by this function.
- **********************************************************************/
-void FIO_HalfWordClearValue(uint8_t portNum, uint8_t halfwordNum, uint16_t bitValue)
-{
-	GPIO_HalfWord_TypeDef *pFIO = FIO_HalfWordGetPointer(portNum);
-	if(pFIO != NULL) {
-		// Upper
-		if(halfwordNum) {
-			pFIO-&gt;FIOCLRU = bitValue;
-		}
-		// lower
-		else {
-			pFIO-&gt;FIOCLRL = bitValue;
-		}
-	}
-}
-
-
-/*********************************************************************//**
- * @brief		Read Current state on port pin that have input direction of GPIO
- * 				in halfword accessible style.
- * @param[in]	portNum		Port number, in range from 0 to 4
- * @param[in]	halfwordNum	HalfWord part number, should be 0 (lower) or 1(upper)
- * @return		Current value of FIO port pin of specified halfword.
- * Note: Return value contain state of each port pin (bit) on that FIO regardless
- * its direction is input or output.
- **********************************************************************/
-uint16_t FIO_HalfWordReadValue(uint8_t portNum, uint8_t halfwordNum)
-{
-	GPIO_HalfWord_TypeDef *pFIO = FIO_HalfWordGetPointer(portNum);
-	if(pFIO != NULL) {
-		// Upper
-		if(halfwordNum) {
-			return (pFIO-&gt;FIOPINU);
-		}
-		// lower
-		else {
-			return (pFIO-&gt;FIOPINL);
-		}
-	}
-	return (0);
-}
-
-
-/* FIO Byte accessible ------------------------------------------------------------ */
-
-/*********************************************************************//**
- * @brief		Set direction for FIO port in byte accessible style
- * @param[in]	portNum		Port number, in range from 0 to 4
- * @param[in]	byteNum		Byte part number, should be in range from 0 to 3
- * @param[in]	bitValue	Value that contains all bits in to set direction,
- * 							in range from 0 to 0xFF.
- * @param[in]	dir			Direction value, should be:
- * 							- 0: Input.
- * 							- 1: Output.
- * @return		None
- *
- * Note: All remaining bits that are not activated in bitValue (value '0')
- * will not be effected by this function.
- **********************************************************************/
-void FIO_ByteSetDir(uint8_t portNum, uint8_t byteNum, uint8_t bitValue, uint8_t dir)
-{
-	GPIO_Byte_TypeDef *pFIO = FIO_ByteGetPointer(portNum);
-	if(pFIO != NULL) {
-		// Output direction
-		if (dir) {
-			if ((byteNum &gt;= 0) &amp;&amp; (byteNum &lt;= 3)) {
-				pFIO-&gt;FIODIR[byteNum] |= bitValue;
-			}
-		}
-		// Input direction
-		else {
-			if ((byteNum &gt;= 0) &amp;&amp; (byteNum &lt;= 3)) {
-				pFIO-&gt;FIODIR[byteNum] &amp;= ~bitValue;
-			}
-		}
-	}
-}
-
-/*********************************************************************//**
- * @brief		Set mask value for bits in FIO port in byte accessible style
- * @param[in]	portNum		Port number, in range from 0 to 4
- * @param[in]	byteNum		Byte part number, should be in range from 0 to 3
- * @param[in]	bitValue	Value that contains all bits in to set mask,
- * 							in range from 0 to 0xFF.
- * @param[in]	maskValue	Mask value contains state value for each bit:
- * 							- 0: not mask.
- * 							- 1: mask.
- * @return		None
- *
- * Note:
- * - All remaining bits that are not activated in bitValue (value '0')
- * will not be effected by this function.
- * - After executing this function, in mask register, value '0' on each bit
- * enables an access to the corresponding physical pin via a read or write access,
- * while value '1' on bit (masked) that corresponding pin will not be changed
- * with write access and if read, will not be reflected in the updated pin.
- **********************************************************************/
-void FIO_ByteSetMask(uint8_t portNum, uint8_t byteNum, uint8_t bitValue, uint8_t maskValue)
-{
-	GPIO_Byte_TypeDef *pFIO = FIO_ByteGetPointer(portNum);
-	if(pFIO != NULL) {
-		// Mask
-		if (maskValue) {
-			if ((byteNum &gt;= 0) &amp;&amp; (byteNum &lt;= 3)) {
-				pFIO-&gt;FIOMASK[byteNum] |= bitValue;
-			}
-		}
-		// Un-mask
-		else {
-			if ((byteNum &gt;= 0) &amp;&amp; (byteNum &lt;= 3)) {
-				pFIO-&gt;FIOMASK[byteNum] &amp;= ~bitValue;
-			}
-		}
-	}
-}
-
-
-/*********************************************************************//**
- * @brief		Set bits for FIO port in byte accessible style
- * @param[in]	portNum		Port number, in range from 0 to 4
- * @param[in]	byteNum		Byte part number, should be in range from 0 to 3
- * @param[in]	bitValue	Value that contains all bits in to set,
- * 							in range from 0 to 0xFF.
- * @return		None
- *
- * Note:
- * - For all bits that has been set as input direction, this function will
- * not effect.
- * - For all remaining bits that are not activated in bitValue (value '0')
- * will not be effected by this function.
- **********************************************************************/
-void FIO_ByteSetValue(uint8_t portNum, uint8_t byteNum, uint8_t bitValue)
-{
-	GPIO_Byte_TypeDef *pFIO = FIO_ByteGetPointer(portNum);
-	if (pFIO != NULL) {
-		if ((byteNum &gt;= 0) &amp;&amp; (byteNum &lt;= 3)){
-			pFIO-&gt;FIOSET[byteNum] = bitValue;
-		}
-	}
-}
-
-
-/*********************************************************************//**
- * @brief		Clear bits for FIO port in byte accessible style
- * @param[in]	portNum		Port number, in range from 0 to 4
- * @param[in]	byteNum		Byte part number, should be in range from 0 to 3
- * @param[in]	bitValue	Value that contains all bits in to clear,
- * 							in range from 0 to 0xFF.
- * @return		None
- *
- * Note:
- * - For all bits that has been set as input direction, this function will
- * not effect.
- * - For all remaining bits that are not activated in bitValue (value '0')
- * will not be effected by this function.
- **********************************************************************/
-void FIO_ByteClearValue(uint8_t portNum, uint8_t byteNum, uint8_t bitValue)
-{
-	GPIO_Byte_TypeDef *pFIO = FIO_ByteGetPointer(portNum);
-	if (pFIO != NULL) {
-		if ((byteNum &gt;= 0) &amp;&amp; (byteNum &lt;= 3)){
-			pFIO-&gt;FIOCLR[byteNum] = bitValue;
-		}
-	}
-}
-
-
-/*********************************************************************//**
- * @brief		Read Current state on port pin that have input direction of GPIO
- * 				in byte accessible style.
- * @param[in]	portNum		Port number, in range from 0 to 4
- * @param[in]	byteNum		Byte part number, should be in range from 0 to 3
- * @return		Current value of FIO port pin of specified byte part.
- * Note: Return value contain state of each port pin (bit) on that FIO regardless
- * its direction is input or output.
- **********************************************************************/
-uint8_t FIO_ByteReadValue(uint8_t portNum, uint8_t byteNum)
-{
-	GPIO_Byte_TypeDef *pFIO = FIO_ByteGetPointer(portNum);
-	if (pFIO != NULL) {
-		if ((byteNum &gt;= 0) &amp;&amp; (byteNum &lt;= 3)){
-			return (pFIO-&gt;FIOPIN[byteNum]);
-		}
-	}
-	return (0);
-}
-
-/**
- * @}
- */
-
-#endif /* _GPIO */
-
-/**
- * @}
- */
-
-/* --------------------------------- End Of File ------------------------------ */
+/**
+ * @file	: lpc17xx_gpio.c
+ * @brief	: Contains all functions support for GPIO firmware library on LPC17xx
+ * @version	: 1.0
+ * @date	: 11. Jun. 2009
+ * @author	: HieuNguyen
+ **************************************************************************
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * products. This software is supplied &quot;AS IS&quot; without any warranties.
+ * NXP Semiconductors assumes no responsibility or liability for the
+ * use of the software, conveys no license or title under any patent,
+ * copyright, or mask work right to the product. NXP Semiconductors
+ * reserves the right to make changes in the software without
+ * notification. NXP Semiconductors also make no representation or
+ * warranty that such application will be suitable for the specified
+ * use without further testing or modification.
+ **********************************************************************/
+
+/* Peripheral group ----------------------------------------------------------- */
+/** @addtogroup GPIO
+ * @{
+ */
+
+/* Includes ------------------------------------------------------------------- */
+#include &quot;lpc17xx_gpio.h&quot;
+
+/* If this source file built with example, the LPC17xx FW library configuration
+ * file in each example directory (&quot;lpc17xx_libcfg.h&quot;) must be included,
+ * otherwise the default FW library configuration file must be included instead
+ */
+#ifdef __BUILD_WITH_EXAMPLE__
+#include &quot;lpc17xx_libcfg.h&quot;
+#else
+#include &quot;lpc17xx_libcfg_default.h&quot;
+#endif /* __BUILD_WITH_EXAMPLE__ */
+
+
+#ifdef _GPIO
+
+/* Private Functions ---------------------------------------------------------- */
+/** @addtogroup GPIO_Private_Functions
+ * @{
+ */
+/*********************************************************************//**
+ * @brief		Get pointer to GPIO peripheral due to GPIO port
+ * @param[in]	portNum		Port Number value, should be in range from 0 to 4.
+ * @return		Pointer to GPIO peripheral
+ **********************************************************************/
+static LPC_GPIO_TypeDef *GPIO_GetPointer(uint8_t portNum)
+{
+	LPC_GPIO_TypeDef *pGPIO = NULL;
+
+	switch (portNum) {
+	case 0:
+		pGPIO = LPC_GPIO0;
+		break;
+	case 1:
+		pGPIO = LPC_GPIO1;
+		break;
+	case 2:
+		pGPIO = LPC_GPIO2;
+		break;
+	case 3:
+		pGPIO = LPC_GPIO3;
+		break;
+	case 4:
+		pGPIO = LPC_GPIO4;
+		break;
+	default:
+		break;
+	}
+
+	return pGPIO;
+}
+
+/*********************************************************************//**
+ * @brief		Get pointer to FIO peripheral in halfword accessible style
+ * 				due to FIO port
+ * @param[in]	portNum		Port Number value, should be in range from 0 to 4.
+ * @return		Pointer to FIO peripheral
+ **********************************************************************/
+static GPIO_HalfWord_TypeDef *FIO_HalfWordGetPointer(uint8_t portNum)
+{
+	GPIO_HalfWord_TypeDef *pFIO = NULL;
+
+	switch (portNum) {
+	case 0:
+		pFIO = GPIO0_HalfWord;
+		break;
+	case 1:
+		pFIO = GPIO1_HalfWord;
+		break;
+	case 2:
+		pFIO = GPIO2_HalfWord;
+		break;
+	case 3:
+		pFIO = GPIO3_HalfWord;
+		break;
+	case 4:
+		pFIO = GPIO4_HalfWord;
+		break;
+	default:
+		break;
+	}
+
+	return pFIO;
+}
+
+/*********************************************************************//**
+ * @brief		Get pointer to FIO peripheral in byte accessible style
+ * 				due to FIO port
+ * @param[in]	portNum		Port Number value, should be in range from 0 to 4.
+ * @return		Pointer to FIO peripheral
+ **********************************************************************/
+static GPIO_Byte_TypeDef *FIO_ByteGetPointer(uint8_t portNum)
+{
+	GPIO_Byte_TypeDef *pFIO = NULL;
+
+	switch (portNum) {
+	case 0:
+		pFIO = GPIO0_Byte;
+		break;
+	case 1:
+		pFIO = GPIO1_Byte;
+		break;
+	case 2:
+		pFIO = GPIO2_Byte;
+		break;
+	case 3:
+		pFIO = GPIO3_Byte;
+		break;
+	case 4:
+		pFIO = GPIO4_Byte;
+		break;
+	default:
+		break;
+	}
+
+	return pFIO;
+}
+
+/**
+ * @}
+ */
+
+
+/* Public Functions ----------------------------------------------------------- */
+/** @addtogroup GPIO_Public_Functions
+ * @{
+ */
+
+
+/* GPIO ------------------------------------------------------------------------------ */
+
+/*********************************************************************//**
+ * @brief		Set Direction for GPIO port.
+ * @param[in]	portNum		Port Number value, should be in range from 0 to 4
+ * @param[in]	bitValue	Value that contains all bits to set direction,
+ * 							in range from 0 to 0xFFFFFFFF.
+ * 							example: value 0x5 to set direction for bit 0 and bit 1.
+ * @param[in]	dir			Direction value, should be:
+ * 							- 0: Input.
+ * 							- 1: Output.
+ * @return		None
+ *
+ * Note: All remaining bits that are not activated in bitValue (value '0')
+ * will not be effected by this function.
+ **********************************************************************/
+void GPIO_SetDir(uint8_t portNum, uint32_t bitValue, uint8_t dir)
+{
+	LPC_GPIO_TypeDef *pGPIO = GPIO_GetPointer(portNum);
+
+	if (pGPIO != NULL) {
+		// Enable Output
+		if (dir) {
+			pGPIO-&gt;FIODIR |= bitValue;
+		}
+		// Enable Input
+		else {
+			pGPIO-&gt;FIODIR &amp;= ~bitValue;
+		}
+	}
+}
+
+
+/*********************************************************************//**
+ * @brief		Set Value for bits that have output direction on GPIO port.
+ * @param[in]	portNum		Port number value, should be in range from 0 to 4
+ * @param[in]	bitValue	Value that contains all bits on GPIO to set,
+ * 							in range from 0 to 0xFFFFFFFF.
+ * 							example: value 0x5 to set bit 0 and bit 1.
+ * @return		None
+ *
+ * Note:
+ * - For all bits that has been set as input direction, this function will
+ * not effect.
+ * - For all remaining bits that are not activated in bitValue (value '0')
+ * will not be effected by this function.
+ **********************************************************************/
+void GPIO_SetValue(uint8_t portNum, uint32_t bitValue)
+{
+	LPC_GPIO_TypeDef *pGPIO = GPIO_GetPointer(portNum);
+
+	if (pGPIO != NULL) {
+		pGPIO-&gt;FIOSET = bitValue;
+	}
+}
+
+/*********************************************************************//**
+ * @brief		Clear Value for bits that have output direction on GPIO port.
+ * @param[in]	portNum		Port number value, should be in range from 0 to 4
+ * @param[in]	bitValue	Value that contains all bits on GPIO to clear,
+ * 							in range from 0 to 0xFFFFFFFF.
+ * 							example: value 0x5 to clear bit 0 and bit 1.
+ * @return		None
+ *
+ * Note:
+ * - For all bits that has been set as input direction, this function will
+ * not effect.
+ * - For all remaining bits that are not activated in bitValue (value '0')
+ * will not be effected by this function.
+ **********************************************************************/
+void GPIO_ClearValue(uint8_t portNum, uint32_t bitValue)
+{
+	LPC_GPIO_TypeDef *pGPIO = GPIO_GetPointer(portNum);
+
+	if (pGPIO != NULL) {
+		pGPIO-&gt;FIOCLR = bitValue;
+	}
+}
+
+/*********************************************************************//**
+ * @brief		Read Current state on port pin that have input direction of GPIO
+ * @param[in]	portNum		Port number to read value, in range from 0 to 4
+ * @return		Current value of GPIO port.
+ *
+ * Note: Return value contain state of each port pin (bit) on that GPIO regardless
+ * its direction is input or output.
+ **********************************************************************/
+uint32_t GPIO_ReadValue(uint8_t portNum)
+{
+	LPC_GPIO_TypeDef *pGPIO = GPIO_GetPointer(portNum);
+
+	if (pGPIO != NULL) {
+		return pGPIO-&gt;FIOPIN;
+	}
+
+	return (0);
+}
+
+/* FIO word accessible ----------------------------------------------------------------- */
+/* Stub function for FIO (word-accessible) style */
+
+/**
+ * @brief The same with GPIO_SetDir()
+ */
+void FIO_SetDir(uint8_t portNum, uint32_t bitValue, uint8_t dir)
+{
+	GPIO_SetDir(portNum, bitValue, dir);
+}
+
+/**
+ * @brief The same with GPIO_SetValue()
+ */
+void FIO_SetValue(uint8_t portNum, uint32_t bitValue)
+{
+	GPIO_SetValue(portNum, bitValue);
+}
+
+/**
+ * @brief The same with GPIO_ClearValue()
+ */
+void FIO_ClearValue(uint8_t portNum, uint32_t bitValue)
+{
+	GPIO_ClearValue(portNum, bitValue);
+}
+
+/**
+ * @brief The same with GPIO_ReadValue()
+ */
+uint32_t FIO_ReadValue(uint8_t portNum)
+{
+	return (GPIO_ReadValue(portNum));
+}
+
+
+/*********************************************************************//**
+ * @brief		Set mask value for bits in FIO port
+ * @param[in]	portNum		Port number, in range from 0 to 4
+ * @param[in]	bitValue	Value that contains all bits in to set,
+ * 							in range from 0 to 0xFFFFFFFF.
+ * @param[in]	maskValue	Mask value contains state value for each bit:
+ * 							- 0: not mask.
+ * 							- 1: mask.
+ * @return		None
+ *
+ * Note:
+ * - All remaining bits that are not activated in bitValue (value '0')
+ * will not be effected by this function.
+ * - After executing this function, in mask register, value '0' on each bit
+ * enables an access to the corresponding physical pin via a read or write access,
+ * while value '1' on bit (masked) that corresponding pin will not be changed
+ * with write access and if read, will not be reflected in the updated pin.
+ **********************************************************************/
+void FIO_SetMask(uint8_t portNum, uint32_t bitValue, uint8_t maskValue)
+{
+	LPC_GPIO_TypeDef *pFIO = GPIO_GetPointer(portNum);
+	if(pFIO != NULL) {
+		// Mask
+		if (maskValue){
+			pFIO-&gt;FIOMASK |= bitValue;
+		}
+		// Un-mask
+		else {
+			pFIO-&gt;FIOMASK &amp;= ~bitValue;
+		}
+	}
+}
+
+
+/* FIO halfword accessible ------------------------------------------------------------- */
+
+/*********************************************************************//**
+ * @brief		Set direction for FIO port in halfword accessible style
+ * @param[in]	portNum		Port number, in range from 0 to 4
+ * @param[in]	halfwordNum	HalfWord part number, should be 0 (lower) or 1(upper)
+ * @param[in]	bitValue	Value that contains all bits in to set direction,
+ * 							in range from 0 to 0xFFFF.
+ * @param[in]	dir			Direction value, should be:
+ * 							- 0: Input.
+ * 							- 1: Output.
+ * @return		None
+ *
+ * Note: All remaining bits that are not activated in bitValue (value '0')
+ * will not be effected by this function.
+ **********************************************************************/
+void FIO_HalfWordSetDir(uint8_t portNum, uint8_t halfwordNum, uint16_t bitValue, uint8_t dir)
+{
+	GPIO_HalfWord_TypeDef *pFIO = FIO_HalfWordGetPointer(portNum);
+	if(pFIO != NULL) {
+		// Output direction
+		if (dir) {
+			// Upper
+			if(halfwordNum) {
+				pFIO-&gt;FIODIRU |= bitValue;
+			}
+			// lower
+			else {
+				pFIO-&gt;FIODIRL |= bitValue;
+			}
+		}
+		// Input direction
+		else {
+			// Upper
+			if(halfwordNum) {
+				pFIO-&gt;FIODIRU &amp;= ~bitValue;
+			}
+			// lower
+			else {
+				pFIO-&gt;FIODIRL &amp;= ~bitValue;
+			}
+		}
+	}
+}
+
+
+/*********************************************************************//**
+ * @brief		Set mask value for bits in FIO port in halfword accessible style
+ * @param[in]	portNum		Port number, in range from 0 to 4
+ * @param[in]	halfwordNum	HalfWord part number, should be 0 (lower) or 1(upper)
+ * @param[in]	bitValue	Value that contains all bits in to set,
+ * 							in range from 0 to 0xFFFF.
+ * @param[in]	maskValue	Mask value contains state value for each bit:
+ * 					- 0: not mask.
+ * 					- 1: mask.
+ * @return		None
+ *
+ * Note:
+ * - All remaining bits that are not activated in bitValue (value '0')
+ * will not be effected by this function.
+ * - After executing this function, in mask register, value '0' on each bit
+ * enables an access to the corresponding physical pin via a read or write access,
+ * while value '1' on bit (masked) that corresponding pin will not be changed
+ * with write access and if read, will not be reflected in the updated pin.
+ **********************************************************************/
+void FIO_HalfWordSetMask(uint8_t portNum, uint8_t halfwordNum, uint16_t bitValue, uint8_t maskValue)
+{
+	GPIO_HalfWord_TypeDef *pFIO = FIO_HalfWordGetPointer(portNum);
+	if(pFIO != NULL) {
+		// Mask
+		if (maskValue){
+			// Upper
+			if(halfwordNum) {
+				pFIO-&gt;FIOMASKU |= bitValue;
+			}
+			// lower
+			else {
+				pFIO-&gt;FIOMASKL |= bitValue;
+			}
+		}
+		// Un-mask
+		else {
+			// Upper
+			if(halfwordNum) {
+				pFIO-&gt;FIOMASKU &amp;= ~bitValue;
+			}
+			// lower
+			else {
+				pFIO-&gt;FIOMASKL &amp;= ~bitValue;
+			}
+		}
+	}
+}
+
+
+/*********************************************************************//**
+ * @brief		Set bits for FIO port in halfword accessible style
+ * @param[in]	portNum		Port number, in range from 0 to 4
+ * @param[in]	halfwordNum	HalfWord part number, should be 0 (lower) or 1(upper)
+ * @param[in]	bitValue	Value that contains all bits in to set,
+ * 							in range from 0 to 0xFFFF.
+ * @return		None
+ *
+ * Note:
+ * - For all bits that has been set as input direction, this function will
+ * not effect.
+ * - For all remaining bits that are not activated in bitValue (value '0')
+ * will not be effected by this function.
+ **********************************************************************/
+void FIO_HalfWordSetValue(uint8_t portNum, uint8_t halfwordNum, uint16_t bitValue)
+{
+	GPIO_HalfWord_TypeDef *pFIO = FIO_HalfWordGetPointer(portNum);
+	if(pFIO != NULL) {
+		// Upper
+		if(halfwordNum) {
+			pFIO-&gt;FIOSETU = bitValue;
+		}
+		// lower
+		else {
+			pFIO-&gt;FIOSETL = bitValue;
+		}
+	}
+}
+
+
+/*********************************************************************//**
+ * @brief		Clear bits for FIO port in halfword accessible style
+ * @param[in]	portNum		Port number, in range from 0 to 4
+ * @param[in]	halfwordNum	HalfWord part number, should be 0 (lower) or 1(upper)
+ * @param[in]	bitValue	Value that contains all bits in to clear,
+ * 							in range from 0 to 0xFFFF.
+ * @return		None
+ *
+ * Note:
+ * - For all bits that has been set as input direction, this function will
+ * not effect.
+ * - For all remaining bits that are not activated in bitValue (value '0')
+ * will not be effected by this function.
+ **********************************************************************/
+void FIO_HalfWordClearValue(uint8_t portNum, uint8_t halfwordNum, uint16_t bitValue)
+{
+	GPIO_HalfWord_TypeDef *pFIO = FIO_HalfWordGetPointer(portNum);
+	if(pFIO != NULL) {
+		// Upper
+		if(halfwordNum) {
+			pFIO-&gt;FIOCLRU = bitValue;
+		}
+		// lower
+		else {
+			pFIO-&gt;FIOCLRL = bitValue;
+		}
+	}
+}
+
+
+/*********************************************************************//**
+ * @brief		Read Current state on port pin that have input direction of GPIO
+ * 				in halfword accessible style.
+ * @param[in]	portNum		Port number, in range from 0 to 4
+ * @param[in]	halfwordNum	HalfWord part number, should be 0 (lower) or 1(upper)
+ * @return		Current value of FIO port pin of specified halfword.
+ * Note: Return value contain state of each port pin (bit) on that FIO regardless
+ * its direction is input or output.
+ **********************************************************************/
+uint16_t FIO_HalfWordReadValue(uint8_t portNum, uint8_t halfwordNum)
+{
+	GPIO_HalfWord_TypeDef *pFIO = FIO_HalfWordGetPointer(portNum);
+	if(pFIO != NULL) {
+		// Upper
+		if(halfwordNum) {
+			return (pFIO-&gt;FIOPINU);
+		}
+		// lower
+		else {
+			return (pFIO-&gt;FIOPINL);
+		}
+	}
+	return (0);
+}
+
+
+/* FIO Byte accessible ------------------------------------------------------------ */
+
+/*********************************************************************//**
+ * @brief		Set direction for FIO port in byte accessible style
+ * @param[in]	portNum		Port number, in range from 0 to 4
+ * @param[in]	byteNum		Byte part number, should be in range from 0 to 3
+ * @param[in]	bitValue	Value that contains all bits in to set direction,
+ * 							in range from 0 to 0xFF.
+ * @param[in]	dir			Direction value, should be:
+ * 							- 0: Input.
+ * 							- 1: Output.
+ * @return		None
+ *
+ * Note: All remaining bits that are not activated in bitValue (value '0')
+ * will not be effected by this function.
+ **********************************************************************/
+void FIO_ByteSetDir(uint8_t portNum, uint8_t byteNum, uint8_t bitValue, uint8_t dir)
+{
+	GPIO_Byte_TypeDef *pFIO = FIO_ByteGetPointer(portNum);
+	if(pFIO != NULL) {
+		// Output direction
+		if (dir) {
+			if ((byteNum &gt;= 0) &amp;&amp; (byteNum &lt;= 3)) {
+				pFIO-&gt;FIODIR[byteNum] |= bitValue;
+			}
+		}
+		// Input direction
+		else {
+			if ((byteNum &gt;= 0) &amp;&amp; (byteNum &lt;= 3)) {
+				pFIO-&gt;FIODIR[byteNum] &amp;= ~bitValue;
+			}
+		}
+	}
+}
+
+/*********************************************************************//**
+ * @brief		Set mask value for bits in FIO port in byte accessible style
+ * @param[in]	portNum		Port number, in range from 0 to 4
+ * @param[in]	byteNum		Byte part number, should be in range from 0 to 3
+ * @param[in]	bitValue	Value that contains all bits in to set mask,
+ * 							in range from 0 to 0xFF.
+ * @param[in]	maskValue	Mask value contains state value for each bit:
+ * 							- 0: not mask.
+ * 							- 1: mask.
+ * @return		None
+ *
+ * Note:
+ * - All remaining bits that are not activated in bitValue (value '0')
+ * will not be effected by this function.
+ * - After executing this function, in mask register, value '0' on each bit
+ * enables an access to the corresponding physical pin via a read or write access,
+ * while value '1' on bit (masked) that corresponding pin will not be changed
+ * with write access and if read, will not be reflected in the updated pin.
+ **********************************************************************/
+void FIO_ByteSetMask(uint8_t portNum, uint8_t byteNum, uint8_t bitValue, uint8_t maskValue)
+{
+	GPIO_Byte_TypeDef *pFIO = FIO_ByteGetPointer(portNum);
+	if(pFIO != NULL) {
+		// Mask
+		if (maskValue) {
+			if ((byteNum &gt;= 0) &amp;&amp; (byteNum &lt;= 3)) {
+				pFIO-&gt;FIOMASK[byteNum] |= bitValue;
+			}
+		}
+		// Un-mask
+		else {
+			if ((byteNum &gt;= 0) &amp;&amp; (byteNum &lt;= 3)) {
+				pFIO-&gt;FIOMASK[byteNum] &amp;= ~bitValue;
+			}
+		}
+	}
+}
+
+
+/*********************************************************************//**
+ * @brief		Set bits for FIO port in byte accessible style
+ * @param[in]	portNum		Port number, in range from 0 to 4
+ * @param[in]	byteNum		Byte part number, should be in range from 0 to 3
+ * @param[in]	bitValue	Value that contains all bits in to set,
+ * 							in range from 0 to 0xFF.
+ * @return		None
+ *
+ * Note:
+ * - For all bits that has been set as input direction, this function will
+ * not effect.
+ * - For all remaining bits that are not activated in bitValue (value '0')
+ * will not be effected by this function.
+ **********************************************************************/
+void FIO_ByteSetValue(uint8_t portNum, uint8_t byteNum, uint8_t bitValue)
+{
+	GPIO_Byte_TypeDef *pFIO = FIO_ByteGetPointer(portNum);
+	if (pFIO != NULL) {
+		if ((byteNum &gt;= 0) &amp;&amp; (byteNum &lt;= 3)){
+			pFIO-&gt;FIOSET[byteNum] = bitValue;
+		}
+	}
+}
+
+
+/*********************************************************************//**
+ * @brief		Clear bits for FIO port in byte accessible style
+ * @param[in]	portNum		Port number, in range from 0 to 4
+ * @param[in]	byteNum		Byte part number, should be in range from 0 to 3
+ * @param[in]	bitValue	Value that contains all bits in to clear,
+ * 							in range from 0 to 0xFF.
+ * @return		None
+ *
+ * Note:
+ * - For all bits that has been set as input direction, this function will
+ * not effect.
+ * - For all remaining bits that are not activated in bitValue (value '0')
+ * will not be effected by this function.
+ **********************************************************************/
+void FIO_ByteClearValue(uint8_t portNum, uint8_t byteNum, uint8_t bitValue)
+{
+	GPIO_Byte_TypeDef *pFIO = FIO_ByteGetPointer(portNum);
+	if (pFIO != NULL) {
+		if ((byteNum &gt;= 0) &amp;&amp; (byteNum &lt;= 3)){
+			pFIO-&gt;FIOCLR[byteNum] = bitValue;
+		}
+	}
+}
+
+
+/*********************************************************************//**
+ * @brief		Read Current state on port pin that have input direction of GPIO
+ * 				in byte accessible style.
+ * @param[in]	portNum		Port number, in range from 0 to 4
+ * @param[in]	byteNum		Byte part number, should be in range from 0 to 3
+ * @return		Current value of FIO port pin of specified byte part.
+ * Note: Return value contain state of each port pin (bit) on that FIO regardless
+ * its direction is input or output.
+ **********************************************************************/
+uint8_t FIO_ByteReadValue(uint8_t portNum, uint8_t byteNum)
+{
+	GPIO_Byte_TypeDef *pFIO = FIO_ByteGetPointer(portNum);
+	if (pFIO != NULL) {
+		if ((byteNum &gt;= 0) &amp;&amp; (byteNum &lt;= 3)){
+			return (pFIO-&gt;FIOPIN[byteNum]);
+		}
+	}
+	return (0);
+}
+
+/**
+ * @}
+ */
+
+#endif /* _GPIO */
+
+/**
+ * @}
+ */
+
+/* --------------------------------- End Of File ------------------------------ */


Property changes on: trunk/src/platform/lpc17xx/drivers/src/lpc17xx_gpio.c
___________________________________________________________________
Deleted: svn:executable
   - *

Modified: trunk/src/platform/lpc17xx/drivers/src/lpc17xx_i2c.c
===================================================================
--- trunk/src/platform/lpc17xx/drivers/src/lpc17xx_i2c.c	2010-06-28 21:53:59 UTC (rev 759)
+++ trunk/src/platform/lpc17xx/drivers/src/lpc17xx_i2c.c	2010-07-12 20:56:54 UTC (rev 760)
@@ -1,1317 +1,1313 @@
-/**
- * @file	: lpc17xx_i2c.c
- * @brief	: Contains all functions support for I2C firmware library on LPC17xx
- * @version	: 1.0
- * @date	: 9. April. 2009
- * @author	: HieuNguyen
- *----------------------------------------------------------------------------
- * Software that is described herein is for illustrative purposes only
- * which provides customers with programming information regarding the
- * products. This software is supplied &quot;AS IS&quot; without any warranties.
- * NXP Semiconductors assumes no responsibility or liability for the
- * use of the software, conveys no license or title under any patent,
- * copyright, or mask work right to the product. NXP Semiconductors
- * reserves the right to make changes in the software without
- * notification. NXP Semiconductors also make no representation or
- * warranty that such application will be suitable for the specified
- * use without further testing or modification.
- **********************************************************************/
-
-/* Peripheral group ----------------------------------------------------------- */
-/** @addtogroup I2C
- * @{
- */
-
-/* Includes ------------------------------------------------------------------- */
-#include &quot;lpc17xx_i2c.h&quot;
-#include &quot;lpc17xx_clkpwr.h&quot;
-#include &quot;lpc17xx_pinsel.h&quot;
-
-
-/* If this source file built with example, the LPC17xx FW library configuration
- * file in each example directory (&quot;lpc17xx_libcfg.h&quot;) must be included,
- * otherwise the default FW library configuration file must be included instead
- */
-#ifdef __BUILD_WITH_EXAMPLE__
-#include &quot;lpc17xx_libcfg.h&quot;
-#else
-#include &quot;lpc17xx_libcfg_default.h&quot;
-#endif /* __BUILD_WITH_EXAMPLE__ */
-
-
-#ifdef _I2C
-
-
-/* Private Types -------------------------------------------------------------- */
-/** @defgroup I2C_Private_Types
- * @{
- */
-
-/**
- * @brief I2C device configuration structure type
- */
-typedef struct
-{
-  uint32_t      txrx_setup; 						/* Transmission setup */
-  int32_t		dir;								/* Current direction phase, 0 - write, 1 - read */
-  void		(*inthandler)(I2C_TypeDef *I2Cx);   	/* Transmission interrupt handler */
-} I2C_CFG_T;
-
-/**
- * @}
- */
-
-/* Private Variables ---------------------------------------------------------- */
-/** @defgroup I2C_Private_Variables
- * @{
- */
-
-/* I2C driver data for I2C0, I2C1 and I2C2 */
-static I2C_CFG_T i2cdat[3];
-
-
-/**
- * @}
- */
-
-
-/* Private Functions ---------------------------------------------------------- */
-/** @defgroup I2C_Private_Functions
- * @{
- */
-
-/* Generate a start condition on I2C bus (in master mode only) */
-static uint32_t I2C_Start (I2C_TypeDef *I2Cx);
-
-/* Generate a stop condition on I2C bus (in master mode only) */
-static void I2C_Stop (I2C_TypeDef *I2Cx);
-
-/* I2C send byte subroutine */
-static uint32_t I2C_SendByte (I2C_TypeDef *I2Cx, uint8_t databyte);
-
-/* I2C get byte subroutine */
-static uint32_t I2C_GetByte (I2C_TypeDef *I2Cx, uint8_t *retdat, Bool ack);
-
-/* I2C interrupt master handler */
-void I2C_MasterHandler (I2C_TypeDef *I2Cx);
-
-/* I2C interrupt master handler */
-void I2C_SlaveHandler (I2C_TypeDef *I2Cx);
-
-/* Enable interrupt for I2C device */
-void I2C_IntCmd (I2C_TypeDef *I2Cx, Bool NewState);
-
-/*--------------------------------------------------------------------------------*/
-
-/**
- * @brief Convert from I2C peripheral to number
- */
-static int32_t I2C_getNum(I2C_TypeDef *I2Cx){
-	if (I2Cx == I2C0) {
-		return (0);
-	} else if (I2Cx == I2C1) {
-		return (1);
-	} else if (I2Cx == I2C2) {
-		return (2);
-	}
-	return (-1);
-}
-
-/***********************************************************************
- * Function: I2C_Start
- * Purpose: Generate a start condition on I2C bus (in master mode only)
- * Parameters:
- *     i2cdev: Pointer to I2C register
- *     blocking: blocking or none blocking mode
- * Returns: value of I2C status register after generate a start condition
- **********************************************************************/
-static uint32_t I2C_Start (I2C_TypeDef *I2Cx)
-{
-	I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_SIC;
-	I2Cx-&gt;I2CONSET = I2C_I2CONSET_STA;
-
-	// Wait for complete
-	while (!(I2Cx-&gt;I2CONSET &amp; I2C_I2CONSET_SI));
-	I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_STAC;
-	return (I2Cx-&gt;I2STAT &amp; I2C_STAT_CODE_BITMASK);
-}
-
-
-/***********************************************************************
- * Function: I2C_Stop
- * Purpose: Generate a stop condition on I2C bus (in master mode only)
- * Parameters:
- *     I2Cx: Pointer to I2C register
- * Returns: None
- **********************************************************************/
-static void I2C_Stop (I2C_TypeDef *I2Cx)
-{
-
-	/* Make sure start bit is not active */
-	if (I2Cx-&gt;I2CONSET &amp; I2C_I2CONSET_STA)
-	{
-		I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_STAC;
-	}
-	I2Cx-&gt;I2CONSET = I2C_I2CONSET_STO;
-	I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_SIC;
-}
-
-
-/***********************************************************************
- * Function: I2C_SendByte
- * Purpose: Send a byte
- * Parameters:
- *     I2Cx: Pointer to I2C register
- * Returns: value of I2C status register after sending
- **********************************************************************/
-static uint32_t I2C_SendByte (I2C_TypeDef *I2Cx, uint8_t databyte)
-{
-	/* Make sure start bit is not active */
-	if (I2Cx-&gt;I2CONSET &amp; I2C_I2CONSET_STA)
-	{
-		I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_STAC;
-	}
-	I2Cx-&gt;I2DAT = databyte &amp; I2C_I2DAT_BITMASK;
-	I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_SIC;
-
-	while (!(I2Cx-&gt;I2CONSET &amp; I2C_I2CONSET_SI));
-	return (I2Cx-&gt;I2STAT &amp; I2C_STAT_CODE_BITMASK);
-}
-
-
-/***********************************************************************
- * Function: I2C_GetByte
- * Purpose: Get a byte
- * Parameters:
- *     I2Cx: Pointer to I2C register
- * Returns: value of I2C status register after receiving
- **********************************************************************/
-static uint32_t I2C_GetByte (I2C_TypeDef *I2Cx, uint8_t *retdat, Bool ack)
-{
-	if (ack == TRUE)
-	{
-		I2Cx-&gt;I2CONSET = I2C_I2CONSET_AA;
-	}
-	else
-	{
-		I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_AAC;
-	}
-	I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_SIC;
-
-	while (!(I2Cx-&gt;I2CONSET &amp; I2C_I2CONSET_SI));
-	*retdat = (uint8_t) (I2Cx-&gt;I2DAT &amp; I2C_I2DAT_BITMASK);
-	return (I2Cx-&gt;I2STAT &amp; I2C_STAT_CODE_BITMASK);
-}
-
-
-
-/*********************************************************************//**
- * @brief 		Enable/Disable interrupt for I2C peripheral
- * @param[in]	I2Cx	I2C peripheral selected, should be I2C0, I2C1 or I2C2
- * @param[in]	NewState	New State of I2C peripheral interrupt in NVIC core
- * 							should be:
- * 							- ENABLE: enable interrupt for this I2C peripheral
- * 							- DISABLE: disable interrupt for this I2C peripheral
- * @return 		None
- **********************************************************************/
-void I2C_IntCmd (I2C_TypeDef *I2Cx, Bool NewState)
-{
-	if (NewState)
-	{
-		if(I2Cx == I2C0)
-		{
-			NVIC_EnableIRQ(I2C0_IRQn);
-		}
-		else if (I2Cx == I2C1)
-		{
-			NVIC_EnableIRQ(I2C1_IRQn);
-		}
-		else if (I2Cx == I2C2)
-		{
-			NVIC_EnableIRQ(I2C2_IRQn);
-		}
-	}
-	else
-	{
-		if(I2Cx == I2C0)
-		{
-			NVIC_DisableIRQ(I2C0_IRQn);
-		}
-		else if (I2Cx == I2C1)
-		{
-			NVIC_DisableIRQ(I2C1_IRQn);
-		}
-		else if (I2Cx == I2C2)
-		{
-			NVIC_DisableIRQ(I2C2_IRQn);
-		}
-	}
-    return;
-}
-
-
-/*********************************************************************//**
- * @brief 		General Master Interrupt handler for I2C peripheral
- * @param[in]	I2Cx	I2C peripheral selected, should be I2C0, I2C1 or I2C2
- * @return 		None
- **********************************************************************/
-void I2C_MasterHandler (I2C_TypeDef  *I2Cx)
-{
-	int32_t tmp;
-	uint8_t returnCode;
-	I2C_M_SETUP_Type *txrx_setup;
-
-	tmp = I2C_getNum(I2Cx);
-	txrx_setup = (I2C_M_SETUP_Type *) i2cdat[tmp].txrx_setup;
-
-	returnCode = (I2Cx-&gt;I2STAT &amp; I2C_STAT_CODE_BITMASK);
-	// Save current status
-	txrx_setup-&gt;status = returnCode;
-	// there's no relevant information
-	if (returnCode == I2C_I2STAT_NO_INF){
-		I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_SIC;
-		return;
-	}
-
-	/* ----------------------------- TRANSMIT PHASE --------------------------*/
-	if (i2cdat[tmp].dir == 0){
-		switch (returnCode)
-		{
-		/* A start/repeat start condition has been transmitted -------------------*/
-		case I2C_I2STAT_M_TX_START:
-		case I2C_I2STAT_M_TX_RESTART:
-			I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_STAC;
-			/*
-			 * If there's any transmit data, then start to
-			 * send SLA+W right now, otherwise check whether if there's
-			 * any receive data for next state.
-			 */
-			if ((txrx_setup-&gt;tx_data != NULL) &amp;&amp; (txrx_setup-&gt;tx_length != 0)){
-				I2Cx-&gt;I2DAT = (txrx_setup-&gt;sl_addr7bit &lt;&lt; 1);
-				I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_SIC;
-			} else {
-				goto next_stage;
-			}
-			break;
-
-		/* SLA+W has been transmitted, ACK has been received ----------------------*/
-		case I2C_I2STAT_M_TX_SLAW_ACK:
-		/* Data has been transmitted, ACK has been received */
-		case I2C_I2STAT_M_TX_DAT_ACK:
-			/* Send more data */
-			if ((txrx_setup-&gt;tx_count &lt; txrx_setup-&gt;tx_length) \
-					&amp;&amp; (txrx_setup-&gt;tx_data != NULL)){
-				I2Cx-&gt;I2DAT =  *(uint8_t *)(txrx_setup-&gt;tx_data + txrx_setup-&gt;tx_count);
-				txrx_setup-&gt;tx_count++;
-				I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_SIC;
-			}
-			// no more data, switch to next stage
-			else {
-next_stage:
-				// change direction
-				i2cdat[tmp].dir = 1;
-				// Check if any data to receive
-				if ((txrx_setup-&gt;rx_length != 0) &amp;&amp; (txrx_setup-&gt;rx_data != NULL)){
-						// check whether if we need to issue an repeat start
-						if ((txrx_setup-&gt;tx_length != 0) &amp;&amp; (txrx_setup-&gt;tx_data != NULL)){
-							// Send out an repeat start command
-							I2Cx-&gt;I2CONSET = I2C_I2CONSET_STA;
-							I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_AAC | I2C_I2CONCLR_SIC;
-						}
-						// Don't need issue an repeat start, just goto send SLA+R
-						else {
-							goto send_slar;
-						}
-				}
-				// no more data send, the go to end stage now
-				else {
-					// success, goto end stage
-					txrx_setup-&gt;status |= I2C_SETUP_STATUS_DONE;
-					goto end_stage;
-				}
-			}
-			break;
-
-		/* SLA+W has been transmitted, NACK has been received ----------------------*/
-		case I2C_I2STAT_M_TX_SLAW_NACK:
-		/* Data has been transmitted, NACK has been received -----------------------*/
-		case I2C_I2STAT_M_TX_DAT_NACK:
-			// update status
-			txrx_setup-&gt;status |= I2C_SETUP_STATUS_NOACKF;
-			goto retry;
-			break;
-		/* Arbitration lost in SLA+R/W or Data bytes -------------------------------*/
-		case I2C_I2STAT_M_TX_ARB_LOST:
-			// update status
-			txrx_setup-&gt;status |= I2C_SETUP_STATUS_ARBF;
-		default:
-			goto retry;
-			break;
-		}
-	}
-
-	/* ----------------------------- RECEIVE PHASE --------------------------*/
-	else if (i2cdat[tmp].dir == 1){
-		switch (returnCode){
-			/* A start/repeat start condition has been transmitted ---------------------*/
-		case I2C_I2STAT_M_RX_START:
-		case I2C_I2STAT_M_RX_RESTART:
-			I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_STAC;
-			/*
-			 * If there's any receive data, then start to
-			 * send SLA+R right now, otherwise check whether if there's
-			 * any receive data for end of state.
-			 */
-			if ((txrx_setup-&gt;rx_data != NULL) &amp;&amp; (txrx_setup-&gt;rx_length != 0)){
-send_slar:
-				I2Cx-&gt;I2DAT = (txrx_setup-&gt;sl_addr7bit &lt;&lt; 1) | 0x01;
-				I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_SIC;
-			} else {
-				// Success, goto end stage
-				txrx_setup-&gt;status |= I2C_SETUP_STATUS_DONE;
-				goto end_stage;
-			}
-			break;
-
-		/* SLA+R has been transmitted, ACK has been received -----------------*/
-		case I2C_I2STAT_M_RX_SLAR_ACK:
-			if (txrx_setup-&gt;rx_count &lt; (txrx_setup-&gt;rx_length - 1)) {
-				/*Data will be received,  ACK will be return*/
-				I2Cx-&gt;I2CONSET = I2C_I2CONSET_AA;
-			}
-			else {
-				/*Last data will be received,  NACK will be return*/
-				I2Cx-&gt;I2CONCLR = I2C_I2CONSET_AA;
-			}
-			I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_SIC;
-			break;
-
-		/* Data has been received, ACK has been returned ----------------------*/
-		case I2C_I2STAT_M_RX_DAT_ACK:
-			// Note save data and increase counter first, then check later
-			/* Save data  */
-			if ((txrx_setup-&gt;rx_data != NULL) &amp;&amp; (txrx_setup-&gt;rx_count &lt; txrx_setup-&gt;rx_length)){
-				*(uint8_t *)(txrx_setup-&gt;rx_data + txrx_setup-&gt;rx_count) = (I2Cx-&gt;I2DAT &amp; I2C_I2DAT_BITMASK);
-				txrx_setup-&gt;rx_count++;
-			}
-			if (txrx_setup-&gt;rx_count &lt; (txrx_setup-&gt;rx_length - 1)) {
-				/*Data will be received,  ACK will be return*/
-				I2Cx-&gt;I2CONSET = I2C_I2CONSET_AA;
-			}
-			else {
-				/*Last data will be received,  NACK will be return*/
-				I2Cx-&gt;I2CONCLR = I2C_I2CONSET_AA;
-			}
-
-			I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_SIC;
-			break;
-
-		/* Data has been received, NACK has been return -------------------------*/
-		case I2C_I2STAT_M_RX_DAT_NACK:
-			/* Save the last data */
-			if ((txrx_setup-&gt;rx_data != NULL) &amp;&amp; (txrx_setup-&gt;rx_count &lt; txrx_setup-&gt;rx_length)){
-				*(uint8_t *)(txrx_setup-&gt;rx_data + txrx_setup-&gt;rx_count) = (I2Cx-&gt;I2DAT &amp; I2C_I2DAT_BITMASK);
-				txrx_setup-&gt;rx_count++;
-			}
-			// success, go to end stage
-			txrx_setup-&gt;status |= I2C_SETUP_STATUS_DONE;
-			goto end_stage;
-			break;
-
-		/* SLA+R has been transmitted, NACK has been received ------------------*/
-		case I2C_I2STAT_M_RX_SLAR_NACK:
-			// update status
-			txrx_setup-&gt;status |= I2C_SETUP_STATUS_NOACKF;
-			goto retry;
-			break;
-
-		/* Arbitration lost ----------------------------------------------------*/
-		case I2C_I2STAT_M_RX_ARB_LOST:
-			// update status
-			txrx_setup-&gt;status |= I2C_SETUP_STATUS_ARBF;
-		default:
-retry:
-			// check if retransmission is available
-			if (txrx_setup-&gt;retransmissions_count &lt; txrx_setup-&gt;retransmissions_max){
-				// Clear tx count
-				txrx_setup-&gt;tx_count = 0;
-				I2Cx-&gt;I2CONSET = I2C_I2CONSET_STA;
-				I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_AAC | I2C_I2CONCLR_SIC;
-				txrx_setup-&gt;retransmissions_count++;
-			}
-			// End of stage
-			else {
-end_stage:
-				// Disable interrupt
-				I2C_IntCmd(I2Cx, 0);
-				// Send stop
-				I2C_Stop(I2Cx);
-				// Call callback if installed
-				if (txrx_setup-&gt;callback != NULL){
-					txrx_setup-&gt;callback();
-				}
-			}
-			break;
-		}
-	}
-}
-
-
-/*********************************************************************//**
- * @brief 		General Slave Interrupt handler for I2C peripheral
- * @param[in]	I2Cx	I2C peripheral selected, should be I2C0, I2C1 or I2C2
- * @return 		None
- **********************************************************************/
-void I2C_SlaveHandler (I2C_TypeDef  *I2Cx)
-{
-	int32_t tmp;
-	uint8_t returnCode;
-	I2C_S_SETUP_Type *txrx_setup;
-	uint32_t timeout;
-
-	tmp = I2C_getNum(I2Cx);
-	txrx_setup = (I2C_S_SETUP_Type *) i2cdat[tmp].txrx_setup;
-
-	returnCode = (I2Cx-&gt;I2STAT &amp; I2C_STAT_CODE_BITMASK);
-	// Save current status
-	txrx_setup-&gt;status = returnCode;
-	// there's no relevant information
-	if (returnCode == I2C_I2STAT_NO_INF){
-		I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_SIC;
-		return;
-	}
-
-
-	switch (returnCode)
-	{
-
-	/* No status information */
-	case I2C_I2STAT_NO_INF:
-		I2Cx-&gt;I2CONSET = I2C_I2CONSET_AA;
-		I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_SIC;
-		break;
-
-	/* Reading phase -------------------------------------------------------- */
-	/* Own SLA+R has been received, ACK has been returned */
-	case I2C_I2STAT_S_RX_SLAW_ACK:
-	/* General call address has been received, ACK has been returned */
-	case I2C_I2STAT_S_RX_GENCALL_ACK:
-		I2Cx-&gt;I2CONSET = I2C_I2CONSET_AA;
-		I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_SIC;
-		break;
-
-	/* Previously addressed with own SLA;
-	 * DATA byte has been received;
-	 * ACK has been returned */
-	case I2C_I2STAT_S_RX_PRE_SLA_DAT_ACK:
-	/* DATA has been received, ACK hasn been return */
-	case I2C_I2STAT_S_RX_PRE_GENCALL_DAT_ACK:
-		/*
-		 * All data bytes that over-flow the specified receive
-		 * data length, just ignore them.
-		 */
-		if ((txrx_setup-&gt;rx_count &lt; txrx_setup-&gt;rx_length) \
-				&amp;&amp; (txrx_setup-&gt;rx_data != NULL)){
-			*(uint8_t *)(txrx_setup-&gt;rx_data + txrx_setup-&gt;rx_count) = (uint8_t)I2Cx-&gt;I2DAT;
-			txrx_setup-&gt;rx_count++;
-		}
-		I2Cx-&gt;I2CONSET = I2C_I2CONSET_AA;
-		I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_SIC;
-		break;
-
-	/* Previously addressed with own SLA;
-	 * DATA byte has been received;
-	 * NOT ACK has been returned */
-	case I2C_I2STAT_S_RX_PRE_SLA_DAT_NACK:
-	/* DATA has been received, NOT ACK has been returned */
-	case I2C_I2STAT_S_RX_PRE_GENCALL_DAT_NACK:
-		I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_SIC;
-		break;
-
-	/*
-	 * Note that: Return code only let us know a stop condition mixed
-	 * with a repeat start condition in the same code value.
-	 * So we should provide a time-out. In case this is really a stop
-	 * condition, this will return back after time out condition. Otherwise,
-	 * next session that is slave receive data will be completed.
-	 */
-
-	/* A Stop or a repeat start condition */
-	case I2C_I2STAT_S_RX_STA_STO_SLVREC_SLVTRX:
-		// Temporally lock the interrupt for timeout condition
-		I2C_IntCmd(I2Cx, 0);
-		I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_SIC;
-		// enable time out
-		timeout = I2C_SLAVE_TIME_OUT;
-		while(1){
-			if (I2Cx-&gt;I2CONSET &amp; I2C_I2CONSET_SI){
-				// re-Enable interrupt
-				I2C_IntCmd(I2Cx, 1);
-				break;
-			} else {
-				timeout--;
-				if (timeout == 0){
-					// timeout occur, it's really a stop condition
-					txrx_setup-&gt;status |= I2C_SETUP_STATUS_DONE;
-					goto s_int_end;
-				}
-			}
-		}
-		break;
-
-	/* Writing phase -------------------------------------------------------- */
-	/* Own SLA+R has been received, ACK has been returned */
-	case I2C_I2STAT_S_TX_SLAR_ACK:
-	/* Data has been transmitted, ACK has been received */
-	case I2C_I2STAT_S_TX_DAT_ACK:
-		/*
-		 * All data bytes that over-flow the specified receive
-		 * data length, just ignore them.
-		 */
-		if ((txrx_setup-&gt;tx_count &lt; txrx_setup-&gt;tx_length) \
-				&amp;&amp; (txrx_setup-&gt;tx_data != NULL)){
-			I2Cx-&gt;I2DAT = *(uint8_t *) (txrx_setup-&gt;tx_data + txrx_setup-&gt;tx_count);
-			txrx_setup-&gt;tx_count++;
-		}
-		I2Cx-&gt;I2CONSET = I2C_I2CONSET_AA;
-		I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_SIC;
-		break;
-
-	/* Data has been transmitted, NACK has been received,
-	 * that means there's no more data to send, exit now */
-	/*
-	 * Note: Don't wait for stop event since in slave transmit mode,
-	 * since there no proof lets us know when a stop signal has been received
-	 * on slave side.
-	 */
-	case I2C_I2STAT_S_TX_DAT_NACK:
-		I2Cx-&gt;I2CONSET = I2C_I2CONSET_AA;
-		I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_SIC;
-		txrx_setup-&gt;status |= I2C_SETUP_STATUS_DONE;
-		goto s_int_end;
-		break;
-
-	// Other status must be captured
-	default:
-s_int_end:
-		// Disable interrupt
-		I2C_IntCmd(I2Cx, 0);
-		I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_AAC | I2C_I2CONCLR_SIC | I2C_I2CONCLR_STAC;
-		// Call callback if installed
-		if (txrx_setup-&gt;callback != NULL){
-			txrx_setup-&gt;callback();
-		}
-		break;
-	}
-}
-
-/**
- * @}
- */
-
-
-/* Public Functions ----------------------------------------------------------- */
-/** @addtogroup I2C_Public_Functions
- * @{
- */
-
-/*********************************************************************//**
- * @brief 		Setup clock rate for I2C peripheral
- * @param[in] 	I2Cx	I2C peripheral selected, should be I2C0, I2C1 or I2C2
- * @param[in]	target_clock : clock of SSP (Hz)
- * @return 		None
- ***********************************************************************/
-void I2C_SetClock (I2C_TypeDef *I2Cx, uint32_t target_clock)
-{
-	uint32_t temp;
-
-	CHECK_PARAM(PARAM_I2Cx(I2Cx));
-
-	// Get PCLK of I2C controller
-	if (I2Cx == I2C0)
-	{
-		temp = CLKPWR_GetPCLK (CLKPWR_PCLKSEL_I2C0) / target_clock;
-	}
-	else if (I2Cx == I2C1)
-	{
-		temp = CLKPWR_GetPCLK (CLKPWR_PCLKSEL_I2C1) / target_clock;
-	}
-	else if (I2Cx == I2C2)
-	{
-		temp = CLKPWR_GetPCLK (CLKPWR_PCLKSEL_I2C1) / target_clock;
-	}
-
-	/* Set the I2C clock value to register */
-	I2Cx-&gt;I2SCLH = (uint32_t)(temp / 2);
-	I2Cx-&gt;I2SCLL = (uint32_t)(temp - I2Cx-&gt;I2SCLH);
-}
-
-
-/*********************************************************************//**
- * @brief		De-initializes the I2C peripheral registers to their
-*                  default reset values.
- * @param[in]	I2Cx	I2C peripheral selected, should be I2C0, I2C1 or I2C2
- * @return 		None
- **********************************************************************/
-void I2C_DeInit(I2C_TypeDef* I2Cx)
-{
-	CHECK_PARAM(PARAM_I2Cx(I2Cx));
-
-	/* Disable I2C control */
-	I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_I2ENC;
-
-	if (I2Cx==I2C0)
-	{
-		/* Disable power for I2C0 module */
-		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCI2C0, DISABLE);
-	}
-	else if (I2Cx==I2C1)
-	{
-		/* Disable power for I2C1 module */
-		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCI2C1, DISABLE);
-	}
-	else if (I2Cx==I2C2)
-	{
-		/* Disable power for I2C2 module */
-		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCI2C2, DISABLE);
-	}
-}
-
-
-/********************************************************************//**
- * @brief		Initializes the I2Cx peripheral with specified parameter.
- * @param[in]	I2Cx	I2C peripheral selected, should be I2C0, I2C1 or I2C2
- * @param[in]	clockrate Target clock rate value to initialized I2C
- * 				peripheral
- * @return 		None
- *********************************************************************/
-void I2C_Init(I2C_TypeDef *I2Cx, uint32_t clockrate)
-{
-	CHECK_PARAM(PARAM_I2Cx(I2Cx));
-
-	if (I2Cx==I2C0)
-	{
-		/* Set up clock and power for I2C0 module */
-		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCI2C0, ENABLE);
-		/* As default, peripheral clock for I2C0 module
-		 * is set to FCCLK / 2 */
-		CLKPWR_SetPCLKDiv(CLKPWR_PCLKSEL_I2C0, CLKPWR_PCLKSEL_CCLK_DIV_2);
-	}
-	else if (I2Cx==I2C1)
-	{
-		/* Set up clock and power for I2C1 module */
-		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCI2C1, ENABLE);
-		/* As default, peripheral clock for I2C1 module
-		 * is set to FCCLK / 2 */
-		CLKPWR_SetPCLKDiv(CLKPWR_PCLKSEL_I2C1, CLKPWR_PCLKSEL_CCLK_DIV_2);
-	}
-	else if (I2Cx==I2C2)
-	{
-		/* Set up clock and power for I2C2 module */
-		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCI2C2, ENABLE);
-		/* As default, peripheral clock for I2C2 module
-		 * is set to FCCLK / 2 */
-		CLKPWR_SetPCLKDiv(CLKPWR_PCLKSEL_I2C2, CLKPWR_PCLKSEL_CCLK_DIV_2);
-	}
-	else {
-		// Up-Support this device
-		return;
-	}
-
-    /* Set clock rate */
-    I2C_SetClock(I2Cx, clockrate);
-    /* Set I2C operation to default */
-    I2Cx-&gt;I2CONCLR = (I2C_I2CONCLR_AAC | I2C_I2CONCLR_STAC | I2C_I2CONCLR_I2ENC);
-}
-
-
-/*********************************************************************//**
- * @brief		Enable or disable I2C peripheral's operation
- * @param[in]	I2Cx I2C peripheral selected, should be I2C0, I2C1 or I2C2
- * @param[in]	NewState New State of I2Cx peripheral's operation
- * @return 		none
- **********************************************************************/
-void I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
-{
-	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
-	CHECK_PARAM(PARAM_I2Cx(I2Cx));
-
-	if (NewState == ENABLE)
-	{
-		I2Cx-&gt;I2CONSET = I2C_I2CONSET_I2EN;
-	}
-	else
-	{
-		I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_I2ENC;
-	}
-}
-
-
-/*********************************************************************//**
- * @brief 		Transmit and Receive data in master mode
- * @param[in]	TransferCfg		Pointer to a I2C_M_SETUP_Type structure that
- * 								contains specified information about the
- * 								configuration for master transfer.
- * @param[in]	Opt				a I2C_TRANSFER_OPT_Type type that selected for
- * 								interrupt or polling mode.
- * @return 		SUCCESS or ERROR
- *
- * Note:
- * - In case of using I2C to transmit data only, either transmit length set to 0
- * or transmit data pointer set to NULL.
- * - In case of using I2C to receive data only, either receive length set to 0
- * or receive data pointer set to NULL.
- * - In case of using I2C to transmit followed by receive data, transmit length,
- * transmit data pointer, receive length and receive data pointer should be set
- * corresponding.
- **********************************************************************/
-Status I2C_MasterTransferData(I2C_TypeDef *I2Cx, I2C_M_SETUP_Type *TransferCfg, \
-								I2C_TRANSFER_OPT_Type Opt)
-{
-	uint8_t *txdat;
-	uint8_t *rxdat;
-	uint32_t CodeStatus;
-	uint8_t tmp;
-
-	// reset all default state
-	txdat = (uint8_t *) TransferCfg-&gt;tx_data;
-	rxdat = (uint8_t *) TransferCfg-&gt;rx_data;
-	// Reset I2C setup value to default state
-	TransferCfg-&gt;tx_count = 0;
-	TransferCfg-&gt;rx_count = 0;
-	TransferCfg-&gt;status = 0;
-
-	if (Opt == I2C_TRANSFER_POLLING){
-
-		/* First Start condition -------------------------------------------------------------- */
-		TransferCfg-&gt;retransmissions_count = 0;
-retry:
-		// reset all default state
-		txdat = (uint8_t *) TransferCfg-&gt;tx_data;
-		rxdat = (uint8_t *) TransferCfg-&gt;rx_data;
-		// Reset I2C setup value to default state
-		TransferCfg-&gt;tx_count = 0;
-		TransferCfg-&gt;rx_count = 0;
-		CodeStatus = 0;
-
-		// Start command
-		CodeStatus = I2C_Start(I2Cx);
-		if ((CodeStatus != I2C_I2STAT_M_TX_START) \
-				&amp;&amp; (CodeStatus != I2C_I2STAT_M_TX_RESTART)){
-			TransferCfg-&gt;retransmissions_count++;
-			if (TransferCfg-&gt;retransmissions_count &gt; TransferCfg-&gt;retransmissions_max){
-				// save status
-				TransferCfg-&gt;status = CodeStatus;
-				goto error;
-			} else {
-				goto retry;
-			}
-		}
-
-		/* In case of sending data first --------------------------------------------------- */
-		if ((TransferCfg-&gt;tx_length != 0) &amp;&amp; (TransferCfg-&gt;tx_data != NULL)){
-
-			/* Send slave address + WR direction bit = 0 ----------------------------------- */
-			CodeStatus = I2C_SendByte(I2Cx, (TransferCfg-&gt;sl_addr7bit &lt;&lt; 1));
-			if (CodeStatus != I2C_I2STAT_M_TX_SLAW_ACK){
-				TransferCfg-&gt;retransmissions_count++;
-				if (TransferCfg-&gt;retransmissions_count &gt; TransferCfg-&gt;retransmissions_max){
-					// save status
-					TransferCfg-&gt;status = CodeStatus | I2C_SETUP_STATUS_NOACKF;
-					goto error;
-				} else {
-					goto retry;
-				}
-			}
-
-			/* Send a number of data bytes ---------------------------------------- */
-			while (TransferCfg-&gt;tx_count &lt; TransferCfg-&gt;tx_length)
-			{
-				CodeStatus = I2C_SendByte(I2Cx, *txdat);
-				if (CodeStatus != I2C_I2STAT_M_TX_DAT_ACK){
-					TransferCfg-&gt;retransmissions_count++;
-					if (TransferCfg-&gt;retransmissions_count &gt; TransferCfg-&gt;retransmissions_max){
-						// save status
-						TransferCfg-&gt;status = CodeStatus | I2C_SETUP_STATUS_NOACKF;
-						goto error;
-					} else {
-						goto retry;
-					}
-				}
-
-				txdat++;
-				TransferCfg-&gt;tx_count++;
-			}
-		}
-
-		/* Second Start condition (Repeat Start) ------------------------------------------- */
-		if ((TransferCfg-&gt;tx_length != 0) &amp;&amp; (TransferCfg-&gt;tx_data != NULL) \
-				&amp;&amp; (TransferCfg-&gt;rx_length != 0) &amp;&amp; (TransferCfg-&gt;rx_data != NULL)){
-
-			CodeStatus = I2C_Start(I2Cx);
-			if ((CodeStatus != I2C_I2STAT_M_RX_START) \
-					&amp;&amp; (CodeStatus != I2C_I2STAT_M_RX_RESTART)){
-				TransferCfg-&gt;retransmissions_count++;
-				if (TransferCfg-&gt;retransmissions_count &gt; TransferCfg-&gt;retransmissions_max){
-					// Update status
-					TransferCfg-&gt;status = CodeStatus;
-					goto error;
-				} else {
-					goto retry;
-				}
-			}
-		}
-
-		/* Then, start reading after sending data -------------------------------------- */
-		if ((TransferCfg-&gt;rx_length != 0) &amp;&amp; (TransferCfg-&gt;rx_data != NULL)){
-			/* Send slave address + RD direction bit = 1 ----------------------------------- */
-
-			CodeStatus = I2C_SendByte(I2Cx, ((TransferCfg-&gt;sl_addr7bit &lt;&lt; 1) | 0x01));
-			if (CodeStatus != I2C_I2STAT_M_RX_SLAR_ACK){
-				TransferCfg-&gt;retransmissions_count++;
-				if (TransferCfg-&gt;retransmissions_count &gt; TransferCfg-&gt;retransmissions_max){
-					// update status
-					TransferCfg-&gt;status = CodeStatus | I2C_SETUP_STATUS_NOACKF;
-					goto error;
-				} else {
-					goto retry;
-				}
-			}
-
-			/* Receive a number of data bytes ------------------------------------------------- */
-			while (TransferCfg-&gt;rx_count &lt; TransferCfg-&gt;rx_length){
-
-				/*
-				 * Note that: if data length is only one, the master should not
-				 * issue an ACK signal on bus after reading to avoid of next data frame
-				 * on slave side
-				 */
-				if (TransferCfg-&gt;rx_count &lt; (TransferCfg-&gt;rx_length - 1)){
-					// Issue an ACK signal for next data frame
-					CodeStatus = I2C_GetByte(I2Cx, &amp;tmp, 1);
-					if (CodeStatus != I2C_I2STAT_M_RX_DAT_ACK){
-						TransferCfg-&gt;retransmissions_count++;
-						if (TransferCfg-&gt;retransmissions_count &gt; TransferCfg-&gt;retransmissions_max){
-							// update status
-							TransferCfg-&gt;status = CodeStatus;
-							goto error;
-						} else {
-							goto retry;
-						}
-					}
-				} else {
-					// Do not issue an ACK signal
-					CodeStatus = I2C_GetByte(I2Cx, &amp;tmp, 0);
-					if (CodeStatus != I2C_I2STAT_M_RX_DAT_NACK){
-						TransferCfg-&gt;retransmissions_count++;
-						if (TransferCfg-&gt;retransmissions_count &gt; TransferCfg-&gt;retransmissions_max){
-							// update status
-							TransferCfg-&gt;status = CodeStatus;
-							goto error;
-						} else {
-							goto retry;
-						}
-					}
-				}
-				*rxdat++ = tmp;
-				TransferCfg-&gt;rx_count++;
-			}
-		}
-
-		/* Send STOP condition ------------------------------------------------- */
-		I2C_Stop(I2Cx);
-		return SUCCESS;
-
-error:
-		// Send stop condition
-		I2C_Stop(I2Cx);
-		return ERROR;
-	}
-
-	else if (Opt == I2C_TRANSFER_INTERRUPT){
-		// Setup tx_rx data, callback and interrupt handler
-		tmp = I2C_getNum(I2Cx);
-		i2cdat[tmp].txrx_setup = (uint32_t) TransferCfg;
-		i2cdat[tmp].inthandler = I2C_MasterHandler;
-		// Set direction phase, write first
-		i2cdat[tmp].dir = 0;
-
-		/* First Start condition -------------------------------------------------------------- */
-		I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_SIC;
-		I2Cx-&gt;I2CONSET = I2C_I2CONSET_STA;
-		I2C_IntCmd(I2Cx, 1);
-
-		return (SUCCESS);
-	}
-
-	return ERROR;
-}
-
-/*********************************************************************//**
- * @brief 		Receive and Transmit data in slave mode
- * @param[in]	TransferCfg		Pointer to a I2C_S_SETUP_Type structure that
- * 								contains specified information about the
- * 								configuration for master transfer.
- * @param[in]	Opt				I2C_TRANSFER_OPT_Type type that selected for
- * 								interrupt or polling mode.
- * @return 		SUCCESS or ERROR
- *
- * Note:
- * The mode of slave's operation depends on the command sent from master on
- * the I2C bus. If the master send a SLA+W command, this sub-routine will
- * use receive data length and receive data pointer. If the master send a SLA+R
- * command, this sub-routine will use transmit data length and transmit data
- * pointer.
- * If the master issue an repeat start command or a stop command, the slave will
- * enable an time out condition, during time out condition, if there's no activity
- * on I2C bus, the slave will exit, otherwise (i.e. the master send a SLA+R/W),
- * the slave then switch to relevant operation mode. The time out should be used
- * because the return status code can not show difference from stop and repeat
- * start command in slave operation.
- * In case of the expected data length from master is greater than data length
- * that slave can support:
- * - In case of reading operation (from master): slave will return I2C_I2DAT_IDLE_CHAR
- * value.
- * - In case of writing operation (from master): slave will ignore remain data from master.
- **********************************************************************/
-Status I2C_SlaveTransferData(I2C_TypeDef *I2Cx, I2C_S_SETUP_Type *TransferCfg, \
-								I2C_TRANSFER_OPT_Type Opt)
-{
-	uint8_t *txdat;
-	uint8_t *rxdat;
-	uint32_t CodeStatus;
-	uint32_t timeout;
-	int32_t time_en;
-	int32_t tmp;
-
-	// reset all default state
-	txdat = (uint8_t *) TransferCfg-&gt;tx_data;
-	rxdat = (uint8_t *) TransferCfg-&gt;rx_data;
-	// Reset I2C setup value to default state
-	TransferCfg-&gt;tx_count = 0;
-	TransferCfg-&gt;rx_count = 0;
-	TransferCfg-&gt;status = 0;
-
-
-	// Polling option
-	if (Opt == I2C_TRANSFER_POLLING){
-
-		/* Set AA bit to ACK command on I2C bus */
-		I2Cx-&gt;I2CONSET = I2C_I2CONSET_AA;
-		/* Clear SI bit to be ready ... */
-		I2Cx-&gt;I2CONCLR = (I2C_I2CONCLR_SIC | I2C_I2CONCLR_STAC);
-
-		time_en = 0;
-		timeout = 0;
-
-		while (1)
-		{
-			/* Check SI flag ready */
-			if (I2Cx-&gt;I2CONSET &amp; I2C_I2CONSET_SI)
-			{
-				time_en = 0;
-
-				switch (CodeStatus = (I2Cx-&gt;I2STAT &amp; I2C_STAT_CODE_BITMASK))
-				{
-
-				/* No status information */
-				case I2C_I2STAT_NO_INF:
-					I2Cx-&gt;I2CONSET = I2C_I2CONSET_AA;
-					I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_SIC;
-					break;
-
-				/* Reading phase -------------------------------------------------------- */
-				/* Own SLA+R has been received, ACK has been returned */
-				case I2C_I2STAT_S_RX_SLAW_ACK:
-				/* General call address has been received, ACK has been returned */
-				case I2C_I2STAT_S_RX_GENCALL_ACK:
-					I2Cx-&gt;I2CONSET = I2C_I2CONSET_AA;
-					I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_SIC;
-					break;
-
-				/* Previously addressed with own SLA;
-				 * DATA byte has been received;
-				 * ACK has been returned */
-				case I2C_I2STAT_S_RX_PRE_SLA_DAT_ACK:
-				/* DATA has been received, ACK hasn been return */
-				case I2C_I2STAT_S_RX_PRE_GENCALL_DAT_ACK:
-					/*
-					 * All data bytes that over-flow the specified receive
-					 * data length, just ignore them.
-					 */
-					if ((TransferCfg-&gt;rx_count &lt; TransferCfg-&gt;rx_length) \
-							&amp;&amp; (TransferCfg-&gt;rx_data != NULL)){
-						*rxdat++ = (uint8_t)I2Cx-&gt;I2DAT;
-						TransferCfg-&gt;rx_count++;
-					}
-					I2Cx-&gt;I2CONSET = I2C_I2CONSET_AA;
-					I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_SIC;
-					break;
-
-				/* Previously addressed with own SLA;
-				 * DATA byte has been received;
-				 * NOT ACK has been returned */
-				case I2C_I2STAT_S_RX_PRE_SLA_DAT_NACK:
-				/* DATA has been received, NOT ACK has been returned */
-				case I2C_I2STAT_S_RX_PRE_GENCALL_DAT_NACK:
-					I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_SIC;
-					break;
-
-				/*
-				 * Note that: Return code only let us know a stop condition mixed
-				 * with a repeat start condition in the same code value.
-				 * So we should provide a time-out. In case this is really a stop
-				 * condition, this will return back after time out condition. Otherwise,
-				 * next session that is slave receive data will be completed.
-				 */
-
-				/* A Stop or a repeat start condition */
-				case I2C_I2STAT_S_RX_STA_STO_SLVREC_SLVTRX:
-					I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_SIC;
-					// enable time out
-					time_en = 1;
-					timeout = 0;
-					break;
-
-				/* Writing phase -------------------------------------------------------- */
-				/* Own SLA+R has been received, ACK has been returned */
-				case I2C_I2STAT_S_TX_SLAR_ACK:
-				/* Data has been transmitted, ACK has been received */
-				case I2C_I2STAT_S_TX_DAT_ACK:
-					/*
-					 * All data bytes that over-flow the specified receive
-					 * data length, just ignore them.
-					 */
-					if ((TransferCfg-&gt;tx_count &lt; TransferCfg-&gt;tx_length) \
-							&amp;&amp; (TransferCfg-&gt;tx_data != NULL)){
-						I2Cx-&gt;I2DAT = *txdat++;
-						TransferCfg-&gt;tx_count++;
-					}
-					I2Cx-&gt;I2CONSET = I2C_I2CONSET_AA;
-					I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_SIC;
-					break;
-
-				/* Data has been transmitted, NACK has been received,
-				 * that means there's no more data to send, exit now */
-				/*
-				 * Note: Don't wait for stop event since in slave transmit mode,
-				 * since there no proof lets us know when a stop signal has been received
-				 * on slave side.
-				 */
-				case I2C_I2STAT_S_TX_DAT_NACK:
-					I2Cx-&gt;I2CONSET = I2C_I2CONSET_AA;
-					I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_SIC;
-					// enable time out
-					time_en = 1;
-					timeout = 0;
-					break;
-
-				// Other status must be captured
-				default:
-					I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_SIC;
-					goto s_error;
-					break;
-				}
-			} else if (time_en){
-				if (timeout++ &gt; I2C_SLAVE_TIME_OUT){
-					// it's really a stop condition, goto end stage
-					goto s_end_stage;
-				}
-			}
-		}
-
-s_end_stage:
-		/* Clear AA bit to disable ACK on I2C bus */
-		I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_AAC;
-		// Check if there's no error during operation
-		// Update status
-		TransferCfg-&gt;status = CodeStatus | I2C_SETUP_STATUS_DONE;
-		return SUCCESS;
-
-s_error:
-		/* Clear AA bit to disable ACK on I2C bus */
-		I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_AAC;
-		// Update status
-		TransferCfg-&gt;status = CodeStatus;
-		return ERROR;
-	}
-
-	else if (Opt == I2C_TRANSFER_INTERRUPT){
-		// Setup tx_rx data, callback and interrupt handler
-		tmp = I2C_getNum(I2Cx);
-		i2cdat[tmp].txrx_setup = (uint32_t) TransferCfg;
-		i2cdat[tmp].inthandler = I2C_SlaveHandler;
-		// Set direction phase, read first
-		i2cdat[tmp].dir = 1;
-
-		// Enable AA
-		I2Cx-&gt;I2CONSET = I2C_I2CONSET_AA;
-		I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_SIC | I2C_I2CONCLR_STAC;
-		I2C_IntCmd(I2Cx, 1);
-
-		return (SUCCESS);
-	}
-
-	return ERROR;
-}
-
-/*********************************************************************//**
- * @brief		Set Own slave address in I2C peripheral corresponding to
- * 				parameter specified in OwnSlaveAddrConfigStruct.
- * @param[in]	I2Cx	I2C peripheral selected, should be I2C0, I2C1 or I2C2
- * @param[in]	OwnSlaveAddrConfigStruct	Pointer to a I2C_OWNSLAVEADDR_CFG_Type
- * 				structure that contains the configuration information for the
-*               specified I2C slave address.
- * @return 		None
- **********************************************************************/
-void I2C_SetOwnSlaveAddr(I2C_TypeDef *I2Cx, I2C_OWNSLAVEADDR_CFG_Type *OwnSlaveAddrConfigStruct)
-{
-	uint32_t tmp;
-	CHECK_PARAM(PARAM_I2Cx(I2Cx));
-	CHECK_PARAM(PARAM_I2C_SLAVEADDR_CH(OwnSlaveAddrConfigStruct-&gt;SlaveAddrChannel));
-	CHECK_PARAM(PARAM_FUNCTIONALSTATE(OwnSlaveAddrConfigStruct-&gt;GeneralCallState));
-
-	tmp = (((uint32_t)(OwnSlaveAddrConfigStruct-&gt;SlaveAddr_7bit &lt;&lt; 1)) \
-			| ((OwnSlaveAddrConfigStruct-&gt;GeneralCallState == ENABLE) ? 0x01 : 0x00))&amp; I2C_I2ADR_BITMASK;
-	switch (OwnSlaveAddrConfigStruct-&gt;SlaveAddrChannel)
-	{
-	case 0:
-		I2Cx-&gt;I2ADR0 = tmp;
-		I2Cx-&gt;I2MASK0 = I2C_I2MASK_MASK((uint32_t) \
-				(OwnSlaveAddrConfigStruct-&gt;SlaveAddrMaskValue));
-		break;
-	case 1:
-		I2Cx-&gt;I2ADR1 = tmp;
-		I2Cx-&gt;I2MASK1 = I2C_I2MASK_MASK((uint32_t) \
-				(OwnSlaveAddrConfigStruct-&gt;SlaveAddrMaskValue));
-		break;
-	case 2:
-		I2Cx-&gt;I2ADR2 = tmp;
-		I2Cx-&gt;I2MASK2 = I2C_I2MASK_MASK((uint32_t) \
-				(OwnSlaveAddrConfigStruct-&gt;SlaveAddrMaskValue));
-		break;
-	case 3:
-		I2Cx-&gt;I2ADR3 = tmp;
-		I2Cx-&gt;I2MASK3 = I2C_I2MASK_MASK((uint32_t) \
-				(OwnSlaveAddrConfigStruct-&gt;SlaveAddrMaskValue));
-		break;
-	}
-}
-
-
-/*********************************************************************//**
- * @brief		Configures functionality in I2C monitor mode
- * @param[in]	I2Cx	I2C peripheral selected, should be I2C0, I2C1 or I2C2
- * @param[in]	MonitorCfgType Monitor Configuration type, should be:
- * 				- I2C_MONITOR_CFG_SCL_OUTPUT: I2C module can 'stretch'
- * 				the clock line (hold it low) until it has had time to
- * 				respond to an I2C interrupt.
- * 				- I2C_MONITOR_CFG_MATCHALL: When this bit is set to '1'
- * 				and the I2C is in monitor mode, an interrupt will be
- * 				generated on ANY address received.
- * @param[in]	NewState New State of this function, should be:
- * 				- ENABLE: Enable this function.
- * 				- DISABLE: Disable this function.
- * @return		None
- **********************************************************************/
-void I2C_MonitorModeConfig(I2C_TypeDef *I2Cx, uint32_t MonitorCfgType, FunctionalState NewState)
-{
-	CHECK_PARAM(PARAM_I2Cx(I2Cx));
-	CHECK_PARAM(PARAM_I2C_MONITOR_CFG(MonitorCfgType));
-	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
-
-	if (NewState == ENABLE)
-	{
-		I2Cx-&gt;MMCTRL |= MonitorCfgType;
-	}
-	else
-	{
-		I2Cx-&gt;MMCTRL &amp;= (~MonitorCfgType) &amp; I2C_I2MMCTRL_BITMASK;
-	}
-}
-
-
-/*********************************************************************//**
- * @brief		Enable/Disable I2C monitor mode
- * @param[in]	I2Cx	I2C peripheral selected, should be I2C0, I2C1 or I2C2
- * @param[in]	NewState New State of this function, should be:
- * 				- ENABLE: Enable monitor mode.
- * 				- DISABLE: Disable monitor mode.
- * @return		None
- **********************************************************************/
-void I2C_MonitorModeCmd(I2C_TypeDef *I2Cx, FunctionalState NewState)
-{
-	CHECK_PARAM(PARAM_I2Cx(I2Cx));
-	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
-
-	if (NewState == ENABLE)
-	{
-		I2Cx-&gt;MMCTRL |= I2C_I2MMCTRL_MM_ENA;
-	}
-	else
-	{
-		I2Cx-&gt;MMCTRL &amp;= (~I2C_I2MMCTRL_MM_ENA) &amp; I2C_I2MMCTRL_BITMASK;
-	}
-}
-
-
-/*********************************************************************//**
- * @brief		Get data from I2C data buffer in monitor mode.
- * @param[in]	I2Cx	I2C peripheral selected, should be I2C0, I2C1 or I2C2
- * @return		None
- * Note:	In monitor mode, the I2C module may lose the ability to stretch
- * the clock (stall the bus) if the ENA_SCL bit is not set. This means that
- * the processor will have a limited amount of time to read the contents of
- * the data received on the bus. If the processor reads the I2DAT shift
- * register, as it ordinarily would, it could have only one bit-time to
- * respond to the interrupt before the received data is overwritten by
- * new data.
- **********************************************************************/
-uint8_t I2C_MonitorGetDatabuffer(I2C_TypeDef *I2Cx)
-{
-	CHECK_PARAM(PARAM_I2Cx(I2Cx));
-	return ((uint8_t)(I2Cx-&gt;I2DATA_BUFFER));
-}
-
-/*********************************************************************//**
- * @brief 		Standard Interrupt handler for I2C0 peripheral
- * @param[in]	None
- * @return 		None
- **********************************************************************/
-void I2C0_StdIntHandler(void)
-{
-	i2cdat[0].inthandler(I2C0);
-}
-
-/*********************************************************************//**
- * @brief 		Standard Interrupt handler for I2C1 peripheral
- * @param[in]	None
- * @return 		None
- **********************************************************************/
-void I2C1_StdIntHandler(void)
-{
-	i2cdat[1].inthandler(I2C1);
-}
-
-/*********************************************************************//**
- * @brief 		Standard Interrupt handler for I2C2 peripheral
- * @param[in]	None
- * @return 		None
- **********************************************************************/
-void I2C2_StdIntHandler(void)
-{
-	i2cdat[2].inthandler(I2C2);
-}
-
-
-/**
- * @}
- */
-
-#endif /* _I2C */
-
-/**
- * @}
- */
-
-/* --------------------------------- End Of File ------------------------------ */
+/**
+ * @file	: lpc17xx_i2c.c
+ * @brief	: Contains all functions support for I2C firmware library on LPC17xx
+ * @version	: 1.0
+ * @date	: 9. April. 2009
+ * @author	: HieuNguyen
+ **************************************************************************
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * products. This software is supplied &quot;AS IS&quot; without any warranties.
+ * NXP Semiconductors assumes no responsibility or liability for the
+ * use of the software, conveys no license or title under any patent,
+ * copyright, or mask work right to the product. NXP Semiconductors
+ * reserves the right to make changes in the software without
+ * notification. NXP Semiconductors also make no representation or
+ * warranty that such application will be suitable for the specified
+ * use without further testing or modification.
+ **********************************************************************/
+
+/* Peripheral group ----------------------------------------------------------- */
+/** @addtogroup I2C
+ * @{
+ */
+
+/* Includes ------------------------------------------------------------------- */
+#include &quot;lpc17xx_i2c.h&quot;
+#include &quot;lpc17xx_clkpwr.h&quot;
+#include &quot;lpc17xx_pinsel.h&quot;
+
+
+/* If this source file built with example, the LPC17xx FW library configuration
+ * file in each example directory (&quot;lpc17xx_libcfg.h&quot;) must be included,
+ * otherwise the default FW library configuration file must be included instead
+ */
+#ifdef __BUILD_WITH_EXAMPLE__
+#include &quot;lpc17xx_libcfg.h&quot;
+#else
+#include &quot;lpc17xx_libcfg_default.h&quot;
+#endif /* __BUILD_WITH_EXAMPLE__ */
+
+
+#ifdef _I2C
+
+
+/* Private Types -------------------------------------------------------------- */
+/** @defgroup I2C_Private_Types
+ * @{
+ */
+
+/**
+ * @brief I2C device configuration structure type
+ */
+typedef struct
+{
+  uint32_t      txrx_setup; 						/* Transmission setup */
+  int32_t		dir;								/* Current direction phase, 0 - write, 1 - read */
+  void		(*inthandler)(LPC_I2C_TypeDef *I2Cx);   	/* Transmission interrupt handler */
+} I2C_CFG_T;
+
+/**
+ * @}
+ */
+
+/* Private Variables ---------------------------------------------------------- */
+/**
+ * @brief II2C driver data for I2C0, I2C1 and I2C2
+ */
+static I2C_CFG_T i2cdat[3];
+
+
+
+/* Private Functions ---------------------------------------------------------- */
+/** @defgroup I2C_Private_Functions
+ * @{
+ */
+
+/* Generate a start condition on I2C bus (in master mode only) */
+static uint32_t I2C_Start (LPC_I2C_TypeDef *I2Cx);
+
+/* Generate a stop condition on I2C bus (in master mode only) */
+static void I2C_Stop (LPC_I2C_TypeDef *I2Cx);
+
+/* I2C send byte subroutine */
+static uint32_t I2C_SendByte (LPC_I2C_TypeDef *I2Cx, uint8_t databyte);
+
+/* I2C get byte subroutine */
+static uint32_t I2C_GetByte (LPC_I2C_TypeDef *I2Cx, uint8_t *retdat, Bool ack);
+
+/* I2C interrupt master handler */
+void I2C_MasterHandler (LPC_I2C_TypeDef *I2Cx);
+
+/* I2C interrupt master handler */
+void I2C_SlaveHandler (LPC_I2C_TypeDef *I2Cx);
+
+/* Enable interrupt for I2C device */
+void I2C_IntCmd (LPC_I2C_TypeDef *I2Cx, Bool NewState);
+
+/*--------------------------------------------------------------------------------*/
+
+/**
+ * @brief Convert from I2C peripheral to number
+ */
+static int32_t I2C_getNum(LPC_I2C_TypeDef *I2Cx){
+	if (I2Cx == LPC_I2C0) {
+		return (0);
+	} else if (I2Cx == LPC_I2C1) {
+		return (1);
+	} else if (I2Cx == LPC_I2C2) {
+		return (2);
+	}
+	return (-1);
+}
+
+/***********************************************************************
+ * Function: I2C_Start
+ * Purpose: Generate a start condition on I2C bus (in master mode only)
+ * Parameters:
+ *     i2cdev: Pointer to I2C register
+ *     blocking: blocking or none blocking mode
+ * Returns: value of I2C status register after generate a start condition
+ **********************************************************************/
+static uint32_t I2C_Start (LPC_I2C_TypeDef *I2Cx)
+{
+	I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_SIC;
+	I2Cx-&gt;I2CONSET = I2C_I2CONSET_STA;
+
+	// Wait for complete
+	while (!(I2Cx-&gt;I2CONSET &amp; I2C_I2CONSET_SI));
+	I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_STAC;
+	return (I2Cx-&gt;I2STAT &amp; I2C_STAT_CODE_BITMASK);
+}
+
+
+/***********************************************************************
+ * Function: I2C_Stop
+ * Purpose: Generate a stop condition on I2C bus (in master mode only)
+ * Parameters:
+ *     I2Cx: Pointer to I2C register
+ * Returns: None
+ **********************************************************************/
+static void I2C_Stop (LPC_I2C_TypeDef *I2Cx)
+{
+
+	/* Make sure start bit is not active */
+	if (I2Cx-&gt;I2CONSET &amp; I2C_I2CONSET_STA)
+	{
+		I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_STAC;
+	}
+	I2Cx-&gt;I2CONSET = I2C_I2CONSET_STO;
+	I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_SIC;
+}
+
+
+/***********************************************************************
+ * Function: I2C_SendByte
+ * Purpose: Send a byte
+ * Parameters:
+ *     I2Cx: Pointer to I2C register
+ * Returns: value of I2C status register after sending
+ **********************************************************************/
+static uint32_t I2C_SendByte (LPC_I2C_TypeDef *I2Cx, uint8_t databyte)
+{
+	/* Make sure start bit is not active */
+	if (I2Cx-&gt;I2CONSET &amp; I2C_I2CONSET_STA)
+	{
+		I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_STAC;
+	}
+	I2Cx-&gt;I2DAT = databyte &amp; I2C_I2DAT_BITMASK;
+	I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_SIC;
+
+	while (!(I2Cx-&gt;I2CONSET &amp; I2C_I2CONSET_SI));
+	return (I2Cx-&gt;I2STAT &amp; I2C_STAT_CODE_BITMASK);
+}
+
+
+/***********************************************************************
+ * Function: I2C_GetByte
+ * Purpose: Get a byte
+ * Parameters:
+ *     I2Cx: Pointer to I2C register
+ * Returns: value of I2C status register after receiving
+ **********************************************************************/
+static uint32_t I2C_GetByte (LPC_I2C_TypeDef *I2Cx, uint8_t *retdat, Bool ack)
+{
+	if (ack == TRUE)
+	{
+		I2Cx-&gt;I2CONSET = I2C_I2CONSET_AA;
+	}
+	else
+	{
+		I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_AAC;
+	}
+	I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_SIC;
+
+	while (!(I2Cx-&gt;I2CONSET &amp; I2C_I2CONSET_SI));
+	*retdat = (uint8_t) (I2Cx-&gt;I2DAT &amp; I2C_I2DAT_BITMASK);
+	return (I2Cx-&gt;I2STAT &amp; I2C_STAT_CODE_BITMASK);
+}
+
+
+
+/*********************************************************************//**
+ * @brief 		Enable/Disable interrupt for I2C peripheral
+ * @param[in]	I2Cx	I2C peripheral selected, should be I2C0, I2C1 or I2C2
+ * @param[in]	NewState	New State of I2C peripheral interrupt in NVIC core
+ * 							should be:
+ * 							- ENABLE: enable interrupt for this I2C peripheral
+ * 							- DISABLE: disable interrupt for this I2C peripheral
+ * @return 		None
+ **********************************************************************/
+void I2C_IntCmd (LPC_I2C_TypeDef *I2Cx, Bool NewState)
+{
+	if (NewState)
+	{
+		if(I2Cx == LPC_I2C0)
+		{
+			NVIC_EnableIRQ(I2C0_IRQn);
+		}
+		else if (I2Cx == LPC_I2C1)
+		{
+			NVIC_EnableIRQ(I2C1_IRQn);
+		}
+		else if (I2Cx == LPC_I2C2)
+		{
+			NVIC_EnableIRQ(I2C2_IRQn);
+		}
+	}
+	else
+	{
+		if(I2Cx == LPC_I2C0)
+		{
+			NVIC_DisableIRQ(I2C0_IRQn);
+		}
+		else if (I2Cx == LPC_I2C1)
+		{
+			NVIC_DisableIRQ(I2C1_IRQn);
+		}
+		else if (I2Cx == LPC_I2C2)
+		{
+			NVIC_DisableIRQ(I2C2_IRQn);
+		}
+	}
+    return;
+}
+
+
+/*********************************************************************//**
+ * @brief 		General Master Interrupt handler for I2C peripheral
+ * @param[in]	I2Cx	I2C peripheral selected, should be I2C0, I2C1 or I2C2
+ * @return 		None
+ **********************************************************************/
+void I2C_MasterHandler (LPC_I2C_TypeDef  *I2Cx)
+{
+	int32_t tmp;
+	uint8_t returnCode;
+	I2C_M_SETUP_Type *txrx_setup;
+
+	tmp = I2C_getNum(I2Cx);
+	txrx_setup = (I2C_M_SETUP_Type *) i2cdat[tmp].txrx_setup;
+
+	returnCode = (I2Cx-&gt;I2STAT &amp; I2C_STAT_CODE_BITMASK);
+	// Save current status
+	txrx_setup-&gt;status = returnCode;
+	// there's no relevant information
+	if (returnCode == I2C_I2STAT_NO_INF){
+		I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_SIC;
+		return;
+	}
+
+	/* ----------------------------- TRANSMIT PHASE --------------------------*/
+	if (i2cdat[tmp].dir == 0){
+		switch (returnCode)
+		{
+		/* A start/repeat start condition has been transmitted -------------------*/
+		case I2C_I2STAT_M_TX_START:
+		case I2C_I2STAT_M_TX_RESTART:
+			I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_STAC;
+			/*
+			 * If there's any transmit data, then start to
+			 * send SLA+W right now, otherwise check whether if there's
+			 * any receive data for next state.
+			 */
+			if ((txrx_setup-&gt;tx_data != NULL) &amp;&amp; (txrx_setup-&gt;tx_length != 0)){
+				I2Cx-&gt;I2DAT = (txrx_setup-&gt;sl_addr7bit &lt;&lt; 1);
+				I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_SIC;
+			} else {
+				goto next_stage;
+			}
+			break;
+
+		/* SLA+W has been transmitted, ACK has been received ----------------------*/
+		case I2C_I2STAT_M_TX_SLAW_ACK:
+		/* Data has been transmitted, ACK has been received */
+		case I2C_I2STAT_M_TX_DAT_ACK:
+			/* Send more data */
+			if ((txrx_setup-&gt;tx_count &lt; txrx_setup-&gt;tx_length) \
+					&amp;&amp; (txrx_setup-&gt;tx_data != NULL)){
+				I2Cx-&gt;I2DAT =  *(uint8_t *)(txrx_setup-&gt;tx_data + txrx_setup-&gt;tx_count);
+				txrx_setup-&gt;tx_count++;
+				I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_SIC;
+			}
+			// no more data, switch to next stage
+			else {
+next_stage:
+				// change direction
+				i2cdat[tmp].dir = 1;
+				// Check if any data to receive
+				if ((txrx_setup-&gt;rx_length != 0) &amp;&amp; (txrx_setup-&gt;rx_data != NULL)){
+						// check whether if we need to issue an repeat start
+						if ((txrx_setup-&gt;tx_length != 0) &amp;&amp; (txrx_setup-&gt;tx_data != NULL)){
+							// Send out an repeat start command
+							I2Cx-&gt;I2CONSET = I2C_I2CONSET_STA;
+							I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_AAC | I2C_I2CONCLR_SIC;
+						}
+						// Don't need issue an repeat start, just goto send SLA+R
+						else {
+							goto send_slar;
+						}
+				}
+				// no more data send, the go to end stage now
+				else {
+					// success, goto end stage
+					txrx_setup-&gt;status |= I2C_SETUP_STATUS_DONE;
+					goto end_stage;
+				}
+			}
+			break;
+
+		/* SLA+W has been transmitted, NACK has been received ----------------------*/
+		case I2C_I2STAT_M_TX_SLAW_NACK:
+		/* Data has been transmitted, NACK has been received -----------------------*/
+		case I2C_I2STAT_M_TX_DAT_NACK:
+			// update status
+			txrx_setup-&gt;status |= I2C_SETUP_STATUS_NOACKF;
+			goto retry;
+			break;
+		/* Arbitration lost in SLA+R/W or Data bytes -------------------------------*/
+		case I2C_I2STAT_M_TX_ARB_LOST:
+			// update status
+			txrx_setup-&gt;status |= I2C_SETUP_STATUS_ARBF;
+		default:
+			goto retry;
+			break;
+		}
+	}
+
+	/* ----------------------------- RECEIVE PHASE --------------------------*/
+	else if (i2cdat[tmp].dir == 1){
+		switch (returnCode){
+			/* A start/repeat start condition has been transmitted ---------------------*/
+		case I2C_I2STAT_M_RX_START:
+		case I2C_I2STAT_M_RX_RESTART:
+			I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_STAC;
+			/*
+			 * If there's any receive data, then start to
+			 * send SLA+R right now, otherwise check whether if there's
+			 * any receive data for end of state.
+			 */
+			if ((txrx_setup-&gt;rx_data != NULL) &amp;&amp; (txrx_setup-&gt;rx_length != 0)){
+send_slar:
+				I2Cx-&gt;I2DAT = (txrx_setup-&gt;sl_addr7bit &lt;&lt; 1) | 0x01;
+				I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_SIC;
+			} else {
+				// Success, goto end stage
+				txrx_setup-&gt;status |= I2C_SETUP_STATUS_DONE;
+				goto end_stage;
+			}
+			break;
+
+		/* SLA+R has been transmitted, ACK has been received -----------------*/
+		case I2C_I2STAT_M_RX_SLAR_ACK:
+			if (txrx_setup-&gt;rx_count &lt; (txrx_setup-&gt;rx_length - 1)) {
+				/*Data will be received,  ACK will be return*/
+				I2Cx-&gt;I2CONSET = I2C_I2CONSET_AA;
+			}
+			else {
+				/*Last data will be received,  NACK will be return*/
+				I2Cx-&gt;I2CONCLR = I2C_I2CONSET_AA;
+			}
+			I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_SIC;
+			break;
+
+		/* Data has been received, ACK has been returned ----------------------*/
+		case I2C_I2STAT_M_RX_DAT_ACK:
+			// Note save data and increase counter first, then check later
+			/* Save data  */
+			if ((txrx_setup-&gt;rx_data != NULL) &amp;&amp; (txrx_setup-&gt;rx_count &lt; txrx_setup-&gt;rx_length)){
+				*(uint8_t *)(txrx_setup-&gt;rx_data + txrx_setup-&gt;rx_count) = (I2Cx-&gt;I2DAT &amp; I2C_I2DAT_BITMASK);
+				txrx_setup-&gt;rx_count++;
+			}
+			if (txrx_setup-&gt;rx_count &lt; (txrx_setup-&gt;rx_length - 1)) {
+				/*Data will be received,  ACK will be return*/
+				I2Cx-&gt;I2CONSET = I2C_I2CONSET_AA;
+			}
+			else {
+				/*Last data will be received,  NACK will be return*/
+				I2Cx-&gt;I2CONCLR = I2C_I2CONSET_AA;
+			}
+
+			I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_SIC;
+			break;
+
+		/* Data has been received, NACK has been return -------------------------*/
+		case I2C_I2STAT_M_RX_DAT_NACK:
+			/* Save the last data */
+			if ((txrx_setup-&gt;rx_data != NULL) &amp;&amp; (txrx_setup-&gt;rx_count &lt; txrx_setup-&gt;rx_length)){
+				*(uint8_t *)(txrx_setup-&gt;rx_data + txrx_setup-&gt;rx_count) = (I2Cx-&gt;I2DAT &amp; I2C_I2DAT_BITMASK);
+				txrx_setup-&gt;rx_count++;
+			}
+			// success, go to end stage
+			txrx_setup-&gt;status |= I2C_SETUP_STATUS_DONE;
+			goto end_stage;
+			break;
+
+		/* SLA+R has been transmitted, NACK has been received ------------------*/
+		case I2C_I2STAT_M_RX_SLAR_NACK:
+			// update status
+			txrx_setup-&gt;status |= I2C_SETUP_STATUS_NOACKF;
+			goto retry;
+			break;
+
+		/* Arbitration lost ----------------------------------------------------*/
+		case I2C_I2STAT_M_RX_ARB_LOST:
+			// update status
+			txrx_setup-&gt;status |= I2C_SETUP_STATUS_ARBF;
+		default:
+retry:
+			// check if retransmission is available
+			if (txrx_setup-&gt;retransmissions_count &lt; txrx_setup-&gt;retransmissions_max){
+				// Clear tx count
+				txrx_setup-&gt;tx_count = 0;
+				I2Cx-&gt;I2CONSET = I2C_I2CONSET_STA;
+				I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_AAC | I2C_I2CONCLR_SIC;
+				txrx_setup-&gt;retransmissions_count++;
+			}
+			// End of stage
+			else {
+end_stage:
+				// Disable interrupt
+				I2C_IntCmd(I2Cx, 0);
+				// Send stop
+				I2C_Stop(I2Cx);
+				// Call callback if installed
+				if (txrx_setup-&gt;callback != NULL){
+					txrx_setup-&gt;callback();
+				}
+			}
+			break;
+		}
+	}
+}
+
+
+/*********************************************************************//**
+ * @brief 		General Slave Interrupt handler for I2C peripheral
+ * @param[in]	I2Cx	I2C peripheral selected, should be I2C0, I2C1 or I2C2
+ * @return 		None
+ **********************************************************************/
+void I2C_SlaveHandler (LPC_I2C_TypeDef  *I2Cx)
+{
+	int32_t tmp;
+	uint8_t returnCode;
+	I2C_S_SETUP_Type *txrx_setup;
+	uint32_t timeout;
+
+	tmp = I2C_getNum(I2Cx);
+	txrx_setup = (I2C_S_SETUP_Type *) i2cdat[tmp].txrx_setup;
+
+	returnCode = (I2Cx-&gt;I2STAT &amp; I2C_STAT_CODE_BITMASK);
+	// Save current status
+	txrx_setup-&gt;status = returnCode;
+	// there's no relevant information
+	if (returnCode == I2C_I2STAT_NO_INF){
+		I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_SIC;
+		return;
+	}
+
+
+	switch (returnCode)
+	{
+
+	/* No status information */
+	case I2C_I2STAT_NO_INF:
+		I2Cx-&gt;I2CONSET = I2C_I2CONSET_AA;
+		I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_SIC;
+		break;
+
+	/* Reading phase -------------------------------------------------------- */
+	/* Own SLA+R has been received, ACK has been returned */
+	case I2C_I2STAT_S_RX_SLAW_ACK:
+	/* General call address has been received, ACK has been returned */
+	case I2C_I2STAT_S_RX_GENCALL_ACK:
+		I2Cx-&gt;I2CONSET = I2C_I2CONSET_AA;
+		I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_SIC;
+		break;
+
+	/* Previously addressed with own SLA;
+	 * DATA byte has been received;
+	 * ACK has been returned */
+	case I2C_I2STAT_S_RX_PRE_SLA_DAT_ACK:
+	/* DATA has been received, ACK hasn been return */
+	case I2C_I2STAT_S_RX_PRE_GENCALL_DAT_ACK:
+		/*
+		 * All data bytes that over-flow the specified receive
+		 * data length, just ignore them.
+		 */
+		if ((txrx_setup-&gt;rx_count &lt; txrx_setup-&gt;rx_length) \
+				&amp;&amp; (txrx_setup-&gt;rx_data != NULL)){
+			*(uint8_t *)(txrx_setup-&gt;rx_data + txrx_setup-&gt;rx_count) = (uint8_t)I2Cx-&gt;I2DAT;
+			txrx_setup-&gt;rx_count++;
+		}
+		I2Cx-&gt;I2CONSET = I2C_I2CONSET_AA;
+		I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_SIC;
+		break;
+
+	/* Previously addressed with own SLA;
+	 * DATA byte has been received;
+	 * NOT ACK has been returned */
+	case I2C_I2STAT_S_RX_PRE_SLA_DAT_NACK:
+	/* DATA has been received, NOT ACK has been returned */
+	case I2C_I2STAT_S_RX_PRE_GENCALL_DAT_NACK:
+		I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_SIC;
+		break;
+
+	/*
+	 * Note that: Return code only let us know a stop condition mixed
+	 * with a repeat start condition in the same code value.
+	 * So we should provide a time-out. In case this is really a stop
+	 * condition, this will return back after time out condition. Otherwise,
+	 * next session that is slave receive data will be completed.
+	 */
+
+	/* A Stop or a repeat start condition */
+	case I2C_I2STAT_S_RX_STA_STO_SLVREC_SLVTRX:
+		// Temporally lock the interrupt for timeout condition
+		I2C_IntCmd(I2Cx, 0);
+		I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_SIC;
+		// enable time out
+		timeout = I2C_SLAVE_TIME_OUT;
+		while(1){
+			if (I2Cx-&gt;I2CONSET &amp; I2C_I2CONSET_SI){
+				// re-Enable interrupt
+				I2C_IntCmd(I2Cx, 1);
+				break;
+			} else {
+				timeout--;
+				if (timeout == 0){
+					// timeout occur, it's really a stop condition
+					txrx_setup-&gt;status |= I2C_SETUP_STATUS_DONE;
+					goto s_int_end;
+				}
+			}
+		}
+		break;
+
+	/* Writing phase -------------------------------------------------------- */
+	/* Own SLA+R has been received, ACK has been returned */
+	case I2C_I2STAT_S_TX_SLAR_ACK:
+	/* Data has been transmitted, ACK has been received */
+	case I2C_I2STAT_S_TX_DAT_ACK:
+		/*
+		 * All data bytes that over-flow the specified receive
+		 * data length, just ignore them.
+		 */
+		if ((txrx_setup-&gt;tx_count &lt; txrx_setup-&gt;tx_length) \
+				&amp;&amp; (txrx_setup-&gt;tx_data != NULL)){
+			I2Cx-&gt;I2DAT = *(uint8_t *) (txrx_setup-&gt;tx_data + txrx_setup-&gt;tx_count);
+			txrx_setup-&gt;tx_count++;
+		}
+		I2Cx-&gt;I2CONSET = I2C_I2CONSET_AA;
+		I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_SIC;
+		break;
+
+	/* Data has been transmitted, NACK has been received,
+	 * that means there's no more data to send, exit now */
+	/*
+	 * Note: Don't wait for stop event since in slave transmit mode,
+	 * since there no proof lets us know when a stop signal has been received
+	 * on slave side.
+	 */
+	case I2C_I2STAT_S_TX_DAT_NACK:
+		I2Cx-&gt;I2CONSET = I2C_I2CONSET_AA;
+		I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_SIC;
+		txrx_setup-&gt;status |= I2C_SETUP_STATUS_DONE;
+		goto s_int_end;
+		break;
+
+	// Other status must be captured
+	default:
+s_int_end:
+		// Disable interrupt
+		I2C_IntCmd(I2Cx, 0);
+		I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_AAC | I2C_I2CONCLR_SIC | I2C_I2CONCLR_STAC;
+		// Call callback if installed
+		if (txrx_setup-&gt;callback != NULL){
+			txrx_setup-&gt;callback();
+		}
+		break;
+	}
+}
+
+/**
+ * @}
+ */
+
+
+/* Public Functions ----------------------------------------------------------- */
+/** @addtogroup I2C_Public_Functions
+ * @{
+ */
+
+/*********************************************************************//**
+ * @brief 		Setup clock rate for I2C peripheral
+ * @param[in] 	I2Cx	I2C peripheral selected, should be I2C0, I2C1 or I2C2
+ * @param[in]	target_clock : clock of SSP (Hz)
+ * @return 		None
+ ***********************************************************************/
+void I2C_SetClock (LPC_I2C_TypeDef *I2Cx, uint32_t target_clock)
+{
+	uint32_t temp;
+
+	CHECK_PARAM(PARAM_I2Cx(I2Cx));
+
+	// Get PCLK of I2C controller
+	if (I2Cx == LPC_I2C0)
+	{
+		temp = CLKPWR_GetPCLK (CLKPWR_PCLKSEL_I2C0) / target_clock;
+	}
+	else if (I2Cx == LPC_I2C1)
+	{
+		temp = CLKPWR_GetPCLK (CLKPWR_PCLKSEL_I2C1) / target_clock;
+	}
+	else if (I2Cx == LPC_I2C2)
+	{
+		temp = CLKPWR_GetPCLK (CLKPWR_PCLKSEL_I2C1) / target_clock;
+	}
+
+	/* Set the I2C clock value to register */
+	I2Cx-&gt;I2SCLH = (uint32_t)(temp / 2);
+	I2Cx-&gt;I2SCLL = (uint32_t)(temp - I2Cx-&gt;I2SCLH);
+}
+
+
+/*********************************************************************//**
+ * @brief		De-initializes the I2C peripheral registers to their
+*                  default reset values.
+ * @param[in]	I2Cx	I2C peripheral selected, should be I2C0, I2C1 or I2C2
+ * @return 		None
+ **********************************************************************/
+void I2C_DeInit(LPC_I2C_TypeDef* I2Cx)
+{
+	CHECK_PARAM(PARAM_I2Cx(I2Cx));
+
+	/* Disable I2C control */
+	I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_I2ENC;
+
+	if (I2Cx==LPC_I2C0)
+	{
+		/* Disable power for I2C0 module */
+		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCI2C0, DISABLE);
+	}
+	else if (I2Cx==LPC_I2C1)
+	{
+		/* Disable power for I2C1 module */
+		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCI2C1, DISABLE);
+	}
+	else if (I2Cx==LPC_I2C2)
+	{
+		/* Disable power for I2C2 module */
+		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCI2C2, DISABLE);
+	}
+}
+
+
+/********************************************************************//**
+ * @brief		Initializes the I2Cx peripheral with specified parameter.
+ * @param[in]	I2Cx	I2C peripheral selected, should be I2C0, I2C1 or I2C2
+ * @param[in]	clockrate Target clock rate value to initialized I2C
+ * 				peripheral
+ * @return 		None
+ *********************************************************************/
+void I2C_Init(LPC_I2C_TypeDef *I2Cx, uint32_t clockrate)
+{
+	CHECK_PARAM(PARAM_I2Cx(I2Cx));
+
+	if (I2Cx==LPC_I2C0)
+	{
+		/* Set up clock and power for I2C0 module */
+		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCI2C0, ENABLE);
+		/* As default, peripheral clock for I2C0 module
+		 * is set to FCCLK / 2 */
+		CLKPWR_SetPCLKDiv(CLKPWR_PCLKSEL_I2C0, CLKPWR_PCLKSEL_CCLK_DIV_2);
+	}
+	else if (I2Cx==LPC_I2C1)
+	{
+		/* Set up clock and power for I2C1 module */
+		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCI2C1, ENABLE);
+		/* As default, peripheral clock for I2C1 module
+		 * is set to FCCLK / 2 */
+		CLKPWR_SetPCLKDiv(CLKPWR_PCLKSEL_I2C1, CLKPWR_PCLKSEL_CCLK_DIV_2);
+	}
+	else if (I2Cx==LPC_I2C2)
+	{
+		/* Set up clock and power for I2C2 module */
+		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCI2C2, ENABLE);
+		/* As default, peripheral clock for I2C2 module
+		 * is set to FCCLK / 2 */
+		CLKPWR_SetPCLKDiv(CLKPWR_PCLKSEL_I2C2, CLKPWR_PCLKSEL_CCLK_DIV_2);
+	}
+	else {
+		// Up-Support this device
+		return;
+	}
+
+    /* Set clock rate */
+    I2C_SetClock(I2Cx, clockrate);
+    /* Set I2C operation to default */
+    I2Cx-&gt;I2CONCLR = (I2C_I2CONCLR_AAC | I2C_I2CONCLR_STAC | I2C_I2CONCLR_I2ENC);
+}
+
+
+/*********************************************************************//**
+ * @brief		Enable or disable I2C peripheral's operation
+ * @param[in]	I2Cx I2C peripheral selected, should be I2C0, I2C1 or I2C2
+ * @param[in]	NewState New State of I2Cx peripheral's operation
+ * @return 		none
+ **********************************************************************/
+void I2C_Cmd(LPC_I2C_TypeDef* I2Cx, FunctionalState NewState)
+{
+	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
+	CHECK_PARAM(PARAM_I2Cx(I2Cx));
+
+	if (NewState == ENABLE)
+	{
+		I2Cx-&gt;I2CONSET = I2C_I2CONSET_I2EN;
+	}
+	else
+	{
+		I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_I2ENC;
+	}
+}
+
+
+/*********************************************************************//**
+ * @brief 		Transmit and Receive data in master mode
+ * @param[in]	I2Cx			I2C peripheral selected, should be I2C0, I2C1 or I2C2
+ * @param[in]	TransferCfg		Pointer to a I2C_M_SETUP_Type structure that
+ * 								contains specified information about the
+ * 								configuration for master transfer.
+ * @param[in]	Opt				a I2C_TRANSFER_OPT_Type type that selected for
+ * 								interrupt or polling mode.
+ * @return 		SUCCESS or ERROR
+ *
+ * Note:
+ * - In case of using I2C to transmit data only, either transmit length set to 0
+ * or transmit data pointer set to NULL.
+ * - In case of using I2C to receive data only, either receive length set to 0
+ * or receive data pointer set to NULL.
+ * - In case of using I2C to transmit followed by receive data, transmit length,
+ * transmit data pointer, receive length and receive data pointer should be set
+ * corresponding.
+ **********************************************************************/
+Status I2C_MasterTransferData(LPC_I2C_TypeDef *I2Cx, I2C_M_SETUP_Type *TransferCfg, \
+								I2C_TRANSFER_OPT_Type Opt)
+{
+	uint8_t *txdat;
+	uint8_t *rxdat;
+	uint32_t CodeStatus;
+	uint8_t tmp;
+
+	// reset all default state
+	txdat = (uint8_t *) TransferCfg-&gt;tx_data;
+	rxdat = (uint8_t *) TransferCfg-&gt;rx_data;
+	// Reset I2C setup value to default state
+	TransferCfg-&gt;tx_count = 0;
+	TransferCfg-&gt;rx_count = 0;
+	TransferCfg-&gt;status = 0;
+
+	if (Opt == I2C_TRANSFER_POLLING){
+
+		/* First Start condition -------------------------------------------------------------- */
+		TransferCfg-&gt;retransmissions_count = 0;
+retry:
+		// reset all default state
+		txdat = (uint8_t *) TransferCfg-&gt;tx_data;
+		rxdat = (uint8_t *) TransferCfg-&gt;rx_data;
+		// Reset I2C setup value to default state
+		TransferCfg-&gt;tx_count = 0;
+		TransferCfg-&gt;rx_count = 0;
+		CodeStatus = 0;
+
+		// Start command
+		CodeStatus = I2C_Start(I2Cx);
+		if ((CodeStatus != I2C_I2STAT_M_TX_START) \
+				&amp;&amp; (CodeStatus != I2C_I2STAT_M_TX_RESTART)){
+			TransferCfg-&gt;retransmissions_count++;
+			if (TransferCfg-&gt;retransmissions_count &gt; TransferCfg-&gt;retransmissions_max){
+				// save status
+				TransferCfg-&gt;status = CodeStatus;
+				goto error;
+			} else {
+				goto retry;
+			}
+		}
+
+		/* In case of sending data first --------------------------------------------------- */
+		if ((TransferCfg-&gt;tx_length != 0) &amp;&amp; (TransferCfg-&gt;tx_data != NULL)){
+
+			/* Send slave address + WR direction bit = 0 ----------------------------------- */
+			CodeStatus = I2C_SendByte(I2Cx, (TransferCfg-&gt;sl_addr7bit &lt;&lt; 1));
+			if (CodeStatus != I2C_I2STAT_M_TX_SLAW_ACK){
+				TransferCfg-&gt;retransmissions_count++;
+				if (TransferCfg-&gt;retransmissions_count &gt; TransferCfg-&gt;retransmissions_max){
+					// save status
+					TransferCfg-&gt;status = CodeStatus | I2C_SETUP_STATUS_NOACKF;
+					goto error;
+				} else {
+					goto retry;
+				}
+			}
+
+			/* Send a number of data bytes ---------------------------------------- */
+			while (TransferCfg-&gt;tx_count &lt; TransferCfg-&gt;tx_length)
+			{
+				CodeStatus = I2C_SendByte(I2Cx, *txdat);
+				if (CodeStatus != I2C_I2STAT_M_TX_DAT_ACK){
+					TransferCfg-&gt;retransmissions_count++;
+					if (TransferCfg-&gt;retransmissions_count &gt; TransferCfg-&gt;retransmissions_max){
+						// save status
+						TransferCfg-&gt;status = CodeStatus | I2C_SETUP_STATUS_NOACKF;
+						goto error;
+					} else {
+						goto retry;
+					}
+				}
+
+				txdat++;
+				TransferCfg-&gt;tx_count++;
+			}
+		}
+
+		/* Second Start condition (Repeat Start) ------------------------------------------- */
+		if ((TransferCfg-&gt;tx_length != 0) &amp;&amp; (TransferCfg-&gt;tx_data != NULL) \
+				&amp;&amp; (TransferCfg-&gt;rx_length != 0) &amp;&amp; (TransferCfg-&gt;rx_data != NULL)){
+
+			CodeStatus = I2C_Start(I2Cx);
+			if ((CodeStatus != I2C_I2STAT_M_RX_START) \
+					&amp;&amp; (CodeStatus != I2C_I2STAT_M_RX_RESTART)){
+				TransferCfg-&gt;retransmissions_count++;
+				if (TransferCfg-&gt;retransmissions_count &gt; TransferCfg-&gt;retransmissions_max){
+					// Update status
+					TransferCfg-&gt;status = CodeStatus;
+					goto error;
+				} else {
+					goto retry;
+				}
+			}
+		}
+
+		/* Then, start reading after sending data -------------------------------------- */
+		if ((TransferCfg-&gt;rx_length != 0) &amp;&amp; (TransferCfg-&gt;rx_data != NULL)){
+			/* Send slave address + RD direction bit = 1 ----------------------------------- */
+
+			CodeStatus = I2C_SendByte(I2Cx, ((TransferCfg-&gt;sl_addr7bit &lt;&lt; 1) | 0x01));
+			if (CodeStatus != I2C_I2STAT_M_RX_SLAR_ACK){
+				TransferCfg-&gt;retransmissions_count++;
+				if (TransferCfg-&gt;retransmissions_count &gt; TransferCfg-&gt;retransmissions_max){
+					// update status
+					TransferCfg-&gt;status = CodeStatus | I2C_SETUP_STATUS_NOACKF;
+					goto error;
+				} else {
+					goto retry;
+				}
+			}
+
+			/* Receive a number of data bytes ------------------------------------------------- */
+			while (TransferCfg-&gt;rx_count &lt; TransferCfg-&gt;rx_length){
+
+				/*
+				 * Note that: if data length is only one, the master should not
+				 * issue an ACK signal on bus after reading to avoid of next data frame
+				 * on slave side
+				 */
+				if (TransferCfg-&gt;rx_count &lt; (TransferCfg-&gt;rx_length - 1)){
+					// Issue an ACK signal for next data frame
+					CodeStatus = I2C_GetByte(I2Cx, &amp;tmp, 1);
+					if (CodeStatus != I2C_I2STAT_M_RX_DAT_ACK){
+						TransferCfg-&gt;retransmissions_count++;
+						if (TransferCfg-&gt;retransmissions_count &gt; TransferCfg-&gt;retransmissions_max){
+							// update status
+							TransferCfg-&gt;status = CodeStatus;
+							goto error;
+						} else {
+							goto retry;
+						}
+					}
+				} else {
+					// Do not issue an ACK signal
+					CodeStatus = I2C_GetByte(I2Cx, &amp;tmp, 0);
+					if (CodeStatus != I2C_I2STAT_M_RX_DAT_NACK){
+						TransferCfg-&gt;retransmissions_count++;
+						if (TransferCfg-&gt;retransmissions_count &gt; TransferCfg-&gt;retransmissions_max){
+							// update status
+							TransferCfg-&gt;status = CodeStatus;
+							goto error;
+						} else {
+							goto retry;
+						}
+					}
+				}
+				*rxdat++ = tmp;
+				TransferCfg-&gt;rx_count++;
+			}
+		}
+
+		/* Send STOP condition ------------------------------------------------- */
+		I2C_Stop(I2Cx);
+		return SUCCESS;
+
+error:
+		// Send stop condition
+		I2C_Stop(I2Cx);
+		return ERROR;
+	}
+
+	else if (Opt == I2C_TRANSFER_INTERRUPT){
+		// Setup tx_rx data, callback and interrupt handler
+		tmp = I2C_getNum(I2Cx);
+		i2cdat[tmp].txrx_setup = (uint32_t) TransferCfg;
+		i2cdat[tmp].inthandler = I2C_MasterHandler;
+		// Set direction phase, write first
+		i2cdat[tmp].dir = 0;
+
+		/* First Start condition -------------------------------------------------------------- */
+		I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_SIC;
+		I2Cx-&gt;I2CONSET = I2C_I2CONSET_STA;
+		I2C_IntCmd(I2Cx, 1);
+
+		return (SUCCESS);
+	}
+
+	return ERROR;
+}
+
+/*********************************************************************//**
+ * @brief 		Receive and Transmit data in slave mode
+ * @param[in]	I2Cx			I2C peripheral selected, should be I2C0, I2C1 or I2C2
+ * @param[in]	TransferCfg		Pointer to a I2C_S_SETUP_Type structure that
+ * 								contains specified information about the
+ * 								configuration for master transfer.
+ * @param[in]	Opt				I2C_TRANSFER_OPT_Type type that selected for
+ * 								interrupt or polling mode.
+ * @return 		SUCCESS or ERROR
+ *
+ * Note:
+ * The mode of slave's operation depends on the command sent from master on
+ * the I2C bus. If the master send a SLA+W command, this sub-routine will
+ * use receive data length and receive data pointer. If the master send a SLA+R
+ * command, this sub-routine will use transmit data length and transmit data
+ * pointer.
+ * If the master issue an repeat start command or a stop command, the slave will
+ * enable an time out condition, during time out condition, if there's no activity
+ * on I2C bus, the slave will exit, otherwise (i.e. the master send a SLA+R/W),
+ * the slave then switch to relevant operation mode. The time out should be used
+ * because the return status code can not show difference from stop and repeat
+ * start command in slave operation.
+ * In case of the expected data length from master is greater than data length
+ * that slave can support:
+ * - In case of reading operation (from master): slave will return I2C_I2DAT_IDLE_CHAR
+ * value.
+ * - In case of writing operation (from master): slave will ignore remain data from master.
+ **********************************************************************/
+Status I2C_SlaveTransferData(LPC_I2C_TypeDef *I2Cx, I2C_S_SETUP_Type *TransferCfg, \
+								I2C_TRANSFER_OPT_Type Opt)
+{
+	uint8_t *txdat;
+	uint8_t *rxdat;
+	uint32_t CodeStatus;
+	uint32_t timeout;
+	int32_t time_en;
+	int32_t tmp;
+
+	// reset all default state
+	txdat = (uint8_t *) TransferCfg-&gt;tx_data;
+	rxdat = (uint8_t *) TransferCfg-&gt;rx_data;
+	// Reset I2C setup value to default state
+	TransferCfg-&gt;tx_count = 0;
+	TransferCfg-&gt;rx_count = 0;
+	TransferCfg-&gt;status = 0;
+
+
+	// Polling option
+	if (Opt == I2C_TRANSFER_POLLING){
+
+		/* Set AA bit to ACK command on I2C bus */
+		I2Cx-&gt;I2CONSET = I2C_I2CONSET_AA;
+		/* Clear SI bit to be ready ... */
+		I2Cx-&gt;I2CONCLR = (I2C_I2CONCLR_SIC | I2C_I2CONCLR_STAC);
+
+		time_en = 0;
+		timeout = 0;
+
+		while (1)
+		{
+			/* Check SI flag ready */
+			if (I2Cx-&gt;I2CONSET &amp; I2C_I2CONSET_SI)
+			{
+				time_en = 0;
+
+				switch (CodeStatus = (I2Cx-&gt;I2STAT &amp; I2C_STAT_CODE_BITMASK))
+				{
+
+				/* No status information */
+				case I2C_I2STAT_NO_INF:
+					I2Cx-&gt;I2CONSET = I2C_I2CONSET_AA;
+					I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_SIC;
+					break;
+
+				/* Reading phase -------------------------------------------------------- */
+				/* Own SLA+R has been received, ACK has been returned */
+				case I2C_I2STAT_S_RX_SLAW_ACK:
+				/* General call address has been received, ACK has been returned */
+				case I2C_I2STAT_S_RX_GENCALL_ACK:
+					I2Cx-&gt;I2CONSET = I2C_I2CONSET_AA;
+					I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_SIC;
+					break;
+
+				/* Previously addressed with own SLA;
+				 * DATA byte has been received;
+				 * ACK has been returned */
+				case I2C_I2STAT_S_RX_PRE_SLA_DAT_ACK:
+				/* DATA has been received, ACK hasn been return */
+				case I2C_I2STAT_S_RX_PRE_GENCALL_DAT_ACK:
+					/*
+					 * All data bytes that over-flow the specified receive
+					 * data length, just ignore them.
+					 */
+					if ((TransferCfg-&gt;rx_count &lt; TransferCfg-&gt;rx_length) \
+							&amp;&amp; (TransferCfg-&gt;rx_data != NULL)){
+						*rxdat++ = (uint8_t)I2Cx-&gt;I2DAT;
+						TransferCfg-&gt;rx_count++;
+					}
+					I2Cx-&gt;I2CONSET = I2C_I2CONSET_AA;
+					I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_SIC;
+					break;
+
+				/* Previously addressed with own SLA;
+				 * DATA byte has been received;
+				 * NOT ACK has been returned */
+				case I2C_I2STAT_S_RX_PRE_SLA_DAT_NACK:
+				/* DATA has been received, NOT ACK has been returned */
+				case I2C_I2STAT_S_RX_PRE_GENCALL_DAT_NACK:
+					I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_SIC;
+					break;
+
+				/*
+				 * Note that: Return code only let us know a stop condition mixed
+				 * with a repeat start condition in the same code value.
+				 * So we should provide a time-out. In case this is really a stop
+				 * condition, this will return back after time out condition. Otherwise,
+				 * next session that is slave receive data will be completed.
+				 */
+
+				/* A Stop or a repeat start condition */
+				case I2C_I2STAT_S_RX_STA_STO_SLVREC_SLVTRX:
+					I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_SIC;
+					// enable time out
+					time_en = 1;
+					timeout = 0;
+					break;
+
+				/* Writing phase -------------------------------------------------------- */
+				/* Own SLA+R has been received, ACK has been returned */
+				case I2C_I2STAT_S_TX_SLAR_ACK:
+				/* Data has been transmitted, ACK has been received */
+				case I2C_I2STAT_S_TX_DAT_ACK:
+					/*
+					 * All data bytes that over-flow the specified receive
+					 * data length, just ignore them.
+					 */
+					if ((TransferCfg-&gt;tx_count &lt; TransferCfg-&gt;tx_length) \
+							&amp;&amp; (TransferCfg-&gt;tx_data != NULL)){
+						I2Cx-&gt;I2DAT = *txdat++;
+						TransferCfg-&gt;tx_count++;
+					}
+					I2Cx-&gt;I2CONSET = I2C_I2CONSET_AA;
+					I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_SIC;
+					break;
+
+				/* Data has been transmitted, NACK has been received,
+				 * that means there's no more data to send, exit now */
+				/*
+				 * Note: Don't wait for stop event since in slave transmit mode,
+				 * since there no proof lets us know when a stop signal has been received
+				 * on slave side.
+				 */
+				case I2C_I2STAT_S_TX_DAT_NACK:
+					I2Cx-&gt;I2CONSET = I2C_I2CONSET_AA;
+					I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_SIC;
+					// enable time out
+					time_en = 1;
+					timeout = 0;
+					break;
+
+				// Other status must be captured
+				default:
+					I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_SIC;
+					goto s_error;
+					break;
+				}
+			} else if (time_en){
+				if (timeout++ &gt; I2C_SLAVE_TIME_OUT){
+					// it's really a stop condition, goto end stage
+					goto s_end_stage;
+				}
+			}
+		}
+
+s_end_stage:
+		/* Clear AA bit to disable ACK on I2C bus */
+		I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_AAC;
+		// Check if there's no error during operation
+		// Update status
+		TransferCfg-&gt;status = CodeStatus | I2C_SETUP_STATUS_DONE;
+		return SUCCESS;
+
+s_error:
+		/* Clear AA bit to disable ACK on I2C bus */
+		I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_AAC;
+		// Update status
+		TransferCfg-&gt;status = CodeStatus;
+		return ERROR;
+	}
+
+	else if (Opt == I2C_TRANSFER_INTERRUPT){
+		// Setup tx_rx data, callback and interrupt handler
+		tmp = I2C_getNum(I2Cx);
+		i2cdat[tmp].txrx_setup = (uint32_t) TransferCfg;
+		i2cdat[tmp].inthandler = I2C_SlaveHandler;
+		// Set direction phase, read first
+		i2cdat[tmp].dir = 1;
+
+		// Enable AA
+		I2Cx-&gt;I2CONSET = I2C_I2CONSET_AA;
+		I2Cx-&gt;I2CONCLR = I2C_I2CONCLR_SIC | I2C_I2CONCLR_STAC;
+		I2C_IntCmd(I2Cx, 1);
+
+		return (SUCCESS);
+	}
+
+	return ERROR;
+}
+
+/*********************************************************************//**
+ * @brief		Set Own slave address in I2C peripheral corresponding to
+ * 				parameter specified in OwnSlaveAddrConfigStruct.
+ * @param[in]	I2Cx	I2C peripheral selected, should be I2C0, I2C1 or I2C2
+ * @param[in]	OwnSlaveAddrConfigStruct	Pointer to a I2C_OWNSLAVEADDR_CFG_Type
+ * 				structure that contains the configuration information for the
+*               specified I2C slave address.
+ * @return 		None
+ **********************************************************************/
+void I2C_SetOwnSlaveAddr(LPC_I2C_TypeDef *I2Cx, I2C_OWNSLAVEADDR_CFG_Type *OwnSlaveAddrConfigStruct)
+{
+	uint32_t tmp;
+	CHECK_PARAM(PARAM_I2Cx(I2Cx));
+	CHECK_PARAM(PARAM_I2C_SLAVEADDR_CH(OwnSlaveAddrConfigStruct-&gt;SlaveAddrChannel));
+	CHECK_PARAM(PARAM_FUNCTIONALSTATE(OwnSlaveAddrConfigStruct-&gt;GeneralCallState));
+
+	tmp = (((uint32_t)(OwnSlaveAddrConfigStruct-&gt;SlaveAddr_7bit &lt;&lt; 1)) \
+			| ((OwnSlaveAddrConfigStruct-&gt;GeneralCallState == ENABLE) ? 0x01 : 0x00))&amp; I2C_I2ADR_BITMASK;
+	switch (OwnSlaveAddrConfigStruct-&gt;SlaveAddrChannel)
+	{
+	case 0:
+		I2Cx-&gt;I2ADR0 = tmp;
+		I2Cx-&gt;I2MASK0 = I2C_I2MASK_MASK((uint32_t) \
+				(OwnSlaveAddrConfigStruct-&gt;SlaveAddrMaskValue));
+		break;
+	case 1:
+		I2Cx-&gt;I2ADR1 = tmp;
+		I2Cx-&gt;I2MASK1 = I2C_I2MASK_MASK((uint32_t) \
+				(OwnSlaveAddrConfigStruct-&gt;SlaveAddrMaskValue));
+		break;
+	case 2:
+		I2Cx-&gt;I2ADR2 = tmp;
+		I2Cx-&gt;I2MASK2 = I2C_I2MASK_MASK((uint32_t) \
+				(OwnSlaveAddrConfigStruct-&gt;SlaveAddrMaskValue));
+		break;
+	case 3:
+		I2Cx-&gt;I2ADR3 = tmp;
+		I2Cx-&gt;I2MASK3 = I2C_I2MASK_MASK((uint32_t) \
+				(OwnSlaveAddrConfigStruct-&gt;SlaveAddrMaskValue));
+		break;
+	}
+}
+
+
+/*********************************************************************//**
+ * @brief		Configures functionality in I2C monitor mode
+ * @param[in]	I2Cx	I2C peripheral selected, should be I2C0, I2C1 or I2C2
+ * @param[in]	MonitorCfgType Monitor Configuration type, should be:
+ * 				- I2C_MONITOR_CFG_SCL_OUTPUT: I2C module can 'stretch'
+ * 				the clock line (hold it low) until it has had time to
+ * 				respond to an I2C interrupt.
+ * 				- I2C_MONITOR_CFG_MATCHALL: When this bit is set to '1'
+ * 				and the I2C is in monitor mode, an interrupt will be
+ * 				generated on ANY address received.
+ * @param[in]	NewState New State of this function, should be:
+ * 				- ENABLE: Enable this function.
+ * 				- DISABLE: Disable this function.
+ * @return		None
+ **********************************************************************/
+void I2C_MonitorModeConfig(LPC_I2C_TypeDef *I2Cx, uint32_t MonitorCfgType, FunctionalState NewState)
+{
+	CHECK_PARAM(PARAM_I2Cx(I2Cx));
+	CHECK_PARAM(PARAM_I2C_MONITOR_CFG(MonitorCfgType));
+	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
+
+	if (NewState == ENABLE)
+	{
+		I2Cx-&gt;MMCTRL |= MonitorCfgType;
+	}
+	else
+	{
+		I2Cx-&gt;MMCTRL &amp;= (~MonitorCfgType) &amp; I2C_I2MMCTRL_BITMASK;
+	}
+}
+
+
+/*********************************************************************//**
+ * @brief		Enable/Disable I2C monitor mode
+ * @param[in]	I2Cx	I2C peripheral selected, should be I2C0, I2C1 or I2C2
+ * @param[in]	NewState New State of this function, should be:
+ * 				- ENABLE: Enable monitor mode.
+ * 				- DISABLE: Disable monitor mode.
+ * @return		None
+ **********************************************************************/
+void I2C_MonitorModeCmd(LPC_I2C_TypeDef *I2Cx, FunctionalState NewState)
+{
+	CHECK_PARAM(PARAM_I2Cx(I2Cx));
+	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
+
+	if (NewState == ENABLE)
+	{
+		I2Cx-&gt;MMCTRL |= I2C_I2MMCTRL_MM_ENA;
+	}
+	else
+	{
+		I2Cx-&gt;MMCTRL &amp;= (~I2C_I2MMCTRL_MM_ENA) &amp; I2C_I2MMCTRL_BITMASK;
+	}
+}
+
+
+/*********************************************************************//**
+ * @brief		Get data from I2C data buffer in monitor mode.
+ * @param[in]	I2Cx	I2C peripheral selected, should be I2C0, I2C1 or I2C2
+ * @return		None
+ * Note:	In monitor mode, the I2C module may lose the ability to stretch
+ * the clock (stall the bus) if the ENA_SCL bit is not set. This means that
+ * the processor will have a limited amount of time to read the contents of
+ * the data received on the bus. If the processor reads the I2DAT shift
+ * register, as it ordinarily would, it could have only one bit-time to
+ * respond to the interrupt before the received data is overwritten by
+ * new data.
+ **********************************************************************/
+uint8_t I2C_MonitorGetDatabuffer(LPC_I2C_TypeDef *I2Cx)
+{
+	CHECK_PARAM(PARAM_I2Cx(I2Cx));
+	return ((uint8_t)(I2Cx-&gt;I2DATA_BUFFER));
+}
+
+/*********************************************************************//**
+ * @brief 		Standard Interrupt handler for I2C0 peripheral
+ * @param[in]	None
+ * @return 		None
+ **********************************************************************/
+void I2C0_StdIntHandler(void)
+{
+	i2cdat[0].inthandler(LPC_I2C0);
+}
+
+/*********************************************************************//**
+ * @brief 		Standard Interrupt handler for I2C1 peripheral
+ * @param[in]	None
+ * @return 		None
+ **********************************************************************/
+void I2C1_StdIntHandler(void)
+{
+	i2cdat[1].inthandler(LPC_I2C1);
+}
+
+/*********************************************************************//**
+ * @brief 		Standard Interrupt handler for I2C2 peripheral
+ * @param[in]	None
+ * @return 		None
+ **********************************************************************/
+void I2C2_StdIntHandler(void)
+{
+	i2cdat[2].inthandler(LPC_I2C2);
+}
+
+
+/**
+ * @}
+ */
+
+#endif /* _I2C */
+
+/**
+ * @}
+ */
+
+/* --------------------------------- End Of File ------------------------------ */


Property changes on: trunk/src/platform/lpc17xx/drivers/src/lpc17xx_i2c.c
___________________________________________________________________
Deleted: svn:executable
   - *

Modified: trunk/src/platform/lpc17xx/drivers/src/lpc17xx_i2s.c
===================================================================
--- trunk/src/platform/lpc17xx/drivers/src/lpc17xx_i2s.c	2010-06-28 21:53:59 UTC (rev 759)
+++ trunk/src/platform/lpc17xx/drivers/src/lpc17xx_i2s.c	2010-07-12 20:56:54 UTC (rev 760)
@@ -1,661 +1,653 @@
-/**
- * @file	: lpc17xx_i2s.c
- * @brief	: Contains all functions support for I2S firmware library on LPC17xx
- * @version	: 1.0
- * @date	: 13. May. 2009
- * @author	: NguyenCao
- *----------------------------------------------------------------------------
- * Software that is described herein is for illustrative purposes only
- * which provides customers with programming information regarding the
- * products. This software is supplied &quot;AS IS&quot; without any warranties.
- * NXP Semiconductors assumes no responsibility or liability for the
- * use of the software, conveys no license or title under any patent,
- * copyright, or mask work right to the product. NXP Semiconductors
- * reserves the right to make changes in the software without
- * notification. NXP Semiconductors also make no representation or
- * warranty that such application will be suitable for the specified
- * use without further testing or modification.
- **********************************************************************/
-
-/* Peripheral group ----------------------------------------------------------- */
-/** @addtogroup I2S
- * @{
- */
-
-/* Includes ------------------------------------------------------------------- */
-#include &quot;lpc17xx_i2s.h&quot;
-#include &quot;lpc17xx_clkpwr.h&quot;
-
-
-/* If this source file built with example, the LPC17xx FW library configuration
- * file in each example directory (&quot;lpc17xx_libcfg.h&quot;) must be included,
- * otherwise the default FW library configuration file must be included instead
- */
-#ifdef __BUILD_WITH_EXAMPLE__
-#include &quot;lpc17xx_libcfg.h&quot;
-#else
-#include &quot;lpc17xx_libcfg_default.h&quot;
-#endif /* __BUILD_WITH_EXAMPLE__ */
-
-
-#ifdef _I2S
-
-/* Private Variables ---------------------------------------------------------- */
-/** @defgroup I2S_Private_Variables
- * @{
- */
-
-static fnI2SCbs_Type *_apfnI2SCbs[2] = {
-		NULL, 	// I2S transmit Call-back function pointer
-		NULL, 	// I2S receive Call-back function pointer
-};
-
-/**
- * @}
- */
-
-
-/* Private Functions ---------------------------------------------------------- */
-/** @defgroup I2S_Private_Functions
- * @{
- */
-
-/********************************************************************//**
- * @brief		Get I2S wordwidth value
- * @param[in]	I2Sx: I2S peripheral selected, should be: I2S
- * @param[in]	TRMode is the I2S mode, should be:
- * 				- I2S_TX_MODE: transmit mode
- * 				- I2S_RX_MODE: receive mode
- * @return 		The wordwidth value, should be: 8,16 or 32
- *********************************************************************/
-uint8_t I2S_GetWordWidth(I2S_TypeDef *I2Sx, uint8_t TRMode) {
-	uint8_t value;
-
-	CHECK_PARAM(PARAM_I2Sx(I2Sx));
-	CHECK_PARAM(PARAM_I2S_TRX(TRMode));
-
-	if (TRMode == I2S_TX_MODE) {
-		value = (I2Sx-&gt;I2SDAO) &amp; 0x03; /* get wordwidth bit */
-	} else {
-		value = (I2Sx-&gt;I2SDAI) &amp; 0x03; /* get wordwidth bit */
-	}
-	switch (value) {
-	case I2S_WORDWIDTH_8:
-		return 8;
-		break;
-	case I2S_WORDWIDTH_16:
-		return 16;
-		break;
-	default:
-		return 32;
-	}
-}
-/********************************************************************//**
- * @brief		Get I2S channel value
- * @param[in]	I2Sx: I2S peripheral selected, should be: I2S
- * @param[in]	TRMode is the I2S mode, should be:
- * 				- I2S_TX_MODE: transmit mode
- * 				- I2S_RX_MODE: receive mode
- * @return 		The channel value, should be: 1(mono) or 2(stereo)
- *********************************************************************/
-uint8_t I2S_GetChannel(I2S_TypeDef *I2Sx, uint8_t TRMode) {
-	uint8_t value;
-
-	CHECK_PARAM(PARAM_I2Sx(I2Sx));
-	CHECK_PARAM(PARAM_I2S_TRX(TRMode));
-
-	if (TRMode == I2S_TX_MODE) {
-		value = (I2Sx-&gt;I2SDAO) &amp; 0x04; /* get bit[2] */
-	} else {
-		value = (I2Sx-&gt;I2SDAI) &amp; 0x04; /* get bit[2] */
-	}
-	switch (value) {
-	case I2S_MONO:
-		return 1;
-		break;
-	default:
-		return 2;
-	}
-}
-
-/**
- * @}
- */
-
-
-/* Public Functions ----------------------------------------------------------- */
-/** @addtogroup I2S_Public_Functions
- * @{
- */
-
-/********************************************************************//**
- * @brief		Initialize I2S
- * 					- Turn on power and clock
- * 					- Setup I2S pin select
- * @param[in]	I2Sx: I2S peripheral selected, should be: I2S
- * @return 		none
- *********************************************************************/
-void I2S_Init(I2S_TypeDef *I2Sx) {
-	CHECK_PARAM(PARAM_I2Sx(I2Sx));
-
-	// Turn on power and clock
-	CLKPWR_ConfigPPWR(CLKPWR_PCONP_PCI2S, ENABLE);
-	I2S-&gt;I2SDAI = I2S-&gt;I2SDAO = 0x00;
-}
-
-/********************************************************************//**
- * @brief		Configuration I2S, setting:
- * 					- master/slave mode
- * 					- wordwidth value
- * 					- channel mode
- * @param[in]	I2Sx: I2S peripheral selected, should be: I2S
- * @param[in]	TRMode: transmit/receive mode, should be:
- * 					- I2S_TX_MODE: transmit mode
- * 					- I2S_RX_MODE: receive mode
- * @param[in]	ConfigStruct pointer to I2S_CFG_Type structure
- *              which will be initialized.
- * @return 		none
- *********************************************************************/
-void I2S_Config(I2S_TypeDef *I2Sx, uint8_t TRMode, I2S_CFG_Type* ConfigStruct)
-{
-	uint32_t bps, config;
-
-	CHECK_PARAM(PARAM_I2Sx(I2Sx));
-
-	CHECK_PARAM(PARAM_I2S_WORDWIDTH(ConfigStruct-&gt;wordwidth));
-	CHECK_PARAM(PARAM_I2S_CHANNEL(ConfigStruct-&gt;mono));
-	CHECK_PARAM(PARAM_I2S_STOP(ConfigStruct-&gt;stop));
-	CHECK_PARAM(PARAM_I2S_RESET(ConfigStruct-&gt;reset));
-	CHECK_PARAM(PARAM_I2S_WS_SEL(ConfigStruct-&gt;ws_sel));
-	CHECK_PARAM(PARAM_I2S_MUTE(ConfigStruct-&gt;mute));
-
-	/* Setup clock */
-	bps = (ConfigStruct-&gt;wordwidth +1)*8;
-
-	/* Calculate audio config */
-	config = (bps - 1)&lt;&lt;6 | (ConfigStruct-&gt;ws_sel)&lt;&lt;5 | (ConfigStruct-&gt;reset)&lt;&lt;4 |
-		(ConfigStruct-&gt;stop)&lt;&lt;3 | (ConfigStruct-&gt;mono)&lt;&lt;2 | (ConfigStruct-&gt;wordwidth);
-
-	if(TRMode == I2S_RX_MODE){
-		I2S-&gt;I2SDAI = config;
-	}else{
-		I2S-&gt;I2SDAO = config;
-	}
-}
-
-/********************************************************************//**
- * @brief		DeInitial both I2S transmit or receive
- * @param[in]	I2Sx: I2S peripheral selected, should be: I2S
- * @return 		none
- *********************************************************************/
-void I2S_DeInit(I2S_TypeDef *I2Sx) {
-	CHECK_PARAM(PARAM_I2Sx(I2Sx));
-
-	// Turn off power and clock
-	CLKPWR_ConfigPPWR(CLKPWR_PCONP_PCI2S, DISABLE);
-}
-
-/********************************************************************//**
- * @brief		Get I2S Buffer Level
- * @param[in]	I2Sx: I2S peripheral selected, should be: I2S
- * @param[in]	TRMode: Transmit/receive mode, should be:
- * 					- I2S_TX_MODE: transmit mode
- * 					- I2S_RX_MODE: receive mode
- * @return 		current level of Transmit/Receive Buffer
- *********************************************************************/
-uint8_t I2S_GetLevel(I2S_TypeDef *I2Sx, uint8_t TRMode)
-{
-	CHECK_PARAM(PARAM_I2Sx(I2Sx));
-	CHECK_PARAM(PARAM_I2S_TRX(TRMode));
-
-	if(TRMode == I2S_TX_MODE)
-	{
-		return ((I2Sx-&gt;I2SSTATE &gt;&gt; 16) &amp; 0xFF);
-	}
-	else
-	{
-		return ((I2Sx-&gt;I2SSTATE &gt;&gt; 8) &amp; 0xFF);
-	}
-}
-/********************************************************************//**
- * @brief		I2S Start: clear all STOP,RESET and MUTE bit, ready to operate
- * @param[in]	I2Sx: I2S peripheral selected, should be: I2S
- * @return 		none
- *********************************************************************/
-void I2S_Start(I2S_TypeDef *I2Sx)
-{
-	//Clear STOP,RESET and MUTE bit
-	I2Sx-&gt;I2SDAO &amp;= ~I2S_DAI_RESET;
-	I2Sx-&gt;I2SDAI &amp;= ~I2S_DAI_RESET;
-	I2Sx-&gt;I2SDAO &amp;= ~I2S_DAI_STOP;
-	I2Sx-&gt;I2SDAI &amp;= ~I2S_DAI_STOP;
-	I2Sx-&gt;I2SDAO &amp;= ~I2S_DAI_MUTE;
-}
-/********************************************************************//**
- * @brief		I2S Send data
- * @param[in]	I2Sx: I2S peripheral selected, should be: I2S
- * @param[in]	BufferData pointer to uint32_t is the data will be send
- * @return 		none
- *********************************************************************/
-void I2S_Send(I2S_TypeDef *I2Sx, uint32_t BufferData) {
-	CHECK_PARAM(PARAM_I2Sx(I2Sx));
-	CHECK_PARAM(PARAM_I2S_DATA(BufferData));
-
-	I2Sx-&gt;I2STXFIFO = BufferData;
-}
-
-/********************************************************************//**
- * @brief		I2S Receive Data
- * @param[in]	I2Sx pointer to I2S_TypeDef
- * @return 		received value
- *********************************************************************/
-uint32_t I2S_Receive(I2S_TypeDef* I2Sx) {
-	CHECK_PARAM(PARAM_I2Sx(I2Sx));
-
-	return (I2Sx-&gt;I2SRXFIFO);
-
-}
-/********************************************************************//**
- * @brief		I2S Pause
- * @param[in]	I2Sx: I2S peripheral selected, should be: I2S
- * @param[in]	TRMode is transmit/receive mode, should be:
- * 				- I2S_TX_MODE: transmit mode
- * 				- I2S_RX_MODE: receive mode
- * @return 		none
- *********************************************************************/
-void I2S_Pause(I2S_TypeDef *I2Sx, uint8_t TRMode) {
-	CHECK_PARAM(PARAM_I2Sx(I2Sx));
-	CHECK_PARAM(PARAM_I2S_TRX(TRMode));
-
-	if (TRMode == I2S_TX_MODE) //Transmit mode
-	{
-		I2Sx-&gt;I2SDAO |= I2S_DAO_STOP;
-	} else //Receive mode
-	{
-		I2Sx-&gt;I2SDAI |= I2S_DAI_STOP;
-	}
-}
-/********************************************************************//**
- * @brief		I2S Mute
- * @param[in]	I2Sx: I2S peripheral selected, should be: I2S
- * @param[in]	TRMode is transmit/receive mode, should be:
- * 				- I2S_TX_MODE: transmit mode
- * 				- I2S_RX_MODE: receive mode
- * @return 		none
- *********************************************************************/
-void I2S_Mute(I2S_TypeDef *I2Sx, uint8_t TRMode) {
-	CHECK_PARAM(PARAM_I2Sx(I2Sx));
-	CHECK_PARAM(PARAM_I2S_TRX(TRMode));
-
-	if (TRMode == I2S_TX_MODE) //Transmit mode
-	{
-		I2Sx-&gt;I2SDAO |= I2S_DAO_MUTE;
-	} else //Receive mode
-	{
-		I2Sx-&gt;I2SDAI |= I2S_DAI_MUTE;
-	}
-}
-
-/********************************************************************//**
- * @brief		I2S Stop
- * @param[in]	I2Sx: I2S peripheral selected, should be: I2S
- * @param[in]	TRMode is transmit/receive mode, should be:
- * 				- I2S_TX_MODE: transmit mode
- * 				- I2S_RX_MODE: receive mode
- * @return 		none
- *********************************************************************/
-void I2S_Stop(I2S_TypeDef *I2Sx, uint8_t TRMode) {
-	CHECK_PARAM(PARAM_I2Sx(I2Sx));
-	CHECK_PARAM(PARAM_I2S_TRX(TRMode));
-
-	if (TRMode == I2S_TX_MODE) //Transmit mode
-	{
-		I2Sx-&gt;I2SDAO &amp;= ~I2S_DAO_MUTE;
-		I2Sx-&gt;I2SDAO |= I2S_DAO_STOP;
-		I2Sx-&gt;I2SDAO |= I2S_DAO_RESET;
-	} else //Receive mode
-	{
-		I2Sx-&gt;I2SDAI |= I2S_DAI_STOP;
-		I2Sx-&gt;I2SDAI |= I2S_DAI_RESET;
-	}
-}
-
-/********************************************************************//**
- * @brief		Set frequency for I2S
- * @param[in]	I2Sx: I2S peripheral selected, should be: I2S
- * @param[in]	Freq is the frequency for I2S will be set. It can range
- * 				from 16-96 kHz(16, 22.05, 32, 44.1, 48, 96kHz)
- * @param[in]	TRMode is transmit/receive mode, should be:
- * 				- I2S_TX_MODE: transmit mode
- * 				- I2S_RX_MODE: receive mode
- * @return 		Status: ERROR or SUCCESS
- *********************************************************************/
-Status I2S_FreqConfig(I2S_TypeDef *I2Sx, uint32_t Freq, uint8_t TRMode) {
-
-	/* Calculate bit rate
-	 * The formula is:
-	 *      bit_rate = channel*wordwidth - 1
-	 * 48kHz sample rate for 16 bit stereo date requires
-	 * a bit rate of 48000*16*2=1536MHz (MCLK)
-	 */
-	uint32_t i2sPclk;
-	uint64_t divider;
-	uint8_t bitrate, channel, wordwidth;
-	uint32_t x, y;
-	uint16_t dif;
-	uint16_t error;
-	uint8_t x_divide, y_divide;
-	uint16_t ErrorOptimal = 0xFFFF;
-
-	CHECK_PARAM(PARAM_I2Sx(I2Sx));
-	CHECK_PARAM(PRAM_I2S_FREQ(Freq));
-	CHECK_PARAM(PARAM_I2S_TRX(TRMode));
-
-	i2sPclk = CLKPWR_GetPCLK(CLKPWR_PCLKSEL_I2S);
-	if(TRMode == I2S_TX_MODE)
-	{
-		channel = I2S_GetChannel(I2Sx,I2S_TX_MODE);
-		wordwidth = I2S_GetWordWidth(I2Sx,I2S_TX_MODE);
-	}
-	else
-	{
-		channel = I2S_GetChannel(I2Sx,I2S_RX_MODE);
-		wordwidth = I2S_GetWordWidth(I2Sx,I2S_RX_MODE);
-	}
-	bitrate = channel * wordwidth - 1;
-	if (TRMode == I2S_TX_MODE)// Transmitter
-	{
-		I2Sx-&gt;I2STXBITRATE = bitrate;
-	} else //Receiver
-	{
-		I2Sx-&gt;I2SRXBITRATE = bitrate;
-	}
-	/* Calculate X and Y divider
-	 * The MCLK rate for the I2S transmitter is determined by the value
-	 * in the I2STXRATE/I2SRXRATE register. The required I2STXRATE/I2SRXRATE
-	 * setting depends on the desired audio sample rate desired, the format
-	 * (stereo/mono) used, and the data size.
-	 * The formula is:
-	 * 		I2S_MCLK = PCLK * (X/Y) / 2
-	 * We have:
-	 * 		I2S_MCLK = Freq * bit_rate;
-	 * So: (X/Y) = (Freq * bit_rate)/PCLK*2
-	 * We use a loop function to chose the most suitable X,Y value
-	 */
-
-	divider = ((uint64_t)(Freq *( bitrate+1)* 2)&lt;&lt;16) / i2sPclk;
-	for (y = 255; y &gt; 0; y--) {
-		x = y * divider;
-		dif = x &amp; 0xFFFF;
-		if(dif&gt;0x8000) error = 0x10000-dif;
-		else error = dif;
-		if (error == 0)
-		{
-			y_divide = y;
-			break;
-		}
-		else if (error &lt; ErrorOptimal)
-		{
-			ErrorOptimal = error;
-			y_divide = y;
-		}
-	}
-	x_divide = (y_divide * Freq *( bitrate+1)* 2)/i2sPclk;
-	if (TRMode == I2S_TX_MODE)// Transmitter
-	{
-		I2Sx-&gt;I2STXRATE = y_divide | (x_divide &lt;&lt; 8);
-	} else //Receiver
-	{
-		I2Sx-&gt;I2SRXRATE = y_divide | (x_divide &lt;&lt; 8);
-	}
-	return SUCCESS;
-}
-/********************************************************************//**
- * @brief		I2S set bitrate
- * @param[in]	I2Sx: I2S peripheral selected, should be: I2S
- * @param[in]	bitrate value will be set
- * @param[in]	TRMode is transmit/receive mode, should be:
- * 				- I2S_TX_MODE: transmit mode
- * 				- I2S_RX_MODE: receive mode
- * @return 		none
- *********************************************************************/
-void I2S_SetBitRate(I2S_TypeDef *I2Sx, uint8_t bitrate, uint8_t TRMode)
-{
-	CHECK_PARAM(PARAM_I2Sx(I2Sx));
-	CHECK_PARAM(PARAM_I2S_BITRATE(bitrate));
-	CHECK_PARAM(PARAM_I2S_TRX(TRMode));
-
-	if(TRMode == I2S_TX_MODE)
-	{
-		I2Sx-&gt;I2STXBITRATE = (bitrate -1);
-	}
-	else
-	{
-		I2Sx-&gt;I2SRXBITRATE = (bitrate -1);
-	}
-}
-/********************************************************************//**
- * @brief		Configuration operating mode for I2S
- * @param[in]	I2Sx: I2S peripheral selected, should be: I2S
- * @param[in]	ModeConfig pointer to I2S_MODEConf_Type will be used to
- * 				configure, should be:
- * @param[in]	TRMode is transmit/receive mode, should be:
- * 				- I2S_TX_MODE: transmit mode
- * 				- I2S_RX_MODE: receive mode
- * @return 		none
- *********************************************************************/
-void I2S_ModeConfig(I2S_TypeDef *I2Sx, I2S_MODEConf_Type* ModeConfig,
-		uint8_t TRMode)
-{
-	CHECK_PARAM(PARAM_I2Sx(I2Sx));
-	CHECK_PARAM(PARAM_I2S_CLKSEL(ModeConfig-&gt;clksel));
-	CHECK_PARAM(PARAM_I2S_4PIN(ModeConfig-&gt;fpin));
-	CHECK_PARAM(PARAM_I2S_MCLK(ModeConfig-&gt;mcena));
-	CHECK_PARAM(PARAM_I2S_TRX(TRMode));
-
-	if (TRMode == I2S_TX_MODE) {
-		I2Sx-&gt;I2STXMODE &amp;= ~0x0F; //clear bit 3:0 in I2STXMODE register
-		if (ModeConfig-&gt;clksel == I2S_CLKSEL_1) {
-			I2Sx-&gt;I2STXMODE |= 0x02;
-		}
-		if (ModeConfig-&gt;fpin == I2S_4PIN_ENABLE) {
-			I2Sx-&gt;I2STXMODE |= (1 &lt;&lt; 2);
-		}
-		if (ModeConfig-&gt;mcena == I2S_MCLK_ENABLE) {
-			I2Sx-&gt;I2STXMODE |= (1 &lt;&lt; 3);
-		}
-	} else {
-		I2Sx-&gt;I2SRXMODE &amp;= ~0x0F; //clear bit 3:0 in I2STXMODE register
-		if (ModeConfig-&gt;clksel == I2S_CLKSEL_1) {
-			I2Sx-&gt;I2SRXMODE |= 0x02;
-		}
-		if (ModeConfig-&gt;fpin == I2S_4PIN_ENABLE) {
-			I2Sx-&gt;I2SRXMODE |= (1 &lt;&lt; 2);
-		}
-		if (ModeConfig-&gt;mcena == I2S_MCLK_ENABLE) {
-			I2Sx-&gt;I2SRXMODE |= (1 &lt;&lt; 3);
-		}
-	}
-}
-
-/********************************************************************//**
- * @brief		Configure DMA operation for I2S
- * @param[in]	I2Sx: I2S peripheral selected, should be: I2S
- * @param[in]	DMAConfig pointer to I2S_DMAConf_Type will be used to configure
- * @param[in]	TRMode is transmit/receive mode, should be:
- * 				- I2S_TX_MODE: transmit mode
- * 				- I2S_RX_MODE: receive mode
- * @return 		none
- *********************************************************************/
-void I2S_DMAConfig(I2S_TypeDef *I2Sx, I2S_DMAConf_Type* DMAConfig,
-		uint8_t TRMode)
-{
-	CHECK_PARAM(PARAM_I2Sx(I2Sx));
-	CHECK_PARAM(PARAM_I2S_DMA(DMAConfig-&gt;DMAIndex));
-	CHECK_PARAM(PARAM_I2S_DMA_DEPTH(DMAConfig-&gt;depth));
-	CHECK_PARAM(PARAM_I2S_TRX(TRMode));
-
-	if (TRMode == I2S_RX_MODE) {
-		if (DMAConfig-&gt;DMAIndex == I2S_DMA_1) {
-			I2S-&gt;I2SDMA1 = (DMAConfig-&gt;depth) &lt;&lt; 8;
-		} else {
-			I2S-&gt;I2SDMA2 = (DMAConfig-&gt;depth) &lt;&lt; 8;
-		}
-	} else {
-		if (DMAConfig-&gt;DMAIndex == I2S_DMA_1) {
-			I2S-&gt;I2SDMA1 = (DMAConfig-&gt;depth) &lt;&lt; 16;
-		} else {
-			I2S-&gt;I2SDMA2 = (DMAConfig-&gt;depth) &lt;&lt; 16;
-		}
-	}
-}
-
-/********************************************************************//**
- * @brief		Enable/Disable DMA operation for I2S
- * @param[in]	I2Sx: I2S peripheral selected, should be: I2S
- * @param[in]	DMAIndex chose what DMA is used, should be:
- * 				- I2S_DMA_1: DMA1
- * 				- I2S_DMA_2: DMA2
- * @param[in]	TRMode is transmit/receive mode, should be:
- * 				- I2S_TX_MODE: transmit mode
- * 				- I2S_RX_MODE: receive mode
- * @param[in]	NewState is new state of DMA operation, should be:
- * 				- ENABLE
- * 				- DISABLE
- * @return 		none
- *********************************************************************/
-void I2S_DMACmd(I2S_TypeDef *I2Sx, uint8_t DMAIndex, uint8_t TRMode,
-		FunctionalState NewState)
-{
-	CHECK_PARAM(PARAM_I2Sx(I2Sx));
-	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
-	CHECK_PARAM(PARAM_I2S_DMA(DMAIndex));
-	CHECK_PARAM(PARAM_I2S_TRX(TRMode));
-
-	if (TRMode == I2S_RX_MODE) {
-		if (DMAIndex == I2S_DMA_1) {
-			if (NewState == ENABLE)
-				I2Sx-&gt;I2SDMA1 |= 0x01;
-			else
-				I2Sx-&gt;I2SDMA1 &amp;= ~0x01;
-		} else {
-			if (NewState == ENABLE)
-				I2Sx-&gt;I2SDMA2 |= 0x01;
-			else
-				I2Sx-&gt;I2SDMA2 &amp;= ~0x01;
-		}
-	} else {
-		if (DMAIndex == I2S_DMA_1) {
-			if (NewState == ENABLE)
-				I2Sx-&gt;I2SDMA1 |= 0x02;
-			else
-				I2Sx-&gt;I2SDMA1 &amp;= ~0x02;
-		} else {
-			if (NewState == ENABLE)
-				I2Sx-&gt;I2SDMA2 |= 0x02;
-			else
-				I2Sx-&gt;I2SDMA2 &amp;= ~0x02;
-		}
-	}
-}
-
-/********************************************************************//**
- * @brief		Configure IRQ for I2S
- * @param[in]	I2Sx: I2S peripheral selected, should be: I2S
- * @param[in]	TRMode is transmit/receive mode, should be:
- * 				- I2S_TX_MODE: transmit mode
- * 				- I2S_RX_MODE: receive mode
- * @param[in]	level: is the FIFO level that triggers IRQ request
- * @param[in]	pfnI2SCbs: the pointer to call-back function handle this interrupt
- * @return 		none
- *********************************************************************/
-void I2S_IRQConfig(I2S_TypeDef *I2Sx, uint8_t TRMode, uint8_t level,  fnI2SCbs_Type *pfnI2SCbs) {
-	CHECK_PARAM(PARAM_I2Sx(I2Sx));
-	CHECK_PARAM(PARAM_I2S_TRX(TRMode));
-	CHECK_PARAM(PARAM_I2S_IRQ_LEVEL(level));
-
-	if (TRMode == I2S_RX_MODE) {
-		I2Sx-&gt;I2SIRQ |= (level &lt;&lt; 8);
-	} else {
-		I2Sx-&gt;I2SIRQ |= (level &lt;&lt; 16);
-	}
-	//setup Call-Back funtion for receive interrupt
-	_apfnI2SCbs[TRMode] = pfnI2SCbs;
-}
-
-/********************************************************************//**
- * @brief		Enable/Disable IRQ for I2S
- * @param[in]	I2Sx: I2S peripheral selected, should be: I2S
- * @param[in]	TRMode is transmit/receive mode, should be:
- * 				- I2S_TX_MODE: transmit mode
- * 				- I2S_RX_MODE: receive mode
- * @param[in]	NewState is new state of DMA operation, should be:
- * 				- ENABLE
- * 				- DISABLE
- * @return 		none
- *********************************************************************/
-void I2S_IRQCmd(I2S_TypeDef *I2Sx, uint8_t TRMode, FunctionalState NewState) {
-	CHECK_PARAM(PARAM_I2Sx(I2Sx));
-	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
-
-	if (TRMode == I2S_RX_MODE) {
-		if (NewState == ENABLE)
-			I2Sx-&gt;I2SIRQ |= 0x01;
-		else
-			I2Sx-&gt;I2SIRQ &amp;= ~0x01;
-		//Enable DMA
-
-	} else {
-		if (NewState == ENABLE)
-			I2Sx-&gt;I2SIRQ |= 0x02;
-		else
-			I2Sx-&gt;I2SIRQ &amp;= ~0x02;
-	}
-}
-/*********************************************************************//**
- * @brief		Standard I2S interrupt handler, this function will check
- * 				all interrupt status of I2S channels, then execute the call
- * 				back function if they're already installed
- * @param[in]	None
- * @return		None
- **********************************************************************/
-void I2S_IntHandler(void)
-{
-	uint8_t rx_level,
-			tx_level,
-			tx_depth_irq,
-			rx_depth_irq;
-
-
-	if((I2S-&gt;I2SIRQ)&amp; 0x01){ //receive interrupt
-		rx_level = ((I2S-&gt;I2SSTATE)&gt;&gt;8)&amp;0xFF;
-		rx_depth_irq = ((I2S-&gt;I2SIRQ)&gt;&gt;8)&amp;0xFF;
-
-		if (rx_level &gt;= rx_depth_irq)//receive interrupt
-		{
-			_apfnI2SCbs[1]();
-		}
-	}
-	else if(((I2S-&gt;I2SIRQ)&gt;&gt;1)&amp; 0x01)
-	{
-		tx_level = ((I2S-&gt;I2SSTATE)&gt;&gt;16)&amp;0xFF;
-		tx_depth_irq = ((I2S-&gt;I2SIRQ)&gt;&gt;16)&amp;0xFF;
-		if(tx_level &lt;= tx_depth_irq)//transmit interrupt
-		{
-			_apfnI2SCbs[0]();
-		}
-	}
-}
-
-/**
- * @}
- */
-
-#endif /* _I2S */
-
-/**
- * @}
- */
-
-/* --------------------------------- End Of File ------------------------------ */
-
+/**
+ * @file	: lpc17xx_i2s.c
+ * @brief	: Contains all functions support for I2S firmware library on LPC17xx
+ * @version	: 1.0
+ * @date	: 13. May. 2009
+ * @author	: NguyenCao
+ **************************************************************************
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * products. This software is supplied &quot;AS IS&quot; without any warranties.
+ * NXP Semiconductors assumes no responsibility or liability for the
+ * use of the software, conveys no license or title under any patent,
+ * copyright, or mask work right to the product. NXP Semiconductors
+ * reserves the right to make changes in the software without
+ * notification. NXP Semiconductors also make no representation or
+ * warranty that such application will be suitable for the specified
+ * use without further testing or modification.
+ **********************************************************************/
+
+/* Peripheral group ----------------------------------------------------------- */
+/** @addtogroup I2S
+ * @{
+ */
+
+/* Includes ------------------------------------------------------------------- */
+#include &quot;lpc17xx_i2s.h&quot;
+#include &quot;lpc17xx_clkpwr.h&quot;
+
+
+/* If this source file built with example, the LPC17xx FW library configuration
+ * file in each example directory (&quot;lpc17xx_libcfg.h&quot;) must be included,
+ * otherwise the default FW library configuration file must be included instead
+ */
+#ifdef __BUILD_WITH_EXAMPLE__
+#include &quot;lpc17xx_libcfg.h&quot;
+#else
+#include &quot;lpc17xx_libcfg_default.h&quot;
+#endif /* __BUILD_WITH_EXAMPLE__ */
+
+
+#ifdef _I2S
+
+/* Private Variables ---------------------------------------------------------- */
+static fnI2SCbs_Type *_apfnI2SCbs[2] = {
+		NULL, 	// I2S transmit Call-back function pointer
+		NULL, 	// I2S receive Call-back function pointer
+};
+
+
+/* Private Functions ---------------------------------------------------------- */
+/** @defgroup I2S_Private_Functions
+ * @{
+ */
+
+/********************************************************************//**
+ * @brief		Get I2S wordwidth value
+ * @param[in]	I2Sx: I2S peripheral selected, should be: I2S
+ * @param[in]	TRMode is the I2S mode, should be:
+ * 				- I2S_TX_MODE: transmit mode
+ * 				- I2S_RX_MODE: receive mode
+ * @return 		The wordwidth value, should be: 8,16 or 32
+ *********************************************************************/
+uint8_t I2S_GetWordWidth(LPC_I2S_TypeDef *I2Sx, uint8_t TRMode) {
+	uint8_t value;
+
+	CHECK_PARAM(PARAM_I2Sx(I2Sx));
+	CHECK_PARAM(PARAM_I2S_TRX(TRMode));
+
+	if (TRMode == I2S_TX_MODE) {
+		value = (I2Sx-&gt;I2SDAO) &amp; 0x03; /* get wordwidth bit */
+	} else {
+		value = (I2Sx-&gt;I2SDAI) &amp; 0x03; /* get wordwidth bit */
+	}
+	switch (value) {
+	case I2S_WORDWIDTH_8:
+		return 8;
+		break;
+	case I2S_WORDWIDTH_16:
+		return 16;
+		break;
+	default:
+		return 32;
+	}
+}
+/********************************************************************//**
+ * @brief		Get I2S channel value
+ * @param[in]	I2Sx: I2S peripheral selected, should be: I2S
+ * @param[in]	TRMode is the I2S mode, should be:
+ * 				- I2S_TX_MODE: transmit mode
+ * 				- I2S_RX_MODE: receive mode
+ * @return 		The channel value, should be: 1(mono) or 2(stereo)
+ *********************************************************************/
+uint8_t I2S_GetChannel(LPC_I2S_TypeDef *I2Sx, uint8_t TRMode) {
+	uint8_t value;
+
+	CHECK_PARAM(PARAM_I2Sx(I2Sx));
+	CHECK_PARAM(PARAM_I2S_TRX(TRMode));
+
+	if (TRMode == I2S_TX_MODE) {
+		value = (I2Sx-&gt;I2SDAO) &amp; 0x04; /* get bit[2] */
+	} else {
+		value = (I2Sx-&gt;I2SDAI) &amp; 0x04; /* get bit[2] */
+	}
+	switch (value) {
+	case I2S_MONO:
+		return 1;
+		break;
+	default:
+		return 2;
+	}
+}
+
+/**
+ * @}
+ */
+
+
+/* Public Functions ----------------------------------------------------------- */
+/** @addtogroup I2S_Public_Functions
+ * @{
+ */
+
+/********************************************************************//**
+ * @brief		Initialize I2S
+ * 					- Turn on power and clock
+ * 					- Setup I2S pin select
+ * @param[in]	I2Sx: I2S peripheral selected, should be: I2S
+ * @return 		none
+ *********************************************************************/
+void I2S_Init(LPC_I2S_TypeDef *I2Sx) {
+	CHECK_PARAM(PARAM_I2Sx(I2Sx));
+
+	// Turn on power and clock
+	CLKPWR_ConfigPPWR(CLKPWR_PCONP_PCI2S, ENABLE);
+	LPC_I2S-&gt;I2SDAI = LPC_I2S-&gt;I2SDAO = 0x00;
+}
+
+/********************************************************************//**
+ * @brief		Configuration I2S, setting:
+ * 					- master/slave mode
+ * 					- wordwidth value
+ * 					- channel mode
+ * @param[in]	I2Sx: I2S peripheral selected, should be: I2S
+ * @param[in]	TRMode: transmit/receive mode, should be:
+ * 					- I2S_TX_MODE: transmit mode
+ * 					- I2S_RX_MODE: receive mode
+ * @param[in]	ConfigStruct pointer to I2S_CFG_Type structure
+ *              which will be initialized.
+ * @return 		none
+ *********************************************************************/
+void I2S_Config(LPC_I2S_TypeDef *I2Sx, uint8_t TRMode, I2S_CFG_Type* ConfigStruct)
+{
+	uint32_t bps, config;
+
+	CHECK_PARAM(PARAM_I2Sx(I2Sx));
+
+	CHECK_PARAM(PARAM_I2S_WORDWIDTH(ConfigStruct-&gt;wordwidth));
+	CHECK_PARAM(PARAM_I2S_CHANNEL(ConfigStruct-&gt;mono));
+	CHECK_PARAM(PARAM_I2S_STOP(ConfigStruct-&gt;stop));
+	CHECK_PARAM(PARAM_I2S_RESET(ConfigStruct-&gt;reset));
+	CHECK_PARAM(PARAM_I2S_WS_SEL(ConfigStruct-&gt;ws_sel));
+	CHECK_PARAM(PARAM_I2S_MUTE(ConfigStruct-&gt;mute));
+
+	/* Setup clock */
+	bps = (ConfigStruct-&gt;wordwidth +1)*8;
+
+	/* Calculate audio config */
+	config = (bps - 1)&lt;&lt;6 | (ConfigStruct-&gt;ws_sel)&lt;&lt;5 | (ConfigStruct-&gt;reset)&lt;&lt;4 |
+		(ConfigStruct-&gt;stop)&lt;&lt;3 | (ConfigStruct-&gt;mono)&lt;&lt;2 | (ConfigStruct-&gt;wordwidth);
+
+	if(TRMode == I2S_RX_MODE){
+		LPC_I2S-&gt;I2SDAI = config;
+	}else{
+		LPC_I2S-&gt;I2SDAO = config;
+	}
+}
+
+/********************************************************************//**
+ * @brief		DeInitial both I2S transmit or receive
+ * @param[in]	I2Sx: I2S peripheral selected, should be: I2S
+ * @return 		none
+ *********************************************************************/
+void I2S_DeInit(LPC_I2S_TypeDef *I2Sx) {
+	CHECK_PARAM(PARAM_I2Sx(I2Sx));
+
+	// Turn off power and clock
+	CLKPWR_ConfigPPWR(CLKPWR_PCONP_PCI2S, DISABLE);
+}
+
+/********************************************************************//**
+ * @brief		Get I2S Buffer Level
+ * @param[in]	I2Sx: I2S peripheral selected, should be: I2S
+ * @param[in]	TRMode: Transmit/receive mode, should be:
+ * 					- I2S_TX_MODE: transmit mode
+ * 					- I2S_RX_MODE: receive mode
+ * @return 		current level of Transmit/Receive Buffer
+ *********************************************************************/
+uint8_t I2S_GetLevel(LPC_I2S_TypeDef *I2Sx, uint8_t TRMode)
+{
+	CHECK_PARAM(PARAM_I2Sx(I2Sx));
+	CHECK_PARAM(PARAM_I2S_TRX(TRMode));
+
+	if(TRMode == I2S_TX_MODE)
+	{
+		return ((I2Sx-&gt;I2SSTATE &gt;&gt; 16) &amp; 0xFF);
+	}
+	else
+	{
+		return ((I2Sx-&gt;I2SSTATE &gt;&gt; 8) &amp; 0xFF);
+	}
+}
+/********************************************************************//**
+ * @brief		I2S Start: clear all STOP,RESET and MUTE bit, ready to operate
+ * @param[in]	I2Sx: I2S peripheral selected, should be: I2S
+ * @return 		none
+ *********************************************************************/
+void I2S_Start(LPC_I2S_TypeDef *I2Sx)
+{
+	//Clear STOP,RESET and MUTE bit
+	I2Sx-&gt;I2SDAO &amp;= ~I2S_DAI_RESET;
+	I2Sx-&gt;I2SDAI &amp;= ~I2S_DAI_RESET;
+	I2Sx-&gt;I2SDAO &amp;= ~I2S_DAI_STOP;
+	I2Sx-&gt;I2SDAI &amp;= ~I2S_DAI_STOP;
+	I2Sx-&gt;I2SDAO &amp;= ~I2S_DAI_MUTE;
+}
+/********************************************************************//**
+ * @brief		I2S Send data
+ * @param[in]	I2Sx: I2S peripheral selected, should be: I2S
+ * @param[in]	BufferData pointer to uint32_t is the data will be send
+ * @return 		none
+ *********************************************************************/
+void I2S_Send(LPC_I2S_TypeDef *I2Sx, uint32_t BufferData) {
+	CHECK_PARAM(PARAM_I2Sx(I2Sx));
+	CHECK_PARAM(PARAM_I2S_DATA(BufferData));
+
+	I2Sx-&gt;I2STXFIFO = BufferData;
+}
+
+/********************************************************************//**
+ * @brief		I2S Receive Data
+ * @param[in]	I2Sx pointer to LPC_I2S_TypeDef
+ * @return 		received value
+ *********************************************************************/
+uint32_t I2S_Receive(LPC_I2S_TypeDef* I2Sx) {
+	CHECK_PARAM(PARAM_I2Sx(I2Sx));
+
+	return (I2Sx-&gt;I2SRXFIFO);
+
+}
+/********************************************************************//**
+ * @brief		I2S Pause
+ * @param[in]	I2Sx: I2S peripheral selected, should be: I2S
+ * @param[in]	TRMode is transmit/receive mode, should be:
+ * 				- I2S_TX_MODE: transmit mode
+ * 				- I2S_RX_MODE: receive mode
+ * @return 		none
+ *********************************************************************/
+void I2S_Pause(LPC_I2S_TypeDef *I2Sx, uint8_t TRMode) {
+	CHECK_PARAM(PARAM_I2Sx(I2Sx));
+	CHECK_PARAM(PARAM_I2S_TRX(TRMode));
+
+	if (TRMode == I2S_TX_MODE) //Transmit mode
+	{
+		I2Sx-&gt;I2SDAO |= I2S_DAO_STOP;
+	} else //Receive mode
+	{
+		I2Sx-&gt;I2SDAI |= I2S_DAI_STOP;
+	}
+}
+/********************************************************************//**
+ * @brief		I2S Mute
+ * @param[in]	I2Sx: I2S peripheral selected, should be: I2S
+ * @param[in]	TRMode is transmit/receive mode, should be:
+ * 				- I2S_TX_MODE: transmit mode
+ * 				- I2S_RX_MODE: receive mode
+ * @return 		none
+ *********************************************************************/
+void I2S_Mute(LPC_I2S_TypeDef *I2Sx, uint8_t TRMode) {
+	CHECK_PARAM(PARAM_I2Sx(I2Sx));
+	CHECK_PARAM(PARAM_I2S_TRX(TRMode));
+
+	if (TRMode == I2S_TX_MODE) //Transmit mode
+	{
+		I2Sx-&gt;I2SDAO |= I2S_DAO_MUTE;
+	} else //Receive mode
+	{
+		I2Sx-&gt;I2SDAI |= I2S_DAI_MUTE;
+	}
+}
+
+/********************************************************************//**
+ * @brief		I2S Stop
+ * @param[in]	I2Sx: I2S peripheral selected, should be: I2S
+ * @param[in]	TRMode is transmit/receive mode, should be:
+ * 				- I2S_TX_MODE: transmit mode
+ * 				- I2S_RX_MODE: receive mode
+ * @return 		none
+ *********************************************************************/
+void I2S_Stop(LPC_I2S_TypeDef *I2Sx, uint8_t TRMode) {
+	CHECK_PARAM(PARAM_I2Sx(I2Sx));
+	CHECK_PARAM(PARAM_I2S_TRX(TRMode));
+
+	if (TRMode == I2S_TX_MODE) //Transmit mode
+	{
+		I2Sx-&gt;I2SDAO &amp;= ~I2S_DAO_MUTE;
+		I2Sx-&gt;I2SDAO |= I2S_DAO_STOP;
+		I2Sx-&gt;I2SDAO |= I2S_DAO_RESET;
+	} else //Receive mode
+	{
+		I2Sx-&gt;I2SDAI |= I2S_DAI_STOP;
+		I2Sx-&gt;I2SDAI |= I2S_DAI_RESET;
+	}
+}
+
+/********************************************************************//**
+ * @brief		Set frequency for I2S
+ * @param[in]	I2Sx: I2S peripheral selected, should be: I2S
+ * @param[in]	Freq is the frequency for I2S will be set. It can range
+ * 				from 16-96 kHz(16, 22.05, 32, 44.1, 48, 96kHz)
+ * @param[in]	TRMode is transmit/receive mode, should be:
+ * 				- I2S_TX_MODE: transmit mode
+ * 				- I2S_RX_MODE: receive mode
+ * @return 		Status: ERROR or SUCCESS
+ *********************************************************************/
+Status I2S_FreqConfig(LPC_I2S_TypeDef *I2Sx, uint32_t Freq, uint8_t TRMode) {
+
+	/* Calculate bit rate
+	 * The formula is:
+	 *      bit_rate = channel*wordwidth - 1
+	 * 48kHz sample rate for 16 bit stereo date requires
+	 * a bit rate of 48000*16*2=1536MHz (MCLK)
+	 */
+	uint32_t i2sPclk;
+	uint64_t divider;
+	uint8_t bitrate, channel, wordwidth;
+	uint32_t x, y;
+	uint16_t dif;
+	uint16_t error;
+	uint8_t x_divide, y_divide;
+	uint16_t ErrorOptimal = 0xFFFF;
+
+	CHECK_PARAM(PARAM_I2Sx(I2Sx));
+	CHECK_PARAM(PRAM_I2S_FREQ(Freq));
+	CHECK_PARAM(PARAM_I2S_TRX(TRMode));
+
+	i2sPclk = CLKPWR_GetPCLK(CLKPWR_PCLKSEL_I2S);
+	if(TRMode == I2S_TX_MODE)
+	{
+		channel = I2S_GetChannel(I2Sx,I2S_TX_MODE);
+		wordwidth = I2S_GetWordWidth(I2Sx,I2S_TX_MODE);
+	}
+	else
+	{
+		channel = I2S_GetChannel(I2Sx,I2S_RX_MODE);
+		wordwidth = I2S_GetWordWidth(I2Sx,I2S_RX_MODE);
+	}
+	bitrate = channel * wordwidth - 1;
+	if (TRMode == I2S_TX_MODE)// Transmitter
+	{
+		I2Sx-&gt;I2STXBITRATE = bitrate;
+	} else //Receiver
+	{
+		I2Sx-&gt;I2SRXBITRATE = bitrate;
+	}
+	/* Calculate X and Y divider
+	 * The MCLK rate for the I2S transmitter is determined by the value
+	 * in the I2STXRATE/I2SRXRATE register. The required I2STXRATE/I2SRXRATE
+	 * setting depends on the desired audio sample rate desired, the format
+	 * (stereo/mono) used, and the data size.
+	 * The formula is:
+	 * 		I2S_MCLK = PCLK * (X/Y) / 2
+	 * We have:
+	 * 		I2S_MCLK = Freq * bit_rate;
+	 * So: (X/Y) = (Freq * bit_rate)/PCLK*2
+	 * We use a loop function to chose the most suitable X,Y value
+	 */
+
+	divider = ((uint64_t)(Freq *( bitrate+1)* 2)&lt;&lt;16) / i2sPclk;
+	for (y = 255; y &gt; 0; y--) {
+		x = y * divider;
+		dif = x &amp; 0xFFFF;
+		if(dif&gt;0x8000) error = 0x10000-dif;
+		else error = dif;
+		if (error == 0)
+		{
+			y_divide = y;
+			break;
+		}
+		else if (error &lt; ErrorOptimal)
+		{
+			ErrorOptimal = error;
+			y_divide = y;
+		}
+	}
+	x_divide = (y_divide * Freq *( bitrate+1)* 2)/i2sPclk;
+	if (TRMode == I2S_TX_MODE)// Transmitter
+	{
+		I2Sx-&gt;I2STXRATE = y_divide | (x_divide &lt;&lt; 8);
+	} else //Receiver
+	{
+		I2Sx-&gt;I2SRXRATE = y_divide | (x_divide &lt;&lt; 8);
+	}
+	return SUCCESS;
+}
+/********************************************************************//**
+ * @brief		I2S set bitrate
+ * @param[in]	I2Sx: I2S peripheral selected, should be: I2S
+ * @param[in]	bitrate value will be set
+ * @param[in]	TRMode is transmit/receive mode, should be:
+ * 				- I2S_TX_MODE: transmit mode
+ * 				- I2S_RX_MODE: receive mode
+ * @return 		none
+ *********************************************************************/
+void I2S_SetBitRate(LPC_I2S_TypeDef *I2Sx, uint8_t bitrate, uint8_t TRMode)
+{
+	CHECK_PARAM(PARAM_I2Sx(I2Sx));
+	CHECK_PARAM(PARAM_I2S_BITRATE(bitrate));
+	CHECK_PARAM(PARAM_I2S_TRX(TRMode));
+
+	if(TRMode == I2S_TX_MODE)
+	{
+		I2Sx-&gt;I2STXBITRATE = (bitrate -1);
+	}
+	else
+	{
+		I2Sx-&gt;I2SRXBITRATE = (bitrate -1);
+	}
+}
+/********************************************************************//**
+ * @brief		Configuration operating mode for I2S
+ * @param[in]	I2Sx: I2S peripheral selected, should be: I2S
+ * @param[in]	ModeConfig pointer to I2S_MODEConf_Type will be used to
+ * 				configure, should be:
+ * @param[in]	TRMode is transmit/receive mode, should be:
+ * 				- I2S_TX_MODE: transmit mode
+ * 				- I2S_RX_MODE: receive mode
+ * @return 		none
+ *********************************************************************/
+void I2S_ModeConfig(LPC_I2S_TypeDef *I2Sx, I2S_MODEConf_Type* ModeConfig,
+		uint8_t TRMode)
+{
+	CHECK_PARAM(PARAM_I2Sx(I2Sx));
+	CHECK_PARAM(PARAM_I2S_CLKSEL(ModeConfig-&gt;clksel));
+	CHECK_PARAM(PARAM_I2S_4PIN(ModeConfig-&gt;fpin));
+	CHECK_PARAM(PARAM_I2S_MCLK(ModeConfig-&gt;mcena));
+	CHECK_PARAM(PARAM_I2S_TRX(TRMode));
+
+	if (TRMode == I2S_TX_MODE) {
+		I2Sx-&gt;I2STXMODE &amp;= ~0x0F; //clear bit 3:0 in I2STXMODE register
+		if (ModeConfig-&gt;clksel == I2S_CLKSEL_1) {
+			I2Sx-&gt;I2STXMODE |= 0x02;
+		}
+		if (ModeConfig-&gt;fpin == I2S_4PIN_ENABLE) {
+			I2Sx-&gt;I2STXMODE |= (1 &lt;&lt; 2);
+		}
+		if (ModeConfig-&gt;mcena == I2S_MCLK_ENABLE) {
+			I2Sx-&gt;I2STXMODE |= (1 &lt;&lt; 3);
+		}
+	} else {
+		I2Sx-&gt;I2SRXMODE &amp;= ~0x0F; //clear bit 3:0 in I2STXMODE register
+		if (ModeConfig-&gt;clksel == I2S_CLKSEL_1) {
+			I2Sx-&gt;I2SRXMODE |= 0x02;
+		}
+		if (ModeConfig-&gt;fpin == I2S_4PIN_ENABLE) {
+			I2Sx-&gt;I2SRXMODE |= (1 &lt;&lt; 2);
+		}
+		if (ModeConfig-&gt;mcena == I2S_MCLK_ENABLE) {
+			I2Sx-&gt;I2SRXMODE |= (1 &lt;&lt; 3);
+		}
+	}
+}
+
+/********************************************************************//**
+ * @brief		Configure DMA operation for I2S
+ * @param[in]	I2Sx: I2S peripheral selected, should be: I2S
+ * @param[in]	DMAConfig pointer to I2S_DMAConf_Type will be used to configure
+ * @param[in]	TRMode is transmit/receive mode, should be:
+ * 				- I2S_TX_MODE: transmit mode
+ * 				- I2S_RX_MODE: receive mode
+ * @return 		none
+ *********************************************************************/
+void I2S_DMAConfig(LPC_I2S_TypeDef *I2Sx, I2S_DMAConf_Type* DMAConfig,
+		uint8_t TRMode)
+{
+	CHECK_PARAM(PARAM_I2Sx(I2Sx));
+	CHECK_PARAM(PARAM_I2S_DMA(DMAConfig-&gt;DMAIndex));
+	CHECK_PARAM(PARAM_I2S_DMA_DEPTH(DMAConfig-&gt;depth));
+	CHECK_PARAM(PARAM_I2S_TRX(TRMode));
+
+	if (TRMode == I2S_RX_MODE) {
+		if (DMAConfig-&gt;DMAIndex == I2S_DMA_1) {
+			LPC_I2S-&gt;I2SDMA1 = (DMAConfig-&gt;depth) &lt;&lt; 8;
+		} else {
+			LPC_I2S-&gt;I2SDMA2 = (DMAConfig-&gt;depth) &lt;&lt; 8;
+		}
+	} else {
+		if (DMAConfig-&gt;DMAIndex == I2S_DMA_1) {
+			LPC_I2S-&gt;I2SDMA1 = (DMAConfig-&gt;depth) &lt;&lt; 16;
+		} else {
+			LPC_I2S-&gt;I2SDMA2 = (DMAConfig-&gt;depth) &lt;&lt; 16;
+		}
+	}
+}
+
+/********************************************************************//**
+ * @brief		Enable/Disable DMA operation for I2S
+ * @param[in]	I2Sx: I2S peripheral selected, should be: I2S
+ * @param[in]	DMAIndex chose what DMA is used, should be:
+ * 				- I2S_DMA_1: DMA1
+ * 				- I2S_DMA_2: DMA2
+ * @param[in]	TRMode is transmit/receive mode, should be:
+ * 				- I2S_TX_MODE: transmit mode
+ * 				- I2S_RX_MODE: receive mode
+ * @param[in]	NewState is new state of DMA operation, should be:
+ * 				- ENABLE
+ * 				- DISABLE
+ * @return 		none
+ *********************************************************************/
+void I2S_DMACmd(LPC_I2S_TypeDef *I2Sx, uint8_t DMAIndex, uint8_t TRMode,
+		FunctionalState NewState)
+{
+	CHECK_PARAM(PARAM_I2Sx(I2Sx));
+	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
+	CHECK_PARAM(PARAM_I2S_DMA(DMAIndex));
+	CHECK_PARAM(PARAM_I2S_TRX(TRMode));
+
+	if (TRMode == I2S_RX_MODE) {
+		if (DMAIndex == I2S_DMA_1) {
+			if (NewState == ENABLE)
+				I2Sx-&gt;I2SDMA1 |= 0x01;
+			else
+				I2Sx-&gt;I2SDMA1 &amp;= ~0x01;
+		} else {
+			if (NewState == ENABLE)
+				I2Sx-&gt;I2SDMA2 |= 0x01;
+			else
+				I2Sx-&gt;I2SDMA2 &amp;= ~0x01;
+		}
+	} else {
+		if (DMAIndex == I2S_DMA_1) {
+			if (NewState == ENABLE)
+				I2Sx-&gt;I2SDMA1 |= 0x02;
+			else
+				I2Sx-&gt;I2SDMA1 &amp;= ~0x02;
+		} else {
+			if (NewState == ENABLE)
+				I2Sx-&gt;I2SDMA2 |= 0x02;
+			else
+				I2Sx-&gt;I2SDMA2 &amp;= ~0x02;
+		}
+	}
+}
+
+/********************************************************************//**
+ * @brief		Configure IRQ for I2S
+ * @param[in]	I2Sx: I2S peripheral selected, should be: I2S
+ * @param[in]	TRMode is transmit/receive mode, should be:
+ * 				- I2S_TX_MODE: transmit mode
+ * 				- I2S_RX_MODE: receive mode
+ * @param[in]	level: is the FIFO level that triggers IRQ request
+ * @param[in]	pfnI2SCbs: the pointer to call-back function handle this interrupt
+ * @return 		none
+ *********************************************************************/
+void I2S_IRQConfig(LPC_I2S_TypeDef *I2Sx, uint8_t TRMode, uint8_t level,  fnI2SCbs_Type *pfnI2SCbs) {
+	CHECK_PARAM(PARAM_I2Sx(I2Sx));
+	CHECK_PARAM(PARAM_I2S_TRX(TRMode));
+	CHECK_PARAM(PARAM_I2S_IRQ_LEVEL(level));
+
+	if (TRMode == I2S_RX_MODE) {
+		I2Sx-&gt;I2SIRQ |= (level &lt;&lt; 8);
+	} else {
+		I2Sx-&gt;I2SIRQ |= (level &lt;&lt; 16);
+	}
+	//setup Call-Back funtion for receive interrupt
+	_apfnI2SCbs[TRMode] = pfnI2SCbs;
+}
+
+/********************************************************************//**
+ * @brief		Enable/Disable IRQ for I2S
+ * @param[in]	I2Sx: I2S peripheral selected, should be: I2S
+ * @param[in]	TRMode is transmit/receive mode, should be:
+ * 				- I2S_TX_MODE: transmit mode
+ * 				- I2S_RX_MODE: receive mode
+ * @param[in]	NewState is new state of DMA operation, should be:
+ * 				- ENABLE
+ * 				- DISABLE
+ * @return 		none
+ *********************************************************************/
+void I2S_IRQCmd(LPC_I2S_TypeDef *I2Sx, uint8_t TRMode, FunctionalState NewState) {
+	CHECK_PARAM(PARAM_I2Sx(I2Sx));
+	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
+
+	if (TRMode == I2S_RX_MODE) {
+		if (NewState == ENABLE)
+			I2Sx-&gt;I2SIRQ |= 0x01;
+		else
+			I2Sx-&gt;I2SIRQ &amp;= ~0x01;
+		//Enable DMA
+
+	} else {
+		if (NewState == ENABLE)
+			I2Sx-&gt;I2SIRQ |= 0x02;
+		else
+			I2Sx-&gt;I2SIRQ &amp;= ~0x02;
+	}
+}
+/*********************************************************************//**
+ * @brief		Standard I2S interrupt handler, this function will check
+ * 				all interrupt status of I2S channels, then execute the call
+ * 				back function if they're already installed
+ * @param[in]	None
+ * @return		None
+ **********************************************************************/
+void I2S_IntHandler(void)
+{
+	uint8_t rx_level,
+			tx_level,
+			tx_depth_irq,
+			rx_depth_irq;
+
+
+	if((LPC_I2S-&gt;I2SIRQ)&amp; 0x01){ //receive interrupt
+		rx_level = ((LPC_I2S-&gt;I2SSTATE)&gt;&gt;8)&amp;0xFF;
+		rx_depth_irq = ((LPC_I2S-&gt;I2SIRQ)&gt;&gt;8)&amp;0xFF;
+
+		if (rx_level &gt;= rx_depth_irq)//receive interrupt
+		{
+			_apfnI2SCbs[1]();
+		}
+	}
+	else if(((LPC_I2S-&gt;I2SIRQ)&gt;&gt;1)&amp; 0x01)
+	{
+		tx_level = ((LPC_I2S-&gt;I2SSTATE)&gt;&gt;16)&amp;0xFF;
+		tx_depth_irq = ((LPC_I2S-&gt;I2SIRQ)&gt;&gt;16)&amp;0xFF;
+		if(tx_level &lt;= tx_depth_irq)//transmit interrupt
+		{
+			_apfnI2SCbs[0]();
+		}
+	}
+}
+
+/**
+ * @}
+ */
+
+#endif /* _I2S */
+
+/**
+ * @}
+ */
+
+/* --------------------------------- End Of File ------------------------------ */
+


Property changes on: trunk/src/platform/lpc17xx/drivers/src/lpc17xx_i2s.c
___________________________________________________________________
Deleted: svn:executable
   - *

Modified: trunk/src/platform/lpc17xx/drivers/src/lpc17xx_libcfg_default.c
===================================================================
--- trunk/src/platform/lpc17xx/drivers/src/lpc17xx_libcfg_default.c	2010-06-28 21:53:59 UTC (rev 759)
+++ trunk/src/platform/lpc17xx/drivers/src/lpc17xx_libcfg_default.c	2010-07-12 20:56:54 UTC (rev 760)
@@ -1,64 +1,64 @@
-/***********************************************************************//**
- * @file	: lpc17xx_libcfg_default.c
- * @brief	: Library configuration source file (default),
- * 				used to build library without examples.
- * @version	: 1.0
- * @date	: 26. Mar. 2009
- * @author	: HieuNguyen
- **************************************************************************
- * Software that is described herein is for illustrative purposes only
- * which provides customers with programming information regarding the
- * products. This software is supplied &quot;AS IS&quot; without any warranties.
- * NXP Semiconductors assumes no responsibility or liability for the
- * use of the software, conveys no license or title under any patent,
- * copyright, or mask work right to the product. NXP Semiconductors
- * reserves the right to make changes in the software without
- * notification. NXP Semiconductors also make no representation or
- * warranty that such application will be suitable for the specified
- * use without further testing or modification.
- **************************************************************************/
-
-/* Library group ----------------------------------------------------------- */
-/** @addtogroup LIBCFG_DEFAULT
- * @{
- */
-
-/* Includes ------------------------------------------------------------------- */
-#include &quot;lpc17xx_libcfg_default.h&quot;
-
-/* Public Functions ----------------------------------------------------------- */
-/** @addtogroup LIBCFG_DEFAULT_Public_Functions
- * @{
- */
-
-#ifndef __BUILD_WITH_EXAMPLE__
-
-#ifdef  DEBUG
-/*******************************************************************************
-* @brief		Reports the name of the source file and the source line number
-* 				where the CHECK_PARAM error has occurred.
-* @param[in]	file Pointer to the source file name
-* @param[in]    line assert_param error line source number
-* @return		None
-*******************************************************************************/
-void check_failed(uint8_t *file, uint32_t line)
-{
-	/* User can add his own implementation to report the file name and line number,
-	 ex: printf(&quot;Wrong parameters value: file %s on line %d\r\n&quot;, file, line) */
-
-	/* Infinite loop */
-	while(1);
-}
-#endif /* DEBUG */
-
-#endif /* __BUILD_WITH_EXAMPLE__ */
-
-/**
- * @}
- */
-
-/**
- * @}
- */
-
-/* --------------------------------- End Of File ------------------------------ */
+/***********************************************************************//**
+ * @file	: lpc17xx_libcfg_default.c
+ * @brief	: Library configuration source file (default),
+ * 				used to build library without examples.
+ * @version	: 1.0
+ * @date	: 26. Mar. 2009
+ * @author	: HieuNguyen
+ **************************************************************************
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * products. This software is supplied &quot;AS IS&quot; without any warranties.
+ * NXP Semiconductors assumes no responsibility or liability for the
+ * use of the software, conveys no license or title under any patent,
+ * copyright, or mask work right to the product. NXP Semiconductors
+ * reserves the right to make changes in the software without
+ * notification. NXP Semiconductors also make no representation or
+ * warranty that such application will be suitable for the specified
+ * use without further testing or modification.
+ **************************************************************************/
+
+/* Library group ----------------------------------------------------------- */
+/** @addtogroup LIBCFG_DEFAULT
+ * @{
+ */
+
+/* Includes ------------------------------------------------------------------- */
+#include &quot;lpc17xx_libcfg_default.h&quot;
+
+/* Public Functions ----------------------------------------------------------- */
+/** @addtogroup LIBCFG_DEFAULT_Public_Functions
+ * @{
+ */
+
+#ifndef __BUILD_WITH_EXAMPLE__
+
+#ifdef  DEBUG
+/*******************************************************************************
+* @brief		Reports the name of the source file and the source line number
+* 				where the CHECK_PARAM error has occurred.
+* @param[in]	file Pointer to the source file name
+* @param[in]    line assert_param error line source number
+* @return		None
+*******************************************************************************/
+void check_failed(uint8_t *file, uint32_t line)
+{
+	/* User can add his own implementation to report the file name and line number,
+	 ex: printf(&quot;Wrong parameters value: file %s on line %d\r\n&quot;, file, line) */
+
+	/* Infinite loop */
+	while(1);
+}
+#endif /* DEBUG */
+
+#endif /* __BUILD_WITH_EXAMPLE__ */
+
+/**
+ * @}
+ */
+
+/**
+ * @}
+ */
+
+/* --------------------------------- End Of File ------------------------------ */


Property changes on: trunk/src/platform/lpc17xx/drivers/src/lpc17xx_libcfg_default.c
___________________________________________________________________
Deleted: svn:executable
   - *

Modified: trunk/src/platform/lpc17xx/drivers/src/lpc17xx_mcpwm.c
===================================================================
--- trunk/src/platform/lpc17xx/drivers/src/lpc17xx_mcpwm.c	2010-06-28 21:53:59 UTC (rev 759)
+++ trunk/src/platform/lpc17xx/drivers/src/lpc17xx_mcpwm.c	2010-07-12 20:56:54 UTC (rev 760)
@@ -1,481 +1,481 @@
-/**
- * @file	: lpc17xx_mcpwm.c
- * @brief	: Contains all functions support for Motor Control PWM firmware
- * 				library on LPC17xx
- * @version	: 1.0
- * @date	: 26. May. 2009
- * @author	: HieuNguyen
- *----------------------------------------------------------------------------
- * Software that is described herein is for illustrative purposes only
- * which provides customers with programming information regarding the
- * products. This software is supplied &quot;AS IS&quot; without any warranties.
- * NXP Semiconductors assumes no responsibility or liability for the
- * use of the software, conveys no license or title under any patent,
- * copyright, or mask work right to the product. NXP Semiconductors
- * reserves the right to make changes in the software without
- * notification. NXP Semiconductors also make no representation or
- * warranty that such application will be suitable for the specified
- * use without further testing or modification.
- **********************************************************************/
-
-/* Peripheral group ----------------------------------------------------------- */
-/** @addtogroup MCPWM
- * @{
- */
-
-/* Includes ------------------------------------------------------------------- */
-#include &quot;lpc17xx_mcpwm.h&quot;
-#include &quot;lpc17xx_clkpwr.h&quot;
-
-/* If this source file built with example, the LPC17xx FW library configuration
- * file in each example directory (&quot;lpc17xx_libcfg.h&quot;) must be included,
- * otherwise the default FW library configuration file must be included instead
- */
-#ifdef __BUILD_WITH_EXAMPLE__
-#include &quot;lpc17xx_libcfg.h&quot;
-#else
-#include &quot;lpc17xx_libcfg_default.h&quot;
-#endif /* __BUILD_WITH_EXAMPLE__ */
-
-
-#ifdef _MCPWM
-
-/* Public Functions ----------------------------------------------------------- */
-/** @addtogroup MCPWM_Public_Functions
- * @{
- */
-
-/*********************************************************************//**
- * @brief		Initializes the MCPWM peripheral
- * @param[in]	MCPWMx 		Motor Control PWM peripheral selected, should be MCPWM
- * @return		None
- **********************************************************************/
-void MCPWM_Init(MCPWM_TypeDef *MCPWMx)
-{
-
-	/* Turn On MCPWM PCLK */
-	CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCMC, ENABLE);
-	/* As default, peripheral clock for MCPWM module
-	 * is set to FCCLK / 2 */
-	// CLKPWR_SetPCLKDiv(CLKPWR_PCLKSEL_MC, CLKPWR_PCLKSEL_CCLK_DIV_2);
-
-	MCPWMx-&gt;MCCAP_CLR = MCPWM_CAPCLR_CAP(0) | MCPWM_CAPCLR_CAP(1) | MCPWM_CAPCLR_CAP(2);
-	MCPWMx-&gt;MCINTFLAG_CLR = MCPWM_INT_ILIM(0) | MCPWM_INT_ILIM(1) | MCPWM_INT_ILIM(2) \
-							| MCPWM_INT_IMAT(0) | MCPWM_INT_IMAT(1) | MCPWM_INT_IMAT(2) \
-							| MCPWM_INT_ICAP(0) | MCPWM_INT_ICAP(1) | MCPWM_INT_ICAP(2);
-	MCPWMx-&gt;MCINTEN_CLR = MCPWM_INT_ILIM(0) | MCPWM_INT_ILIM(1) | MCPWM_INT_ILIM(2) \
-							| MCPWM_INT_IMAT(0) | MCPWM_INT_IMAT(1) | MCPWM_INT_IMAT(2) \
-							| MCPWM_INT_ICAP(0) | MCPWM_INT_ICAP(1) | MCPWM_INT_ICAP(2);
-}
-
-
-/*********************************************************************//**
- * @brief		Configures each channel in MCPWM peripheral according to the
- * 				specified parameters in the MCPWM_CHANNEL_CFG_Type.
- * @param[in]	MCPWMx 			Motor Control PWM peripheral selected, should be MCPWM
- * @param[in]	channelNum		Channel number, should be in range from 0 to 2.
- * @param[in]	channelSetup	Pointer to a MCPWM_CHANNEL_CFG_Type structure
-*                    			that contains the configuration information for the
-*                    			specified MCPWM channel.
- * @return		None
- **********************************************************************/
-void MCPWM_ConfigChannel(MCPWM_TypeDef *MCPWMx, uint32_t channelNum,
-						MCPWM_CHANNEL_CFG_Type * channelSetup)
-{
-	if ((channelNum &gt;= 0) &amp;&amp; (channelNum &lt;= 2)) {
-		if (channelNum == 0) {
-			MCPWMx-&gt;MCTIM0 = channelSetup-&gt;channelTimercounterValue;
-			MCPWMx-&gt;MCPER0 = channelSetup-&gt;channelPeriodValue;
-			MCPWMx-&gt;MCPW0 = channelSetup-&gt;channelPulsewidthValue;
-		} else if (channelNum == 1) {
-			MCPWMx-&gt;MCTIM1 = channelSetup-&gt;channelTimercounterValue;
-			MCPWMx-&gt;MCPER1 = channelSetup-&gt;channelPeriodValue;
-			MCPWMx-&gt;MCPW1 = channelSetup-&gt;channelPulsewidthValue;
-		} else if (channelNum == 2) {
-			MCPWMx-&gt;MCTIM2 = channelSetup-&gt;channelTimercounterValue;
-			MCPWMx-&gt;MCPER2 = channelSetup-&gt;channelPeriodValue;
-			MCPWMx-&gt;MCPW2 = channelSetup-&gt;channelPulsewidthValue;
-		} else {
-			return;
-		}
-
-		if (channelSetup-&gt;channelType /* == MCPWM_CHANNEL_CENTER_MODE */){
-			MCPWMx-&gt;MCCON_SET = MCPWM_CON_CENTER(channelNum);
-		} else {
-			MCPWMx-&gt;MCCON_CLR = MCPWM_CON_CENTER(channelNum);
-		}
-
-		if (channelSetup-&gt;channelPolarity /* == MCPWM_CHANNEL_PASSIVE_HI */){
-			MCPWMx-&gt;MCCON_SET = MCPWM_CON_POLAR(channelNum);
-		} else {
-			MCPWMx-&gt;MCCON_CLR = MCPWM_CON_POLAR(channelNum);
-		}
-
-		if (channelSetup-&gt;channelDeadtimeEnable /* == ENABLE */){
-			MCPWMx-&gt;MCCON_SET = MCPWM_CON_DTE(channelNum);
-			MCPWMx-&gt;MCDEADTIME &amp;= ~(MCPWM_DT(channelNum, 0x3FF));
-			MCPWMx-&gt;MCDEADTIME |= MCPWM_DT(channelNum, channelSetup-&gt;channelDeadtimeValue);
-		} else {
-			MCPWMx-&gt;MCCON_CLR = MCPWM_CON_DTE(channelNum);
-		}
-
-		if (channelSetup-&gt;channelUpdateEnable /* == ENABLE */){
-			MCPWMx-&gt;MCCON_CLR = MCPWM_CON_DISUP(channelNum);
-		} else {
-			MCPWMx-&gt;MCCON_SET = MCPWM_CON_DISUP(channelNum);
-		}
-	}
-}
-
-
-/*********************************************************************//**
- * @brief		Write to MCPWM shadow registers - Update the value for period
- * 				and pulse width in MCPWM peripheral.
- * @param[in]	MCPWMx 			Motor Control PWM peripheral selected, should be MCPWM
- * @param[in]	channelNum		Channel Number, should be in range from 0 to 2.
- * @param[in]	channelSetup	Pointer to a MCPWM_CHANNEL_CFG_Type structure
-*                    			that contains the configuration information for the
-*                    			specified MCPWM channel.
- * @return		None
- **********************************************************************/
-void MCPWM_WriteToShadow(MCPWM_TypeDef *MCPWMx, uint32_t channelNum,
-								MCPWM_CHANNEL_CFG_Type *channelSetup)
-{
-	if (channelNum == 0){
-		MCPWMx-&gt;MCPER0 = channelSetup-&gt;channelPeriodValue;
-		MCPWMx-&gt;MCPW0 = channelSetup-&gt;channelPulsewidthValue;
-	} else if (channelNum == 1) {
-		MCPWMx-&gt;MCPER1 = channelSetup-&gt;channelPeriodValue;
-		MCPWMx-&gt;MCPW1 = channelSetup-&gt;channelPulsewidthValue;
-	} else if (channelNum == 2) {
-		MCPWMx-&gt;MCPER2 = channelSetup-&gt;channelPeriodValue;
-		MCPWMx-&gt;MCPW2 = channelSetup-&gt;channelPulsewidthValue;
-	}
-}
-
-
-
-/*********************************************************************//**
- * @brief		Configures capture function in MCPWM peripheral
- * @param[in]	MCPWMx 			Motor Control PWM peripheral selected, should be MCPWM
- * @param[in]	channelNum		MCI (Motor Control Input pin) number, should be in range from 0 to 2.
- * @param[in]	captureConfig	Pointer to a MCPWM_CAPTURE_CFG_Type structure
-*                    			that contains the configuration information for the
-*                    			specified MCPWM capture.
- * @return
- **********************************************************************/
-void MCPWM_ConfigCapture(MCPWM_TypeDef *MCPWMx, uint32_t channelNum,
-						MCPWM_CAPTURE_CFG_Type *captureConfig)
-{
-	if ((channelNum &gt;= 0) &amp;&amp; (channelNum &lt;= 2)) {
-
-		if (captureConfig-&gt;captureFalling /* == ENABLE */) {
-			MCPWMx-&gt;MCCAPCON_SET = MCPWM_CAPCON_CAPMCI_FE(captureConfig-&gt;captureChannel, channelNum);
-		} else {
-			MCPWMx-&gt;MCCAPCON_CLR = MCPWM_CAPCON_CAPMCI_FE(captureConfig-&gt;captureChannel, channelNum);
-		}
-
-		if (captureConfig-&gt;captureRising /* == ENABLE */) {
-			MCPWMx-&gt;MCCAPCON_SET = MCPWM_CAPCON_CAPMCI_RE(captureConfig-&gt;captureChannel, channelNum);
-		} else {
-			MCPWMx-&gt;MCCAPCON_CLR = MCPWM_CAPCON_CAPMCI_RE(captureConfig-&gt;captureChannel, channelNum);
-		}
-
-		if (captureConfig-&gt;timerReset /* == ENABLE */){
-			MCPWMx-&gt;MCCAPCON_SET = MCPWM_CAPCON_RT(captureConfig-&gt;captureChannel);
-		} else {
-			MCPWMx-&gt;MCCAPCON_CLR = MCPWM_CAPCON_RT(captureConfig-&gt;captureChannel);
-		}
-
-		if (captureConfig-&gt;hnfEnable /* == ENABLE */){
-			MCPWMx-&gt;MCCAPCON_SET = MCPWM_CAPCON_HNFCAP(channelNum);
-		} else {
-			MCPWMx-&gt;MCCAPCON_CLR = MCPWM_CAPCON_HNFCAP(channelNum);
-		}
-	}
-}
-
-
-/*********************************************************************//**
- * @brief		Clears current captured value in specified capture channel
- * @param[in]	MCPWMx 		Motor Control PWM peripheral selected, should be MCPWM
- * @param[in]	captureChannel	Capture channel number, should be in range from 0 to 2
- * @return		None
- **********************************************************************/
-void MCPWM_ClearCapture(MCPWM_TypeDef *MCPWMx, uint32_t captureChannel)
-{
-	MCPWMx-&gt;MCCAP_CLR = MCPWM_CAPCLR_CAP(captureChannel);
-}
-
-/*********************************************************************//**
- * @brief		Get current captured value in specified capture channel
- * @param[in]	MCPWMx 		Motor Control PWM peripheral selected, should be MCPWM
- * @param[in]	captureChannel	Capture channel number, should be in range from 0 to 2
- * @return		None
- **********************************************************************/
-uint32_t MCPWM_GetCapture(MCPWM_TypeDef *MCPWMx, uint32_t captureChannel)
-{
-	if (captureChannel == 0){
-		return (MCPWMx-&gt;MCCR0);
-	} else if (captureChannel == 1) {
-		return (MCPWMx-&gt;MCCR1);
-	} else if (captureChannel == 2) {
-		return (MCPWMx-&gt;MCCR2);
-	}
-	return (0);
-}
-
-
-/*********************************************************************//**
- * @brief		Configures Count control in MCPWM peripheral
- * @param[in]	MCPWMx 		Motor Control PWM peripheral selected, should be MCPWM
- * @param[in]	channelNum	Channel number, should be in range from 0 to 2
- * @param[in]	countMode	Count mode, should be:
- * 							- ENABLE: Enables count mode.
- * 							- DISABLE: Disable count mode, the channel is in timer mode.
- * @param[in]	countConfig	Pointer to a MCPWM_COUNT_CFG_Type structure
-*                    		that contains the configuration information for the
-*                    		specified MCPWM count control.
- * @return		None
- **********************************************************************/
-void MCPWM_CountConfig(MCPWM_TypeDef *MCPWMx, uint32_t channelNum,
-					uint32_t countMode, MCPWM_COUNT_CFG_Type *countConfig)
-{
-	if ((channelNum &gt;= 0) &amp;&amp; (channelNum &lt;= 2)) {
-		if (countMode /* == ENABLE */){
-			MCPWMx-&gt;MCCNTCON_SET = MCPWM_CNTCON_CNTR(channelNum);
-			if (countConfig-&gt;countFalling /* == ENABLE */) {
-				MCPWMx-&gt;MCCNTCON_SET = MCPWM_CNTCON_TCMCI_FE(countConfig-&gt;counterChannel,channelNum);
-			} else {
-				MCPWMx-&gt;MCCNTCON_CLR = MCPWM_CNTCON_TCMCI_FE(countConfig-&gt;counterChannel,channelNum);
-			}
-			if (countConfig-&gt;countRising /* == ENABLE */) {
-				MCPWMx-&gt;MCCNTCON_SET = MCPWM_CNTCON_TCMCI_RE(countConfig-&gt;counterChannel,channelNum);
-			} else {
-				MCPWMx-&gt;MCCNTCON_CLR = MCPWM_CNTCON_TCMCI_RE(countConfig-&gt;counterChannel,channelNum);
-			}
-		} else {
-			MCPWMx-&gt;MCCNTCON_CLR = MCPWM_CNTCON_CNTR(channelNum);
-		}
-	}
-}
-
-
-/*********************************************************************//**
- * @brief		Start MCPWM activity for each MCPWM channel
- * @param[in]	MCPWMx 		Motor Control PWM peripheral selected, should be MCPWM
- * @param[in]	channel0	State of this command on channel 0:
- * 							- ENABLE: 'Start' command will effect on channel 0
- * 							- DISABLE: 'Start' command will not effect on channel 0
- * @param[in]	channel1	State of this command on channel 1:
- * 							- ENABLE: 'Start' command will effect on channel 1
- * 							- DISABLE: 'Start' command will not effect on channel 1
- * @param[in]	channel2	State of this command on channel 2:
- * 							- ENABLE: 'Start' command will effect on channel 2
- * 							- DISABLE: 'Start' command will not effect on channel 2
- * @return		None
- **********************************************************************/
-void MCPWM_Start(MCPWM_TypeDef *MCPWMx, uint32_t channel0,
-					uint32_t channel1, uint32_t channel2)
-{
-	uint32_t regVal = 0;
-	regVal = (channel0 ? MCPWM_CON_RUN(0) : 0) | (channel1 ? MCPWM_CON_RUN(1) : 0) \
-				| (channel2 ? MCPWM_CON_RUN(2) : 0);
-	MCPWMx-&gt;MCCON_SET = regVal;
-}
-
-
-/*********************************************************************//**
- * @brief		Stop MCPWM activity for each MCPWM channel
- * @param[in]	MCPWMx 		Motor Control PWM peripheral selected, should be MCPWM
- * @param[in]	channel0	State of this command on channel 0:
- * 							- ENABLE: 'Stop' command will effect on channel 0
- * 							- DISABLE: 'Stop' command will not effect on channel 0
- * @param[in]	channel1	State of this command on channel 1:
- * 							- ENABLE: 'Stop' command will effect on channel 1
- * 							- DISABLE: 'Stop' command will not effect on channel 1
- * @param[in]	channel2	State of this command on channel 2:
- * 							- ENABLE: 'Stop' command will effect on channel 2
- * 							- DISABLE: 'Stop' command will not effect on channel 2
- * @return		None
- **********************************************************************/
-void MCPWM_Stop(MCPWM_TypeDef *MCPWMx, uint32_t channel0,
-		uint32_t channel1, uint32_t channel2)
-{
-	uint32_t regVal = 0;
-	regVal = (channel0 ? MCPWM_CON_RUN(0) : 0) | (channel1 ? MCPWM_CON_RUN(1) : 0) \
-				| (channel2 ? MCPWM_CON_RUN(2) : 0);
-	MCPWMx-&gt;MCCON_CLR = regVal;
-}
-
-
-/*********************************************************************//**
- * @brief		Enables/Disables 3-phase AC motor mode on MCPWM peripheral
- * @param[in]	MCPWMx 		Motor Control PWM peripheral selected, should be MCPWM
- * @param[in]	acMode		State of this command, should be:
- * 							- ENABLE.
- * 							- DISABLE.
- * @return		None
- **********************************************************************/
-void MCPWM_ACMode(MCPWM_TypeDef *MCPWMx, uint32_t acMode)
-{
-	if (acMode){
-		MCPWMx-&gt;MCCON_SET = MCPWM_CON_ACMODE;
-	} else {
-		MCPWMx-&gt;MCCON_CLR = MCPWM_CON_ACMODE;
-	}
-}
-
-
-/*********************************************************************//**
- * @brief		Enables/Disables 3-phase DC motor mode on MCPWM peripheral
- * @param[in]	MCPWMx 			Motor Control PWM peripheral selected, should be MCPWM
- * @param[in]	dcMode			State of this command, should be:
- * 								- ENABLE.
- * 								- DISABLE.
- * @param[in]	outputInvered	Polarity of the MCOB outputs for all 3 channels,
- * 								should be:
- * 								- ENABLE: The MCOB outputs have opposite polarity
- * 									from the MCOA outputs.
- * 								- DISABLE: The MCOB outputs have the same basic
- * 									polarity as the MCOA outputs.
- * @param[in]	outputPatent	A value contains bits that enables/disables the specified
- * 								output pins route to the internal MCOA0 signal, should be:
-								- MCPWM_PATENT_A0: 	 MCOA0 tracks internal MCOA0
-								- MCPWM_PATENT_B0: 	 MCOB0 tracks internal MCOA0
-								- MCPWM_PATENT_A1: 	 MCOA1 tracks internal MCOA0
-								- MCPWM_PATENT_B1: 	 MCOB1 tracks internal MCOA0
-								- MCPWM_PATENT_A2: 	 MCOA2 tracks internal MCOA0
-								- MCPWM_PATENT_B2: 	 MCOB2 tracks internal MCOA0
- * @return		None
- *
- * Note: all these outputPatent values above can be ORed together for using as input parameter.
- **********************************************************************/
-void MCPWM_DCMode(MCPWM_TypeDef *MCPWMx, uint32_t dcMode,
-					uint32_t outputInvered, uint32_t outputPattern)
-{
-	if (dcMode){
-		MCPWMx-&gt;MCCON_SET = MCPWM_CON_DCMODE;
-	} else {
-		MCPWMx-&gt;MCCON_CLR = MCPWM_CON_DCMODE;
-	}
-
-	if (outputInvered) {
-		MCPWMx-&gt;MCCON_SET = MCPWM_CON_INVBDC;
-	} else {
-		MCPWMx-&gt;MCCON_CLR = MCPWM_CON_INVBDC;
-	}
-
-	MCPWMx-&gt;MCCCP = outputPattern;
-}
-
-
-/*********************************************************************//**
- * @brief		Configures the specified interrupt in MCPWM peripheral
- * @param[in]	MCPWMx 		Motor Control PWM peripheral selected, should be MCPWM
- * @param[in]	ulIntType	Interrupt type, should be:
- * 							- MCPWM_INTFLAG_LIM0: Limit interrupt for channel (0)
- * 							- MCPWM_INTFLAG_MAT0: Match interrupt for channel (0)
- * 							- MCPWM_INTFLAG_CAP0: Capture interrupt for channel (0)
- * 							- MCPWM_INTFLAG_LIM1: Limit interrupt for channel (1)
- * 							- MCPWM_INTFLAG_MAT1: Match interrupt for channel (1)
- * 							- MCPWM_INTFLAG_CAP1: Capture interrupt for channel (1)
- * 							- MCPWM_INTFLAG_LIM2: Limit interrupt for channel (2)
- * 							- MCPWM_INTFLAG_MAT2: Match interrupt for channel (2)
- * 							- MCPWM_INTFLAG_CAP2: Capture interrupt for channel (2)
- * 							- MCPWM_INTFLAG_ABORT: Fast abort interrupt
- * @param[in]	NewState	New State of this command, should be:
- * 							- ENABLE.
- * 							- DISABLE.
- * @return		None
- *
- * Note: all these ulIntType values above can be ORed together for using as input parameter.
- **********************************************************************/
-void MCPWM_IntConfig(MCPWM_TypeDef *MCPWMx, uint32_t ulIntType, FunctionalState NewState)
-{
-	if (NewState) {
-		MCPWMx-&gt;MCINTEN_SET = ulIntType;
-	} else {
-		MCPWMx-&gt;MCINTEN_CLR = ulIntType;
-	}
-}
-
-
-/*********************************************************************//**
- * @brief		Sets/Forces the specified interrupt for MCPWM peripheral
- * @param[in]	MCPWMx 		Motor Control PWM peripheral selected, should be MCPWM
- * @param[in]	ulIntType	Interrupt type, should be:
- * 							- MCPWM_INTFLAG_LIM0: Limit interrupt for channel (0)
- * 							- MCPWM_INTFLAG_MAT0: Match interrupt for channel (0)
- * 							- MCPWM_INTFLAG_CAP0: Capture interrupt for channel (0)
- * 							- MCPWM_INTFLAG_LIM1: Limit interrupt for channel (1)
- * 							- MCPWM_INTFLAG_MAT1: Match interrupt for channel (1)
- * 							- MCPWM_INTFLAG_CAP1: Capture interrupt for channel (1)
- * 							- MCPWM_INTFLAG_LIM2: Limit interrupt for channel (2)
- * 							- MCPWM_INTFLAG_MAT2: Match interrupt for channel (2)
- * 							- MCPWM_INTFLAG_CAP2: Capture interrupt for channel (2)
- * 							- MCPWM_INTFLAG_ABORT: Fast abort interrupt
- * @return		None
- * Note: all these ulIntType values above can be ORed together for using as input parameter.
- **********************************************************************/
-void MCPWM_IntSet(MCPWM_TypeDef *MCPWMx, uint32_t ulIntType)
-{
-	MCPWMx-&gt;MCINTFLAG_SET = ulIntType;
-}
-
-
-/*********************************************************************//**
- * @brief		Clear the specified interrupt pending for MCPWM peripheral
- * @param[in]	MCPWMx 		Motor Control PWM peripheral selected, should be MCPWM
- * @param[in]	ulIntType	Interrupt type, should be:
- * 							- MCPWM_INTFLAG_LIM0: Limit interrupt for channel (0)
- * 							- MCPWM_INTFLAG_MAT0: Match interrupt for channel (0)
- * 							- MCPWM_INTFLAG_CAP0: Capture interrupt for channel (0)
- * 							- MCPWM_INTFLAG_LIM1: Limit interrupt for channel (1)
- * 							- MCPWM_INTFLAG_MAT1: Match interrupt for channel (1)
- * 							- MCPWM_INTFLAG_CAP1: Capture interrupt for channel (1)
- * 							- MCPWM_INTFLAG_LIM2: Limit interrupt for channel (2)
- * 							- MCPWM_INTFLAG_MAT2: Match interrupt for channel (2)
- * 							- MCPWM_INTFLAG_CAP2: Capture interrupt for channel (2)
- * 							- MCPWM_INTFLAG_ABORT: Fast abort interrupt
- * @return		None
- * Note: all these ulIntType values above can be ORed together for using as input parameter.
- **********************************************************************/
-void MCPWM_IntClear(MCPWM_TypeDef *MCPWMx, uint32_t ulIntType)
-{
-	MCPWMx-&gt;MCINTFLAG_CLR = ulIntType;
-}
-
-
-/*********************************************************************//**
- * @brief		Check whether if the specified interrupt in MCPWM is set or not
- * @param[in]	MCPWMx 		Motor Control PWM peripheral selected, should be MCPWM
- * @param[in]	ulIntType	Interrupt type, should be:
- * 							- MCPWM_INTFLAG_LIM0: Limit interrupt for channel (0)
- * 							- MCPWM_INTFLAG_MAT0: Match interrupt for channel (0)
- * 							- MCPWM_INTFLAG_CAP0: Capture interrupt for channel (0)
- * 							- MCPWM_INTFLAG_LIM1: Limit interrupt for channel (1)
- * 							- MCPWM_INTFLAG_MAT1: Match interrupt for channel (1)
- * 							- MCPWM_INTFLAG_CAP1: Capture interrupt for channel (1)
- * 							- MCPWM_INTFLAG_LIM2: Limit interrupt for channel (2)
- * 							- MCPWM_INTFLAG_MAT2: Match interrupt for channel (2)
- * 							- MCPWM_INTFLAG_CAP2: Capture interrupt for channel (2)
- * 							- MCPWM_INTFLAG_ABORT: Fast abort interrupt
- * @return		None
- **********************************************************************/
-FlagStatus MCPWM_GetIntStatus(MCPWM_TypeDef *MCPWMx, uint32_t ulIntType)
-{
-	return ((MCPWMx-&gt;MCINTFLAG &amp; ulIntType) ? SET : RESET);
-}
-
-/**
- * @}
- */
-
-#endif /* _MCPWM */
-
-/**
- * @}
- */
-
-/* --------------------------------- End Of File ------------------------------ */
+/**
+ * @file	: lpc17xx_mcpwm.c
+ * @brief	: Contains all functions support for Motor Control PWM firmware
+ * 				library on LPC17xx
+ * @version	: 1.0
+ * @date	: 26. May. 2009
+ * @author	: HieuNguyen
+ **************************************************************************
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * products. This software is supplied &quot;AS IS&quot; without any warranties.
+ * NXP Semiconductors assumes no responsibility or liability for the
+ * use of the software, conveys no license or title under any patent,
+ * copyright, or mask work right to the product. NXP Semiconductors
+ * reserves the right to make changes in the software without
+ * notification. NXP Semiconductors also make no representation or
+ * warranty that such application will be suitable for the specified
+ * use without further testing or modification.
+ **********************************************************************/
+
+/* Peripheral group ----------------------------------------------------------- */
+/** @addtogroup MCPWM
+ * @{
+ */
+
+/* Includes ------------------------------------------------------------------- */
+#include &quot;lpc17xx_mcpwm.h&quot;
+#include &quot;lpc17xx_clkpwr.h&quot;
+
+/* If this source file built with example, the LPC17xx FW library configuration
+ * file in each example directory (&quot;lpc17xx_libcfg.h&quot;) must be included,
+ * otherwise the default FW library configuration file must be included instead
+ */
+#ifdef __BUILD_WITH_EXAMPLE__
+#include &quot;lpc17xx_libcfg.h&quot;
+#else
+#include &quot;lpc17xx_libcfg_default.h&quot;
+#endif /* __BUILD_WITH_EXAMPLE__ */
+
+
+#ifdef _MCPWM
+
+/* Public Functions ----------------------------------------------------------- */
+/** @addtogroup MCPWM_Public_Functions
+ * @{
+ */
+
+/*********************************************************************//**
+ * @brief		Initializes the MCPWM peripheral
+ * @param[in]	MCPWMx 		Motor Control PWM peripheral selected, should be MCPWM
+ * @return		None
+ **********************************************************************/
+void MCPWM_Init(LPC_MCPWM_TypeDef *MCPWMx)
+{
+
+	/* Turn On MCPWM PCLK */
+	CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCMC, ENABLE);
+	/* As default, peripheral clock for MCPWM module
+	 * is set to FCCLK / 2 */
+	// CLKPWR_SetPCLKDiv(CLKPWR_PCLKSEL_MC, CLKPWR_PCLKSEL_CCLK_DIV_2);
+
+	MCPWMx-&gt;MCCAP_CLR = MCPWM_CAPCLR_CAP(0) | MCPWM_CAPCLR_CAP(1) | MCPWM_CAPCLR_CAP(2);
+	MCPWMx-&gt;MCINTFLAG_CLR = MCPWM_INT_ILIM(0) | MCPWM_INT_ILIM(1) | MCPWM_INT_ILIM(2) \
+							| MCPWM_INT_IMAT(0) | MCPWM_INT_IMAT(1) | MCPWM_INT_IMAT(2) \
+							| MCPWM_INT_ICAP(0) | MCPWM_INT_ICAP(1) | MCPWM_INT_ICAP(2);
+	MCPWMx-&gt;MCINTEN_CLR = MCPWM_INT_ILIM(0) | MCPWM_INT_ILIM(1) | MCPWM_INT_ILIM(2) \
+							| MCPWM_INT_IMAT(0) | MCPWM_INT_IMAT(1) | MCPWM_INT_IMAT(2) \
+							| MCPWM_INT_ICAP(0) | MCPWM_INT_ICAP(1) | MCPWM_INT_ICAP(2);
+}
+
+
+/*********************************************************************//**
+ * @brief		Configures each channel in MCPWM peripheral according to the
+ * 				specified parameters in the MCPWM_CHANNEL_CFG_Type.
+ * @param[in]	MCPWMx 			Motor Control PWM peripheral selected, should be MCPWM
+ * @param[in]	channelNum		Channel number, should be in range from 0 to 2.
+ * @param[in]	channelSetup	Pointer to a MCPWM_CHANNEL_CFG_Type structure
+*                    			that contains the configuration information for the
+*                    			specified MCPWM channel.
+ * @return		None
+ **********************************************************************/
+void MCPWM_ConfigChannel(LPC_MCPWM_TypeDef *MCPWMx, uint32_t channelNum,
+						MCPWM_CHANNEL_CFG_Type * channelSetup)
+{
+	if ((channelNum &gt;= 0) &amp;&amp; (channelNum &lt;= 2)) {
+		if (channelNum == 0) {
+			MCPWMx-&gt;MCTIM0 = channelSetup-&gt;channelTimercounterValue;
+			MCPWMx-&gt;MCPER0 = channelSetup-&gt;channelPeriodValue;
+			MCPWMx-&gt;MCPW0 = channelSetup-&gt;channelPulsewidthValue;
+		} else if (channelNum == 1) {
+			MCPWMx-&gt;MCTIM1 = channelSetup-&gt;channelTimercounterValue;
+			MCPWMx-&gt;MCPER1 = channelSetup-&gt;channelPeriodValue;
+			MCPWMx-&gt;MCPW1 = channelSetup-&gt;channelPulsewidthValue;
+		} else if (channelNum == 2) {
+			MCPWMx-&gt;MCTIM2 = channelSetup-&gt;channelTimercounterValue;
+			MCPWMx-&gt;MCPER2 = channelSetup-&gt;channelPeriodValue;
+			MCPWMx-&gt;MCPW2 = channelSetup-&gt;channelPulsewidthValue;
+		} else {
+			return;
+		}
+
+		if (channelSetup-&gt;channelType /* == MCPWM_CHANNEL_CENTER_MODE */){
+			MCPWMx-&gt;MCCON_SET = MCPWM_CON_CENTER(channelNum);
+		} else {
+			MCPWMx-&gt;MCCON_CLR = MCPWM_CON_CENTER(channelNum);
+		}
+
+		if (channelSetup-&gt;channelPolarity /* == MCPWM_CHANNEL_PASSIVE_HI */){
+			MCPWMx-&gt;MCCON_SET = MCPWM_CON_POLAR(channelNum);
+		} else {
+			MCPWMx-&gt;MCCON_CLR = MCPWM_CON_POLAR(channelNum);
+		}
+
+		if (channelSetup-&gt;channelDeadtimeEnable /* == ENABLE */){
+			MCPWMx-&gt;MCCON_SET = MCPWM_CON_DTE(channelNum);
+			MCPWMx-&gt;MCDEADTIME &amp;= ~(MCPWM_DT(channelNum, 0x3FF));
+			MCPWMx-&gt;MCDEADTIME |= MCPWM_DT(channelNum, channelSetup-&gt;channelDeadtimeValue);
+		} else {
+			MCPWMx-&gt;MCCON_CLR = MCPWM_CON_DTE(channelNum);
+		}
+
+		if (channelSetup-&gt;channelUpdateEnable /* == ENABLE */){
+			MCPWMx-&gt;MCCON_CLR = MCPWM_CON_DISUP(channelNum);
+		} else {
+			MCPWMx-&gt;MCCON_SET = MCPWM_CON_DISUP(channelNum);
+		}
+	}
+}
+
+
+/*********************************************************************//**
+ * @brief		Write to MCPWM shadow registers - Update the value for period
+ * 				and pulse width in MCPWM peripheral.
+ * @param[in]	MCPWMx 			Motor Control PWM peripheral selected, should be MCPWM
+ * @param[in]	channelNum		Channel Number, should be in range from 0 to 2.
+ * @param[in]	channelSetup	Pointer to a MCPWM_CHANNEL_CFG_Type structure
+*                    			that contains the configuration information for the
+*                    			specified MCPWM channel.
+ * @return		None
+ **********************************************************************/
+void MCPWM_WriteToShadow(LPC_MCPWM_TypeDef *MCPWMx, uint32_t channelNum,
+								MCPWM_CHANNEL_CFG_Type *channelSetup)
+{
+	if (channelNum == 0){
+		MCPWMx-&gt;MCPER0 = channelSetup-&gt;channelPeriodValue;
+		MCPWMx-&gt;MCPW0 = channelSetup-&gt;channelPulsewidthValue;
+	} else if (channelNum == 1) {
+		MCPWMx-&gt;MCPER1 = channelSetup-&gt;channelPeriodValue;
+		MCPWMx-&gt;MCPW1 = channelSetup-&gt;channelPulsewidthValue;
+	} else if (channelNum == 2) {
+		MCPWMx-&gt;MCPER2 = channelSetup-&gt;channelPeriodValue;
+		MCPWMx-&gt;MCPW2 = channelSetup-&gt;channelPulsewidthValue;
+	}
+}
+
+
+
+/*********************************************************************//**
+ * @brief		Configures capture function in MCPWM peripheral
+ * @param[in]	MCPWMx 			Motor Control PWM peripheral selected, should be MCPWM
+ * @param[in]	channelNum		MCI (Motor Control Input pin) number, should be in range from 0 to 2.
+ * @param[in]	captureConfig	Pointer to a MCPWM_CAPTURE_CFG_Type structure
+*                    			that contains the configuration information for the
+*                    			specified MCPWM capture.
+ * @return
+ **********************************************************************/
+void MCPWM_ConfigCapture(LPC_MCPWM_TypeDef *MCPWMx, uint32_t channelNum,
+						MCPWM_CAPTURE_CFG_Type *captureConfig)
+{
+	if ((channelNum &gt;= 0) &amp;&amp; (channelNum &lt;= 2)) {
+
+		if (captureConfig-&gt;captureFalling /* == ENABLE */) {
+			MCPWMx-&gt;MCCAPCON_SET = MCPWM_CAPCON_CAPMCI_FE(captureConfig-&gt;captureChannel, channelNum);
+		} else {
+			MCPWMx-&gt;MCCAPCON_CLR = MCPWM_CAPCON_CAPMCI_FE(captureConfig-&gt;captureChannel, channelNum);
+		}
+
+		if (captureConfig-&gt;captureRising /* == ENABLE */) {
+			MCPWMx-&gt;MCCAPCON_SET = MCPWM_CAPCON_CAPMCI_RE(captureConfig-&gt;captureChannel, channelNum);
+		} else {
+			MCPWMx-&gt;MCCAPCON_CLR = MCPWM_CAPCON_CAPMCI_RE(captureConfig-&gt;captureChannel, channelNum);
+		}
+
+		if (captureConfig-&gt;timerReset /* == ENABLE */){
+			MCPWMx-&gt;MCCAPCON_SET = MCPWM_CAPCON_RT(captureConfig-&gt;captureChannel);
+		} else {
+			MCPWMx-&gt;MCCAPCON_CLR = MCPWM_CAPCON_RT(captureConfig-&gt;captureChannel);
+		}
+
+		if (captureConfig-&gt;hnfEnable /* == ENABLE */){
+			MCPWMx-&gt;MCCAPCON_SET = MCPWM_CAPCON_HNFCAP(channelNum);
+		} else {
+			MCPWMx-&gt;MCCAPCON_CLR = MCPWM_CAPCON_HNFCAP(channelNum);
+		}
+	}
+}
+
+
+/*********************************************************************//**
+ * @brief		Clears current captured value in specified capture channel
+ * @param[in]	MCPWMx 		Motor Control PWM peripheral selected, should be MCPWM
+ * @param[in]	captureChannel	Capture channel number, should be in range from 0 to 2
+ * @return		None
+ **********************************************************************/
+void MCPWM_ClearCapture(LPC_MCPWM_TypeDef *MCPWMx, uint32_t captureChannel)
+{
+	MCPWMx-&gt;MCCAP_CLR = MCPWM_CAPCLR_CAP(captureChannel);
+}
+
+/*********************************************************************//**
+ * @brief		Get current captured value in specified capture channel
+ * @param[in]	MCPWMx 		Motor Control PWM peripheral selected, should be MCPWM
+ * @param[in]	captureChannel	Capture channel number, should be in range from 0 to 2
+ * @return		None
+ **********************************************************************/
+uint32_t MCPWM_GetCapture(LPC_MCPWM_TypeDef *MCPWMx, uint32_t captureChannel)
+{
+	if (captureChannel == 0){
+		return (MCPWMx-&gt;MCCR0);
+	} else if (captureChannel == 1) {
+		return (MCPWMx-&gt;MCCR1);
+	} else if (captureChannel == 2) {
+		return (MCPWMx-&gt;MCCR2);
+	}
+	return (0);
+}
+
+
+/*********************************************************************//**
+ * @brief		Configures Count control in MCPWM peripheral
+ * @param[in]	MCPWMx 		Motor Control PWM peripheral selected, should be MCPWM
+ * @param[in]	channelNum	Channel number, should be in range from 0 to 2
+ * @param[in]	countMode	Count mode, should be:
+ * 							- ENABLE: Enables count mode.
+ * 							- DISABLE: Disable count mode, the channel is in timer mode.
+ * @param[in]	countConfig	Pointer to a MCPWM_COUNT_CFG_Type structure
+*                    		that contains the configuration information for the
+*                    		specified MCPWM count control.
+ * @return		None
+ **********************************************************************/
+void MCPWM_CountConfig(LPC_MCPWM_TypeDef *MCPWMx, uint32_t channelNum,
+					uint32_t countMode, MCPWM_COUNT_CFG_Type *countConfig)
+{
+	if ((channelNum &gt;= 0) &amp;&amp; (channelNum &lt;= 2)) {
+		if (countMode /* == ENABLE */){
+			MCPWMx-&gt;MCCNTCON_SET = MCPWM_CNTCON_CNTR(channelNum);
+			if (countConfig-&gt;countFalling /* == ENABLE */) {
+				MCPWMx-&gt;MCCNTCON_SET = MCPWM_CNTCON_TCMCI_FE(countConfig-&gt;counterChannel,channelNum);
+			} else {
+				MCPWMx-&gt;MCCNTCON_CLR = MCPWM_CNTCON_TCMCI_FE(countConfig-&gt;counterChannel,channelNum);
+			}
+			if (countConfig-&gt;countRising /* == ENABLE */) {
+				MCPWMx-&gt;MCCNTCON_SET = MCPWM_CNTCON_TCMCI_RE(countConfig-&gt;counterChannel,channelNum);
+			} else {
+				MCPWMx-&gt;MCCNTCON_CLR = MCPWM_CNTCON_TCMCI_RE(countConfig-&gt;counterChannel,channelNum);
+			}
+		} else {
+			MCPWMx-&gt;MCCNTCON_CLR = MCPWM_CNTCON_CNTR(channelNum);
+		}
+	}
+}
+
+
+/*********************************************************************//**
+ * @brief		Start MCPWM activity for each MCPWM channel
+ * @param[in]	MCPWMx 		Motor Control PWM peripheral selected, should be MCPWM
+ * @param[in]	channel0	State of this command on channel 0:
+ * 							- ENABLE: 'Start' command will effect on channel 0
+ * 							- DISABLE: 'Start' command will not effect on channel 0
+ * @param[in]	channel1	State of this command on channel 1:
+ * 							- ENABLE: 'Start' command will effect on channel 1
+ * 							- DISABLE: 'Start' command will not effect on channel 1
+ * @param[in]	channel2	State of this command on channel 2:
+ * 							- ENABLE: 'Start' command will effect on channel 2
+ * 							- DISABLE: 'Start' command will not effect on channel 2
+ * @return		None
+ **********************************************************************/
+void MCPWM_Start(LPC_MCPWM_TypeDef *MCPWMx, uint32_t channel0,
+					uint32_t channel1, uint32_t channel2)
+{
+	uint32_t regVal = 0;
+	regVal = (channel0 ? MCPWM_CON_RUN(0) : 0) | (channel1 ? MCPWM_CON_RUN(1) : 0) \
+				| (channel2 ? MCPWM_CON_RUN(2) : 0);
+	MCPWMx-&gt;MCCON_SET = regVal;
+}
+
+
+/*********************************************************************//**
+ * @brief		Stop MCPWM activity for each MCPWM channel
+ * @param[in]	MCPWMx 		Motor Control PWM peripheral selected, should be MCPWM
+ * @param[in]	channel0	State of this command on channel 0:
+ * 							- ENABLE: 'Stop' command will effect on channel 0
+ * 							- DISABLE: 'Stop' command will not effect on channel 0
+ * @param[in]	channel1	State of this command on channel 1:
+ * 							- ENABLE: 'Stop' command will effect on channel 1
+ * 							- DISABLE: 'Stop' command will not effect on channel 1
+ * @param[in]	channel2	State of this command on channel 2:
+ * 							- ENABLE: 'Stop' command will effect on channel 2
+ * 							- DISABLE: 'Stop' command will not effect on channel 2
+ * @return		None
+ **********************************************************************/
+void MCPWM_Stop(LPC_MCPWM_TypeDef *MCPWMx, uint32_t channel0,
+		uint32_t channel1, uint32_t channel2)
+{
+	uint32_t regVal = 0;
+	regVal = (channel0 ? MCPWM_CON_RUN(0) : 0) | (channel1 ? MCPWM_CON_RUN(1) : 0) \
+				| (channel2 ? MCPWM_CON_RUN(2) : 0);
+	MCPWMx-&gt;MCCON_CLR = regVal;
+}
+
+
+/*********************************************************************//**
+ * @brief		Enables/Disables 3-phase AC motor mode on MCPWM peripheral
+ * @param[in]	MCPWMx 		Motor Control PWM peripheral selected, should be MCPWM
+ * @param[in]	acMode		State of this command, should be:
+ * 							- ENABLE.
+ * 							- DISABLE.
+ * @return		None
+ **********************************************************************/
+void MCPWM_ACMode(LPC_MCPWM_TypeDef *MCPWMx, uint32_t acMode)
+{
+	if (acMode){
+		MCPWMx-&gt;MCCON_SET = MCPWM_CON_ACMODE;
+	} else {
+		MCPWMx-&gt;MCCON_CLR = MCPWM_CON_ACMODE;
+	}
+}
+
+
+/*********************************************************************//**
+ * @brief		Enables/Disables 3-phase DC motor mode on MCPWM peripheral
+ * @param[in]	MCPWMx 			Motor Control PWM peripheral selected, should be MCPWM
+ * @param[in]	dcMode			State of this command, should be:
+ * 								- ENABLE.
+ * 								- DISABLE.
+ * @param[in]	outputInvered	Polarity of the MCOB outputs for all 3 channels,
+ * 								should be:
+ * 								- ENABLE: The MCOB outputs have opposite polarity
+ * 									from the MCOA outputs.
+ * 								- DISABLE: The MCOB outputs have the same basic
+ * 									polarity as the MCOA outputs.
+ * @param[in]	outputPattern	A value contains bits that enables/disables the specified
+ * 								output pins route to the internal MCOA0 signal, should be:
+								- MCPWM_PATENT_A0: 	 MCOA0 tracks internal MCOA0
+								- MCPWM_PATENT_B0: 	 MCOB0 tracks internal MCOA0
+								- MCPWM_PATENT_A1: 	 MCOA1 tracks internal MCOA0
+								- MCPWM_PATENT_B1: 	 MCOB1 tracks internal MCOA0
+								- MCPWM_PATENT_A2: 	 MCOA2 tracks internal MCOA0
+								- MCPWM_PATENT_B2: 	 MCOB2 tracks internal MCOA0
+ * @return		None
+ *
+ * Note: all these outputPatent values above can be ORed together for using as input parameter.
+ **********************************************************************/
+void MCPWM_DCMode(LPC_MCPWM_TypeDef *MCPWMx, uint32_t dcMode,
+					uint32_t outputInvered, uint32_t outputPattern)
+{
+	if (dcMode){
+		MCPWMx-&gt;MCCON_SET = MCPWM_CON_DCMODE;
+	} else {
+		MCPWMx-&gt;MCCON_CLR = MCPWM_CON_DCMODE;
+	}
+
+	if (outputInvered) {
+		MCPWMx-&gt;MCCON_SET = MCPWM_CON_INVBDC;
+	} else {
+		MCPWMx-&gt;MCCON_CLR = MCPWM_CON_INVBDC;
+	}
+
+	MCPWMx-&gt;MCCCP = outputPattern;
+}
+
+
+/*********************************************************************//**
+ * @brief		Configures the specified interrupt in MCPWM peripheral
+ * @param[in]	MCPWMx 		Motor Control PWM peripheral selected, should be MCPWM
+ * @param[in]	ulIntType	Interrupt type, should be:
+ * 							- MCPWM_INTFLAG_LIM0: Limit interrupt for channel (0)
+ * 							- MCPWM_INTFLAG_MAT0: Match interrupt for channel (0)
+ * 							- MCPWM_INTFLAG_CAP0: Capture interrupt for channel (0)
+ * 							- MCPWM_INTFLAG_LIM1: Limit interrupt for channel (1)
+ * 							- MCPWM_INTFLAG_MAT1: Match interrupt for channel (1)
+ * 							- MCPWM_INTFLAG_CAP1: Capture interrupt for channel (1)
+ * 							- MCPWM_INTFLAG_LIM2: Limit interrupt for channel (2)
+ * 							- MCPWM_INTFLAG_MAT2: Match interrupt for channel (2)
+ * 							- MCPWM_INTFLAG_CAP2: Capture interrupt for channel (2)
+ * 							- MCPWM_INTFLAG_ABORT: Fast abort interrupt
+ * @param[in]	NewState	New State of this command, should be:
+ * 							- ENABLE.
+ * 							- DISABLE.
+ * @return		None
+ *
+ * Note: all these ulIntType values above can be ORed together for using as input parameter.
+ **********************************************************************/
+void MCPWM_IntConfig(LPC_MCPWM_TypeDef *MCPWMx, uint32_t ulIntType, FunctionalState NewState)
+{
+	if (NewState) {
+		MCPWMx-&gt;MCINTEN_SET = ulIntType;
+	} else {
+		MCPWMx-&gt;MCINTEN_CLR = ulIntType;
+	}
+}
+
+
+/*********************************************************************//**
+ * @brief		Sets/Forces the specified interrupt for MCPWM peripheral
+ * @param[in]	MCPWMx 		Motor Control PWM peripheral selected, should be MCPWM
+ * @param[in]	ulIntType	Interrupt type, should be:
+ * 							- MCPWM_INTFLAG_LIM0: Limit interrupt for channel (0)
+ * 							- MCPWM_INTFLAG_MAT0: Match interrupt for channel (0)
+ * 							- MCPWM_INTFLAG_CAP0: Capture interrupt for channel (0)
+ * 							- MCPWM_INTFLAG_LIM1: Limit interrupt for channel (1)
+ * 							- MCPWM_INTFLAG_MAT1: Match interrupt for channel (1)
+ * 							- MCPWM_INTFLAG_CAP1: Capture interrupt for channel (1)
+ * 							- MCPWM_INTFLAG_LIM2: Limit interrupt for channel (2)
+ * 							- MCPWM_INTFLAG_MAT2: Match interrupt for channel (2)
+ * 							- MCPWM_INTFLAG_CAP2: Capture interrupt for channel (2)
+ * 							- MCPWM_INTFLAG_ABORT: Fast abort interrupt
+ * @return		None
+ * Note: all these ulIntType values above can be ORed together for using as input parameter.
+ **********************************************************************/
+void MCPWM_IntSet(LPC_MCPWM_TypeDef *MCPWMx, uint32_t ulIntType)
+{
+	MCPWMx-&gt;MCINTFLAG_SET = ulIntType;
+}
+
+
+/*********************************************************************//**
+ * @brief		Clear the specified interrupt pending for MCPWM peripheral
+ * @param[in]	MCPWMx 		Motor Control PWM peripheral selected, should be MCPWM
+ * @param[in]	ulIntType	Interrupt type, should be:
+ * 							- MCPWM_INTFLAG_LIM0: Limit interrupt for channel (0)
+ * 							- MCPWM_INTFLAG_MAT0: Match interrupt for channel (0)
+ * 							- MCPWM_INTFLAG_CAP0: Capture interrupt for channel (0)
+ * 							- MCPWM_INTFLAG_LIM1: Limit interrupt for channel (1)
+ * 							- MCPWM_INTFLAG_MAT1: Match interrupt for channel (1)
+ * 							- MCPWM_INTFLAG_CAP1: Capture interrupt for channel (1)
+ * 							- MCPWM_INTFLAG_LIM2: Limit interrupt for channel (2)
+ * 							- MCPWM_INTFLAG_MAT2: Match interrupt for channel (2)
+ * 							- MCPWM_INTFLAG_CAP2: Capture interrupt for channel (2)
+ * 							- MCPWM_INTFLAG_ABORT: Fast abort interrupt
+ * @return		None
+ * Note: all these ulIntType values above can be ORed together for using as input parameter.
+ **********************************************************************/
+void MCPWM_IntClear(LPC_MCPWM_TypeDef *MCPWMx, uint32_t ulIntType)
+{
+	MCPWMx-&gt;MCINTFLAG_CLR = ulIntType;
+}
+
+
+/*********************************************************************//**
+ * @brief		Check whether if the specified interrupt in MCPWM is set or not
+ * @param[in]	MCPWMx 		Motor Control PWM peripheral selected, should be MCPWM
+ * @param[in]	ulIntType	Interrupt type, should be:
+ * 							- MCPWM_INTFLAG_LIM0: Limit interrupt for channel (0)
+ * 							- MCPWM_INTFLAG_MAT0: Match interrupt for channel (0)
+ * 							- MCPWM_INTFLAG_CAP0: Capture interrupt for channel (0)
+ * 							- MCPWM_INTFLAG_LIM1: Limit interrupt for channel (1)
+ * 							- MCPWM_INTFLAG_MAT1: Match interrupt for channel (1)
+ * 							- MCPWM_INTFLAG_CAP1: Capture interrupt for channel (1)
+ * 							- MCPWM_INTFLAG_LIM2: Limit interrupt for channel (2)
+ * 							- MCPWM_INTFLAG_MAT2: Match interrupt for channel (2)
+ * 							- MCPWM_INTFLAG_CAP2: Capture interrupt for channel (2)
+ * 							- MCPWM_INTFLAG_ABORT: Fast abort interrupt
+ * @return		None
+ **********************************************************************/
+FlagStatus MCPWM_GetIntStatus(LPC_MCPWM_TypeDef *MCPWMx, uint32_t ulIntType)
+{
+	return ((MCPWMx-&gt;MCINTFLAG &amp; ulIntType) ? SET : RESET);
+}
+
+/**
+ * @}
+ */
+
+#endif /* _MCPWM */
+
+/**
+ * @}
+ */
+
+/* --------------------------------- End Of File ------------------------------ */


Property changes on: trunk/src/platform/lpc17xx/drivers/src/lpc17xx_mcpwm.c
___________________________________________________________________
Deleted: svn:executable
   - *

Modified: trunk/src/platform/lpc17xx/drivers/src/lpc17xx_nvic.c
===================================================================
--- trunk/src/platform/lpc17xx/drivers/src/lpc17xx_nvic.c	2010-06-28 21:53:59 UTC (rev 759)
+++ trunk/src/platform/lpc17xx/drivers/src/lpc17xx_nvic.c	2010-07-12 20:56:54 UTC (rev 760)
@@ -1,135 +1,135 @@
-/**
- * @file	: lpc17xx_nvic.c
- * @brief	: Contains all expansion functions support for
- * 				NVIC firmware library on LPC17xx. The main
- * 				NVIC functions are defined in core_cm3.h
- * @version	: 1.0
- * @date	: 18. Mar. 2009
- * @author	: HieuNguyen
- *----------------------------------------------------------------------------
- * Software that is described herein is for illustrative purposes only
- * which provides customers with programming information regarding the
- * products. This software is supplied &quot;AS IS&quot; without any warranties.
- * NXP Semiconductors assumes no responsibility or liability for the
- * use of the software, conveys no license or title under any patent,
- * copyright, or mask work right to the product. NXP Semiconductors
- * reserves the right to make changes in the software without
- * notification. NXP Semiconductors also make no representation or
- * warranty that such application will be suitable for the specified
- * use without further testing or modification.
- **********************************************************************/
-
-/* Peripheral group ----------------------------------------------------------- */
-/** @addtogroup NVIC
- * @{
- */
-
-/* Includes ------------------------------------------------------------------- */
-#include &quot;lpc17xx_nvic.h&quot;
-
-
-/* Private Macros ------------------------------------------------------------- */
-/** @addtogroup NVIC_Private_Macros
- * @{
- */
-
-/* Vector table offset bit mask */
-#define NVIC_VTOR_MASK              0x3FFFFF80
-
-/**
- * @}
- */
-
-
-/* Public Functions ----------------------------------------------------------- */
-/** @addtogroup NVIC_Public_Functions
- * @{
- */
-
-
-/*****************************************************************************//**
- * @brief		De-initializes the NVIC peripheral registers to their default
- * 				reset values.
- * @param		None
- * @return      None
- *
- * These following NVIC peripheral registers will be de-initialized:
- * - Disable Interrupt (32 IRQ interrupt sources that matched with LPC17xx)
- * - Clear all Pending Interrupts (32 IRQ interrupt source that matched with LPC17xx)
- * - Clear all Interrupt Priorities (32 IRQ interrupt source that matched with LPC17xx)
- *******************************************************************************/
-void NVIC_DeInit(void)
-{
-	uint8_t tmp;
-
-	/* Disable all interrupts */
-	NVIC-&gt;ICER[0] = 0xFFFFFFFF;
-	NVIC-&gt;ICER[1] = 0x00000001;
-	/* Clear all pending interrupts */
-	NVIC-&gt;ICPR[0] = 0xFFFFFFFF;
-	NVIC-&gt;ICPR[1] = 0x00000001;
-
-	/* Clear all interrupt priority */
-	for (tmp = 0; tmp &lt; 32; tmp++) {
-		NVIC-&gt;IP[tmp] = 0x00;
-	}
-}
-
-/*****************************************************************************//**
- * @brief			De-initializes the SCB peripheral registers to their default
- *                  reset values.
- * @param			none
- * @return 			none
- *
- * These following SCB NVIC peripheral registers will be de-initialized:
- * - Interrupt Control State register
- * - Interrupt Vector Table Offset register
- * - Application Interrupt/Reset Control register
- * - System Control register
- * - Configuration Control register
- * - System Handlers Priority Registers
- * - System Handler Control and State Register
- * - Configurable Fault Status Register
- * - Hard Fault Status Register
- * - Debug Fault Status Register
- *******************************************************************************/
-void NVIC_SCBDeInit(void)
-{
-	uint8_t tmp;
-
-	SCB-&gt;ICSR = 0x0A000000;
-	SCB-&gt;VTOR = 0x00000000;
-	SCB-&gt;AIRCR = 0x05FA0000;
-	SCB-&gt;SCR = 0x00000000;
-	SCB-&gt;CCR = 0x00000000;
-
-	for (tmp = 0; tmp &lt; 32; tmp++) {
-		SCB-&gt;SHP[tmp] = 0x00;
-	}
-
-	SCB-&gt;SHCSR = 0x00000000;
-	SCB-&gt;CFSR = 0xFFFFFFFF;
-	SCB-&gt;HFSR = 0xFFFFFFFF;
-	SCB-&gt;DFSR = 0xFFFFFFFF;
-}
-
-
-/*****************************************************************************//**
- * @brief		Set Vector Table Offset value
- * @param		offset Offset value
- * @return      None
- *******************************************************************************/
-void NVIC_SetVTOR(uint32_t offset)
-{
-	SCB-&gt;VTOR  = (offset &amp; NVIC_VTOR_MASK);
-}
-
-/**
- * @}
- */
-
-/**
- * @}
- */
-
-/* --------------------------------- End Of File ------------------------------ */
+/**
+ * @file	: lpc17xx_nvic.c
+ * @brief	: Contains all expansion functions support for
+ * 				NVIC firmware library on LPC17xx. The main
+ * 				NVIC functions are defined in core_cm3.h
+ * @version	: 1.0
+ * @date	: 18. Mar. 2009
+ * @author	: HieuNguyen
+ **************************************************************************
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * products. This software is supplied &quot;AS IS&quot; without any warranties.
+ * NXP Semiconductors assumes no responsibility or liability for the
+ * use of the software, conveys no license or title under any patent,
+ * copyright, or mask work right to the product. NXP Semiconductors
+ * reserves the right to make changes in the software without
+ * notification. NXP Semiconductors also make no representation or
+ * warranty that such application will be suitable for the specified
+ * use without further testing or modification.
+ **********************************************************************/
+
+/* Peripheral group ----------------------------------------------------------- */
+/** @addtogroup NVIC
+ * @{
+ */
+
+/* Includes ------------------------------------------------------------------- */
+#include &quot;lpc17xx_nvic.h&quot;
+
+
+/* Private Macros ------------------------------------------------------------- */
+/** @addtogroup NVIC_Private_Macros
+ * @{
+ */
+
+/* Vector table offset bit mask */
+#define NVIC_VTOR_MASK              0x3FFFFF80
+
+/**
+ * @}
+ */
+
+
+/* Public Functions ----------------------------------------------------------- */
+/** @addtogroup NVIC_Public_Functions
+ * @{
+ */
+
+
+/*****************************************************************************//**
+ * @brief		De-initializes the NVIC peripheral registers to their default
+ * 				reset values.
+ * @param		None
+ * @return      None
+ *
+ * These following NVIC peripheral registers will be de-initialized:
+ * - Disable Interrupt (32 IRQ interrupt sources that matched with LPC17xx)
+ * - Clear all Pending Interrupts (32 IRQ interrupt source that matched with LPC17xx)
+ * - Clear all Interrupt Priorities (32 IRQ interrupt source that matched with LPC17xx)
+ *******************************************************************************/
+void NVIC_DeInit(void)
+{
+	uint8_t tmp;
+
+	/* Disable all interrupts */
+	NVIC-&gt;ICER[0] = 0xFFFFFFFF;
+	NVIC-&gt;ICER[1] = 0x00000001;
+	/* Clear all pending interrupts */
+	NVIC-&gt;ICPR[0] = 0xFFFFFFFF;
+	NVIC-&gt;ICPR[1] = 0x00000001;
+
+	/* Clear all interrupt priority */
+	for (tmp = 0; tmp &lt; 32; tmp++) {
+		NVIC-&gt;IP[tmp] = 0x00;
+	}
+}
+
+/*****************************************************************************//**
+ * @brief			De-initializes the SCB peripheral registers to their default
+ *                  reset values.
+ * @param			none
+ * @return 			none
+ *
+ * These following SCB NVIC peripheral registers will be de-initialized:
+ * - Interrupt Control State register
+ * - Interrupt Vector Table Offset register
+ * - Application Interrupt/Reset Control register
+ * - System Control register
+ * - Configuration Control register
+ * - System Handlers Priority Registers
+ * - System Handler Control and State Register
+ * - Configurable Fault Status Register
+ * - Hard Fault Status Register
+ * - Debug Fault Status Register
+ *******************************************************************************/
+void NVIC_SCBDeInit(void)
+{
+	uint8_t tmp;
+
+	SCB-&gt;ICSR = 0x0A000000;
+	SCB-&gt;VTOR = 0x00000000;
+	SCB-&gt;AIRCR = 0x05FA0000;
+	SCB-&gt;SCR = 0x00000000;
+	SCB-&gt;CCR = 0x00000000;
+
+	for (tmp = 0; tmp &lt; 32; tmp++) {
+		SCB-&gt;SHP[tmp] = 0x00;
+	}
+
+	SCB-&gt;SHCSR = 0x00000000;
+	SCB-&gt;CFSR = 0xFFFFFFFF;
+	SCB-&gt;HFSR = 0xFFFFFFFF;
+	SCB-&gt;DFSR = 0xFFFFFFFF;
+}
+
+
+/*****************************************************************************//**
+ * @brief		Set Vector Table Offset value
+ * @param		offset Offset value
+ * @return      None
+ *******************************************************************************/
+void NVIC_SetVTOR(uint32_t offset)
+{
+	SCB-&gt;VTOR  = (offset &amp; NVIC_VTOR_MASK);
+}
+
+/**
+ * @}
+ */
+
+/**
+ * @}
+ */
+
+/* --------------------------------- End Of File ------------------------------ */


Property changes on: trunk/src/platform/lpc17xx/drivers/src/lpc17xx_nvic.c
___________________________________________________________________
Deleted: svn:executable
   - *

Modified: trunk/src/platform/lpc17xx/drivers/src/lpc17xx_pinsel.c
===================================================================
--- trunk/src/platform/lpc17xx/drivers/src/lpc17xx_pinsel.c	2010-06-28 21:53:59 UTC (rev 759)
+++ trunk/src/platform/lpc17xx/drivers/src/lpc17xx_pinsel.c	2010-07-12 20:56:54 UTC (rev 760)
@@ -1,308 +1,308 @@
-/**
- * @file	: lpc17xx_pinsel.c
- * @brief	: Contains all functions support for Pin connect block firmware
- * 				library on LPC17xx
- * @version	: 1.0
- * @date	: 25. Feb. 2009
- * @author	: HoanTran
- *----------------------------------------------------------------------------
- * Software that is described herein is for illustrative purposes only
- * which provides customers with programming information regarding the
- * products. This software is supplied &quot;AS IS&quot; without any warranties.
- * NXP Semiconductors assumes no responsibility or liability for the
- * use of the software, conveys no license or title under any patent,
- * copyright, or mask work right to the product. NXP Semiconductors
- * reserves the right to make changes in the software without
- * notification. NXP Semiconductors also make no representation or
- * warranty that such application will be suitable for the specified
- * use without further testing or modification.
- **********************************************************************/
-
-/* Peripheral group ----------------------------------------------------------- */
-/** @addtogroup PINSEL
- * @{
- */
-
-/* Includes ------------------------------------------------------------------- */
-#include &quot;lpc17xx_pinsel.h&quot;
-
-
-/* Public Functions ----------------------------------------------------------- */
-/** @addtogroup PINSEL_Public_Functions
- * @{
- */
-
-/*********************************************************************//**
- * @brief 		Setup the pin selection function
- * @param[in]	portnum PORT number,
- * 				should be one of the following:
- * 				- PINSEL_PORT_0	: Port 0
- * 				- PINSEL_PORT_1	: Port 1
- * 				- PINSEL_PORT_2	: Port 2
- * 				- PINSEL_PORT_3	: Port 3
- *
- * @param[in]	pinnum	Pin number,
- * 				should be one of the following:
-				- PINSEL_PIN_0 : Pin 0
-				- PINSEL_PIN_1 : Pin 1
-				- PINSEL_PIN_2 : Pin 2
-				- PINSEL_PIN_3 : Pin 3
-				- PINSEL_PIN_4 : Pin 4
-				- PINSEL_PIN_5 : Pin 5
-				- PINSEL_PIN_6 : Pin 6
-				- PINSEL_PIN_7 : Pin 7
-				- PINSEL_PIN_8 : Pin 8
-				- PINSEL_PIN_9 : Pin 9
-				- PINSEL_PIN_10 : Pin 10
-				- PINSEL_PIN_11 : Pin 11
-				- PINSEL_PIN_12 : Pin 12
-				- PINSEL_PIN_13 : Pin 13
-				- PINSEL_PIN_14 : Pin 14
-				- PINSEL_PIN_15 : Pin 15
-				- PINSEL_PIN_16 : Pin 16
-				- PINSEL_PIN_17 : Pin 17
-				- PINSEL_PIN_18 : Pin 18
-				- PINSEL_PIN_19 : Pin 19
-				- PINSEL_PIN_20 : Pin 20
-				- PINSEL_PIN_21 : Pin 21
-				- PINSEL_PIN_22 : Pin 22
-				- PINSEL_PIN_23 : Pin 23
-				- PINSEL_PIN_24 : Pin 24
-				- PINSEL_PIN_25 : Pin 25
-				- PINSEL_PIN_26 : Pin 26
-				- PINSEL_PIN_27 : Pin 27
-				- PINSEL_PIN_28 : Pin 28
-				- PINSEL_PIN_29 : Pin 29
-				- PINSEL_PIN_30 : Pin 30
-				- PINSEL_PIN_31 : Pin 31
-
- * @param[in] 	funcnum Function number,
- * 				should be one of the following:
- *				- PINSEL_FUNC_0 : default function
- *				- PINSEL_FUNC_1 : first alternate function
- *				- PINSEL_FUNC_2 : second alternate function
- *				- PINSEL_FUNC_3 : third alternate function
- *
- * @return 		None
- **********************************************************************/
-void PINSEL_SetPinFunc ( uint8_t portnum, uint8_t pinnum, uint8_t funcnum)
-{
-	uint32_t pinnum_t = pinnum;
-	uint32_t pinselreg_idx = 2 * portnum;
-	uint32_t *pPinCon = (uint32_t *)&amp;PINCON-&gt;PINSEL0;
-
-	if (pinnum_t &gt;= 16) {
-		pinnum_t -= 16;
-		pinselreg_idx++;
-	}
-	*(uint32_t *)(pPinCon + pinselreg_idx) &amp;= ~(0x03UL &lt;&lt; (pinnum_t * 2));
-	*(uint32_t *)(pPinCon + pinselreg_idx) |= ((uint32_t)funcnum) &lt;&lt; (pinnum_t * 2);
-}
-
-
-
-/*********************************************************************//**
- * @brief 		Configure trace function
- * @param[in] 	NewState State of the Trace function configuration,
- * 				should be one of the following:
- * 				- ENABLE : Enable Trace Function
- * 				- DISABLE : Disable Trace Function
- *
- * @return 		None
- **********************************************************************/
-void PINSEL_ConfigTraceFunc(FunctionalState NewState)
-{
-	if (NewState == ENABLE) {
-		PINCON-&gt;PINSEL10 |= (0x01UL &lt;&lt; 3);
-	} else if (NewState == DISABLE) {
-		PINCON-&gt;PINSEL10 &amp;= ~(0x01UL &lt;&lt; 3);
-	}
-}
-
-
-
-/*********************************************************************//**
- * @brief 		Setup resistor mode for each pin
- * @param[in]	portnum PORT number,
- * 				should be one of the following:
- * 				- PINSEL_PORT_0	: Port 0
- * 				- PINSEL_PORT_1	: Port 1
- * 				- PINSEL_PORT_2	: Port 2
- * 				- PINSEL_PORT_3	: Port 3
- * @param[in]	pinnum	Pin number,
- * 				should be one of the following:
-				- PINSEL_PIN_0 : Pin 0
-				- PINSEL_PIN_1 : Pin 1
-				- PINSEL_PIN_2 : Pin 2
-				- PINSEL_PIN_3 : Pin 3
-				- PINSEL_PIN_4 : Pin 4
-				- PINSEL_PIN_5 : Pin 5
-				- PINSEL_PIN_6 : Pin 6
-				- PINSEL_PIN_7 : Pin 7
-				- PINSEL_PIN_8 : Pin 8
-				- PINSEL_PIN_9 : Pin 9
-				- PINSEL_PIN_10 : Pin 10
-				- PINSEL_PIN_11 : Pin 11
-				- PINSEL_PIN_12 : Pin 12
-				- PINSEL_PIN_13 : Pin 13
-				- PINSEL_PIN_14 : Pin 14
-				- PINSEL_PIN_15 : Pin 15
-				- PINSEL_PIN_16 : Pin 16
-				- PINSEL_PIN_17 : Pin 17
-				- PINSEL_PIN_18 : Pin 18
-				- PINSEL_PIN_19 : Pin 19
-				- PINSEL_PIN_20 : Pin 20
-				- PINSEL_PIN_21 : Pin 21
-				- PINSEL_PIN_22 : Pin 22
-				- PINSEL_PIN_23 : Pin 23
-				- PINSEL_PIN_24 : Pin 24
-				- PINSEL_PIN_25 : Pin 25
-				- PINSEL_PIN_26 : Pin 26
-				- PINSEL_PIN_27 : Pin 27
-				- PINSEL_PIN_28 : Pin 28
-				- PINSEL_PIN_29 : Pin 29
-				- PINSEL_PIN_30 : Pin 30
-				- PINSEL_PIN_31 : Pin 31
-
- * @param[in] 	modenum: Mode number,
- * 				should be one of the following:
-				- PINSEL_PINMODE_PULLUP	: Internal pull-up resistor
-				- PINSEL_PINMODE_TRISTATE : Tri-state
-				- PINSEL_PINMODE_PULLDOWN : Internal pull-down resistor
-
- * @return 		None
- **********************************************************************/
-void PINSEL_SetResistorMode ( uint8_t portnum, uint8_t pinnum, uint8_t modenum)
-{
-	uint32_t pinnum_t = pinnum;
-	uint32_t pinmodereg_idx = 2 * portnum;
-	uint32_t *pPinCon = (uint32_t *)&amp;PINCON-&gt;PINMODE0;
-
-	if (pinnum_t &gt;= 16) {
-		pinnum_t -= 16;
-		pinmodereg_idx++ ;
-	}
-
-	*(uint32_t *)(pPinCon + pinmodereg_idx) &amp;= ~(0x03UL &lt;&lt; (pinnum_t * 2));
-	*(uint32_t *)(pPinCon + pinmodereg_idx) |= ((uint32_t)modenum) &lt;&lt; (pinnum_t * 2);
-}
-
-
-
-/*********************************************************************//**
- * @brief 		Setup Open drain mode for each pin
- * @param[in]	portnum PORT number,
- * 				should be one of the following:
- * 				- PINSEL_PORT_0	: Port 0
- * 				- PINSEL_PORT_1	: Port 1
- * 				- PINSEL_PORT_2	: Port 2
- * 				- PINSEL_PORT_3	: Port 3
- *
- * @param[in]	pinnum	Pin number,
- * 				should be one of the following:
-				- PINSEL_PIN_0 : Pin 0
-				- PINSEL_PIN_1 : Pin 1
-				- PINSEL_PIN_2 : Pin 2
-				- PINSEL_PIN_3 : Pin 3
-				- PINSEL_PIN_4 : Pin 4
-				- PINSEL_PIN_5 : Pin 5
-				- PINSEL_PIN_6 : Pin 6
-				- PINSEL_PIN_7 : Pin 7
-				- PINSEL_PIN_8 : Pin 8
-				- PINSEL_PIN_9 : Pin 9
-				- PINSEL_PIN_10 : Pin 10
-				- PINSEL_PIN_11 : Pin 11
-				- PINSEL_PIN_12 : Pin 12
-				- PINSEL_PIN_13 : Pin 13
-				- PINSEL_PIN_14 : Pin 14
-				- PINSEL_PIN_15 : Pin 15
-				- PINSEL_PIN_16 : Pin 16
-				- PINSEL_PIN_17 : Pin 17
-				- PINSEL_PIN_18 : Pin 18
-				- PINSEL_PIN_19 : Pin 19
-				- PINSEL_PIN_20 : Pin 20
-				- PINSEL_PIN_21 : Pin 21
-				- PINSEL_PIN_22 : Pin 22
-				- PINSEL_PIN_23 : Pin 23
-				- PINSEL_PIN_24 : Pin 24
-				- PINSEL_PIN_25 : Pin 25
-				- PINSEL_PIN_26 : Pin 26
-				- PINSEL_PIN_27 : Pin 27
-				- PINSEL_PIN_28 : Pin 28
-				- PINSEL_PIN_29 : Pin 29
-				- PINSEL_PIN_30 : Pin 30
-				- PINSEL_PIN_31 : Pin 31
-
- * @param[in]	modenum  Open drain mode number,
- * 				should be one of the following:
- * 				- PINSEL_PINMODE_NORMAL : Pin is in the normal (not open drain) mode
- * 				- PINSEL_PINMODE_OPENDRAIN : Pin is in the open drain mode
- *
- * @return 		None
- **********************************************************************/
-void PINSEL_SetOpenDrainMode( uint8_t portnum, uint8_t pinnum, uint8_t modenum)
-{
-	uint32_t *pPinCon = (uint32_t *)&amp;PINCON-&gt;PINMODE_OD0;
-
-	if (modenum == PINSEL_PINMODE_OPENDRAIN){
-		*(uint32_t *)(pPinCon + portnum) |= (0x01UL &lt;&lt; pinnum);
-	} else {
-		*(uint32_t *)(pPinCon + portnum) &amp;= ~(0x01UL &lt;&lt; pinnum);
-	}
-}
-
-
-
-/*********************************************************************//**
- * @brief 		Setup I2C0 pins
- * @param[in]	i2cPinMode I2C pin mode,
- * 				should be one of the following:
- * 				- PINSEL_I2C_Normal_Mode : The standard drive mode
- * 				- PINSEL_I2C_Fast_Mode : Fast Mode Plus drive mode
- *
- * @param[in]	filterSlewRateEnable  should be:
- * 				- ENABLE: Enable filter and slew rate.
- * 				- DISABLE: Disable filter and slew rate.
- *
- * @return 		None
- **********************************************************************/
-void PINSEL_SetI2C0Pins(uint8_t i2cPinMode, FunctionalState filterSlewRateEnable)
-{
-	uint32_t regVal;
-
-	if (i2cPinMode == PINSEL_I2C_Fast_Mode){
-		regVal = PINSEL_I2CPADCFG_SCLDRV0 | PINSEL_I2CPADCFG_SDADRV0;
-	}
-
-	if (filterSlewRateEnable == DISABLE){
-		regVal = PINSEL_I2CPADCFG_SCLI2C0 | PINSEL_I2CPADCFG_SDAI2C0;
-	}
-	PINCON-&gt;I2CPADCFG = regVal;
-}
-
-
-/*********************************************************************//**
- * @brief 		Configure Pin corresponding to specified parameters passed
- * 				in the PinCfg
- * @param[in]	PinCfg	Pointer to a PINSEL_CFG_Type structure
- *                    that contains the configuration information for the
- *                    specified pin.
- * @return 		None
- **********************************************************************/
-void PINSEL_ConfigPin(PINSEL_CFG_Type *PinCfg)
-{
-	PINSEL_SetPinFunc(PinCfg-&gt;Portnum, PinCfg-&gt;Pinnum, PinCfg-&gt;Funcnum);
-	PINSEL_SetResistorMode(PinCfg-&gt;Portnum, PinCfg-&gt;Pinnum, PinCfg-&gt;Pinmode);
-	PINSEL_SetOpenDrainMode(PinCfg-&gt;Portnum, PinCfg-&gt;Pinnum, PinCfg-&gt;OpenDrain);
-}
-
-
-/**
- * @}
- */
-
-/**
- * @}
- */
-
-/* --------------------------------- End Of File ------------------------------ */
+/**
+ * @file	: lpc17xx_pinsel.c
+ * @brief	: Contains all functions support for Pin connect block firmware
+ * 				library on LPC17xx
+ * @version	: 1.0
+ * @date	: 25. Feb. 2009
+ * @author	: HoanTran
+ **************************************************************************
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * products. This software is supplied &quot;AS IS&quot; without any warranties.
+ * NXP Semiconductors assumes no responsibility or liability for the
+ * use of the software, conveys no license or title under any patent,
+ * copyright, or mask work right to the product. NXP Semiconductors
+ * reserves the right to make changes in the software without
+ * notification. NXP Semiconductors also make no representation or
+ * warranty that such application will be suitable for the specified
+ * use without further testing or modification.
+ **********************************************************************/
+
+/* Peripheral group ----------------------------------------------------------- */
+/** @addtogroup PINSEL
+ * @{
+ */
+
+/* Includes ------------------------------------------------------------------- */
+#include &quot;lpc17xx_pinsel.h&quot;
+
+
+/* Public Functions ----------------------------------------------------------- */
+/** @addtogroup PINSEL_Public_Functions
+ * @{
+ */
+
+/*********************************************************************//**
+ * @brief 		Setup the pin selection function
+ * @param[in]	portnum PORT number,
+ * 				should be one of the following:
+ * 				- PINSEL_PORT_0	: Port 0
+ * 				- PINSEL_PORT_1	: Port 1
+ * 				- PINSEL_PORT_2	: Port 2
+ * 				- PINSEL_PORT_3	: Port 3
+ *
+ * @param[in]	pinnum	Pin number,
+ * 				should be one of the following:
+				- PINSEL_PIN_0 : Pin 0
+				- PINSEL_PIN_1 : Pin 1
+				- PINSEL_PIN_2 : Pin 2
+				- PINSEL_PIN_3 : Pin 3
+				- PINSEL_PIN_4 : Pin 4
+				- PINSEL_PIN_5 : Pin 5
+				- PINSEL_PIN_6 : Pin 6
+				- PINSEL_PIN_7 : Pin 7
+				- PINSEL_PIN_8 : Pin 8
+				- PINSEL_PIN_9 : Pin 9
+				- PINSEL_PIN_10 : Pin 10
+				- PINSEL_PIN_11 : Pin 11
+				- PINSEL_PIN_12 : Pin 12
+				- PINSEL_PIN_13 : Pin 13
+				- PINSEL_PIN_14 : Pin 14
+				- PINSEL_PIN_15 : Pin 15
+				- PINSEL_PIN_16 : Pin 16
+				- PINSEL_PIN_17 : Pin 17
+				- PINSEL_PIN_18 : Pin 18
+				- PINSEL_PIN_19 : Pin 19
+				- PINSEL_PIN_20 : Pin 20
+				- PINSEL_PIN_21 : Pin 21
+				- PINSEL_PIN_22 : Pin 22
+				- PINSEL_PIN_23 : Pin 23
+				- PINSEL_PIN_24 : Pin 24
+				- PINSEL_PIN_25 : Pin 25
+				- PINSEL_PIN_26 : Pin 26
+				- PINSEL_PIN_27 : Pin 27
+				- PINSEL_PIN_28 : Pin 28
+				- PINSEL_PIN_29 : Pin 29
+				- PINSEL_PIN_30 : Pin 30
+				- PINSEL_PIN_31 : Pin 31
+
+ * @param[in] 	funcnum Function number,
+ * 				should be one of the following:
+ *				- PINSEL_FUNC_0 : default function
+ *				- PINSEL_FUNC_1 : first alternate function
+ *				- PINSEL_FUNC_2 : second alternate function
+ *				- PINSEL_FUNC_3 : third alternate function
+ *
+ * @return 		None
+ **********************************************************************/
+void PINSEL_SetPinFunc ( uint8_t portnum, uint8_t pinnum, uint8_t funcnum)
+{
+	uint32_t pinnum_t = pinnum;
+	uint32_t pinselreg_idx = 2 * portnum;
+	uint32_t *pPinCon = (uint32_t *)&amp;LPC_PINCON-&gt;PINSEL0;
+
+	if (pinnum_t &gt;= 16) {
+		pinnum_t -= 16;
+		pinselreg_idx++;
+	}
+	*(uint32_t *)(pPinCon + pinselreg_idx) &amp;= ~(0x03UL &lt;&lt; (pinnum_t * 2));
+	*(uint32_t *)(pPinCon + pinselreg_idx) |= ((uint32_t)funcnum) &lt;&lt; (pinnum_t * 2);
+}
+
+
+
+/*********************************************************************//**
+ * @brief 		Configure trace function
+ * @param[in] 	NewState State of the Trace function configuration,
+ * 				should be one of the following:
+ * 				- ENABLE : Enable Trace Function
+ * 				- DISABLE : Disable Trace Function
+ *
+ * @return 		None
+ **********************************************************************/
+void PINSEL_ConfigTraceFunc(FunctionalState NewState)
+{
+	if (NewState == ENABLE) {
+		LPC_PINCON-&gt;PINSEL10 |= (0x01UL &lt;&lt; 3);
+	} else if (NewState == DISABLE) {
+		LPC_PINCON-&gt;PINSEL10 &amp;= ~(0x01UL &lt;&lt; 3);
+	}
+}
+
+
+
+/*********************************************************************//**
+ * @brief 		Setup resistor mode for each pin
+ * @param[in]	portnum PORT number,
+ * 				should be one of the following:
+ * 				- PINSEL_PORT_0	: Port 0
+ * 				- PINSEL_PORT_1	: Port 1
+ * 				- PINSEL_PORT_2	: Port 2
+ * 				- PINSEL_PORT_3	: Port 3
+ * @param[in]	pinnum	Pin number,
+ * 				should be one of the following:
+				- PINSEL_PIN_0 : Pin 0
+				- PINSEL_PIN_1 : Pin 1
+				- PINSEL_PIN_2 : Pin 2
+				- PINSEL_PIN_3 : Pin 3
+				- PINSEL_PIN_4 : Pin 4
+				- PINSEL_PIN_5 : Pin 5
+				- PINSEL_PIN_6 : Pin 6
+				- PINSEL_PIN_7 : Pin 7
+				- PINSEL_PIN_8 : Pin 8
+				- PINSEL_PIN_9 : Pin 9
+				- PINSEL_PIN_10 : Pin 10
+				- PINSEL_PIN_11 : Pin 11
+				- PINSEL_PIN_12 : Pin 12
+				- PINSEL_PIN_13 : Pin 13
+				- PINSEL_PIN_14 : Pin 14
+				- PINSEL_PIN_15 : Pin 15
+				- PINSEL_PIN_16 : Pin 16
+				- PINSEL_PIN_17 : Pin 17
+				- PINSEL_PIN_18 : Pin 18
+				- PINSEL_PIN_19 : Pin 19
+				- PINSEL_PIN_20 : Pin 20
+				- PINSEL_PIN_21 : Pin 21
+				- PINSEL_PIN_22 : Pin 22
+				- PINSEL_PIN_23 : Pin 23
+				- PINSEL_PIN_24 : Pin 24
+				- PINSEL_PIN_25 : Pin 25
+				- PINSEL_PIN_26 : Pin 26
+				- PINSEL_PIN_27 : Pin 27
+				- PINSEL_PIN_28 : Pin 28
+				- PINSEL_PIN_29 : Pin 29
+				- PINSEL_PIN_30 : Pin 30
+				- PINSEL_PIN_31 : Pin 31
+
+ * @param[in] 	modenum: Mode number,
+ * 				should be one of the following:
+				- PINSEL_PINMODE_PULLUP	: Internal pull-up resistor
+				- PINSEL_PINMODE_TRISTATE : Tri-state
+				- PINSEL_PINMODE_PULLDOWN : Internal pull-down resistor
+
+ * @return 		None
+ **********************************************************************/
+void PINSEL_SetResistorMode ( uint8_t portnum, uint8_t pinnum, uint8_t modenum)
+{
+	uint32_t pinnum_t = pinnum;
+	uint32_t pinmodereg_idx = 2 * portnum;
+	uint32_t *pPinCon = (uint32_t *)&amp;LPC_PINCON-&gt;PINMODE0;
+
+	if (pinnum_t &gt;= 16) {
+		pinnum_t -= 16;
+		pinmodereg_idx++ ;
+	}
+
+	*(uint32_t *)(pPinCon + pinmodereg_idx) &amp;= ~(0x03UL &lt;&lt; (pinnum_t * 2));
+	*(uint32_t *)(pPinCon + pinmodereg_idx) |= ((uint32_t)modenum) &lt;&lt; (pinnum_t * 2);
+}
+
+
+
+/*********************************************************************//**
+ * @brief 		Setup Open drain mode for each pin
+ * @param[in]	portnum PORT number,
+ * 				should be one of the following:
+ * 				- PINSEL_PORT_0	: Port 0
+ * 				- PINSEL_PORT_1	: Port 1
+ * 				- PINSEL_PORT_2	: Port 2
+ * 				- PINSEL_PORT_3	: Port 3
+ *
+ * @param[in]	pinnum	Pin number,
+ * 				should be one of the following:
+				- PINSEL_PIN_0 : Pin 0
+				- PINSEL_PIN_1 : Pin 1
+				- PINSEL_PIN_2 : Pin 2
+				- PINSEL_PIN_3 : Pin 3
+				- PINSEL_PIN_4 : Pin 4
+				- PINSEL_PIN_5 : Pin 5
+				- PINSEL_PIN_6 : Pin 6
+				- PINSEL_PIN_7 : Pin 7
+				- PINSEL_PIN_8 : Pin 8
+				- PINSEL_PIN_9 : Pin 9
+				- PINSEL_PIN_10 : Pin 10
+				- PINSEL_PIN_11 : Pin 11
+				- PINSEL_PIN_12 : Pin 12
+				- PINSEL_PIN_13 : Pin 13
+				- PINSEL_PIN_14 : Pin 14
+				- PINSEL_PIN_15 : Pin 15
+				- PINSEL_PIN_16 : Pin 16
+				- PINSEL_PIN_17 : Pin 17
+				- PINSEL_PIN_18 : Pin 18
+				- PINSEL_PIN_19 : Pin 19
+				- PINSEL_PIN_20 : Pin 20
+				- PINSEL_PIN_21 : Pin 21
+				- PINSEL_PIN_22 : Pin 22
+				- PINSEL_PIN_23 : Pin 23
+				- PINSEL_PIN_24 : Pin 24
+				- PINSEL_PIN_25 : Pin 25
+				- PINSEL_PIN_26 : Pin 26
+				- PINSEL_PIN_27 : Pin 27
+				- PINSEL_PIN_28 : Pin 28
+				- PINSEL_PIN_29 : Pin 29
+				- PINSEL_PIN_30 : Pin 30
+				- PINSEL_PIN_31 : Pin 31
+
+ * @param[in]	modenum  Open drain mode number,
+ * 				should be one of the following:
+ * 				- PINSEL_PINMODE_NORMAL : Pin is in the normal (not open drain) mode
+ * 				- PINSEL_PINMODE_OPENDRAIN : Pin is in the open drain mode
+ *
+ * @return 		None
+ **********************************************************************/
+void PINSEL_SetOpenDrainMode( uint8_t portnum, uint8_t pinnum, uint8_t modenum)
+{
+	uint32_t *pPinCon = (uint32_t *)&amp;LPC_PINCON-&gt;PINMODE_OD0;
+
+	if (modenum == PINSEL_PINMODE_OPENDRAIN){
+		*(uint32_t *)(pPinCon + portnum) |= (0x01UL &lt;&lt; pinnum);
+	} else {
+		*(uint32_t *)(pPinCon + portnum) &amp;= ~(0x01UL &lt;&lt; pinnum);
+	}
+}
+
+
+
+/*********************************************************************//**
+ * @brief 		Setup I2C0 pins
+ * @param[in]	i2cPinMode I2C pin mode,
+ * 				should be one of the following:
+ * 				- PINSEL_I2C_Normal_Mode : The standard drive mode
+ * 				- PINSEL_I2C_Fast_Mode : Fast Mode Plus drive mode
+ *
+ * @param[in]	filterSlewRateEnable  should be:
+ * 				- ENABLE: Enable filter and slew rate.
+ * 				- DISABLE: Disable filter and slew rate.
+ *
+ * @return 		None
+ **********************************************************************/
+void PINSEL_SetI2C0Pins(uint8_t i2cPinMode, FunctionalState filterSlewRateEnable)
+{
+	uint32_t regVal;
+
+	if (i2cPinMode == PINSEL_I2C_Fast_Mode){
+		regVal = PINSEL_I2CPADCFG_SCLDRV0 | PINSEL_I2CPADCFG_SDADRV0;
+	}
+
+	if (filterSlewRateEnable == DISABLE){
+		regVal = PINSEL_I2CPADCFG_SCLI2C0 | PINSEL_I2CPADCFG_SDAI2C0;
+	}
+	LPC_PINCON-&gt;I2CPADCFG = regVal;
+}
+
+
+/*********************************************************************//**
+ * @brief 		Configure Pin corresponding to specified parameters passed
+ * 				in the PinCfg
+ * @param[in]	PinCfg	Pointer to a PINSEL_CFG_Type structure
+ *                    that contains the configuration information for the
+ *                    specified pin.
+ * @return 		None
+ **********************************************************************/
+void PINSEL_ConfigPin(PINSEL_CFG_Type *PinCfg)
+{
+	PINSEL_SetPinFunc(PinCfg-&gt;Portnum, PinCfg-&gt;Pinnum, PinCfg-&gt;Funcnum);
+	PINSEL_SetResistorMode(PinCfg-&gt;Portnum, PinCfg-&gt;Pinnum, PinCfg-&gt;Pinmode);
+	PINSEL_SetOpenDrainMode(PinCfg-&gt;Portnum, PinCfg-&gt;Pinnum, PinCfg-&gt;OpenDrain);
+}
+
+
+/**
+ * @}
+ */
+
+/**
+ * @}
+ */
+
+/* --------------------------------- End Of File ------------------------------ */


Property changes on: trunk/src/platform/lpc17xx/drivers/src/lpc17xx_pinsel.c
___________________________________________________________________
Deleted: svn:executable
   - *

Modified: trunk/src/platform/lpc17xx/drivers/src/lpc17xx_pwm.c
===================================================================
--- trunk/src/platform/lpc17xx/drivers/src/lpc17xx_pwm.c	2010-06-28 21:53:59 UTC (rev 759)
+++ trunk/src/platform/lpc17xx/drivers/src/lpc17xx_pwm.c	2010-07-12 20:56:54 UTC (rev 760)
@@ -1,534 +1,535 @@
-/**
- * @file	: lpc17xx_pwm.c
- * @brief	: Contains all functions support for PWM firmware library on LPC17xx
- * @version	: 1.0
- * @date	: 22. Apr. 2009
- * @author	: HieuNguyen
- *----------------------------------------------------------------------------
- * Software that is described herein is for illustrative purposes only
- * which provides customers with programming information regarding the
- * products. This software is supplied &quot;AS IS&quot; without any warranties.
- * NXP Semiconductors assumes no responsibility or liability for the
- * use of the software, conveys no license or title under any patent,
- * copyright, or mask work right to the product. NXP Semiconductors
- * reserves the right to make changes in the software without
- * notification. NXP Semiconductors also make no representation or
- * warranty that such application will be suitable for the specified
- * use without further testing or modification.
- **********************************************************************/
-
-/* Peripheral group ----------------------------------------------------------- */
-/** @addtogroup PWM
- * @{
- */
-
-/* Includes ------------------------------------------------------------------- */
-#include &quot;lpc17xx_pwm.h&quot;
-#include &quot;lpc17xx_clkpwr.h&quot;
-
-/* If this source file built with example, the LPC17xx FW library configuration
- * file in each example directory (&quot;lpc17xx_libcfg.h&quot;) must be included,
- * otherwise the default FW library configuration file must be included instead
- */
-#ifdef __BUILD_WITH_EXAMPLE__
-#include &quot;lpc17xx_libcfg.h&quot;
-#else
-#include &quot;lpc17xx_libcfg_default.h&quot;
-#endif /* __BUILD_WITH_EXAMPLE__ */
-
-
-#ifdef _PWM
-
-
-/* Public Functions ----------------------------------------------------------- */
-/** @addtogroup PWM_Public_Functions
- * @{
- */
-
-
-/*********************************************************************//**
- * @brief 		Check whether specified interrupt flag in PWM is set or not
- * @param[in]	PWMx: PWM peripheral, should be PWM1
- * @param[in]	IntFlag: PWM interrupt flag, should be:
- * 				- PWM_INTSTAT_MR0: Interrupt flag for PWM match channel 0
- * 				- PWM_INTSTAT_MR1: Interrupt flag for PWM match channel 1
- * 				- PWM_INTSTAT_MR2: Interrupt flag for PWM match channel 2
- * 				- PWM_INTSTAT_MR3: Interrupt flag for PWM match channel 3
- * 				- PWM_INTSTAT_MR4: Interrupt flag for PWM match channel 4
- * 				- PWM_INTSTAT_MR5: Interrupt flag for PWM match channel 5
- * 				- PWM_INTSTAT_MR6: Interrupt flag for PWM match channel 6
- * 				- PWM_INTSTAT_CAP0: Interrupt flag for capture input 0
- * 				- PWM_INTSTAT_CAP1: Interrupt flag for capture input 1
- * @return 		New State of PWM interrupt flag (SET or RESET)
- **********************************************************************/
-IntStatus PWM_GetIntStatus(PWM_TypeDef *PWMx, uint32_t IntFlag)
-{
-	CHECK_PARAM(PARAM_PWMx(PWMx));
-	CHECK_PARAM(PARAM_PWM_INTSTAT(IntFlag));
-
-	return ((PWMx-&gt;IR &amp; IntFlag) ? SET : RESET);
-}
-
-
-
-/*********************************************************************//**
- * @brief 		Clear specified PWM Interrupt pending
- * @param[in]	PWMx: PWM peripheral, should be PWM1
- * @param[in]	IntFlag: PWM interrupt flag, should be:
- * 				- PWM_INTSTAT_MR0: Interrupt flag for PWM match channel 0
- * 				- PWM_INTSTAT_MR1: Interrupt flag for PWM match channel 1
- * 				- PWM_INTSTAT_MR2: Interrupt flag for PWM match channel 2
- * 				- PWM_INTSTAT_MR3: Interrupt flag for PWM match channel 3
- * 				- PWM_INTSTAT_MR4: Interrupt flag for PWM match channel 4
- * 				- PWM_INTSTAT_MR5: Interrupt flag for PWM match channel 5
- * 				- PWM_INTSTAT_MR6: Interrupt flag for PWM match channel 6
- * 				- PWM_INTSTAT_CAP0: Interrupt flag for capture input 0
- * 				- PWM_INTSTAT_CAP1: Interrupt flag for capture input 1
- * @return 		None
- **********************************************************************/
-void PWM_ClearIntPending(PWM_TypeDef *PWMx, uint32_t IntFlag)
-{
-	CHECK_PARAM(PARAM_PWMx(PWMx));
-	CHECK_PARAM(PARAM_PWM_INTSTAT(IntFlag));
-	PWMx-&gt;IR = IntFlag;
-}
-
-
-
-/*****************************************************************************//**
-* @brief		Fills each PWM_InitStruct member with its default value:
-* 				- If PWMCounterMode = PWM_MODE_TIMER:
-* 					+ PrescaleOption = PWM_TIMER_PRESCALE_USVAL
-* 					+ PrescaleValue = 1
-* 				- If PWMCounterMode = PWM_MODE_COUNTER:
-* 					+ CountInputSelect = PWM_COUNTER_PCAP1_0
-* 					+ CounterOption = PWM_COUNTER_RISING
-* @param[in]	PWMTimerCounterMode Timer or Counter mode, should be:
-* 				- PWM_MODE_TIMER: Counter of PWM peripheral is in Timer mode
-* 				- PWM_MODE_COUNTER: Counter of PWM peripheral is in Counter mode
-* @param[in]	PWM_InitStruct Pointer to structure (PWM_TIMERCFG_Type or
-* 				 PWM_COUNTERCFG_Type) which will be initialized.
-* @return		None
-* Note: PWM_InitStruct pointer will be assigned to corresponding structure
-* 		(PWM_TIMERCFG_Type or PWM_COUNTERCFG_Type) due to PWMTimerCounterMode.
-*******************************************************************************/
-void PWM_ConfigStructInit(uint8_t PWMTimerCounterMode, void *PWM_InitStruct)
-{
-	CHECK_PARAM(PARAM_PWM_TC_MODE(PWMTimerCounterMode));
-
-	PWM_TIMERCFG_Type *pTimeCfg = (PWM_TIMERCFG_Type *) PWM_InitStruct;
-	PWM_COUNTERCFG_Type *pCounterCfg = (PWM_COUNTERCFG_Type *) PWM_InitStruct;
-
-	if (PWMTimerCounterMode == PWM_MODE_TIMER )
-	{
-		pTimeCfg-&gt;PrescaleOption = PWM_TIMER_PRESCALE_USVAL;
-		pTimeCfg-&gt;PrescaleValue = 1;
-	}
-	else if (PWMTimerCounterMode == PWM_MODE_COUNTER)
-	{
-		pCounterCfg-&gt;CountInputSelect = PWM_COUNTER_PCAP1_0;
-		pCounterCfg-&gt;CounterOption = PWM_COUNTER_RISING;
-	}
-}
-
-
-/*********************************************************************//**
- * @brief 		Initializes the PWMx peripheral corresponding to the specified
- *               parameters in the PWM_ConfigStruct.
- * @param[in]	PWMx PWM peripheral, should be PWM1
- * @param[in]	PWMTimerCounterMode Timer or Counter mode, should be:
- * 				- PWM_MODE_TIMER: Counter of PWM peripheral is in Timer mode
- * 				- PWM_MODE_COUNTER: Counter of PWM peripheral is in Counter mode
- * @param[in]	PWM_ConfigStruct Pointer to structure (PWM_TIMERCFG_Type or
- * 				 PWM_COUNTERCFG_Type) which will be initialized.
- * @return 		None
- * Note: PWM_ConfigStruct pointer will be assigned to corresponding structure
- * 		(PWM_TIMERCFG_Type or PWM_COUNTERCFG_Type) due to PWMTimerCounterMode.
- **********************************************************************/
-void PWM_Init(PWM_TypeDef *PWMx, uint32_t PWMTimerCounterMode, void *PWM_ConfigStruct)
-{
-	CHECK_PARAM(PARAM_PWMx(PWMx));
-	CHECK_PARAM(PARAM_PWM_TC_MODE(PWMTimerCounterMode));
-
-	PWM_TIMERCFG_Type *pTimeCfg = (PWM_TIMERCFG_Type *)PWM_ConfigStruct;
-	PWM_COUNTERCFG_Type *pCounterCfg = (PWM_COUNTERCFG_Type *)PWM_ConfigStruct;
-	uint64_t clkdlycnt;
-
-	if (PWMx == PWM1)
-	{
-		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCPWM1, ENABLE);
-		CLKPWR_SetPCLKDiv (CLKPWR_PCLKSEL_PWM1, CLKPWR_PCLKSEL_CCLK_DIV_4);
-		// Get peripheral clock of PWM1
-		clkdlycnt = (uint64_t) CLKPWR_GetPCLK (CLKPWR_PCLKSEL_PWM1);
-	}
-
-	// Clear all interrupts pending
-	PWMx-&gt;IR = 0xFF &amp; PWM_IR_BITMASK;
-	PWMx-&gt;TCR = 0x00;
-	PWMx-&gt;CTCR = 0x00;
-	PWMx-&gt;MCR = 0x00;
-	PWMx-&gt;CCR = 0x00;
-	PWMx-&gt;PCR = 0x00;
-	PWMx-&gt;LER = 0x00;
-
-	if (PWMTimerCounterMode == PWM_MODE_TIMER)
-	{
-		CHECK_PARAM(PARAM_PWM_TIMER_PRESCALE(pTimeCfg-&gt;PrescaleOption));
-
-		/* Absolute prescale value */
-		if (pTimeCfg-&gt;PrescaleOption == PWM_TIMER_PRESCALE_TICKVAL)
-		{
-			PWMx-&gt;PR   = pTimeCfg-&gt;PrescaleValue - 1;
-		}
-		/* uSecond prescale value */
-		else
-		{
-			clkdlycnt = (clkdlycnt * pTimeCfg-&gt;PrescaleValue) / 1000000;
-			PWMx-&gt;PR = ((uint32_t) clkdlycnt) - 1;
-		}
-
-	}
-	else if (PWMTimerCounterMode == PWM_MODE_COUNTER)
-	{
-		CHECK_PARAM(PARAM_PWM_COUNTER_INPUTSEL(pCounterCfg-&gt;CountInputSelect));
-		CHECK_PARAM(PARAM_PWM_COUNTER_EDGE(pCounterCfg-&gt;CounterOption));
-
-		PWMx-&gt;CTCR |= (PWM_CTCR_MODE((uint32_t)pCounterCfg-&gt;CounterOption)) \
-						| (PWM_CTCR_SELECT_INPUT((uint32_t)pCounterCfg-&gt;CountInputSelect));
-	}
-}
-
-/*********************************************************************//**
- * @brief		De-initializes the PWM peripheral registers to their
-*                  default reset values.
- * @param[in]	PWMx	PWM peripheral selected, should be PWM1
- * @return 		None
- **********************************************************************/
-void PWM_DeInit (PWM_TypeDef *PWMx)
-{
-	CHECK_PARAM(PARAM_PWMx(PWMx));
-
-	// Disable PWM control (timer, counter and PWM)
-	PWMx-&gt;TCR = 0x00;
-
-	if (PWMx == PWM1)
-	{
-		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCPWM1, DISABLE);
-	}
-}
-
-
-/*********************************************************************//**
- * @brief	 	Enable/Disable PWM peripheral
- * @param[in]	PWMx	PWM peripheral selected, should be PWM1
- * @param[in]	NewState	New State of this function, should be:
- * 							- ENABLE: Enable PWM peripheral
- * 							- DISABLE: Disable PWM peripheral
- * @return 		None
- **********************************************************************/
-void PWM_Cmd(PWM_TypeDef *PWMx, FunctionalState NewState)
-{
-	CHECK_PARAM(PARAM_PWMx(PWMx));
-	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
-
-	if (NewState == ENABLE)
-	{
-		PWMx-&gt;TCR	|=  PWM_TCR_PWM_ENABLE;
-	}
-	else
-	{
-		PWMx-&gt;TCR &amp;= (~PWM_TCR_PWM_ENABLE) &amp; PWM_TCR_BITMASK;
-	}
-}
-
-
-/*********************************************************************//**
- * @brief 		Enable/Disable Counter in PWM peripheral
- * @param[in]	PWMx	PWM peripheral selected, should be PWM1
- * @param[in]	NewState New State of this function, should be:
- * 							- ENABLE: Enable Counter in PWM peripheral
- * 							- DISABLE: Disable Counter in PWM peripheral
- * @return 		None
- **********************************************************************/
-void PWM_CounterCmd(PWM_TypeDef *PWMx, FunctionalState NewState)
-{
-	CHECK_PARAM(PARAM_PWMx(PWMx));
-	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
-	if (NewState == ENABLE)
-	{
-		PWMx-&gt;TCR	|=  PWM_TCR_COUNTER_ENABLE;
-	}
-	else
-	{
-		PWMx-&gt;TCR &amp;= (~PWM_TCR_COUNTER_ENABLE) &amp; PWM_TCR_BITMASK;
-	}
-}
-
-
-/*********************************************************************//**
- * @brief 		Reset Counter in PWM peripheral
- * @param[in]	PWMx	PWM peripheral selected, should be PWM1
- * @return 		None
- **********************************************************************/
-void PWM_ResetCounter(PWM_TypeDef *PWMx)
-{
-	CHECK_PARAM(PARAM_PWMx(PWMx));
-	PWMx-&gt;TCR |= PWM_TCR_COUNTER_RESET;
-	PWMx-&gt;TCR &amp;= (~PWM_TCR_COUNTER_RESET) &amp; PWM_TCR_BITMASK;
-}
-
-
-/*********************************************************************//**
- * @brief 		Configures match for PWM peripheral
- * @param[in]	PWMx	PWM peripheral selected, should be PWM1
- * @param[in]   PWM_MatchConfigStruct	Pointer to a PWM_MATCHCFG_Type structure
-*                    that contains the configuration information for the
-*                    specified PWM match function.
- * @return 		None
- **********************************************************************/
-void PWM_ConfigMatch(PWM_TypeDef *PWMx, PWM_MATCHCFG_Type *PWM_MatchConfigStruct)
-{
-	CHECK_PARAM(PARAM_PWMx(PWMx));
-	CHECK_PARAM(PARAM_PWM1_MATCH_CHANNEL(PWM_MatchConfigStruct-&gt;MatchChannel));
-	CHECK_PARAM(PARAM_FUNCTIONALSTATE(PWM_MatchConfigStruct-&gt;IntOnMatch));
-	CHECK_PARAM(PARAM_FUNCTIONALSTATE(PWM_MatchConfigStruct-&gt;ResetOnMatch));
-	CHECK_PARAM(PARAM_FUNCTIONALSTATE(PWM_MatchConfigStruct-&gt;StopOnMatch));
-
-	//interrupt on MRn
-	if (PWM_MatchConfigStruct-&gt;IntOnMatch == ENABLE)
-	{
-		PWMx-&gt;MCR |= PWM_MCR_INT_ON_MATCH(PWM_MatchConfigStruct-&gt;MatchChannel);
-	}
-	else
-	{
-		PWMx-&gt;MCR &amp;= (~PWM_MCR_INT_ON_MATCH(PWM_MatchConfigStruct-&gt;MatchChannel)) \
-					&amp; PWM_MCR_BITMASK;
-	}
-
-	//reset on MRn
-	if (PWM_MatchConfigStruct-&gt;ResetOnMatch == ENABLE)
-	{
-		PWMx-&gt;MCR |= PWM_MCR_RESET_ON_MATCH(PWM_MatchConfigStruct-&gt;MatchChannel);
-	}
-	else
-	{
-		PWMx-&gt;MCR &amp;= (~PWM_MCR_RESET_ON_MATCH(PWM_MatchConfigStruct-&gt;MatchChannel)) \
-					&amp; PWM_MCR_BITMASK;
-	}
-
-	//stop on MRn
-	if (PWM_MatchConfigStruct-&gt;StopOnMatch == ENABLE)
-	{
-		PWMx-&gt;MCR |= PWM_MCR_STOP_ON_MATCH(PWM_MatchConfigStruct-&gt;MatchChannel);
-	}
-	else
-	{
-		PWMx-&gt;MCR &amp;= (~PWM_MCR_STOP_ON_MATCH(PWM_MatchConfigStruct-&gt;MatchChannel)) \
-					&amp; PWM_MCR_BITMASK;
-	}
-}
-
-
-/*********************************************************************//**
- * @brief 		Configures capture input for PWM peripheral
- * @param[in]	PWMx	PWM peripheral selected, should be PWM1
- * @param[in]   PWM_CaptureConfigStruct	Pointer to a PWM_CAPTURECFG_Type structure
-*                    that contains the configuration information for the
-*                    specified PWM capture input function.
- * @return 		None
- **********************************************************************/
-void PWM_ConfigCapture(PWM_TypeDef *PWMx, PWM_CAPTURECFG_Type *PWM_CaptureConfigStruct)
-{
-	CHECK_PARAM(PARAM_PWMx(PWMx));
-	CHECK_PARAM(PARAM_PWM1_CAPTURE_CHANNEL(PWM_CaptureConfigStruct-&gt;CaptureChannel));
-	CHECK_PARAM(PARAM_FUNCTIONALSTATE(PWM_CaptureConfigStruct-&gt;FallingEdge));
-	CHECK_PARAM(PARAM_FUNCTIONALSTATE(PWM_CaptureConfigStruct-&gt;IntOnCaption));
-	CHECK_PARAM(PARAM_FUNCTIONALSTATE(PWM_CaptureConfigStruct-&gt;RisingEdge));
-
-	if (PWM_CaptureConfigStruct-&gt;RisingEdge == ENABLE)
-	{
-		PWMx-&gt;CCR |= PWM_CCR_CAP_RISING(PWM_CaptureConfigStruct-&gt;CaptureChannel);
-	}
-	else
-	{
-		PWMx-&gt;CCR &amp;= (~PWM_CCR_CAP_RISING(PWM_CaptureConfigStruct-&gt;CaptureChannel)) \
-					&amp; PWM_CCR_BITMASK;
-	}
-
-	if (PWM_CaptureConfigStruct-&gt;FallingEdge == ENABLE)
-	{
-		PWMx-&gt;CCR |= PWM_CCR_CAP_FALLING(PWM_CaptureConfigStruct-&gt;CaptureChannel);
-	}
-	else
-	{
-		PWMx-&gt;CCR &amp;= (~PWM_CCR_CAP_FALLING(PWM_CaptureConfigStruct-&gt;CaptureChannel)) \
-					&amp; PWM_CCR_BITMASK;
-	}
-
-	if (PWM_CaptureConfigStruct-&gt;IntOnCaption == ENABLE)
-	{
-		PWMx-&gt;CCR |= PWM_CCR_INT_ON_CAP(PWM_CaptureConfigStruct-&gt;CaptureChannel);
-	}
-	else
-	{
-		PWMx-&gt;CCR &amp;= (~PWM_CCR_INT_ON_CAP(PWM_CaptureConfigStruct-&gt;CaptureChannel)) \
-					&amp; PWM_CCR_BITMASK;
-	}
-}
-
-
-/*********************************************************************//**
- * @brief 		Read value of capture register PWM peripheral
- * @param[in]	PWMx	PWM peripheral selected, should be PWM1
- * @param[in]	CaptureChannel: capture channel number, should be in
- * 				range 0 to 1
- * @return 		Value of capture register
- **********************************************************************/
-uint32_t PWM_GetCaptureValue(PWM_TypeDef *PWMx, uint8_t CaptureChannel)
-{
-	CHECK_PARAM(PARAM_PWMx(PWMx));
-	CHECK_PARAM(PARAM_PWM1_CAPTURE_CHANNEL(CaptureChannel));
-
-	switch (CaptureChannel)
-	{
-	case 0:
-		return PWMx-&gt;CR0;
-		break;
-
-	case 1:
-		return PWMx-&gt;CR1;
-		break;
-
-	default:
-		return (0);
-		break;
-	}
-}
-
-
-/********************************************************************//**
- * @brief 		Update value for each PWM channel with update type option
- * @param[in]	PWMx	PWM peripheral selected, should be PWM1
- * @param[in]	Channel PWM Channel, should be in range from 1 to 6
- * @param[in]	UpdateType Type of Update, should be:
- * 				- PWM_MATCH_UPDATE_NOW: The update value will be updated for
- * 					this channel immediately
- * 				- PWM_MATCH_UPDATE_NEXT_RST: The update value will be updated for
- * 					this channel on next reset by a PWM Match event.
- * @return		None
- *********************************************************************/
-void PWM_MatchUpdate(PWM_TypeDef *PWMx, uint8_t MatchChannel, \
-					uint32_t MatchValue, uint8_t UpdateType)
-{
-	CHECK_PARAM(PARAM_PWMx(PWMx));
-	CHECK_PARAM(PARAM_PWM1_MATCH_CHANNEL(MatchChannel));
-	CHECK_PARAM(PARAM_PWM_MATCH_UPDATE(UpdateType));
-
-	switch (MatchChannel)
-	{
-	case 0:
-		PWMx-&gt;MR0 = MatchValue;
-		break;
-
-	case 1:
-		PWMx-&gt;MR1 = MatchValue;
-		break;
-
-	case 2:
-		PWMx-&gt;MR2 = MatchValue;
-		break;
-
-	case 3:
-		PWMx-&gt;MR3 = MatchValue;
-		break;
-
-	case 4:
-		PWMx-&gt;MR4 = MatchValue;
-		break;
-
-	case 5:
-		PWMx-&gt;MR5 = MatchValue;
-		break;
-
-	case 6:
-		PWMx-&gt;MR6 = MatchValue;
-		break;
-	}
-
-	// Write Latch register
-	PWMx-&gt;LER |= PWM_LER_EN_MATCHn_LATCH(MatchChannel);
-
-	// In case of update now
-	if (UpdateType == PWM_MATCH_UPDATE_NOW)
-	{
-		PWMx-&gt;TCR |= PWM_TCR_COUNTER_RESET;
-		PWMx-&gt;TCR &amp;= (~PWM_TCR_COUNTER_RESET) &amp; PWM_TCR_BITMASK;
-	}
-}
-
-
-/********************************************************************//**
- * @brief 		Configure Edge mode for each PWM channel
- * @param[in]	PWMx	PWM peripheral selected, should be PWM1
- * @param[in]	PWMChannel PWM channel, should be in range from 2 to 6
- * @param[in]	ModeOption PWM mode option, should be:
- * 				- PWM_CHANNEL_SINGLE_EDGE: Single Edge mode
- * 				- PWM_CHANNEL_DUAL_EDGE: Dual Edge mode
- * @return 		None
- * Note: PWM Channel 1 can not be selected for mode option
- *********************************************************************/
-void PWM_ChannelConfig(PWM_TypeDef *PWMx, uint8_t PWMChannel, uint8_t ModeOption)
-{
-	CHECK_PARAM(PARAM_PWMx(PWMx));
-	CHECK_PARAM(PARAM_PWM1_EDGE_MODE_CHANNEL(PWMChannel));
-	CHECK_PARAM(PARAM_PWM_CHANNEL_EDGE(ModeOption));
-
-	// Single edge mode
-	if (ModeOption == PWM_CHANNEL_SINGLE_EDGE)
-	{
-		PWMx-&gt;PCR &amp;= (~PWM_PCR_PWMSELn(PWMChannel)) &amp; PWM_PCR_BITMASK;
-	}
-	// Double edge mode
-	else if (PWM_CHANNEL_DUAL_EDGE)
-	{
-		PWMx-&gt;PCR |= PWM_PCR_PWMSELn(PWMChannel);
-	}
-}
-
-
-
-/********************************************************************//**
- * @brief 		Enable/Disable PWM channel output
- * @param[in]	PWMx	PWM peripheral selected, should be PWM1
- * @param[in]	PWMChannel PWM channel, should be in range from 1 to 6
- * @param[in]	NewState New State of this function, should be:
- * 				- ENABLE: Enable this PWM channel output
- * 				- DISABLE: Disable this PWM channel output
- * @return		None
- *********************************************************************/
-void PWM_ChannelCmd(PWM_TypeDef *PWMx, uint8_t PWMChannel, FunctionalState NewState)
-{
-	CHECK_PARAM(PARAM_PWMx(PWMx));
-	CHECK_PARAM(PARAM_PWM1_CHANNEL(PWMChannel));
-
-	if (NewState == ENABLE)
-	{
-		PWMx-&gt;PCR |= PWM_PCR_PWMENAn(PWMChannel);
-	}
-	else
-	{
-		PWMx-&gt;PCR &amp;= (~PWM_PCR_PWMENAn(PWMChannel)) &amp; PWM_PCR_BITMASK;
-	}
-}
-
-/**
- * @}
- */
-
-#endif /* _PWM */
-
-/**
- * @}
- */
-
-/* --------------------------------- End Of File ------------------------------ */
+/**
+ * @file	: lpc17xx_pwm.c
+ * @brief	: Contains all functions support for PWM firmware library on LPC17xx
+ * @version	: 1.0
+ * @date	: 22. Apr. 2009
+ * @author	: HieuNguyen
+ **************************************************************************
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * products. This software is supplied &quot;AS IS&quot; without any warranties.
+ * NXP Semiconductors assumes no responsibility or liability for the
+ * use of the software, conveys no license or title under any patent,
+ * copyright, or mask work right to the product. NXP Semiconductors
+ * reserves the right to make changes in the software without
+ * notification. NXP Semiconductors also make no representation or
+ * warranty that such application will be suitable for the specified
+ * use without further testing or modification.
+ **********************************************************************/
+
+/* Peripheral group ----------------------------------------------------------- */
+/** @addtogroup PWM
+ * @{
+ */
+
+/* Includes ------------------------------------------------------------------- */
+#include &quot;lpc17xx_pwm.h&quot;
+#include &quot;lpc17xx_clkpwr.h&quot;
+
+/* If this source file built with example, the LPC17xx FW library configuration
+ * file in each example directory (&quot;lpc17xx_libcfg.h&quot;) must be included,
+ * otherwise the default FW library configuration file must be included instead
+ */
+#ifdef __BUILD_WITH_EXAMPLE__
+#include &quot;lpc17xx_libcfg.h&quot;
+#else
+#include &quot;lpc17xx_libcfg_default.h&quot;
+#endif /* __BUILD_WITH_EXAMPLE__ */
+
+
+#ifdef _PWM
+
+
+/* Public Functions ----------------------------------------------------------- */
+/** @addtogroup PWM_Public_Functions
+ * @{
+ */
+
+
+/*********************************************************************//**
+ * @brief 		Check whether specified interrupt flag in PWM is set or not
+ * @param[in]	PWMx: PWM peripheral, should be PWM1
+ * @param[in]	IntFlag: PWM interrupt flag, should be:
+ * 				- PWM_INTSTAT_MR0: Interrupt flag for PWM match channel 0
+ * 				- PWM_INTSTAT_MR1: Interrupt flag for PWM match channel 1
+ * 				- PWM_INTSTAT_MR2: Interrupt flag for PWM match channel 2
+ * 				- PWM_INTSTAT_MR3: Interrupt flag for PWM match channel 3
+ * 				- PWM_INTSTAT_MR4: Interrupt flag for PWM match channel 4
+ * 				- PWM_INTSTAT_MR5: Interrupt flag for PWM match channel 5
+ * 				- PWM_INTSTAT_MR6: Interrupt flag for PWM match channel 6
+ * 				- PWM_INTSTAT_CAP0: Interrupt flag for capture input 0
+ * 				- PWM_INTSTAT_CAP1: Interrupt flag for capture input 1
+ * @return 		New State of PWM interrupt flag (SET or RESET)
+ **********************************************************************/
+IntStatus PWM_GetIntStatus(LPC_PWM_TypeDef *PWMx, uint32_t IntFlag)
+{
+	CHECK_PARAM(PARAM_PWMx(PWMx));
+	CHECK_PARAM(PARAM_PWM_INTSTAT(IntFlag));
+
+	return ((PWMx-&gt;IR &amp; IntFlag) ? SET : RESET);
+}
+
+
+
+/*********************************************************************//**
+ * @brief 		Clear specified PWM Interrupt pending
+ * @param[in]	PWMx: PWM peripheral, should be PWM1
+ * @param[in]	IntFlag: PWM interrupt flag, should be:
+ * 				- PWM_INTSTAT_MR0: Interrupt flag for PWM match channel 0
+ * 				- PWM_INTSTAT_MR1: Interrupt flag for PWM match channel 1
+ * 				- PWM_INTSTAT_MR2: Interrupt flag for PWM match channel 2
+ * 				- PWM_INTSTAT_MR3: Interrupt flag for PWM match channel 3
+ * 				- PWM_INTSTAT_MR4: Interrupt flag for PWM match channel 4
+ * 				- PWM_INTSTAT_MR5: Interrupt flag for PWM match channel 5
+ * 				- PWM_INTSTAT_MR6: Interrupt flag for PWM match channel 6
+ * 				- PWM_INTSTAT_CAP0: Interrupt flag for capture input 0
+ * 				- PWM_INTSTAT_CAP1: Interrupt flag for capture input 1
+ * @return 		None
+ **********************************************************************/
+void PWM_ClearIntPending(LPC_PWM_TypeDef *PWMx, uint32_t IntFlag)
+{
+	CHECK_PARAM(PARAM_PWMx(PWMx));
+	CHECK_PARAM(PARAM_PWM_INTSTAT(IntFlag));
+	PWMx-&gt;IR = IntFlag;
+}
+
+
+
+/*****************************************************************************//**
+* @brief		Fills each PWM_InitStruct member with its default value:
+* 				- If PWMCounterMode = PWM_MODE_TIMER:
+* 					+ PrescaleOption = PWM_TIMER_PRESCALE_USVAL
+* 					+ PrescaleValue = 1
+* 				- If PWMCounterMode = PWM_MODE_COUNTER:
+* 					+ CountInputSelect = PWM_COUNTER_PCAP1_0
+* 					+ CounterOption = PWM_COUNTER_RISING
+* @param[in]	PWMTimerCounterMode Timer or Counter mode, should be:
+* 				- PWM_MODE_TIMER: Counter of PWM peripheral is in Timer mode
+* 				- PWM_MODE_COUNTER: Counter of PWM peripheral is in Counter mode
+* @param[in]	PWM_InitStruct Pointer to structure (PWM_TIMERCFG_Type or
+* 				 PWM_COUNTERCFG_Type) which will be initialized.
+* @return		None
+* Note: PWM_InitStruct pointer will be assigned to corresponding structure
+* 		(PWM_TIMERCFG_Type or PWM_COUNTERCFG_Type) due to PWMTimerCounterMode.
+*******************************************************************************/
+void PWM_ConfigStructInit(uint8_t PWMTimerCounterMode, void *PWM_InitStruct)
+{
+	CHECK_PARAM(PARAM_PWM_TC_MODE(PWMTimerCounterMode));
+
+	PWM_TIMERCFG_Type *pTimeCfg = (PWM_TIMERCFG_Type *) PWM_InitStruct;
+	PWM_COUNTERCFG_Type *pCounterCfg = (PWM_COUNTERCFG_Type *) PWM_InitStruct;
+
+	if (PWMTimerCounterMode == PWM_MODE_TIMER )
+	{
+		pTimeCfg-&gt;PrescaleOption = PWM_TIMER_PRESCALE_USVAL;
+		pTimeCfg-&gt;PrescaleValue = 1;
+	}
+	else if (PWMTimerCounterMode == PWM_MODE_COUNTER)
+	{
+		pCounterCfg-&gt;CountInputSelect = PWM_COUNTER_PCAP1_0;
+		pCounterCfg-&gt;CounterOption = PWM_COUNTER_RISING;
+	}
+}
+
+
+/*********************************************************************//**
+ * @brief 		Initializes the PWMx peripheral corresponding to the specified
+ *               parameters in the PWM_ConfigStruct.
+ * @param[in]	PWMx PWM peripheral, should be PWM1
+ * @param[in]	PWMTimerCounterMode Timer or Counter mode, should be:
+ * 				- PWM_MODE_TIMER: Counter of PWM peripheral is in Timer mode
+ * 				- PWM_MODE_COUNTER: Counter of PWM peripheral is in Counter mode
+ * @param[in]	PWM_ConfigStruct Pointer to structure (PWM_TIMERCFG_Type or
+ * 				 PWM_COUNTERCFG_Type) which will be initialized.
+ * @return 		None
+ * Note: PWM_ConfigStruct pointer will be assigned to corresponding structure
+ * 		(PWM_TIMERCFG_Type or PWM_COUNTERCFG_Type) due to PWMTimerCounterMode.
+ **********************************************************************/
+void PWM_Init(LPC_PWM_TypeDef *PWMx, uint32_t PWMTimerCounterMode, void *PWM_ConfigStruct)
+{
+	CHECK_PARAM(PARAM_PWMx(PWMx));
+	CHECK_PARAM(PARAM_PWM_TC_MODE(PWMTimerCounterMode));
+
+	PWM_TIMERCFG_Type *pTimeCfg = (PWM_TIMERCFG_Type *)PWM_ConfigStruct;
+	PWM_COUNTERCFG_Type *pCounterCfg = (PWM_COUNTERCFG_Type *)PWM_ConfigStruct;
+	uint64_t clkdlycnt;
+
+	if (PWMx == LPC_PWM1)
+	{
+		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCPWM1, ENABLE);
+		CLKPWR_SetPCLKDiv (CLKPWR_PCLKSEL_PWM1, CLKPWR_PCLKSEL_CCLK_DIV_4);
+		// Get peripheral clock of PWM1
+		clkdlycnt = (uint64_t) CLKPWR_GetPCLK (CLKPWR_PCLKSEL_PWM1);
+	}
+
+	// Clear all interrupts pending
+	PWMx-&gt;IR = 0xFF &amp; PWM_IR_BITMASK;
+	PWMx-&gt;TCR = 0x00;
+	PWMx-&gt;CTCR = 0x00;
+	PWMx-&gt;MCR = 0x00;
+	PWMx-&gt;CCR = 0x00;
+	PWMx-&gt;PCR = 0x00;
+	PWMx-&gt;LER = 0x00;
+
+	if (PWMTimerCounterMode == PWM_MODE_TIMER)
+	{
+		CHECK_PARAM(PARAM_PWM_TIMER_PRESCALE(pTimeCfg-&gt;PrescaleOption));
+
+		/* Absolute prescale value */
+		if (pTimeCfg-&gt;PrescaleOption == PWM_TIMER_PRESCALE_TICKVAL)
+		{
+			PWMx-&gt;PR   = pTimeCfg-&gt;PrescaleValue - 1;
+		}
+		/* uSecond prescale value */
+		else
+		{
+			clkdlycnt = (clkdlycnt * pTimeCfg-&gt;PrescaleValue) / 1000000;
+			PWMx-&gt;PR = ((uint32_t) clkdlycnt) - 1;
+		}
+
+	}
+	else if (PWMTimerCounterMode == PWM_MODE_COUNTER)
+	{
+		CHECK_PARAM(PARAM_PWM_COUNTER_INPUTSEL(pCounterCfg-&gt;CountInputSelect));
+		CHECK_PARAM(PARAM_PWM_COUNTER_EDGE(pCounterCfg-&gt;CounterOption));
+
+		PWMx-&gt;CTCR |= (PWM_CTCR_MODE((uint32_t)pCounterCfg-&gt;CounterOption)) \
+						| (PWM_CTCR_SELECT_INPUT((uint32_t)pCounterCfg-&gt;CountInputSelect));
+	}
+}
+
+/*********************************************************************//**
+ * @brief		De-initializes the PWM peripheral registers to their
+*                  default reset values.
+ * @param[in]	PWMx	PWM peripheral selected, should be PWM1
+ * @return 		None
+ **********************************************************************/
+void PWM_DeInit (LPC_PWM_TypeDef *PWMx)
+{
+	CHECK_PARAM(PARAM_PWMx(PWMx));
+
+	// Disable PWM control (timer, counter and PWM)
+	PWMx-&gt;TCR = 0x00;
+
+	if (PWMx == LPC_PWM1)
+	{
+		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCPWM1, DISABLE);
+	}
+}
+
+
+/*********************************************************************//**
+ * @brief	 	Enable/Disable PWM peripheral
+ * @param[in]	PWMx	PWM peripheral selected, should be PWM1
+ * @param[in]	NewState	New State of this function, should be:
+ * 							- ENABLE: Enable PWM peripheral
+ * 							- DISABLE: Disable PWM peripheral
+ * @return 		None
+ **********************************************************************/
+void PWM_Cmd(LPC_PWM_TypeDef *PWMx, FunctionalState NewState)
+{
+	CHECK_PARAM(PARAM_PWMx(PWMx));
+	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
+
+	if (NewState == ENABLE)
+	{
+		PWMx-&gt;TCR	|=  PWM_TCR_PWM_ENABLE;
+	}
+	else
+	{
+		PWMx-&gt;TCR &amp;= (~PWM_TCR_PWM_ENABLE) &amp; PWM_TCR_BITMASK;
+	}
+}
+
+
+/*********************************************************************//**
+ * @brief 		Enable/Disable Counter in PWM peripheral
+ * @param[in]	PWMx	PWM peripheral selected, should be PWM1
+ * @param[in]	NewState New State of this function, should be:
+ * 							- ENABLE: Enable Counter in PWM peripheral
+ * 							- DISABLE: Disable Counter in PWM peripheral
+ * @return 		None
+ **********************************************************************/
+void PWM_CounterCmd(LPC_PWM_TypeDef *PWMx, FunctionalState NewState)
+{
+	CHECK_PARAM(PARAM_PWMx(PWMx));
+	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
+	if (NewState == ENABLE)
+	{
+		PWMx-&gt;TCR	|=  PWM_TCR_COUNTER_ENABLE;
+	}
+	else
+	{
+		PWMx-&gt;TCR &amp;= (~PWM_TCR_COUNTER_ENABLE) &amp; PWM_TCR_BITMASK;
+	}
+}
+
+
+/*********************************************************************//**
+ * @brief 		Reset Counter in PWM peripheral
+ * @param[in]	PWMx	PWM peripheral selected, should be PWM1
+ * @return 		None
+ **********************************************************************/
+void PWM_ResetCounter(LPC_PWM_TypeDef *PWMx)
+{
+	CHECK_PARAM(PARAM_PWMx(PWMx));
+	PWMx-&gt;TCR |= PWM_TCR_COUNTER_RESET;
+	PWMx-&gt;TCR &amp;= (~PWM_TCR_COUNTER_RESET) &amp; PWM_TCR_BITMASK;
+}
+
+
+/*********************************************************************//**
+ * @brief 		Configures match for PWM peripheral
+ * @param[in]	PWMx	PWM peripheral selected, should be PWM1
+ * @param[in]   PWM_MatchConfigStruct	Pointer to a PWM_MATCHCFG_Type structure
+*                    that contains the configuration information for the
+*                    specified PWM match function.
+ * @return 		None
+ **********************************************************************/
+void PWM_ConfigMatch(LPC_PWM_TypeDef *PWMx, PWM_MATCHCFG_Type *PWM_MatchConfigStruct)
+{
+	CHECK_PARAM(PARAM_PWMx(PWMx));
+	CHECK_PARAM(PARAM_PWM1_MATCH_CHANNEL(PWM_MatchConfigStruct-&gt;MatchChannel));
+	CHECK_PARAM(PARAM_FUNCTIONALSTATE(PWM_MatchConfigStruct-&gt;IntOnMatch));
+	CHECK_PARAM(PARAM_FUNCTIONALSTATE(PWM_MatchConfigStruct-&gt;ResetOnMatch));
+	CHECK_PARAM(PARAM_FUNCTIONALSTATE(PWM_MatchConfigStruct-&gt;StopOnMatch));
+
+	//interrupt on MRn
+	if (PWM_MatchConfigStruct-&gt;IntOnMatch == ENABLE)
+	{
+		PWMx-&gt;MCR |= PWM_MCR_INT_ON_MATCH(PWM_MatchConfigStruct-&gt;MatchChannel);
+	}
+	else
+	{
+		PWMx-&gt;MCR &amp;= (~PWM_MCR_INT_ON_MATCH(PWM_MatchConfigStruct-&gt;MatchChannel)) \
+					&amp; PWM_MCR_BITMASK;
+	}
+
+	//reset on MRn
+	if (PWM_MatchConfigStruct-&gt;ResetOnMatch == ENABLE)
+	{
+		PWMx-&gt;MCR |= PWM_MCR_RESET_ON_MATCH(PWM_MatchConfigStruct-&gt;MatchChannel);
+	}
+	else
+	{
+		PWMx-&gt;MCR &amp;= (~PWM_MCR_RESET_ON_MATCH(PWM_MatchConfigStruct-&gt;MatchChannel)) \
+					&amp; PWM_MCR_BITMASK;
+	}
+
+	//stop on MRn
+	if (PWM_MatchConfigStruct-&gt;StopOnMatch == ENABLE)
+	{
+		PWMx-&gt;MCR |= PWM_MCR_STOP_ON_MATCH(PWM_MatchConfigStruct-&gt;MatchChannel);
+	}
+	else
+	{
+		PWMx-&gt;MCR &amp;= (~PWM_MCR_STOP_ON_MATCH(PWM_MatchConfigStruct-&gt;MatchChannel)) \
+					&amp; PWM_MCR_BITMASK;
+	}
+}
+
+
+/*********************************************************************//**
+ * @brief 		Configures capture input for PWM peripheral
+ * @param[in]	PWMx	PWM peripheral selected, should be PWM1
+ * @param[in]   PWM_CaptureConfigStruct	Pointer to a PWM_CAPTURECFG_Type structure
+*                    that contains the configuration information for the
+*                    specified PWM capture input function.
+ * @return 		None
+ **********************************************************************/
+void PWM_ConfigCapture(LPC_PWM_TypeDef *PWMx, PWM_CAPTURECFG_Type *PWM_CaptureConfigStruct)
+{
+	CHECK_PARAM(PARAM_PWMx(PWMx));
+	CHECK_PARAM(PARAM_PWM1_CAPTURE_CHANNEL(PWM_CaptureConfigStruct-&gt;CaptureChannel));
+	CHECK_PARAM(PARAM_FUNCTIONALSTATE(PWM_CaptureConfigStruct-&gt;FallingEdge));
+	CHECK_PARAM(PARAM_FUNCTIONALSTATE(PWM_CaptureConfigStruct-&gt;IntOnCaption));
+	CHECK_PARAM(PARAM_FUNCTIONALSTATE(PWM_CaptureConfigStruct-&gt;RisingEdge));
+
+	if (PWM_CaptureConfigStruct-&gt;RisingEdge == ENABLE)
+	{
+		PWMx-&gt;CCR |= PWM_CCR_CAP_RISING(PWM_CaptureConfigStruct-&gt;CaptureChannel);
+	}
+	else
+	{
+		PWMx-&gt;CCR &amp;= (~PWM_CCR_CAP_RISING(PWM_CaptureConfigStruct-&gt;CaptureChannel)) \
+					&amp; PWM_CCR_BITMASK;
+	}
+
+	if (PWM_CaptureConfigStruct-&gt;FallingEdge == ENABLE)
+	{
+		PWMx-&gt;CCR |= PWM_CCR_CAP_FALLING(PWM_CaptureConfigStruct-&gt;CaptureChannel);
+	}
+	else
+	{
+		PWMx-&gt;CCR &amp;= (~PWM_CCR_CAP_FALLING(PWM_CaptureConfigStruct-&gt;CaptureChannel)) \
+					&amp; PWM_CCR_BITMASK;
+	}
+
+	if (PWM_CaptureConfigStruct-&gt;IntOnCaption == ENABLE)
+	{
+		PWMx-&gt;CCR |= PWM_CCR_INT_ON_CAP(PWM_CaptureConfigStruct-&gt;CaptureChannel);
+	}
+	else
+	{
+		PWMx-&gt;CCR &amp;= (~PWM_CCR_INT_ON_CAP(PWM_CaptureConfigStruct-&gt;CaptureChannel)) \
+					&amp; PWM_CCR_BITMASK;
+	}
+}
+
+
+/*********************************************************************//**
+ * @brief 		Read value of capture register PWM peripheral
+ * @param[in]	PWMx	PWM peripheral selected, should be PWM1
+ * @param[in]	CaptureChannel: capture channel number, should be in
+ * 				range 0 to 1
+ * @return 		Value of capture register
+ **********************************************************************/
+uint32_t PWM_GetCaptureValue(LPC_PWM_TypeDef *PWMx, uint8_t CaptureChannel)
+{
+	CHECK_PARAM(PARAM_PWMx(PWMx));
+	CHECK_PARAM(PARAM_PWM1_CAPTURE_CHANNEL(CaptureChannel));
+
+	switch (CaptureChannel)
+	{
+	case 0:
+		return PWMx-&gt;CR0;
+		break;
+
+	case 1:
+		return PWMx-&gt;CR1;
+		break;
+
+	default:
+		return (0);
+		break;
+	}
+}
+
+
+/********************************************************************//**
+ * @brief 		Update value for each PWM channel with update type option
+ * @param[in]	PWMx	PWM peripheral selected, should be PWM1
+ * @param[in]	MatchChannel Match channel
+ * @param[in]	MatchValue Match value
+ * @param[in]	UpdateType Type of Update, should be:
+ * 				- PWM_MATCH_UPDATE_NOW: The update value will be updated for
+ * 					this channel immediately
+ * 				- PWM_MATCH_UPDATE_NEXT_RST: The update value will be updated for
+ * 					this channel on next reset by a PWM Match event.
+ * @return		None
+ *********************************************************************/
+void PWM_MatchUpdate(LPC_PWM_TypeDef *PWMx, uint8_t MatchChannel, \
+					uint32_t MatchValue, uint8_t UpdateType)
+{
+	CHECK_PARAM(PARAM_PWMx(PWMx));
+	CHECK_PARAM(PARAM_PWM1_MATCH_CHANNEL(MatchChannel));
+	CHECK_PARAM(PARAM_PWM_MATCH_UPDATE(UpdateType));
+
+	switch (MatchChannel)
+	{
+	case 0:
+		PWMx-&gt;MR0 = MatchValue;
+		break;
+
+	case 1:
+		PWMx-&gt;MR1 = MatchValue;
+		break;
+
+	case 2:
+		PWMx-&gt;MR2 = MatchValue;
+		break;
+
+	case 3:
+		PWMx-&gt;MR3 = MatchValue;
+		break;
+
+	case 4:
+		PWMx-&gt;MR4 = MatchValue;
+		break;
+
+	case 5:
+		PWMx-&gt;MR5 = MatchValue;
+		break;
+
+	case 6:
+		PWMx-&gt;MR6 = MatchValue;
+		break;
+	}
+
+	// Write Latch register
+	PWMx-&gt;LER |= PWM_LER_EN_MATCHn_LATCH(MatchChannel);
+
+	// In case of update now
+	if (UpdateType == PWM_MATCH_UPDATE_NOW)
+	{
+		PWMx-&gt;TCR |= PWM_TCR_COUNTER_RESET;
+		PWMx-&gt;TCR &amp;= (~PWM_TCR_COUNTER_RESET) &amp; PWM_TCR_BITMASK;
+	}
+}
+
+
+/********************************************************************//**
+ * @brief 		Configure Edge mode for each PWM channel
+ * @param[in]	PWMx	PWM peripheral selected, should be PWM1
+ * @param[in]	PWMChannel PWM channel, should be in range from 2 to 6
+ * @param[in]	ModeOption PWM mode option, should be:
+ * 				- PWM_CHANNEL_SINGLE_EDGE: Single Edge mode
+ * 				- PWM_CHANNEL_DUAL_EDGE: Dual Edge mode
+ * @return 		None
+ * Note: PWM Channel 1 can not be selected for mode option
+ *********************************************************************/
+void PWM_ChannelConfig(LPC_PWM_TypeDef *PWMx, uint8_t PWMChannel, uint8_t ModeOption)
+{
+	CHECK_PARAM(PARAM_PWMx(PWMx));
+	CHECK_PARAM(PARAM_PWM1_EDGE_MODE_CHANNEL(PWMChannel));
+	CHECK_PARAM(PARAM_PWM_CHANNEL_EDGE(ModeOption));
+
+	// Single edge mode
+	if (ModeOption == PWM_CHANNEL_SINGLE_EDGE)
+	{
+		PWMx-&gt;PCR &amp;= (~PWM_PCR_PWMSELn(PWMChannel)) &amp; PWM_PCR_BITMASK;
+	}
+	// Double edge mode
+	else if (PWM_CHANNEL_DUAL_EDGE)
+	{
+		PWMx-&gt;PCR |= PWM_PCR_PWMSELn(PWMChannel);
+	}
+}
+
+
+
+/********************************************************************//**
+ * @brief 		Enable/Disable PWM channel output
+ * @param[in]	PWMx	PWM peripheral selected, should be PWM1
+ * @param[in]	PWMChannel PWM channel, should be in range from 1 to 6
+ * @param[in]	NewState New State of this function, should be:
+ * 				- ENABLE: Enable this PWM channel output
+ * 				- DISABLE: Disable this PWM channel output
+ * @return		None
+ *********************************************************************/
+void PWM_ChannelCmd(LPC_PWM_TypeDef *PWMx, uint8_t PWMChannel, FunctionalState NewState)
+{
+	CHECK_PARAM(PARAM_PWMx(PWMx));
+	CHECK_PARAM(PARAM_PWM1_CHANNEL(PWMChannel));
+
+	if (NewState == ENABLE)
+	{
+		PWMx-&gt;PCR |= PWM_PCR_PWMENAn(PWMChannel);
+	}
+	else
+	{
+		PWMx-&gt;PCR &amp;= (~PWM_PCR_PWMENAn(PWMChannel)) &amp; PWM_PCR_BITMASK;
+	}
+}
+
+/**
+ * @}
+ */
+
+#endif /* _PWM */
+
+/**
+ * @}
+ */
+
+/* --------------------------------- End Of File ------------------------------ */


Property changes on: trunk/src/platform/lpc17xx/drivers/src/lpc17xx_pwm.c
___________________________________________________________________
Deleted: svn:executable
   - *

Modified: trunk/src/platform/lpc17xx/drivers/src/lpc17xx_qei.c
===================================================================
--- trunk/src/platform/lpc17xx/drivers/src/lpc17xx_qei.c	2010-06-28 21:53:59 UTC (rev 759)
+++ trunk/src/platform/lpc17xx/drivers/src/lpc17xx_qei.c	2010-07-12 20:56:54 UTC (rev 760)
@@ -1,499 +1,502 @@
-/**
- * @file	: lpc17xx_qei.c
- * @brief	: Contains all functions support for QEI firmware library on LPC17xx
- * @version	: 1.0
- * @date	: 26. May. 2009
- * @author	: HieuNguyen
- *----------------------------------------------------------------------------
- * Software that is described herein is for illustrative purposes only
- * which provides customers with programming information regarding the
- * products. This software is supplied &quot;AS IS&quot; without any warranties.
- * NXP Semiconductors assumes no responsibility or liability for the
- * use of the software, conveys no license or title under any patent,
- * copyright, or mask work right to the product. NXP Semiconductors
- * reserves the right to make changes in the software without
- * notification. NXP Semiconductors also make no representation or
- * warranty that such application will be suitable for the specified
- * use without further testing or modification.
- **********************************************************************/
-
-/* Peripheral group ----------------------------------------------------------- */
-/** @addtogroup QEI
- * @{
- */
-
-/* Includes ------------------------------------------------------------------- */
-#include &quot;lpc17xx_qei.h&quot;
-#include &quot;lpc17xx_clkpwr.h&quot;
-
-
-/* If this source file built with example, the LPC17xx FW library configuration
- * file in each example directory (&quot;lpc17xx_libcfg.h&quot;) must be included,
- * otherwise the default FW library configuration file must be included instead
- */
-#ifdef __BUILD_WITH_EXAMPLE__
-#include &quot;lpc17xx_libcfg.h&quot;
-#else
-#include &quot;lpc17xx_libcfg_default.h&quot;
-#endif /* __BUILD_WITH_EXAMPLE__ */
-
-
-#ifdef _QEI
-
-/* Private Types -------------------------------------------------------------- */
-/** @defgroup QEI_Private_Types
- * @{
- */
-
-/**
- * @brief QEI configuration union type definition
- */
-typedef union {
-	QEI_CFG_Type bmQEIConfig;
-	uint32_t ulQEIConfig;
-} QEI_CFGOPT_Type;
-
-/**
- * @}
- */
-
-
-/* Public Functions ----------------------------------------------------------- */
-/** @addtogroup QEI_Public_Functions
- * @{
- */
-
-/*********************************************************************//**
- * @brief		Resets value for each type of QEI value, such as velocity,
- * 				counter, position, etc..
- * @param[in]	QEIx			QEI peripheral, should be QEI
- * @param[in]	ulResetType		QEI Reset Type, should be one of the following:
- * 								- QEI_RESET_POS: Reset Position Counter
- * 								- QEI_RESET_POSOnIDX: Reset Position Counter on Index signal
- * 								- QEI_RESET_VEL: Reset Velocity
- * 								- QEI_RESET_IDX: Reset Index Counter
- * @return		None
- **********************************************************************/
-void QEI_Reset(QEI_TypeDef *QEIx, uint32_t ulResetType)
-{
-	CHECK_PARAM(PARAM_QEIx(QEIx));
-	CHECK_PARAM(PARAM_QEI_RESET(ulResetType));
-
-	QEIx-&gt;QEICON = ulResetType;
-}
-
-/*********************************************************************//**
- * @brief		Initializes the QEI peripheral according to the specified
-*               parameters in the QEI_ConfigStruct.
- * @param[in]	QEIx				QEI peripheral, should be QEI
- * @param[in]	QEI_ConfigStruct	Pointer to a QEI_CFG_Type structure
-*                    that contains the configuration information for the
-*                    specified QEI peripheral
- * @return		None
- **********************************************************************/
-void QEI_Init(QEI_TypeDef *QEIx, QEI_CFG_Type *QEI_ConfigStruct)
-{
-
-	CHECK_PARAM(PARAM_QEIx(QEIx));
-	CHECK_PARAM(PARAM_QEI_DIRINV(QEI_ConfigStruct-&gt;DirectionInvert));
-	CHECK_PARAM(PARAM_QEI_SIGNALMODE(QEI_ConfigStruct-&gt;SignalMode));
-	CHECK_PARAM(PARAM_QEI_CAPMODE(QEI_ConfigStruct-&gt;CaptureMode));
-	CHECK_PARAM(PARAM_QEI_INVINX(QEI_ConfigStruct-&gt;InvertIndex));
-
-	/* Set up clock and power for QEI module */
-	CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCQEI, ENABLE);
-
-	/* As default, peripheral clock for QEI module
-	 * is set to FCCLK / 2 */
-	CLKPWR_SetPCLKDiv(CLKPWR_PCLKSEL_QEI, CLKPWR_PCLKSEL_CCLK_DIV_1);
-
-	// Reset all remaining value in QEI peripheral
-	QEIx-&gt;QEICON = QEI_CON_RESP | QEI_CON_RESV | QEI_CON_RESI;
-	QEIx-&gt;QEIMAXPOS = 0x00;
-	QEIx-&gt;CMPOS0 = 0x00;
-	QEIx-&gt;CMPOS1 = 0x00;
-	QEIx-&gt;CMPOS2 = 0x00;
-	QEIx-&gt;INXCMP = 0x00;
-	QEIx-&gt;QEILOAD = 0x00;
-	QEIx-&gt;VELCOMP = 0x00;
-	QEIx-&gt;FILTER = 0x00;
-	// Disable all Interrupt
-	QEIx-&gt;QEIIEC = QEI_IECLR_BITMASK;
-	// Clear all Interrupt pending
-	QEIx-&gt;QEICLR = QEI_INTCLR_BITMASK;
-	// Set QEI configuration value corresponding to its setting up value
-	QEIx-&gt;QEICONF = ((QEI_CFGOPT_Type *)QEI_ConfigStruct)-&gt;ulQEIConfig;
-}
-
-
-/*********************************************************************//**
- * @brief		De-initializes the QEI peripheral registers to their
-*                  default reset values.
- * @param[in]	QEIx				QEI peripheral, should be QEI
- * @return 		None
- **********************************************************************/
-void QEI_DeInit(QEI_TypeDef *QEIx)
-{
-	CHECK_PARAM(PARAM_QEIx(QEIx));
-
-	/* Turn off clock and power for QEI module */
-	CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCQEI, DISABLE);
-}
-
-
-/*****************************************************************************//**
-* @brief		Fills each QIE_InitStruct member with its default value:
-* 				- DirectionInvert = QEI_DIRINV_NONE
-* 				- SignalMode = QEI_SIGNALMODE_QUAD
-* 				- CaptureMode = QEI_CAPMODE_4X
-* 				- InvertIndex = QEI_INVINX_NONE
-* @param[in]	QIE_InitStruct Pointer to a QEI_CFG_Type structure
-*                    which will be initialized.
-* @return		None
-*******************************************************************************/
-void QEI_ConfigStructInit(QEI_CFG_Type *QIE_InitStruct)
-{
-	QIE_InitStruct-&gt;CaptureMode = QEI_CAPMODE_4X;
-	QIE_InitStruct-&gt;DirectionInvert = QEI_DIRINV_NONE;
-	QIE_InitStruct-&gt;InvertIndex = QEI_INVINX_NONE;
-	QIE_InitStruct-&gt;SignalMode = QEI_SIGNALMODE_QUAD;
-}
-
-
-/*********************************************************************//**
- * @brief		Check whether if specified flag status is set or not
- * @param[in]	QEIx		QEI peripheral, should be QEI
- * @param[in]	ulFlagType	Status Flag Type, should be one of the following:
- * 							- QEI_STATUS_DIR: Direction Status
- * @return		New Status of this status flag (SET or RESET)
- **********************************************************************/
-FlagStatus QEI_GetStatus(QEI_TypeDef *QEIx, uint32_t ulFlagType)
-{
-	CHECK_PARAM(PARAM_QEIx(QEIx));
-	CHECK_PARAM(PARAM_QEI_STATUS(ulFlagType));
-	return ((QEIx-&gt;QEISTAT &amp; ulFlagType) ? SET : RESET);
-}
-
-/*********************************************************************//**
- * @brief		Get current position value in QEI peripheral
- * @param[in]	QEIx		QEI peripheral, should be QEI
- * @return		Current position value of QEI peripheral
- **********************************************************************/
-uint32_t QEI_GetPosition(QEI_TypeDef *QEIx)
-{
-	CHECK_PARAM(PARAM_QEIx(QEIx));
-	return (QEIx-&gt;QEIPOS);
-}
-
-/*********************************************************************//**
- * @brief		Set max position value for QEI peripheral
- * @param[in]	QEIx		QEI peripheral, should be QEI
- * @param[in]	ulMaxPos	Max position value to set
- * @return		None
- **********************************************************************/
-void QEI_SetMaxPosition(QEI_TypeDef *QEIx, uint32_t ulMaxPos)
-{
-	CHECK_PARAM(PARAM_QEIx(QEIx));
-	QEIx-&gt;QEIMAXPOS = ulMaxPos;
-}
-
-/*********************************************************************//**
- * @brief		Set position compare value for QEI peripheral
- * @param[in]	QEIx		QEI peripheral, should be QEI
- * @param[in]	bPosCompCh	Compare Position channel, should be:
- * 							- QEI_COMPPOS_CH_0: QEI compare position channel 0
- * 							- QEI_COMPPOS_CH_1: QEI compare position channel 1
- * 							- QEI_COMPPOS_CH_2: QEI compare position channel 2
- * @param[in]	ulPosComp	Compare Position value to set
- * @return		None
- **********************************************************************/
-void QEI_SetPositionComp(QEI_TypeDef *QEIx, uint8_t bPosCompCh, uint32_t ulPosComp)
-{
-	uint32_t *tmp;
-
-	CHECK_PARAM(PARAM_QEIx(QEIx));
-	CHECK_PARAM(PARAM_QEI_COMPPOS_CH(bPosCompCh));
-	tmp = (uint32_t *) (&amp;(QEIx-&gt;CMPOS0) + bPosCompCh * 4);
-	*tmp = ulPosComp;
-
-}
-
-/*********************************************************************//**
- * @brief		Get current index counter of QEI peripheral
- * @param[in]	QEIx		QEI peripheral, should be QEI
- * @return		Current value of QEI index counter
- **********************************************************************/
-uint32_t QEI_GetIndex(QEI_TypeDef *QEIx)
-{
-	CHECK_PARAM(PARAM_QEIx(QEIx));
-	return (QEIx-&gt;INXCNT);
-}
-
-/*********************************************************************//**
- * @brief		Set value for index compare in QEI peripheral
- * @param[in]	QEIx		QEI peripheral, should be QEI
- * @param[in]	ulIndexComp		Compare Index Value to set
- * @return		None
- **********************************************************************/
-void QEI_SetIndexComp(QEI_TypeDef *QEIx, uint32_t ulIndexComp)
-{
-	CHECK_PARAM(PARAM_QEIx(QEIx));
-	QEIx-&gt;INXCMP = ulIndexComp;
-}
-
-/*********************************************************************//**
- * @brief		Set timer reload value for QEI peripheral. When the velocity timer is
- * 				over-flow, the value that set for Timer Reload register will be loaded
- * 				into the velocity timer for next period. The calculated velocity in RPM
- * 				therefore will be affect by this value.
- * @param[in]	QEIx			QEI peripheral, should be QEI
- * @param[in]	ulTimerReload	Timer Reload value to set
- * @return		None
- **********************************************************************/
-void QEI_SetTimerReload(QEI_TypeDef *QEIx, QEI_RELOADCFG_Type *QEIReloadStruct)
-{
-	uint64_t pclk;
-
-	CHECK_PARAM(PARAM_QEIx(QEIx));
-	CHECK_PARAM(PARAM_QEI_TIMERRELOAD(QEIReloadStruct-&gt;ReloadOption));
-
-	if (QEIReloadStruct-&gt;ReloadOption == QEI_TIMERRELOAD_TICKVAL) {
-		QEIx-&gt;QEILOAD = QEIReloadStruct-&gt;ReloadValue - 1;
-	} else {
-		pclk = (uint64_t)CLKPWR_GetPCLK(CLKPWR_PCLKSEL_QEI);
-		pclk = (pclk /(1000000/QEIReloadStruct-&gt;ReloadValue)) - 1;
-		QEIx-&gt;QEILOAD = (uint32_t)pclk;
-	}
-}
-
-/*********************************************************************//**
- * @brief		Get current timer counter in QEI peripheral
- * @param[in]	QEIx			QEI peripheral, should be QEI
- * @return		Current timer counter in QEI peripheral
- **********************************************************************/
-uint32_t QEI_GetTimer(QEI_TypeDef *QEIx)
-{
-	CHECK_PARAM(PARAM_QEIx(QEIx));
-	return (QEIx-&gt;QEITIME);
-}
-
-/*********************************************************************//**
- * @brief		Get current velocity pulse counter in current time period
- * @param[in]	QEIx			QEI peripheral, should be QEI
- * @return		Current velocity pulse counter value
- **********************************************************************/
-uint32_t QEI_GetVelocity(QEI_TypeDef *QEIx)
-{
-	CHECK_PARAM(PARAM_QEIx(QEIx));
-	return (QEIx-&gt;QEIVEL);
-}
-
-/*********************************************************************//**
- * @brief		Get the most recently measured velocity of the QEI. When
- * 				the Velocity timer in QEI is over-flow, the current velocity
- * 				value will be loaded into Velocity Capture register.
- * @param[in]	QEIx			QEI peripheral, should be QEI
- * @return		The most recently measured velocity value
- **********************************************************************/
-uint32_t QEI_GetVelocityCap(QEI_TypeDef *QEIx)
-{
-	CHECK_PARAM(PARAM_QEIx(QEIx));
-	return (QEIx-&gt;QEICAP);
-}
-
-/*********************************************************************//**
- * @brief		Set Velocity Compare value for QEI peripheral
- * @param[in]	QEIx			QEI peripheral, should be QEI
- * @param[in]	ulVelComp		Compare Velocity value to set
- * @return		None
- **********************************************************************/
-void QEI_SetVelocityComp(QEI_TypeDef *QEIx, uint32_t ulVelComp)
-{
-	CHECK_PARAM(PARAM_QEIx(QEIx));
-	QEIx-&gt;VELCOMP = ulVelComp;
-}
-
-/*********************************************************************//**
- * @brief		Set value of sampling count for the digital filter in
- * 				QEI peripheral
- * @param[in]	QEIx			QEI peripheral, should be QEI
- * @param[in]	ulSamplingPulse	Value of sampling count to set
- * @return		None
- **********************************************************************/
-void QEI_SetDigiFilter(QEI_TypeDef *QEIx, uint32_t ulSamplingPulse)
-{
-	CHECK_PARAM(PARAM_QEIx(QEIx));
-	QEIx-&gt;FILTER = ulSamplingPulse;
-}
-
-/*********************************************************************//**
- * @brief		Check whether if specified interrupt flag status in QEI
- * 				peripheral is set or not
- * @param[in]	QEIx			QEI peripheral, should be QEI
- * @param[in]	ulIntType		Interrupt Flag Status type, should be:
-								- QEI_INTFLAG_INX_Int: index pulse was detected interrupt
-								- QEI_INTFLAG_TIM_Int: Velocity timer over flow interrupt
-								- QEI_INTFLAG_VELC_Int: Capture velocity is less than compare interrupt
-								- QEI_INTFLAG_DIR_Int: Change of direction interrupt
-								- QEI_INTFLAG_ERR_Int: An encoder phase error interrupt
-								- QEI_INTFLAG_ENCLK_Int: An encoder clock pulse was detected interrupt
-								- QEI_INTFLAG_POS0_Int: position 0 compare value is equal to the
-														current position interrupt
-								- QEI_INTFLAG_POS1_Int: position 1 compare value is equal to the
-														current position interrupt
-								- QEI_INTFLAG_POS2_Int: position 2 compare value is equal to the
-														current position interrupt
-								- QEI_INTFLAG_REV_Int: Index compare value is equal to the current
-														index count interrupt
-								- QEI_INTFLAG_POS0REV_Int: Combined position 0 and revolution count interrupt
-								- QEI_INTFLAG_POS1REV_Int: Combined position 1 and revolution count interrupt
-								- QEI_INTFLAG_POS2REV_Int: Combined position 2 and revolution count interrupt
- * @return		New State of specified interrupt flag status (SET or RESET)
- **********************************************************************/
-FlagStatus QEI_GetIntStatus(QEI_TypeDef *QEIx, uint32_t ulIntType)
-{
-	CHECK_PARAM(PARAM_QEIx(QEIx));
-	CHECK_PARAM(PARAM_QEI_INTFLAG(ulIntType));
-
-	return((QEIx-&gt;QEIINTSTAT &amp; ulIntType) ? SET : RESET);
-}
-
-/*********************************************************************//**
- * @brief		Enable/Disable specified interrupt in QEI peripheral
- * @param[in]	QEIx			QEI peripheral, should be QEI
- * @param[in]	ulIntType		Interrupt Flag Status type, should be:
-								- QEI_INTFLAG_INX_Int: index pulse was detected interrupt
-								- QEI_INTFLAG_TIM_Int: Velocity timer over flow interrupt
-								- QEI_INTFLAG_VELC_Int: Capture velocity is less than compare interrupt
-								- QEI_INTFLAG_DIR_Int: Change of direction interrupt
-								- QEI_INTFLAG_ERR_Int: An encoder phase error interrupt
-								- QEI_INTFLAG_ENCLK_Int: An encoder clock pulse was detected interrupt
-								- QEI_INTFLAG_POS0_Int: position 0 compare value is equal to the
-														current position interrupt
-								- QEI_INTFLAG_POS1_Int: position 1 compare value is equal to the
-														current position interrupt
-								- QEI_INTFLAG_POS2_Int: position 2 compare value is equal to the
-														current position interrupt
-								- QEI_INTFLAG_REV_Int: Index compare value is equal to the current
-														index count interrupt
-								- QEI_INTFLAG_POS0REV_Int: Combined position 0 and revolution count interrupt
-								- QEI_INTFLAG_POS1REV_Int: Combined position 1 and revolution count interrupt
-								- QEI_INTFLAG_POS2REV_Int: Combined position 2 and revolution count interrupt
- * @return		None
- **********************************************************************/
-void QEI_IntCmd(QEI_TypeDef *QEIx, uint32_t ulIntType, FunctionalState NewState)
-{
-	CHECK_PARAM(PARAM_QEIx(QEIx));
-	CHECK_PARAM(PARAM_QEI_INTFLAG(ulIntType));
-	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
-
-	if (NewState == ENABLE) {
-		QEIx-&gt;QEIIES = ulIntType;
-	} else {
-		QEIx-&gt;QEIIEC = ulIntType;
-	}
-}
-
-
-/*********************************************************************//**
- * @brief		Sets (forces) specified interrupt in QEI peripheral
- * @param[in]	QEIx			QEI peripheral, should be QEI
- * @param[in]	ulIntType		Interrupt Flag Status type, should be:
-								- QEI_INTFLAG_INX_Int: index pulse was detected interrupt
-								- QEI_INTFLAG_TIM_Int: Velocity timer over flow interrupt
-								- QEI_INTFLAG_VELC_Int: Capture velocity is less than compare interrupt
-								- QEI_INTFLAG_DIR_Int: Change of direction interrupt
-								- QEI_INTFLAG_ERR_Int: An encoder phase error interrupt
-								- QEI_INTFLAG_ENCLK_Int: An encoder clock pulse was detected interrupt
-								- QEI_INTFLAG_POS0_Int: position 0 compare value is equal to the
-														current position interrupt
-								- QEI_INTFLAG_POS1_Int: position 1 compare value is equal to the
-														current position interrupt
-								- QEI_INTFLAG_POS2_Int: position 2 compare value is equal to the
-														current position interrupt
-								- QEI_INTFLAG_REV_Int: Index compare value is equal to the current
-														index count interrupt
-								- QEI_INTFLAG_POS0REV_Int: Combined position 0 and revolution count interrupt
-								- QEI_INTFLAG_POS1REV_Int: Combined position 1 and revolution count interrupt
-								- QEI_INTFLAG_POS2REV_Int: Combined position 2 and revolution count interrupt
- * @return		None
- **********************************************************************/
-void QEI_IntSet(QEI_TypeDef *QEIx, uint32_t ulIntType)
-{
-	CHECK_PARAM(PARAM_QEIx(QEIx));
-	CHECK_PARAM(PARAM_QEI_INTFLAG(ulIntType));
-
-	QEIx-&gt;QEISET = ulIntType;
-}
-
-/*********************************************************************//**
- * @brief		Clear (force) specified interrupt (pending) in QEI peripheral
- * @param[in]	QEIx			QEI peripheral, should be QEI
- * @param[in]	ulIntType		Interrupt Flag Status type, should be:
-								- QEI_INTFLAG_INX_Int: index pulse was detected interrupt
-								- QEI_INTFLAG_TIM_Int: Velocity timer over flow interrupt
-								- QEI_INTFLAG_VELC_Int: Capture velocity is less than compare interrupt
-								- QEI_INTFLAG_DIR_Int: Change of direction interrupt
-								- QEI_INTFLAG_ERR_Int: An encoder phase error interrupt
-								- QEI_INTFLAG_ENCLK_Int: An encoder clock pulse was detected interrupt
-								- QEI_INTFLAG_POS0_Int: position 0 compare value is equal to the
-														current position interrupt
-								- QEI_INTFLAG_POS1_Int: position 1 compare value is equal to the
-														current position interrupt
-								- QEI_INTFLAG_POS2_Int: position 2 compare value is equal to the
-														current position interrupt
-								- QEI_INTFLAG_REV_Int: Index compare value is equal to the current
-														index count interrupt
-								- QEI_INTFLAG_POS0REV_Int: Combined position 0 and revolution count interrupt
-								- QEI_INTFLAG_POS1REV_Int: Combined position 1 and revolution count interrupt
-								- QEI_INTFLAG_POS2REV_Int: Combined position 2 and revolution count interrupt
- * @return		None
- **********************************************************************/
-void QEI_IntClear(QEI_TypeDef *QEIx, uint32_t ulIntType)
-{
-	CHECK_PARAM(PARAM_QEIx(QEIx));
-	CHECK_PARAM(PARAM_QEI_INTFLAG(ulIntType));
-
-	QEIx-&gt;QEICLR = ulIntType;
-}
-
-
-/*********************************************************************//**
- * @brief		Calculates the actual velocity in RPM passed via velocity
- * 				capture value and Pulse Per Round (of the encoder) value
- * 				parameter input.
- * @param[in]	QEIx			QEI peripheral, should be QEI
- * @param[in]	ulVelCapValue	Velocity capture input value that can
- * 								be got from QEI_GetVelocityCap() function
- * @param[in]	ulPPR			Pulse per round of encoder
- * @return		The actual value of velocity in RPM (Round per minute)
- **********************************************************************/
-uint32_t QEI_CalculateRPM(QEI_TypeDef *QEIx, uint32_t ulVelCapValue, uint32_t ulPPR)
-{
-	uint64_t rpm, clock, Load, edges;
-
-	// Get current Clock rate for timer input
-	clock = (uint64_t)CLKPWR_GetPCLK(CLKPWR_PCLKSEL_QEI);
-	// Get Timer load value (velocity capture period)
-	Load  = (uint64_t)(QEIx-&gt;QEILOAD + 1);
-	// Get Edge
-	edges = (uint64_t)((QEIx-&gt;QEICONF &amp; QEI_CONF_CAPMODE) ? 4 : 2);
-	// Calculate RPM
-	rpm = ((clock * ulVelCapValue * 60) / (Load * ulPPR * edges));
-
-	return (uint32_t)(rpm);
-}
-
-
-/**
- * @}
- */
-
-#endif /* _QEI */
-
-/**
- * @}
- */
-
-/* --------------------------------- End Of File ------------------------------ */
-
+/**
+ * @file	: lpc17xx_qei.c
+ * @brief	: Contains all functions support for QEI firmware library on LPC17xx
+ * @version	: 1.0
+ * @date	: 26. May. 2009
+ * @author	: HieuNguyen
+ **************************************************************************
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * products. This software is supplied &quot;AS IS&quot; without any warranties.
+ * NXP Semiconductors assumes no responsibility or liability for the
+ * use of the software, conveys no license or title under any patent,
+ * copyright, or mask work right to the product. NXP Semiconductors
+ * reserves the right to make changes in the software without
+ * notification. NXP Semiconductors also make no representation or
+ * warranty that such application will be suitable for the specified
+ * use without further testing or modification.
+ **********************************************************************/
+
+/* Peripheral group ----------------------------------------------------------- */
+/** @addtogroup QEI
+ * @{
+ */
+
+/* Includes ------------------------------------------------------------------- */
+#include &quot;lpc17xx_qei.h&quot;
+#include &quot;lpc17xx_clkpwr.h&quot;
+
+
+/* If this source file built with example, the LPC17xx FW library configuration
+ * file in each example directory (&quot;lpc17xx_libcfg.h&quot;) must be included,
+ * otherwise the default FW library configuration file must be included instead
+ */
+#ifdef __BUILD_WITH_EXAMPLE__
+#include &quot;lpc17xx_libcfg.h&quot;
+#else
+#include &quot;lpc17xx_libcfg_default.h&quot;
+#endif /* __BUILD_WITH_EXAMPLE__ */
+
+
+#ifdef _QEI
+
+/* Private Types -------------------------------------------------------------- */
+/** @defgroup QEI_Private_Types
+ * @{
+ */
+
+/**
+ * @brief QEI configuration union type definition
+ */
+typedef union {
+	QEI_CFG_Type bmQEIConfig;
+	uint32_t ulQEIConfig;
+} QEI_CFGOPT_Type;
+
+/**
+ * @}
+ */
+
+
+/* Public Functions ----------------------------------------------------------- */
+/** @addtogroup QEI_Public_Functions
+ * @{
+ */
+
+/*********************************************************************//**
+ * @brief		Resets value for each type of QEI value, such as velocity,
+ * 				counter, position, etc..
+ * @param[in]	QEIx			QEI peripheral, should be QEI
+ * @param[in]	ulResetType		QEI Reset Type, should be one of the following:
+ * 								- QEI_RESET_POS: Reset Position Counter
+ * 								- QEI_RESET_POSOnIDX: Reset Position Counter on Index signal
+ * 								- QEI_RESET_VEL: Reset Velocity
+ * 								- QEI_RESET_IDX: Reset Index Counter
+ * @return		None
+ **********************************************************************/
+void QEI_Reset(LPC_QEI_TypeDef *QEIx, uint32_t ulResetType)
+{
+	CHECK_PARAM(PARAM_QEIx(QEIx));
+	CHECK_PARAM(PARAM_QEI_RESET(ulResetType));
+
+	QEIx-&gt;QEICON = ulResetType;
+}
+
+/*********************************************************************//**
+ * @brief		Initializes the QEI peripheral according to the specified
+*               parameters in the QEI_ConfigStruct.
+ * @param[in]	QEIx				QEI peripheral, should be QEI
+ * @param[in]	QEI_ConfigStruct	Pointer to a QEI_CFG_Type structure
+*                    that contains the configuration information for the
+*                    specified QEI peripheral
+ * @return		None
+ **********************************************************************/
+void QEI_Init(LPC_QEI_TypeDef *QEIx, QEI_CFG_Type *QEI_ConfigStruct)
+{
+
+	CHECK_PARAM(PARAM_QEIx(QEIx));
+	CHECK_PARAM(PARAM_QEI_DIRINV(QEI_ConfigStruct-&gt;DirectionInvert));
+	CHECK_PARAM(PARAM_QEI_SIGNALMODE(QEI_ConfigStruct-&gt;SignalMode));
+	CHECK_PARAM(PARAM_QEI_CAPMODE(QEI_ConfigStruct-&gt;CaptureMode));
+	CHECK_PARAM(PARAM_QEI_INVINX(QEI_ConfigStruct-&gt;InvertIndex));
+
+	/* Set up clock and power for QEI module */
+	CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCQEI, ENABLE);
+
+	/* As default, peripheral clock for QEI module
+	 * is set to FCCLK / 2 */
+	CLKPWR_SetPCLKDiv(CLKPWR_PCLKSEL_QEI, CLKPWR_PCLKSEL_CCLK_DIV_1);
+
+	// Reset all remaining value in QEI peripheral
+	QEIx-&gt;QEICON = QEI_CON_RESP | QEI_CON_RESV | QEI_CON_RESI;
+	QEIx-&gt;QEIMAXPOS = 0x00;
+	QEIx-&gt;CMPOS0 = 0x00;
+	QEIx-&gt;CMPOS1 = 0x00;
+	QEIx-&gt;CMPOS2 = 0x00;
+	QEIx-&gt;INXCMP = 0x00;
+	QEIx-&gt;QEILOAD = 0x00;
+	QEIx-&gt;VELCOMP = 0x00;
+	QEIx-&gt;FILTER = 0x00;
+	// Disable all Interrupt
+	QEIx-&gt;QEIIEC = QEI_IECLR_BITMASK;
+	// Clear all Interrupt pending
+	QEIx-&gt;QEICLR = QEI_INTCLR_BITMASK;
+	// Set QEI configuration value corresponding to its setting up value
+	QEIx-&gt;QEICONF = ((QEI_CFGOPT_Type *)QEI_ConfigStruct)-&gt;ulQEIConfig;
+}
+
+
+/*********************************************************************//**
+ * @brief		De-initializes the QEI peripheral registers to their
+*                  default reset values.
+ * @param[in]	QEIx				QEI peripheral, should be QEI
+ * @return 		None
+ **********************************************************************/
+void QEI_DeInit(LPC_QEI_TypeDef *QEIx)
+{
+	CHECK_PARAM(PARAM_QEIx(QEIx));
+
+	/* Turn off clock and power for QEI module */
+	CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCQEI, DISABLE);
+}
+
+
+/*****************************************************************************//**
+* @brief		Fills each QIE_InitStruct member with its default value:
+* 				- DirectionInvert = QEI_DIRINV_NONE
+* 				- SignalMode = QEI_SIGNALMODE_QUAD
+* 				- CaptureMode = QEI_CAPMODE_4X
+* 				- InvertIndex = QEI_INVINX_NONE
+* @param[in]	QIE_InitStruct Pointer to a QEI_CFG_Type structure
+*                    which will be initialized.
+* @return		None
+*******************************************************************************/
+void QEI_ConfigStructInit(QEI_CFG_Type *QIE_InitStruct)
+{
+	QIE_InitStruct-&gt;CaptureMode = QEI_CAPMODE_4X;
+	QIE_InitStruct-&gt;DirectionInvert = QEI_DIRINV_NONE;
+	QIE_InitStruct-&gt;InvertIndex = QEI_INVINX_NONE;
+	QIE_InitStruct-&gt;SignalMode = QEI_SIGNALMODE_QUAD;
+}
+
+
+/*********************************************************************//**
+ * @brief		Check whether if specified flag status is set or not
+ * @param[in]	QEIx		QEI peripheral, should be QEI
+ * @param[in]	ulFlagType	Status Flag Type, should be one of the following:
+ * 							- QEI_STATUS_DIR: Direction Status
+ * @return		New Status of this status flag (SET or RESET)
+ **********************************************************************/
+FlagStatus QEI_GetStatus(LPC_QEI_TypeDef *QEIx, uint32_t ulFlagType)
+{
+	CHECK_PARAM(PARAM_QEIx(QEIx));
+	CHECK_PARAM(PARAM_QEI_STATUS(ulFlagType));
+	return ((QEIx-&gt;QEISTAT &amp; ulFlagType) ? SET : RESET);
+}
+
+/*********************************************************************//**
+ * @brief		Get current position value in QEI peripheral
+ * @param[in]	QEIx		QEI peripheral, should be QEI
+ * @return		Current position value of QEI peripheral
+ **********************************************************************/
+uint32_t QEI_GetPosition(LPC_QEI_TypeDef *QEIx)
+{
+	CHECK_PARAM(PARAM_QEIx(QEIx));
+	return (QEIx-&gt;QEIPOS);
+}
+
+/*********************************************************************//**
+ * @brief		Set max position value for QEI peripheral
+ * @param[in]	QEIx		QEI peripheral, should be QEI
+ * @param[in]	ulMaxPos	Max position value to set
+ * @return		None
+ **********************************************************************/
+void QEI_SetMaxPosition(LPC_QEI_TypeDef *QEIx, uint32_t ulMaxPos)
+{
+	CHECK_PARAM(PARAM_QEIx(QEIx));
+	QEIx-&gt;QEIMAXPOS = ulMaxPos;
+}
+
+/*********************************************************************//**
+ * @brief		Set position compare value for QEI peripheral
+ * @param[in]	QEIx		QEI peripheral, should be QEI
+ * @param[in]	bPosCompCh	Compare Position channel, should be:
+ * 							- QEI_COMPPOS_CH_0: QEI compare position channel 0
+ * 							- QEI_COMPPOS_CH_1: QEI compare position channel 1
+ * 							- QEI_COMPPOS_CH_2: QEI compare position channel 2
+ * @param[in]	ulPosComp	Compare Position value to set
+ * @return		None
+ **********************************************************************/
+void QEI_SetPositionComp(LPC_QEI_TypeDef *QEIx, uint8_t bPosCompCh, uint32_t ulPosComp)
+{
+	uint32_t *tmp;
+
+	CHECK_PARAM(PARAM_QEIx(QEIx));
+	CHECK_PARAM(PARAM_QEI_COMPPOS_CH(bPosCompCh));
+	tmp = (uint32_t *) (&amp;(QEIx-&gt;CMPOS0) + bPosCompCh * 4);
+	*tmp = ulPosComp;
+
+}
+
+/*********************************************************************//**
+ * @brief		Get current index counter of QEI peripheral
+ * @param[in]	QEIx		QEI peripheral, should be QEI
+ * @return		Current value of QEI index counter
+ **********************************************************************/
+uint32_t QEI_GetIndex(LPC_QEI_TypeDef *QEIx)
+{
+	CHECK_PARAM(PARAM_QEIx(QEIx));
+	return (QEIx-&gt;INXCNT);
+}
+
+/*********************************************************************//**
+ * @brief		Set value for index compare in QEI peripheral
+ * @param[in]	QEIx		QEI peripheral, should be QEI
+ * @param[in]	ulIndexComp		Compare Index Value to set
+ * @return		None
+ **********************************************************************/
+void QEI_SetIndexComp(LPC_QEI_TypeDef *QEIx, uint32_t ulIndexComp)
+{
+	CHECK_PARAM(PARAM_QEIx(QEIx));
+	QEIx-&gt;INXCMP = ulIndexComp;
+}
+
+/*********************************************************************//**
+ * @brief		Set timer reload value for QEI peripheral. When the velocity timer is
+ * 				over-flow, the value that set for Timer Reload register will be loaded
+ * 				into the velocity timer for next period. The calculated velocity in RPM
+ * 				therefore will be affect by this value.
+ * @param[in]	QEIx			QEI peripheral, should be QEI
+ * @param[in]	QEIReloadStruct	QEI reload structure
+ * @return		None
+ **********************************************************************/
+void QEI_SetTimerReload(LPC_QEI_TypeDef *QEIx, QEI_RELOADCFG_Type *QEIReloadStruct)
+{
+	uint64_t pclk;
+
+	CHECK_PARAM(PARAM_QEIx(QEIx));
+	CHECK_PARAM(PARAM_QEI_TIMERRELOAD(QEIReloadStruct-&gt;ReloadOption));
+
+	if (QEIReloadStruct-&gt;ReloadOption == QEI_TIMERRELOAD_TICKVAL) {
+		QEIx-&gt;QEILOAD = QEIReloadStruct-&gt;ReloadValue - 1;
+	} else {
+		pclk = (uint64_t)CLKPWR_GetPCLK(CLKPWR_PCLKSEL_QEI);
+		pclk = (pclk /(1000000/QEIReloadStruct-&gt;ReloadValue)) - 1;
+		QEIx-&gt;QEILOAD = (uint32_t)pclk;
+	}
+}
+
+/*********************************************************************//**
+ * @brief		Get current timer counter in QEI peripheral
+ * @param[in]	QEIx			QEI peripheral, should be QEI
+ * @return		Current timer counter in QEI peripheral
+ **********************************************************************/
+uint32_t QEI_GetTimer(LPC_QEI_TypeDef *QEIx)
+{
+	CHECK_PARAM(PARAM_QEIx(QEIx));
+	return (QEIx-&gt;QEITIME);
+}
+
+/*********************************************************************//**
+ * @brief		Get current velocity pulse counter in current time period
+ * @param[in]	QEIx			QEI peripheral, should be QEI
+ * @return		Current velocity pulse counter value
+ **********************************************************************/
+uint32_t QEI_GetVelocity(LPC_QEI_TypeDef *QEIx)
+{
+	CHECK_PARAM(PARAM_QEIx(QEIx));
+	return (QEIx-&gt;QEIVEL);
+}
+
+/*********************************************************************//**
+ * @brief		Get the most recently measured velocity of the QEI. When
+ * 				the Velocity timer in QEI is over-flow, the current velocity
+ * 				value will be loaded into Velocity Capture register.
+ * @param[in]	QEIx			QEI peripheral, should be QEI
+ * @return		The most recently measured velocity value
+ **********************************************************************/
+uint32_t QEI_GetVelocityCap(LPC_QEI_TypeDef *QEIx)
+{
+	CHECK_PARAM(PARAM_QEIx(QEIx));
+	return (QEIx-&gt;QEICAP);
+}
+
+/*********************************************************************//**
+ * @brief		Set Velocity Compare value for QEI peripheral
+ * @param[in]	QEIx			QEI peripheral, should be QEI
+ * @param[in]	ulVelComp		Compare Velocity value to set
+ * @return		None
+ **********************************************************************/
+void QEI_SetVelocityComp(LPC_QEI_TypeDef *QEIx, uint32_t ulVelComp)
+{
+	CHECK_PARAM(PARAM_QEIx(QEIx));
+	QEIx-&gt;VELCOMP = ulVelComp;
+}
+
+/*********************************************************************//**
+ * @brief		Set value of sampling count for the digital filter in
+ * 				QEI peripheral
+ * @param[in]	QEIx			QEI peripheral, should be QEI
+ * @param[in]	ulSamplingPulse	Value of sampling count to set
+ * @return		None
+ **********************************************************************/
+void QEI_SetDigiFilter(LPC_QEI_TypeDef *QEIx, uint32_t ulSamplingPulse)
+{
+	CHECK_PARAM(PARAM_QEIx(QEIx));
+	QEIx-&gt;FILTER = ulSamplingPulse;
+}
+
+/*********************************************************************//**
+ * @brief		Check whether if specified interrupt flag status in QEI
+ * 				peripheral is set or not
+ * @param[in]	QEIx			QEI peripheral, should be QEI
+ * @param[in]	ulIntType		Interrupt Flag Status type, should be:
+								- QEI_INTFLAG_INX_Int: index pulse was detected interrupt
+								- QEI_INTFLAG_TIM_Int: Velocity timer over flow interrupt
+								- QEI_INTFLAG_VELC_Int: Capture velocity is less than compare interrupt
+								- QEI_INTFLAG_DIR_Int: Change of direction interrupt
+								- QEI_INTFLAG_ERR_Int: An encoder phase error interrupt
+								- QEI_INTFLAG_ENCLK_Int: An encoder clock pulse was detected interrupt
+								- QEI_INTFLAG_POS0_Int: position 0 compare value is equal to the
+														current position interrupt
+								- QEI_INTFLAG_POS1_Int: position 1 compare value is equal to the
+														current position interrupt
+								- QEI_INTFLAG_POS2_Int: position 2 compare value is equal to the
+														current position interrupt
+								- QEI_INTFLAG_REV_Int: Index compare value is equal to the current
+														index count interrupt
+								- QEI_INTFLAG_POS0REV_Int: Combined position 0 and revolution count interrupt
+								- QEI_INTFLAG_POS1REV_Int: Combined position 1 and revolution count interrupt
+								- QEI_INTFLAG_POS2REV_Int: Combined position 2 and revolution count interrupt
+ * @return		New State of specified interrupt flag status (SET or RESET)
+ **********************************************************************/
+FlagStatus QEI_GetIntStatus(LPC_QEI_TypeDef *QEIx, uint32_t ulIntType)
+{
+	CHECK_PARAM(PARAM_QEIx(QEIx));
+	CHECK_PARAM(PARAM_QEI_INTFLAG(ulIntType));
+
+	return((QEIx-&gt;QEIINTSTAT &amp; ulIntType) ? SET : RESET);
+}
+
+/*********************************************************************//**
+ * @brief		Enable/Disable specified interrupt in QEI peripheral
+ * @param[in]	QEIx			QEI peripheral, should be QEI
+ * @param[in]	ulIntType		Interrupt Flag Status type, should be:
+ * 								- QEI_INTFLAG_INX_Int: index pulse was detected interrupt
+ *								- QEI_INTFLAG_TIM_Int: Velocity timer over flow interrupt
+ *								- QEI_INTFLAG_VELC_Int: Capture velocity is less than compare interrupt
+ * 								- QEI_INTFLAG_DIR_Int: Change of direction interrupt
+ *  							- QEI_INTFLAG_ERR_Int: An encoder phase error interrupt
+ * 								- QEI_INTFLAG_ENCLK_Int: An encoder clock pulse was detected interrupt
+ *								- QEI_INTFLAG_POS0_Int: position 0 compare value is equal to the
+ *														current position interrupt
+ *								- QEI_INTFLAG_POS1_Int: position 1 compare value is equal to the
+ *														current position interrupt
+ *								- QEI_INTFLAG_POS2_Int: position 2 compare value is equal to the
+ *														current position interrupt
+ *								- QEI_INTFLAG_REV_Int: Index compare value is equal to the current
+ *														index count interrupt
+ *								- QEI_INTFLAG_POS0REV_Int: Combined position 0 and revolution count interrupt
+ *								- QEI_INTFLAG_POS1REV_Int: Combined position 1 and revolution count interrupt
+ *								- QEI_INTFLAG_POS2REV_Int: Combined position 2 and revolution count interrupt
+ * @param[in]	NewState		New function state, should be:
+ *								- DISABLE
+ *								- ENABLE
+ * @return		None
+ **********************************************************************/
+void QEI_IntCmd(LPC_QEI_TypeDef *QEIx, uint32_t ulIntType, FunctionalState NewState)
+{
+	CHECK_PARAM(PARAM_QEIx(QEIx));
+	CHECK_PARAM(PARAM_QEI_INTFLAG(ulIntType));
+	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
+
+	if (NewState == ENABLE) {
+		QEIx-&gt;QEIIES = ulIntType;
+	} else {
+		QEIx-&gt;QEIIEC = ulIntType;
+	}
+}
+
+
+/*********************************************************************//**
+ * @brief		Sets (forces) specified interrupt in QEI peripheral
+ * @param[in]	QEIx			QEI peripheral, should be QEI
+ * @param[in]	ulIntType		Interrupt Flag Status type, should be:
+								- QEI_INTFLAG_INX_Int: index pulse was detected interrupt
+								- QEI_INTFLAG_TIM_Int: Velocity timer over flow interrupt
+								- QEI_INTFLAG_VELC_Int: Capture velocity is less than compare interrupt
+								- QEI_INTFLAG_DIR_Int: Change of direction interrupt
+								- QEI_INTFLAG_ERR_Int: An encoder phase error interrupt
+								- QEI_INTFLAG_ENCLK_Int: An encoder clock pulse was detected interrupt
+								- QEI_INTFLAG_POS0_Int: position 0 compare value is equal to the
+														current position interrupt
+								- QEI_INTFLAG_POS1_Int: position 1 compare value is equal to the
+														current position interrupt
+								- QEI_INTFLAG_POS2_Int: position 2 compare value is equal to the
+														current position interrupt
+								- QEI_INTFLAG_REV_Int: Index compare value is equal to the current
+														index count interrupt
+								- QEI_INTFLAG_POS0REV_Int: Combined position 0 and revolution count interrupt
+								- QEI_INTFLAG_POS1REV_Int: Combined position 1 and revolution count interrupt
+								- QEI_INTFLAG_POS2REV_Int: Combined position 2 and revolution count interrupt
+ * @return		None
+ **********************************************************************/
+void QEI_IntSet(LPC_QEI_TypeDef *QEIx, uint32_t ulIntType)
+{
+	CHECK_PARAM(PARAM_QEIx(QEIx));
+	CHECK_PARAM(PARAM_QEI_INTFLAG(ulIntType));
+
+	QEIx-&gt;QEISET = ulIntType;
+}
+
+/*********************************************************************//**
+ * @brief		Clear (force) specified interrupt (pending) in QEI peripheral
+ * @param[in]	QEIx			QEI peripheral, should be QEI
+ * @param[in]	ulIntType		Interrupt Flag Status type, should be:
+								- QEI_INTFLAG_INX_Int: index pulse was detected interrupt
+								- QEI_INTFLAG_TIM_Int: Velocity timer over flow interrupt
+								- QEI_INTFLAG_VELC_Int: Capture velocity is less than compare interrupt
+								- QEI_INTFLAG_DIR_Int: Change of direction interrupt
+								- QEI_INTFLAG_ERR_Int: An encoder phase error interrupt
+								- QEI_INTFLAG_ENCLK_Int: An encoder clock pulse was detected interrupt
+								- QEI_INTFLAG_POS0_Int: position 0 compare value is equal to the
+														current position interrupt
+								- QEI_INTFLAG_POS1_Int: position 1 compare value is equal to the
+														current position interrupt
+								- QEI_INTFLAG_POS2_Int: position 2 compare value is equal to the
+														current position interrupt
+								- QEI_INTFLAG_REV_Int: Index compare value is equal to the current
+														index count interrupt
+								- QEI_INTFLAG_POS0REV_Int: Combined position 0 and revolution count interrupt
+								- QEI_INTFLAG_POS1REV_Int: Combined position 1 and revolution count interrupt
+								- QEI_INTFLAG_POS2REV_Int: Combined position 2 and revolution count interrupt
+ * @return		None
+ **********************************************************************/
+void QEI_IntClear(LPC_QEI_TypeDef *QEIx, uint32_t ulIntType)
+{
+	CHECK_PARAM(PARAM_QEIx(QEIx));
+	CHECK_PARAM(PARAM_QEI_INTFLAG(ulIntType));
+
+	QEIx-&gt;QEICLR = ulIntType;
+}
+
+
+/*********************************************************************//**
+ * @brief		Calculates the actual velocity in RPM passed via velocity
+ * 				capture value and Pulse Per Round (of the encoder) value
+ * 				parameter input.
+ * @param[in]	QEIx			QEI peripheral, should be QEI
+ * @param[in]	ulVelCapValue	Velocity capture input value that can
+ * 								be got from QEI_GetVelocityCap() function
+ * @param[in]	ulPPR			Pulse per round of encoder
+ * @return		The actual value of velocity in RPM (Round per minute)
+ **********************************************************************/
+uint32_t QEI_CalculateRPM(LPC_QEI_TypeDef *QEIx, uint32_t ulVelCapValue, uint32_t ulPPR)
+{
+	uint64_t rpm, clock, Load, edges;
+
+	// Get current Clock rate for timer input
+	clock = (uint64_t)CLKPWR_GetPCLK(CLKPWR_PCLKSEL_QEI);
+	// Get Timer load value (velocity capture period)
+	Load  = (uint64_t)(QEIx-&gt;QEILOAD + 1);
+	// Get Edge
+	edges = (uint64_t)((QEIx-&gt;QEICONF &amp; QEI_CONF_CAPMODE) ? 4 : 2);
+	// Calculate RPM
+	rpm = ((clock * ulVelCapValue * 60) / (Load * ulPPR * edges));
+
+	return (uint32_t)(rpm);
+}
+
+
+/**
+ * @}
+ */
+
+#endif /* _QEI */
+
+/**
+ * @}
+ */
+
+/* --------------------------------- End Of File ------------------------------ */
+


Property changes on: trunk/src/platform/lpc17xx/drivers/src/lpc17xx_qei.c
___________________________________________________________________
Deleted: svn:executable
   - *

Modified: trunk/src/platform/lpc17xx/drivers/src/lpc17xx_rit.c
===================================================================
--- trunk/src/platform/lpc17xx/drivers/src/lpc17xx_rit.c	2010-06-28 21:53:59 UTC (rev 759)
+++ trunk/src/platform/lpc17xx/drivers/src/lpc17xx_rit.c	2010-07-12 20:56:54 UTC (rev 760)
@@ -1,195 +1,195 @@
-/**
- * @file	: lpc17xx_rit.c
- * @brief	: Contains all functions support for RIT firmware library on LPC17xx
- * @version	: 1.0
- * @date	: 7. May. 2009
- * @author	: NguyenCao
- *----------------------------------------------------------------------------
- * Software that is described herein is for illustrative purposes only
- * which provides customers with programming information regarding the
- * products. This software is supplied &quot;AS IS&quot; without any warranties.
- * NXP Semiconductors assumes no responsibility or liability for the
- * use of the software, conveys no license or title under any patent,
- * copyright, or mask work right to the product. NXP Semiconductors
- * reserves the right to make changes in the software without
- * notification. NXP Semiconductors also make no representation or
- * warranty that such application will be suitable for the specified
- * use without further testing or modification.
- **********************************************************************/
-
-/* Peripheral group ----------------------------------------------------------- */
-/** @addtogroup RIT
- * @{
- */
-
-/* Includes ------------------------------------------------------------------- */
-#include &quot;lpc17xx_rit.h&quot;
-#include &quot;lpc17xx_clkpwr.h&quot;
-
-/* If this source file built with example, the LPC17xx FW library configuration
- * file in each example directory (&quot;lpc17xx_libcfg.h&quot;) must be included,
- * otherwise the default FW library configuration file must be included instead
- */
-#ifdef __BUILD_WITH_EXAMPLE__
-#include &quot;lpc17xx_libcfg.h&quot;
-#else
-#include &quot;lpc17xx_libcfg_default.h&quot;
-#endif /* __BUILD_WITH_EXAMPLE__ */
-
-#ifdef _RIT
-
-/* Public Functions ----------------------------------------------------------- */
-/** @addtogroup RIT_Public_Functions
- * @{
- */
-
-/******************************************************************************//*
- * @brief 		Initial for RIT
- * 					- Turn on power and clock
- * 					- Setup default register values
- * @param[in]	RITx is RIT peripheral selected, should be: RIT
- * @return 		None
- *******************************************************************************/
-void RIT_Init(RIT_TypeDef *RITx)
-{
-	CHECK_PARAM(PARAM_RITx(RITx));
-	CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCRIT, ENABLE);
-	//Set up default register values
-	RITx-&gt;RICOMPVAL = 0xFFFFFFFF;
-	RITx-&gt;RIMASK	= 0x00000000;
-	RITx-&gt;RICTRL	= 0x0C;
-	RITx-&gt;RICOUNTER	= 0x00000000;
-	// Turn on power and clock
-
-}
-/******************************************************************************//*
- * @brief 		DeInitial for RIT
- * 					- Turn off power and clock
- * 					- ReSetup default register values
- * @param[in]	RITx is RIT peripheral selected, should be: RIT
- * @return 		None
- *******************************************************************************/
-void RIT_DeInit(RIT_TypeDef *RITx)
-{
-	CHECK_PARAM(PARAM_RITx(RITx));
-
-	// Turn off power and clock
-	CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCRIT, DISABLE);
-	//ReSetup default register values
-	RITx-&gt;RICOMPVAL = 0xFFFFFFFF;
-	RITx-&gt;RIMASK	= 0x00000000;
-	RITx-&gt;RICTRL	= 0x0C;
-	RITx-&gt;RICOUNTER	= 0x00000000;
-}
-/******************************************************************************//*
- * @brief 		Set compare value, mask value and time counter value
- * @param[in]	RITx is RIT peripheral selected, should be: RIT
- * @param[in]	value: pointer to RIT_CMP_VAL Structure
- * @return 		None
- *******************************************************************************/
-void RIT_TimerConfig(RIT_TypeDef *RITx, RIT_CMP_VAL *value)
-{
-	CHECK_PARAM(PARAM_RITx(RITx));
-
-	RITx-&gt;RICOMPVAL	= value-&gt;CMPVAL;
-	RITx-&gt;RIMASK	= value-&gt;MASKVAL;
-	RITx-&gt;RICOUNTER	= value-&gt;COUNTVAL;
-}
-/******************************************************************************//*
- * @brief 		Enable/Disable Timer
- * @param[in]	RITx is RIT peripheral selected, should be: RIT
- * @param[in]	NewState 	New State of this function
- * 					-ENABLE: Enable Timer
- * 					-DISABLE: Disable Timer
- * @return 		None
- *******************************************************************************/
-void RIT_Cmd(RIT_TypeDef *RITx, FunctionalState NewState)
-{
-	CHECK_PARAM(PARAM_RITx(RITx));
-	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
-
-	//Enable or Disable Timer
-	if(NewState==ENABLE)
-	{
-		RITx-&gt;RICTRL |= RIT_CTRL_TEN;
-	}
-	else
-	{
-		RITx-&gt;RICTRL &amp;= ~RIT_CTRL_TEN;
-	}
-}
-/******************************************************************************//*
- * @brief 		Timer Enable/Disable Clear
- * @param[in]	RITx is RIT peripheral selected, should be: RIT
- * @param[in]	NewState 	New State of this function
- * 						-ENABLE: The timer will be cleared to 0 whenever
- * 				the counter value equals the masked compare value specified
- * 				by the contents of RICOMPVAL and RIMASK register
- * 						-DISABLE: The timer will not be clear to 0
- * @return 		None
- *******************************************************************************/
-void RIT_TimerClearCmd(RIT_TypeDef *RITx, FunctionalState NewState)
-{
-	CHECK_PARAM(PARAM_RITx(RITx));
-	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
-
-	//Timer Enable/Disable Clear
-	if(NewState==ENABLE)
-	{
-		RITx-&gt;RICTRL |= RIT_CTRL_ENCLR;
-	}
-	else
-	{
-		RITx-&gt;RICTRL &amp;= ~RIT_CTRL_ENCLR;
-	}
-}
-/******************************************************************************//*
- * @brief 		Timer Enable/Disable on break
- * @param[in]	RITx is RIT peripheral selected, should be: RIT
- * @param[in]	NewState 	New State of this function
- * 					-ENABLE: The timer is halted whenever a hardware break condition occurs
- * 					-DISABLE: Hardware break has no effect on the timer operation
- * @return 		None
- *******************************************************************************/
-void RIT_TimerEnableOnBreakCmd(RIT_TypeDef *RITx, FunctionalState NewState)
-{
-	CHECK_PARAM(PARAM_RITx(RITx));
-	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
-
-	//Timer Enable/Disable on break
-	if(NewState==ENABLE)
-	{
-		RITx-&gt;RICTRL |= RIT_CTRL_ENBR;
-	}
-	else
-	{
-		RITx-&gt;RICTRL &amp;= ~RIT_CTRL_ENBR;
-	}
-}
-/******************************************************************************//*
- * @brief 		Check whether interrupt flag is set or not
- * @param[in]	RITx is RIT peripheral selected, should be: RIT
- * @return 		Current interrupt status, could be: SET/RESET
- *******************************************************************************/
-IntStatus RIT_GetIntStatus(RIT_TypeDef *RITx)
-{
-	uint8_t result;
-	CHECK_PARAM(PARAM_RITx(RITx));
-	if((RITx-&gt;RICTRL&amp;RIT_CTRL_INTEN)==1)	result= SET;
-	else return RESET;
-	//clear interrupt flag
-	RITx-&gt;RICTRL |= RIT_CTRL_INTEN;
-	return result;
-}
-
-/**
- * @}
- */
-
-#endif /* _RIT */
-
-/**
- * @}
- */
-
-/* --------------------------------- End Of File ------------------------------ */
+/**
+ * @file	: lpc17xx_rit.c
+ * @brief	: Contains all functions support for RIT firmware library on LPC17xx
+ * @version	: 1.0
+ * @date	: 7. May. 2009
+ * @author	: NguyenCao
+ **************************************************************************
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * products. This software is supplied &quot;AS IS&quot; without any warranties.
+ * NXP Semiconductors assumes no responsibility or liability for the
+ * use of the software, conveys no license or title under any patent,
+ * copyright, or mask work right to the product. NXP Semiconductors
+ * reserves the right to make changes in the software without
+ * notification. NXP Semiconductors also make no representation or
+ * warranty that such application will be suitable for the specified
+ * use without further testing or modification.
+ **********************************************************************/
+
+/* Peripheral group ----------------------------------------------------------- */
+/** @addtogroup RIT
+ * @{
+ */
+
+/* Includes ------------------------------------------------------------------- */
+#include &quot;lpc17xx_rit.h&quot;
+#include &quot;lpc17xx_clkpwr.h&quot;
+
+/* If this source file built with example, the LPC17xx FW library configuration
+ * file in each example directory (&quot;lpc17xx_libcfg.h&quot;) must be included,
+ * otherwise the default FW library configuration file must be included instead
+ */
+#ifdef __BUILD_WITH_EXAMPLE__
+#include &quot;lpc17xx_libcfg.h&quot;
+#else
+#include &quot;lpc17xx_libcfg_default.h&quot;
+#endif /* __BUILD_WITH_EXAMPLE__ */
+
+#ifdef _RIT
+
+/* Public Functions ----------------------------------------------------------- */
+/** @addtogroup RIT_Public_Functions
+ * @{
+ */
+
+/******************************************************************************//*
+ * @brief 		Initial for RIT
+ * 					- Turn on power and clock
+ * 					- Setup default register values
+ * @param[in]	RITx is RIT peripheral selected, should be: RIT
+ * @return 		None
+ *******************************************************************************/
+void RIT_Init(LPC_RIT_TypeDef *RITx)
+{
+	CHECK_PARAM(PARAM_RITx(RITx));
+	CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCRIT, ENABLE);
+	//Set up default register values
+	RITx-&gt;RICOMPVAL = 0xFFFFFFFF;
+	RITx-&gt;RIMASK	= 0x00000000;
+	RITx-&gt;RICTRL	= 0x0C;
+	RITx-&gt;RICOUNTER	= 0x00000000;
+	// Turn on power and clock
+
+}
+/******************************************************************************//*
+ * @brief 		DeInitial for RIT
+ * 					- Turn off power and clock
+ * 					- ReSetup default register values
+ * @param[in]	RITx is RIT peripheral selected, should be: RIT
+ * @return 		None
+ *******************************************************************************/
+void RIT_DeInit(LPC_RIT_TypeDef *RITx)
+{
+	CHECK_PARAM(PARAM_RITx(RITx));
+
+	// Turn off power and clock
+	CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCRIT, DISABLE);
+	//ReSetup default register values
+	RITx-&gt;RICOMPVAL = 0xFFFFFFFF;
+	RITx-&gt;RIMASK	= 0x00000000;
+	RITx-&gt;RICTRL	= 0x0C;
+	RITx-&gt;RICOUNTER	= 0x00000000;
+}
+/******************************************************************************//*
+ * @brief 		Set compare value, mask value and time counter value
+ * @param[in]	RITx is RIT peripheral selected, should be: RIT
+ * @param[in]	value: pointer to RIT_CMP_VAL Structure
+ * @return 		None
+ *******************************************************************************/
+void RIT_TimerConfig(LPC_RIT_TypeDef *RITx, RIT_CMP_VAL *value)
+{
+	CHECK_PARAM(PARAM_RITx(RITx));
+
+	RITx-&gt;RICOMPVAL	= value-&gt;CMPVAL;
+	RITx-&gt;RIMASK	= value-&gt;MASKVAL;
+	RITx-&gt;RICOUNTER	= value-&gt;COUNTVAL;
+}
+/******************************************************************************//*
+ * @brief 		Enable/Disable Timer
+ * @param[in]	RITx is RIT peripheral selected, should be: RIT
+ * @param[in]	NewState 	New State of this function
+ * 					-ENABLE: Enable Timer
+ * 					-DISABLE: Disable Timer
+ * @return 		None
+ *******************************************************************************/
+void RIT_Cmd(LPC_RIT_TypeDef *RITx, FunctionalState NewState)
+{
+	CHECK_PARAM(PARAM_RITx(RITx));
+	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
+
+	//Enable or Disable Timer
+	if(NewState==ENABLE)
+	{
+		RITx-&gt;RICTRL |= RIT_CTRL_TEN;
+	}
+	else
+	{
+		RITx-&gt;RICTRL &amp;= ~RIT_CTRL_TEN;
+	}
+}
+/******************************************************************************//*
+ * @brief 		Timer Enable/Disable Clear
+ * @param[in]	RITx is RIT peripheral selected, should be: RIT
+ * @param[in]	NewState 	New State of this function
+ * 						-ENABLE: The timer will be cleared to 0 whenever
+ * 				the counter value equals the masked compare value specified
+ * 				by the contents of RICOMPVAL and RIMASK register
+ * 						-DISABLE: The timer will not be clear to 0
+ * @return 		None
+ *******************************************************************************/
+void RIT_TimerClearCmd(LPC_RIT_TypeDef *RITx, FunctionalState NewState)
+{
+	CHECK_PARAM(PARAM_RITx(RITx));
+	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
+
+	//Timer Enable/Disable Clear
+	if(NewState==ENABLE)
+	{
+		RITx-&gt;RICTRL |= RIT_CTRL_ENCLR;
+	}
+	else
+	{
+		RITx-&gt;RICTRL &amp;= ~RIT_CTRL_ENCLR;
+	}
+}
+/******************************************************************************//*
+ * @brief 		Timer Enable/Disable on break
+ * @param[in]	RITx is RIT peripheral selected, should be: RIT
+ * @param[in]	NewState 	New State of this function
+ * 					-ENABLE: The timer is halted whenever a hardware break condition occurs
+ * 					-DISABLE: Hardware break has no effect on the timer operation
+ * @return 		None
+ *******************************************************************************/
+void RIT_TimerEnableOnBreakCmd(LPC_RIT_TypeDef *RITx, FunctionalState NewState)
+{
+	CHECK_PARAM(PARAM_RITx(RITx));
+	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
+
+	//Timer Enable/Disable on break
+	if(NewState==ENABLE)
+	{
+		RITx-&gt;RICTRL |= RIT_CTRL_ENBR;
+	}
+	else
+	{
+		RITx-&gt;RICTRL &amp;= ~RIT_CTRL_ENBR;
+	}
+}
+/******************************************************************************//*
+ * @brief 		Check whether interrupt flag is set or not
+ * @param[in]	RITx is RIT peripheral selected, should be: RIT
+ * @return 		Current interrupt status, could be: SET/RESET
+ *******************************************************************************/
+IntStatus RIT_GetIntStatus(LPC_RIT_TypeDef *RITx)
+{
+	uint8_t result;
+	CHECK_PARAM(PARAM_RITx(RITx));
+	if((RITx-&gt;RICTRL&amp;RIT_CTRL_INTEN)==1)	result= SET;
+	else return RESET;
+	//clear interrupt flag
+	RITx-&gt;RICTRL |= RIT_CTRL_INTEN;
+	return result;
+}
+
+/**
+ * @}
+ */
+
+#endif /* _RIT */
+
+/**
+ * @}
+ */
+
+/* --------------------------------- End Of File ------------------------------ */


Property changes on: trunk/src/platform/lpc17xx/drivers/src/lpc17xx_rit.c
___________________________________________________________________
Deleted: svn:executable
   - *

Modified: trunk/src/platform/lpc17xx/drivers/src/lpc17xx_rtc.c
===================================================================
--- trunk/src/platform/lpc17xx/drivers/src/lpc17xx_rtc.c	2010-06-28 21:53:59 UTC (rev 759)
+++ trunk/src/platform/lpc17xx/drivers/src/lpc17xx_rtc.c	2010-07-12 20:56:54 UTC (rev 760)
@@ -1,789 +1,789 @@
-/**
- * @file	: lpc17xx_rtc.c
- * @brief	: Contains all functions support for RTC firmware library on LPC17xx
- * @version	: 1.0
- * @date	: 23. Apr. 2009
- * @author	: HieuNguyen
- *----------------------------------------------------------------------------
- * Software that is described herein is for illustrative purposes only
- * which provides customers with programming information regarding the
- * products. This software is supplied &quot;AS IS&quot; without any warranties.
- * NXP Semiconductors assumes no responsibility or liability for the
- * use of the software, conveys no license or title under any patent,
- * copyright, or mask work right to the product. NXP Semiconductors
- * reserves the right to make changes in the software without
- * notification. NXP Semiconductors also make no representation or
- * warranty that such application will be suitable for the specified
- * use without further testing or modification.
- **********************************************************************/
-
-
-/* Peripheral group ----------------------------------------------------------- */
-/** @addtogroup RTC
- * @{
- */
-
-/* Includes ------------------------------------------------------------------- */
-#include &quot;lpc17xx_rtc.h&quot;
-#include &quot;lpc17xx_clkpwr.h&quot;
-
-
-/* If this source file built with example, the LPC17xx FW library configuration
- * file in each example directory (&quot;lpc17xx_libcfg.h&quot;) must be included,
- * otherwise the default FW library configuration file must be included instead
- */
-#ifdef __BUILD_WITH_EXAMPLE__
-#include &quot;lpc17xx_libcfg.h&quot;
-#else
-#include &quot;lpc17xx_libcfg_default.h&quot;
-#endif /* __BUILD_WITH_EXAMPLE__ */
-
-
-#ifdef _RTC
-
-/* Public Functions ----------------------------------------------------------- */
-/** @addtogroup RTC_Public_Functions
- * @{
- */
-
-/********************************************************************//**
- * @brief		Initializes the RTC peripheral.
- * @param[in]	RTCx	RTC peripheral selected, should be RTC
- * @return 		None
- *********************************************************************/
-void RTC_Init (RTC_TypeDef *RTCx)
-{
-	CHECK_PARAM(PARAM_RTCx(RTCx));
-
-	/* Set up clock and power for RTC module */
-	CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCRTC, ENABLE);
-
-	// Clear all register to be default
-	RTCx-&gt;ILR = 0x00;
-	RTCx-&gt;CCR = 0x00;
-	RTCx-&gt;CIIR = 0x00;
-	RTCx-&gt;AMR = 0xFF;
-	RTCx-&gt;CALIBRATION = 0x00;
-}
-
-
-/*********************************************************************//**
- * @brief		De-initializes the RTC peripheral registers to their
-*                  default reset values.
- * @param[in]	RTCx	RTC peripheral selected, should be RTC
- * @return 		None
- **********************************************************************/
-void RTC_DeInit(RTC_TypeDef *RTCx)
-{
-	CHECK_PARAM(PARAM_RTCx(RTCx));
-
-	RTCx-&gt;CCR = 0x00;
-	// Disable power and clock for RTC module
-	CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCRTC, DISABLE);
-}
-
-/*********************************************************************//**
- * @brief 		Reset clock tick counter in RTC peripheral
- * @param[in]	RTCx	RTC peripheral selected, should be RTC
- * @return 		None
- **********************************************************************/
-void RTC_ResetClockTickCounter(RTC_TypeDef *RTCx)
-{
-	CHECK_PARAM(PARAM_RTCx(RTCx));
-
-	RTCx-&gt;CCR |= RTC_CCR_CTCRST;
-	RTCx-&gt;CCR &amp;= (~RTC_CCR_CTCRST) &amp; RTC_CCR_BITMASK;
-}
-
-/*********************************************************************//**
- * @brief 		Start/Stop RTC peripheral
- * @param[in]	RTCx	RTC peripheral selected, should be RTC
- * @param[in]	NewState New State of this function, should be:
- * 				- ENABLE: The time counters are enabled
- * 				- DISABLE: The time counters are disabled
- * @return 		None
- **********************************************************************/
-void RTC_Cmd (RTC_TypeDef *RTCx, FunctionalState NewState)
-{
-	CHECK_PARAM(PARAM_RTCx(RTCx));
-	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
-
-	if (NewState == ENABLE)
-	{
-		RTCx-&gt;CCR |= RTC_CCR_CLKEN;
-	}
-	else
-	{
-		RTCx-&gt;CCR &amp;= (~RTC_CCR_CLKEN) &amp; RTC_CCR_BITMASK;
-	}
-}
-
-
-/*********************************************************************//**
- * @brief 		Enable/Disable Counter increment interrupt for each time type
- * 				in RTC peripheral
- * @param[in]	RTCx	RTC peripheral selected, should be RTC
- * @param[in]	CntIncrIntType: Counter Increment Interrupt type,
- * 				an increment of this type value below will generates
- * 				an interrupt, should be:
- * 				- RTC_TIMETYPE_SECOND
- * 				- RTC_TIMETYPE_MINUTE
- * 				- RTC_TIMETYPE_HOUR
- * 				- RTC_TIMETYPE_DAYOFWEEK
- * 				- RTC_TIMETYPE_DAYOFMONTH
- * 				- RTC_TIMETYPE_DAYOFYEAR
- * 				- RTC_TIMETYPE_MONTH
- * 				- RTC_TIMETYPE_YEAR
- * @param[in]	NewState New State of this function, should be:
- * 				- ENABLE: Counter Increment interrupt for this
- * 					time type are enabled
- * 				- DISABLE: Counter Increment interrupt for this
- * 					time type are disabled
- * @return 		None
- **********************************************************************/
-void RTC_CntIncrIntConfig (RTC_TypeDef *RTCx, uint32_t CntIncrIntType, \
-								FunctionalState NewState)
-{
-	CHECK_PARAM(PARAM_RTCx(RTCx));
-	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
-	CHECK_PARAM(PARAM_RTC_TIMETYPE(CntIncrIntType));
-
-	if (NewState ==  ENABLE)
-	{
-		switch (CntIncrIntType)
-		{
-		case RTC_TIMETYPE_SECOND:
-			RTCx-&gt;CIIR |= RTC_CIIR_IMSEC;
-			break;
-		case RTC_TIMETYPE_MINUTE:
-			RTCx-&gt;CIIR |= RTC_CIIR_IMMIN;
-			break;
-		case RTC_TIMETYPE_HOUR:
-			RTCx-&gt;CIIR |= RTC_CIIR_IMHOUR;
-			break;
-		case RTC_TIMETYPE_DAYOFWEEK:
-			RTCx-&gt;CIIR |= RTC_CIIR_IMDOW;
-			break;
-		case RTC_TIMETYPE_DAYOFMONTH:
-			RTCx-&gt;CIIR |= RTC_CIIR_IMDOM;
-			break;
-		case RTC_TIMETYPE_DAYOFYEAR:
-			RTCx-&gt;CIIR |= RTC_CIIR_IMDOY;
-			break;
-		case RTC_TIMETYPE_MONTH:
-			RTCx-&gt;CIIR |= RTC_CIIR_IMMON;
-			break;
-		case RTC_TIMETYPE_YEAR:
-			RTCx-&gt;CIIR |= RTC_CIIR_IMYEAR;
-			break;
-		}
-	}
-	else
-	{
-		switch (CntIncrIntType)
-		{
-		case RTC_TIMETYPE_SECOND:
-			RTCx-&gt;CIIR &amp;= (~RTC_CIIR_IMSEC) &amp; RTC_CIIR_BITMASK;
-			break;
-		case RTC_TIMETYPE_MINUTE:
-			RTCx-&gt;CIIR &amp;= (~RTC_CIIR_IMMIN) &amp; RTC_CIIR_BITMASK;
-			break;
-		case RTC_TIMETYPE_HOUR:
-			RTCx-&gt;CIIR &amp;= (~RTC_CIIR_IMHOUR) &amp; RTC_CIIR_BITMASK;
-			break;
-		case RTC_TIMETYPE_DAYOFWEEK:
-			RTCx-&gt;CIIR &amp;= (~RTC_CIIR_IMDOW) &amp; RTC_CIIR_BITMASK;
-			break;
-		case RTC_TIMETYPE_DAYOFMONTH:
-			RTCx-&gt;CIIR &amp;= (~RTC_CIIR_IMDOM) &amp; RTC_CIIR_BITMASK;
-			break;
-		case RTC_TIMETYPE_DAYOFYEAR:
-			RTCx-&gt;CIIR &amp;= (~RTC_CIIR_IMDOY) &amp; RTC_CIIR_BITMASK;
-			break;
-		case RTC_TIMETYPE_MONTH:
-			RTCx-&gt;CIIR &amp;= (~RTC_CIIR_IMMON) &amp; RTC_CIIR_BITMASK;
-			break;
-		case RTC_TIMETYPE_YEAR:
-			RTCx-&gt;CIIR &amp;= (~RTC_CIIR_IMYEAR) &amp; RTC_CIIR_BITMASK;
-			break;
-		}
-	}
-}
-
-
-/*********************************************************************//**
- * @brief 		Enable/Disable Alarm interrupt for each time type
- * 				in RTC peripheral
- * @param[in]	RTCx	RTC peripheral selected, should be RTC
- * @param[in]	AlarmTimeType: Alarm Time Interrupt type,
- * 				an matching of this type value below with current time
- * 				in RTC will generates an interrupt, should be:
- * 				- RTC_TIMETYPE_SECOND
- * 				- RTC_TIMETYPE_MINUTE
- * 				- RTC_TIMETYPE_HOUR
- * 				- RTC_TIMETYPE_DAYOFWEEK
- * 				- RTC_TIMETYPE_DAYOFMONTH
- * 				- RTC_TIMETYPE_DAYOFYEAR
- * 				- RTC_TIMETYPE_MONTH
- * 				- RTC_TIMETYPE_YEAR
- * @param[in]	NewState New State of this function, should be:
- * 				- ENABLE: Alarm interrupt for this
- * 					time type are enabled
- * 				- DISABLE: Alarm interrupt for this
- * 					time type are disabled
- * @return 		None
- **********************************************************************/
-void RTC_AlarmIntConfig (RTC_TypeDef *RTCx, uint32_t AlarmTimeType, \
-								FunctionalState NewState)
-{
-	CHECK_PARAM(PARAM_RTCx(RTCx));
-	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
-	CHECK_PARAM(PARAM_RTC_TIMETYPE(AlarmTimeType));
-
-	if (NewState == ENABLE)
-	{
-		switch (AlarmTimeType)
-		{
-		case RTC_TIMETYPE_SECOND:
-			RTCx-&gt;AMR &amp;= (~RTC_AMR_AMRSEC) &amp; RTC_AMR_BITMASK;
-			break;
-		case RTC_TIMETYPE_MINUTE:
-			RTCx-&gt;AMR &amp;= (~RTC_AMR_AMRMIN) &amp; RTC_AMR_BITMASK;
-			break;
-		case RTC_TIMETYPE_HOUR:
-			RTCx-&gt;AMR &amp;= (~RTC_AMR_AMRHOUR) &amp; RTC_AMR_BITMASK;
-			break;
-		case RTC_TIMETYPE_DAYOFWEEK:
-			RTCx-&gt;AMR &amp;= (~RTC_AMR_AMRDOW) &amp; RTC_AMR_BITMASK;
-			break;
-		case RTC_TIMETYPE_DAYOFMONTH:
-			RTCx-&gt;AMR &amp;= (~RTC_AMR_AMRDOM) &amp; RTC_AMR_BITMASK;
-			break;
-		case RTC_TIMETYPE_DAYOFYEAR:
-			RTCx-&gt;AMR &amp;= (~RTC_AMR_AMRDOY) &amp; RTC_AMR_BITMASK;
-			break;
-		case RTC_TIMETYPE_MONTH:
-			RTCx-&gt;AMR &amp;= (~RTC_AMR_AMRMON) &amp; RTC_AMR_BITMASK;
-			break;
-		case RTC_TIMETYPE_YEAR:
-			RTCx-&gt;AMR &amp;= (~RTC_AMR_AMRYEAR) &amp; RTC_AMR_BITMASK;
-			break;
-		}
-	}
-	else
-	{
-		switch (AlarmTimeType)
-		{
-		case RTC_TIMETYPE_SECOND:
-			RTCx-&gt;AMR |= (RTC_AMR_AMRSEC);
-			break;
-		case RTC_TIMETYPE_MINUTE:
-			RTCx-&gt;AMR |= (RTC_AMR_AMRMIN);
-			break;
-		case RTC_TIMETYPE_HOUR:
-			RTCx-&gt;AMR |= (RTC_AMR_AMRHOUR);
-			break;
-		case RTC_TIMETYPE_DAYOFWEEK:
-			RTCx-&gt;AMR |= (RTC_AMR_AMRDOW);
-			break;
-		case RTC_TIMETYPE_DAYOFMONTH:
-			RTCx-&gt;AMR |= (RTC_AMR_AMRDOM);
-			break;
-		case RTC_TIMETYPE_DAYOFYEAR:
-			RTCx-&gt;AMR |= (RTC_AMR_AMRDOY);
-			break;
-		case RTC_TIMETYPE_MONTH:
-			RTCx-&gt;AMR |= (RTC_AMR_AMRMON);
-			break;
-		case RTC_TIMETYPE_YEAR:
-			RTCx-&gt;AMR |= (RTC_AMR_AMRYEAR);
-			break;
-		}
-	}
-}
-
-
-/*********************************************************************//**
- * @brief 		Set current time value for each time type in RTC peripheral
- * @param[in]	RTCx	RTC peripheral selected, should be RTC
- * @param[in]	Timetype: Time Type, should be:
- * 				- RTC_TIMETYPE_SECOND
- * 				- RTC_TIMETYPE_MINUTE
- * 				- RTC_TIMETYPE_HOUR
- * 				- RTC_TIMETYPE_DAYOFWEEK
- * 				- RTC_TIMETYPE_DAYOFMONTH
- * 				- RTC_TIMETYPE_DAYOFYEAR
- * 				- RTC_TIMETYPE_MONTH
- * 				- RTC_TIMETYPE_YEAR
- * @param[in]	TimeValue Time value to set
- * @return 		None
- **********************************************************************/
-void RTC_SetTime (RTC_TypeDef *RTCx, uint32_t Timetype, uint32_t TimeValue)
-{
-	CHECK_PARAM(PARAM_RTCx(RTCx));
-	CHECK_PARAM(PARAM_RTC_TIMETYPE(Timetype));
-
-	switch ( Timetype)
-	{
-	case RTC_TIMETYPE_SECOND:
-		CHECK_PARAM(TimeValue &lt; RTC_SECOND_MAX);
-
-		RTCx-&gt;SEC = TimeValue &amp; RTC_SEC_MASK;
-		break;
-
-	case RTC_TIMETYPE_MINUTE:
-		CHECK_PARAM(TimeValue &lt; RTC_MINUTE_MAX);
-
-		RTCx-&gt;MIN = TimeValue &amp; RTC_MIN_MASK;
-		break;
-
-	case RTC_TIMETYPE_HOUR:
-		CHECK_PARAM(TimeValue &lt; RTC_HOUR_MAX);
-
-		RTCx-&gt;HOUR = TimeValue &amp; RTC_HOUR_MASK;
-		break;
-
-	case RTC_TIMETYPE_DAYOFWEEK:
-		CHECK_PARAM(TimeValue &lt; RTC_DAYOFWEEK_MAX);
-
-		RTCx-&gt;DOW = TimeValue &amp; RTC_DOW_MASK;
-		break;
-
-	case RTC_TIMETYPE_DAYOFMONTH:
-		CHECK_PARAM((TimeValue &lt; RTC_DAYOFMONTH_MAX) \
-				&amp;&amp; (TimeValue &gt; RTC_DAYOFMONTH_MIN));
-
-		RTCx-&gt;DOM = TimeValue &amp; RTC_DOM_MASK;
-		break;
-
-	case RTC_TIMETYPE_DAYOFYEAR:
-		CHECK_PARAM((TimeValue &gt; RTC_DAYOFYEAR_MIN) \
-				&amp;&amp; (TimeValue &lt; RTC_DAYOFYEAR_MAX));
-
-		RTCx-&gt;DOY = TimeValue &amp; RTC_DOY_MASK;
-		break;
-
-	case RTC_TIMETYPE_MONTH:
-		CHECK_PARAM((TimeValue &gt; RTC_MONTH_MIN) \
-				&amp;&amp; (TimeValue &lt; RTC_MONTH_MAX));
-
-		RTCx-&gt;MONTH = TimeValue &amp; RTC_MONTH_MASK;
-		break;
-
-	case RTC_TIMETYPE_YEAR:
-		CHECK_PARAM(TimeValue &lt; RTC_YEAR_MAX);
-
-		RTCx-&gt;YEAR = TimeValue &amp; RTC_YEAR_MASK;
-		break;
-	}
-}
-
-/*********************************************************************//**
- * @brief 		Get current time value for each type time type
- * @param[in]	RTCx	RTC peripheral selected, should be RTC
- * @param[in]	Timetype: Time Type, should be:
- * 				- RTC_TIMETYPE_SECOND
- * 				- RTC_TIMETYPE_MINUTE
- * 				- RTC_TIMETYPE_HOUR
- * 				- RTC_TIMETYPE_DAYOFWEEK
- * 				- RTC_TIMETYPE_DAYOFMONTH
- * 				- RTC_TIMETYPE_DAYOFYEAR
- * 				- RTC_TIMETYPE_MONTH
- * 				- RTC_TIMETYPE_YEAR
- * @return 		Value of time according to specified time type
- **********************************************************************/
-uint32_t RTC_GetTime(RTC_TypeDef *RTCx, uint32_t Timetype)
-{
-	CHECK_PARAM(PARAM_RTCx(RTCx));
-	CHECK_PARAM(PARAM_RTC_TIMETYPE(Timetype));
-
-	switch (Timetype)
-	{
-	case RTC_TIMETYPE_SECOND:
-		return (RTCx-&gt;SEC &amp; RTC_SEC_MASK);
-		break;
-	case RTC_TIMETYPE_MINUTE:
-		return (RTCx-&gt;MIN &amp; RTC_MIN_MASK);
-		break;
-	case RTC_TIMETYPE_HOUR:
-		return (RTCx-&gt;HOUR &amp; RTC_HOUR_MASK);
-		break;
-	case RTC_TIMETYPE_DAYOFWEEK:
-		return (RTCx-&gt;DOW &amp; RTC_DOW_MASK);
-		break;
-	case RTC_TIMETYPE_DAYOFMONTH:
-		return (RTCx-&gt;DOM &amp; RTC_DOM_MASK);
-		break;
-	case RTC_TIMETYPE_DAYOFYEAR:
-		return (RTCx-&gt;DOY &amp; RTC_DOY_MASK);
-		break;
-	case RTC_TIMETYPE_MONTH:
-		return (RTCx-&gt;MONTH &amp; RTC_MONTH_MASK);
-		break;
-	case RTC_TIMETYPE_YEAR:
-		return (RTCx-&gt;YEAR &amp; RTC_YEAR_MASK);
-		break;
-	default:
-		return (0);
-		break;
-	}
-}
-
-
-/*********************************************************************//**
- * @brief 		Set full of time in RTC peripheral
- * @param[in]	RTCx	RTC peripheral selected, should be RTC
- * @param[in]	pFullTime Pointer to a RTC_TIME_Type structure that
- * 				contains time value in full.
- * @return 		None
- **********************************************************************/
-void RTC_SetFullTime (RTC_TypeDef *RTCx, RTC_TIME_Type *pFullTime)
-{
-	CHECK_PARAM(PARAM_RTCx(RTCx));
-
-	RTCx-&gt;DOM = pFullTime-&gt;DOM &amp; RTC_DOM_MASK;
-	RTCx-&gt;DOW = pFullTime-&gt;DOW &amp; RTC_DOW_MASK;
-	RTCx-&gt;DOY = pFullTime-&gt;DOY &amp; RTC_DOY_MASK;
-	RTCx-&gt;HOUR = pFullTime-&gt;HOUR &amp; RTC_HOUR_MASK;
-	RTCx-&gt;MIN = pFullTime-&gt;MIN &amp; RTC_MIN_MASK;
-	RTCx-&gt;SEC = pFullTime-&gt;SEC &amp; RTC_SEC_MASK;
-	RTCx-&gt;MONTH = pFullTime-&gt;MONTH &amp; RTC_MONTH_MASK;
-	RTCx-&gt;YEAR = pFullTime-&gt;YEAR &amp; RTC_YEAR_MASK;
-}
-
-
-/*********************************************************************//**
- * @brief 		Get full of time in RTC peripheral
- * @param[in]	RTCx	RTC peripheral selected, should be RTC
- * @param[in]	pFullTime Pointer to a RTC_TIME_Type structure that
- * 				will be stored time in full.
- * @return 		None
- **********************************************************************/
-void RTC_GetFullTime (RTC_TypeDef *RTCx, RTC_TIME_Type *pFullTime)
-{
-	CHECK_PARAM(PARAM_RTCx(RTCx));
-
-	pFullTime-&gt;DOM = RTCx-&gt;DOM &amp; RTC_DOM_MASK;
-	pFullTime-&gt;DOW = RTCx-&gt;DOW &amp; RTC_DOW_MASK;
-	pFullTime-&gt;DOY = RTCx-&gt;DOY &amp; RTC_DOY_MASK;
-	pFullTime-&gt;HOUR = RTCx-&gt;HOUR &amp; RTC_HOUR_MASK;
-	pFullTime-&gt;MIN = RTCx-&gt;MIN &amp; RTC_MIN_MASK;
-	pFullTime-&gt;SEC = RTCx-&gt;SEC &amp; RTC_SEC_MASK;
-	pFullTime-&gt;MONTH = RTCx-&gt;MONTH &amp; RTC_MONTH_MASK;
-	pFullTime-&gt;YEAR = RTCx-&gt;YEAR &amp; RTC_YEAR_MASK;
-}
-
-
-/*********************************************************************//**
- * @brief 		Set alarm time value for each time type
- * @param[in]	RTCx	RTC peripheral selected, should be RTC
- * @param[in]	Timetype: Time Type, should be:
- * 				- RTC_TIMETYPE_SECOND
- * 				- RTC_TIMETYPE_MINUTE
- * 				- RTC_TIMETYPE_HOUR
- * 				- RTC_TIMETYPE_DAYOFWEEK
- * 				- RTC_TIMETYPE_DAYOFMONTH
- * 				- RTC_TIMETYPE_DAYOFYEAR
- * 				- RTC_TIMETYPE_MONTH
- * 				- RTC_TIMETYPE_YEAR
- * @param[in]	ALValue Alarm time value to set
- * @return 		None
- **********************************************************************/
-void RTC_SetAlarmTime (RTC_TypeDef *RTCx, uint32_t Timetype, uint32_t ALValue)
-{
-	CHECK_PARAM(PARAM_RTCx(RTCx));
-
-	switch (Timetype)
-	{
-	case RTC_TIMETYPE_SECOND:
-		CHECK_PARAM(ALValue &lt; RTC_SECOND_MAX);
-
-		RTCx-&gt;ALSEC = ALValue &amp; RTC_SEC_MASK;
-		break;
-
-	case RTC_TIMETYPE_MINUTE:
-		CHECK_PARAM(ALValue &lt; RTC_MINUTE_MAX);
-
-		RTCx-&gt;ALMIN = ALValue &amp; RTC_MIN_MASK;
-		break;
-
-	case RTC_TIMETYPE_HOUR:
-		CHECK_PARAM(ALValue &lt; RTC_HOUR_MAX);
-
-		RTCx-&gt;ALHOUR = ALValue &amp; RTC_HOUR_MASK;
-		break;
-
-	case RTC_TIMETYPE_DAYOFWEEK:
-		CHECK_PARAM(ALValue &lt; RTC_DAYOFWEEK_MAX);
-
-		RTCx-&gt;ALDOW = ALValue &amp; RTC_DOW_MASK;
-		break;
-
-	case RTC_TIMETYPE_DAYOFMONTH:
-		CHECK_PARAM((ALValue &lt; RTC_DAYOFMONTH_MAX) \
-				&amp;&amp; (ALValue &gt; RTC_DAYOFMONTH_MIN));
-
-		RTCx-&gt;ALDOM = ALValue &amp; RTC_DOM_MASK;
-		break;
-
-	case RTC_TIMETYPE_DAYOFYEAR:
-		CHECK_PARAM((ALValue &gt; RTC_DAYOFYEAR_MIN) \
-				&amp;&amp; (ALValue &lt; RTC_DAYOFYEAR_MAX));
-
-		RTCx-&gt;ALDOY = ALValue &amp; RTC_DOY_MASK;
-		break;
-
-	case RTC_TIMETYPE_MONTH:
-		CHECK_PARAM((ALValue &gt; RTC_MONTH_MIN) \
-				&amp;&amp; (ALValue &lt; RTC_MONTH_MAX));
-
-		RTCx-&gt;ALMON = ALValue &amp; RTC_MONTH_MASK;
-		break;
-
-	case RTC_TIMETYPE_YEAR:
-		CHECK_PARAM(ALValue &lt; RTC_YEAR_MAX);
-
-		RTCx-&gt;ALYEAR = ALValue &amp; RTC_YEAR_MASK;
-		break;
-	}
-}
-
-
-
-/*********************************************************************//**
- * @brief 		Get alarm time value for each time type
- * @param[in]	RTCx	RTC peripheral selected, should be RTC
- * @param[in]	Timetype: Time Type, should be:
- * 				- RTC_TIMETYPE_SECOND
- * 				- RTC_TIMETYPE_MINUTE
- * 				- RTC_TIMETYPE_HOUR
- * 				- RTC_TIMETYPE_DAYOFWEEK
- * 				- RTC_TIMETYPE_DAYOFMONTH
- * 				- RTC_TIMETYPE_DAYOFYEAR
- * 				- RTC_TIMETYPE_MONTH
- * 				- RTC_TIMETYPE_YEAR
-  * @return 	Value of Alarm time according to specified time type
- **********************************************************************/
-uint32_t RTC_GetAlarmTime (RTC_TypeDef *RTCx, uint32_t Timetype)
-{
-	switch (Timetype)
-	{
-	case RTC_TIMETYPE_SECOND:
-		return (RTCx-&gt;ALSEC &amp; RTC_SEC_MASK);
-		break;
-	case RTC_TIMETYPE_MINUTE:
-		return (RTCx-&gt;ALMIN &amp; RTC_MIN_MASK);
-		break;
-	case RTC_TIMETYPE_HOUR:
-		return (RTCx-&gt;ALHOUR &amp; RTC_HOUR_MASK);
-		break;
-	case RTC_TIMETYPE_DAYOFWEEK:
-		return (RTCx-&gt;ALDOW &amp; RTC_DOW_MASK);
-		break;
-	case RTC_TIMETYPE_DAYOFMONTH:
-		return (RTCx-&gt;ALDOM &amp; RTC_DOM_MASK);
-		break;
-	case RTC_TIMETYPE_DAYOFYEAR:
-		return (RTCx-&gt;ALDOY &amp; RTC_DOY_MASK);
-		break;
-	case RTC_TIMETYPE_MONTH:
-		return (RTCx-&gt;ALMON &amp; RTC_MONTH_MASK);
-		break;
-	case RTC_TIMETYPE_YEAR:
-		return (RTCx-&gt;ALYEAR &amp; RTC_YEAR_MASK);
-		break;
-	default:
-		return (0);
-		break;
-	}
-}
-
-
-/*********************************************************************//**
- * @brief 		Set full of alarm time in RTC peripheral
- * @param[in]	RTCx	RTC peripheral selected, should be RTC
- * @param[in]	pFullTime Pointer to a RTC_TIME_Type structure that
- * 				contains alarm time value in full.
- * @return 		None
- **********************************************************************/
-void RTC_SetFullAlarmTime (RTC_TypeDef *RTCx, RTC_TIME_Type *pFullTime)
-{
-	CHECK_PARAM(PARAM_RTCx(RTCx));
-
-	RTCx-&gt;ALDOM = pFullTime-&gt;DOM &amp; RTC_DOM_MASK;
-	RTCx-&gt;ALDOW = pFullTime-&gt;DOW &amp; RTC_DOW_MASK;
-	RTCx-&gt;ALDOY = pFullTime-&gt;DOY &amp; RTC_DOY_MASK;
-	RTCx-&gt;ALHOUR = pFullTime-&gt;HOUR &amp; RTC_HOUR_MASK;
-	RTCx-&gt;ALMIN = pFullTime-&gt;MIN &amp; RTC_MIN_MASK;
-	RTCx-&gt;ALSEC = pFullTime-&gt;SEC &amp; RTC_SEC_MASK;
-	RTCx-&gt;ALMON = pFullTime-&gt;MONTH &amp; RTC_MONTH_MASK;
-	RTCx-&gt;ALYEAR = pFullTime-&gt;YEAR &amp; RTC_YEAR_MASK;
-}
-
-
-/*********************************************************************//**
- * @brief 		Get full of alarm time in RTC peripheral
- * @param[in]	RTCx	RTC peripheral selected, should be RTC
- * @param[in]	pFullTime Pointer to a RTC_TIME_Type structure that
- * 				will be stored alarm time in full.
- * @return 		None
- **********************************************************************/
-void RTC_GetFullAlarmTime (RTC_TypeDef *RTCx, RTC_TIME_Type *pFullTime)
-{
-	CHECK_PARAM(PARAM_RTCx(RTCx));
-
-	pFullTime-&gt;DOM = RTCx-&gt;ALDOM &amp; RTC_DOM_MASK;
-	pFullTime-&gt;DOW = RTCx-&gt;ALDOW &amp; RTC_DOW_MASK;
-	pFullTime-&gt;DOY = RTCx-&gt;ALDOY &amp; RTC_DOY_MASK;
-	pFullTime-&gt;HOUR = RTCx-&gt;ALHOUR &amp; RTC_HOUR_MASK;
-	pFullTime-&gt;MIN = RTCx-&gt;ALMIN &amp; RTC_MIN_MASK;
-	pFullTime-&gt;SEC = RTCx-&gt;ALSEC &amp; RTC_SEC_MASK;
-	pFullTime-&gt;MONTH = RTCx-&gt;ALMON &amp; RTC_MONTH_MASK;
-	pFullTime-&gt;YEAR = RTCx-&gt;ALYEAR &amp; RTC_YEAR_MASK;
-}
-
-
-/*********************************************************************//**
- * @brief 		Check whether if specified Location interrupt in
- * 				RTC peripheral is set or not
- * @param[in]	RTCx	RTC peripheral selected, should be RTC
- * @param[in]	IntType Interrupt location type, should be:
- * 						- RTC_INT_COUNTER_INCREASE: Counter Increment Interrupt
- * 							block generated an interrupt.
- * 						- RTC_INT_ALARM: Alarm generated an
- * 							interrupt.
- * @return 		New state of specified Location interrupt in RTC peripheral
- * 				(SET or RESET)
- **********************************************************************/
-IntStatus RTC_GetIntPending (RTC_TypeDef *RTCx, uint32_t IntType)
-{
-	CHECK_PARAM(PARAM_RTCx(RTCx));
-	CHECK_PARAM(PARAM_RTC_INT(IntType));
-
-	return ((RTCx-&gt;ILR &amp; IntType) ? SET : RESET);
-}
-
-
-/*********************************************************************//**
- * @brief 		Clear specified Location interrupt pending in
- * 				RTC peripheral
- * @param[in]	RTCx	RTC peripheral selected, should be RTC
- * @param[in]	IntType Interrupt location type, should be:
- * 						- RTC_INT_COUNTER_INCREASE: Clear Counter Increment
- * 						Interrupt pending.
- * 						- RTC_INT_ALARM: Clear alarm interrupt pending
- * @return 		None
- **********************************************************************/
-void RTC_ClearIntPending (RTC_TypeDef *RTCx, uint32_t IntType)
-{
-	CHECK_PARAM(PARAM_RTCx(RTCx));
-	CHECK_PARAM(PARAM_RTC_INT(IntType));
-
-	RTCx-&gt;ILR = IntType;
-}
-
-/*********************************************************************//**
- * @brief 		Enable/Disable calibration counter in RTC peripheral
- * @param[in]	RTCx	RTC peripheral selected, should be RTC
- * @param[in]	NewState New State of this function, should be:
- * 				- ENABLE: The calibration counter is enabled and counting
- * 				- DISABLE: The calibration counter is disabled and reset to zero
- * @return 		None
- **********************************************************************/
-void RTC_CalibCounterCmd(RTC_TypeDef *RTCx, FunctionalState NewState)
-{
-	CHECK_PARAM(PARAM_RTCx(RTCx));
-	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
-
-	if (NewState == ENABLE)
-	{
-		RTCx-&gt;CCR &amp;= (~RTC_CCR_CCALEN) &amp; RTC_CCR_BITMASK;
-	}
-	else
-	{
-		RTCx-&gt;CCR |= RTC_CCR_CCALEN;
-	}
-}
-
-
-/*********************************************************************//**
- * @brief 		Configures Calibration in RTC peripheral
- * @param[in]	RTCx	RTC peripheral selected, should be RTC
- * @param[in]	CalibValue Calibration value, should be in range from
- * 					0 to 131,072
- * @param[in]	CalibDir Calibration Direction, should be:
- * 					- RTC_CALIB_DIR_FORWARD: Forward calibration
- * 					- RTC_CALIB_DIR_BACKWARD: Backward calibration
- * @return 		None
- **********************************************************************/
-void RTC_CalibConfig(RTC_TypeDef *RTCx, uint32_t CalibValue, uint8_t CalibDir)
-{
-	CHECK_PARAM(PARAM_RTCx(RTCx));
-	CHECK_PARAM(PARAM_RTC_CALIB_DIR(CalibDir));
-	CHECK_PARAM(CalibValue &gt; RTC_CALIBRATION_MAX);
-
-	RTCx-&gt;CALIBRATION = ((CalibValue - 1) &amp; RTC_CALIBRATION_CALVAL_MASK) \
-			| ((CalibDir == RTC_CALIB_DIR_BACKWARD) ? RTC_CALIBRATION_LIBDIR : 0);
-}
-
-
-/*********************************************************************//**
- * @brief 		Write value to General purpose registers
- * @param[in]	RTCx	RTC peripheral selected, should be RTC
- * @param[in]	Channel General purpose registers Channel number,
- * 				should be in range from 0 to 4.
- * @param[in]	Value Value to write
- * @return 		None
- * Note: These General purpose registers can be used to store important
- * information when the main power supply is off. The value in these
- * registers is not affected by chip reset.
- **********************************************************************/
-void RTC_WriteGPREG (RTC_TypeDef *RTCx, uint8_t Channel, uint32_t Value)
-{
-	uint32_t *preg;
-
-	CHECK_PARAM(PARAM_RTCx(RTCx));
-	CHECK_PARAM(PARAM_RTC_GPREG_CH(Channel));
-
-	preg = (uint32_t *)&amp;RTCx-&gt;GPREG0;
-	preg += Channel;
-	*preg = Value;
-}
-
-
-/*********************************************************************//**
- * @brief 		Read value from General purpose registers
- * @param[in]	RTCx	RTC peripheral selected, should be RTC
- * @param[in]	Channel General purpose registers Channel number,
- * 				should be in range from 0 to 4.
- * @return 		Read Value
- * Note: These General purpose registers can be used to store important
- * information when the main power supply is off. The value in these
- * registers is not affected by chip reset.
- **********************************************************************/
-uint32_t RTC_ReadGPREG (RTC_TypeDef *RTCx, uint8_t Channel)
-{
-	uint32_t *preg;
-	uint32_t value;
-
-	CHECK_PARAM(PARAM_RTCx(RTCx));
-	CHECK_PARAM(PARAM_RTC_GPREG_CH(Channel));
-
-	preg = (uint32_t *)&amp;RTCx-&gt;GPREG0;
-	preg += Channel;
-	value = *preg;
-	return (value);
-}
-
-/**
- * @}
- */
-
-#endif /* _RTC */
-
-/**
- * @}
- */
-
-/* --------------------------------- End Of File ------------------------------ */
-
+/**
+ * @file	: lpc17xx_rtc.c
+ * @brief	: Contains all functions support for RTC firmware library on LPC17xx
+ * @version	: 1.0
+ * @date	: 23. Apr. 2009
+ * @author	: HieuNguyen
+ **************************************************************************
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * products. This software is supplied &quot;AS IS&quot; without any warranties.
+ * NXP Semiconductors assumes no responsibility or liability for the
+ * use of the software, conveys no license or title under any patent,
+ * copyright, or mask work right to the product. NXP Semiconductors
+ * reserves the right to make changes in the software without
+ * notification. NXP Semiconductors also make no representation or
+ * warranty that such application will be suitable for the specified
+ * use without further testing or modification.
+ **********************************************************************/
+
+
+/* Peripheral group ----------------------------------------------------------- */
+/** @addtogroup RTC
+ * @{
+ */
+
+/* Includes ------------------------------------------------------------------- */
+#include &quot;lpc17xx_rtc.h&quot;
+#include &quot;lpc17xx_clkpwr.h&quot;
+
+
+/* If this source file built with example, the LPC17xx FW library configuration
+ * file in each example directory (&quot;lpc17xx_libcfg.h&quot;) must be included,
+ * otherwise the default FW library configuration file must be included instead
+ */
+#ifdef __BUILD_WITH_EXAMPLE__
+#include &quot;lpc17xx_libcfg.h&quot;
+#else
+#include &quot;lpc17xx_libcfg_default.h&quot;
+#endif /* __BUILD_WITH_EXAMPLE__ */
+
+
+#ifdef _RTC
+
+/* Public Functions ----------------------------------------------------------- */
+/** @addtogroup RTC_Public_Functions
+ * @{
+ */
+
+/********************************************************************//**
+ * @brief		Initializes the RTC peripheral.
+ * @param[in]	RTCx	RTC peripheral selected, should be RTC
+ * @return 		None
+ *********************************************************************/
+void RTC_Init (LPC_RTC_TypeDef *RTCx)
+{
+	CHECK_PARAM(PARAM_RTCx(RTCx));
+
+	/* Set up clock and power for RTC module */
+	CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCRTC, ENABLE);
+
+	// Clear all register to be default
+	RTCx-&gt;ILR = 0x00;
+	RTCx-&gt;CCR = 0x00;
+	RTCx-&gt;CIIR = 0x00;
+	RTCx-&gt;AMR = 0xFF;
+	RTCx-&gt;CALIBRATION = 0x00;
+}
+
+
+/*********************************************************************//**
+ * @brief		De-initializes the RTC peripheral registers to their
+*                  default reset values.
+ * @param[in]	RTCx	RTC peripheral selected, should be RTC
+ * @return 		None
+ **********************************************************************/
+void RTC_DeInit(LPC_RTC_TypeDef *RTCx)
+{
+	CHECK_PARAM(PARAM_RTCx(RTCx));
+
+	RTCx-&gt;CCR = 0x00;
+	// Disable power and clock for RTC module
+	CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCRTC, DISABLE);
+}
+
+/*********************************************************************//**
+ * @brief 		Reset clock tick counter in RTC peripheral
+ * @param[in]	RTCx	RTC peripheral selected, should be RTC
+ * @return 		None
+ **********************************************************************/
+void RTC_ResetClockTickCounter(LPC_RTC_TypeDef *RTCx)
+{
+	CHECK_PARAM(PARAM_RTCx(RTCx));
+
+	RTCx-&gt;CCR |= RTC_CCR_CTCRST;
+	RTCx-&gt;CCR &amp;= (~RTC_CCR_CTCRST) &amp; RTC_CCR_BITMASK;
+}
+
+/*********************************************************************//**
+ * @brief 		Start/Stop RTC peripheral
+ * @param[in]	RTCx	RTC peripheral selected, should be RTC
+ * @param[in]	NewState New State of this function, should be:
+ * 				- ENABLE: The time counters are enabled
+ * 				- DISABLE: The time counters are disabled
+ * @return 		None
+ **********************************************************************/
+void RTC_Cmd (LPC_RTC_TypeDef *RTCx, FunctionalState NewState)
+{
+	CHECK_PARAM(PARAM_RTCx(RTCx));
+	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
+
+	if (NewState == ENABLE)
+	{
+		RTCx-&gt;CCR |= RTC_CCR_CLKEN;
+	}
+	else
+	{
+		RTCx-&gt;CCR &amp;= (~RTC_CCR_CLKEN) &amp; RTC_CCR_BITMASK;
+	}
+}
+
+
+/*********************************************************************//**
+ * @brief 		Enable/Disable Counter increment interrupt for each time type
+ * 				in RTC peripheral
+ * @param[in]	RTCx	RTC peripheral selected, should be RTC
+ * @param[in]	CntIncrIntType: Counter Increment Interrupt type,
+ * 				an increment of this type value below will generates
+ * 				an interrupt, should be:
+ * 				- RTC_TIMETYPE_SECOND
+ * 				- RTC_TIMETYPE_MINUTE
+ * 				- RTC_TIMETYPE_HOUR
+ * 				- RTC_TIMETYPE_DAYOFWEEK
+ * 				- RTC_TIMETYPE_DAYOFMONTH
+ * 				- RTC_TIMETYPE_DAYOFYEAR
+ * 				- RTC_TIMETYPE_MONTH
+ * 				- RTC_TIMETYPE_YEAR
+ * @param[in]	NewState New State of this function, should be:
+ * 				- ENABLE: Counter Increment interrupt for this
+ * 					time type are enabled
+ * 				- DISABLE: Counter Increment interrupt for this
+ * 					time type are disabled
+ * @return 		None
+ **********************************************************************/
+void RTC_CntIncrIntConfig (LPC_RTC_TypeDef *RTCx, uint32_t CntIncrIntType, \
+								FunctionalState NewState)
+{
+	CHECK_PARAM(PARAM_RTCx(RTCx));
+	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
+	CHECK_PARAM(PARAM_RTC_TIMETYPE(CntIncrIntType));
+
+	if (NewState ==  ENABLE)
+	{
+		switch (CntIncrIntType)
+		{
+		case RTC_TIMETYPE_SECOND:
+			RTCx-&gt;CIIR |= RTC_CIIR_IMSEC;
+			break;
+		case RTC_TIMETYPE_MINUTE:
+			RTCx-&gt;CIIR |= RTC_CIIR_IMMIN;
+			break;
+		case RTC_TIMETYPE_HOUR:
+			RTCx-&gt;CIIR |= RTC_CIIR_IMHOUR;
+			break;
+		case RTC_TIMETYPE_DAYOFWEEK:
+			RTCx-&gt;CIIR |= RTC_CIIR_IMDOW;
+			break;
+		case RTC_TIMETYPE_DAYOFMONTH:
+			RTCx-&gt;CIIR |= RTC_CIIR_IMDOM;
+			break;
+		case RTC_TIMETYPE_DAYOFYEAR:
+			RTCx-&gt;CIIR |= RTC_CIIR_IMDOY;
+			break;
+		case RTC_TIMETYPE_MONTH:
+			RTCx-&gt;CIIR |= RTC_CIIR_IMMON;
+			break;
+		case RTC_TIMETYPE_YEAR:
+			RTCx-&gt;CIIR |= RTC_CIIR_IMYEAR;
+			break;
+		}
+	}
+	else
+	{
+		switch (CntIncrIntType)
+		{
+		case RTC_TIMETYPE_SECOND:
+			RTCx-&gt;CIIR &amp;= (~RTC_CIIR_IMSEC) &amp; RTC_CIIR_BITMASK;
+			break;
+		case RTC_TIMETYPE_MINUTE:
+			RTCx-&gt;CIIR &amp;= (~RTC_CIIR_IMMIN) &amp; RTC_CIIR_BITMASK;
+			break;
+		case RTC_TIMETYPE_HOUR:
+			RTCx-&gt;CIIR &amp;= (~RTC_CIIR_IMHOUR) &amp; RTC_CIIR_BITMASK;
+			break;
+		case RTC_TIMETYPE_DAYOFWEEK:
+			RTCx-&gt;CIIR &amp;= (~RTC_CIIR_IMDOW) &amp; RTC_CIIR_BITMASK;
+			break;
+		case RTC_TIMETYPE_DAYOFMONTH:
+			RTCx-&gt;CIIR &amp;= (~RTC_CIIR_IMDOM) &amp; RTC_CIIR_BITMASK;
+			break;
+		case RTC_TIMETYPE_DAYOFYEAR:
+			RTCx-&gt;CIIR &amp;= (~RTC_CIIR_IMDOY) &amp; RTC_CIIR_BITMASK;
+			break;
+		case RTC_TIMETYPE_MONTH:
+			RTCx-&gt;CIIR &amp;= (~RTC_CIIR_IMMON) &amp; RTC_CIIR_BITMASK;
+			break;
+		case RTC_TIMETYPE_YEAR:
+			RTCx-&gt;CIIR &amp;= (~RTC_CIIR_IMYEAR) &amp; RTC_CIIR_BITMASK;
+			break;
+		}
+	}
+}
+
+
+/*********************************************************************//**
+ * @brief 		Enable/Disable Alarm interrupt for each time type
+ * 				in RTC peripheral
+ * @param[in]	RTCx	RTC peripheral selected, should be RTC
+ * @param[in]	AlarmTimeType: Alarm Time Interrupt type,
+ * 				an matching of this type value below with current time
+ * 				in RTC will generates an interrupt, should be:
+ * 				- RTC_TIMETYPE_SECOND
+ * 				- RTC_TIMETYPE_MINUTE
+ * 				- RTC_TIMETYPE_HOUR
+ * 				- RTC_TIMETYPE_DAYOFWEEK
+ * 				- RTC_TIMETYPE_DAYOFMONTH
+ * 				- RTC_TIMETYPE_DAYOFYEAR
+ * 				- RTC_TIMETYPE_MONTH
+ * 				- RTC_TIMETYPE_YEAR
+ * @param[in]	NewState New State of this function, should be:
+ * 				- ENABLE: Alarm interrupt for this
+ * 					time type are enabled
+ * 				- DISABLE: Alarm interrupt for this
+ * 					time type are disabled
+ * @return 		None
+ **********************************************************************/
+void RTC_AlarmIntConfig (LPC_RTC_TypeDef *RTCx, uint32_t AlarmTimeType, \
+								FunctionalState NewState)
+{
+	CHECK_PARAM(PARAM_RTCx(RTCx));
+	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
+	CHECK_PARAM(PARAM_RTC_TIMETYPE(AlarmTimeType));
+
+	if (NewState == ENABLE)
+	{
+		switch (AlarmTimeType)
+		{
+		case RTC_TIMETYPE_SECOND:
+			RTCx-&gt;AMR &amp;= (~RTC_AMR_AMRSEC) &amp; RTC_AMR_BITMASK;
+			break;
+		case RTC_TIMETYPE_MINUTE:
+			RTCx-&gt;AMR &amp;= (~RTC_AMR_AMRMIN) &amp; RTC_AMR_BITMASK;
+			break;
+		case RTC_TIMETYPE_HOUR:
+			RTCx-&gt;AMR &amp;= (~RTC_AMR_AMRHOUR) &amp; RTC_AMR_BITMASK;
+			break;
+		case RTC_TIMETYPE_DAYOFWEEK:
+			RTCx-&gt;AMR &amp;= (~RTC_AMR_AMRDOW) &amp; RTC_AMR_BITMASK;
+			break;
+		case RTC_TIMETYPE_DAYOFMONTH:
+			RTCx-&gt;AMR &amp;= (~RTC_AMR_AMRDOM) &amp; RTC_AMR_BITMASK;
+			break;
+		case RTC_TIMETYPE_DAYOFYEAR:
+			RTCx-&gt;AMR &amp;= (~RTC_AMR_AMRDOY) &amp; RTC_AMR_BITMASK;
+			break;
+		case RTC_TIMETYPE_MONTH:
+			RTCx-&gt;AMR &amp;= (~RTC_AMR_AMRMON) &amp; RTC_AMR_BITMASK;
+			break;
+		case RTC_TIMETYPE_YEAR:
+			RTCx-&gt;AMR &amp;= (~RTC_AMR_AMRYEAR) &amp; RTC_AMR_BITMASK;
+			break;
+		}
+	}
+	else
+	{
+		switch (AlarmTimeType)
+		{
+		case RTC_TIMETYPE_SECOND:
+			RTCx-&gt;AMR |= (RTC_AMR_AMRSEC);
+			break;
+		case RTC_TIMETYPE_MINUTE:
+			RTCx-&gt;AMR |= (RTC_AMR_AMRMIN);
+			break;
+		case RTC_TIMETYPE_HOUR:
+			RTCx-&gt;AMR |= (RTC_AMR_AMRHOUR);
+			break;
+		case RTC_TIMETYPE_DAYOFWEEK:
+			RTCx-&gt;AMR |= (RTC_AMR_AMRDOW);
+			break;
+		case RTC_TIMETYPE_DAYOFMONTH:
+			RTCx-&gt;AMR |= (RTC_AMR_AMRDOM);
+			break;
+		case RTC_TIMETYPE_DAYOFYEAR:
+			RTCx-&gt;AMR |= (RTC_AMR_AMRDOY);
+			break;
+		case RTC_TIMETYPE_MONTH:
+			RTCx-&gt;AMR |= (RTC_AMR_AMRMON);
+			break;
+		case RTC_TIMETYPE_YEAR:
+			RTCx-&gt;AMR |= (RTC_AMR_AMRYEAR);
+			break;
+		}
+	}
+}
+
+
+/*********************************************************************//**
+ * @brief 		Set current time value for each time type in RTC peripheral
+ * @param[in]	RTCx	RTC peripheral selected, should be RTC
+ * @param[in]	Timetype: Time Type, should be:
+ * 				- RTC_TIMETYPE_SECOND
+ * 				- RTC_TIMETYPE_MINUTE
+ * 				- RTC_TIMETYPE_HOUR
+ * 				- RTC_TIMETYPE_DAYOFWEEK
+ * 				- RTC_TIMETYPE_DAYOFMONTH
+ * 				- RTC_TIMETYPE_DAYOFYEAR
+ * 				- RTC_TIMETYPE_MONTH
+ * 				- RTC_TIMETYPE_YEAR
+ * @param[in]	TimeValue Time value to set
+ * @return 		None
+ **********************************************************************/
+void RTC_SetTime (LPC_RTC_TypeDef *RTCx, uint32_t Timetype, uint32_t TimeValue)
+{
+	CHECK_PARAM(PARAM_RTCx(RTCx));
+	CHECK_PARAM(PARAM_RTC_TIMETYPE(Timetype));
+
+	switch ( Timetype)
+	{
+	case RTC_TIMETYPE_SECOND:
+		CHECK_PARAM(TimeValue &lt; RTC_SECOND_MAX);
+
+		RTCx-&gt;SEC = TimeValue &amp; RTC_SEC_MASK;
+		break;
+
+	case RTC_TIMETYPE_MINUTE:
+		CHECK_PARAM(TimeValue &lt; RTC_MINUTE_MAX);
+
+		RTCx-&gt;MIN = TimeValue &amp; RTC_MIN_MASK;
+		break;
+
+	case RTC_TIMETYPE_HOUR:
+		CHECK_PARAM(TimeValue &lt; RTC_HOUR_MAX);
+
+		RTCx-&gt;HOUR = TimeValue &amp; RTC_HOUR_MASK;
+		break;
+
+	case RTC_TIMETYPE_DAYOFWEEK:
+		CHECK_PARAM(TimeValue &lt; RTC_DAYOFWEEK_MAX);
+
+		RTCx-&gt;DOW = TimeValue &amp; RTC_DOW_MASK;
+		break;
+
+	case RTC_TIMETYPE_DAYOFMONTH:
+		CHECK_PARAM((TimeValue &lt; RTC_DAYOFMONTH_MAX) \
+				&amp;&amp; (TimeValue &gt; RTC_DAYOFMONTH_MIN));
+
+		RTCx-&gt;DOM = TimeValue &amp; RTC_DOM_MASK;
+		break;
+
+	case RTC_TIMETYPE_DAYOFYEAR:
+		CHECK_PARAM((TimeValue &gt; RTC_DAYOFYEAR_MIN) \
+				&amp;&amp; (TimeValue &lt; RTC_DAYOFYEAR_MAX));
+
+		RTCx-&gt;DOY = TimeValue &amp; RTC_DOY_MASK;
+		break;
+
+	case RTC_TIMETYPE_MONTH:
+		CHECK_PARAM((TimeValue &gt; RTC_MONTH_MIN) \
+				&amp;&amp; (TimeValue &lt; RTC_MONTH_MAX));
+
+		RTCx-&gt;MONTH = TimeValue &amp; RTC_MONTH_MASK;
+		break;
+
+	case RTC_TIMETYPE_YEAR:
+		CHECK_PARAM(TimeValue &lt; RTC_YEAR_MAX);
+
+		RTCx-&gt;YEAR = TimeValue &amp; RTC_YEAR_MASK;
+		break;
+	}
+}
+
+/*********************************************************************//**
+ * @brief 		Get current time value for each type time type
+ * @param[in]	RTCx	RTC peripheral selected, should be RTC
+ * @param[in]	Timetype: Time Type, should be:
+ * 				- RTC_TIMETYPE_SECOND
+ * 				- RTC_TIMETYPE_MINUTE
+ * 				- RTC_TIMETYPE_HOUR
+ * 				- RTC_TIMETYPE_DAYOFWEEK
+ * 				- RTC_TIMETYPE_DAYOFMONTH
+ * 				- RTC_TIMETYPE_DAYOFYEAR
+ * 				- RTC_TIMETYPE_MONTH
+ * 				- RTC_TIMETYPE_YEAR
+ * @return 		Value of time according to specified time type
+ **********************************************************************/
+uint32_t RTC_GetTime(LPC_RTC_TypeDef *RTCx, uint32_t Timetype)
+{
+	CHECK_PARAM(PARAM_RTCx(RTCx));
+	CHECK_PARAM(PARAM_RTC_TIMETYPE(Timetype));
+
+	switch (Timetype)
+	{
+	case RTC_TIMETYPE_SECOND:
+		return (RTCx-&gt;SEC &amp; RTC_SEC_MASK);
+		break;
+	case RTC_TIMETYPE_MINUTE:
+		return (RTCx-&gt;MIN &amp; RTC_MIN_MASK);
+		break;
+	case RTC_TIMETYPE_HOUR:
+		return (RTCx-&gt;HOUR &amp; RTC_HOUR_MASK);
+		break;
+	case RTC_TIMETYPE_DAYOFWEEK:
+		return (RTCx-&gt;DOW &amp; RTC_DOW_MASK);
+		break;
+	case RTC_TIMETYPE_DAYOFMONTH:
+		return (RTCx-&gt;DOM &amp; RTC_DOM_MASK);
+		break;
+	case RTC_TIMETYPE_DAYOFYEAR:
+		return (RTCx-&gt;DOY &amp; RTC_DOY_MASK);
+		break;
+	case RTC_TIMETYPE_MONTH:
+		return (RTCx-&gt;MONTH &amp; RTC_MONTH_MASK);
+		break;
+	case RTC_TIMETYPE_YEAR:
+		return (RTCx-&gt;YEAR &amp; RTC_YEAR_MASK);
+		break;
+	default:
+		return (0);
+		break;
+	}
+}
+
+
+/*********************************************************************//**
+ * @brief 		Set full of time in RTC peripheral
+ * @param[in]	RTCx	RTC peripheral selected, should be RTC
+ * @param[in]	pFullTime Pointer to a RTC_TIME_Type structure that
+ * 				contains time value in full.
+ * @return 		None
+ **********************************************************************/
+void RTC_SetFullTime (LPC_RTC_TypeDef *RTCx, RTC_TIME_Type *pFullTime)
+{
+	CHECK_PARAM(PARAM_RTCx(RTCx));
+
+	RTCx-&gt;DOM = pFullTime-&gt;DOM &amp; RTC_DOM_MASK;
+	RTCx-&gt;DOW = pFullTime-&gt;DOW &amp; RTC_DOW_MASK;
+	RTCx-&gt;DOY = pFullTime-&gt;DOY &amp; RTC_DOY_MASK;
+	RTCx-&gt;HOUR = pFullTime-&gt;HOUR &amp; RTC_HOUR_MASK;
+	RTCx-&gt;MIN = pFullTime-&gt;MIN &amp; RTC_MIN_MASK;
+	RTCx-&gt;SEC = pFullTime-&gt;SEC &amp; RTC_SEC_MASK;
+	RTCx-&gt;MONTH = pFullTime-&gt;MONTH &amp; RTC_MONTH_MASK;
+	RTCx-&gt;YEAR = pFullTime-&gt;YEAR &amp; RTC_YEAR_MASK;
+}
+
+
+/*********************************************************************//**
+ * @brief 		Get full of time in RTC peripheral
+ * @param[in]	RTCx	RTC peripheral selected, should be RTC
+ * @param[in]	pFullTime Pointer to a RTC_TIME_Type structure that
+ * 				will be stored time in full.
+ * @return 		None
+ **********************************************************************/
+void RTC_GetFullTime (LPC_RTC_TypeDef *RTCx, RTC_TIME_Type *pFullTime)
+{
+	CHECK_PARAM(PARAM_RTCx(RTCx));
+
+	pFullTime-&gt;DOM = RTCx-&gt;DOM &amp; RTC_DOM_MASK;
+	pFullTime-&gt;DOW = RTCx-&gt;DOW &amp; RTC_DOW_MASK;
+	pFullTime-&gt;DOY = RTCx-&gt;DOY &amp; RTC_DOY_MASK;
+	pFullTime-&gt;HOUR = RTCx-&gt;HOUR &amp; RTC_HOUR_MASK;
+	pFullTime-&gt;MIN = RTCx-&gt;MIN &amp; RTC_MIN_MASK;
+	pFullTime-&gt;SEC = RTCx-&gt;SEC &amp; RTC_SEC_MASK;
+	pFullTime-&gt;MONTH = RTCx-&gt;MONTH &amp; RTC_MONTH_MASK;
+	pFullTime-&gt;YEAR = RTCx-&gt;YEAR &amp; RTC_YEAR_MASK;
+}
+
+
+/*********************************************************************//**
+ * @brief 		Set alarm time value for each time type
+ * @param[in]	RTCx	RTC peripheral selected, should be RTC
+ * @param[in]	Timetype: Time Type, should be:
+ * 				- RTC_TIMETYPE_SECOND
+ * 				- RTC_TIMETYPE_MINUTE
+ * 				- RTC_TIMETYPE_HOUR
+ * 				- RTC_TIMETYPE_DAYOFWEEK
+ * 				- RTC_TIMETYPE_DAYOFMONTH
+ * 				- RTC_TIMETYPE_DAYOFYEAR
+ * 				- RTC_TIMETYPE_MONTH
+ * 				- RTC_TIMETYPE_YEAR
+ * @param[in]	ALValue Alarm time value to set
+ * @return 		None
+ **********************************************************************/
+void RTC_SetAlarmTime (LPC_RTC_TypeDef *RTCx, uint32_t Timetype, uint32_t ALValue)
+{
+	CHECK_PARAM(PARAM_RTCx(RTCx));
+
+	switch (Timetype)
+	{
+	case RTC_TIMETYPE_SECOND:
+		CHECK_PARAM(ALValue &lt; RTC_SECOND_MAX);
+
+		RTCx-&gt;ALSEC = ALValue &amp; RTC_SEC_MASK;
+		break;
+
+	case RTC_TIMETYPE_MINUTE:
+		CHECK_PARAM(ALValue &lt; RTC_MINUTE_MAX);
+
+		RTCx-&gt;ALMIN = ALValue &amp; RTC_MIN_MASK;
+		break;
+
+	case RTC_TIMETYPE_HOUR:
+		CHECK_PARAM(ALValue &lt; RTC_HOUR_MAX);
+
+		RTCx-&gt;ALHOUR = ALValue &amp; RTC_HOUR_MASK;
+		break;
+
+	case RTC_TIMETYPE_DAYOFWEEK:
+		CHECK_PARAM(ALValue &lt; RTC_DAYOFWEEK_MAX);
+
+		RTCx-&gt;ALDOW = ALValue &amp; RTC_DOW_MASK;
+		break;
+
+	case RTC_TIMETYPE_DAYOFMONTH:
+		CHECK_PARAM((ALValue &lt; RTC_DAYOFMONTH_MAX) \
+				&amp;&amp; (ALValue &gt; RTC_DAYOFMONTH_MIN));
+
+		RTCx-&gt;ALDOM = ALValue &amp; RTC_DOM_MASK;
+		break;
+
+	case RTC_TIMETYPE_DAYOFYEAR:
+		CHECK_PARAM((ALValue &gt; RTC_DAYOFYEAR_MIN) \
+				&amp;&amp; (ALValue &lt; RTC_DAYOFYEAR_MAX));
+
+		RTCx-&gt;ALDOY = ALValue &amp; RTC_DOY_MASK;
+		break;
+
+	case RTC_TIMETYPE_MONTH:
+		CHECK_PARAM((ALValue &gt; RTC_MONTH_MIN) \
+				&amp;&amp; (ALValue &lt; RTC_MONTH_MAX));
+
+		RTCx-&gt;ALMON = ALValue &amp; RTC_MONTH_MASK;
+		break;
+
+	case RTC_TIMETYPE_YEAR:
+		CHECK_PARAM(ALValue &lt; RTC_YEAR_MAX);
+
+		RTCx-&gt;ALYEAR = ALValue &amp; RTC_YEAR_MASK;
+		break;
+	}
+}
+
+
+
+/*********************************************************************//**
+ * @brief 		Get alarm time value for each time type
+ * @param[in]	RTCx	RTC peripheral selected, should be RTC
+ * @param[in]	Timetype: Time Type, should be:
+ * 				- RTC_TIMETYPE_SECOND
+ * 				- RTC_TIMETYPE_MINUTE
+ * 				- RTC_TIMETYPE_HOUR
+ * 				- RTC_TIMETYPE_DAYOFWEEK
+ * 				- RTC_TIMETYPE_DAYOFMONTH
+ * 				- RTC_TIMETYPE_DAYOFYEAR
+ * 				- RTC_TIMETYPE_MONTH
+ * 				- RTC_TIMETYPE_YEAR
+  * @return 	Value of Alarm time according to specified time type
+ **********************************************************************/
+uint32_t RTC_GetAlarmTime (LPC_RTC_TypeDef *RTCx, uint32_t Timetype)
+{
+	switch (Timetype)
+	{
+	case RTC_TIMETYPE_SECOND:
+		return (RTCx-&gt;ALSEC &amp; RTC_SEC_MASK);
+		break;
+	case RTC_TIMETYPE_MINUTE:
+		return (RTCx-&gt;ALMIN &amp; RTC_MIN_MASK);
+		break;
+	case RTC_TIMETYPE_HOUR:
+		return (RTCx-&gt;ALHOUR &amp; RTC_HOUR_MASK);
+		break;
+	case RTC_TIMETYPE_DAYOFWEEK:
+		return (RTCx-&gt;ALDOW &amp; RTC_DOW_MASK);
+		break;
+	case RTC_TIMETYPE_DAYOFMONTH:
+		return (RTCx-&gt;ALDOM &amp; RTC_DOM_MASK);
+		break;
+	case RTC_TIMETYPE_DAYOFYEAR:
+		return (RTCx-&gt;ALDOY &amp; RTC_DOY_MASK);
+		break;
+	case RTC_TIMETYPE_MONTH:
+		return (RTCx-&gt;ALMON &amp; RTC_MONTH_MASK);
+		break;
+	case RTC_TIMETYPE_YEAR:
+		return (RTCx-&gt;ALYEAR &amp; RTC_YEAR_MASK);
+		break;
+	default:
+		return (0);
+		break;
+	}
+}
+
+
+/*********************************************************************//**
+ * @brief 		Set full of alarm time in RTC peripheral
+ * @param[in]	RTCx	RTC peripheral selected, should be RTC
+ * @param[in]	pFullTime Pointer to a RTC_TIME_Type structure that
+ * 				contains alarm time value in full.
+ * @return 		None
+ **********************************************************************/
+void RTC_SetFullAlarmTime (LPC_RTC_TypeDef *RTCx, RTC_TIME_Type *pFullTime)
+{
+	CHECK_PARAM(PARAM_RTCx(RTCx));
+
+	RTCx-&gt;ALDOM = pFullTime-&gt;DOM &amp; RTC_DOM_MASK;
+	RTCx-&gt;ALDOW = pFullTime-&gt;DOW &amp; RTC_DOW_MASK;
+	RTCx-&gt;ALDOY = pFullTime-&gt;DOY &amp; RTC_DOY_MASK;
+	RTCx-&gt;ALHOUR = pFullTime-&gt;HOUR &amp; RTC_HOUR_MASK;
+	RTCx-&gt;ALMIN = pFullTime-&gt;MIN &amp; RTC_MIN_MASK;
+	RTCx-&gt;ALSEC = pFullTime-&gt;SEC &amp; RTC_SEC_MASK;
+	RTCx-&gt;ALMON = pFullTime-&gt;MONTH &amp; RTC_MONTH_MASK;
+	RTCx-&gt;ALYEAR = pFullTime-&gt;YEAR &amp; RTC_YEAR_MASK;
+}
+
+
+/*********************************************************************//**
+ * @brief 		Get full of alarm time in RTC peripheral
+ * @param[in]	RTCx	RTC peripheral selected, should be RTC
+ * @param[in]	pFullTime Pointer to a RTC_TIME_Type structure that
+ * 				will be stored alarm time in full.
+ * @return 		None
+ **********************************************************************/
+void RTC_GetFullAlarmTime (LPC_RTC_TypeDef *RTCx, RTC_TIME_Type *pFullTime)
+{
+	CHECK_PARAM(PARAM_RTCx(RTCx));
+
+	pFullTime-&gt;DOM = RTCx-&gt;ALDOM &amp; RTC_DOM_MASK;
+	pFullTime-&gt;DOW = RTCx-&gt;ALDOW &amp; RTC_DOW_MASK;
+	pFullTime-&gt;DOY = RTCx-&gt;ALDOY &amp; RTC_DOY_MASK;
+	pFullTime-&gt;HOUR = RTCx-&gt;ALHOUR &amp; RTC_HOUR_MASK;
+	pFullTime-&gt;MIN = RTCx-&gt;ALMIN &amp; RTC_MIN_MASK;
+	pFullTime-&gt;SEC = RTCx-&gt;ALSEC &amp; RTC_SEC_MASK;
+	pFullTime-&gt;MONTH = RTCx-&gt;ALMON &amp; RTC_MONTH_MASK;
+	pFullTime-&gt;YEAR = RTCx-&gt;ALYEAR &amp; RTC_YEAR_MASK;
+}
+
+
+/*********************************************************************//**
+ * @brief 		Check whether if specified Location interrupt in
+ * 				RTC peripheral is set or not
+ * @param[in]	RTCx	RTC peripheral selected, should be RTC
+ * @param[in]	IntType Interrupt location type, should be:
+ * 						- RTC_INT_COUNTER_INCREASE: Counter Increment Interrupt
+ * 							block generated an interrupt.
+ * 						- RTC_INT_ALARM: Alarm generated an
+ * 							interrupt.
+ * @return 		New state of specified Location interrupt in RTC peripheral
+ * 				(SET or RESET)
+ **********************************************************************/
+IntStatus RTC_GetIntPending (LPC_RTC_TypeDef *RTCx, uint32_t IntType)
+{
+	CHECK_PARAM(PARAM_RTCx(RTCx));
+	CHECK_PARAM(PARAM_RTC_INT(IntType));
+
+	return ((RTCx-&gt;ILR &amp; IntType) ? SET : RESET);
+}
+
+
+/*********************************************************************//**
+ * @brief 		Clear specified Location interrupt pending in
+ * 				RTC peripheral
+ * @param[in]	RTCx	RTC peripheral selected, should be RTC
+ * @param[in]	IntType Interrupt location type, should be:
+ * 						- RTC_INT_COUNTER_INCREASE: Clear Counter Increment
+ * 						Interrupt pending.
+ * 						- RTC_INT_ALARM: Clear alarm interrupt pending
+ * @return 		None
+ **********************************************************************/
+void RTC_ClearIntPending (LPC_RTC_TypeDef *RTCx, uint32_t IntType)
+{
+	CHECK_PARAM(PARAM_RTCx(RTCx));
+	CHECK_PARAM(PARAM_RTC_INT(IntType));
+
+	RTCx-&gt;ILR = IntType;
+}
+
+/*********************************************************************//**
+ * @brief 		Enable/Disable calibration counter in RTC peripheral
+ * @param[in]	RTCx	RTC peripheral selected, should be RTC
+ * @param[in]	NewState New State of this function, should be:
+ * 				- ENABLE: The calibration counter is enabled and counting
+ * 				- DISABLE: The calibration counter is disabled and reset to zero
+ * @return 		None
+ **********************************************************************/
+void RTC_CalibCounterCmd(LPC_RTC_TypeDef *RTCx, FunctionalState NewState)
+{
+	CHECK_PARAM(PARAM_RTCx(RTCx));
+	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
+
+	if (NewState == ENABLE)
+	{
+		RTCx-&gt;CCR &amp;= (~RTC_CCR_CCALEN) &amp; RTC_CCR_BITMASK;
+	}
+	else
+	{
+		RTCx-&gt;CCR |= RTC_CCR_CCALEN;
+	}
+}
+
+
+/*********************************************************************//**
+ * @brief 		Configures Calibration in RTC peripheral
+ * @param[in]	RTCx	RTC peripheral selected, should be RTC
+ * @param[in]	CalibValue Calibration value, should be in range from
+ * 					0 to 131,072
+ * @param[in]	CalibDir Calibration Direction, should be:
+ * 					- RTC_CALIB_DIR_FORWARD: Forward calibration
+ * 					- RTC_CALIB_DIR_BACKWARD: Backward calibration
+ * @return 		None
+ **********************************************************************/
+void RTC_CalibConfig(LPC_RTC_TypeDef *RTCx, uint32_t CalibValue, uint8_t CalibDir)
+{
+	CHECK_PARAM(PARAM_RTCx(RTCx));
+	CHECK_PARAM(PARAM_RTC_CALIB_DIR(CalibDir));
+	CHECK_PARAM(CalibValue &gt; RTC_CALIBRATION_MAX);
+
+	RTCx-&gt;CALIBRATION = ((CalibValue - 1) &amp; RTC_CALIBRATION_CALVAL_MASK) \
+			| ((CalibDir == RTC_CALIB_DIR_BACKWARD) ? RTC_CALIBRATION_LIBDIR : 0);
+}
+
+
+/*********************************************************************//**
+ * @brief 		Write value to General purpose registers
+ * @param[in]	RTCx	RTC peripheral selected, should be RTC
+ * @param[in]	Channel General purpose registers Channel number,
+ * 				should be in range from 0 to 4.
+ * @param[in]	Value Value to write
+ * @return 		None
+ * Note: These General purpose registers can be used to store important
+ * information when the main power supply is off. The value in these
+ * registers is not affected by chip reset.
+ **********************************************************************/
+void RTC_WriteGPREG (LPC_RTC_TypeDef *RTCx, uint8_t Channel, uint32_t Value)
+{
+	uint32_t *preg;
+
+	CHECK_PARAM(PARAM_RTCx(RTCx));
+	CHECK_PARAM(PARAM_RTC_GPREG_CH(Channel));
+
+	preg = (uint32_t *)&amp;RTCx-&gt;GPREG0;
+	preg += Channel;
+	*preg = Value;
+}
+
+
+/*********************************************************************//**
+ * @brief 		Read value from General purpose registers
+ * @param[in]	RTCx	RTC peripheral selected, should be RTC
+ * @param[in]	Channel General purpose registers Channel number,
+ * 				should be in range from 0 to 4.
+ * @return 		Read Value
+ * Note: These General purpose registers can be used to store important
+ * information when the main power supply is off. The value in these
+ * registers is not affected by chip reset.
+ **********************************************************************/
+uint32_t RTC_ReadGPREG (LPC_RTC_TypeDef *RTCx, uint8_t Channel)
+{
+	uint32_t *preg;
+	uint32_t value;
+
+	CHECK_PARAM(PARAM_RTCx(RTCx));
+	CHECK_PARAM(PARAM_RTC_GPREG_CH(Channel));
+
+	preg = (uint32_t *)&amp;RTCx-&gt;GPREG0;
+	preg += Channel;
+	value = *preg;
+	return (value);
+}
+
+/**
+ * @}
+ */
+
+#endif /* _RTC */
+
+/**
+ * @}
+ */
+
+/* --------------------------------- End Of File ------------------------------ */
+


Property changes on: trunk/src/platform/lpc17xx/drivers/src/lpc17xx_rtc.c
___________________________________________________________________
Deleted: svn:executable
   - *

Modified: trunk/src/platform/lpc17xx/drivers/src/lpc17xx_spi.c
===================================================================
--- trunk/src/platform/lpc17xx/drivers/src/lpc17xx_spi.c	2010-06-28 21:53:59 UTC (rev 759)
+++ trunk/src/platform/lpc17xx/drivers/src/lpc17xx_spi.c	2010-07-12 20:56:54 UTC (rev 760)
@@ -1,570 +1,562 @@
-/**
- * @file	: lpc17xx_spi.c
- * @brief	: Contains all functions support for SPI firmware library on LPC17xx
- * @version	: 1.0
- * @date	: 3. April. 2009
- * @author	: HieuNguyen
- *----------------------------------------------------------------------------
- * Software that is described herein is for illustrative purposes only
- * which provides customers with programming information regarding the
- * products. This software is supplied &quot;AS IS&quot; without any warranties.
- * NXP Semiconductors assumes no responsibility or liability for the
- * use of the software, conveys no license or title under any patent,
- * copyright, or mask work right to the product. NXP Semiconductors
- * reserves the right to make changes in the software without
- * notification. NXP Semiconductors also make no representation or
- * warranty that such application will be suitable for the specified
- * use without further testing or modification.
- **********************************************************************/
-
-/* Peripheral group ----------------------------------------------------------- */
-/** @addtogroup SPI
- * @{
- */
-
-/* Includes ------------------------------------------------------------------- */
-#include &quot;lpc17xx_spi.h&quot;
-#include &quot;lpc17xx_clkpwr.h&quot;
-
-/* If this source file built with example, the LPC17xx FW library configuration
- * file in each example directory (&quot;lpc17xx_libcfg.h&quot;) must be included,
- * otherwise the default FW library configuration file must be included instead
- */
-#ifdef __BUILD_WITH_EXAMPLE__
-#include &quot;lpc17xx_libcfg.h&quot;
-#else
-#include &quot;lpc17xx_libcfg_default.h&quot;
-#endif /* __BUILD_WITH_EXAMPLE__ */
-
-#ifdef _SPI
-
-/* Private Types -------------------------------------------------------------- */
-/** @defgroup SPI_Private_Types
- * @{
- */
-
-/** @brief SPI device configuration structure type */
-typedef struct
-{
-	int32_t 	dataword;				/* Current data word: 0 - 8 bit; 1 - 16 bit */
-	uint32_t    txrx_setup; 			/* Transmission setup */
-	void		(*inthandler)(void);   	/* Transmission interrupt handler */
-} SPI_CFG_T;
-
-/**
- * @}
- */
-
-
-/* Private Variables ---------------------------------------------------------- */
-/** @defgroup SPI_Private_Variables
- * @{
- */
-
-/* SPI configuration data */
-static SPI_CFG_T spidat;
-
-/**
- * @}
- */
-
-
-/* Private Functions ---------------------------------------------------------- */
-/** @defgroup SPI_Private_Functions
- * @{
- */
-
-/*********************************************************************//**
- * @brief 		Standard Private SPI Interrupt handler
- * @param		None
- * @return 		None
- ***********************************************************************/
-void SPI_IntHandler(void)
-{
-	SPI_DATA_SETUP_Type *xf_setup;
-    uint16_t tmp;
-
-    xf_setup = (SPI_DATA_SETUP_Type *)spidat.txrx_setup;
-
-    /* Dummy read to clear SPI interrupt flag */
-    if (SPI-&gt;SPINT &amp; SPI_SPINT_INTFLAG){
-    	SPI-&gt;SPINT = SPI_SPINT_INTFLAG;
-    }
-
-    // save status
-    tmp = SPI-&gt;SPSR;
-    xf_setup-&gt;status = tmp;
-    // Check for error
-    if (tmp &amp; (SPI_SPSR_ABRT | SPI_SPSR_MODF | SPI_SPSR_ROVR | SPI_SPSR_WCOL)){
-    	xf_setup-&gt;status |= SPI_STAT_ERROR;
-    	// Disable Interrupt and call call-back
-    	SPI_IntCmd(SPI, DISABLE);
-    	if (xf_setup-&gt;callback != NULL){
-    		xf_setup-&gt;callback();
-    	}
-    	return;
-    }
-
-    /* Check SPI complete flag */
-    if (tmp &amp; SPI_SPSR_SPIF){
-	   // Read data from SPI data
-		tmp = SPI_ReceiveData(SPI);
-		if (xf_setup-&gt;rx_data != NULL)
-		{
-//			if (spidat.dataword == 0){
-//				*(uint8_t *)(xf_setup-&gt;rx_data + xf_setup-&gt;counter) = (uint8_t) tmp;
-//			} else {
-//				*(uint16_t *)(xf_setup-&gt;rx_data + xf_setup-&gt;counter) = (uint8_t) tmp;
-//			}
-			if (spidat.dataword == 0){
-				*(uint8_t *)((uint8_t *)(xf_setup-&gt;rx_data) + xf_setup-&gt;counter) = (uint8_t) tmp;
-			} else {
-				*(uint16_t *)((uint8_t *)(xf_setup-&gt;rx_data) + xf_setup-&gt;counter) = (uint8_t) tmp;
-			}
-		}
-		// Increase counter
-		if (spidat.dataword == 0){
-			xf_setup-&gt;counter++;
-		} else {
-			xf_setup-&gt;counter += 2;
-		}
-    }
-
-    if (xf_setup-&gt;counter &lt; xf_setup-&gt;length){
-		// Write data to buffer
-		if(xf_setup-&gt;tx_data == NULL){
-			if (spidat.dataword == 0){
-				SPI_SendData(SPI, 0xFF);
-			} else {
-				SPI_SendData(SPI, 0xFFFF);
-			}
-		} else {
-//			if (spidat.dataword == 0){
-//				SPI_SendData(SPI, (*(uint8_t *)(xf_setup-&gt;tx_data + xf_setup-&gt;counter)));
-//			} else {
-//				SPI_SendData(SPI, (*(uint16_t *)(xf_setup-&gt;tx_data + xf_setup-&gt;counter)));
-//			}
-			if (spidat.dataword == 0){
-				SPI_SendData(SPI, (*(uint8_t *)((uint8_t *)(xf_setup-&gt;tx_data) + xf_setup-&gt;counter)));
-			} else {
-				SPI_SendData(SPI, (*(uint16_t *)((uint8_t *)(xf_setup-&gt;tx_data) + xf_setup-&gt;counter)));
-			}
-		}
-    }
-    // No more data to send
-	else {
-    	xf_setup-&gt;status |= SPI_STAT_DONE;
-    	// Disable Interrupt and call call-back
-    	SPI_IntCmd(SPI, DISABLE);
-    	if (xf_setup-&gt;callback != NULL){
-    		xf_setup-&gt;callback();
-    	}
-	}
-}
-
-
-/**
- * @}
- */
-
-/* Public Functions ----------------------------------------------------------- */
-/** @addtogroup SPI_Public_Functions
- * @{
- */
-
-/*********************************************************************//**
- * @brief 		Setup clock rate for SPI device
- * @param[in] 	SPIx	SPI peripheral definition, should be SPI
- * @param[in]	target_clock : clock of SPI (Hz)
- * @return 		None
- ***********************************************************************/
-void SPI_SetClock (SPI_TypeDef *SPIx, uint32_t target_clock)
-{
-	uint32_t spi_pclk;
-	uint32_t prescale, temp;
-
-	CHECK_PARAM(PARAM_SPIx(SPIx));
-
-	if (SPIx == SPI){
-		spi_pclk =  CLKPWR_GetPCLK (CLKPWR_PCLKSEL_SPI);
-	} else {
-		return;
-	}
-
-	prescale = 8;
-	// Find closest clock to target clock
-	while (1){
-		temp = target_clock * prescale;
-		if (temp &gt;= spi_pclk){
-			break;
-		}
-		prescale += 2;
-		if(prescale &gt;= 254){
-			break;
-		}
-	}
-
-	// Write to register
-	SPIx-&gt;SPCCR = SPI_SPCCR_COUNTER(prescale);
-}
-
-
-/*********************************************************************//**
- * @brief		De-initializes the SPIx peripheral registers to their
-*                  default reset values.
- * @param[in]	SPIx	SPI peripheral selected, should be SPI
- * @return 		None
- **********************************************************************/
-void SPI_DeInit(SPI_TypeDef *SPIx)
-{
-	CHECK_PARAM(PARAM_SPIx(SPIx));
-
-	if (SPIx == SPI){
-		/* Set up clock and power for SPI module */
-		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCSPI, DISABLE);
-	}
-}
-
-
-
-/********************************************************************//**
- * @brief		Initializes the SPIx peripheral according to the specified
-*               parameters in the UART_ConfigStruct.
- * @param[in]	SPIx	SPI peripheral selected, should be SPI
- * @param[in]	SPI_ConfigStruct Pointer to a SPI_CFG_Type structure
-*                    that contains the configuration information for the
-*                    specified SPI peripheral.
- * @return 		None
- *********************************************************************/
-void SPI_Init(SPI_TypeDef *SPIx, SPI_CFG_Type *SPI_ConfigStruct)
-{
-	uint32_t tmp;
-
-	CHECK_PARAM(PARAM_SPIx(SPIx));
-
-	if(SPIx == SPI){
-		/* Set up clock and power for UART module */
-		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCSPI, ENABLE);
-	} else {
-		return;
-	}
-
-	// Configure SPI, interrupt is disable as default
-	tmp = ((SPI_ConfigStruct-&gt;CPHA) | (SPI_ConfigStruct-&gt;CPOL) \
-		| (SPI_ConfigStruct-&gt;DataOrder) | (SPI_ConfigStruct-&gt;Databit) \
-		| (SPI_ConfigStruct-&gt;Mode) | SPI_SPCR_BIT_EN) &amp; SPI_SPCR_BITMASK;
-	// write back to SPI control register
-	SPIx-&gt;SPCR = tmp;
-
-	if (SPI_ConfigStruct-&gt;Databit &gt; SPI_DATABIT_8){
-		spidat.dataword = 1;
-	} else {
-		spidat.dataword = 0;
-	}
-
-	// Set clock rate for SPI peripheral
-	SPI_SetClock(SPIx, SPI_ConfigStruct-&gt;ClockRate);
-
-	// If interrupt flag is set, Write '1' to Clear interrupt flag
-	if (SPIx-&gt;SPINT &amp; SPI_SPINT_INTFLAG){
-		SPIx-&gt;SPINT = SPI_SPINT_INTFLAG;
-	}
-}
-
-
-
-/*****************************************************************************//**
-* @brief		Fills each SPI_InitStruct member with its default value:
-* 				- CPHA = SPI_CPHA_FIRST
-* 				- CPOL = SPI_CPOL_HI
-* 				- ClockRate = 1000000
-* 				- DataOrder = SPI_DATA_MSB_FIRST
-* 				- Databit = SPI_DATABIT_8
-* 				- Mode = SPI_MASTER_MODE
-* @param[in]	SPI_InitStruct Pointer to a SPI_CFG_Type structure
-*                    which will be initialized.
-* @return		None
-*******************************************************************************/
-void SPI_ConfigStructInit(SPI_CFG_Type *SPI_InitStruct)
-{
-	SPI_InitStruct-&gt;CPHA = SPI_CPHA_FIRST;
-	SPI_InitStruct-&gt;CPOL = SPI_CPOL_HI;
-	SPI_InitStruct-&gt;ClockRate = 1000000;
-	SPI_InitStruct-&gt;DataOrder = SPI_DATA_MSB_FIRST;
-	SPI_InitStruct-&gt;Databit = SPI_DATABIT_8;
-	SPI_InitStruct-&gt;Mode = SPI_MASTER_MODE;
-}
-
-/*********************************************************************//**
- * @brief		Transmit a single data through SPIx peripheral
- * @param[in]	SPIx	SPI peripheral selected, should be SPI
- * @param[in]	Data	Data to transmit (must be 16 or 8-bit long,
- * 						this depend on SPI data bit number configured)
- * @return 		none
- **********************************************************************/
-void SPI_SendData(SPI_TypeDef* SPIx, uint16_t Data)
-{
-	CHECK_PARAM(PARAM_SPIx(SPIx));
-
-	SPIx-&gt;SPDR = Data &amp; SPI_SPDR_BITMASK;
-}
-
-
-
-/*********************************************************************//**
- * @brief		Receive a single data from SPIx peripheral
- * @param[in]	SPIx	SPI peripheral selected, should be SPI
- * @return 		Data received (16-bit long)
- **********************************************************************/
-uint16_t SPI_ReceiveData(SPI_TypeDef* SPIx)
-{
-	CHECK_PARAM(PARAM_SPIx(SPIx));
-
-	return ((uint16_t) (SPIx-&gt;SPDR &amp; SPI_SPDR_BITMASK));
-}
-
-/*********************************************************************//**
- * @brief 		SPI 	Read write data function
- * @param[in]	SPIx 	Pointer to SPI peripheral, should be SPI
- * @param[in]	dataCfg	Pointer to a SPI_DATA_SETUP_Type structure that
- * 						contains specified information about transmit
- * 						data configuration.
- * @param[in]	xfType	Transfer type, should be:
- * 						- SPI_TRANSFER_POLLING: Polling mode
- * 						- SPI_TRANSFER_INTERRUPT: Interrupt mode
- * @return 		Actual Data length has been transferred in polling mode.
- * 				In interrupt mode, always return (0)
- * 				Return (-1) if error.
- * Note: This function can be used in both master and slave mode.
- ***********************************************************************/
-int32_t SPI_ReadWrite (SPI_TypeDef *SPIx, SPI_DATA_SETUP_Type *dataCfg, \
-						SPI_TRANSFER_Type xfType)
-{
-	uint8_t *rdata8;
-    uint8_t *wdata8;
-	uint16_t *rdata16;
-    uint16_t *wdata16;
-    uint32_t stat;
-    uint32_t temp;
-
-	//read for empty buffer
-	temp = SPIx-&gt;SPDR;
-	//dummy to clear status
-	temp = SPIx-&gt;SPSR;
-	dataCfg-&gt;counter = 0;
-	dataCfg-&gt;status = 0;
-
-	if (xfType == SPI_TRANSFER_POLLING){
-
-		if (spidat.dataword == 0){
-			rdata8 = (uint8_t *)dataCfg-&gt;rx_data;
-			wdata8 = (uint8_t *)dataCfg-&gt;tx_data;
-		} else {
-			rdata16 = (uint16_t *)dataCfg-&gt;rx_data;
-			wdata16 = (uint16_t *)dataCfg-&gt;tx_data;
-		}
-
-		while(dataCfg-&gt;counter &lt; dataCfg-&gt;length)
-		{
-			// Write data to buffer
-			if(dataCfg-&gt;tx_data == NULL){
-				if (spidat.dataword == 0){
-					SPI_SendData(SPIx, 0xFF);
-				} else {
-					SPI_SendData(SPIx, 0xFFFF);
-				}
-			} else {
-				if (spidat.dataword == 0){
-					SPI_SendData(SPIx, *wdata8);
-					wdata8++;
-				} else {
-					SPI_SendData(SPIx, *wdata16);
-					wdata16++;
-				}
-			}
-			// Wait for transfer complete
-			while (!((stat = SPIx-&gt;SPSR) &amp; SPI_SPSR_SPIF));
-			// Check for error
-			if (stat &amp; (SPI_SPSR_ABRT | SPI_SPSR_MODF | SPI_SPSR_ROVR | SPI_SPSR_WCOL)){
-				// save status
-				dataCfg-&gt;status = stat | SPI_STAT_ERROR;
-				return (dataCfg-&gt;counter);
-			}
-			// Read data from SPI dat
-			temp = (uint32_t) SPI_ReceiveData(SPIx);
-
-			// Store data to destination
-			if (dataCfg-&gt;rx_data != NULL)
-			{
-				if (spidat.dataword == 0){
-					*(rdata8) = (uint8_t) temp;
-					rdata8++;
-				} else {
-					*(rdata16) = (uint16_t) temp;
-					rdata16++;
-				}
-			}
-			// Increase counter
-			if (spidat.dataword == 0){
-				dataCfg-&gt;counter++;
-			} else {
-				dataCfg-&gt;counter += 2;
-			}
-		}
-
-		// Return length of actual data transferred
-		// save status
-		dataCfg-&gt;status = stat | SPI_STAT_DONE;
-		return (dataCfg-&gt;counter);
-	}
-	// Interrupt mode
-	else {
-		spidat.txrx_setup = (uint32_t)dataCfg;
-		spidat.inthandler = SPI_IntHandler;
-
-		// Check if interrupt flag is already set
-		if(SPIx-&gt;SPINT &amp; SPI_SPINT_INTFLAG){
-			SPIx-&gt;SPINT = SPI_SPINT_INTFLAG;
-		}
-		if (dataCfg-&gt;counter &lt; dataCfg-&gt;length){
-			// Write data to buffer
-			if(dataCfg-&gt;tx_data == NULL){
-				if (spidat.dataword == 0){
-					SPI_SendData(SPIx, 0xFF);
-				} else {
-					SPI_SendData(SPIx, 0xFFFF);
-				}
-			} else {
-				if (spidat.dataword == 0){
-					SPI_SendData(SPIx, (*(uint8_t *)dataCfg-&gt;tx_data));
-				} else {
-					SPI_SendData(SPIx, (*(uint16_t *)dataCfg-&gt;tx_data));
-				}
-			}
-			SPI_IntCmd(SPIx, ENABLE);
-		} else {
-			// Save status
-			dataCfg-&gt;status = SPI_STAT_DONE;
-		}
-		return (0);
-	}
-	return (0);
-}
-
-
-/********************************************************************//**
- * @brief 		Enable or disable SPIx interrupt.
- * @param[in]	SPIx	SPI peripheral selected, should be SPI
- * @param[in]	NewState New state of specified UART interrupt type,
- * 				should be:
- * 				- ENALBE: Enable this SPI interrupt.
-* 				- DISALBE: Disable this SPI interrupt.
- * @return 		None
- *********************************************************************/
-void SPI_IntCmd(SPI_TypeDef *SPIx, FunctionalState NewState)
-{
-	CHECK_PARAM(PARAM_SPIx(SPIx));
-	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
-
-	if (NewState == ENABLE)
-	{
-		SPIx-&gt;SPCR |= SPI_SPCR_SPIE;
-	}
-	else
-	{
-		SPIx-&gt;SPCR &amp;= (~SPI_SPCR_SPIE) &amp; SPI_SPCR_BITMASK;
-	}
-}
-
-
-/********************************************************************//**
- * @brief 		Checks whether the SPI interrupt flag is set or not.
- * @param[in]	SPIx	SPI peripheral selected, should be SPI
- * @return 		The new state of SPI Interrupt Flag (SET or RESET)
- *********************************************************************/
-IntStatus SPI_GetIntStatus (SPI_TypeDef *SPIx)
-{
-	CHECK_PARAM(PARAM_SPIx(SPIx));
-
-	return ((SPIx-&gt;SPINT &amp; SPI_SPINT_INTFLAG) ? SET : RESET);
-}
-
-
-/********************************************************************//**
- * @brief 		Clear SPI interrupt flag.
- * @param[in]	SPIx	SPI peripheral selected, should be SPI
- * @return 		None
- *********************************************************************/
-void SPI_ClearIntPending(SPI_TypeDef *SPIx)
-{
-	CHECK_PARAM(PARAM_SPIx(SPIx));
-
-	SPIx-&gt;SPINT = SPI_SPINT_INTFLAG;
-}
-
-
-/********************************************************************//**
- * @brief 		Get current value of SPI Status register in SPIx peripheral.
- * @param[in]	SPIx	SPI peripheral selected, should be SPI
- * @return		Current value of SPI Status register in SPI peripheral.
- * Note:	The return value of this function must be used with
- * 			SPI_CheckStatus() to determine current flag status
- * 			corresponding to each SPI status type. Because some flags in
- * 			SPI Status register will be cleared after reading, the next reading
- * 			SPI Status register could not be correct. So this function used to
- * 			read SPI status register in one time only, then the return value
- * 			used to check all flags.
- *********************************************************************/
-uint32_t SPI_GetStatus(SPI_TypeDef* SPIx)
-{
-	CHECK_PARAM(PARAM_SPIx(SPIx));
-
-	return (SPIx-&gt;SPSR &amp; SPI_SPSR_BITMASK);
-}
-
-
-
-/********************************************************************//**
- * @brief 		Checks whether the specified SPI Status flag is set or not
- * 				via inputSPIStatus parameter.
- * @param[in]	inputSPIStatus Value to check status of each flag type.
- * 				This value is the return value from SPI_GetStatus().
- * @param[in]	SPIStatus	Specifies the SPI status flag to check,
- * 				should be one of the following:
-				- SPI_STAT_ABRT: Slave abort.
-				- SPI_STAT_MODF: Mode fault.
-				- SPI_STAT_ROVR: Read overrun.
-				- SPI_STAT_WCOL: Write collision.
-				- SPI_STAT_SPIF: SPI transfer complete.
- * @return 		The new state of SPIStatus (SET or RESET)
- *********************************************************************/
-FlagStatus SPI_CheckStatus (uint32_t inputSPIStatus,  uint8_t SPIStatus)
-{
-	CHECK_PARAM(PARAM_SPI_STAT(SPIStatus));
-
-	return ((inputSPIStatus &amp; SPIStatus) ? SET : RESET);
-}
-
-/**
- * @brief		Standard SPI Interrupt handler
- * @param[in] 	None
- * @return		None
- */
-void SPI_StdIntHandler(void)
-{
-	// Call relevant handler
-	spidat.inthandler();
-}
-
-
-/**
- * @}
- */
-
-#endif /* _SPI */
-
-/**
- * @}
- */
-
-/* --------------------------------- End Of File ------------------------------ */
+/**
+ * @file	: lpc17xx_spi.c
+ * @brief	: Contains all functions support for SPI firmware library on LPC17xx
+ * @version	: 1.0
+ * @date	: 3. April. 2009
+ * @author	: HieuNguyen
+ **************************************************************************
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * products. This software is supplied &quot;AS IS&quot; without any warranties.
+ * NXP Semiconductors assumes no responsibility or liability for the
+ * use of the software, conveys no license or title under any patent,
+ * copyright, or mask work right to the product. NXP Semiconductors
+ * reserves the right to make changes in the software without
+ * notification. NXP Semiconductors also make no representation or
+ * warranty that such application will be suitable for the specified
+ * use without further testing or modification.
+ **********************************************************************/
+
+/* Peripheral group ----------------------------------------------------------- */
+/** @addtogroup SPI
+ * @{
+ */
+
+/* Includes ------------------------------------------------------------------- */
+#include &quot;lpc17xx_spi.h&quot;
+#include &quot;lpc17xx_clkpwr.h&quot;
+
+/* If this source file built with example, the LPC17xx FW library configuration
+ * file in each example directory (&quot;lpc17xx_libcfg.h&quot;) must be included,
+ * otherwise the default FW library configuration file must be included instead
+ */
+#ifdef __BUILD_WITH_EXAMPLE__
+#include &quot;lpc17xx_libcfg.h&quot;
+#else
+#include &quot;lpc17xx_libcfg_default.h&quot;
+#endif /* __BUILD_WITH_EXAMPLE__ */
+
+#ifdef _SPI
+
+/* Private Types -------------------------------------------------------------- */
+/** @defgroup SPI_Private_Types
+ * @{
+ */
+
+/** @brief SPI device configuration structure type */
+typedef struct
+{
+	int32_t 	dataword;				/* Current data word: 0 - 8 bit; 1 - 16 bit */
+	uint32_t    txrx_setup; 			/* Transmission setup */
+	void		(*inthandler)(void);   	/* Transmission interrupt handler */
+} SPI_CFG_T;
+
+/**
+ * @}
+ */
+
+
+/* Private Variables ---------------------------------------------------------- */
+/* SPI configuration data */
+static SPI_CFG_T spidat;
+
+
+/* Private Functions ---------------------------------------------------------- */
+/** @defgroup SPI_Private_Functions
+ * @{
+ */
+
+/*********************************************************************//**
+ * @brief 		Standard Private SPI Interrupt handler
+ * @param[in]	None
+ * @return 		None
+ ***********************************************************************/
+void SPI_IntHandler(void)
+{
+	SPI_DATA_SETUP_Type *xf_setup;
+    uint16_t tmp;
+
+    xf_setup = (SPI_DATA_SETUP_Type *)spidat.txrx_setup;
+
+    /* Dummy read to clear SPI interrupt flag */
+    if (LPC_SPI-&gt;SPINT &amp; SPI_SPINT_INTFLAG){
+    	LPC_SPI-&gt;SPINT = SPI_SPINT_INTFLAG;
+    }
+
+    // save status
+    tmp = LPC_SPI-&gt;SPSR;
+    xf_setup-&gt;status = tmp;
+    // Check for error
+    if (tmp &amp; (SPI_SPSR_ABRT | SPI_SPSR_MODF | SPI_SPSR_ROVR | SPI_SPSR_WCOL)){
+    	xf_setup-&gt;status |= SPI_STAT_ERROR;
+    	// Disable Interrupt and call call-back
+    	SPI_IntCmd(LPC_SPI, DISABLE);
+    	if (xf_setup-&gt;callback != NULL){
+    		xf_setup-&gt;callback();
+    	}
+    	return;
+    }
+
+    /* Check SPI complete flag */
+    if (tmp &amp; SPI_SPSR_SPIF){
+	   // Read data from SPI data
+		tmp = SPI_ReceiveData(LPC_SPI);
+		if (xf_setup-&gt;rx_data != NULL)
+		{
+//			if (spidat.dataword == 0){
+//				*(uint8_t *)(xf_setup-&gt;rx_data + xf_setup-&gt;counter) = (uint8_t) tmp;
+//			} else {
+//				*(uint16_t *)(xf_setup-&gt;rx_data + xf_setup-&gt;counter) = (uint8_t) tmp;
+//			}
+			if (spidat.dataword == 0){
+				*(uint8_t *)((uint8_t *)(xf_setup-&gt;rx_data) + xf_setup-&gt;counter) = (uint8_t) tmp;
+			} else {
+				*(uint16_t *)((uint8_t *)(xf_setup-&gt;rx_data) + xf_setup-&gt;counter) = (uint8_t) tmp;
+			}
+		}
+		// Increase counter
+		if (spidat.dataword == 0){
+			xf_setup-&gt;counter++;
+		} else {
+			xf_setup-&gt;counter += 2;
+		}
+    }
+
+    if (xf_setup-&gt;counter &lt; xf_setup-&gt;length){
+		// Write data to buffer
+		if(xf_setup-&gt;tx_data == NULL){
+			if (spidat.dataword == 0){
+				SPI_SendData(LPC_SPI, 0xFF);
+			} else {
+				SPI_SendData(LPC_SPI, 0xFFFF);
+			}
+		} else {
+//			if (spidat.dataword == 0){
+//				SPI_SendData(SPI, (*(uint8_t *)(xf_setup-&gt;tx_data + xf_setup-&gt;counter)));
+//			} else {
+//				SPI_SendData(SPI, (*(uint16_t *)(xf_setup-&gt;tx_data + xf_setup-&gt;counter)));
+//			}
+			if (spidat.dataword == 0){
+				SPI_SendData(LPC_SPI, (*(uint8_t *)((uint8_t *)(xf_setup-&gt;tx_data) + xf_setup-&gt;counter)));
+			} else {
+				SPI_SendData(LPC_SPI, (*(uint16_t *)((uint8_t *)(xf_setup-&gt;tx_data) + xf_setup-&gt;counter)));
+			}
+		}
+    }
+    // No more data to send
+	else {
+    	xf_setup-&gt;status |= SPI_STAT_DONE;
+    	// Disable Interrupt and call call-back
+    	SPI_IntCmd(LPC_SPI, DISABLE);
+    	if (xf_setup-&gt;callback != NULL){
+    		xf_setup-&gt;callback();
+    	}
+	}
+}
+
+
+/**
+ * @}
+ */
+
+/* Public Functions ----------------------------------------------------------- */
+/** @addtogroup SPI_Public_Functions
+ * @{
+ */
+
+/*********************************************************************//**
+ * @brief 		Setup clock rate for SPI device
+ * @param[in] 	SPIx	SPI peripheral definition, should be SPI
+ * @param[in]	target_clock : clock of SPI (Hz)
+ * @return 		None
+ ***********************************************************************/
+void SPI_SetClock (LPC_SPI_TypeDef *SPIx, uint32_t target_clock)
+{
+	uint32_t spi_pclk;
+	uint32_t prescale, temp;
+
+	CHECK_PARAM(PARAM_SPIx(SPIx));
+
+	if (SPIx == LPC_SPI){
+		spi_pclk =  CLKPWR_GetPCLK (CLKPWR_PCLKSEL_SPI);
+	} else {
+		return;
+	}
+
+	prescale = 8;
+	// Find closest clock to target clock
+	while (1){
+		temp = target_clock * prescale;
+		if (temp &gt;= spi_pclk){
+			break;
+		}
+		prescale += 2;
+		if(prescale &gt;= 254){
+			break;
+		}
+	}
+
+	// Write to register
+	SPIx-&gt;SPCCR = SPI_SPCCR_COUNTER(prescale);
+}
+
+
+/*********************************************************************//**
+ * @brief		De-initializes the SPIx peripheral registers to their
+*                  default reset values.
+ * @param[in]	SPIx	SPI peripheral selected, should be SPI
+ * @return 		None
+ **********************************************************************/
+void SPI_DeInit(LPC_SPI_TypeDef *SPIx)
+{
+	CHECK_PARAM(PARAM_SPIx(SPIx));
+
+	if (SPIx == LPC_SPI){
+		/* Set up clock and power for SPI module */
+		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCSPI, DISABLE);
+	}
+}
+
+
+
+/********************************************************************//**
+ * @brief		Initializes the SPIx peripheral according to the specified
+*               parameters in the UART_ConfigStruct.
+ * @param[in]	SPIx	SPI peripheral selected, should be SPI
+ * @param[in]	SPI_ConfigStruct Pointer to a SPI_CFG_Type structure
+*                    that contains the configuration information for the
+*                    specified SPI peripheral.
+ * @return 		None
+ *********************************************************************/
+void SPI_Init(LPC_SPI_TypeDef *SPIx, SPI_CFG_Type *SPI_ConfigStruct)
+{
+	uint32_t tmp;
+
+	CHECK_PARAM(PARAM_SPIx(SPIx));
+
+	if(SPIx == LPC_SPI){
+		/* Set up clock and power for UART module */
+		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCSPI, ENABLE);
+	} else {
+		return;
+	}
+
+	// Configure SPI, interrupt is disable as default
+	tmp = ((SPI_ConfigStruct-&gt;CPHA) | (SPI_ConfigStruct-&gt;CPOL) \
+		| (SPI_ConfigStruct-&gt;DataOrder) | (SPI_ConfigStruct-&gt;Databit) \
+		| (SPI_ConfigStruct-&gt;Mode) | SPI_SPCR_BIT_EN) &amp; SPI_SPCR_BITMASK;
+	// write back to SPI control register
+	SPIx-&gt;SPCR = tmp;
+
+	if (SPI_ConfigStruct-&gt;Databit &gt; SPI_DATABIT_8){
+		spidat.dataword = 1;
+	} else {
+		spidat.dataword = 0;
+	}
+
+	// Set clock rate for SPI peripheral
+	SPI_SetClock(SPIx, SPI_ConfigStruct-&gt;ClockRate);
+
+	// If interrupt flag is set, Write '1' to Clear interrupt flag
+	if (SPIx-&gt;SPINT &amp; SPI_SPINT_INTFLAG){
+		SPIx-&gt;SPINT = SPI_SPINT_INTFLAG;
+	}
+}
+
+
+
+/*****************************************************************************//**
+* @brief		Fills each SPI_InitStruct member with its default value:
+* 				- CPHA = SPI_CPHA_FIRST
+* 				- CPOL = SPI_CPOL_HI
+* 				- ClockRate = 1000000
+* 				- DataOrder = SPI_DATA_MSB_FIRST
+* 				- Databit = SPI_DATABIT_8
+* 				- Mode = SPI_MASTER_MODE
+* @param[in]	SPI_InitStruct Pointer to a SPI_CFG_Type structure
+*                    which will be initialized.
+* @return		None
+*******************************************************************************/
+void SPI_ConfigStructInit(SPI_CFG_Type *SPI_InitStruct)
+{
+	SPI_InitStruct-&gt;CPHA = SPI_CPHA_FIRST;
+	SPI_InitStruct-&gt;CPOL = SPI_CPOL_HI;
+	SPI_InitStruct-&gt;ClockRate = 1000000;
+	SPI_InitStruct-&gt;DataOrder = SPI_DATA_MSB_FIRST;
+	SPI_InitStruct-&gt;Databit = SPI_DATABIT_8;
+	SPI_InitStruct-&gt;Mode = SPI_MASTER_MODE;
+}
+
+/*********************************************************************//**
+ * @brief		Transmit a single data through SPIx peripheral
+ * @param[in]	SPIx	SPI peripheral selected, should be SPI
+ * @param[in]	Data	Data to transmit (must be 16 or 8-bit long,
+ * 						this depend on SPI data bit number configured)
+ * @return 		none
+ **********************************************************************/
+void SPI_SendData(LPC_SPI_TypeDef* SPIx, uint16_t Data)
+{
+	CHECK_PARAM(PARAM_SPIx(SPIx));
+
+	SPIx-&gt;SPDR = Data &amp; SPI_SPDR_BITMASK;
+}
+
+
+
+/*********************************************************************//**
+ * @brief		Receive a single data from SPIx peripheral
+ * @param[in]	SPIx	SPI peripheral selected, should be SPI
+ * @return 		Data received (16-bit long)
+ **********************************************************************/
+uint16_t SPI_ReceiveData(LPC_SPI_TypeDef* SPIx)
+{
+	CHECK_PARAM(PARAM_SPIx(SPIx));
+
+	return ((uint16_t) (SPIx-&gt;SPDR &amp; SPI_SPDR_BITMASK));
+}
+
+/*********************************************************************//**
+ * @brief 		SPI 	Read write data function
+ * @param[in]	SPIx 	Pointer to SPI peripheral, should be SPI
+ * @param[in]	dataCfg	Pointer to a SPI_DATA_SETUP_Type structure that
+ * 						contains specified information about transmit
+ * 						data configuration.
+ * @param[in]	xfType	Transfer type, should be:
+ * 						- SPI_TRANSFER_POLLING: Polling mode
+ * 						- SPI_TRANSFER_INTERRUPT: Interrupt mode
+ * @return 		Actual Data length has been transferred in polling mode.
+ * 				In interrupt mode, always return (0)
+ * 				Return (-1) if error.
+ * Note: This function can be used in both master and slave mode.
+ ***********************************************************************/
+int32_t SPI_ReadWrite (LPC_SPI_TypeDef *SPIx, SPI_DATA_SETUP_Type *dataCfg, \
+						SPI_TRANSFER_Type xfType)
+{
+	uint8_t *rdata8;
+    uint8_t *wdata8;
+	uint16_t *rdata16;
+    uint16_t *wdata16;
+    uint32_t stat;
+    uint32_t temp;
+
+	//read for empty buffer
+	temp = SPIx-&gt;SPDR;
+	//dummy to clear status
+	temp = SPIx-&gt;SPSR;
+	dataCfg-&gt;counter = 0;
+	dataCfg-&gt;status = 0;
+
+	if (xfType == SPI_TRANSFER_POLLING){
+
+		if (spidat.dataword == 0){
+			rdata8 = (uint8_t *)dataCfg-&gt;rx_data;
+			wdata8 = (uint8_t *)dataCfg-&gt;tx_data;
+		} else {
+			rdata16 = (uint16_t *)dataCfg-&gt;rx_data;
+			wdata16 = (uint16_t *)dataCfg-&gt;tx_data;
+		}
+
+		while(dataCfg-&gt;counter &lt; dataCfg-&gt;length)
+		{
+			// Write data to buffer
+			if(dataCfg-&gt;tx_data == NULL){
+				if (spidat.dataword == 0){
+					SPI_SendData(SPIx, 0xFF);
+				} else {
+					SPI_SendData(SPIx, 0xFFFF);
+				}
+			} else {
+				if (spidat.dataword == 0){
+					SPI_SendData(SPIx, *wdata8);
+					wdata8++;
+				} else {
+					SPI_SendData(SPIx, *wdata16);
+					wdata16++;
+				}
+			}
+			// Wait for transfer complete
+			while (!((stat = SPIx-&gt;SPSR) &amp; SPI_SPSR_SPIF));
+			// Check for error
+			if (stat &amp; (SPI_SPSR_ABRT | SPI_SPSR_MODF | SPI_SPSR_ROVR | SPI_SPSR_WCOL)){
+				// save status
+				dataCfg-&gt;status = stat | SPI_STAT_ERROR;
+				return (dataCfg-&gt;counter);
+			}
+			// Read data from SPI dat
+			temp = (uint32_t) SPI_ReceiveData(SPIx);
+
+			// Store data to destination
+			if (dataCfg-&gt;rx_data != NULL)
+			{
+				if (spidat.dataword == 0){
+					*(rdata8) = (uint8_t) temp;
+					rdata8++;
+				} else {
+					*(rdata16) = (uint16_t) temp;
+					rdata16++;
+				}
+			}
+			// Increase counter
+			if (spidat.dataword == 0){
+				dataCfg-&gt;counter++;
+			} else {
+				dataCfg-&gt;counter += 2;
+			}
+		}
+
+		// Return length of actual data transferred
+		// save status
+		dataCfg-&gt;status = stat | SPI_STAT_DONE;
+		return (dataCfg-&gt;counter);
+	}
+	// Interrupt mode
+	else {
+		spidat.txrx_setup = (uint32_t)dataCfg;
+		spidat.inthandler = SPI_IntHandler;
+
+		// Check if interrupt flag is already set
+		if(SPIx-&gt;SPINT &amp; SPI_SPINT_INTFLAG){
+			SPIx-&gt;SPINT = SPI_SPINT_INTFLAG;
+		}
+		if (dataCfg-&gt;counter &lt; dataCfg-&gt;length){
+			// Write data to buffer
+			if(dataCfg-&gt;tx_data == NULL){
+				if (spidat.dataword == 0){
+					SPI_SendData(SPIx, 0xFF);
+				} else {
+					SPI_SendData(SPIx, 0xFFFF);
+				}
+			} else {
+				if (spidat.dataword == 0){
+					SPI_SendData(SPIx, (*(uint8_t *)dataCfg-&gt;tx_data));
+				} else {
+					SPI_SendData(SPIx, (*(uint16_t *)dataCfg-&gt;tx_data));
+				}
+			}
+			SPI_IntCmd(SPIx, ENABLE);
+		} else {
+			// Save status
+			dataCfg-&gt;status = SPI_STAT_DONE;
+		}
+		return (0);
+	}
+	return (0);
+}
+
+
+/********************************************************************//**
+ * @brief 		Enable or disable SPIx interrupt.
+ * @param[in]	SPIx	SPI peripheral selected, should be SPI
+ * @param[in]	NewState New state of specified UART interrupt type,
+ * 				should be:
+ * 				- ENALBE: Enable this SPI interrupt.
+* 				- DISALBE: Disable this SPI interrupt.
+ * @return 		None
+ *********************************************************************/
+void SPI_IntCmd(LPC_SPI_TypeDef *SPIx, FunctionalState NewState)
+{
+	CHECK_PARAM(PARAM_SPIx(SPIx));
+	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
+
+	if (NewState == ENABLE)
+	{
+		SPIx-&gt;SPCR |= SPI_SPCR_SPIE;
+	}
+	else
+	{
+		SPIx-&gt;SPCR &amp;= (~SPI_SPCR_SPIE) &amp; SPI_SPCR_BITMASK;
+	}
+}
+
+
+/********************************************************************//**
+ * @brief 		Checks whether the SPI interrupt flag is set or not.
+ * @param[in]	SPIx	SPI peripheral selected, should be SPI
+ * @return 		The new state of SPI Interrupt Flag (SET or RESET)
+ *********************************************************************/
+IntStatus SPI_GetIntStatus (LPC_SPI_TypeDef *SPIx)
+{
+	CHECK_PARAM(PARAM_SPIx(SPIx));
+
+	return ((SPIx-&gt;SPINT &amp; SPI_SPINT_INTFLAG) ? SET : RESET);
+}
+
+
+/********************************************************************//**
+ * @brief 		Clear SPI interrupt flag.
+ * @param[in]	SPIx	SPI peripheral selected, should be SPI
+ * @return 		None
+ *********************************************************************/
+void SPI_ClearIntPending(LPC_SPI_TypeDef *SPIx)
+{
+	CHECK_PARAM(PARAM_SPIx(SPIx));
+
+	SPIx-&gt;SPINT = SPI_SPINT_INTFLAG;
+}
+
+
+/********************************************************************//**
+ * @brief 		Get current value of SPI Status register in SPIx peripheral.
+ * @param[in]	SPIx	SPI peripheral selected, should be SPI
+ * @return		Current value of SPI Status register in SPI peripheral.
+ * Note:	The return value of this function must be used with
+ * 			SPI_CheckStatus() to determine current flag status
+ * 			corresponding to each SPI status type. Because some flags in
+ * 			SPI Status register will be cleared after reading, the next reading
+ * 			SPI Status register could not be correct. So this function used to
+ * 			read SPI status register in one time only, then the return value
+ * 			used to check all flags.
+ *********************************************************************/
+uint32_t SPI_GetStatus(LPC_SPI_TypeDef* SPIx)
+{
+	CHECK_PARAM(PARAM_SPIx(SPIx));
+
+	return (SPIx-&gt;SPSR &amp; SPI_SPSR_BITMASK);
+}
+
+
+
+/********************************************************************//**
+ * @brief 		Checks whether the specified SPI Status flag is set or not
+ * 				via inputSPIStatus parameter.
+ * @param[in]	inputSPIStatus Value to check status of each flag type.
+ * 				This value is the return value from SPI_GetStatus().
+ * @param[in]	SPIStatus	Specifies the SPI status flag to check,
+ * 				should be one of the following:
+				- SPI_STAT_ABRT: Slave abort.
+				- SPI_STAT_MODF: Mode fault.
+				- SPI_STAT_ROVR: Read overrun.
+				- SPI_STAT_WCOL: Write collision.
+				- SPI_STAT_SPIF: SPI transfer complete.
+ * @return 		The new state of SPIStatus (SET or RESET)
+ *********************************************************************/
+FlagStatus SPI_CheckStatus (uint32_t inputSPIStatus,  uint8_t SPIStatus)
+{
+	CHECK_PARAM(PARAM_SPI_STAT(SPIStatus));
+
+	return ((inputSPIStatus &amp; SPIStatus) ? SET : RESET);
+}
+
+/**
+ * @brief		Standard SPI Interrupt handler
+ * @param[in] 	None
+ * @return		None
+ */
+void SPI_StdIntHandler(void)
+{
+	// Call relevant handler
+	spidat.inthandler();
+}
+
+
+/**
+ * @}
+ */
+
+#endif /* _SPI */
+
+/**
+ * @}
+ */
+
+/* --------------------------------- End Of File ------------------------------ */


Property changes on: trunk/src/platform/lpc17xx/drivers/src/lpc17xx_spi.c
___________________________________________________________________
Deleted: svn:executable
   - *

Modified: trunk/src/platform/lpc17xx/drivers/src/lpc17xx_ssp.c
===================================================================
--- trunk/src/platform/lpc17xx/drivers/src/lpc17xx_ssp.c	2010-06-28 21:53:59 UTC (rev 759)
+++ trunk/src/platform/lpc17xx/drivers/src/lpc17xx_ssp.c	2010-07-12 20:56:54 UTC (rev 760)
@@ -1,838 +1,831 @@
-/**
- * @file	: lpc17xx_ssp.c
- * @brief	: Contains all functions support for SSP firmware library on LPC17xx
- * @version	: 1.0
- * @date	: 9. April. 2009
- * @author	: HieuNguyen
- *----------------------------------------------------------------------------
- * Software that is described herein is for illustrative purposes only
- * which provides customers with programming information regarding the
- * products. This software is supplied &quot;AS IS&quot; without any warranties.
- * NXP Semiconductors assumes no responsibility or liability for the
- * use of the software, conveys no license or title under any patent,
- * copyright, or mask work right to the product. NXP Semiconductors
- * reserves the right to make changes in the software without
- * notification. NXP Semiconductors also make no representation or
- * warranty that such application will be suitable for the specified
- * use without further testing or modification.
- **********************************************************************/
-
-/* Peripheral group ----------------------------------------------------------- */
-/** @addtogroup SSP
- * @{
- */
-
-/* Includes ------------------------------------------------------------------- */
-#include &quot;lpc17xx_ssp.h&quot;
-#include &quot;lpc17xx_clkpwr.h&quot;
-
-
-/* If this source file built with example, the LPC17xx FW library configuration
- * file in each example directory (&quot;lpc17xx_libcfg.h&quot;) must be included,
- * otherwise the default FW library configuration file must be included instead
- */
-#ifdef __BUILD_WITH_EXAMPLE__
-#include &quot;lpc17xx_libcfg.h&quot;
-#else
-#include &quot;lpc17xx_libcfg_default.h&quot;
-#endif /* __BUILD_WITH_EXAMPLE__ */
-
-
-#ifdef _SSP
-
-/* Private Types -------------------------------------------------------------- */
-/** @defgroup SSP_Private_Types
- * @{
- */
-
-/** @brief SSP device configuration structure type */
-typedef struct
-{
-	int32_t 	dataword;				/* Current data word: 0 - 8 bit; 1 - 16 bit */
-	uint32_t    txrx_setup; 			/* Transmission setup */
-	void		(*inthandler)(SSP_TypeDef *SSPx);   	/* Transmission interrupt handler */
-} SSP_CFG_T;
-
-/**
- * @}
- */
-
-/* Private Variables ---------------------------------------------------------- */
-/** @defgroup SSP_Private_Variables
- * @{
- */
-
-/* SSP configuration data */
-static SSP_CFG_T sspdat[2];
-
-/**
- * @}
- */
-
-
-/* Private Functions ---------------------------------------------------------- */
-/** @defgroup SSP_Private_Functions
- * @{
- */
-
-/**
- * @brief Convert from SSP peripheral to number
- */
-static int32_t SSP_getNum(SSP_TypeDef *SSPx){
-	if (SSPx == SSP0) {
-		return (0);
-	} else if (SSPx == SSP1) {
-		return (1);
-	}
-	return (-1);
-}
-
-
-/*********************************************************************//**
- * @brief 		Standard Private SSP Interrupt handler
- * @param		None
- * @return 		None
- ***********************************************************************/
-void SSP_IntHandler(SSP_TypeDef *SSPx)
-{
-	SSP_DATA_SETUP_Type *xf_setup;
-    uint16_t tmp;
-    int32_t sspnum;
-
-    // Disable interrupt
-    SSPx-&gt;IMSC = 0;
-
-    sspnum = SSP_getNum(SSPx);
-    xf_setup = (SSP_DATA_SETUP_Type *)sspdat[sspnum].txrx_setup;
-
-    // save status
-    tmp = SSPx-&gt;RIS;
-    xf_setup-&gt;status = tmp;
-
-    // Check overrun error
-    if (tmp &amp; SSP_RIS_ROR){
-    	// Clear interrupt
-    	SSPx-&gt;ICR = SSP_RIS_ROR;
-    	// update status
-    	xf_setup-&gt;status |= SSP_STAT_ERROR;
-    	// Callback
-    	if (xf_setup-&gt;callback != NULL){
-    		xf_setup-&gt;callback();
-    	}
-    	return;
-    }
-
-    if ((xf_setup-&gt;tx_cnt != xf_setup-&gt;length) || (xf_setup-&gt;rx_cnt != xf_setup-&gt;length)){
-    	/* check if RX FIFO contains data */
-		while ((SSPx-&gt;SR &amp; SSP_SR_RNE) &amp;&amp; (xf_setup-&gt;rx_cnt != xf_setup-&gt;length)){
-			// Read data from SSP data
-			tmp = SSP_ReceiveData(SSPx);
-
-			// Store data to destination
-			if (xf_setup-&gt;rx_data != NULL)
-			{
-				if (sspdat[sspnum].dataword == 0){
-					*(uint8_t *)((uint32_t)xf_setup-&gt;rx_data + xf_setup-&gt;rx_cnt) = (uint8_t) tmp;
-				} else {
-					*(uint16_t *)((uint32_t)xf_setup-&gt;rx_data + xf_setup-&gt;rx_cnt) = (uint16_t) tmp;
-				}
-			}
-			// Increase counter
-			if (sspdat[sspnum].dataword == 0){
-				xf_setup-&gt;rx_cnt++;
-			} else {
-				xf_setup-&gt;rx_cnt += 2;
-			}
-		}
-
-		while ((SSPx-&gt;SR &amp; SSP_SR_TNF) &amp;&amp; (xf_setup-&gt;tx_cnt != xf_setup-&gt;length)){
-			// Write data to buffer
-			if(xf_setup-&gt;tx_data == NULL){
-				if (sspdat[sspnum].dataword == 0){
-					SSP_SendData(SSPx, 0xFF);
-					xf_setup-&gt;tx_cnt++;
-				} else {
-					SSP_SendData(SSPx, 0xFFFF);
-					xf_setup-&gt;tx_cnt += 2;
-				}
-			} else {
-				if (sspdat[sspnum].dataword == 0){
-					SSP_SendData(SSPx, (*(uint8_t *)((uint32_t)xf_setup-&gt;tx_data + xf_setup-&gt;tx_cnt)));
-					xf_setup-&gt;tx_cnt++;
-				} else {
-					SSP_SendData(SSPx, (*(uint16_t *)((uint32_t)xf_setup-&gt;tx_data + xf_setup-&gt;tx_cnt)));
-					xf_setup-&gt;tx_cnt += 2;
-				}
-			}
-
-		    // Check overrun error
-		    if ((tmp = SSPx-&gt;RIS) &amp; SSP_RIS_ROR){
-		    	// update status
-		    	xf_setup-&gt;status |= SSP_STAT_ERROR;
-		    	// Callback
-		    	if (xf_setup-&gt;callback != NULL){
-		    		xf_setup-&gt;callback();
-		    	}
-		    	return;
-		    }
-
-			// Check for any data available in RX FIFO
-			while ((SSPx-&gt;SR &amp; SSP_SR_RNE) &amp;&amp; (xf_setup-&gt;rx_cnt != xf_setup-&gt;length)){
-				// Read data from SSP data
-				tmp = SSP_ReceiveData(SSPx);
-
-				// Store data to destination
-				if (xf_setup-&gt;rx_data != NULL)
-				{
-					if (sspdat[sspnum].dataword == 0){
-						*(uint8_t *)((uint32_t)xf_setup-&gt;rx_data + xf_setup-&gt;rx_cnt) = (uint8_t) tmp;
-					} else {
-						*(uint16_t *)((uint32_t)xf_setup-&gt;rx_data + xf_setup-&gt;rx_cnt) = (uint16_t) tmp;
-					}
-				}
-				// Increase counter
-				if (sspdat[sspnum].dataword == 0){
-					xf_setup-&gt;rx_cnt++;
-				} else {
-					xf_setup-&gt;rx_cnt += 2;
-				}
-			}
-		}
-    }
-
-	// If there more data to sent or receive
-	if ((xf_setup-&gt;rx_cnt != xf_setup-&gt;length) || (xf_setup-&gt;tx_cnt != xf_setup-&gt;length)){
-		// Enable all interrupt
-		SSPx-&gt;IMSC = SSP_IMSC_BITMASK;
-	} else {
-		// Save status
-		xf_setup-&gt;status = SSP_STAT_DONE;
-		// Callback
-		if (xf_setup-&gt;callback != NULL){
-			xf_setup-&gt;callback();
-		}
-	}
-}
-
-/**
- * @}
- */
-
-
-/* Public Functions ----------------------------------------------------------- */
-/** @addtogroup SSP_Public_Functions
- * @{
- */
-
-/*********************************************************************//**
- * @brief 		Setup clock rate for SSP device
- * @param[in] 	SSPx	SSP peripheral definition, should be
- * 						SSP0 or SSP1.
- * @param[in]	target_clock : clock of SSP (Hz)
- * @return 		None
- ***********************************************************************/
-void SSP_SetClock (SSP_TypeDef *SSPx, uint32_t target_clock)
-{
-    uint32_t prescale, cr0_div, cmp_clk, ssp_clk;
-
-    CHECK_PARAM(PARAM_SSPx(SSPx));
-
-    /* The SSP clock is derived from the (main system oscillator / 2),
-       so compute the best divider from that clock */
-    if (SSPx == SSP0){
-    	ssp_clk = CLKPWR_GetPCLK (CLKPWR_PCLKSEL_SSP0);
-    } else if (SSPx == SSP1) {
-    	ssp_clk = CLKPWR_GetPCLK (CLKPWR_PCLKSEL_SSP1);
-    } else {
-    	return;
-    }
-
-	/* Find closest divider to get at or under the target frequency.
-	   Use smallest prescale possible and rely on the divider to get
-	   the closest target frequency */
-	cr0_div = 0;
-	cmp_clk = 0xFFFFFFFF;
-	prescale = 2;
-	while (cmp_clk &gt; target_clock)
-	{
-		cmp_clk = ssp_clk / ((cr0_div + 1) * prescale);
-		if (cmp_clk &gt; target_clock)
-		{
-			cr0_div++;
-			if (cr0_div &gt; 0xFF)
-			{
-				cr0_div = 0;
-				prescale += 2;
-			}
-		}
-	}
-
-    /* Write computed prescaler and divider back to register */
-    SSPx-&gt;CR0 &amp;= (~SSP_CR0_SCR(0xFF)) &amp; SSP_CR0_BITMASK;
-    SSPx-&gt;CR0 |= (SSP_CR0_SCR(cr0_div)) &amp; SSP_CR0_BITMASK;
-    SSPx-&gt;CPSR = prescale &amp; SSP_CPSR_BITMASK;
-}
-
-
-/*********************************************************************//**
- * @brief		De-initializes the SSPx peripheral registers to their
-*                  default reset values.
- * @param[in]	SSPx	SSP peripheral selected, should be SSP0 or SSP1
- * @return 		None
- **********************************************************************/
-void SSP_DeInit(SSP_TypeDef* SSPx)
-{
-	CHECK_PARAM(PARAM_SSPx(SSPx));
-
-	if (SSPx == SSP0){
-		/* Set up clock and power for SSP0 module */
-		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCSSP0, DISABLE);
-	} else if (SSPx == SSP1) {
-		/* Set up clock and power for SSP1 module */
-		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCSSP1, DISABLE);
-	}
-}
-
-
-
-/********************************************************************//**
- * @brief		Initializes the SSPx peripheral according to the specified
-*               parameters in the SSP_ConfigStruct.
- * @param[in]	SSPx	SSP peripheral selected, should be SSP0 or SSP1
- * @param[in]	SSP_ConfigStruct Pointer to a SSP_CFG_Type structure
-*                    that contains the configuration information for the
-*                    specified SSP peripheral.
- * @return 		None
- *********************************************************************/
-void SSP_Init(SSP_TypeDef *SSPx, SSP_CFG_Type *SSP_ConfigStruct)
-{
-	uint32_t tmp;
-
-	CHECK_PARAM(PARAM_SSPx(SSPx));
-
-	if(SSPx == SSP0) {
-		/* Set up clock and power for SSP0 module */
-		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCSSP0, ENABLE);
-	} else if(SSPx == SSP1) {
-		/* Set up clock and power for SSP1 module */
-		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCSSP1, ENABLE);
-	} else {
-		return;
-	}
-
-	/* Configure SSP, interrupt is disable, LoopBack mode is disable,
-	 * SSP is disable, Slave output is disable as default
-	 */
-	tmp = ((SSP_ConfigStruct-&gt;CPHA) | (SSP_ConfigStruct-&gt;CPOL) \
-		| (SSP_ConfigStruct-&gt;FrameFormat) | (SSP_ConfigStruct-&gt;Databit))
-		&amp; SSP_CR0_BITMASK;
-	// write back to SSP control register
-	SSPx-&gt;CR0 = tmp;
-	tmp = SSP_getNum(SSPx);
-	if (SSP_ConfigStruct-&gt;Databit &gt; SSP_DATABIT_8){
-		sspdat[tmp].dataword = 1;
-	} else {
-		sspdat[tmp].dataword = 0;
-	}
-
-	tmp = SSP_ConfigStruct-&gt;Mode &amp; SSP_CR1_BITMASK;
-	// Write back to CR1
-	SSPx-&gt;CR1 = tmp;
-
-	// Set clock rate for SSP peripheral
-	SSP_SetClock(SSPx, SSP_ConfigStruct-&gt;ClockRate);
-}
-
-
-
-/*****************************************************************************//**
-* @brief		Fills each SSP_InitStruct member with its default value:
-* 				- CPHA = SSP_CPHA_FIRST
-* 				- CPOL = SSP_CPOL_HI
-* 				- ClockRate = 1000000
-* 				- Databit = SSP_DATABIT_8
-* 				- Mode = SSP_MASTER_MODE
-* 				- FrameFormat = SSP_FRAME_SSP
-* @param[in]	SSP_InitStruct Pointer to a SSP_CFG_Type structure
-*                    which will be initialized.
-* @return		None
-*******************************************************************************/
-void SSP_ConfigStructInit(SSP_CFG_Type *SSP_InitStruct)
-{
-	SSP_InitStruct-&gt;CPHA = SSP_CPHA_FIRST;
-	SSP_InitStruct-&gt;CPOL = SSP_CPOL_HI;
-	SSP_InitStruct-&gt;ClockRate = 1000000;
-	SSP_InitStruct-&gt;Databit = SSP_DATABIT_8;
-	SSP_InitStruct-&gt;Mode = SSP_MASTER_MODE;
-	SSP_InitStruct-&gt;FrameFormat = SSP_FRAME_SPI;
-}
-
-
-/*********************************************************************//**
- * @brief		Enable or disable SSP peripheral's operation
- * @param[in]	SSPx	SSP peripheral, should be SSP0 or SSP1
- * @param[in]	NewState New State of SSPx peripheral's operation
- * @return 		none
- **********************************************************************/
-void SSP_Cmd(SSP_TypeDef* SSPx, FunctionalState NewState)
-{
-	CHECK_PARAM(PARAM_SSPx(SSPx));
-	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
-
-	if (NewState == ENABLE)
-	{
-		SSPx-&gt;CR1 |= SSP_CR1_SSP_EN;
-	}
-	else
-	{
-		SSPx-&gt;CR1 &amp;= (~SSP_CR1_SSP_EN) &amp; SSP_CR1_BITMASK;
-	}
-}
-
-
-
-/*********************************************************************//**
- * @brief		Enable or disable Loop Back mode function in SSP peripheral
- * @param[in]	SSPx	SSP peripheral selected, should be SSP0 or SSP1
- * @param[in]	NewState	New State of Loop Back mode, should be:
- * 							- ENABLE: Enable this function
- * 							- DISABLE: Disable this function
- * @return 		None
- **********************************************************************/
-void SSP_LoopBackCmd(SSP_TypeDef* SSPx, FunctionalState NewState)
-{
-	CHECK_PARAM(PARAM_SSPx(SSPx));
-	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
-
-	if (NewState == ENABLE)
-	{
-		SSPx-&gt;CR1 |= SSP_CR1_LBM_EN;
-	}
-	else
-	{
-		SSPx-&gt;CR1 &amp;= (~SSP_CR1_LBM_EN) &amp; SSP_CR1_BITMASK;
-	}
-}
-
-
-
-/*********************************************************************//**
- * @brief		Enable or disable Slave Output function in SSP peripheral
- * @param[in]	SSPx	SSP peripheral selected, should be SSP0 or SSP1
- * @param[in]	NewState	New State of Slave Output function, should be:
- * 							- ENABLE: Slave Output in normal operation
- * 							- DISABLE: Slave Output is disabled. This blocks
- * 							SSP controller from driving the transmit data
- * 							line (MISO)
- * Note: 		This function is available when SSP peripheral in Slave mode
- * @return 		None
- **********************************************************************/
-void SSP_SlaveOutputCmd(SSP_TypeDef* SSPx, FunctionalState NewState)
-{
-	CHECK_PARAM(PARAM_SSPx(SSPx));
-	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
-
-	if (NewState == ENABLE)
-	{
-		SSPx-&gt;CR1 &amp;= (~SSP_CR1_SO_DISABLE) &amp; SSP_CR1_BITMASK;
-	}
-	else
-	{
-		SSPx-&gt;CR1 |= SSP_CR1_SO_DISABLE;
-	}
-}
-
-
-
-/*********************************************************************//**
- * @brief		Transmit a single data through SSPx peripheral
- * @param[in]	SSPx	SSP peripheral selected, should be SSP
- * @param[in]	Data	Data to transmit (must be 16 or 8-bit long,
- * 						this depend on SSP data bit number configured)
- * @return 		none
- **********************************************************************/
-void SSP_SendData(SSP_TypeDef* SSPx, uint16_t Data)
-{
-	CHECK_PARAM(PARAM_SSPx(SSPx));
-
-	SSPx-&gt;DR = SSP_DR_BITMASK(Data);
-}
-
-
-
-/*********************************************************************//**
- * @brief		Receive a single data from SSPx peripheral
- * @param[in]	SSPx	SSP peripheral selected, should be SSP
- * @return 		Data received (16-bit long)
- **********************************************************************/
-uint16_t SSP_ReceiveData(SSP_TypeDef* SSPx)
-{
-	CHECK_PARAM(PARAM_SSPx(SSPx));
-
-	return ((uint16_t) (SSP_DR_BITMASK(SSPx-&gt;DR)));
-}
-
-/*********************************************************************//**
- * @brief 		SSP Read write data function
- * @param[in]	SSPx 	Pointer to SSP peripheral, should be SSP0 or SSP1
- * @param[in]	dataCfg	Pointer to a SSP_DATA_SETUP_Type structure that
- * 						contains specified information about transmit
- * 						data configuration.
- * @param[in]	xfType	Transfer type, should be:
- * 						- SSP_TRANSFER_POLLING: Polling mode
- * 						- SSP_TRANSFER_INTERRUPT: Interrupt mode
- * @return 		Actual Data length has been transferred in polling mode.
- * 				In interrupt mode, always return (0)
- * 				Return (-1) if error.
- * Note: This function can be used in both master and slave mode.
- ***********************************************************************/
-int32_t SSP_ReadWrite (SSP_TypeDef *SSPx, SSP_DATA_SETUP_Type *dataCfg, \
-						SSP_TRANSFER_Type xfType)
-{
-	uint8_t *rdata8;
-    uint8_t *wdata8;
-	uint16_t *rdata16;
-    uint16_t *wdata16;
-    uint32_t stat;
-    uint32_t tmp;
-    int32_t sspnum;
-    int32_t dataword;
-
-    dataCfg-&gt;rx_cnt = 0;
-    dataCfg-&gt;tx_cnt = 0;
-    dataCfg-&gt;status = 0;
-
-
-	/* Clear all remaining data in RX FIFO */
-	while (SSPx-&gt;SR &amp; SSP_SR_RNE){
-		tmp = (uint32_t) SSP_ReceiveData(SSPx);
-	}
-
-	// Clear status
-	SSPx-&gt;ICR = SSP_ICR_BITMASK;
-
-	sspnum = SSP_getNum(SSPx);
-	dataword = sspdat[sspnum].dataword;
-
-	// Polling mode ----------------------------------------------------------------------
-	if (xfType == SSP_TRANSFER_POLLING){
-		if (dataword == 0){
-			rdata8 = (uint8_t *)dataCfg-&gt;rx_data;
-			wdata8 = (uint8_t *)dataCfg-&gt;tx_data;
-		} else {
-			rdata16 = (uint16_t *)dataCfg-&gt;rx_data;
-			wdata16 = (uint16_t *)dataCfg-&gt;tx_data;
-		}
-		while ((dataCfg-&gt;tx_cnt != dataCfg-&gt;length) || (dataCfg-&gt;rx_cnt != dataCfg-&gt;length)){
-			if ((SSPx-&gt;SR &amp; SSP_SR_TNF) &amp;&amp; (dataCfg-&gt;tx_cnt != dataCfg-&gt;length)){
-				// Write data to buffer
-				if(dataCfg-&gt;tx_data == NULL){
-					if (dataword == 0){
-						SSP_SendData(SSPx, 0xFF);
-						dataCfg-&gt;tx_cnt++;
-					} else {
-						SSP_SendData(SSPx, 0xFFFF);
-						dataCfg-&gt;tx_cnt += 2;
-					}
-				} else {
-					if (dataword == 0){
-						SSP_SendData(SSPx, *wdata8);
-						wdata8++;
-						dataCfg-&gt;tx_cnt++;
-					} else {
-						SSP_SendData(SSPx, *wdata16);
-						wdata16++;
-						dataCfg-&gt;tx_cnt += 2;
-					}
-				}
-			}
-
-			// Check overrun error
-			if ((stat = SSPx-&gt;RIS) &amp; SSP_RIS_ROR){
-				// save status and return
-				dataCfg-&gt;status = stat | SSP_STAT_ERROR;
-				return (-1);
-			}
-
-			// Check for any data available in RX FIFO
-			while ((SSPx-&gt;SR &amp; SSP_SR_RNE) &amp;&amp; (dataCfg-&gt;rx_cnt != dataCfg-&gt;length)){
-				// Read data from SSP data
-				tmp = SSP_ReceiveData(SSPx);
-
-				// Store data to destination
-				if (dataCfg-&gt;rx_data != NULL)
-				{
-					if (dataword == 0){
-						*(rdata8) = (uint8_t) tmp;
-						rdata8++;
-					} else {
-						*(rdata16) = (uint16_t) tmp;
-						rdata16++;
-					}
-				}
-				// Increase counter
-				if (dataword == 0){
-					dataCfg-&gt;rx_cnt++;
-				} else {
-					dataCfg-&gt;rx_cnt += 2;
-				}
-			}
-		}
-
-		// save status
-		dataCfg-&gt;status = SSP_STAT_DONE;
-
-		if (dataCfg-&gt;tx_data != NULL){
-			return dataCfg-&gt;tx_cnt;
-		} else if (dataCfg-&gt;rx_data != NULL){
-			return dataCfg-&gt;rx_cnt;
-		} else {
-			return (0);
-		}
-	}
-
-	// Interrupt mode ----------------------------------------------------------------------
-	else if (xfType == SSP_TRANSFER_INTERRUPT){
-		sspdat[sspnum].inthandler = SSP_IntHandler;
-		sspdat[sspnum].txrx_setup = (uint32_t)dataCfg;
-
-		while ((SSPx-&gt;SR &amp; SSP_SR_TNF) &amp;&amp; (dataCfg-&gt;tx_cnt != dataCfg-&gt;length)){
-			// Write data to buffer
-			if(dataCfg-&gt;tx_data == NULL){
-				if (sspdat[sspnum].dataword == 0){
-					SSP_SendData(SSPx, 0xFF);
-					dataCfg-&gt;tx_cnt++;
-				} else {
-					SSP_SendData(SSPx, 0xFFFF);
-					dataCfg-&gt;tx_cnt += 2;
-				}
-			} else {
-				if (sspdat[sspnum].dataword == 0){
-					SSP_SendData(SSPx, (*(uint8_t *)((uint32_t)dataCfg-&gt;tx_data + dataCfg-&gt;tx_cnt)));
-					dataCfg-&gt;tx_cnt++;
-				} else {
-					SSP_SendData(SSPx, (*(uint16_t *)((uint32_t)dataCfg-&gt;tx_data + dataCfg-&gt;tx_cnt)));
-					dataCfg-&gt;tx_cnt += 2;
-				}
-			}
-
-			// Check error
-			if ((stat = SSPx-&gt;RIS) &amp; SSP_RIS_ROR){
-				// save status and return
-				dataCfg-&gt;status = stat | SSP_STAT_ERROR;
-				return (-1);
-			}
-
-			// Check for any data available in RX FIFO
-			while ((SSPx-&gt;SR &amp; SSP_SR_RNE) &amp;&amp; (dataCfg-&gt;rx_cnt != dataCfg-&gt;length)){
-				// Read data from SSP data
-				tmp = SSP_ReceiveData(SSPx);
-
-				// Store data to destination
-				if (dataCfg-&gt;rx_data != NULL)
-				{
-					if (sspdat[sspnum].dataword == 0){
-						*(uint8_t *)((uint32_t)dataCfg-&gt;rx_data + dataCfg-&gt;rx_cnt) = (uint8_t) tmp;
-					} else {
-						*(uint16_t *)((uint32_t)dataCfg-&gt;rx_data + dataCfg-&gt;rx_cnt) = (uint16_t) tmp;
-					}
-				}
-				// Increase counter
-				if (sspdat[sspnum].dataword == 0){
-					dataCfg-&gt;rx_cnt++;
-				} else {
-					dataCfg-&gt;rx_cnt += 2;
-				}
-			}
-		}
-
-		// If there more data to sent or receive
-		if ((dataCfg-&gt;rx_cnt != dataCfg-&gt;length) || (dataCfg-&gt;tx_cnt != dataCfg-&gt;length)){
-			// Enable all interrupt
-			SSPx-&gt;IMSC = SSP_IMSC_BITMASK;
-		} else {
-			// Save status
-			dataCfg-&gt;status = SSP_STAT_DONE;
-		}
-		return (0);
-	}
-
-	return (-1);
-}
-
-/*********************************************************************//**
- * @brief		Checks whether the specified SSP status flag is set or not
- * @param[in]	SSPx	SSP peripheral selected, should be SSP0 or SSP1
- * @param[in]	FlagType	Type of flag to check status, should be one
- * 							of following:
- *							- SSP_STAT_TXFIFO_EMPTY: TX FIFO is empty
- *							- SSP_STAT_TXFIFO_NOTFULL: TX FIFO is not full
- *							- SSP_STAT_RXFIFO_NOTEMPTY: RX FIFO is not empty
- *							- SSP_STAT_RXFIFO_FULL: RX FIFO is full
- *							- SSP_STAT_BUSY: SSP peripheral is busy
- * @return		New State of specified SSP status flag
- **********************************************************************/
-FlagStatus SSP_GetStatus(SSP_TypeDef* SSPx, uint32_t FlagType)
-{
-	CHECK_PARAM(PARAM_SSPx(SSPx));
-	CHECK_PARAM(PARAM_SSP_STAT(FlagType));
-
-	return ((SSPx-&gt;SR &amp; FlagType) ? SET : RESET);
-}
-
-
-
-/*********************************************************************//**
- * @brief		Enable or disable specified interrupt type in SSP peripheral
- * @param[in]	SSPx	SSP peripheral selected, should be SSP0 or SSP1
- * @param[in]	IntType	Interrupt type in SSP peripheral, should be:
- * 				- SSP_INTCFG_ROR: Receive Overrun interrupt
- * 				- SSP_INTCFG_RT: Receive Time out interrupt
- * 				- SSP_INTCFG_RX: RX FIFO is at least half full interrupt
- * 				- SSP_INTCFG_TX: TX FIFO is at least half empty interrupt
- * @param[in]	NewState New State of specified interrupt type, should be:
- * 				- ENABLE: Enable this interrupt type
- * 				- DISABLE: Disable this interrupt type
- * @return		None
- **********************************************************************/
-void SSP_IntConfig(SSP_TypeDef *SSPx, uint32_t IntType, FunctionalState NewState)
-{
-	CHECK_PARAM(PARAM_SSPx(SSPx));
-	CHECK_PARAM(PARAM_SSP_INTCFG(IntType));
-
-	if (NewState == ENABLE)
-	{
-		SSPx-&gt;IMSC |= IntType;
-	}
-	else
-	{
-		SSPx-&gt;IMSC &amp;= (~IntType) &amp; SSP_IMSC_BITMASK;
-	}
-}
-
-
-/*********************************************************************//**
- * @brief	Check whether the specified Raw interrupt status flag is
- * 			set or not
- * @param[in]	SSPx	SSP peripheral selected, should be SSP0 or SSP1
- * @param[in]	RawIntType	Raw Interrupt Type, should be:
- * 				- SSP_INTSTAT_RAW_ROR: Receive Overrun interrupt
- * 				- SSP_INTSTAT_RAW_RT: Receive Time out interrupt
- * 				- SSP_INTSTAT_RAW_RX: RX FIFO is at least half full interrupt
- * 				- SSP_INTSTAT_RAW_TX: TX FIFO is at least half empty interrupt
- * @return	New State of specified Raw interrupt status flag in SSP peripheral
- * Note: Enabling/Disabling specified interrupt in SSP peripheral does not
- * 		effect to Raw Interrupt Status flag.
- **********************************************************************/
-IntStatus SSP_GetRawIntStatus(SSP_TypeDef *SSPx, uint32_t RawIntType)
-{
-	CHECK_PARAM(PARAM_SSPx(SSPx));
-	CHECK_PARAM(PARAM_SSP_INTSTAT_RAW(RawIntType));
-
-	return ((SSPx-&gt;RIS &amp; RawIntType) ? SET : RESET);
-}
-
-
-/*********************************************************************//**
- * @brief	Check whether the specified interrupt status flag is
- * 			set or not
- * @param[in]	SSPx	SSP peripheral selected, should be SSP0 or SSP1
- * @param[in]	RawIntType	Raw Interrupt Type, should be:
- * 				- SSP_INTSTAT_ROR: Receive Overrun interrupt
- * 				- SSP_INTSTAT_RT: Receive Time out interrupt
- * 				- SSP_INTSTAT_RX: RX FIFO is at least half full interrupt
- * 				- SSP_INTSTAT_TX: TX FIFO is at least half empty interrupt
- * @return	New State of specified interrupt status flag in SSP peripheral
- * Note: Enabling/Disabling specified interrupt in SSP peripheral effects
- * 			to Interrupt Status flag.
- **********************************************************************/
-IntStatus SSP_GetIntStatus (SSP_TypeDef *SSPx, uint32_t IntType)
-{
-	CHECK_PARAM(PARAM_SSPx(SSPx));
-	CHECK_PARAM(PARAM_SSP_INTSTAT(IntType));
-
-	return ((SSPx-&gt;MIS &amp; IntType) ? SET :RESET);
-}
-
-
-
-/*********************************************************************//**
- * @brief				Clear specified interrupt pending in SSP peripheral
- * @param[in]	SSPx	SSP peripheral selected, should be SSP0 or SSP1
- * @param[in]	IntType	Interrupt pending to clear, should be:
- * 						- SSP_INTCLR_ROR: clears the &quot;frame was received when
- * 						RxFIFO was full&quot; interrupt.
- * 						- SSP_INTCLR_RT: clears the &quot;Rx FIFO was not empty and
- * 						has not been read for a timeout period&quot; interrupt.
- * @return		None
- **********************************************************************/
-void SSP_ClearIntPending(SSP_TypeDef *SSPx, uint32_t IntType)
-{
-	CHECK_PARAM(PARAM_SSPx(SSPx));
-	CHECK_PARAM(PARAM_SSP_INTCLR(IntType));
-
-	SSPx-&gt;ICR = IntType;
-}
-
-/*********************************************************************//**
- * @brief				Enable/Disable DMA function for SSP peripheral
- * @param[in]	SSPx	SSP peripheral selected, should be SSP0 or SSP1
- * @param[in]	DMAMode	Type of DMA, should be:
- * 						- SSP_DMA_TX: DMA for the transmit FIFO
- * 						- SSP_DMA_RX: DMA for the Receive FIFO
- * @param[in]	NewState	New State of DMA function on SSP peripheral,
- * 						should be:
- * 						- ENALBE: Enable this function
- * 						- DISABLE: Disable this function
- * @return		None
- **********************************************************************/
-void SSP_DMACmd(SSP_TypeDef *SSPx, uint32_t DMAMode, FunctionalState NewState)
-{
-	CHECK_PARAM(PARAM_SSPx(SSPx));
-	CHECK_PARAM(PARAM_SSP_DMA(DMAMode));
-	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
-
-	if (NewState == ENABLE)
-	{
-		SSPx-&gt;DMACR |= DMAMode;
-	}
-	else
-	{
-		SSPx-&gt;DMACR &amp;= (~DMAMode) &amp; SSP_DMA_BITMASK;
-	}
-}
-
-/**
- * @brief		Standard SSP0 Interrupt handler
- * @param[in] 	None
- * @return		None
- */
-void SSP0_StdIntHandler(void)
-{
-	// Call relevant handler
-	sspdat[0].inthandler(SSP0);
-}
-
-/**
- * @brief		Standard SSP1 Interrupt handler
- * @param[in] 	None
- * @return		None
- */
-void SSP1_StdIntHandler(void)
-{
-	// Call relevant handler
-	sspdat[1].inthandler(SSP1);
-}
-
-/**
- * @}
- */
-
-#endif /* _SSP */
-
-/**
- * @}
- */
-
-/* --------------------------------- End Of File ------------------------------ */
-
+/**
+ * @file	: lpc17xx_ssp.c
+ * @brief	: Contains all functions support for SSP firmware library on LPC17xx
+ * @version	: 1.0
+ * @date	: 9. April. 2009
+ * @author	: HieuNguyen
+ **************************************************************************
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * products. This software is supplied &quot;AS IS&quot; without any warranties.
+ * NXP Semiconductors assumes no responsibility or liability for the
+ * use of the software, conveys no license or title under any patent,
+ * copyright, or mask work right to the product. NXP Semiconductors
+ * reserves the right to make changes in the software without
+ * notification. NXP Semiconductors also make no representation or
+ * warranty that such application will be suitable for the specified
+ * use without further testing or modification.
+ **********************************************************************/
+
+/* Peripheral group ----------------------------------------------------------- */
+/** @addtogroup SSP
+ * @{
+ */
+
+/* Includes ------------------------------------------------------------------- */
+#include &quot;lpc17xx_ssp.h&quot;
+#include &quot;lpc17xx_clkpwr.h&quot;
+
+
+/* If this source file built with example, the LPC17xx FW library configuration
+ * file in each example directory (&quot;lpc17xx_libcfg.h&quot;) must be included,
+ * otherwise the default FW library configuration file must be included instead
+ */
+#ifdef __BUILD_WITH_EXAMPLE__
+#include &quot;lpc17xx_libcfg.h&quot;
+#else
+#include &quot;lpc17xx_libcfg_default.h&quot;
+#endif /* __BUILD_WITH_EXAMPLE__ */
+
+
+#ifdef _SSP
+
+/* Private Types -------------------------------------------------------------- */
+/** @defgroup SSP_Private_Types
+ * @{
+ */
+
+/** @brief SSP device configuration structure type */
+typedef struct
+{
+	int32_t 	dataword;				/* Current data word: 0 - 8 bit; 1 - 16 bit */
+	uint32_t    txrx_setup; 			/* Transmission setup */
+	void		(*inthandler)(LPC_SSP_TypeDef *SSPx);   	/* Transmission interrupt handler */
+} SSP_CFG_T;
+
+/**
+ * @}
+ */
+
+/* Private Variables ---------------------------------------------------------- */
+/* SSP configuration data */
+static SSP_CFG_T sspdat[2];
+
+
+/* Private Functions ---------------------------------------------------------- */
+/** @defgroup SSP_Private_Functions
+ * @{
+ */
+
+/**
+ * @brief Convert from SSP peripheral to number
+ */
+static int32_t SSP_getNum(LPC_SSP_TypeDef *SSPx){
+	if (SSPx == LPC_SSP0) {
+		return (0);
+	} else if (SSPx == LPC_SSP1) {
+		return (1);
+	}
+	return (-1);
+}
+
+
+/*********************************************************************//**
+ * @brief 		Standard Private SSP Interrupt handler
+ * @param		SSPx: SSP peripheral definition, should be
+ * 					  SSP0 or SSP1.
+ * @return 		None
+ ***********************************************************************/
+void SSP_IntHandler(LPC_SSP_TypeDef *SSPx)
+{
+	SSP_DATA_SETUP_Type *xf_setup;
+    uint16_t tmp;
+    int32_t sspnum;
+
+    // Disable interrupt
+    SSPx-&gt;IMSC = 0;
+
+    sspnum = SSP_getNum(SSPx);
+    xf_setup = (SSP_DATA_SETUP_Type *)sspdat[sspnum].txrx_setup;
+
+    // save status
+    tmp = SSPx-&gt;RIS;
+    xf_setup-&gt;status = tmp;
+
+    // Check overrun error
+    if (tmp &amp; SSP_RIS_ROR){
+    	// Clear interrupt
+    	SSPx-&gt;ICR = SSP_RIS_ROR;
+    	// update status
+    	xf_setup-&gt;status |= SSP_STAT_ERROR;
+    	// Callback
+    	if (xf_setup-&gt;callback != NULL){
+    		xf_setup-&gt;callback();
+    	}
+    	return;
+    }
+
+    if ((xf_setup-&gt;tx_cnt != xf_setup-&gt;length) || (xf_setup-&gt;rx_cnt != xf_setup-&gt;length)){
+    	/* check if RX FIFO contains data */
+		while ((SSPx-&gt;SR &amp; SSP_SR_RNE) &amp;&amp; (xf_setup-&gt;rx_cnt != xf_setup-&gt;length)){
+			// Read data from SSP data
+			tmp = SSP_ReceiveData(SSPx);
+
+			// Store data to destination
+			if (xf_setup-&gt;rx_data != NULL)
+			{
+				if (sspdat[sspnum].dataword == 0){
+					*(uint8_t *)((uint32_t)xf_setup-&gt;rx_data + xf_setup-&gt;rx_cnt) = (uint8_t) tmp;
+				} else {
+					*(uint16_t *)((uint32_t)xf_setup-&gt;rx_data + xf_setup-&gt;rx_cnt) = (uint16_t) tmp;
+				}
+			}
+			// Increase counter
+			if (sspdat[sspnum].dataword == 0){
+				xf_setup-&gt;rx_cnt++;
+			} else {
+				xf_setup-&gt;rx_cnt += 2;
+			}
+		}
+
+		while ((SSPx-&gt;SR &amp; SSP_SR_TNF) &amp;&amp; (xf_setup-&gt;tx_cnt != xf_setup-&gt;length)){
+			// Write data to buffer
+			if(xf_setup-&gt;tx_data == NULL){
+				if (sspdat[sspnum].dataword == 0){
+					SSP_SendData(SSPx, 0xFF);
+					xf_setup-&gt;tx_cnt++;
+				} else {
+					SSP_SendData(SSPx, 0xFFFF);
+					xf_setup-&gt;tx_cnt += 2;
+				}
+			} else {
+				if (sspdat[sspnum].dataword == 0){
+					SSP_SendData(SSPx, (*(uint8_t *)((uint32_t)xf_setup-&gt;tx_data + xf_setup-&gt;tx_cnt)));
+					xf_setup-&gt;tx_cnt++;
+				} else {
+					SSP_SendData(SSPx, (*(uint16_t *)((uint32_t)xf_setup-&gt;tx_data + xf_setup-&gt;tx_cnt)));
+					xf_setup-&gt;tx_cnt += 2;
+				}
+			}
+
+		    // Check overrun error
+		    if ((tmp = SSPx-&gt;RIS) &amp; SSP_RIS_ROR){
+		    	// update status
+		    	xf_setup-&gt;status |= SSP_STAT_ERROR;
+		    	// Callback
+		    	if (xf_setup-&gt;callback != NULL){
+		    		xf_setup-&gt;callback();
+		    	}
+		    	return;
+		    }
+
+			// Check for any data available in RX FIFO
+			while ((SSPx-&gt;SR &amp; SSP_SR_RNE) &amp;&amp; (xf_setup-&gt;rx_cnt != xf_setup-&gt;length)){
+				// Read data from SSP data
+				tmp = SSP_ReceiveData(SSPx);
+
+				// Store data to destination
+				if (xf_setup-&gt;rx_data != NULL)
+				{
+					if (sspdat[sspnum].dataword == 0){
+						*(uint8_t *)((uint32_t)xf_setup-&gt;rx_data + xf_setup-&gt;rx_cnt) = (uint8_t) tmp;
+					} else {
+						*(uint16_t *)((uint32_t)xf_setup-&gt;rx_data + xf_setup-&gt;rx_cnt) = (uint16_t) tmp;
+					}
+				}
+				// Increase counter
+				if (sspdat[sspnum].dataword == 0){
+					xf_setup-&gt;rx_cnt++;
+				} else {
+					xf_setup-&gt;rx_cnt += 2;
+				}
+			}
+		}
+    }
+
+	// If there more data to sent or receive
+	if ((xf_setup-&gt;rx_cnt != xf_setup-&gt;length) || (xf_setup-&gt;tx_cnt != xf_setup-&gt;length)){
+		// Enable all interrupt
+		SSPx-&gt;IMSC = SSP_IMSC_BITMASK;
+	} else {
+		// Save status
+		xf_setup-&gt;status = SSP_STAT_DONE;
+		// Callback
+		if (xf_setup-&gt;callback != NULL){
+			xf_setup-&gt;callback();
+		}
+	}
+}
+
+/**
+ * @}
+ */
+
+
+/* Public Functions ----------------------------------------------------------- */
+/** @addtogroup SSP_Public_Functions
+ * @{
+ */
+
+/*********************************************************************//**
+ * @brief 		Setup clock rate for SSP device
+ * @param[in] 	SSPx	SSP peripheral definition, should be
+ * 						SSP0 or SSP1.
+ * @param[in]	target_clock : clock of SSP (Hz)
+ * @return 		None
+ ***********************************************************************/
+void SSP_SetClock (LPC_SSP_TypeDef *SSPx, uint32_t target_clock)
+{
+    uint32_t prescale, cr0_div, cmp_clk, ssp_clk;
+
+    CHECK_PARAM(PARAM_SSPx(SSPx));
+
+    /* The SSP clock is derived from the (main system oscillator / 2),
+       so compute the best divider from that clock */
+    if (SSPx == LPC_SSP0){
+    	ssp_clk = CLKPWR_GetPCLK (CLKPWR_PCLKSEL_SSP0);
+    } else if (SSPx == LPC_SSP1) {
+    	ssp_clk = CLKPWR_GetPCLK (CLKPWR_PCLKSEL_SSP1);
+    } else {
+    	return;
+    }
+
+	/* Find closest divider to get at or under the target frequency.
+	   Use smallest prescale possible and rely on the divider to get
+	   the closest target frequency */
+	cr0_div = 0;
+	cmp_clk = 0xFFFFFFFF;
+	prescale = 2;
+	while (cmp_clk &gt; target_clock)
+	{
+		cmp_clk = ssp_clk / ((cr0_div + 1) * prescale);
+		if (cmp_clk &gt; target_clock)
+		{
+			cr0_div++;
+			if (cr0_div &gt; 0xFF)
+			{
+				cr0_div = 0;
+				prescale += 2;
+			}
+		}
+	}
+
+    /* Write computed prescaler and divider back to register */
+    SSPx-&gt;CR0 &amp;= (~SSP_CR0_SCR(0xFF)) &amp; SSP_CR0_BITMASK;
+    SSPx-&gt;CR0 |= (SSP_CR0_SCR(cr0_div)) &amp; SSP_CR0_BITMASK;
+    SSPx-&gt;CPSR = prescale &amp; SSP_CPSR_BITMASK;
+}
+
+
+/*********************************************************************//**
+ * @brief		De-initializes the SSPx peripheral registers to their
+*                  default reset values.
+ * @param[in]	SSPx	SSP peripheral selected, should be SSP0 or SSP1
+ * @return 		None
+ **********************************************************************/
+void SSP_DeInit(LPC_SSP_TypeDef* SSPx)
+{
+	CHECK_PARAM(PARAM_SSPx(SSPx));
+
+	if (SSPx == LPC_SSP0){
+		/* Set up clock and power for SSP0 module */
+		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCSSP0, DISABLE);
+	} else if (SSPx == LPC_SSP1) {
+		/* Set up clock and power for SSP1 module */
+		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCSSP1, DISABLE);
+	}
+}
+
+
+
+/********************************************************************//**
+ * @brief		Initializes the SSPx peripheral according to the specified
+*               parameters in the SSP_ConfigStruct.
+ * @param[in]	SSPx	SSP peripheral selected, should be SSP0 or SSP1
+ * @param[in]	SSP_ConfigStruct Pointer to a SSP_CFG_Type structure
+*                    that contains the configuration information for the
+*                    specified SSP peripheral.
+ * @return 		None
+ *********************************************************************/
+void SSP_Init(LPC_SSP_TypeDef *SSPx, SSP_CFG_Type *SSP_ConfigStruct)
+{
+	uint32_t tmp;
+
+	CHECK_PARAM(PARAM_SSPx(SSPx));
+
+	if(SSPx == LPC_SSP0) {
+		/* Set up clock and power for SSP0 module */
+		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCSSP0, ENABLE);
+	} else if(SSPx == LPC_SSP1) {
+		/* Set up clock and power for SSP1 module */
+		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCSSP1, ENABLE);
+	} else {
+		return;
+	}
+
+	/* Configure SSP, interrupt is disable, LoopBack mode is disable,
+	 * SSP is disable, Slave output is disable as default
+	 */
+	tmp = ((SSP_ConfigStruct-&gt;CPHA) | (SSP_ConfigStruct-&gt;CPOL) \
+		| (SSP_ConfigStruct-&gt;FrameFormat) | (SSP_ConfigStruct-&gt;Databit))
+		&amp; SSP_CR0_BITMASK;
+	// write back to SSP control register
+	SSPx-&gt;CR0 = tmp;
+	tmp = SSP_getNum(SSPx);
+	if (SSP_ConfigStruct-&gt;Databit &gt; SSP_DATABIT_8){
+		sspdat[tmp].dataword = 1;
+	} else {
+		sspdat[tmp].dataword = 0;
+	}
+
+	tmp = SSP_ConfigStruct-&gt;Mode &amp; SSP_CR1_BITMASK;
+	// Write back to CR1
+	SSPx-&gt;CR1 = tmp;
+
+	// Set clock rate for SSP peripheral
+	SSP_SetClock(SSPx, SSP_ConfigStruct-&gt;ClockRate);
+}
+
+
+
+/*****************************************************************************//**
+* @brief		Fills each SSP_InitStruct member with its default value:
+* 				- CPHA = SSP_CPHA_FIRST
+* 				- CPOL = SSP_CPOL_HI
+* 				- ClockRate = 1000000
+* 				- Databit = SSP_DATABIT_8
+* 				- Mode = SSP_MASTER_MODE
+* 				- FrameFormat = SSP_FRAME_SSP
+* @param[in]	SSP_InitStruct Pointer to a SSP_CFG_Type structure
+*                    which will be initialized.
+* @return		None
+*******************************************************************************/
+void SSP_ConfigStructInit(SSP_CFG_Type *SSP_InitStruct)
+{
+	SSP_InitStruct-&gt;CPHA = SSP_CPHA_FIRST;
+	SSP_InitStruct-&gt;CPOL = SSP_CPOL_HI;
+	SSP_InitStruct-&gt;ClockRate = 1000000;
+	SSP_InitStruct-&gt;Databit = SSP_DATABIT_8;
+	SSP_InitStruct-&gt;Mode = SSP_MASTER_MODE;
+	SSP_InitStruct-&gt;FrameFormat = SSP_FRAME_SPI;
+}
+
+
+/*********************************************************************//**
+ * @brief		Enable or disable SSP peripheral's operation
+ * @param[in]	SSPx	SSP peripheral, should be SSP0 or SSP1
+ * @param[in]	NewState New State of SSPx peripheral's operation
+ * @return 		none
+ **********************************************************************/
+void SSP_Cmd(LPC_SSP_TypeDef* SSPx, FunctionalState NewState)
+{
+	CHECK_PARAM(PARAM_SSPx(SSPx));
+	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
+
+	if (NewState == ENABLE)
+	{
+		SSPx-&gt;CR1 |= SSP_CR1_SSP_EN;
+	}
+	else
+	{
+		SSPx-&gt;CR1 &amp;= (~SSP_CR1_SSP_EN) &amp; SSP_CR1_BITMASK;
+	}
+}
+
+
+
+/*********************************************************************//**
+ * @brief		Enable or disable Loop Back mode function in SSP peripheral
+ * @param[in]	SSPx	SSP peripheral selected, should be SSP0 or SSP1
+ * @param[in]	NewState	New State of Loop Back mode, should be:
+ * 							- ENABLE: Enable this function
+ * 							- DISABLE: Disable this function
+ * @return 		None
+ **********************************************************************/
+void SSP_LoopBackCmd(LPC_SSP_TypeDef* SSPx, FunctionalState NewState)
+{
+	CHECK_PARAM(PARAM_SSPx(SSPx));
+	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
+
+	if (NewState == ENABLE)
+	{
+		SSPx-&gt;CR1 |= SSP_CR1_LBM_EN;
+	}
+	else
+	{
+		SSPx-&gt;CR1 &amp;= (~SSP_CR1_LBM_EN) &amp; SSP_CR1_BITMASK;
+	}
+}
+
+
+
+/*********************************************************************//**
+ * @brief		Enable or disable Slave Output function in SSP peripheral
+ * @param[in]	SSPx	SSP peripheral selected, should be SSP0 or SSP1
+ * @param[in]	NewState	New State of Slave Output function, should be:
+ * 							- ENABLE: Slave Output in normal operation
+ * 							- DISABLE: Slave Output is disabled. This blocks
+ * 							SSP controller from driving the transmit data
+ * 							line (MISO)
+ * Note: 		This function is available when SSP peripheral in Slave mode
+ * @return 		None
+ **********************************************************************/
+void SSP_SlaveOutputCmd(LPC_SSP_TypeDef* SSPx, FunctionalState NewState)
+{
+	CHECK_PARAM(PARAM_SSPx(SSPx));
+	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
+
+	if (NewState == ENABLE)
+	{
+		SSPx-&gt;CR1 &amp;= (~SSP_CR1_SO_DISABLE) &amp; SSP_CR1_BITMASK;
+	}
+	else
+	{
+		SSPx-&gt;CR1 |= SSP_CR1_SO_DISABLE;
+	}
+}
+
+
+
+/*********************************************************************//**
+ * @brief		Transmit a single data through SSPx peripheral
+ * @param[in]	SSPx	SSP peripheral selected, should be SSP
+ * @param[in]	Data	Data to transmit (must be 16 or 8-bit long,
+ * 						this depend on SSP data bit number configured)
+ * @return 		none
+ **********************************************************************/
+void SSP_SendData(LPC_SSP_TypeDef* SSPx, uint16_t Data)
+{
+	CHECK_PARAM(PARAM_SSPx(SSPx));
+
+	SSPx-&gt;DR = SSP_DR_BITMASK(Data);
+}
+
+
+
+/*********************************************************************//**
+ * @brief		Receive a single data from SSPx peripheral
+ * @param[in]	SSPx	SSP peripheral selected, should be SSP
+ * @return 		Data received (16-bit long)
+ **********************************************************************/
+uint16_t SSP_ReceiveData(LPC_SSP_TypeDef* SSPx)
+{
+	CHECK_PARAM(PARAM_SSPx(SSPx));
+
+	return ((uint16_t) (SSP_DR_BITMASK(SSPx-&gt;DR)));
+}
+
+/*********************************************************************//**
+ * @brief 		SSP Read write data function
+ * @param[in]	SSPx 	Pointer to SSP peripheral, should be SSP0 or SSP1
+ * @param[in]	dataCfg	Pointer to a SSP_DATA_SETUP_Type structure that
+ * 						contains specified information about transmit
+ * 						data configuration.
+ * @param[in]	xfType	Transfer type, should be:
+ * 						- SSP_TRANSFER_POLLING: Polling mode
+ * 						- SSP_TRANSFER_INTERRUPT: Interrupt mode
+ * @return 		Actual Data length has been transferred in polling mode.
+ * 				In interrupt mode, always return (0)
+ * 				Return (-1) if error.
+ * Note: This function can be used in both master and slave mode.
+ ***********************************************************************/
+int32_t SSP_ReadWrite (LPC_SSP_TypeDef *SSPx, SSP_DATA_SETUP_Type *dataCfg, \
+						SSP_TRANSFER_Type xfType)
+{
+	uint8_t *rdata8;
+    uint8_t *wdata8;
+	uint16_t *rdata16;
+    uint16_t *wdata16;
+    uint32_t stat;
+    uint32_t tmp;
+    int32_t sspnum;
+    int32_t dataword;
+
+    dataCfg-&gt;rx_cnt = 0;
+    dataCfg-&gt;tx_cnt = 0;
+    dataCfg-&gt;status = 0;
+
+
+	/* Clear all remaining data in RX FIFO */
+	while (SSPx-&gt;SR &amp; SSP_SR_RNE){
+		tmp = (uint32_t) SSP_ReceiveData(SSPx);
+	}
+
+	// Clear status
+	SSPx-&gt;ICR = SSP_ICR_BITMASK;
+
+	sspnum = SSP_getNum(SSPx);
+	dataword = sspdat[sspnum].dataword;
+
+	// Polling mode ----------------------------------------------------------------------
+	if (xfType == SSP_TRANSFER_POLLING){
+		if (dataword == 0){
+			rdata8 = (uint8_t *)dataCfg-&gt;rx_data;
+			wdata8 = (uint8_t *)dataCfg-&gt;tx_data;
+		} else {
+			rdata16 = (uint16_t *)dataCfg-&gt;rx_data;
+			wdata16 = (uint16_t *)dataCfg-&gt;tx_data;
+		}
+		while ((dataCfg-&gt;tx_cnt != dataCfg-&gt;length) || (dataCfg-&gt;rx_cnt != dataCfg-&gt;length)){
+			if ((SSPx-&gt;SR &amp; SSP_SR_TNF) &amp;&amp; (dataCfg-&gt;tx_cnt != dataCfg-&gt;length)){
+				// Write data to buffer
+				if(dataCfg-&gt;tx_data == NULL){
+					if (dataword == 0){
+						SSP_SendData(SSPx, 0xFF);
+						dataCfg-&gt;tx_cnt++;
+					} else {
+						SSP_SendData(SSPx, 0xFFFF);
+						dataCfg-&gt;tx_cnt += 2;
+					}
+				} else {
+					if (dataword == 0){
+						SSP_SendData(SSPx, *wdata8);
+						wdata8++;
+						dataCfg-&gt;tx_cnt++;
+					} else {
+						SSP_SendData(SSPx, *wdata16);
+						wdata16++;
+						dataCfg-&gt;tx_cnt += 2;
+					}
+				}
+			}
+
+			// Check overrun error
+			if ((stat = SSPx-&gt;RIS) &amp; SSP_RIS_ROR){
+				// save status and return
+				dataCfg-&gt;status = stat | SSP_STAT_ERROR;
+				return (-1);
+			}
+
+			// Check for any data available in RX FIFO
+			while ((SSPx-&gt;SR &amp; SSP_SR_RNE) &amp;&amp; (dataCfg-&gt;rx_cnt != dataCfg-&gt;length)){
+				// Read data from SSP data
+				tmp = SSP_ReceiveData(SSPx);
+
+				// Store data to destination
+				if (dataCfg-&gt;rx_data != NULL)
+				{
+					if (dataword == 0){
+						*(rdata8) = (uint8_t) tmp;
+						rdata8++;
+					} else {
+						*(rdata16) = (uint16_t) tmp;
+						rdata16++;
+					}
+				}
+				// Increase counter
+				if (dataword == 0){
+					dataCfg-&gt;rx_cnt++;
+				} else {
+					dataCfg-&gt;rx_cnt += 2;
+				}
+			}
+		}
+
+		// save status
+		dataCfg-&gt;status = SSP_STAT_DONE;
+
+		if (dataCfg-&gt;tx_data != NULL){
+			return dataCfg-&gt;tx_cnt;
+		} else if (dataCfg-&gt;rx_data != NULL){
+			return dataCfg-&gt;rx_cnt;
+		} else {
+			return (0);
+		}
+	}
+
+	// Interrupt mode ----------------------------------------------------------------------
+	else if (xfType == SSP_TRANSFER_INTERRUPT){
+		sspdat[sspnum].inthandler = SSP_IntHandler;
+		sspdat[sspnum].txrx_setup = (uint32_t)dataCfg;
+
+		while ((SSPx-&gt;SR &amp; SSP_SR_TNF) &amp;&amp; (dataCfg-&gt;tx_cnt != dataCfg-&gt;length)){
+			// Write data to buffer
+			if(dataCfg-&gt;tx_data == NULL){
+				if (sspdat[sspnum].dataword == 0){
+					SSP_SendData(SSPx, 0xFF);
+					dataCfg-&gt;tx_cnt++;
+				} else {
+					SSP_SendData(SSPx, 0xFFFF);
+					dataCfg-&gt;tx_cnt += 2;
+				}
+			} else {
+				if (sspdat[sspnum].dataword == 0){
+					SSP_SendData(SSPx, (*(uint8_t *)((uint32_t)dataCfg-&gt;tx_data + dataCfg-&gt;tx_cnt)));
+					dataCfg-&gt;tx_cnt++;
+				} else {
+					SSP_SendData(SSPx, (*(uint16_t *)((uint32_t)dataCfg-&gt;tx_data + dataCfg-&gt;tx_cnt)));
+					dataCfg-&gt;tx_cnt += 2;
+				}
+			}
+
+			// Check error
+			if ((stat = SSPx-&gt;RIS) &amp; SSP_RIS_ROR){
+				// save status and return
+				dataCfg-&gt;status = stat | SSP_STAT_ERROR;
+				return (-1);
+			}
+
+			// Check for any data available in RX FIFO
+			while ((SSPx-&gt;SR &amp; SSP_SR_RNE) &amp;&amp; (dataCfg-&gt;rx_cnt != dataCfg-&gt;length)){
+				// Read data from SSP data
+				tmp = SSP_ReceiveData(SSPx);
+
+				// Store data to destination
+				if (dataCfg-&gt;rx_data != NULL)
+				{
+					if (sspdat[sspnum].dataword == 0){
+						*(uint8_t *)((uint32_t)dataCfg-&gt;rx_data + dataCfg-&gt;rx_cnt) = (uint8_t) tmp;
+					} else {
+						*(uint16_t *)((uint32_t)dataCfg-&gt;rx_data + dataCfg-&gt;rx_cnt) = (uint16_t) tmp;
+					}
+				}
+				// Increase counter
+				if (sspdat[sspnum].dataword == 0){
+					dataCfg-&gt;rx_cnt++;
+				} else {
+					dataCfg-&gt;rx_cnt += 2;
+				}
+			}
+		}
+
+		// If there more data to sent or receive
+		if ((dataCfg-&gt;rx_cnt != dataCfg-&gt;length) || (dataCfg-&gt;tx_cnt != dataCfg-&gt;length)){
+			// Enable all interrupt
+			SSPx-&gt;IMSC = SSP_IMSC_BITMASK;
+		} else {
+			// Save status
+			dataCfg-&gt;status = SSP_STAT_DONE;
+		}
+		return (0);
+	}
+
+	return (-1);
+}
+
+/*********************************************************************//**
+ * @brief		Checks whether the specified SSP status flag is set or not
+ * @param[in]	SSPx	SSP peripheral selected, should be SSP0 or SSP1
+ * @param[in]	FlagType	Type of flag to check status, should be one
+ * 							of following:
+ *							- SSP_STAT_TXFIFO_EMPTY: TX FIFO is empty
+ *							- SSP_STAT_TXFIFO_NOTFULL: TX FIFO is not full
+ *							- SSP_STAT_RXFIFO_NOTEMPTY: RX FIFO is not empty
+ *							- SSP_STAT_RXFIFO_FULL: RX FIFO is full
+ *							- SSP_STAT_BUSY: SSP peripheral is busy
+ * @return		New State of specified SSP status flag
+ **********************************************************************/
+FlagStatus SSP_GetStatus(LPC_SSP_TypeDef* SSPx, uint32_t FlagType)
+{
+	CHECK_PARAM(PARAM_SSPx(SSPx));
+	CHECK_PARAM(PARAM_SSP_STAT(FlagType));
+
+	return ((SSPx-&gt;SR &amp; FlagType) ? SET : RESET);
+}
+
+
+
+/*********************************************************************//**
+ * @brief		Enable or disable specified interrupt type in SSP peripheral
+ * @param[in]	SSPx	SSP peripheral selected, should be SSP0 or SSP1
+ * @param[in]	IntType	Interrupt type in SSP peripheral, should be:
+ * 				- SSP_INTCFG_ROR: Receive Overrun interrupt
+ * 				- SSP_INTCFG_RT: Receive Time out interrupt
+ * 				- SSP_INTCFG_RX: RX FIFO is at least half full interrupt
+ * 				- SSP_INTCFG_TX: TX FIFO is at least half empty interrupt
+ * @param[in]	NewState New State of specified interrupt type, should be:
+ * 				- ENABLE: Enable this interrupt type
+ * 				- DISABLE: Disable this interrupt type
+ * @return		None
+ **********************************************************************/
+void SSP_IntConfig(LPC_SSP_TypeDef *SSPx, uint32_t IntType, FunctionalState NewState)
+{
+	CHECK_PARAM(PARAM_SSPx(SSPx));
+	CHECK_PARAM(PARAM_SSP_INTCFG(IntType));
+
+	if (NewState == ENABLE)
+	{
+		SSPx-&gt;IMSC |= IntType;
+	}
+	else
+	{
+		SSPx-&gt;IMSC &amp;= (~IntType) &amp; SSP_IMSC_BITMASK;
+	}
+}
+
+
+/*********************************************************************//**
+ * @brief	Check whether the specified Raw interrupt status flag is
+ * 			set or not
+ * @param[in]	SSPx	SSP peripheral selected, should be SSP0 or SSP1
+ * @param[in]	RawIntType	Raw Interrupt Type, should be:
+ * 				- SSP_INTSTAT_RAW_ROR: Receive Overrun interrupt
+ * 				- SSP_INTSTAT_RAW_RT: Receive Time out interrupt
+ * 				- SSP_INTSTAT_RAW_RX: RX FIFO is at least half full interrupt
+ * 				- SSP_INTSTAT_RAW_TX: TX FIFO is at least half empty interrupt
+ * @return	New State of specified Raw interrupt status flag in SSP peripheral
+ * Note: Enabling/Disabling specified interrupt in SSP peripheral does not
+ * 		effect to Raw Interrupt Status flag.
+ **********************************************************************/
+IntStatus SSP_GetRawIntStatus(LPC_SSP_TypeDef *SSPx, uint32_t RawIntType)
+{
+	CHECK_PARAM(PARAM_SSPx(SSPx));
+	CHECK_PARAM(PARAM_SSP_INTSTAT_RAW(RawIntType));
+
+	return ((SSPx-&gt;RIS &amp; RawIntType) ? SET : RESET);
+}
+
+
+/*********************************************************************//**
+ * @brief	Check whether the specified interrupt status flag is
+ * 			set or not
+ * @param[in]	SSPx	SSP peripheral selected, should be SSP0 or SSP1
+ * @param[in]	IntType	Raw Interrupt Type, should be:
+ * 				- SSP_INTSTAT_ROR: Receive Overrun interrupt
+ * 				- SSP_INTSTAT_RT: Receive Time out interrupt
+ * 				- SSP_INTSTAT_RX: RX FIFO is at least half full interrupt
+ * 				- SSP_INTSTAT_TX: TX FIFO is at least half empty interrupt
+ * @return	New State of specified interrupt status flag in SSP peripheral
+ * Note: Enabling/Disabling specified interrupt in SSP peripheral effects
+ * 			to Interrupt Status flag.
+ **********************************************************************/
+IntStatus SSP_GetIntStatus (LPC_SSP_TypeDef *SSPx, uint32_t IntType)
+{
+	CHECK_PARAM(PARAM_SSPx(SSPx));
+	CHECK_PARAM(PARAM_SSP_INTSTAT(IntType));
+
+	return ((SSPx-&gt;MIS &amp; IntType) ? SET :RESET);
+}
+
+
+
+/*********************************************************************//**
+ * @brief				Clear specified interrupt pending in SSP peripheral
+ * @param[in]	SSPx	SSP peripheral selected, should be SSP0 or SSP1
+ * @param[in]	IntType	Interrupt pending to clear, should be:
+ * 						- SSP_INTCLR_ROR: clears the &quot;frame was received when
+ * 						RxFIFO was full&quot; interrupt.
+ * 						- SSP_INTCLR_RT: clears the &quot;Rx FIFO was not empty and
+ * 						has not been read for a timeout period&quot; interrupt.
+ * @return		None
+ **********************************************************************/
+void SSP_ClearIntPending(LPC_SSP_TypeDef *SSPx, uint32_t IntType)
+{
+	CHECK_PARAM(PARAM_SSPx(SSPx));
+	CHECK_PARAM(PARAM_SSP_INTCLR(IntType));
+
+	SSPx-&gt;ICR = IntType;
+}
+
+/*********************************************************************//**
+ * @brief				Enable/Disable DMA function for SSP peripheral
+ * @param[in]	SSPx	SSP peripheral selected, should be SSP0 or SSP1
+ * @param[in]	DMAMode	Type of DMA, should be:
+ * 						- SSP_DMA_TX: DMA for the transmit FIFO
+ * 						- SSP_DMA_RX: DMA for the Receive FIFO
+ * @param[in]	NewState	New State of DMA function on SSP peripheral,
+ * 						should be:
+ * 						- ENALBE: Enable this function
+ * 						- DISABLE: Disable this function
+ * @return		None
+ **********************************************************************/
+void SSP_DMACmd(LPC_SSP_TypeDef *SSPx, uint32_t DMAMode, FunctionalState NewState)
+{
+	CHECK_PARAM(PARAM_SSPx(SSPx));
+	CHECK_PARAM(PARAM_SSP_DMA(DMAMode));
+	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
+
+	if (NewState == ENABLE)
+	{
+		SSPx-&gt;DMACR |= DMAMode;
+	}
+	else
+	{
+		SSPx-&gt;DMACR &amp;= (~DMAMode) &amp; SSP_DMA_BITMASK;
+	}
+}
+
+/**
+ * @brief		Standard SSP0 Interrupt handler
+ * @param[in] 	None
+ * @return		None
+ */
+void SSP0_StdIntHandler(void)
+{
+	// Call relevant handler
+	sspdat[0].inthandler(LPC_SSP0);
+}
+
+/**
+ * @brief		Standard SSP1 Interrupt handler
+ * @param[in] 	None
+ * @return		None
+ */
+void SSP1_StdIntHandler(void)
+{
+	// Call relevant handler
+	sspdat[1].inthandler(LPC_SSP1);
+}
+
+/**
+ * @}
+ */
+
+#endif /* _SSP */
+
+/**
+ * @}
+ */
+
+/* --------------------------------- End Of File ------------------------------ */
+


Property changes on: trunk/src/platform/lpc17xx/drivers/src/lpc17xx_ssp.c
___________________________________________________________________
Deleted: svn:executable
   - *

Modified: trunk/src/platform/lpc17xx/drivers/src/lpc17xx_timer.c
===================================================================
--- trunk/src/platform/lpc17xx/drivers/src/lpc17xx_timer.c	2010-06-28 21:53:59 UTC (rev 759)
+++ trunk/src/platform/lpc17xx/drivers/src/lpc17xx_timer.c	2010-07-12 20:56:54 UTC (rev 760)
@@ -1,479 +1,479 @@
-/**
- * @file	: lpc17xx_timer.c
- * @brief	: Contains all functions support for SPI firmware library on LPC17xx
- * @version	: 1.0
- * @date	: 14. April. 2009
- * @author	:
- *----------------------------------------------------------------------------
- * Software that is described herein is for illustrative purposes only
- * which provides customers with programming information regarding the
- * products. This software is supplied &quot;AS IS&quot; without any warranties.
- * NXP Semiconductors assumes no responsibility or liability for the
- * use of the software, conveys no license or title under any patent,
- * copyright, or mask work right to the product. NXP Semiconductors
- * reserves the right to make changes in the software without
- * notification. NXP Semiconductors also make no representation or
- * warranty that such application will be suitable for the specified
- * use without further testing or modification.
- **********************************************************************/
-
-/* Peripheral group ----------------------------------------------------------- */
-/** @addtogroup TIM
- * @{
- */
-
-/* Includes ------------------------------------------------------------------- */
-#include &quot;lpc17xx_timer.h&quot;
-#include &quot;lpc17xx_clkpwr.h&quot;
-#include &quot;lpc17xx_pinsel.h&quot;
-
-/* If this source file built with example, the LPC17xx FW library configuration
- * file in each example directory (&quot;lpc17xx_libcfg.h&quot;) must be included,
- * otherwise the default FW library configuration file must be included instead
- */
-#ifdef __BUILD_WITH_EXAMPLE__
-#include &quot;lpc17xx_libcfg.h&quot;
-#else
-#include &quot;lpc17xx_libcfg_default.h&quot;
-#endif /* __BUILD_WITH_EXAMPLE__ */
-
-#ifdef _TIM
-
-/* Private Functions ---------------------------------------------------------- */
-/** @defgroup TIM_Private_Functions
- * @{
- */
-
-uint32_t TIM_GetPClock (uint32_t timernum);
-uint32_t TIM_ConverUSecToVal (uint32_t timernum, uint32_t usec);
-uint32_t TIM_ConverPtrToTimeNum (TIM_TypeDef *TIMx);
-
-
-/*********************************************************************//**
- * @brief 		Get peripheral clock of each timer controller
- * @param[in]	timernum Timer number
- * @return 		Peripheral clock of timer
- **********************************************************************/
-
-uint32_t TIM_GetPClock (uint32_t timernum)
-{
-	uint32_t clkdlycnt;
-	switch (timernum)
-	{
-	case 0:
-		clkdlycnt = CLKPWR_GetPCLK (CLKPWR_PCLKSEL_TIMER0);
-		break;
-
-	case 1:
-		clkdlycnt = CLKPWR_GetPCLK (CLKPWR_PCLKSEL_TIMER1);
-		break;
-
-	case 2:
-		clkdlycnt = CLKPWR_GetPCLK (CLKPWR_PCLKSEL_TIMER2);
-		break;
-
-	case 3:
-		clkdlycnt = CLKPWR_GetPCLK (CLKPWR_PCLKSEL_TIMER3);
-		break;
-	}
-	return clkdlycnt;
-}
-
-
-/*********************************************************************//**
- * @brief 		Convert a time to a timer count value
- * @param[in]	timernum Timer number
- * @param[in]	usec Time in microseconds
- * @return 		The number of required clock ticks to give the time delay
- **********************************************************************/
-uint32_t TIM_ConverUSecToVal (uint32_t timernum, uint32_t usec)
-{
-	uint64_t clkdlycnt;
-
-	// Get Pclock of timer
-	clkdlycnt = (uint64_t) TIM_GetPClock (timernum);
-
-	clkdlycnt = (clkdlycnt * usec) / 1000000;
-	return (uint32_t) clkdlycnt;
-}
-
-
-/*********************************************************************//**
- * @brief 		Convert a timer register pointer to a timer number
- * @param[in]	TIMx Pointer to a timer register set
- * @return 		The timer number (0 to 3) or -1 if register pointer is bad
- **********************************************************************/
-uint32_t TIM_ConverPtrToTimeNum (TIM_TypeDef *TIMx)
-{
-	uint32_t tnum = -1;
-
-	if (TIMx == TIM0)
-	{
-		tnum = 0;
-	}
-	else if (TIMx == TIM1)
-	{
-		tnum = 1;
-	}
-	else if (TIMx == TIM2)
-	{
-		tnum = 2;
-	}
-	else if (TIMx == TIM3)
-	{
-		tnum = 3;
-	}
-
-	return tnum;
-}
-
-/**
- * @}
- */
-
-
-/* Public Functions ----------------------------------------------------------- */
-/** @addtogroup TIM_Public_Functions
- * @{
- */
-
-/*********************************************************************//**
- * @brief 		Get Interrupt Status
- * @param[in]	TIMx Timer selection, should be TIM0, TIM1, TIM2, TIM3
- * @param[in]	IntFlag
- * @return 		FlagStatus
- * 				- SET : interrupt
- * 				- RESET : no interrupt
- **********************************************************************/
-FlagStatus TIM_GetIntStatus(TIM_TypeDef *TIMx, uint8_t IntFlag)
-{
-	CHECK_PARAM(PARAM_TIMx(TIMx));
-	CHECK_PARAM(PARAM_TIM_INT_TYPE(IntFlag));
-	uint8_t temp = (TIMx-&gt;IR)&amp; TIM_IR_CLR(IntFlag);
-	if (temp)
-		return SET;
-
-	return RESET;
-
-}
-/*********************************************************************//**
- * @brief 		Get Capture Interrupt Status
- * @param[in]	TIMx Timer selection, should be TIM0, TIM1, TIM2, TIM3
- * @param[in]	IntFlag
- * @return 		FlagStatus
- * 				- SET : interrupt
- * 				- RESET : no interrupt
- **********************************************************************/
-FlagStatus TIM_GetIntCaptureStatus(TIM_TypeDef *TIMx, uint8_t IntFlag)
-{
-	CHECK_PARAM(PARAM_TIMx(TIMx));
-	CHECK_PARAM(PARAM_TIM_INT_TYPE(IntFlag));
-	uint8_t temp = (TIMx-&gt;IR) &amp; (1&lt;&lt;(4+IntFlag));
-	if(temp)
-		return SET;
-	return RESET;
-}
-/*********************************************************************//**
- * @brief 		Clear Interrupt pending
- * @param[in]	TIMx Timer selection, should be TIM0, TIM1, TIM2, TIM3
- * @param[in]	IntFlag should be in TIM_INT_TYPE enum
- * @return 		None
- **********************************************************************/
-void TIM_ClearIntPending(TIM_TypeDef *TIMx, uint8_t IntFlag)
-{
-	CHECK_PARAM(PARAM_TIMx(TIMx));
-	CHECK_PARAM(PARAM_TIM_INT_TYPE(IntFlag));
-	TIMx-&gt;IR |= TIM_IR_CLR(IntFlag);
-}
-
-/*********************************************************************//**
- * @brief 		Clear Capture Interrupt pending
- * @param[in]	TIMx Timer selection, should be TIM0, TIM1, TIM2, TIM3
- * @param[in]	IntFlag should be in TIM_INT_TYPE enum
- * @return 		None
- **********************************************************************/
-void TIM_ClearIntCapturePending(TIM_TypeDef *TIMx, uint8_t IntFlag)
-{
-	CHECK_PARAM(PARAM_TIMx(TIMx));
-	CHECK_PARAM(PARAM_TIM_INT_TYPE(IntFlag));
-	TIMx-&gt;IR |= (1&lt;&lt;(4+IntFlag));
-}
-
-/*********************************************************************//**
-* @brief 		Configuration for Timer at initial time
-* @param[in] 	TimerCounterMode Should be :
-* 					- PrescaleOption = TC_PRESCALE_USVAL,
-* 					- PrescaleValue = 1
-* 				Counter mode with
-* 					- Caption channel 0
-* @param[in] 	TIM_ConfigStruct pointer to TIM_TIMERCFG_Type or
-* 				TIM_COUNTERCFG_Type
-* @return 		None
- **********************************************************************/
-void TIM_ConfigStructInit(uint8_t TimerCounterMode, void *TIM_ConfigStruct)
-{
-	if (TimerCounterMode == TIM_TIMER_MODE )
-	{
-		TIM_TIMERCFG_Type * pTimeCfg = (TIM_TIMERCFG_Type *)TIM_ConfigStruct;
-		pTimeCfg-&gt;PrescaleOption = TIM_PRESCALE_USVAL;
-		pTimeCfg-&gt;PrescaleValue = 1;
-	}
-	else
-	{
-		TIM_COUNTERCFG_Type * pCounterCfg = (TIM_COUNTERCFG_Type *)TIM_ConfigStruct;
-		pCounterCfg-&gt;CountInputSelect = TIM_COUNTER_INCAP0;
-
-	}
-}
-
-/*********************************************************************//**
- * @brief 		Initial Timer/Counter device
- * 				 	Set Clock frequency for Timer
- * 					Set initial configuration for Timer
- * @param[in]	TIMx  Timer selection, should be TIM0, TIM1, TIM2, TIM3
- * @param[in]	TimerCounterMode TIM_MODE_OPT
- * @param[in]	TIM_ConfigStruct pointer to TIM_TIMERCFG_Type
- * 				that contains the configuration information for the
- *                    specified Timer peripheral.
- * @return 		None
- **********************************************************************/
-void TIM_Init(TIM_TypeDef *TIMx, uint8_t TimerCounterMode, void *TIM_ConfigStruct)
-{
-	TIM_TIMERCFG_Type *pTimeCfg;
-	TIM_COUNTERCFG_Type *pCounterCfg;
-	uint32_t timer;
-
-	CHECK_PARAM(PARAM_TIMx(TIMx));
-	CHECK_PARAM(PARAM_TIM_MODE_OPT(TimerCounterMode));
-
-	timer = TIM_ConverPtrToTimeNum(TIMx) ;
-	//set power
-	if (TIMx== TIM0)
-	{
-		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCTIM0, ENABLE);
-		CLKPWR_SetPCLKDiv (CLKPWR_PCLKSEL_TIMER0, CLKPWR_PCLKSEL_CCLK_DIV_4);
-	}
-	else if (TIMx== TIM1)
-	{
-		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCTIM1, ENABLE);
-		CLKPWR_SetPCLKDiv (CLKPWR_PCLKSEL_TIMER1, CLKPWR_PCLKSEL_CCLK_DIV_4);
-
-	}
-
-	else if (TIMx== TIM2)
-	{
-		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCTIM2, ENABLE);
-		CLKPWR_SetPCLKDiv (CLKPWR_PCLKSEL_TIMER2, CLKPWR_PCLKSEL_CCLK_DIV_4);
-	}
-	else if (TIMx== TIM3)
-	{
-		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCTIM3, ENABLE);
-		CLKPWR_SetPCLKDiv (CLKPWR_PCLKSEL_TIMER3, CLKPWR_PCLKSEL_CCLK_DIV_4);
-
-	}
-
-	TIMx-&gt;CCR &amp;= ~TIM_CTCR_MODE_MASK;
-	TIMx-&gt;CCR |= TIM_TIMER_MODE;
-
-	TIMx-&gt;TC =0;
-	TIMx-&gt;PC =0;
-	TIMx-&gt;PR =0;
-	if (TimerCounterMode == TIM_TIMER_MODE )
-	{
-		pTimeCfg = (TIM_TIMERCFG_Type *)TIM_ConfigStruct;
-		if (pTimeCfg-&gt;PrescaleOption  == TIM_PRESCALE_TICKVAL)
-		{
-			TIMx-&gt;PR   = pTimeCfg-&gt;PrescaleValue -1  ;
-		}
-		else
-		{
-			TIMx-&gt;PR   = TIM_ConverUSecToVal (TIM_ConverPtrToTimeNum(TIMx),pTimeCfg-&gt;PrescaleValue)-1;
-		}
-	}
-	else
-	{
-
-		pCounterCfg = (TIM_COUNTERCFG_Type *)TIM_ConfigStruct;
-		TIMx-&gt;CCR  &amp;= ~TIM_CTCR_INPUT_MASK;
-		if (pCounterCfg-&gt;CountInputSelect == TIM_COUNTER_INCAP1)
-			TIMx-&gt;CCR |= _BIT(2);
-	}
-
-	// Clear interrupt pending
-	TIMx-&gt;IR = 0xFFFFFFFF;
-
-}
-
-/*********************************************************************//**
- * @brief 		Close Timer/Counter device
- * @param[in]	TIMx  Pointer to timer device
- * @return 		None
- **********************************************************************/
-void TIM_DeInit (TIM_TypeDef *TIMx)
-{
-	CHECK_PARAM(PARAM_TIMx(TIMx));
-	// Disable timer/counter
-	TIMx-&gt;TCR = 0x00;
-
-	// Disable power
-	if (TIMx== TIM0)
-		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCTIM0, DISABLE);
-
-	else if (TIMx== TIM1)
-		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCTIM1, DISABLE);
-
-	else if (TIMx== TIM2)
-		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCTIM2, DISABLE);
-
-	else if (TIMx== TIM3)
-		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCTIM2, DISABLE);
-
-}
-
-/*********************************************************************//**
- * @brief	 	Start/Stop Timer/Counter device
- * @param[in]	TIMx Pointer to timer device
- * @param[in]	NewState
- * 				-	ENABLE  : set timer enable
- * 				-	DISABLE : disable timer
- * @return 		None
- **********************************************************************/
-void TIM_Cmd(TIM_TypeDef *TIMx, FunctionalState NewState)
-{
-	CHECK_PARAM(PARAM_TIMx(TIMx));
-	if (NewState == ENABLE)
-	{
-		TIMx-&gt;TCR	|=  TIM_ENABLE;
-	}
-	else
-	{
-		TIMx-&gt;TCR &amp;= ~TIM_ENABLE;
-	}
-}
-
-/*********************************************************************//**
- * @brief 		Reset Timer/Counter device,
- * 					Make TC and PC are synchronously reset on the next
- * 					positive edge of PCLK
- * @param[in]	TIMx Pointer to timer device
- * @return 		None
- **********************************************************************/
-void TIM_ResetCounter(TIM_TypeDef *TIMx)
-{
-	CHECK_PARAM(PARAM_TIMx(TIMx));
-	TIMx-&gt;TCR |= TIM_RESET;
-	TIMx-&gt;TCR &amp;= ~TIM_RESET;
-}
-
-/*********************************************************************//**
- * @brief 		Configuration for Match register
- * @param[in]	TIMx Pointer to timer device
- * @param[in]   TIM_MatchConfigStruct Pointer to TIM_MATCHCFG_Type
- * 					- MatchChannel : choose channel 0 or 1
- * 					- IntOnMatch	 : if SET, interrupt will be generated when MRxx match
- * 									the value in TC
- * 					- StopOnMatch	 : if SET, TC and PC will be stopped whenM Rxx match
- * 									the value in TC
- * 					- ResetOnMatch : if SET, Reset on MR0 when MRxx match
- * 									the value in TC
- * 					-ExtMatchOutputType: Select output for external match
- * 						 +	 0:	Do nothing for external output pin if match
- *						 +   1:	Force external output pin to low if match
- *						 + 	 2: Force external output pin to high if match
- *						 + 	 3: Toggle external output pin if match
- *					MatchValue: Set the value to be compared with TC value
- * @return 		None
- **********************************************************************/
-void TIM_ConfigMatch(TIM_TypeDef *TIMx, TIM_MATCHCFG_Type *TIM_MatchConfigStruct)
-{
-	uint32_t timer;
-
-	CHECK_PARAM(PARAM_TIMx(TIMx));
-	CHECK_PARAM(PARAM_TIM_EXTMATCH_OPT(TIM_MatchConfigStruct-&gt;ExtMatchOutputType));
-
-	timer = TIM_ConverPtrToTimeNum(TIMx) ;
-	switch(TIM_MatchConfigStruct-&gt;MatchChannel)
-	{
-	case 0:
-		TIMx-&gt;MR0 = TIM_MatchConfigStruct-&gt;MatchValue;
-		break;
-	case 1:
-		TIMx-&gt;MR1 = TIM_MatchConfigStruct-&gt;MatchValue;
-		break;
-	}
-	//interrupt on MRn
-	TIMx-&gt;MCR &amp;=~TIM_MCR_CHANNEL_MASKBIT(TIM_MatchConfigStruct-&gt;MatchChannel);
-
-	if (TIM_MatchConfigStruct-&gt;IntOnMatch)
-		TIMx-&gt;MCR |= TIM_INT_ON_MATCH(TIM_MatchConfigStruct-&gt;MatchChannel);
-
-	//reset on MRn
-	if (TIM_MatchConfigStruct-&gt;ResetOnMatch)
-		TIMx-&gt;MCR |= TIM_RESET_ON_MATCH(TIM_MatchConfigStruct-&gt;MatchChannel);
-
-	//stop on MRn
-	if (TIM_MatchConfigStruct-&gt;StopOnMatch)
-		TIMx-&gt;MCR |= TIM_STOP_ON_MATCH(TIM_MatchConfigStruct-&gt;MatchChannel);
-//	TIMx-&gt;MCR = 0x02;
-
-	// match output type
-
-	TIMx-&gt;EMR 	&amp;= ~TIM_EM_MASK(TIM_MatchConfigStruct-&gt;MatchChannel);
-	TIMx-&gt;EMR    = TIM_EM_SET(TIM_MatchConfigStruct-&gt;MatchChannel,TIM_MatchConfigStruct-&gt;ExtMatchOutputType);
-}
-/*********************************************************************//**
- * @brief 		Configuration for Capture register
- * @param[in]	TIMx Pointer to timer device
- * 					- CaptureChannel: set the channel to capture data
- * 					- RisingEdge    : if SET, Capture at rising edge
- * 					- FallingEdge	: if SET, Capture at falling edge
- * 					- IntOnCaption  : if SET, Capture generate interrupt
- * @param[in]   TIM_CaptureConfigStruct	Pointer to TIM_CAPTURECFG_Type
- * @return 		None
- **********************************************************************/
-void TIM_ConfigCapture(TIM_TypeDef *TIMx, TIM_CAPTURECFG_Type *TIM_CaptureConfigStruct)
-{
-	uint32_t timer;
-
-	CHECK_PARAM(PARAM_TIMx(TIMx));
-	timer = TIM_ConverPtrToTimeNum(TIMx) ;
-	TIMx-&gt;CCR &amp;= ~TIM_CCR_CHANNEL_MASKBIT(TIM_CaptureConfigStruct-&gt;CaptureChannel);
-
-	if (TIM_CaptureConfigStruct-&gt;RisingEdge)
-		TIMx-&gt;CCR |= TIM_CAP_RISING(TIM_CaptureConfigStruct-&gt;CaptureChannel);
-
-	if (TIM_CaptureConfigStruct-&gt;FallingEdge)
-		TIMx-&gt;CCR |= TIM_CAP_FALLING(TIM_CaptureConfigStruct-&gt;CaptureChannel);
-
-	if (TIM_CaptureConfigStruct-&gt;IntOnCaption)
-		TIMx-&gt;CCR |= TIM_INT_ON_CAP(TIM_CaptureConfigStruct-&gt;CaptureChannel);
-}
-
-/*********************************************************************//**
- * @brief 		Read value of capture register in timer/counter device
- * @param[in]	TIMx Pointer to timer/counter device
- * @param[in]	CaptureChannel: capture channel number
- * @return 		Value of capture register
- **********************************************************************/
-uint32_t TIM_GetCaptureValue(TIM_TypeDef *TIMx, uint8_t CaptureChannel)
-{
-	CHECK_PARAM(PARAM_TIMx(TIMx));
-	CHECK_PARAM(PARAM_TIM_COUNTER_INPUT_OPT(CaptureChannel));
-
-	if(CaptureChannel==0)
-		return TIMx-&gt;CR0;
-	else
-		return TIMx-&gt;CR1;
-}
-
-/**
- * @}
- */
-
-#endif /* _TIMER */
-
-/**
- * @}
- */
-
-/* --------------------------------- End Of File ------------------------------ */
+/**
+ * @file	: lpc17xx_timer.c
+ * @brief	: Contains all functions support for Timer firmware library on LPC17xx
+ * @version	: 1.0
+ * @date	: 14. April. 2009
+ * @author	: HieuNguyen
+ **************************************************************************
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * products. This software is supplied &quot;AS IS&quot; without any warranties.
+ * NXP Semiconductors assumes no responsibility or liability for the
+ * use of the software, conveys no license or title under any patent,
+ * copyright, or mask work right to the product. NXP Semiconductors
+ * reserves the right to make changes in the software without
+ * notification. NXP Semiconductors also make no representation or
+ * warranty that such application will be suitable for the specified
+ * use without further testing or modification.
+ **********************************************************************/
+
+/* Peripheral group ----------------------------------------------------------- */
+/** @addtogroup TIM
+ * @{
+ */
+
+/* Includes ------------------------------------------------------------------- */
+#include &quot;lpc17xx_timer.h&quot;
+#include &quot;lpc17xx_clkpwr.h&quot;
+#include &quot;lpc17xx_pinsel.h&quot;
+
+/* If this source file built with example, the LPC17xx FW library configuration
+ * file in each example directory (&quot;lpc17xx_libcfg.h&quot;) must be included,
+ * otherwise the default FW library configuration file must be included instead
+ */
+#ifdef __BUILD_WITH_EXAMPLE__
+#include &quot;lpc17xx_libcfg.h&quot;
+#else
+#include &quot;lpc17xx_libcfg_default.h&quot;
+#endif /* __BUILD_WITH_EXAMPLE__ */
+
+#ifdef _TIM
+
+/* Private Functions ---------------------------------------------------------- */
+/** @defgroup TIM_Private_Functions
+ * @{
+ */
+
+uint32_t TIM_GetPClock (uint32_t timernum);
+uint32_t TIM_ConverUSecToVal (uint32_t timernum, uint32_t usec);
+uint32_t TIM_ConverPtrToTimeNum (LPC_TIM_TypeDef *TIMx);
+
+
+/*********************************************************************//**
+ * @brief 		Get peripheral clock of each timer controller
+ * @param[in]	timernum Timer number
+ * @return 		Peripheral clock of timer
+ **********************************************************************/
+
+uint32_t TIM_GetPClock (uint32_t timernum)
+{
+	uint32_t clkdlycnt;
+	switch (timernum)
+	{
+	case 0:
+		clkdlycnt = CLKPWR_GetPCLK (CLKPWR_PCLKSEL_TIMER0);
+		break;
+
+	case 1:
+		clkdlycnt = CLKPWR_GetPCLK (CLKPWR_PCLKSEL_TIMER1);
+		break;
+
+	case 2:
+		clkdlycnt = CLKPWR_GetPCLK (CLKPWR_PCLKSEL_TIMER2);
+		break;
+
+	case 3:
+		clkdlycnt = CLKPWR_GetPCLK (CLKPWR_PCLKSEL_TIMER3);
+		break;
+	}
+	return clkdlycnt;
+}
+
+
+/*********************************************************************//**
+ * @brief 		Convert a time to a timer count value
+ * @param[in]	timernum Timer number
+ * @param[in]	usec Time in microseconds
+ * @return 		The number of required clock ticks to give the time delay
+ **********************************************************************/
+uint32_t TIM_ConverUSecToVal (uint32_t timernum, uint32_t usec)
+{
+	uint64_t clkdlycnt;
+
+	// Get Pclock of timer
+	clkdlycnt = (uint64_t) TIM_GetPClock (timernum);
+
+	clkdlycnt = (clkdlycnt * usec) / 1000000;
+	return (uint32_t) clkdlycnt;
+}
+
+
+/*********************************************************************//**
+ * @brief 		Convert a timer register pointer to a timer number
+ * @param[in]	TIMx Pointer to a timer register set
+ * @return 		The timer number (0 to 3) or -1 if register pointer is bad
+ **********************************************************************/
+uint32_t TIM_ConverPtrToTimeNum (LPC_TIM_TypeDef *TIMx)
+{
+	uint32_t tnum = -1;
+
+	if (TIMx == LPC_TIM0)
+	{
+		tnum = 0;
+	}
+	else if (TIMx == LPC_TIM1)
+	{
+		tnum = 1;
+	}
+	else if (TIMx == LPC_TIM2)
+	{
+		tnum = 2;
+	}
+	else if (TIMx == LPC_TIM3)
+	{
+		tnum = 3;
+	}
+
+	return tnum;
+}
+
+/**
+ * @}
+ */
+
+
+/* Public Functions ----------------------------------------------------------- */
+/** @addtogroup TIM_Public_Functions
+ * @{
+ */
+
+/*********************************************************************//**
+ * @brief 		Get Interrupt Status
+ * @param[in]	TIMx Timer selection, should be TIM0, TIM1, TIM2, TIM3
+ * @param[in]	IntFlag
+ * @return 		FlagStatus
+ * 				- SET : interrupt
+ * 				- RESET : no interrupt
+ **********************************************************************/
+FlagStatus TIM_GetIntStatus(LPC_TIM_TypeDef *TIMx, uint8_t IntFlag)
+{
+	CHECK_PARAM(PARAM_TIMx(TIMx));
+	CHECK_PARAM(PARAM_TIM_INT_TYPE(IntFlag));
+	uint8_t temp = (TIMx-&gt;IR)&amp; TIM_IR_CLR(IntFlag);
+	if (temp)
+		return SET;
+
+	return RESET;
+
+}
+/*********************************************************************//**
+ * @brief 		Get Capture Interrupt Status
+ * @param[in]	TIMx Timer selection, should be TIM0, TIM1, TIM2, TIM3
+ * @param[in]	IntFlag
+ * @return 		FlagStatus
+ * 				- SET : interrupt
+ * 				- RESET : no interrupt
+ **********************************************************************/
+FlagStatus TIM_GetIntCaptureStatus(LPC_TIM_TypeDef *TIMx, uint8_t IntFlag)
+{
+	CHECK_PARAM(PARAM_TIMx(TIMx));
+	CHECK_PARAM(PARAM_TIM_INT_TYPE(IntFlag));
+	uint8_t temp = (TIMx-&gt;IR) &amp; (1&lt;&lt;(4+IntFlag));
+	if(temp)
+		return SET;
+	return RESET;
+}
+/*********************************************************************//**
+ * @brief 		Clear Interrupt pending
+ * @param[in]	TIMx Timer selection, should be TIM0, TIM1, TIM2, TIM3
+ * @param[in]	IntFlag should be in TIM_INT_TYPE enum
+ * @return 		None
+ **********************************************************************/
+void TIM_ClearIntPending(LPC_TIM_TypeDef *TIMx, uint8_t IntFlag)
+{
+	CHECK_PARAM(PARAM_TIMx(TIMx));
+	CHECK_PARAM(PARAM_TIM_INT_TYPE(IntFlag));
+	TIMx-&gt;IR |= TIM_IR_CLR(IntFlag);
+}
+
+/*********************************************************************//**
+ * @brief 		Clear Capture Interrupt pending
+ * @param[in]	TIMx Timer selection, should be TIM0, TIM1, TIM2, TIM3
+ * @param[in]	IntFlag should be in TIM_INT_TYPE enum
+ * @return 		None
+ **********************************************************************/
+void TIM_ClearIntCapturePending(LPC_TIM_TypeDef *TIMx, uint8_t IntFlag)
+{
+	CHECK_PARAM(PARAM_TIMx(TIMx));
+	CHECK_PARAM(PARAM_TIM_INT_TYPE(IntFlag));
+	TIMx-&gt;IR |= (1&lt;&lt;(4+IntFlag));
+}
+
+/*********************************************************************//**
+* @brief 		Configuration for Timer at initial time
+* @param[in] 	TimerCounterMode Should be :
+* 					- PrescaleOption = TC_PRESCALE_USVAL,
+* 					- PrescaleValue = 1
+* 				Counter mode with
+* 					- Caption channel 0
+* @param[in] 	TIM_ConfigStruct pointer to TIM_TIMERCFG_Type or
+* 				TIM_COUNTERCFG_Type
+* @return 		None
+ **********************************************************************/
+void TIM_ConfigStructInit(uint8_t TimerCounterMode, void *TIM_ConfigStruct)
+{
+	if (TimerCounterMode == TIM_TIMER_MODE )
+	{
+		TIM_TIMERCFG_Type * pTimeCfg = (TIM_TIMERCFG_Type *)TIM_ConfigStruct;
+		pTimeCfg-&gt;PrescaleOption = TIM_PRESCALE_USVAL;
+		pTimeCfg-&gt;PrescaleValue = 1;
+	}
+	else
+	{
+		TIM_COUNTERCFG_Type * pCounterCfg = (TIM_COUNTERCFG_Type *)TIM_ConfigStruct;
+		pCounterCfg-&gt;CountInputSelect = TIM_COUNTER_INCAP0;
+
+	}
+}
+
+/*********************************************************************//**
+ * @brief 		Initial Timer/Counter device
+ * 				 	Set Clock frequency for Timer
+ * 					Set initial configuration for Timer
+ * @param[in]	TIMx  Timer selection, should be TIM0, TIM1, TIM2, TIM3
+ * @param[in]	TimerCounterMode TIM_MODE_OPT
+ * @param[in]	TIM_ConfigStruct pointer to TIM_TIMERCFG_Type
+ * 				that contains the configuration information for the
+ *                    specified Timer peripheral.
+ * @return 		None
+ **********************************************************************/
+void TIM_Init(LPC_TIM_TypeDef *TIMx, uint8_t TimerCounterMode, void *TIM_ConfigStruct)
+{
+	TIM_TIMERCFG_Type *pTimeCfg;
+	TIM_COUNTERCFG_Type *pCounterCfg;
+	uint32_t timer;
+
+	CHECK_PARAM(PARAM_TIMx(TIMx));
+	CHECK_PARAM(PARAM_TIM_MODE_OPT(TimerCounterMode));
+
+	timer = TIM_ConverPtrToTimeNum(TIMx) ;
+	//set power
+	if (TIMx== LPC_TIM0)
+	{
+		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCTIM0, ENABLE);
+		CLKPWR_SetPCLKDiv (CLKPWR_PCLKSEL_TIMER0, CLKPWR_PCLKSEL_CCLK_DIV_4);
+	}
+	else if (TIMx== LPC_TIM1)
+	{
+		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCTIM1, ENABLE);
+		CLKPWR_SetPCLKDiv (CLKPWR_PCLKSEL_TIMER1, CLKPWR_PCLKSEL_CCLK_DIV_4);
+
+	}
+
+	else if (TIMx== LPC_TIM2)
+	{
+		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCTIM2, ENABLE);
+		CLKPWR_SetPCLKDiv (CLKPWR_PCLKSEL_TIMER2, CLKPWR_PCLKSEL_CCLK_DIV_4);
+	}
+	else if (TIMx== LPC_TIM3)
+	{
+		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCTIM3, ENABLE);
+		CLKPWR_SetPCLKDiv (CLKPWR_PCLKSEL_TIMER3, CLKPWR_PCLKSEL_CCLK_DIV_4);
+
+	}
+
+	TIMx-&gt;CCR &amp;= ~TIM_CTCR_MODE_MASK;
+	TIMx-&gt;CCR |= TIM_TIMER_MODE;
+
+	TIMx-&gt;TC =0;
+	TIMx-&gt;PC =0;
+	TIMx-&gt;PR =0;
+	if (TimerCounterMode == TIM_TIMER_MODE )
+	{
+		pTimeCfg = (TIM_TIMERCFG_Type *)TIM_ConfigStruct;
+		if (pTimeCfg-&gt;PrescaleOption  == TIM_PRESCALE_TICKVAL)
+		{
+			TIMx-&gt;PR   = pTimeCfg-&gt;PrescaleValue -1  ;
+		}
+		else
+		{
+			TIMx-&gt;PR   = TIM_ConverUSecToVal (TIM_ConverPtrToTimeNum(TIMx),pTimeCfg-&gt;PrescaleValue)-1;
+		}
+	}
+	else
+	{
+
+		pCounterCfg = (TIM_COUNTERCFG_Type *)TIM_ConfigStruct;
+		TIMx-&gt;CCR  &amp;= ~TIM_CTCR_INPUT_MASK;
+		if (pCounterCfg-&gt;CountInputSelect == TIM_COUNTER_INCAP1)
+			TIMx-&gt;CCR |= _BIT(2);
+	}
+
+	// Clear interrupt pending
+	TIMx-&gt;IR = 0xFFFFFFFF;
+
+}
+
+/*********************************************************************//**
+ * @brief 		Close Timer/Counter device
+ * @param[in]	TIMx  Pointer to timer device
+ * @return 		None
+ **********************************************************************/
+void TIM_DeInit (LPC_TIM_TypeDef *TIMx)
+{
+	CHECK_PARAM(PARAM_TIMx(TIMx));
+	// Disable timer/counter
+	TIMx-&gt;TCR = 0x00;
+
+	// Disable power
+	if (TIMx== LPC_TIM0)
+		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCTIM0, DISABLE);
+
+	else if (TIMx== LPC_TIM1)
+		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCTIM1, DISABLE);
+
+	else if (TIMx== LPC_TIM2)
+		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCTIM2, DISABLE);
+
+	else if (TIMx== LPC_TIM3)
+		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCTIM2, DISABLE);
+
+}
+
+/*********************************************************************//**
+ * @brief	 	Start/Stop Timer/Counter device
+ * @param[in]	TIMx Pointer to timer device
+ * @param[in]	NewState
+ * 				-	ENABLE  : set timer enable
+ * 				-	DISABLE : disable timer
+ * @return 		None
+ **********************************************************************/
+void TIM_Cmd(LPC_TIM_TypeDef *TIMx, FunctionalState NewState)
+{
+	CHECK_PARAM(PARAM_TIMx(TIMx));
+	if (NewState == ENABLE)
+	{
+		TIMx-&gt;TCR	|=  TIM_ENABLE;
+	}
+	else
+	{
+		TIMx-&gt;TCR &amp;= ~TIM_ENABLE;
+	}
+}
+
+/*********************************************************************//**
+ * @brief 		Reset Timer/Counter device,
+ * 					Make TC and PC are synchronously reset on the next
+ * 					positive edge of PCLK
+ * @param[in]	TIMx Pointer to timer device
+ * @return 		None
+ **********************************************************************/
+void TIM_ResetCounter(LPC_TIM_TypeDef *TIMx)
+{
+	CHECK_PARAM(PARAM_TIMx(TIMx));
+	TIMx-&gt;TCR |= TIM_RESET;
+	TIMx-&gt;TCR &amp;= ~TIM_RESET;
+}
+
+/*********************************************************************//**
+ * @brief 		Configuration for Match register
+ * @param[in]	TIMx Pointer to timer device
+ * @param[in]   TIM_MatchConfigStruct Pointer to TIM_MATCHCFG_Type
+ * 					- MatchChannel : choose channel 0 or 1
+ * 					- IntOnMatch	 : if SET, interrupt will be generated when MRxx match
+ * 									the value in TC
+ * 					- StopOnMatch	 : if SET, TC and PC will be stopped whenM Rxx match
+ * 									the value in TC
+ * 					- ResetOnMatch : if SET, Reset on MR0 when MRxx match
+ * 									the value in TC
+ * 					-ExtMatchOutputType: Select output for external match
+ * 						 +	 0:	Do nothing for external output pin if match
+ *						 +   1:	Force external output pin to low if match
+ *						 + 	 2: Force external output pin to high if match
+ *						 + 	 3: Toggle external output pin if match
+ *					MatchValue: Set the value to be compared with TC value
+ * @return 		None
+ **********************************************************************/
+void TIM_ConfigMatch(LPC_TIM_TypeDef *TIMx, TIM_MATCHCFG_Type *TIM_MatchConfigStruct)
+{
+	uint32_t timer;
+
+	CHECK_PARAM(PARAM_TIMx(TIMx));
+	CHECK_PARAM(PARAM_TIM_EXTMATCH_OPT(TIM_MatchConfigStruct-&gt;ExtMatchOutputType));
+
+	timer = TIM_ConverPtrToTimeNum(TIMx) ;
+	switch(TIM_MatchConfigStruct-&gt;MatchChannel)
+	{
+	case 0:
+		TIMx-&gt;MR0 = TIM_MatchConfigStruct-&gt;MatchValue;
+		break;
+	case 1:
+		TIMx-&gt;MR1 = TIM_MatchConfigStruct-&gt;MatchValue;
+		break;
+	}
+	//interrupt on MRn
+	TIMx-&gt;MCR &amp;=~TIM_MCR_CHANNEL_MASKBIT(TIM_MatchConfigStruct-&gt;MatchChannel);
+
+	if (TIM_MatchConfigStruct-&gt;IntOnMatch)
+		TIMx-&gt;MCR |= TIM_INT_ON_MATCH(TIM_MatchConfigStruct-&gt;MatchChannel);
+
+	//reset on MRn
+	if (TIM_MatchConfigStruct-&gt;ResetOnMatch)
+		TIMx-&gt;MCR |= TIM_RESET_ON_MATCH(TIM_MatchConfigStruct-&gt;MatchChannel);
+
+	//stop on MRn
+	if (TIM_MatchConfigStruct-&gt;StopOnMatch)
+		TIMx-&gt;MCR |= TIM_STOP_ON_MATCH(TIM_MatchConfigStruct-&gt;MatchChannel);
+//	TIMx-&gt;MCR = 0x02;
+
+	// match output type
+
+	TIMx-&gt;EMR 	&amp;= ~TIM_EM_MASK(TIM_MatchConfigStruct-&gt;MatchChannel);
+	TIMx-&gt;EMR    = TIM_EM_SET(TIM_MatchConfigStruct-&gt;MatchChannel,TIM_MatchConfigStruct-&gt;ExtMatchOutputType);
+}
+/*********************************************************************//**
+ * @brief 		Configuration for Capture register
+ * @param[in]	TIMx Pointer to timer device
+ * 					- CaptureChannel: set the channel to capture data
+ * 					- RisingEdge    : if SET, Capture at rising edge
+ * 					- FallingEdge	: if SET, Capture at falling edge
+ * 					- IntOnCaption  : if SET, Capture generate interrupt
+ * @param[in]   TIM_CaptureConfigStruct	Pointer to TIM_CAPTURECFG_Type
+ * @return 		None
+ **********************************************************************/
+void TIM_ConfigCapture(LPC_TIM_TypeDef *TIMx, TIM_CAPTURECFG_Type *TIM_CaptureConfigStruct)
+{
+	uint32_t timer;
+
+	CHECK_PARAM(PARAM_TIMx(TIMx));
+	timer = TIM_ConverPtrToTimeNum(TIMx) ;
+	TIMx-&gt;CCR &amp;= ~TIM_CCR_CHANNEL_MASKBIT(TIM_CaptureConfigStruct-&gt;CaptureChannel);
+
+	if (TIM_CaptureConfigStruct-&gt;RisingEdge)
+		TIMx-&gt;CCR |= TIM_CAP_RISING(TIM_CaptureConfigStruct-&gt;CaptureChannel);
+
+	if (TIM_CaptureConfigStruct-&gt;FallingEdge)
+		TIMx-&gt;CCR |= TIM_CAP_FALLING(TIM_CaptureConfigStruct-&gt;CaptureChannel);
+
+	if (TIM_CaptureConfigStruct-&gt;IntOnCaption)
+		TIMx-&gt;CCR |= TIM_INT_ON_CAP(TIM_CaptureConfigStruct-&gt;CaptureChannel);
+}
+
+/*********************************************************************//**
+ * @brief 		Read value of capture register in timer/counter device
+ * @param[in]	TIMx Pointer to timer/counter device
+ * @param[in]	CaptureChannel: capture channel number
+ * @return 		Value of capture register
+ **********************************************************************/
+uint32_t TIM_GetCaptureValue(LPC_TIM_TypeDef *TIMx, uint8_t CaptureChannel)
+{
+	CHECK_PARAM(PARAM_TIMx(TIMx));
+	CHECK_PARAM(PARAM_TIM_COUNTER_INPUT_OPT(CaptureChannel));
+
+	if(CaptureChannel==0)
+		return TIMx-&gt;CR0;
+	else
+		return TIMx-&gt;CR1;
+}
+
+/**
+ * @}
+ */
+
+#endif /* _TIMER */
+
+/**
+ * @}
+ */
+
+/* --------------------------------- End Of File ------------------------------ */


Property changes on: trunk/src/platform/lpc17xx/drivers/src/lpc17xx_timer.c
___________________________________________________________________
Deleted: svn:executable
   - *

Modified: trunk/src/platform/lpc17xx/drivers/src/lpc17xx_uart.c
===================================================================
--- trunk/src/platform/lpc17xx/drivers/src/lpc17xx_uart.c	2010-06-28 21:53:59 UTC (rev 759)
+++ trunk/src/platform/lpc17xx/drivers/src/lpc17xx_uart.c	2010-07-12 20:56:54 UTC (rev 760)
@@ -1,1538 +1,1538 @@
-/**
- * @file	: lpc17xx_uart.c
- * @brief	: Contains all functions support for UART firmware library on LPC17xx
- * @version	: 1.0
- * @date	: 18. Mar. 2009
- * @author	: HieuNguyen
- *----------------------------------------------------------------------------
- * Software that is described herein is for illustrative purposes only
- * which provides customers with programming information regarding the
- * products. This software is supplied &quot;AS IS&quot; without any warranties.
- * NXP Semiconductors assumes no responsibility or liability for the
- * use of the software, conveys no license or title under any patent,
- * copyright, or mask work right to the product. NXP Semiconductors
- * reserves the right to make changes in the software without
- * notification. NXP Semiconductors also make no representation or
- * warranty that such application will be suitable for the specified
- * use without further testing or modification.
- **********************************************************************/
-
-/* Peripheral group ----------------------------------------------------------- */
-/** @addtogroup UART
- * @{
- */
-
-/* Includes ------------------------------------------------------------------- */
-#include &quot;lpc17xx_uart.h&quot;
-#include &quot;lpc17xx_clkpwr.h&quot;
-
-/* If this source file built with example, the LPC17xx FW library configuration
- * file in each example directory (&quot;lpc17xx_libcfg.h&quot;) must be included,
- * otherwise the default FW library configuration file must be included instead
- */
-#ifdef __BUILD_WITH_EXAMPLE__
-#include &quot;lpc17xx_libcfg.h&quot;
-#else
-#include &quot;lpc17xx_libcfg_default.h&quot;
-#endif /* __BUILD_WITH_EXAMPLE__ */
-
-
-#ifdef _UART
-
-/* Private Types -------------------------------------------------------------- */
-/** @defgroup UART_Private_Types
- * @{
- */
-
-/**
- * @brief UART call-back function type definitions
- */
-typedef struct {
-	fnTxCbs_Type *pfnTxCbs; 	// Transmit callback
-	fnRxCbs_Type *pfnRxCbs;		// Receive callback
-	fnABCbs_Type *pfnABCbs;		// Auto-Baudrate callback
-	fnErrCbs_Type *pfnErrCbs;	// Error callback
-} UART_CBS_Type;
-
-/**
- * @}
- */
-
-
-/* Private Variables ---------------------------------------------------------- */
-/** @defgroup UART_Private_Variables
- * @{
- */
-
-
-/** Call-back function pointer data */
-UART_CBS_Type uartCbsDat[4] = {
-		{NULL, NULL, NULL, NULL},
-		{NULL, NULL, NULL, NULL},
-		{NULL, NULL, NULL, NULL},
-		{NULL, NULL, NULL, NULL},
-};
-
-/** UART1 modem status interrupt callback pointer data */
-fnModemCbs_Type *pfnModemCbs = NULL;
-
-/**
- * @}
- */
-
-
-/* Private Functions ---------------------------------------------------------- */
-/** @defgroup UART_Private_Functions
- * @{
- */
-
-/**
- * @brief		Get UART number due to UART peripheral pointer
- * @param[in]	UARTx	UART pointer
- * @return		UART number
- */
-uint8_t getUartNum(UART_TypeDef *UARTx) {
-	if (UARTx == UART0) return (0);
-	else if (UARTx == (UART_TypeDef *)UART1) return (1);
-	else if (UARTx == UART2) return (2);
-	else return (3);
-}
-
-/*********************************************************************//**
- * @brief		Determines best dividers to get a target clock rate
- * @param[in]	UARTx	Pointer to selected UART peripheral, should be
- * 						UART0, UART1, UART2 or UART3.
- * @param[in]	baudrate Desired UART baud rate.
- * @return 		Error status.
- **********************************************************************/
-
-Status uart_set_divisors(UART_TypeDef *UARTx, uint32_t baudrate)
-{
-	Status errorStatus = ERROR;
-
-	uint32_t uClk;
-	uint32_t calcBaudrate = 0;
-	uint32_t temp = 0;
-
-	uint32_t mulFracDiv, dividerAddFracDiv;
-	uint32_t diviser = 0 ;
-	uint32_t mulFracDivOptimal = 1;
-	uint32_t dividerAddOptimal = 0;
-	uint32_t diviserOptimal = 0;
-
-	uint32_t relativeError = 0;
-	uint32_t relativeOptimalError = 100000;
-
-	/* get UART block clock */
-	if (UARTx == UART0)
-	{
-		uClk = CLKPWR_GetPCLK (CLKPWR_PCLKSEL_UART0);
-	}
-	else if (UARTx == (UART_TypeDef *)UART1)
-	{
-		uClk = CLKPWR_GetPCLK (CLKPWR_PCLKSEL_UART1);
-	}
-	else if (UARTx == UART2)
-	{
-		uClk = CLKPWR_GetPCLK (CLKPWR_PCLKSEL_UART2);
-	}
-	else if (UARTx == UART3)
-	{
-		uClk = CLKPWR_GetPCLK (CLKPWR_PCLKSEL_UART3);
-	}
-
-
-	uClk = uClk &gt;&gt; 4; /* div by 16 */
-	/* In the Uart IP block, baud rate is calculated using FDR and DLL-DLM registers
-	* The formula is :
-	* BaudRate= uClk * (mulFracDiv/(mulFracDiv+dividerAddFracDiv) / (16 * (DLL)
-	* It involves floating point calculations. That's the reason the formulae are adjusted with
-	* Multiply and divide method.*/
-	/* The value of mulFracDiv and dividerAddFracDiv should comply to the following expressions:
-	* 0 &lt; mulFracDiv &lt;= 15, 0 &lt;= dividerAddFracDiv &lt;= 15 */
-	for (mulFracDiv = 1 ; mulFracDiv &lt;= 15 ;mulFracDiv++)
-	{
-	for (dividerAddFracDiv = 0 ; dividerAddFracDiv &lt;= 15 ;dividerAddFracDiv++)
-	{
-	  temp = (mulFracDiv * uClk) / ((mulFracDiv + dividerAddFracDiv));
-
-	  diviser = temp / baudrate;
-	  if ((temp % baudrate) &gt; (baudrate / 2))
-		diviser++;
-
-	  if (diviser &gt; 2 &amp;&amp; diviser &lt; 65536)
-	  {
-		calcBaudrate = temp / diviser;
-
-		if (calcBaudrate &lt;= baudrate)
-		  relativeError = baudrate - calcBaudrate;
-		else
-		  relativeError = calcBaudrate - baudrate;
-
-		if ((relativeError &lt; relativeOptimalError))
-		{
-		  mulFracDivOptimal = mulFracDiv ;
-		  dividerAddOptimal = dividerAddFracDiv;
-		  diviserOptimal = diviser;
-		  relativeOptimalError = relativeError;
-		  if (relativeError == 0)
-			break;
-		}
-	  } /* End of if */
-	} /* end of inner for loop */
-	if (relativeError == 0)
-	  break;
-	} /* end of outer for loop  */
-
-	if (relativeOptimalError &lt; ((baudrate * UART_ACCEPTED_BAUDRATE_ERROR)/100))
-	{
-		if (((UART1_TypeDef *)UARTx) == UART1)
-		{
-			((UART1_TypeDef *)UARTx)-&gt;LCR |= UART_LCR_DLAB_EN;
-			((UART1_TypeDef *)UARTx)-&gt;/*DLIER.*/DLM = UART_LOAD_DLM(diviserOptimal);
-			((UART1_TypeDef *)UARTx)-&gt;/*RBTHDLR.*/DLL = UART_LOAD_DLL(diviserOptimal);
-			/* Then reset DLAB bit */
-			((UART1_TypeDef *)UARTx)-&gt;LCR &amp;= (~UART_LCR_DLAB_EN) &amp; UART_LCR_BITMASK;
-			((UART1_TypeDef *)UARTx)-&gt;FDR = (UART_FDR_MULVAL(mulFracDivOptimal) \
-					| UART_FDR_DIVADDVAL(dividerAddOptimal)) &amp; UART_FDR_BITMASK;
-		}
-		else
-		{
-			UARTx-&gt;LCR |= UART_LCR_DLAB_EN;
-			UARTx-&gt;/*DLIER.*/DLM = UART_LOAD_DLM(diviserOptimal);
-			UARTx-&gt;/*RBTHDLR.*/DLL = UART_LOAD_DLL(diviserOptimal);
-			/* Then reset DLAB bit */
-			UARTx-&gt;LCR &amp;= (~UART_LCR_DLAB_EN) &amp; UART_LCR_BITMASK;
-			UARTx-&gt;FDR = (UART_FDR_MULVAL(mulFracDivOptimal) \
-					| UART_FDR_DIVADDVAL(dividerAddOptimal)) &amp; UART_FDR_BITMASK;
-		}
-		errorStatus = SUCCESS;
-	}
-
-	return errorStatus;
-}
-
-/*********************************************************************//**
- * @brief		General UART interrupt handler and router
- * @param[in]	UARTx	Selected UART peripheral, should be UART0..3
- * @return		None
- *
- * Note:
- * - Handles transmit, receive, and status interrupts for the UART.
- * Based on the interrupt status, routes the interrupt to the
- * respective call-back to be handled by the user application using
- * this driver.
- * - If callback is not installed, corresponding interrupt will be disabled
- * - All these interrupt source below will be checked:
- *   		- Transmit Holding Register Empty.
- * 			- Received Data Available and Character Time Out.
- * 			- Receive Line Status (not implemented)
- * 			- End of auto-baud interrupt (not implemented)
- * 			- Auto-Baudrate Time-Out interrupt (not implemented)
- * 			- Modem Status interrupt (UART0 Modem functionality)
- * 			- CTS signal transition interrupt (UART0 Modem functionality)
- **********************************************************************/
-void UART_GenIntHandler(UART_TypeDef *UARTx)
-{
-	uint8_t pUart, modemsts;
-	uint32_t intsrc, tmp, tmp1;
-
-	pUart = getUartNum(UARTx);
-
-	/* Determine the interrupt source */
-	intsrc = UARTx-&gt;IIR;
-	tmp = intsrc &amp; UART_IIR_INTID_MASK;
-
-	/*
-	 * In case of using UART1 with full modem,
-	 * interrupt ID = 0 that means modem status interrupt has been detected
-	 */
-	if (pUart == 1) {
-		if (tmp == 0){
-			// Check Modem status
-			modemsts = UART1-&gt;MSR &amp; UART1_MSR_BITMASK;
-			// Call modem status call-back
-			if (pfnModemCbs != NULL){
-				pfnModemCbs(modemsts);
-			}
-			// disable modem status interrupt and CTS status change interrupt
-			// if its callback is not installed
-			else {
-				UART1-&gt;IER &amp;= ~(UART1_IER_MSINT_EN | UART1_IER_CTSINT_EN);
-			}
-		}
-	}
-
-	// Receive Line Status
-	if (tmp == UART_IIR_INTID_RLS){
-		// Check line status
-		tmp1 = UARTx-&gt;LSR;
-		// Mask out the Receive Ready and Transmit Holding empty status
-		tmp1 &amp;= (UART_LSR_OE | UART_LSR_PE | UART_LSR_FE \
-				| UART_LSR_BI | UART_LSR_RXFE);
-		// If any error exist
-		if (tmp1) {
-			// Call Call-back function with error input value
-			if (uartCbsDat[pUart].pfnErrCbs != NULL) {
-				uartCbsDat[pUart].pfnErrCbs(tmp1);
-			}
-			// Disable interrupt if its call-back is not install
-			else {
-				UARTx-&gt;IER &amp;= ~(UART_IER_RLSINT_EN);
-			}
-		}
-	}
-
-	// Receive Data Available or Character time-out
-	if ((tmp == UART_IIR_INTID_RDA) || (tmp == UART_IIR_INTID_CTI)){
-		// Call Rx call back function
-		if (uartCbsDat[pUart].pfnRxCbs != NULL) {
-			uartCbsDat[pUart].pfnRxCbs();
-		}
-		// Disable interrupt if its call-back is not install
-		else {
-			UARTx-&gt;IER &amp;= ~(UART_IER_RBRINT_EN);
-		}
-	}
-
-	// Transmit Holding Empty
-	if (tmp == UART_IIR_INTID_THRE){
-		// Call Tx call back function
-		if (uartCbsDat[pUart].pfnTxCbs != NULL) {
-			uartCbsDat[pUart].pfnTxCbs();
-		}
-		// Disable interrupt if its call-back is not install
-		else {
-			UARTx-&gt;IER &amp;= ~(UART_IER_THREINT_EN);
-		}
-	}
-
-	intsrc &amp;= (UART_IIR_ABEO_INT | UART_IIR_ABTO_INT);
-	// Check if End of auto-baudrate interrupt or Auto baudrate time out
-	if (intsrc){
-		// Clear interrupt pending
-		UARTx-&gt;ACR |= ((intsrc &amp; UART_IIR_ABEO_INT) ? UART_ACR_ABEOINT_CLR : 0) \
-						| ((intsrc &amp; UART_IIR_ABTO_INT) ? UART_ACR_ABTOINT_CLR : 0);
-		if (uartCbsDat[pUart].pfnABCbs != NULL) {
-			uartCbsDat[pUart].pfnABCbs(intsrc);
-		} else {
-			// Disable End of AB interrupt
-			UARTx-&gt;IER &amp;= ~(UART_IER_ABEOINT_EN | UART_IER_ABTOINT_EN);
-		}
-	}
-}
-
-/**
- * @}
- */
-
-
-/* Public Functions ----------------------------------------------------------- */
-/** @addtogroup UART_Public_Functions
- * @{
- */
-
-/*********************************************************************//**
- * @brief		De-initializes the UARTx peripheral registers to their
-*                  default reset values.
- * @param[in]	UARTx	UART peripheral selected, should be UART0, UART1,
- * 						UART2 or UART3.
- * @return 		None
- **********************************************************************/
-void UART_DeInit(UART_TypeDef* UARTx)
-{
-	// For debug mode
-	CHECK_PARAM(PARAM_UARTx(UARTx));
-
-	UART_TxCmd(UARTx, DISABLE);
-
-#ifdef _UART0
-	if (UARTx == UART0)
-	{
-		/* Set up clock and power for UART module */
-		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCUART0, DISABLE);
-	}
-#endif
-
-#ifdef _UART1
-	if (((UART1_TypeDef *)UARTx) == UART1)
-	{
-		/* Set up clock and power for UART module */
-		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCUART1, DISABLE);
-	}
-#endif
-
-#ifdef _UART2
-	if (UARTx == UART2)
-	{
-		/* Set up clock and power for UART module */
-		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCUART2, DISABLE);
-	}
-#endif
-
-#ifdef _UART3
-	if (UARTx == UART3)
-	{
-		/* Set up clock and power for UART module */
-		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCUART3, DISABLE);
-	}
-#endif
-}
-
-/********************************************************************//**
- * @brief		Initializes the UARTx peripheral according to the specified
-*               parameters in the UART_ConfigStruct.
- * @param[in]	UARTx	UART peripheral selected, should be UART0, UART1,
- * 						UART2 or UART3.
- * @param[in]	UART_ConfigStruct Pointer to a UART_CFG_Type structure
-*                    that contains the configuration information for the
-*                    specified UART peripheral.
- * @return 		None
- *********************************************************************/
-void UART_Init(UART_TypeDef *UARTx, UART_CFG_Type *UART_ConfigStruct)
-{
-	uint32_t tmp;
-
-	// For debug mode
-	CHECK_PARAM(PARAM_UARTx(UARTx));
-	CHECK_PARAM(PARAM_UART_DATABIT(UART_ConfigStruct-&gt;Databits));
-	CHECK_PARAM(PARAM_UART_STOPBIT(UART_ConfigStruct-&gt;Stopbits));
-	CHECK_PARAM(PARAM_UART_PARITY(UART_ConfigStruct-&gt;Parity));
-
-#ifdef _UART0
-	if(UARTx == UART0)
-	{
-		/* Set up clock and power for UART module */
-		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCUART0, ENABLE);
-	}
-#endif
-
-#ifdef _UART1
-	if(((UART1_TypeDef *)UARTx) == UART1)
-	{
-		/* Set up clock and power for UART module */
-		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCUART1, ENABLE);
-	}
-#endif
-
-#ifdef _UART2
-	if(UARTx == UART2)
-	{
-		/* Set up clock and power for UART module */
-		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCUART2, ENABLE);
-	}
-#endif
-
-#ifdef _UART3
-	if(UARTx == UART3)
-	{
-		/* Set up clock and power for UART module */
-		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCUART3, ENABLE);
-	}
-#endif
-
-	if (((UART1_TypeDef *)UARTx) == UART1)
-	{
-		/* FIFOs are empty */
-		((UART1_TypeDef *)UARTx)-&gt;/*IIFCR.*/FCR = ( UART_FCR_FIFO_EN \
-				| UART_FCR_RX_RS | UART_FCR_TX_RS);
-		// Disable FIFO
-		((UART1_TypeDef *)UARTx)-&gt;/*IIFCR.*/FCR = 0;
-
-		// Dummy reading
-		while (((UART1_TypeDef *)UARTx)-&gt;LSR &amp; UART_LSR_RDR)
-		{
-			tmp = ((UART1_TypeDef *)UARTx)-&gt;/*RBTHDLR.*/RBR;
-		}
-
-		((UART1_TypeDef *)UARTx)-&gt;TER = UART_TER_TXEN;
-		// Wait for current transmit complete
-		while (!(((UART1_TypeDef *)UARTx)-&gt;LSR &amp; UART_LSR_THRE));
-		// Disable Tx
-		((UART1_TypeDef *)UARTx)-&gt;TER = 0;
-
-		// Disable interrupt
-		((UART1_TypeDef *)UARTx)-&gt;/*DLIER.*/IER = 0;
-		// Set LCR to default state
-		((UART1_TypeDef *)UARTx)-&gt;LCR = 0;
-		// Set ACR to default state
-		((UART1_TypeDef *)UARTx)-&gt;ACR = 0;
-		// Set Modem Control to default state
-		((UART1_TypeDef *)UARTx)-&gt;MCR = 0;
-		// Set RS485 control to default state
-		((UART1_TypeDef *)UARTx)-&gt;RS485CTRL = 0;
-		// Set RS485 delay timer to default state
-		((UART1_TypeDef *)UARTx)-&gt;RS485DLY = 0;
-		// Set RS485 addr match to default state
-		((UART1_TypeDef *)UARTx)-&gt;ADRMATCH = 0;
-		//Dummy Reading to Clear Status
-		tmp = ((UART1_TypeDef *)UARTx)-&gt;MSR;
-		tmp = ((UART1_TypeDef *)UARTx)-&gt;LSR;
-	}
-	else
-	{
-		/* FIFOs are empty */
-		UARTx-&gt;/*IIFCR.*/FCR = ( UART_FCR_FIFO_EN | UART_FCR_RX_RS | UART_FCR_TX_RS);
-		// Disable FIFO
-		UARTx-&gt;/*IIFCR.*/FCR = 0;
-
-		// Dummy reading
-		while (UARTx-&gt;LSR &amp; UART_LSR_RDR)
-		{
-			tmp = UARTx-&gt;/*RBTHDLR.*/RBR;
-		}
-
-		UARTx-&gt;TER = UART_TER_TXEN;
-		// Wait for current transmit complete
-		while (!(UARTx-&gt;LSR &amp; UART_LSR_THRE));
-		// Disable Tx
-		UARTx-&gt;TER = 0;
-
-		// Disable interrupt
-		UARTx-&gt;/*DLIER.*/IER = 0;
-		// Set LCR to default state
-		UARTx-&gt;LCR = 0;
-		// Set ACR to default state
-		UARTx-&gt;ACR = 0;
-		// Dummy reading
-		tmp = UARTx-&gt;LSR;
-	}
-
-	if (UARTx == UART3)
-	{
-		// Set IrDA to default state
-		UARTx-&gt;ICR = 0;
-	}
-
-	// Set Line Control register ----------------------------
-
-	uart_set_divisors(UARTx, (UART_ConfigStruct-&gt;Baud_rate));
-
-	if (((UART1_TypeDef *)UARTx) == UART1)
-	{
-		tmp = (((UART1_TypeDef *)UARTx)-&gt;LCR &amp; (UART_LCR_DLAB_EN | UART_LCR_BREAK_EN)) \
-				&amp; UART_LCR_BITMASK;
-	}
-	else
-	{
-		tmp = (UARTx-&gt;LCR &amp; (UART_LCR_DLAB_EN | UART_LCR_BREAK_EN)) &amp; UART_LCR_BITMASK;
-	}
-
-	switch (UART_ConfigStruct-&gt;Databits){
-	case UART_DATABIT_5:
-		tmp |= UART_LCR_WLEN5;
-		break;
-	case UART_DATABIT_6:
-		tmp |= UART_LCR_WLEN6;
-		break;
-	case UART_DATABIT_7:
-		tmp |= UART_LCR_WLEN7;
-		break;
-	case UART_DATABIT_8:
-	default:
-		tmp |= UART_LCR_WLEN8;
-		break;
-	}
-
-	if (UART_ConfigStruct-&gt;Parity == UART_PARITY_NONE)
-	{
-		// Do nothing...
-	}
-	else
-	{
-		tmp |= UART_LCR_PARITY_EN;
-		switch (UART_ConfigStruct-&gt;Parity)
-		{
-		case UART_PARITY_ODD:
-			tmp |= UART_LCR_PARITY_ODD;
-			break;
-
-		case UART_PARITY_EVEN:
-			tmp |= UART_LCR_PARITY_EVEN;
-			break;
-
-		case UART_PARITY_SP_1:
-			tmp |= UART_LCR_PARITY_F_1;
-			break;
-
-		case UART_PARITY_SP_0:
-			tmp |= UART_LCR_PARITY_F_0;
-			break;
-		default:
-			break;
-		}
-	}
-
-	switch (UART_ConfigStruct-&gt;Stopbits){
-	case UART_STOPBIT_2:
-		tmp |= UART_LCR_STOPBIT_SEL;
-		break;
-	case UART_STOPBIT_1:
-	default:
-		// Do no thing
-		break;
-	}
-
-
-	// Write back to LCR, configure FIFO and Disable Tx
-	if (((UART1_TypeDef *)UARTx) ==  UART1)
-	{
-		((UART1_TypeDef *)UARTx)-&gt;LCR = (uint8_t)(tmp &amp; UART_LCR_BITMASK);
-	}
-	else
-	{
-		UARTx-&gt;LCR = (uint8_t)(tmp &amp; UART_LCR_BITMASK);
-	}
-}
-
-
-/*****************************************************************************//**
-* @brief		Fills each UART_InitStruct member with its default value:
-* 				9600 bps
-* 				8-bit data
-* 				1 Stopbit
-* 				None Parity
-* @param[in]	UART_InitStruct Pointer to a UART_CFG_Type structure
-*                    which will be initialized.
-* @return		None
-*******************************************************************************/
-void UART_ConfigStructInit(UART_CFG_Type *UART_InitStruct)
-{
-	UART_InitStruct-&gt;Baud_rate = 9600;
-	UART_InitStruct-&gt;Databits = UART_DATABIT_8;
-	UART_InitStruct-&gt;Parity = UART_PARITY_NONE;
-	UART_InitStruct-&gt;Stopbits = UART_STOPBIT_1;
-}
-
-
-/*********************************************************************//**
- * @brief		Transmit a single data through UART peripheral
- * @param[in]	UARTx	UART peripheral selected, should be UART0, UART1,
- * 						UART2 or UART3.
- * @param[in]	Data	Data to transmit (must be 8-bit long)
- * @return none
- **********************************************************************/
-void UART_SendData(UART_TypeDef* UARTx, uint8_t Data)
-{
-	CHECK_PARAM(PARAM_UARTx(UARTx));
-
-	if (((UART1_TypeDef *)UARTx) == UART1)
-	{
-		((UART1_TypeDef *)UARTx)-&gt;/*RBTHDLR.*/THR = Data &amp; UART_THR_MASKBIT;
-	}
-	else
-	{
-		UARTx-&gt;/*RBTHDLR.*/THR = Data &amp; UART_THR_MASKBIT;
-	}
-
-}
-
-
-/*********************************************************************//**
- * @brief		Receive a single data from UART peripheral
- * @param[in]	UARTx	UART peripheral selected, should be UART0, UART1,
- * 						UART2 or UART3.
- * @return 		Data received
- **********************************************************************/
-uint8_t UART_ReceiveData(UART_TypeDef* UARTx)
-{
-	CHECK_PARAM(PARAM_UARTx(UARTx));
-
-	if (((UART1_TypeDef *)UARTx) == UART1)
-	{
-		return (((UART1_TypeDef *)UARTx)-&gt;/*RBTHDLR.*/RBR &amp; UART_RBR_MASKBIT);
-	}
-	else
-	{
-		return (UARTx-&gt;/*RBTHDLR.*/RBR &amp; UART_RBR_MASKBIT);
-	}
-}
-
-
-/*********************************************************************//**
- * @brief		Force BREAK character on UART line, output pin UARTx TXD is
-				forced to logic 0.
- * @param[in]	UARTx	UART peripheral selected, should be UART0, UART1,
- * 						UART2 or UART3.
- * @return none
- **********************************************************************/
-void UART_ForceBreak(UART_TypeDef* UARTx)
-{
-	CHECK_PARAM(PARAM_UARTx(UARTx));
-
-	if (((UART1_TypeDef *)UARTx) == UART1)
-	{
-		((UART1_TypeDef *)UARTx)-&gt;LCR |= UART_LCR_BREAK_EN;
-	}
-	else
-	{
-		UARTx-&gt;LCR |= UART_LCR_BREAK_EN;
-	}
-}
-
-
-#ifdef _UART3
-
-/*********************************************************************//**
- * @brief		Enable or disable inverting serial input function of IrDA
- * 				on UART peripheral.
- * @param[in]	UARTx UART peripheral selected, should be UART3 (only)
- * @param[in]	NewState New state of inverting serial input, should be:
- * 				- ENABLE: Enable this function.
- * 				- DISABLE: Disable this function.
- * @return none
- **********************************************************************/
-void UART_IrDAInvtInputCmd(UART_TypeDef* UARTx, FunctionalState NewState)
-{
-	CHECK_PARAM(PARAM_UART_IrDA(UARTx));
-	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
-
-	if (NewState == ENABLE)
-	{
-		UARTx-&gt;ICR |= UART_ICR_IRDAINV;
-	}
-	else if (NewState == DISABLE)
-	{
-		UARTx-&gt;ICR &amp;= (~UART_ICR_IRDAINV) &amp; UART_ICR_BITMASK;
-	}
-}
-
-
-/*********************************************************************//**
- * @brief		Enable or disable IrDA function on UART peripheral.
- * @param[in]	UARTx UART peripheral selected, should be UART3 (only)
- * @param[in]	NewState New state of IrDA function, should be:
- * 				- ENABLE: Enable this function.
- * 				- DISABLE: Disable this function.
- * @return none
- **********************************************************************/
-void UART_IrDACmd(UART_TypeDef* UARTx, FunctionalState NewState)
-{
-	CHECK_PARAM(PARAM_UART_IrDA(UARTx));
-	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
-
-	if (NewState == ENABLE)
-	{
-		UARTx-&gt;ICR |= UART_ICR_IRDAEN;
-	}
-	else
-	{
-		UARTx-&gt;ICR &amp;= (~UART_ICR_IRDAEN) &amp; UART_ICR_BITMASK;
-	}
-}
-
-
-/*********************************************************************//**
- * @brief		Configure Pulse divider for IrDA function on UART peripheral.
- * @param[in]	UARTx UART peripheral selected, should be UART3 (only)
- * @param[in]	PulseDiv Pulse Divider value from Peripheral clock,
- * 				should be one of the following:
-				- UART_IrDA_PULSEDIV2 	: Pulse width = 2 * Tpclk
-				- UART_IrDA_PULSEDIV4 	: Pulse width = 4 * Tpclk
-				- UART_IrDA_PULSEDIV8 	: Pulse width = 8 * Tpclk
-				- UART_IrDA_PULSEDIV16 	: Pulse width = 16 * Tpclk
-				- UART_IrDA_PULSEDIV32 	: Pulse width = 32 * Tpclk
-				- UART_IrDA_PULSEDIV64 	: Pulse width = 64 * Tpclk
-				- UART_IrDA_PULSEDIV128 : Pulse width = 128 * Tpclk
-				- UART_IrDA_PULSEDIV256 : Pulse width = 256 * Tpclk
-
- * @return none
- **********************************************************************/
-void UART_IrDAPulseDivConfig(UART_TypeDef *UARTx, UART_IrDA_PULSE_Type PulseDiv)
-{
-	uint32_t tmp, tmp1;
-	CHECK_PARAM(PARAM_UART_IrDA(UARTx));
-	CHECK_PARAM(PARAM_UART_IrDA_PULSEDIV(PulseDiv));
-
-	tmp1 = UART_ICR_PULSEDIV(PulseDiv);
-	tmp = UARTx-&gt;ICR &amp; (~UART_ICR_PULSEDIV(7));
-	tmp |= tmp1 | UART_ICR_FIXPULSE_EN;
-	UARTx-&gt;ICR = tmp &amp; UART_ICR_BITMASK;
-}
-
-#endif
-
-
-/********************************************************************//**
- * @brief 		Enable or disable specified UART interrupt.
- * @param[in]	UARTx	UART peripheral selected, should be UART0, UART1,
- * 						UART2 or UART3.
- * @param[in]	UARTIntCfg	Specifies the interrupt flag,
- * 				should be one of the following:
-				- UART_INTCFG_RBR 	:  RBR Interrupt enable
-				- UART_INTCFG_THRE 	:  THR Interrupt enable
-				- UART_INTCFG_RLS 	:  RX line status interrupt enable
-				- UART1_INTCFG_MS	:  Modem status interrupt enable (UART1 only)
-				- UART1_INTCFG_CTS	:  CTS1 signal transition interrupt enable (UART1 only)
-				- UART_INTCFG_ABEO 	:  Enables the end of auto-baud interrupt
-				- UART_INTCFG_ABTO 	:  Enables the auto-baud time-out interrupt
- * @param[in]	NewState New state of specified UART interrupt type,
- * 				should be:
- * 				- ENALBE: Enable this UART interrupt type.
-* 				- DISALBE: Disable this UART interrupt type.
- * @return 		None
- *********************************************************************/
-void UART_IntConfig(UART_TypeDef *UARTx, UART_INT_Type UARTIntCfg, FunctionalState NewState)
-{
-	uint32_t tmp;
-
-	CHECK_PARAM(PARAM_UARTx(UARTx));
-	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
-
-	switch(UARTIntCfg){
-		case UART_INTCFG_RBR:
-			tmp = UART_IER_RBRINT_EN;
-			break;
-		case UART_INTCFG_THRE:
-			tmp = UART_IER_THREINT_EN;
-			break;
-		case UART_INTCFG_RLS:
-			tmp = UART_IER_RLSINT_EN;
-			break;
-		case UART1_INTCFG_MS:
-			tmp = UART1_IER_MSINT_EN;
-			break;
-		case UART1_INTCFG_CTS:
-			tmp = UART1_IER_CTSINT_EN;
-			break;
-		case UART_INTCFG_ABEO:
-			tmp = UART_IER_ABEOINT_EN;
-			break;
-		case UART_INTCFG_ABTO:
-			tmp = UART_IER_ABTOINT_EN;
-			break;
-	}
-
-	if ((UART1_TypeDef *) UARTx == UART1)
-	{
-		CHECK_PARAM((PARAM_UART_INTCFG(UARTIntCfg)) || (PARAM_UART1_INTCFG(UARTIntCfg)));
-	}
-	else
-	{
-		CHECK_PARAM(PARAM_UART_INTCFG(UARTIntCfg));
-	}
-
-	if (NewState == ENABLE)
-	{
-		if ((UART1_TypeDef *) UARTx == UART1)
-		{
-			((UART1_TypeDef *)UARTx)-&gt;/*DLIER.*/IER |= tmp;
-		}
-		else
-		{
-			UARTx-&gt;/*DLIER.*/IER |= tmp;
-		}
-	}
-	else
-	{
-		if ((UART1_TypeDef *) UARTx == UART1)
-		{
-			((UART1_TypeDef *)UARTx)-&gt;/*DLIER.*/IER &amp;= (~tmp) &amp; UART1_IER_BITMASK;
-		}
-		else
-		{
-			UARTx-&gt;/*DLIER.*/IER &amp;= (~tmp) &amp; UART_IER_BITMASK;
-		}
-	}
-}
-
-
-/********************************************************************//**
- * @brief 		Get current value of Line Status register in UART peripheral.
- * @param[in]	UARTx	UART peripheral selected, should be UART0, UART1,
- * 						UART2 or UART3.
- * @return		Current value of Line Status register in UART peripheral.
- * Note:	The return value of this function must be ANDed with each member in
- * 			UART_LS_Type enumeration to determine current flag status
- * 			corresponding to each Line status type. Because some flags in
- * 			Line Status register will be cleared after reading, the next reading
- * 			Line Status register could not be correct. So this function used to
- * 			read Line status register in one time only, then the return value
- * 			used to check all flags.
- *********************************************************************/
-uint8_t UART_GetLineStatus(UART_TypeDef* UARTx)
-{
-	CHECK_PARAM(PARAM_UARTx(UARTx));
-
-	if (((UART1_TypeDef *)UARTx) == UART1)
-	{
-		return ((((UART1_TypeDef *)UART1)-&gt;LSR) &amp; UART_LSR_BITMASK);
-	}
-	else
-	{
-		return ((UARTx-&gt;LSR) &amp; UART_LSR_BITMASK);
-	}
-}
-
-/*********************************************************************//**
- * @brief		Check whether if UART is busy or not
- * @param[in]	UARTx	UART peripheral selected, should be UART0, UART1,
- * 						UART2 or UART3.
- * @return		RESET if UART is not busy, otherwise return SET.
- **********************************************************************/
-FlagStatus UART_CheckBusy(UART_TypeDef *UARTx)
-{
-	if (UARTx-&gt;LSR &amp; UART_LSR_TEMT){
-		return RESET;
-	} else {
-		return SET;
-	}
-}
-
-
-/*********************************************************************//**
- * @brief		Configure FIFO function on selected UART peripheral
- * @param[in]	UARTx	UART peripheral selected, should be UART0, UART1,
- * 						UART2 or UART3.
- * @param[in]	FIFOCfg	Pointer to a UART_FIFO_CFG_Type Structure that
- * 						contains specified information about FIFO configuration
- * @return 		none
- **********************************************************************/
-void UART_FIFOConfig(UART_TypeDef *UARTx, UART_FIFO_CFG_Type *FIFOCfg)
-{
-	uint8_t tmp = 0;
-
-	CHECK_PARAM(PARAM_UARTx(UARTx));
-	CHECK_PARAM(PARAM_UART_FIFO_LEVEL(FIFOCfg-&gt;FIFO_Level));
-	CHECK_PARAM(PARAM_FUNCTIONALSTATE(FIFOCfg-&gt;FIFO_DMAMode));
-	CHECK_PARAM(PARAM_FUNCTIONALSTATE(FIFOCfg-&gt;FIFO_ResetRxBuf));
-	CHECK_PARAM(PARAM_FUNCTIONALSTATE(FIFOCfg-&gt;FIFO_ResetTxBuf));
-
-	tmp |= UART_FCR_FIFO_EN;
-	switch (FIFOCfg-&gt;FIFO_Level){
-	case UART_FIFO_TRGLEV0:
-		tmp |= UART_FCR_TRG_LEV0;
-		break;
-	case UART_FIFO_TRGLEV1:
-		tmp |= UART_FCR_TRG_LEV1;
-		break;
-	case UART_FIFO_TRGLEV2:
-		tmp |= UART_FCR_TRG_LEV2;
-		break;
-	case UART_FIFO_TRGLEV3:
-	default:
-		tmp |= UART_FCR_TRG_LEV3;
-		break;
-	}
-
-	if (FIFOCfg-&gt;FIFO_ResetTxBuf == ENABLE)
-	{
-		tmp |= UART_FCR_TX_RS;
-	}
-	if (FIFOCfg-&gt;FIFO_ResetRxBuf == ENABLE)
-	{
-		tmp |= UART_FCR_RX_RS;
-	}
-	if (FIFOCfg-&gt;FIFO_DMAMode == ENABLE)
-	{
-		tmp |= UART_FCR_DMAMODE_SEL;
-	}
-
-
-	//write to FIFO control register
-	if (((UART1_TypeDef *)UARTx) == UART1)
-	{
-		((UART1_TypeDef *)UARTx)-&gt;/*IIFCR.*/FCR = tmp &amp; UART_FCR_BITMASK;
-	}
-	else
-	{
-		UARTx-&gt;/*IIFCR.*/FCR = tmp &amp; UART_FCR_BITMASK;
-	}
-
-}
-
-
-/*****************************************************************************//**
-* @brief		Fills each UART_FIFOInitStruct member with its default value:
-* 				- FIFO_DMAMode = DISABLE
-* 				- FIFO_Level = UART_FIFO_TRGLEV0
-* 				- FIFO_ResetRxBuf = ENABLE
-* 				- FIFO_ResetTxBuf = ENABLE
-* 				- FIFO_State = ENABLE
-
-* @param[in]	UART_FIFOInitStruct Pointer to a UART_FIFO_CFG_Type structure
-*                    which will be initialized.
-* @return		None
-*******************************************************************************/
-void UART_FIFOConfigStructInit(UART_FIFO_CFG_Type *UART_FIFOInitStruct)
-{
-	UART_FIFOInitStruct-&gt;FIFO_DMAMode = DISABLE;
-	UART_FIFOInitStruct-&gt;FIFO_Level = UART_FIFO_TRGLEV0;
-	UART_FIFOInitStruct-&gt;FIFO_ResetRxBuf = ENABLE;
-	UART_FIFOInitStruct-&gt;FIFO_ResetTxBuf = ENABLE;
-}
-
-
-/*********************************************************************//**
- * @brief		Start/Stop Auto Baudrate activity
- * @param[in]	UARTx	UART peripheral selected, should be UART0, UART1,
- * 						UART2 or UART3.
- * @param[in]	ABConfigStruct	A pointer to UART_AB_CFG_Type structure that
- * 								contains specified information about UART
- * 								auto baudrate configuration
- * @param[in]	NewState New State of Auto baudrate activity, should be:
- * 				- ENABLE: Start this activity
- *				- DISABLE: Stop this activity
- * Note:		Auto-baudrate mode enable bit will be cleared once this mode
- * 				completed.
- * @return 		none
- **********************************************************************/
-void UART_ABCmd(UART_TypeDef *UARTx, UART_AB_CFG_Type *ABConfigStruct, \
-				FunctionalState NewState)
-{
-	uint32_t tmp;
-
-	CHECK_PARAM(PARAM_UARTx(UARTx));
-	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
-
-	tmp = 0;
-	if (NewState == ENABLE) {
-		if (ABConfigStruct-&gt;ABMode == UART_AUTOBAUD_MODE1){
-			tmp |= UART_ACR_MODE;
-		}
-		if (ABConfigStruct-&gt;AutoRestart == ENABLE){
-			tmp |= UART_ACR_AUTO_RESTART;
-		}
-	}
-
-	if (((UART1_TypeDef *)UARTx) == UART1)
-	{
-		if (NewState == ENABLE)
-		{
-			// Clear DLL and DLM value
-			((UART1_TypeDef *)UARTx)-&gt;LCR |= UART_LCR_DLAB_EN;
-			((UART1_TypeDef *)UARTx)-&gt;DLL = 0;
-			((UART1_TypeDef *)UARTx)-&gt;DLM = 0;
-			((UART1_TypeDef *)UARTx)-&gt;LCR &amp;= ~UART_LCR_DLAB_EN;
-			// FDR value must be reset to default value
-			((UART1_TypeDef *)UARTx)-&gt;FDR = 0x10;
-			((UART1_TypeDef *)UARTx)-&gt;ACR = UART_ACR_START | tmp;
-		}
-		else
-		{
-			((UART1_TypeDef *)UARTx)-&gt;ACR = 0;
-		}
-	}
-	else
-	{
-		if (NewState == ENABLE)
-		{
-			// Clear DLL and DLM value
-			UARTx-&gt;LCR |= UART_LCR_DLAB_EN;
-			UARTx-&gt;DLL = 0;
-			UARTx-&gt;DLM = 0;
-			UARTx-&gt;LCR &amp;= ~UART_LCR_DLAB_EN;
-			// FDR value must be reset to default value
-			UARTx-&gt;FDR = 0x10;
-			UARTx-&gt;ACR = UART_ACR_START | tmp;
-		}
-		else
-		{
-			UARTx-&gt;ACR = 0;
-		}
-	}
-}
-
-
-/*********************************************************************//**
- * @brief		Enable/Disable transmission on UART TxD pin
- * @param[in]	UARTx	UART peripheral selected, should be UART0, UART1,
- * 						UART2 or UART3.
- * @param[in]	NewState New State of Tx transmission function, should be:
- * 				- ENABLE: Enable this function
-				- DISABLE: Disable this function
- * @return none
- **********************************************************************/
-void UART_TxCmd(UART_TypeDef *UARTx, FunctionalState NewState)
-{
-	CHECK_PARAM(PARAM_UARTx(UARTx));
-	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
-
-	if (NewState == ENABLE)
-	{
-		if (((UART1_TypeDef *)UARTx) == UART1)
-		{
-			((UART1_TypeDef *)UARTx)-&gt;TER |= UART_TER_TXEN;
-		}
-		else
-		{
-			UARTx-&gt;TER |= UART_TER_TXEN;
-		}
-	}
-	else
-	{
-		if (((UART1_TypeDef *)UARTx) == UART1)
-		{
-			((UART1_TypeDef *)UARTx)-&gt;TER &amp;= (~UART_TER_TXEN) &amp; UART_TER_BITMASK;
-		}
-		else
-		{
-			UARTx-&gt;TER &amp;= (~UART_TER_TXEN) &amp; UART_TER_BITMASK;
-		}
-	}
-}
-
-#ifdef _UART1
-
-/*********************************************************************//**
- * @brief		Force pin DTR/RTS corresponding to given state (Full modem mode)
- * @param[in]	UARTx	UART1 (only)
- * @param[in]	Pin	Pin that NewState will be applied to, should be:
- * 				- UART1_MODEM_PIN_DTR: DTR pin.
- * 				- UART1_MODEM_PIN_RTS: RTS pin.
- * @param[in]	NewState New State of DTR/RTS pin, should be:
- * 				- INACTIVE: Force the pin to inactive signal.
-				- ACTIVE: Force the pin to active signal.
- * @return none
- **********************************************************************/
-void UART_FullModemForcePinState(UART1_TypeDef *UARTx, UART_MODEM_PIN_Type Pin, \
-							UART1_SignalState NewState)
-{
-	uint8_t tmp = 0;
-
-	CHECK_PARAM(PARAM_UART1_MODEM(UARTx));
-	CHECK_PARAM(PARAM_UART1_MODEM_PIN(Pin));
-	CHECK_PARAM(PARAM_UART1_SIGNALSTATE(NewState));
-
-	switch (Pin){
-	case UART1_MODEM_PIN_DTR:
-		tmp = UART1_MCR_DTR_CTRL;
-		break;
-	case UART1_MODEM_PIN_RTS:
-		tmp = UART1_MCR_RTS_CTRL;
-		break;
-	default:
-		break;
-	}
-
-	if (NewState == ACTIVE){
-		UARTx-&gt;MCR |= tmp;
-	} else {
-		UARTx-&gt;MCR &amp;= (~tmp) &amp; UART1_MCR_BITMASK;
-	}
-}
-
-
-/*********************************************************************//**
- * @brief		Configure Full Modem mode for UART peripheral
- * @param[in]	UARTx	UART1 (only)
- * @param[in]	Mode Full Modem mode, should be:
- * 				- UART1_MODEM_MODE_LOOPBACK: Loop back mode.
- * 				- UART1_MODEM_MODE_AUTO_RTS: Auto-RTS mode.
- * 				- UART1_MODEM_MODE_AUTO_CTS: Auto-CTS mode.
- * @param[in]	NewState New State of this mode, should be:
- * 				- ENABLE: Enable this mode.
-				- DISABLE: Disable this mode.
- * @return none
- **********************************************************************/
-void UART_FullModemConfigMode(UART1_TypeDef *UARTx, UART_MODEM_MODE_Type Mode, \
-							FunctionalState NewState)
-{
-	uint8_t tmp;
-
-	CHECK_PARAM(PARAM_UART1_MODEM(UARTx));
-	CHECK_PARAM(PARAM_UART1_MODEM_MODE(Mode));
-	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
-
-	switch(Mode){
-	case UART1_MODEM_MODE_LOOPBACK:
-		tmp = UART1_MCR_LOOPB_EN;
-		break;
-	case UART1_MODEM_MODE_AUTO_RTS:
-		tmp = UART1_MCR_AUTO_RTS_EN;
-		break;
-	case UART1_MODEM_MODE_AUTO_CTS:
-		tmp = UART1_MCR_AUTO_CTS_EN;
-		break;
-	default:
-		break;
-	}
-
-	if (NewState == ENABLE)
-	{
-		UARTx-&gt;MCR |= tmp;
-	}
-	else
-	{
-		UARTx-&gt;MCR &amp;= (~tmp) &amp; UART1_MCR_BITMASK;
-	}
-}
-
-
-/*********************************************************************//**
- * @brief		Get current status of modem status register
- * @param[in]	UARTx	UART1 (only)
- * @return 		Current value of modem status register
- * Note:	The return value of this function must be ANDed with each member
- * 			UART_MODEM_STAT_type enumeration to determine current flag status
- * 			corresponding to each modem flag status. Because some flags in
- * 			modem status register will be cleared after reading, the next reading
- * 			modem register could not be correct. So this function used to
- * 			read modem status register in one time only, then the return value
- * 			used to check all flags.
- **********************************************************************/
-uint8_t UART_FullModemGetStatus(UART1_TypeDef *UARTx)
-{
-	CHECK_PARAM(PARAM_UART1_MODEM(UARTx));
-	return ((UARTx-&gt;MSR) &amp; UART1_MSR_BITMASK);
-}
-
-
-/*********************************************************************//**
- * @brief		Configure UART peripheral in RS485 mode according to the specified
-*               parameters in the RS485ConfigStruct.
- * @param[in]	UARTx	UART1 (only)
- * @param[in]	RS485ConfigStruct Pointer to a UART1_RS485_CTRLCFG_Type structure
-*                    that contains the configuration information for specified UART
-*                    in RS485 mode.
- * @return		None
- **********************************************************************/
-void UART_RS485Config(UART1_TypeDef *UARTx, UART1_RS485_CTRLCFG_Type *RS485ConfigStruct)
-{
-	uint32_t tmp;
-
-	CHECK_PARAM(PARAM_UART1_MODEM(UARTx));
-	CHECK_PARAM(PARAM_FUNCTIONALSTATE(RS485ConfigStruct-&gt;AutoAddrDetect_State));
-	CHECK_PARAM(PARAM_FUNCTIONALSTATE(RS485ConfigStruct-&gt;AutoDirCtrl_State));
-	CHECK_PARAM(PARAM_UART1_RS485_CFG_DELAYVALUE(RS485ConfigStruct-&gt;DelayValue));
-	CHECK_PARAM(PARAM_SETSTATE(RS485ConfigStruct-&gt;DirCtrlPol_Level));
-	CHECK_PARAM(PARAM_UART_RS485_DIRCTRL_PIN(RS485ConfigStruct-&gt;DirCtrlPin));
-	CHECK_PARAM(PARAM_UART1_RS485_CFG_MATCHADDRVALUE(RS485ConfigStruct-&gt;MatchAddrValue));
-	CHECK_PARAM(PARAM_FUNCTIONALSTATE(RS485ConfigStruct-&gt;NormalMultiDropMode_State));
-	CHECK_PARAM(PARAM_FUNCTIONALSTATE(RS485ConfigStruct-&gt;Rx_State));
-
-	tmp = 0;
-	// If Auto Direction Control is enabled -  This function is used in Master mode
-	if (RS485ConfigStruct-&gt;AutoDirCtrl_State == ENABLE)
-	{
-		tmp |= UART1_RS485CTRL_DCTRL_EN;
-
-		// Set polar
-		if (RS485ConfigStruct-&gt;DirCtrlPol_Level == SET)
-		{
-			tmp |= UART1_RS485CTRL_OINV_1;
-		}
-
-		// Set pin according to
-		if (RS485ConfigStruct-&gt;DirCtrlPin == UART1_RS485_DIRCTRL_DTR)
-		{
-			tmp |= UART1_RS485CTRL_SEL_DTR;
-		}
-
-		// Fill delay time
-		UARTx-&gt;RS485DLY = RS485ConfigStruct-&gt;DelayValue &amp; UART1_RS485DLY_BITMASK;
-	}
-
-	// MultiDrop mode is enable
-	if (RS485ConfigStruct-&gt;NormalMultiDropMode_State == ENABLE)
-	{
-		tmp |= UART1_RS485CTRL_NMM_EN;
-	}
-
-	// Auto Address Detect function
-	if (RS485ConfigStruct-&gt;AutoAddrDetect_State == ENABLE)
-	{
-		tmp |= UART1_RS485CTRL_AADEN;
-		// Fill Match Address
-		UARTx-&gt;ADRMATCH = RS485ConfigStruct-&gt;MatchAddrValue &amp; UART1_RS485ADRMATCH_BITMASK;
-	}
-
-
-	// Receiver is disable
-	if (RS485ConfigStruct-&gt;Rx_State == DISABLE)
-	{
-		tmp |= UART1_RS485CTRL_RX_DIS;
-	}
-
-	// write back to RS485 control register
-	UARTx-&gt;RS485CTRL = tmp &amp; UART1_RS485CTRL_BITMASK;
-
-	// Enable Parity function and leave parity in stick '0' parity as default
-	UARTx-&gt;LCR |= (UART_LCR_PARITY_F_0 | UART_LCR_PARITY_EN);
-}
-
-
-/**
- * @brief 		Enable/Disable receiver in RS485 module in UART1
- * @param[in]	UARTx 		UART1 only.
- * @param[in]	NewState	New State of command, should be:
- * 							- ENABLE: Enable this function.
- * 							- DISABLE: Disable this function.
- * @return		None
- */
-void UART_RS485ReceiverCmd(UART1_TypeDef *UARTx, FunctionalState NewState)
-{
-	if (NewState == ENABLE){
-		UARTx-&gt;RS485CTRL &amp;= ~UART1_RS485CTRL_RX_DIS;
-	} else {
-		UARTx-&gt;RS485CTRL |= UART1_RS485CTRL_RX_DIS;
-	}
-}
-
-
-/**
- * @brief 		Send data on RS485 bus with specified parity stick value (9-bit mode).
- * @param[in]	UARTx 		UART1 (only).
- * @param[in]	pDatFrm 	Pointer to data frame.
- * @param[in]	size		Size of data.
- * @param[in]	ParityStick	Parity Stick value, should be 0 or 1.
- * @return		None.
- */
-uint32_t UART_RS485Send(UART1_TypeDef *UARTx, uint8_t *pDatFrm, \
-					uint32_t size, uint8_t ParityStick)
-{
-	uint8_t tmp, save;
-	uint32_t cnt;
-
-	if (ParityStick){
-		save = tmp = UARTx-&gt;LCR &amp; UART_LCR_BITMASK;
-		tmp &amp;= ~(UART_LCR_PARITY_EVEN);
-		UARTx-&gt;LCR = tmp;
-		cnt = UART_Send((UART_TypeDef *)UARTx, pDatFrm, size, BLOCKING);
-		while (!(UARTx-&gt;LSR &amp; UART_LSR_TEMT));
-		UARTx-&gt;LCR = save;
-	} else {
-		cnt = UART_Send((UART_TypeDef *)UARTx, pDatFrm, size, BLOCKING);
-		while (!(UARTx-&gt;LSR &amp; UART_LSR_TEMT));
-	}
-	return cnt;
-}
-
-
-/**
- * @brief 		Send Slave address frames on RS485 bus.
- * @param[in]	UARTx UART1 (only).
- * @param[in]	SlvAddr Slave Address.
- * @return		None.
- */
-void UART_RS485SendSlvAddr(UART1_TypeDef *UARTx, uint8_t SlvAddr)
-{
-	UART_RS485Send(UARTx, &amp;SlvAddr, 1, 1);
-}
-
-
-/**
- * @brief 		Send Data frames on RS485 bus.
- * @param[in]	UARTx UART1 (only).
- * @param[in]	pData Pointer to data to be sent.
- * @param[in]	size Size of data frame to be sent.
- * @return		None.
- */
-uint32_t UART_RS485SendData(UART1_TypeDef *UARTx, uint8_t *pData, uint32_t size)
-{
-	return (UART_RS485Send(UARTx, pData, size, 0));
-}
-
-#endif /* _UART1 */
-
-
-/* Additional driver APIs ----------------------------------------------------------------------- */
-
-/*********************************************************************//**
- * @brief		Send a block of data via UART peripheral
- * @param[in]	UARTx	Selected UART peripheral used to send data,
- * 				should be UART0, UART1, UART2 or UART3.
- * @param[in]	txbuf 	Pointer to Transmit buffer
- * @param[in]	buflen 	Length of Transmit buffer
- * @param[in] 	flag 	Flag used in  UART transfer, should be
- * 						NONE_BLOCKING or BLOCKING
- * @return 		Number of bytes sent.
- *
- * Note: when using UART in BLOCKING mode, a time-out condition is used
- * via defined symbol UART_BLOCKING_TIMEOUT.
- **********************************************************************/
-uint32_t UART_Send(UART_TypeDef *UARTx, uint8_t *txbuf,
-		uint32_t buflen, TRANSFER_BLOCK_Type flag)
-{
-	uint32_t bToSend, bSent, timeOut, fifo_cnt;
-	uint8_t *pChar = txbuf;
-
-	bToSend = buflen;
-
-	// blocking mode
-	if (flag == BLOCKING) {
-		bSent = 0;
-		while (bToSend){
-			timeOut = UART_BLOCKING_TIMEOUT;
-			// Wait for THR empty with timeout
-			while (!(UARTx-&gt;LSR &amp; UART_LSR_THRE)) {
-				if (timeOut == 0) break;
-				timeOut--;
-			}
-			// Time out!
-			if(timeOut == 0) break;
-			fifo_cnt = UART_TX_FIFO_SIZE;
-			while (fifo_cnt &amp;&amp; bToSend){
-				UART_SendData(UARTx, (*pChar++));
-				fifo_cnt--;
-				bToSend--;
-				bSent++;
-			}
-		}
-	}
-	// None blocking mode
-	else {
-		bSent = 0;
-		while (bToSend) {
-			if (!(UARTx-&gt;LSR &amp; UART_LSR_THRE)){
-				break;
-			}
-			fifo_cnt = UART_TX_FIFO_SIZE;
-			while (fifo_cnt &amp;&amp; bToSend) {
-				UART_SendData(UARTx, (*pChar++));
-				bToSend--;
-				fifo_cnt--;
-				bSent++;
-			}
-		}
-	}
-	return bSent;
-}
-
-/*********************************************************************//**
- * @brief		Receive a block of data via UART peripheral
- * @param[in]	UARTx	Selected UART peripheral used to send data,
- * 				should be UART0, UART1, UART2 or UART3.
- * @param[out]	rxbuf 	Pointer to Received buffer
- * @param[in]	buflen 	Length of Received buffer
- * @param[in] 	flag 	Flag mode, should be NONE_BLOCKING or BLOCKING
-
- * @return 		Number of bytes received
- *
- * Note: when using UART in BLOCKING mode, a time-out condition is used
- * via defined symbol UART_BLOCKING_TIMEOUT.
- **********************************************************************/
-uint32_t UART_Receive(UART_TypeDef *UARTx, uint8_t *rxbuf, \
-		uint32_t buflen, TRANSFER_BLOCK_Type flag)
-{
-	uint32_t bToRecv, bRecv, timeOut;
-	uint8_t *pChar = rxbuf;
-
-	bToRecv = buflen;
-
-	// Blocking mode
-	if (flag == BLOCKING) {
-		bRecv = 0;
-		while (bToRecv){
-			timeOut = UART_BLOCKING_TIMEOUT;
-			while (!(UARTx-&gt;LSR &amp; UART_LSR_RDR)){
-				if (timeOut == 0) break;
-				timeOut--;
-			}
-			// Time out!
-			if(timeOut == 0) break;
-			// Get data from the buffer
-			(*pChar++) = UART_ReceiveData(UARTx);
-			bToRecv--;
-			bRecv++;
-		}
-	}
-	// None blocking mode
-	else {
-		bRecv = 0;
-		while (bToRecv) {
-			if (!(UARTx-&gt;LSR &amp; UART_LSR_RDR)) {
-				break;
-			} else {
-				(*pChar++) = UART_ReceiveData(UARTx);
-				bRecv++;
-				bToRecv--;
-			}
-		}
-	}
-	return bRecv;
-}
-
-
-/*********************************************************************//**
- * @brief		Setup call-back function for UART interrupt handler for each
- * 				UART peripheral
- * @param[in]	UARTx	Selected UART peripheral, should be UART0..3
- * @param[in]	CbType	Call-back type, should be:
- * 						0 - Receive Call-back
- * 						1 - Transmit Call-back
- * 						2 - Auto Baudrate Callback
- * 						3 - Error Call-back
- * 						4 - Modem Status Call-back (UART1 only)
- * @param[in]	pfnCbs	Pointer to Call-back function
- * @return		None
- **********************************************************************/
-void UART_SetupCbs(UART_TypeDef *UARTx, uint8_t CbType, void *pfnCbs)
-{
-	uint8_t pUartNum;
-
-	pUartNum = getUartNum(UARTx);
-	switch(CbType){
-	case 0:
-		uartCbsDat[pUartNum].pfnRxCbs = (fnTxCbs_Type *)pfnCbs;
-		break;
-	case 1:
-		uartCbsDat[pUartNum].pfnTxCbs = (fnRxCbs_Type *)pfnCbs;
-		break;
-	case 2:
-		uartCbsDat[pUartNum].pfnABCbs = (fnABCbs_Type *)pfnCbs;
-		break;
-	case 3:
-		uartCbsDat[pUartNum].pfnErrCbs = (fnErrCbs_Type *)pfnCbs;
-		break;
-	case 4:
-		pfnModemCbs = (fnModemCbs_Type *)pfnCbs;
-		break;
-	default:
-		break;
-	}
-}
-
-/*********************************************************************//**
- * @brief		Standard UART0 interrupt handler
- * @param[in]	None
- * @return
- **********************************************************************/
-void UART0_StdIntHandler(void)
-{
-	UART_GenIntHandler(UART0);
-}
-
-/*********************************************************************//**
- * @brief		Standard UART1 interrupt handler
- * @param[in]	None
- * @return
- **********************************************************************/
-void UART1_StdIntHandler(void)
-{
-	UART_GenIntHandler((UART_TypeDef *)UART1);
-}
-
-/*********************************************************************//**
- * @brief		Standard UART2 interrupt handler
- * @param[in]	None
- * @return
- **********************************************************************/
-void UART2_StdIntHandler(void)
-{
-	UART_GenIntHandler(UART2);
-}
-
-/*********************************************************************//**
- * @brief		Standard UART3 interrupt handler
- * @param[in]	None
- * @return
- **********************************************************************/
-void UART3_StdIntHandler(void)
-{
-	UART_GenIntHandler(UART3);
-}
-
-/**
- * @}
- */
-
-
-#endif /* _UART */
-
-/**
- * @}
- */
-
-/* --------------------------------- End Of File ------------------------------ */
-
+/**
+ * @file	: lpc17xx_uart.c
+ * @brief	: Contains all functions support for UART firmware library on LPC17xx
+ * @version	: 1.0
+ * @date	: 18. Mar. 2009
+ * @author	: HieuNguyen
+ **************************************************************************
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * products. This software is supplied &quot;AS IS&quot; without any warranties.
+ * NXP Semiconductors assumes no responsibility or liability for the
+ * use of the software, conveys no license or title under any patent,
+ * copyright, or mask work right to the product. NXP Semiconductors
+ * reserves the right to make changes in the software without
+ * notification. NXP Semiconductors also make no representation or
+ * warranty that such application will be suitable for the specified
+ * use without further testing or modification.
+ **********************************************************************/
+
+/* Peripheral group ----------------------------------------------------------- */
+/** @addtogroup UART
+ * @{
+ */
+
+/* Includes ------------------------------------------------------------------- */
+#include &quot;lpc17xx_uart.h&quot;
+#include &quot;lpc17xx_clkpwr.h&quot;
+
+/* If this source file built with example, the LPC17xx FW library configuration
+ * file in each example directory (&quot;lpc17xx_libcfg.h&quot;) must be included,
+ * otherwise the default FW library configuration file must be included instead
+ */
+#ifdef __BUILD_WITH_EXAMPLE__
+#include &quot;lpc17xx_libcfg.h&quot;
+#else
+#include &quot;lpc17xx_libcfg_default.h&quot;
+#endif /* __BUILD_WITH_EXAMPLE__ */
+
+
+#ifdef _UART
+
+/* Private Types -------------------------------------------------------------- */
+/** @defgroup UART_Private_Types
+ * @{
+ */
+
+/**
+ * @brief UART call-back function type definitions
+ */
+typedef struct {
+	fnTxCbs_Type *pfnTxCbs; 	// Transmit callback
+	fnRxCbs_Type *pfnRxCbs;		// Receive callback
+	fnABCbs_Type *pfnABCbs;		// Auto-Baudrate callback
+	fnErrCbs_Type *pfnErrCbs;	// Error callback
+} UART_CBS_Type;
+
+/**
+ * @}
+ */
+
+
+/* Private Variables ---------------------------------------------------------- */
+/** @defgroup UART_Private_Variables
+ * @{
+ */
+
+
+/** Call-back function pointer data */
+UART_CBS_Type uartCbsDat[4] = {
+		{NULL, NULL, NULL, NULL},
+		{NULL, NULL, NULL, NULL},
+		{NULL, NULL, NULL, NULL},
+		{NULL, NULL, NULL, NULL},
+};
+
+/** UART1 modem status interrupt callback pointer data */
+fnModemCbs_Type *pfnModemCbs = NULL;
+
+/**
+ * @}
+ */
+
+
+/* Private Functions ---------------------------------------------------------- */
+/** @defgroup UART_Private_Functions
+ * @{
+ */
+
+/**
+ * @brief		Get UART number due to UART peripheral pointer
+ * @param[in]	UARTx	UART pointer
+ * @return		UART number
+ */
+uint8_t getUartNum(LPC_UART_TypeDef *UARTx) {
+	if (UARTx == LPC_UART0) return (0);
+	else if (UARTx == (LPC_UART_TypeDef *)LPC_UART1) return (1);
+	else if (UARTx == LPC_UART2) return (2);
+	else return (3);
+}
+
+/*********************************************************************//**
+ * @brief		Determines best dividers to get a target clock rate
+ * @param[in]	UARTx	Pointer to selected UART peripheral, should be
+ * 						UART0, UART1, UART2 or UART3.
+ * @param[in]	baudrate Desired UART baud rate.
+ * @return 		Error status.
+ **********************************************************************/
+
+Status uart_set_divisors(LPC_UART_TypeDef *UARTx, uint32_t baudrate)
+{
+	Status errorStatus = ERROR;
+
+	uint32_t uClk;
+	uint32_t calcBaudrate = 0;
+	uint32_t temp = 0;
+
+	uint32_t mulFracDiv, dividerAddFracDiv;
+	uint32_t diviser = 0 ;
+	uint32_t mulFracDivOptimal = 1;
+	uint32_t dividerAddOptimal = 0;
+	uint32_t diviserOptimal = 0;
+
+	uint32_t relativeError = 0;
+	uint32_t relativeOptimalError = 100000;
+
+	/* get UART block clock */
+	if (UARTx == LPC_UART0)
+	{
+		uClk = CLKPWR_GetPCLK (CLKPWR_PCLKSEL_UART0);
+	}
+	else if (UARTx == (LPC_UART_TypeDef *)LPC_UART1)
+	{
+		uClk = CLKPWR_GetPCLK (CLKPWR_PCLKSEL_UART1);
+	}
+	else if (UARTx == LPC_UART2)
+	{
+		uClk = CLKPWR_GetPCLK (CLKPWR_PCLKSEL_UART2);
+	}
+	else if (UARTx == LPC_UART3)
+	{
+		uClk = CLKPWR_GetPCLK (CLKPWR_PCLKSEL_UART3);
+	}
+
+
+	uClk = uClk &gt;&gt; 4; /* div by 16 */
+	/* In the Uart IP block, baud rate is calculated using FDR and DLL-DLM registers
+	* The formula is :
+	* BaudRate= uClk * (mulFracDiv/(mulFracDiv+dividerAddFracDiv) / (16 * (DLL)
+	* It involves floating point calculations. That's the reason the formulae are adjusted with
+	* Multiply and divide method.*/
+	/* The value of mulFracDiv and dividerAddFracDiv should comply to the following expressions:
+	* 0 &lt; mulFracDiv &lt;= 15, 0 &lt;= dividerAddFracDiv &lt;= 15 */
+	for (mulFracDiv = 1 ; mulFracDiv &lt;= 15 ;mulFracDiv++)
+	{
+	for (dividerAddFracDiv = 0 ; dividerAddFracDiv &lt;= 15 ;dividerAddFracDiv++)
+	{
+	  temp = (mulFracDiv * uClk) / ((mulFracDiv + dividerAddFracDiv));
+
+	  diviser = temp / baudrate;
+	  if ((temp % baudrate) &gt; (baudrate / 2))
+		diviser++;
+
+	  if (diviser &gt; 2 &amp;&amp; diviser &lt; 65536)
+	  {
+		calcBaudrate = temp / diviser;
+
+		if (calcBaudrate &lt;= baudrate)
+		  relativeError = baudrate - calcBaudrate;
+		else
+		  relativeError = calcBaudrate - baudrate;
+
+		if ((relativeError &lt; relativeOptimalError))
+		{
+		  mulFracDivOptimal = mulFracDiv ;
+		  dividerAddOptimal = dividerAddFracDiv;
+		  diviserOptimal = diviser;
+		  relativeOptimalError = relativeError;
+		  if (relativeError == 0)
+			break;
+		}
+	  } /* End of if */
+	} /* end of inner for loop */
+	if (relativeError == 0)
+	  break;
+	} /* end of outer for loop  */
+
+	if (relativeOptimalError &lt; ((baudrate * UART_ACCEPTED_BAUDRATE_ERROR)/100))
+	{
+		if (((LPC_UART1_TypeDef *)UARTx) == LPC_UART1)
+		{
+			((LPC_UART1_TypeDef *)UARTx)-&gt;LCR |= UART_LCR_DLAB_EN;
+			((LPC_UART1_TypeDef *)UARTx)-&gt;/*DLIER.*/DLM = UART_LOAD_DLM(diviserOptimal);
+			((LPC_UART1_TypeDef *)UARTx)-&gt;/*RBTHDLR.*/DLL = UART_LOAD_DLL(diviserOptimal);
+			/* Then reset DLAB bit */
+			((LPC_UART1_TypeDef *)UARTx)-&gt;LCR &amp;= (~UART_LCR_DLAB_EN) &amp; UART_LCR_BITMASK;
+			((LPC_UART1_TypeDef *)UARTx)-&gt;FDR = (UART_FDR_MULVAL(mulFracDivOptimal) \
+					| UART_FDR_DIVADDVAL(dividerAddOptimal)) &amp; UART_FDR_BITMASK;
+		}
+		else
+		{
+			UARTx-&gt;LCR |= UART_LCR_DLAB_EN;
+			UARTx-&gt;/*DLIER.*/DLM = UART_LOAD_DLM(diviserOptimal);
+			UARTx-&gt;/*RBTHDLR.*/DLL = UART_LOAD_DLL(diviserOptimal);
+			/* Then reset DLAB bit */
+			UARTx-&gt;LCR &amp;= (~UART_LCR_DLAB_EN) &amp; UART_LCR_BITMASK;
+			UARTx-&gt;FDR = (UART_FDR_MULVAL(mulFracDivOptimal) \
+					| UART_FDR_DIVADDVAL(dividerAddOptimal)) &amp; UART_FDR_BITMASK;
+		}
+		errorStatus = SUCCESS;
+	}
+
+	return errorStatus;
+}
+
+/*********************************************************************//**
+ * @brief		General UART interrupt handler and router
+ * @param[in]	UARTx	Selected UART peripheral, should be UART0..3
+ * @return		None
+ *
+ * Note:
+ * - Handles transmit, receive, and status interrupts for the UART.
+ * Based on the interrupt status, routes the interrupt to the
+ * respective call-back to be handled by the user application using
+ * this driver.
+ * - If callback is not installed, corresponding interrupt will be disabled
+ * - All these interrupt source below will be checked:
+ *   		- Transmit Holding Register Empty.
+ * 			- Received Data Available and Character Time Out.
+ * 			- Receive Line Status (not implemented)
+ * 			- End of auto-baud interrupt (not implemented)
+ * 			- Auto-Baudrate Time-Out interrupt (not implemented)
+ * 			- Modem Status interrupt (UART0 Modem functionality)
+ * 			- CTS signal transition interrupt (UART0 Modem functionality)
+ **********************************************************************/
+void UART_GenIntHandler(LPC_UART_TypeDef *UARTx)
+{
+	uint8_t pUart, modemsts;
+	uint32_t intsrc, tmp, tmp1;
+
+	pUart = getUartNum(UARTx);
+
+	/* Determine the interrupt source */
+	intsrc = UARTx-&gt;IIR;
+	tmp = intsrc &amp; UART_IIR_INTID_MASK;
+
+	/*
+	 * In case of using UART1 with full modem,
+	 * interrupt ID = 0 that means modem status interrupt has been detected
+	 */
+	if (pUart == 1) {
+		if (tmp == 0){
+			// Check Modem status
+			modemsts = LPC_UART1-&gt;MSR &amp; UART1_MSR_BITMASK;
+			// Call modem status call-back
+			if (pfnModemCbs != NULL){
+				pfnModemCbs(modemsts);
+			}
+			// disable modem status interrupt and CTS status change interrupt
+			// if its callback is not installed
+			else {
+				LPC_UART1-&gt;IER &amp;= ~(UART1_IER_MSINT_EN | UART1_IER_CTSINT_EN);
+			}
+		}
+	}
+
+	// Receive Line Status
+	if (tmp == UART_IIR_INTID_RLS){
+		// Check line status
+		tmp1 = UARTx-&gt;LSR;
+		// Mask out the Receive Ready and Transmit Holding empty status
+		tmp1 &amp;= (UART_LSR_OE | UART_LSR_PE | UART_LSR_FE \
+				| UART_LSR_BI | UART_LSR_RXFE);
+		// If any error exist
+		if (tmp1) {
+			// Call Call-back function with error input value
+			if (uartCbsDat[pUart].pfnErrCbs != NULL) {
+				uartCbsDat[pUart].pfnErrCbs(tmp1);
+			}
+			// Disable interrupt if its call-back is not install
+			else {
+				UARTx-&gt;IER &amp;= ~(UART_IER_RLSINT_EN);
+			}
+		}
+	}
+
+	// Receive Data Available or Character time-out
+	if ((tmp == UART_IIR_INTID_RDA) || (tmp == UART_IIR_INTID_CTI)){
+		// Call Rx call back function
+		if (uartCbsDat[pUart].pfnRxCbs != NULL) {
+			uartCbsDat[pUart].pfnRxCbs();
+		}
+		// Disable interrupt if its call-back is not install
+		else {
+			UARTx-&gt;IER &amp;= ~(UART_IER_RBRINT_EN);
+		}
+	}
+
+	// Transmit Holding Empty
+	if (tmp == UART_IIR_INTID_THRE){
+		// Call Tx call back function
+		if (uartCbsDat[pUart].pfnTxCbs != NULL) {
+			uartCbsDat[pUart].pfnTxCbs();
+		}
+		// Disable interrupt if its call-back is not install
+		else {
+			UARTx-&gt;IER &amp;= ~(UART_IER_THREINT_EN);
+		}
+	}
+
+	intsrc &amp;= (UART_IIR_ABEO_INT | UART_IIR_ABTO_INT);
+	// Check if End of auto-baudrate interrupt or Auto baudrate time out
+	if (intsrc){
+		// Clear interrupt pending
+		UARTx-&gt;ACR |= ((intsrc &amp; UART_IIR_ABEO_INT) ? UART_ACR_ABEOINT_CLR : 0) \
+						| ((intsrc &amp; UART_IIR_ABTO_INT) ? UART_ACR_ABTOINT_CLR : 0);
+		if (uartCbsDat[pUart].pfnABCbs != NULL) {
+			uartCbsDat[pUart].pfnABCbs(intsrc);
+		} else {
+			// Disable End of AB interrupt
+			UARTx-&gt;IER &amp;= ~(UART_IER_ABEOINT_EN | UART_IER_ABTOINT_EN);
+		}
+	}
+}
+
+/**
+ * @}
+ */
+
+
+/* Public Functions ----------------------------------------------------------- */
+/** @addtogroup UART_Public_Functions
+ * @{
+ */
+
+/*********************************************************************//**
+ * @brief		De-initializes the UARTx peripheral registers to their
+*                  default reset values.
+ * @param[in]	UARTx	UART peripheral selected, should be UART0, UART1,
+ * 						UART2 or UART3.
+ * @return 		None
+ **********************************************************************/
+void UART_DeInit(LPC_UART_TypeDef* UARTx)
+{
+	// For debug mode
+	CHECK_PARAM(PARAM_UARTx(UARTx));
+
+	UART_TxCmd(UARTx, DISABLE);
+
+#ifdef _UART0
+	if (UARTx == LPC_UART0)
+	{
+		/* Set up clock and power for UART module */
+		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCUART0, DISABLE);
+	}
+#endif
+
+#ifdef _UART1
+	if (((LPC_UART1_TypeDef *)UARTx) == LPC_UART1)
+	{
+		/* Set up clock and power for UART module */
+		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCUART1, DISABLE);
+	}
+#endif
+
+#ifdef _UART2
+	if (UARTx == LPC_UART2)
+	{
+		/* Set up clock and power for UART module */
+		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCUART2, DISABLE);
+	}
+#endif
+
+#ifdef _UART3
+	if (UARTx == LPC_UART3)
+	{
+		/* Set up clock and power for UART module */
+		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCUART3, DISABLE);
+	}
+#endif
+}
+
+/********************************************************************//**
+ * @brief		Initializes the UARTx peripheral according to the specified
+*               parameters in the UART_ConfigStruct.
+ * @param[in]	UARTx	UART peripheral selected, should be UART0, UART1,
+ * 						UART2 or UART3.
+ * @param[in]	UART_ConfigStruct Pointer to a UART_CFG_Type structure
+*                    that contains the configuration information for the
+*                    specified UART peripheral.
+ * @return 		None
+ *********************************************************************/
+void UART_Init(LPC_UART_TypeDef *UARTx, UART_CFG_Type *UART_ConfigStruct)
+{
+	uint32_t tmp;
+
+	// For debug mode
+	CHECK_PARAM(PARAM_UARTx(UARTx));
+	CHECK_PARAM(PARAM_UART_DATABIT(UART_ConfigStruct-&gt;Databits));
+	CHECK_PARAM(PARAM_UART_STOPBIT(UART_ConfigStruct-&gt;Stopbits));
+	CHECK_PARAM(PARAM_UART_PARITY(UART_ConfigStruct-&gt;Parity));
+
+#ifdef _UART0
+	if(UARTx == LPC_UART0)
+	{
+		/* Set up clock and power for UART module */
+		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCUART0, ENABLE);
+	}
+#endif
+
+#ifdef _UART1
+	if(((LPC_UART1_TypeDef *)UARTx) == LPC_UART1)
+	{
+		/* Set up clock and power for UART module */
+		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCUART1, ENABLE);
+	}
+#endif
+
+#ifdef _UART2
+	if(UARTx == LPC_UART2)
+	{
+		/* Set up clock and power for UART module */
+		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCUART2, ENABLE);
+	}
+#endif
+
+#ifdef _UART3
+	if(UARTx == LPC_UART3)
+	{
+		/* Set up clock and power for UART module */
+		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCUART3, ENABLE);
+	}
+#endif
+
+	if (((LPC_UART1_TypeDef *)UARTx) == LPC_UART1)
+	{
+		/* FIFOs are empty */
+		((LPC_UART1_TypeDef *)UARTx)-&gt;/*IIFCR.*/FCR = ( UART_FCR_FIFO_EN \
+				| UART_FCR_RX_RS | UART_FCR_TX_RS);
+		// Disable FIFO
+		((LPC_UART1_TypeDef *)UARTx)-&gt;/*IIFCR.*/FCR = 0;
+
+		// Dummy reading
+		while (((LPC_UART1_TypeDef *)UARTx)-&gt;LSR &amp; UART_LSR_RDR)
+		{
+			tmp = ((LPC_UART1_TypeDef *)UARTx)-&gt;/*RBTHDLR.*/RBR;
+		}
+
+		((LPC_UART1_TypeDef *)UARTx)-&gt;TER = UART_TER_TXEN;
+		// Wait for current transmit complete
+		while (!(((LPC_UART1_TypeDef *)UARTx)-&gt;LSR &amp; UART_LSR_THRE));
+		// Disable Tx
+		((LPC_UART1_TypeDef *)UARTx)-&gt;TER = 0;
+
+		// Disable interrupt
+		((LPC_UART1_TypeDef *)UARTx)-&gt;/*DLIER.*/IER = 0;
+		// Set LCR to default state
+		((LPC_UART1_TypeDef *)UARTx)-&gt;LCR = 0;
+		// Set ACR to default state
+		((LPC_UART1_TypeDef *)UARTx)-&gt;ACR = 0;
+		// Set Modem Control to default state
+		((LPC_UART1_TypeDef *)UARTx)-&gt;MCR = 0;
+		// Set RS485 control to default state
+		((LPC_UART1_TypeDef *)UARTx)-&gt;RS485CTRL = 0;
+		// Set RS485 delay timer to default state
+		((LPC_UART1_TypeDef *)UARTx)-&gt;RS485DLY = 0;
+		// Set RS485 addr match to default state
+		((LPC_UART1_TypeDef *)UARTx)-&gt;ADRMATCH = 0;
+		//Dummy Reading to Clear Status
+		tmp = ((LPC_UART1_TypeDef *)UARTx)-&gt;MSR;
+		tmp = ((LPC_UART1_TypeDef *)UARTx)-&gt;LSR;
+	}
+	else
+	{
+		/* FIFOs are empty */
+		UARTx-&gt;/*IIFCR.*/FCR = ( UART_FCR_FIFO_EN | UART_FCR_RX_RS | UART_FCR_TX_RS);
+		// Disable FIFO
+		UARTx-&gt;/*IIFCR.*/FCR = 0;
+
+		// Dummy reading
+		while (UARTx-&gt;LSR &amp; UART_LSR_RDR)
+		{
+			tmp = UARTx-&gt;/*RBTHDLR.*/RBR;
+		}
+
+		UARTx-&gt;TER = UART_TER_TXEN;
+		// Wait for current transmit complete
+		while (!(UARTx-&gt;LSR &amp; UART_LSR_THRE));
+		// Disable Tx
+		UARTx-&gt;TER = 0;
+
+		// Disable interrupt
+		UARTx-&gt;/*DLIER.*/IER = 0;
+		// Set LCR to default state
+		UARTx-&gt;LCR = 0;
+		// Set ACR to default state
+		UARTx-&gt;ACR = 0;
+		// Dummy reading
+		tmp = UARTx-&gt;LSR;
+	}
+
+	if (UARTx == LPC_UART3)
+	{
+		// Set IrDA to default state
+		UARTx-&gt;ICR = 0;
+	}
+
+	// Set Line Control register ----------------------------
+
+	uart_set_divisors(UARTx, (UART_ConfigStruct-&gt;Baud_rate));
+
+	if (((LPC_UART1_TypeDef *)UARTx) == LPC_UART1)
+	{
+		tmp = (((LPC_UART1_TypeDef *)UARTx)-&gt;LCR &amp; (UART_LCR_DLAB_EN | UART_LCR_BREAK_EN)) \
+				&amp; UART_LCR_BITMASK;
+	}
+	else
+	{
+		tmp = (UARTx-&gt;LCR &amp; (UART_LCR_DLAB_EN | UART_LCR_BREAK_EN)) &amp; UART_LCR_BITMASK;
+	}
+
+	switch (UART_ConfigStruct-&gt;Databits){
+	case UART_DATABIT_5:
+		tmp |= UART_LCR_WLEN5;
+		break;
+	case UART_DATABIT_6:
+		tmp |= UART_LCR_WLEN6;
+		break;
+	case UART_DATABIT_7:
+		tmp |= UART_LCR_WLEN7;
+		break;
+	case UART_DATABIT_8:
+	default:
+		tmp |= UART_LCR_WLEN8;
+		break;
+	}
+
+	if (UART_ConfigStruct-&gt;Parity == UART_PARITY_NONE)
+	{
+		// Do nothing...
+	}
+	else
+	{
+		tmp |= UART_LCR_PARITY_EN;
+		switch (UART_ConfigStruct-&gt;Parity)
+		{
+		case UART_PARITY_ODD:
+			tmp |= UART_LCR_PARITY_ODD;
+			break;
+
+		case UART_PARITY_EVEN:
+			tmp |= UART_LCR_PARITY_EVEN;
+			break;
+
+		case UART_PARITY_SP_1:
+			tmp |= UART_LCR_PARITY_F_1;
+			break;
+
+		case UART_PARITY_SP_0:
+			tmp |= UART_LCR_PARITY_F_0;
+			break;
+		default:
+			break;
+		}
+	}
+
+	switch (UART_ConfigStruct-&gt;Stopbits){
+	case UART_STOPBIT_2:
+		tmp |= UART_LCR_STOPBIT_SEL;
+		break;
+	case UART_STOPBIT_1:
+	default:
+		// Do no thing
+		break;
+	}
+
+
+	// Write back to LCR, configure FIFO and Disable Tx
+	if (((LPC_UART1_TypeDef *)UARTx) ==  LPC_UART1)
+	{
+		((LPC_UART1_TypeDef *)UARTx)-&gt;LCR = (uint8_t)(tmp &amp; UART_LCR_BITMASK);
+	}
+	else
+	{
+		UARTx-&gt;LCR = (uint8_t)(tmp &amp; UART_LCR_BITMASK);
+	}
+}
+
+
+/*****************************************************************************//**
+* @brief		Fills each UART_InitStruct member with its default value:
+* 				9600 bps
+* 				8-bit data
+* 				1 Stopbit
+* 				None Parity
+* @param[in]	UART_InitStruct Pointer to a UART_CFG_Type structure
+*                    which will be initialized.
+* @return		None
+*******************************************************************************/
+void UART_ConfigStructInit(UART_CFG_Type *UART_InitStruct)
+{
+	UART_InitStruct-&gt;Baud_rate = 9600;
+	UART_InitStruct-&gt;Databits = UART_DATABIT_8;
+	UART_InitStruct-&gt;Parity = UART_PARITY_NONE;
+	UART_InitStruct-&gt;Stopbits = UART_STOPBIT_1;
+}
+
+
+/*********************************************************************//**
+ * @brief		Transmit a single data through UART peripheral
+ * @param[in]	UARTx	UART peripheral selected, should be UART0, UART1,
+ * 						UART2 or UART3.
+ * @param[in]	Data	Data to transmit (must be 8-bit long)
+ * @return none
+ **********************************************************************/
+void UART_SendData(LPC_UART_TypeDef* UARTx, uint8_t Data)
+{
+	CHECK_PARAM(PARAM_UARTx(UARTx));
+
+	if (((LPC_UART1_TypeDef *)UARTx) == LPC_UART1)
+	{
+		((LPC_UART1_TypeDef *)UARTx)-&gt;/*RBTHDLR.*/THR = Data &amp; UART_THR_MASKBIT;
+	}
+	else
+	{
+		UARTx-&gt;/*RBTHDLR.*/THR = Data &amp; UART_THR_MASKBIT;
+	}
+
+}
+
+
+/*********************************************************************//**
+ * @brief		Receive a single data from UART peripheral
+ * @param[in]	UARTx	UART peripheral selected, should be UART0, UART1,
+ * 						UART2 or UART3.
+ * @return 		Data received
+ **********************************************************************/
+uint8_t UART_ReceiveData(LPC_UART_TypeDef* UARTx)
+{
+	CHECK_PARAM(PARAM_UARTx(UARTx));
+
+	if (((LPC_UART1_TypeDef *)UARTx) == LPC_UART1)
+	{
+		return (((LPC_UART1_TypeDef *)UARTx)-&gt;/*RBTHDLR.*/RBR &amp; UART_RBR_MASKBIT);
+	}
+	else
+	{
+		return (UARTx-&gt;/*RBTHDLR.*/RBR &amp; UART_RBR_MASKBIT);
+	}
+}
+
+
+/*********************************************************************//**
+ * @brief		Force BREAK character on UART line, output pin UARTx TXD is
+				forced to logic 0.
+ * @param[in]	UARTx	UART peripheral selected, should be UART0, UART1,
+ * 						UART2 or UART3.
+ * @return none
+ **********************************************************************/
+void UART_ForceBreak(LPC_UART_TypeDef* UARTx)
+{
+	CHECK_PARAM(PARAM_UARTx(UARTx));
+
+	if (((LPC_UART1_TypeDef *)UARTx) == LPC_UART1)
+	{
+		((LPC_UART1_TypeDef *)UARTx)-&gt;LCR |= UART_LCR_BREAK_EN;
+	}
+	else
+	{
+		UARTx-&gt;LCR |= UART_LCR_BREAK_EN;
+	}
+}
+
+
+#ifdef _UART3
+
+/*********************************************************************//**
+ * @brief		Enable or disable inverting serial input function of IrDA
+ * 				on UART peripheral.
+ * @param[in]	UARTx UART peripheral selected, should be UART3 (only)
+ * @param[in]	NewState New state of inverting serial input, should be:
+ * 				- ENABLE: Enable this function.
+ * 				- DISABLE: Disable this function.
+ * @return none
+ **********************************************************************/
+void UART_IrDAInvtInputCmd(LPC_UART_TypeDef* UARTx, FunctionalState NewState)
+{
+	CHECK_PARAM(PARAM_UART_IrDA(UARTx));
+	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
+
+	if (NewState == ENABLE)
+	{
+		UARTx-&gt;ICR |= UART_ICR_IRDAINV;
+	}
+	else if (NewState == DISABLE)
+	{
+		UARTx-&gt;ICR &amp;= (~UART_ICR_IRDAINV) &amp; UART_ICR_BITMASK;
+	}
+}
+
+
+/*********************************************************************//**
+ * @brief		Enable or disable IrDA function on UART peripheral.
+ * @param[in]	UARTx UART peripheral selected, should be UART3 (only)
+ * @param[in]	NewState New state of IrDA function, should be:
+ * 				- ENABLE: Enable this function.
+ * 				- DISABLE: Disable this function.
+ * @return none
+ **********************************************************************/
+void UART_IrDACmd(LPC_UART_TypeDef* UARTx, FunctionalState NewState)
+{
+	CHECK_PARAM(PARAM_UART_IrDA(UARTx));
+	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
+
+	if (NewState == ENABLE)
+	{
+		UARTx-&gt;ICR |= UART_ICR_IRDAEN;
+	}
+	else
+	{
+		UARTx-&gt;ICR &amp;= (~UART_ICR_IRDAEN) &amp; UART_ICR_BITMASK;
+	}
+}
+
+
+/*********************************************************************//**
+ * @brief		Configure Pulse divider for IrDA function on UART peripheral.
+ * @param[in]	UARTx UART peripheral selected, should be UART3 (only)
+ * @param[in]	PulseDiv Pulse Divider value from Peripheral clock,
+ * 				should be one of the following:
+				- UART_IrDA_PULSEDIV2 	: Pulse width = 2 * Tpclk
+				- UART_IrDA_PULSEDIV4 	: Pulse width = 4 * Tpclk
+				- UART_IrDA_PULSEDIV8 	: Pulse width = 8 * Tpclk
+				- UART_IrDA_PULSEDIV16 	: Pulse width = 16 * Tpclk
+				- UART_IrDA_PULSEDIV32 	: Pulse width = 32 * Tpclk
+				- UART_IrDA_PULSEDIV64 	: Pulse width = 64 * Tpclk
+				- UART_IrDA_PULSEDIV128 : Pulse width = 128 * Tpclk
+				- UART_IrDA_PULSEDIV256 : Pulse width = 256 * Tpclk
+
+ * @return none
+ **********************************************************************/
+void UART_IrDAPulseDivConfig(LPC_UART_TypeDef *UARTx, UART_IrDA_PULSE_Type PulseDiv)
+{
+	uint32_t tmp, tmp1;
+	CHECK_PARAM(PARAM_UART_IrDA(UARTx));
+	CHECK_PARAM(PARAM_UART_IrDA_PULSEDIV(PulseDiv));
+
+	tmp1 = UART_ICR_PULSEDIV(PulseDiv);
+	tmp = UARTx-&gt;ICR &amp; (~UART_ICR_PULSEDIV(7));
+	tmp |= tmp1 | UART_ICR_FIXPULSE_EN;
+	UARTx-&gt;ICR = tmp &amp; UART_ICR_BITMASK;
+}
+
+#endif
+
+
+/********************************************************************//**
+ * @brief 		Enable or disable specified UART interrupt.
+ * @param[in]	UARTx	UART peripheral selected, should be UART0, UART1,
+ * 						UART2 or UART3.
+ * @param[in]	UARTIntCfg	Specifies the interrupt flag,
+ * 				should be one of the following:
+				- UART_INTCFG_RBR 	:  RBR Interrupt enable
+				- UART_INTCFG_THRE 	:  THR Interrupt enable
+				- UART_INTCFG_RLS 	:  RX line status interrupt enable
+				- UART1_INTCFG_MS	:  Modem status interrupt enable (UART1 only)
+				- UART1_INTCFG_CTS	:  CTS1 signal transition interrupt enable (UART1 only)
+				- UART_INTCFG_ABEO 	:  Enables the end of auto-baud interrupt
+				- UART_INTCFG_ABTO 	:  Enables the auto-baud time-out interrupt
+ * @param[in]	NewState New state of specified UART interrupt type,
+ * 				should be:
+ * 				- ENALBE: Enable this UART interrupt type.
+* 				- DISALBE: Disable this UART interrupt type.
+ * @return 		None
+ *********************************************************************/
+void UART_IntConfig(LPC_UART_TypeDef *UARTx, UART_INT_Type UARTIntCfg, FunctionalState NewState)
+{
+	uint32_t tmp;
+
+	CHECK_PARAM(PARAM_UARTx(UARTx));
+	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
+
+	switch(UARTIntCfg){
+		case UART_INTCFG_RBR:
+			tmp = UART_IER_RBRINT_EN;
+			break;
+		case UART_INTCFG_THRE:
+			tmp = UART_IER_THREINT_EN;
+			break;
+		case UART_INTCFG_RLS:
+			tmp = UART_IER_RLSINT_EN;
+			break;
+		case UART1_INTCFG_MS:
+			tmp = UART1_IER_MSINT_EN;
+			break;
+		case UART1_INTCFG_CTS:
+			tmp = UART1_IER_CTSINT_EN;
+			break;
+		case UART_INTCFG_ABEO:
+			tmp = UART_IER_ABEOINT_EN;
+			break;
+		case UART_INTCFG_ABTO:
+			tmp = UART_IER_ABTOINT_EN;
+			break;
+	}
+
+	if ((LPC_UART1_TypeDef *) UARTx == LPC_UART1)
+	{
+		CHECK_PARAM((PARAM_UART_INTCFG(UARTIntCfg)) || (PARAM_UART1_INTCFG(UARTIntCfg)));
+	}
+	else
+	{
+		CHECK_PARAM(PARAM_UART_INTCFG(UARTIntCfg));
+	}
+
+	if (NewState == ENABLE)
+	{
+		if ((LPC_UART1_TypeDef *) UARTx == LPC_UART1)
+		{
+			((LPC_UART1_TypeDef *)UARTx)-&gt;/*DLIER.*/IER |= tmp;
+		}
+		else
+		{
+			UARTx-&gt;/*DLIER.*/IER |= tmp;
+		}
+	}
+	else
+	{
+		if ((LPC_UART1_TypeDef *) UARTx == LPC_UART1)
+		{
+			((LPC_UART1_TypeDef *)UARTx)-&gt;/*DLIER.*/IER &amp;= (~tmp) &amp; UART1_IER_BITMASK;
+		}
+		else
+		{
+			UARTx-&gt;/*DLIER.*/IER &amp;= (~tmp) &amp; UART_IER_BITMASK;
+		}
+	}
+}
+
+
+/********************************************************************//**
+ * @brief 		Get current value of Line Status register in UART peripheral.
+ * @param[in]	UARTx	UART peripheral selected, should be UART0, UART1,
+ * 						UART2 or UART3.
+ * @return		Current value of Line Status register in UART peripheral.
+ * Note:	The return value of this function must be ANDed with each member in
+ * 			UART_LS_Type enumeration to determine current flag status
+ * 			corresponding to each Line status type. Because some flags in
+ * 			Line Status register will be cleared after reading, the next reading
+ * 			Line Status register could not be correct. So this function used to
+ * 			read Line status register in one time only, then the return value
+ * 			used to check all flags.
+ *********************************************************************/
+uint8_t UART_GetLineStatus(LPC_UART_TypeDef* UARTx)
+{
+	CHECK_PARAM(PARAM_UARTx(UARTx));
+
+	if (((LPC_UART1_TypeDef *)UARTx) == LPC_UART1)
+	{
+		return ((((LPC_UART1_TypeDef *)LPC_UART1)-&gt;LSR) &amp; UART_LSR_BITMASK);
+	}
+	else
+	{
+		return ((UARTx-&gt;LSR) &amp; UART_LSR_BITMASK);
+	}
+}
+
+/*********************************************************************//**
+ * @brief		Check whether if UART is busy or not
+ * @param[in]	UARTx	UART peripheral selected, should be UART0, UART1,
+ * 						UART2 or UART3.
+ * @return		RESET if UART is not busy, otherwise return SET.
+ **********************************************************************/
+FlagStatus UART_CheckBusy(LPC_UART_TypeDef *UARTx)
+{
+	if (UARTx-&gt;LSR &amp; UART_LSR_TEMT){
+		return RESET;
+	} else {
+		return SET;
+	}
+}
+
+
+/*********************************************************************//**
+ * @brief		Configure FIFO function on selected UART peripheral
+ * @param[in]	UARTx	UART peripheral selected, should be UART0, UART1,
+ * 						UART2 or UART3.
+ * @param[in]	FIFOCfg	Pointer to a UART_FIFO_CFG_Type Structure that
+ * 						contains specified information about FIFO configuration
+ * @return 		none
+ **********************************************************************/
+void UART_FIFOConfig(LPC_UART_TypeDef *UARTx, UART_FIFO_CFG_Type *FIFOCfg)
+{
+	uint8_t tmp = 0;
+
+	CHECK_PARAM(PARAM_UARTx(UARTx));
+	CHECK_PARAM(PARAM_UART_FIFO_LEVEL(FIFOCfg-&gt;FIFO_Level));
+	CHECK_PARAM(PARAM_FUNCTIONALSTATE(FIFOCfg-&gt;FIFO_DMAMode));
+	CHECK_PARAM(PARAM_FUNCTIONALSTATE(FIFOCfg-&gt;FIFO_ResetRxBuf));
+	CHECK_PARAM(PARAM_FUNCTIONALSTATE(FIFOCfg-&gt;FIFO_ResetTxBuf));
+
+	tmp |= UART_FCR_FIFO_EN;
+	switch (FIFOCfg-&gt;FIFO_Level){
+	case UART_FIFO_TRGLEV0:
+		tmp |= UART_FCR_TRG_LEV0;
+		break;
+	case UART_FIFO_TRGLEV1:
+		tmp |= UART_FCR_TRG_LEV1;
+		break;
+	case UART_FIFO_TRGLEV2:
+		tmp |= UART_FCR_TRG_LEV2;
+		break;
+	case UART_FIFO_TRGLEV3:
+	default:
+		tmp |= UART_FCR_TRG_LEV3;
+		break;
+	}
+
+	if (FIFOCfg-&gt;FIFO_ResetTxBuf == ENABLE)
+	{
+		tmp |= UART_FCR_TX_RS;
+	}
+	if (FIFOCfg-&gt;FIFO_ResetRxBuf == ENABLE)
+	{
+		tmp |= UART_FCR_RX_RS;
+	}
+	if (FIFOCfg-&gt;FIFO_DMAMode == ENABLE)
+	{
+		tmp |= UART_FCR_DMAMODE_SEL;
+	}
+
+
+	//write to FIFO control register
+	if (((LPC_UART1_TypeDef *)UARTx) == LPC_UART1)
+	{
+		((LPC_UART1_TypeDef *)UARTx)-&gt;/*IIFCR.*/FCR = tmp &amp; UART_FCR_BITMASK;
+	}
+	else
+	{
+		UARTx-&gt;/*IIFCR.*/FCR = tmp &amp; UART_FCR_BITMASK;
+	}
+
+}
+
+
+/*****************************************************************************//**
+* @brief		Fills each UART_FIFOInitStruct member with its default value:
+* 				- FIFO_DMAMode = DISABLE
+* 				- FIFO_Level = UART_FIFO_TRGLEV0
+* 				- FIFO_ResetRxBuf = ENABLE
+* 				- FIFO_ResetTxBuf = ENABLE
+* 				- FIFO_State = ENABLE
+
+* @param[in]	UART_FIFOInitStruct Pointer to a UART_FIFO_CFG_Type structure
+*                    which will be initialized.
+* @return		None
+*******************************************************************************/
+void UART_FIFOConfigStructInit(UART_FIFO_CFG_Type *UART_FIFOInitStruct)
+{
+	UART_FIFOInitStruct-&gt;FIFO_DMAMode = DISABLE;
+	UART_FIFOInitStruct-&gt;FIFO_Level = UART_FIFO_TRGLEV0;
+	UART_FIFOInitStruct-&gt;FIFO_ResetRxBuf = ENABLE;
+	UART_FIFOInitStruct-&gt;FIFO_ResetTxBuf = ENABLE;
+}
+
+
+/*********************************************************************//**
+ * @brief		Start/Stop Auto Baudrate activity
+ * @param[in]	UARTx	UART peripheral selected, should be UART0, UART1,
+ * 						UART2 or UART3.
+ * @param[in]	ABConfigStruct	A pointer to UART_AB_CFG_Type structure that
+ * 								contains specified information about UART
+ * 								auto baudrate configuration
+ * @param[in]	NewState New State of Auto baudrate activity, should be:
+ * 				- ENABLE: Start this activity
+ *				- DISABLE: Stop this activity
+ * Note:		Auto-baudrate mode enable bit will be cleared once this mode
+ * 				completed.
+ * @return 		none
+ **********************************************************************/
+void UART_ABCmd(LPC_UART_TypeDef *UARTx, UART_AB_CFG_Type *ABConfigStruct, \
+				FunctionalState NewState)
+{
+	uint32_t tmp;
+
+	CHECK_PARAM(PARAM_UARTx(UARTx));
+	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
+
+	tmp = 0;
+	if (NewState == ENABLE) {
+		if (ABConfigStruct-&gt;ABMode == UART_AUTOBAUD_MODE1){
+			tmp |= UART_ACR_MODE;
+		}
+		if (ABConfigStruct-&gt;AutoRestart == ENABLE){
+			tmp |= UART_ACR_AUTO_RESTART;
+		}
+	}
+
+	if (((LPC_UART1_TypeDef *)UARTx) == LPC_UART1)
+	{
+		if (NewState == ENABLE)
+		{
+			// Clear DLL and DLM value
+			((LPC_UART1_TypeDef *)UARTx)-&gt;LCR |= UART_LCR_DLAB_EN;
+			((LPC_UART1_TypeDef *)UARTx)-&gt;DLL = 0;
+			((LPC_UART1_TypeDef *)UARTx)-&gt;DLM = 0;
+			((LPC_UART1_TypeDef *)UARTx)-&gt;LCR &amp;= ~UART_LCR_DLAB_EN;
+			// FDR value must be reset to default value
+			((LPC_UART1_TypeDef *)UARTx)-&gt;FDR = 0x10;
+			((LPC_UART1_TypeDef *)UARTx)-&gt;ACR = UART_ACR_START | tmp;
+		}
+		else
+		{
+			((LPC_UART1_TypeDef *)UARTx)-&gt;ACR = 0;
+		}
+	}
+	else
+	{
+		if (NewState == ENABLE)
+		{
+			// Clear DLL and DLM value
+			UARTx-&gt;LCR |= UART_LCR_DLAB_EN;
+			UARTx-&gt;DLL = 0;
+			UARTx-&gt;DLM = 0;
+			UARTx-&gt;LCR &amp;= ~UART_LCR_DLAB_EN;
+			// FDR value must be reset to default value
+			UARTx-&gt;FDR = 0x10;
+			UARTx-&gt;ACR = UART_ACR_START | tmp;
+		}
+		else
+		{
+			UARTx-&gt;ACR = 0;
+		}
+	}
+}
+
+
+/*********************************************************************//**
+ * @brief		Enable/Disable transmission on UART TxD pin
+ * @param[in]	UARTx	UART peripheral selected, should be UART0, UART1,
+ * 						UART2 or UART3.
+ * @param[in]	NewState New State of Tx transmission function, should be:
+ * 				- ENABLE: Enable this function
+				- DISABLE: Disable this function
+ * @return none
+ **********************************************************************/
+void UART_TxCmd(LPC_UART_TypeDef *UARTx, FunctionalState NewState)
+{
+	CHECK_PARAM(PARAM_UARTx(UARTx));
+	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
+
+	if (NewState == ENABLE)
+	{
+		if (((LPC_UART1_TypeDef *)UARTx) == LPC_UART1)
+		{
+			((LPC_UART1_TypeDef *)UARTx)-&gt;TER |= UART_TER_TXEN;
+		}
+		else
+		{
+			UARTx-&gt;TER |= UART_TER_TXEN;
+		}
+	}
+	else
+	{
+		if (((LPC_UART1_TypeDef *)UARTx) == LPC_UART1)
+		{
+			((LPC_UART1_TypeDef *)UARTx)-&gt;TER &amp;= (~UART_TER_TXEN) &amp; UART_TER_BITMASK;
+		}
+		else
+		{
+			UARTx-&gt;TER &amp;= (~UART_TER_TXEN) &amp; UART_TER_BITMASK;
+		}
+	}
+}
+
+#ifdef _UART1
+
+/*********************************************************************//**
+ * @brief		Force pin DTR/RTS corresponding to given state (Full modem mode)
+ * @param[in]	UARTx	UART1 (only)
+ * @param[in]	Pin	Pin that NewState will be applied to, should be:
+ * 				- UART1_MODEM_PIN_DTR: DTR pin.
+ * 				- UART1_MODEM_PIN_RTS: RTS pin.
+ * @param[in]	NewState New State of DTR/RTS pin, should be:
+ * 				- INACTIVE: Force the pin to inactive signal.
+				- ACTIVE: Force the pin to active signal.
+ * @return none
+ **********************************************************************/
+void UART_FullModemForcePinState(LPC_UART1_TypeDef *UARTx, UART_MODEM_PIN_Type Pin, \
+							UART1_SignalState NewState)
+{
+	uint8_t tmp = 0;
+
+	CHECK_PARAM(PARAM_UART1_MODEM(UARTx));
+	CHECK_PARAM(PARAM_UART1_MODEM_PIN(Pin));
+	CHECK_PARAM(PARAM_UART1_SIGNALSTATE(NewState));
+
+	switch (Pin){
+	case UART1_MODEM_PIN_DTR:
+		tmp = UART1_MCR_DTR_CTRL;
+		break;
+	case UART1_MODEM_PIN_RTS:
+		tmp = UART1_MCR_RTS_CTRL;
+		break;
+	default:
+		break;
+	}
+
+	if (NewState == ACTIVE){
+		UARTx-&gt;MCR |= tmp;
+	} else {
+		UARTx-&gt;MCR &amp;= (~tmp) &amp; UART1_MCR_BITMASK;
+	}
+}
+
+
+/*********************************************************************//**
+ * @brief		Configure Full Modem mode for UART peripheral
+ * @param[in]	UARTx	UART1 (only)
+ * @param[in]	Mode Full Modem mode, should be:
+ * 				- UART1_MODEM_MODE_LOOPBACK: Loop back mode.
+ * 				- UART1_MODEM_MODE_AUTO_RTS: Auto-RTS mode.
+ * 				- UART1_MODEM_MODE_AUTO_CTS: Auto-CTS mode.
+ * @param[in]	NewState New State of this mode, should be:
+ * 				- ENABLE: Enable this mode.
+				- DISABLE: Disable this mode.
+ * @return none
+ **********************************************************************/
+void UART_FullModemConfigMode(LPC_UART1_TypeDef *UARTx, UART_MODEM_MODE_Type Mode, \
+							FunctionalState NewState)
+{
+	uint8_t tmp;
+
+	CHECK_PARAM(PARAM_UART1_MODEM(UARTx));
+	CHECK_PARAM(PARAM_UART1_MODEM_MODE(Mode));
+	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
+
+	switch(Mode){
+	case UART1_MODEM_MODE_LOOPBACK:
+		tmp = UART1_MCR_LOOPB_EN;
+		break;
+	case UART1_MODEM_MODE_AUTO_RTS:
+		tmp = UART1_MCR_AUTO_RTS_EN;
+		break;
+	case UART1_MODEM_MODE_AUTO_CTS:
+		tmp = UART1_MCR_AUTO_CTS_EN;
+		break;
+	default:
+		break;
+	}
+
+	if (NewState == ENABLE)
+	{
+		UARTx-&gt;MCR |= tmp;
+	}
+	else
+	{
+		UARTx-&gt;MCR &amp;= (~tmp) &amp; UART1_MCR_BITMASK;
+	}
+}
+
+
+/*********************************************************************//**
+ * @brief		Get current status of modem status register
+ * @param[in]	UARTx	UART1 (only)
+ * @return 		Current value of modem status register
+ * Note:	The return value of this function must be ANDed with each member
+ * 			UART_MODEM_STAT_type enumeration to determine current flag status
+ * 			corresponding to each modem flag status. Because some flags in
+ * 			modem status register will be cleared after reading, the next reading
+ * 			modem register could not be correct. So this function used to
+ * 			read modem status register in one time only, then the return value
+ * 			used to check all flags.
+ **********************************************************************/
+uint8_t UART_FullModemGetStatus(LPC_UART1_TypeDef *UARTx)
+{
+	CHECK_PARAM(PARAM_UART1_MODEM(UARTx));
+	return ((UARTx-&gt;MSR) &amp; UART1_MSR_BITMASK);
+}
+
+
+/*********************************************************************//**
+ * @brief		Configure UART peripheral in RS485 mode according to the specified
+*               parameters in the RS485ConfigStruct.
+ * @param[in]	UARTx	UART1 (only)
+ * @param[in]	RS485ConfigStruct Pointer to a UART1_RS485_CTRLCFG_Type structure
+*                    that contains the configuration information for specified UART
+*                    in RS485 mode.
+ * @return		None
+ **********************************************************************/
+void UART_RS485Config(LPC_UART1_TypeDef *UARTx, UART1_RS485_CTRLCFG_Type *RS485ConfigStruct)
+{
+	uint32_t tmp;
+
+	CHECK_PARAM(PARAM_UART1_MODEM(UARTx));
+	CHECK_PARAM(PARAM_FUNCTIONALSTATE(RS485ConfigStruct-&gt;AutoAddrDetect_State));
+	CHECK_PARAM(PARAM_FUNCTIONALSTATE(RS485ConfigStruct-&gt;AutoDirCtrl_State));
+	CHECK_PARAM(PARAM_UART1_RS485_CFG_DELAYVALUE(RS485ConfigStruct-&gt;DelayValue));
+	CHECK_PARAM(PARAM_SETSTATE(RS485ConfigStruct-&gt;DirCtrlPol_Level));
+	CHECK_PARAM(PARAM_UART_RS485_DIRCTRL_PIN(RS485ConfigStruct-&gt;DirCtrlPin));
+	CHECK_PARAM(PARAM_UART1_RS485_CFG_MATCHADDRVALUE(RS485ConfigStruct-&gt;MatchAddrValue));
+	CHECK_PARAM(PARAM_FUNCTIONALSTATE(RS485ConfigStruct-&gt;NormalMultiDropMode_State));
+	CHECK_PARAM(PARAM_FUNCTIONALSTATE(RS485ConfigStruct-&gt;Rx_State));
+
+	tmp = 0;
+	// If Auto Direction Control is enabled -  This function is used in Master mode
+	if (RS485ConfigStruct-&gt;AutoDirCtrl_State == ENABLE)
+	{
+		tmp |= UART1_RS485CTRL_DCTRL_EN;
+
+		// Set polar
+		if (RS485ConfigStruct-&gt;DirCtrlPol_Level == SET)
+		{
+			tmp |= UART1_RS485CTRL_OINV_1;
+		}
+
+		// Set pin according to
+		if (RS485ConfigStruct-&gt;DirCtrlPin == UART1_RS485_DIRCTRL_DTR)
+		{
+			tmp |= UART1_RS485CTRL_SEL_DTR;
+		}
+
+		// Fill delay time
+		UARTx-&gt;RS485DLY = RS485ConfigStruct-&gt;DelayValue &amp; UART1_RS485DLY_BITMASK;
+	}
+
+	// MultiDrop mode is enable
+	if (RS485ConfigStruct-&gt;NormalMultiDropMode_State == ENABLE)
+	{
+		tmp |= UART1_RS485CTRL_NMM_EN;
+	}
+
+	// Auto Address Detect function
+	if (RS485ConfigStruct-&gt;AutoAddrDetect_State == ENABLE)
+	{
+		tmp |= UART1_RS485CTRL_AADEN;
+		// Fill Match Address
+		UARTx-&gt;ADRMATCH = RS485ConfigStruct-&gt;MatchAddrValue &amp; UART1_RS485ADRMATCH_BITMASK;
+	}
+
+
+	// Receiver is disable
+	if (RS485ConfigStruct-&gt;Rx_State == DISABLE)
+	{
+		tmp |= UART1_RS485CTRL_RX_DIS;
+	}
+
+	// write back to RS485 control register
+	UARTx-&gt;RS485CTRL = tmp &amp; UART1_RS485CTRL_BITMASK;
+
+	// Enable Parity function and leave parity in stick '0' parity as default
+	UARTx-&gt;LCR |= (UART_LCR_PARITY_F_0 | UART_LCR_PARITY_EN);
+}
+
+
+/**
+ * @brief 		Enable/Disable receiver in RS485 module in UART1
+ * @param[in]	UARTx 		UART1 only.
+ * @param[in]	NewState	New State of command, should be:
+ * 							- ENABLE: Enable this function.
+ * 							- DISABLE: Disable this function.
+ * @return		None
+ */
+void UART_RS485ReceiverCmd(LPC_UART1_TypeDef *UARTx, FunctionalState NewState)
+{
+	if (NewState == ENABLE){
+		UARTx-&gt;RS485CTRL &amp;= ~UART1_RS485CTRL_RX_DIS;
+	} else {
+		UARTx-&gt;RS485CTRL |= UART1_RS485CTRL_RX_DIS;
+	}
+}
+
+
+/**
+ * @brief 		Send data on RS485 bus with specified parity stick value (9-bit mode).
+ * @param[in]	UARTx 		UART1 (only).
+ * @param[in]	pDatFrm 	Pointer to data frame.
+ * @param[in]	size		Size of data.
+ * @param[in]	ParityStick	Parity Stick value, should be 0 or 1.
+ * @return		None.
+ */
+uint32_t UART_RS485Send(LPC_UART1_TypeDef *UARTx, uint8_t *pDatFrm, \
+					uint32_t size, uint8_t ParityStick)
+{
+	uint8_t tmp, save;
+	uint32_t cnt;
+
+	if (ParityStick){
+		save = tmp = UARTx-&gt;LCR &amp; UART_LCR_BITMASK;
+		tmp &amp;= ~(UART_LCR_PARITY_EVEN);
+		UARTx-&gt;LCR = tmp;
+		cnt = UART_Send((LPC_UART_TypeDef *)UARTx, pDatFrm, size, BLOCKING);
+		while (!(UARTx-&gt;LSR &amp; UART_LSR_TEMT));
+		UARTx-&gt;LCR = save;
+	} else {
+		cnt = UART_Send((LPC_UART_TypeDef *)UARTx, pDatFrm, size, BLOCKING);
+		while (!(UARTx-&gt;LSR &amp; UART_LSR_TEMT));
+	}
+	return cnt;
+}
+
+
+/**
+ * @brief 		Send Slave address frames on RS485 bus.
+ * @param[in]	UARTx UART1 (only).
+ * @param[in]	SlvAddr Slave Address.
+ * @return		None.
+ */
+void UART_RS485SendSlvAddr(LPC_UART1_TypeDef *UARTx, uint8_t SlvAddr)
+{
+	UART_RS485Send(UARTx, &amp;SlvAddr, 1, 1);
+}
+
+
+/**
+ * @brief 		Send Data frames on RS485 bus.
+ * @param[in]	UARTx UART1 (only).
+ * @param[in]	pData Pointer to data to be sent.
+ * @param[in]	size Size of data frame to be sent.
+ * @return		None.
+ */
+uint32_t UART_RS485SendData(LPC_UART1_TypeDef *UARTx, uint8_t *pData, uint32_t size)
+{
+	return (UART_RS485Send(UARTx, pData, size, 0));
+}
+
+#endif /* _UART1 */
+
+
+/* Additional driver APIs ----------------------------------------------------------------------- */
+
+/*********************************************************************//**
+ * @brief		Send a block of data via UART peripheral
+ * @param[in]	UARTx	Selected UART peripheral used to send data,
+ * 				should be UART0, UART1, UART2 or UART3.
+ * @param[in]	txbuf 	Pointer to Transmit buffer
+ * @param[in]	buflen 	Length of Transmit buffer
+ * @param[in] 	flag 	Flag used in  UART transfer, should be
+ * 						NONE_BLOCKING or BLOCKING
+ * @return 		Number of bytes sent.
+ *
+ * Note: when using UART in BLOCKING mode, a time-out condition is used
+ * via defined symbol UART_BLOCKING_TIMEOUT.
+ **********************************************************************/
+uint32_t UART_Send(LPC_UART_TypeDef *UARTx, uint8_t *txbuf,
+		uint32_t buflen, TRANSFER_BLOCK_Type flag)
+{
+	uint32_t bToSend, bSent, timeOut, fifo_cnt;
+	uint8_t *pChar = txbuf;
+
+	bToSend = buflen;
+
+	// blocking mode
+	if (flag == BLOCKING) {
+		bSent = 0;
+		while (bToSend){
+			timeOut = UART_BLOCKING_TIMEOUT;
+			// Wait for THR empty with timeout
+			while (!(UARTx-&gt;LSR &amp; UART_LSR_THRE)) {
+				if (timeOut == 0) break;
+				timeOut--;
+			}
+			// Time out!
+			if(timeOut == 0) break;
+			fifo_cnt = UART_TX_FIFO_SIZE;
+			while (fifo_cnt &amp;&amp; bToSend){
+				UART_SendData(UARTx, (*pChar++));
+				fifo_cnt--;
+				bToSend--;
+				bSent++;
+			}
+		}
+	}
+	// None blocking mode
+	else {
+		bSent = 0;
+		while (bToSend) {
+			if (!(UARTx-&gt;LSR &amp; UART_LSR_THRE)){
+				break;
+			}
+			fifo_cnt = UART_TX_FIFO_SIZE;
+			while (fifo_cnt &amp;&amp; bToSend) {
+				UART_SendData(UARTx, (*pChar++));
+				bToSend--;
+				fifo_cnt--;
+				bSent++;
+			}
+		}
+	}
+	return bSent;
+}
+
+/*********************************************************************//**
+ * @brief		Receive a block of data via UART peripheral
+ * @param[in]	UARTx	Selected UART peripheral used to send data,
+ * 				should be UART0, UART1, UART2 or UART3.
+ * @param[out]	rxbuf 	Pointer to Received buffer
+ * @param[in]	buflen 	Length of Received buffer
+ * @param[in] 	flag 	Flag mode, should be NONE_BLOCKING or BLOCKING
+
+ * @return 		Number of bytes received
+ *
+ * Note: when using UART in BLOCKING mode, a time-out condition is used
+ * via defined symbol UART_BLOCKING_TIMEOUT.
+ **********************************************************************/
+uint32_t UART_Receive(LPC_UART_TypeDef *UARTx, uint8_t *rxbuf, \
+		uint32_t buflen, TRANSFER_BLOCK_Type flag)
+{
+	uint32_t bToRecv, bRecv, timeOut;
+	uint8_t *pChar = rxbuf;
+
+	bToRecv = buflen;
+
+	// Blocking mode
+	if (flag == BLOCKING) {
+		bRecv = 0;
+		while (bToRecv){
+			timeOut = UART_BLOCKING_TIMEOUT;
+			while (!(UARTx-&gt;LSR &amp; UART_LSR_RDR)){
+				if (timeOut == 0) break;
+				timeOut--;
+			}
+			// Time out!
+			if(timeOut == 0) break;
+			// Get data from the buffer
+			(*pChar++) = UART_ReceiveData(UARTx);
+			bToRecv--;
+			bRecv++;
+		}
+	}
+	// None blocking mode
+	else {
+		bRecv = 0;
+		while (bToRecv) {
+			if (!(UARTx-&gt;LSR &amp; UART_LSR_RDR)) {
+				break;
+			} else {
+				(*pChar++) = UART_ReceiveData(UARTx);
+				bRecv++;
+				bToRecv--;
+			}
+		}
+	}
+	return bRecv;
+}
+
+
+/*********************************************************************//**
+ * @brief		Setup call-back function for UART interrupt handler for each
+ * 				UART peripheral
+ * @param[in]	UARTx	Selected UART peripheral, should be UART0..3
+ * @param[in]	CbType	Call-back type, should be:
+ * 						0 - Receive Call-back
+ * 						1 - Transmit Call-back
+ * 						2 - Auto Baudrate Callback
+ * 						3 - Error Call-back
+ * 						4 - Modem Status Call-back (UART1 only)
+ * @param[in]	pfnCbs	Pointer to Call-back function
+ * @return		None
+ **********************************************************************/
+void UART_SetupCbs(LPC_UART_TypeDef *UARTx, uint8_t CbType, void *pfnCbs)
+{
+	uint8_t pUartNum;
+
+	pUartNum = getUartNum(UARTx);
+	switch(CbType){
+	case 0:
+		uartCbsDat[pUartNum].pfnRxCbs = (fnTxCbs_Type *)pfnCbs;
+		break;
+	case 1:
+		uartCbsDat[pUartNum].pfnTxCbs = (fnRxCbs_Type *)pfnCbs;
+		break;
+	case 2:
+		uartCbsDat[pUartNum].pfnABCbs = (fnABCbs_Type *)pfnCbs;
+		break;
+	case 3:
+		uartCbsDat[pUartNum].pfnErrCbs = (fnErrCbs_Type *)pfnCbs;
+		break;
+	case 4:
+		pfnModemCbs = (fnModemCbs_Type *)pfnCbs;
+		break;
+	default:
+		break;
+	}
+}
+
+/*********************************************************************//**
+ * @brief		Standard UART0 interrupt handler
+ * @param[in]	None
+ * @return		None
+ **********************************************************************/
+void UART0_StdIntHandler(void)
+{
+	UART_GenIntHandler(LPC_UART0);
+}
+
+/*********************************************************************//**
+ * @brief		Standard UART1 interrupt handler
+ * @param[in]	None
+ * @return		None
+ **********************************************************************/
+void UART1_StdIntHandler(void)
+{
+	UART_GenIntHandler((LPC_UART_TypeDef *)LPC_UART1);
+}
+
+/*********************************************************************//**
+ * @brief		Standard UART2 interrupt handler
+ * @param[in]	None
+ * @return		None
+ **********************************************************************/
+void UART2_StdIntHandler(void)
+{
+	UART_GenIntHandler(LPC_UART2);
+}
+
+/*********************************************************************//**
+ * @brief		Standard UART3 interrupt handler
+ * @param[in]	None
+ * @return
+ **********************************************************************/
+void UART3_StdIntHandler(void)
+{
+	UART_GenIntHandler(LPC_UART3);
+}
+
+/**
+ * @}
+ */
+
+
+#endif /* _UART */
+
+/**
+ * @}
+ */
+
+/* --------------------------------- End Of File ------------------------------ */
+


Property changes on: trunk/src/platform/lpc17xx/drivers/src/lpc17xx_uart.c
___________________________________________________________________
Deleted: svn:executable
   - *

Modified: trunk/src/platform/lpc17xx/drivers/src/lpc17xx_wdt.c
===================================================================
--- trunk/src/platform/lpc17xx/drivers/src/lpc17xx_wdt.c	2010-06-28 21:53:59 UTC (rev 759)
+++ trunk/src/platform/lpc17xx/drivers/src/lpc17xx_wdt.c	2010-07-12 20:56:54 UTC (rev 760)
@@ -1,268 +1,266 @@
-/**
- * @file	: lpc17xx_wdt.c
- * @brief	: Contains all functions support for WDT firmware library on LPC17xx
- * @version	: 1.0
- * @date	: 9. April. 2009
- * @author	: HieuNguyen
- *----------------------------------------------------------------------------
- * Software that is described herein is for illustrative purposes only
- * which provides customers with programming information regarding the
- * products. This software is supplied &quot;AS IS&quot; without any warranties.
- * NXP Semiconductors assumes no responsibility or liability for the
- * use of the software, conveys no license or title under any patent,
- * copyright, or mask work right to the product. NXP Semiconductors
- * reserves the right to make changes in the software without
- * notification. NXP Semiconductors also make no representation or
- * warranty that such application will be suitable for the specified
- * use without further testing or modification.
- **********************************************************************/
-
-/* Peripheral group ----------------------------------------------------------- */
-/** @addtogroup WDT
- * @{
- */
-
-/* Includes ------------------------------------------------------------------- */
-#include &quot;lpc17xx_wdt.h&quot;
-#include &quot;lpc17xx_clkpwr.h&quot;
-#include &quot;lpc17xx_pinsel.h&quot;
-
-
-/* If this source file built with example, the LPC17xx FW library configuration
- * file in each example directory (&quot;lpc17xx_libcfg.h&quot;) must be included,
- * otherwise the default FW library configuration file must be included instead
- */
-#ifdef __BUILD_WITH_EXAMPLE__
-#include &quot;lpc17xx_libcfg.h&quot;
-#else
-#include &quot;lpc17xx_libcfg_default.h&quot;
-#endif /* __BUILD_WITH_EXAMPLE__ */
-
-
-#ifdef _WDT
-
-/* Private Functions ---------------------------------------------------------- */
-/** @defgroup WDT_Private_Functions
- * @{
- */
-
-/********************************************************************//**
- * @brief 		Set WDT time out value and WDT mode
- * @param[in]	clk_source select Clock source for WDT device
- * @param[in]	timeout value of time-out for WDT (us)
- * @return		None
- *********************************************************************/
-uint8_t WDT_SetTimeOut (uint8_t clk_source, uint32_t timeout)
-{
-
-	uint32_t pclk_wdt = 0;
-	uint32_t tempval = 0;
-
-	switch ((WDT_CLK_OPT) clk_source)
-    {
-    case WDT_CLKSRC_IRC:
-    	pclk_wdt = 4000000;
-    	// Calculate TC in WDT
-    	tempval  = (((pclk_wdt) / WDT_US_INDEX) * (timeout / 4));
-    	// Check if it valid
-    	if ((tempval &gt;= WDT_TIMEOUT_MIN) &amp;&amp; (tempval &lt;= WDT_TIMEOUT_MAX))
-    	{
-    		WDT-&gt;WDTC = tempval;
-    		return	SUCCESS;
-    	}
-
-    	break;
-
-    case WDT_CLKSRC_PCLK:
-
-    	// Get WDT clock with CCLK divider = 4
-		pclk_wdt = SystemFrequency / 4;
-		// Calculate TC in WDT
-		tempval  = (((pclk_wdt) / WDT_US_INDEX) * (timeout / 4));
-
-		if ((tempval &gt;= WDT_TIMEOUT_MIN) &amp;&amp; (tempval &lt;= WDT_TIMEOUT_MAX))
-		{
-			CLKPWR_SetPCLKDiv (CLKPWR_PCLKSEL_WDT, CLKPWR_PCLKSEL_CCLK_DIV_4);
-			WDT-&gt;WDTC = (uint32_t) tempval;
-			return SUCCESS;
-		}
-
-		// Get WDT clock with CCLK divider = 2
-		pclk_wdt = SystemFrequency / 2;
-		// Calculate TC in WDT
-		tempval  = (((pclk_wdt) / WDT_US_INDEX) * (timeout / 4));
-
-		if ((tempval &gt;= WDT_TIMEOUT_MIN) &amp;&amp; (tempval &lt;= WDT_TIMEOUT_MAX))
-		{
-			CLKPWR_SetPCLKDiv (CLKPWR_PCLKSEL_WDT, CLKPWR_PCLKSEL_CCLK_DIV_2);
-			WDT-&gt;WDTC = (uint32_t) tempval;
-			return	SUCCESS;
-		}
-
-		// Get WDT clock with CCLK divider = 1
-		pclk_wdt = SystemFrequency;
-		// Calculate TC in WDT
-		tempval  = (((pclk_wdt) / WDT_US_INDEX) * (timeout / 4));
-
-		if ((tempval &gt;= WDT_TIMEOUT_MIN) &amp;&amp; (tempval &lt;= WDT_TIMEOUT_MAX))
-		{
-			CLKPWR_SetPCLKDiv (CLKPWR_PCLKSEL_WDT, CLKPWR_PCLKSEL_CCLK_DIV_1);
-			WDT-&gt;WDTC = (uint32_t) tempval;
-			return	SUCCESS;
-		}
-		break ;
-
-
-    case WDT_CLKSRC_RTC:
-		pclk_wdt = 32768;
-		// Calculate TC in WDT
-		tempval  = (((pclk_wdt) / WDT_US_INDEX) * (timeout / 4));
-		// Check if it valid
-		if ((tempval &gt;= WDT_TIMEOUT_MIN) &amp;&amp; (tempval &lt;= WDT_TIMEOUT_MAX))
-		{
-			WDT-&gt;WDTC = (uint32_t) tempval;
-			return	SUCCESS;
-		}
-
-		break;
-
-// Error parameter
-		default:
-			break;
-}
-
-	return ERROR;
-}
-
-/**
- * @}
- */
-
-
-/* Public Functions ----------------------------------------------------------- */
-/** @addtogroup WDT_Public_Functions
- * @{
- */
-
-
-/*********************************************************************//**
-* @brief 		Initial for Watchdog function
-* 					Clock source = RTC ,
-*
-* @param[in]	ClkSrc  Select clock source
-* 				-	0:Clock source from Internal RC oscillator
-* 				-	1: Selects the APB peripheral clock (PCLK)
-* 				-	2:Selects the RTC oscillator
-*
-* @param[in]	WDTMode WDT mode
-* 				-	0: Use WDT to generate interrupt only
-* 				-	1:WDT_MODE_RESET
-* @return 		None
- **********************************************************************/
-void WDT_Init (uint32_t ClkSrc, uint32_t WDTMode)
-{
-	CHECK_PARAM(PARAM_WDT_CLK_OPT(ClkSrc));
-	CHECK_PARAM(PARAM_WDT_MODE_OPT(WDTMode));
-	CLKPWR_SetPCLKDiv (CLKPWR_PCLKSEL_WDT, CLKPWR_PCLKSEL_CCLK_DIV_4);
-
-	//Set clock source
-	WDT-&gt;WDCLKSEL &amp;= ~WDT_WDCLKSEL_MASK;
-	WDT-&gt;WDCLKSEL |= ClkSrc;
-	//Set WDT mode
-	if (WDTMode == WDT_MODE_RESET){
-		WDT-&gt;WDMOD |= WDT_WDMOD(WDTMode);
-	}
-}
-
-
-/**
- * @brief		Start WDT activity with given timeout value
- * @param[in]   TimeOut WDT reset after timeout if it is not feed
- * @return		None
- */
-void WDT_Start(uint32_t TimeOut)
-{
-	uint32_t ClkSrc;
-
-	ClkSrc = WDT-&gt;WDCLKSEL;
-	ClkSrc &amp;=WDT_WDCLKSEL_MASK;
-	WDT_SetTimeOut(ClkSrc,TimeOut);
-	//enable watchdog
-	WDT-&gt;WDMOD |= WDT_WDMOD_WDEN;
-	WDT_Feed();
-}
-
-
-/********************************************************************//**
- * @brief 		Read WDT Time out flag
- * @param		None
- * @return		Time out flag status of WDT
- *********************************************************************/
-FlagStatus WDT_ReadTimeOutFlag (void)
-{
-	return ((WDT-&gt;WDMOD &amp; WDT_WDMOD_WDTOF) &gt;&gt;2);
-}
-
-/********************************************************************//**
- * @brief 		Clear WDT Time out flag
- * @param		None
- * @return		None
- *********************************************************************/
-void WDT_ClrTimeOutFlag (void)
-{
-	WDT-&gt;WDMOD &amp;=~WDT_WDMOD_WDTOF;
-}
-
-/********************************************************************//**
- * @brief 		Update WDT timeout value and feed
- * @param[in]	TimeOut	TimeOut value to be updated
- * @return		None
- *********************************************************************/
-void WDT_UpdateTimeOut ( uint32_t TimeOut)
-{
-	uint32_t ClkSrc;
-	ClkSrc = WDT-&gt;WDCLKSEL;
-	ClkSrc &amp;=WDT_WDCLKSEL_MASK;
-	WDT_SetTimeOut(ClkSrc,TimeOut);
-	WDT_Feed();
-}
-
-
-/********************************************************************//**
- * @brief 		After set WDTEN, call this function to start Watchdog
- * 				or reload the Watchdog timer
- * @param	None
- *
- * @return		None
- *********************************************************************/
-void WDT_Feed (void)
-{
-	// Disable irq interrupt
-	__disable_irq();
-	WDT-&gt;WDFEED = 0xAA;
-	WDT-&gt;WDFEED = 0x55;
-	// Then enable irq interrupt
-	__enable_irq();
-}
-
-/********************************************************************//**
- * @brief 		Get the current value of WDT
- * @param		None
- * @return		current value of WDT
- *********************************************************************/
-uint32_t WDT_GetCurrentCount(void)
-{
-	return WDT-&gt;WDTV;
-}
-
-/**
- * @}
- */
-
-#endif /* _WDT */
-
-/**
- * @}
- */
-
-/* --------------------------------- End Of File ------------------------------ */
+/**
+ * @file	: lpc17xx_wdt.c
+ * @brief	: Contains all functions support for WDT firmware library on LPC17xx
+ * @version	: 1.0
+ * @date	: 9. April. 2009
+ * @author	: HieuNguyen
+ **************************************************************************
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * products. This software is supplied &quot;AS IS&quot; without any warranties.
+ * NXP Semiconductors assumes no responsibility or liability for the
+ * use of the software, conveys no license or title under any patent,
+ * copyright, or mask work right to the product. NXP Semiconductors
+ * reserves the right to make changes in the software without
+ * notification. NXP Semiconductors also make no representation or
+ * warranty that such application will be suitable for the specified
+ * use without further testing or modification.
+ **********************************************************************/
+
+/* Peripheral group ----------------------------------------------------------- */
+/** @addtogroup WDT
+ * @{
+ */
+
+/* Includes ------------------------------------------------------------------- */
+#include &quot;lpc17xx_wdt.h&quot;
+#include &quot;lpc17xx_clkpwr.h&quot;
+#include &quot;lpc17xx_pinsel.h&quot;
+
+
+/* If this source file built with example, the LPC17xx FW library configuration
+ * file in each example directory (&quot;lpc17xx_libcfg.h&quot;) must be included,
+ * otherwise the default FW library configuration file must be included instead
+ */
+#ifdef __BUILD_WITH_EXAMPLE__
+#include &quot;lpc17xx_libcfg.h&quot;
+#else
+#include &quot;lpc17xx_libcfg_default.h&quot;
+#endif /* __BUILD_WITH_EXAMPLE__ */
+
+
+#ifdef _WDT
+
+/* Private Functions ---------------------------------------------------------- */
+/** @defgroup WDT_Private_Functions
+ * @{
+ */
+
+/********************************************************************//**
+ * @brief 		Set WDT time out value and WDT mode
+ * @param[in]	clk_source select Clock source for WDT device
+ * @param[in]	timeout value of time-out for WDT (us)
+ * @return		None
+ *********************************************************************/
+uint8_t WDT_SetTimeOut (uint8_t clk_source, uint32_t timeout)
+{
+
+	uint32_t pclk_wdt = 0;
+	uint32_t tempval = 0;
+
+	switch ((WDT_CLK_OPT) clk_source)
+    {
+    case WDT_CLKSRC_IRC:
+    	pclk_wdt = 4000000;
+    	// Calculate TC in WDT
+    	tempval  = (((pclk_wdt) / WDT_US_INDEX) * (timeout / 4));
+    	// Check if it valid
+    	if ((tempval &gt;= WDT_TIMEOUT_MIN) &amp;&amp; (tempval &lt;= WDT_TIMEOUT_MAX))
+    	{
+    		LPC_WDT-&gt;WDTC = tempval;
+    		return	SUCCESS;
+    	}
+
+    	break;
+
+    case WDT_CLKSRC_PCLK:
+
+    	// Get WDT clock with CCLK divider = 4
+		pclk_wdt = SystemCoreClock / 4;
+		// Calculate TC in WDT
+		tempval  = (((pclk_wdt) / WDT_US_INDEX) * (timeout / 4));
+
+		if ((tempval &gt;= WDT_TIMEOUT_MIN) &amp;&amp; (tempval &lt;= WDT_TIMEOUT_MAX))
+		{
+			CLKPWR_SetPCLKDiv (CLKPWR_PCLKSEL_WDT, CLKPWR_PCLKSEL_CCLK_DIV_4);
+			LPC_WDT-&gt;WDTC = (uint32_t) tempval;
+			return SUCCESS;
+		}
+
+		// Get WDT clock with CCLK divider = 2
+		pclk_wdt = SystemCoreClock / 2;
+		// Calculate TC in WDT
+		tempval  = (((pclk_wdt) / WDT_US_INDEX) * (timeout / 4));
+
+		if ((tempval &gt;= WDT_TIMEOUT_MIN) &amp;&amp; (tempval &lt;= WDT_TIMEOUT_MAX))
+		{
+			CLKPWR_SetPCLKDiv (CLKPWR_PCLKSEL_WDT, CLKPWR_PCLKSEL_CCLK_DIV_2);
+			LPC_WDT-&gt;WDTC = (uint32_t) tempval;
+			return	SUCCESS;
+		}
+
+		// Get WDT clock with CCLK divider = 1
+		pclk_wdt = SystemCoreClock;
+		// Calculate TC in WDT
+		tempval  = (((pclk_wdt) / WDT_US_INDEX) * (timeout / 4));
+
+		if ((tempval &gt;= WDT_TIMEOUT_MIN) &amp;&amp; (tempval &lt;= WDT_TIMEOUT_MAX))
+		{
+			CLKPWR_SetPCLKDiv (CLKPWR_PCLKSEL_WDT, CLKPWR_PCLKSEL_CCLK_DIV_1);
+			LPC_WDT-&gt;WDTC = (uint32_t) tempval;
+			return	SUCCESS;
+		}
+		break ;
+
+
+    case WDT_CLKSRC_RTC:
+		pclk_wdt = 32768;
+		// Calculate TC in WDT
+		tempval  = (((pclk_wdt) / WDT_US_INDEX) * (timeout / 4));
+		// Check if it valid
+		if ((tempval &gt;= WDT_TIMEOUT_MIN) &amp;&amp; (tempval &lt;= WDT_TIMEOUT_MAX))
+		{
+			LPC_WDT-&gt;WDTC = (uint32_t) tempval;
+			return	SUCCESS;
+		}
+
+		break;
+
+// Error parameter
+		default:
+			break;
+}
+
+	return ERROR;
+}
+
+/**
+ * @}
+ */
+
+
+/* Public Functions ----------------------------------------------------------- */
+/** @addtogroup WDT_Public_Functions
+ * @{
+ */
+
+
+/*********************************************************************//**
+* @brief 		Initial for Watchdog function
+* 					Clock source = RTC ,
+*
+* @param[in]	ClkSrc  Select clock source
+* 				-	0:Clock source from Internal RC oscillator
+* 				-	1: Selects the APB peripheral clock (PCLK)
+* 				-	2:Selects the RTC oscillator
+*
+* @param[in]	WDTMode WDT mode
+* 				-	0: Use WDT to generate interrupt only
+* 				-	1:WDT_MODE_RESET
+* @return 		None
+ **********************************************************************/
+void WDT_Init (uint32_t ClkSrc, uint32_t WDTMode)
+{
+	CHECK_PARAM(PARAM_WDT_CLK_OPT(ClkSrc));
+	CHECK_PARAM(PARAM_WDT_MODE_OPT(WDTMode));
+	CLKPWR_SetPCLKDiv (CLKPWR_PCLKSEL_WDT, CLKPWR_PCLKSEL_CCLK_DIV_4);
+
+	//Set clock source
+	LPC_WDT-&gt;WDCLKSEL &amp;= ~WDT_WDCLKSEL_MASK;
+	LPC_WDT-&gt;WDCLKSEL |= ClkSrc;
+	//Set WDT mode
+	if (WDTMode == WDT_MODE_RESET){
+		LPC_WDT-&gt;WDMOD |= WDT_WDMOD(WDTMode);
+	}
+}
+
+/*********************************************************************//**
+* @brief 		Start WDT activity with given timeout value
+* @param[in]	TimeOut WDT reset after timeout if it is not feed
+* @return 		None
+ **********************************************************************/
+void WDT_Start(uint32_t TimeOut)
+{
+	uint32_t ClkSrc;
+
+	ClkSrc = LPC_WDT-&gt;WDCLKSEL;
+	ClkSrc &amp;=WDT_WDCLKSEL_MASK;
+	WDT_SetTimeOut(ClkSrc,TimeOut);
+	//enable watchdog
+	LPC_WDT-&gt;WDMOD |= WDT_WDMOD_WDEN;
+	WDT_Feed();
+}
+
+/********************************************************************//**
+ * @brief 		Read WDT Time out flag
+ * @param[in]	None
+ * @return		Time out flag status of WDT
+ *********************************************************************/
+FlagStatus WDT_ReadTimeOutFlag (void)
+{
+	return ((LPC_WDT-&gt;WDMOD &amp; WDT_WDMOD_WDTOF) &gt;&gt;2);
+}
+
+/********************************************************************//**
+ * @brief 		Clear WDT Time out flag
+ * @param[in]	None
+ * @return		None
+ *********************************************************************/
+void WDT_ClrTimeOutFlag (void)
+{
+	LPC_WDT-&gt;WDMOD &amp;=~WDT_WDMOD_WDTOF;
+}
+
+/********************************************************************//**
+ * @brief 		Update WDT timeout value and feed
+ * @param[in]	TimeOut	TimeOut value to be updated
+ * @return		None
+ *********************************************************************/
+void WDT_UpdateTimeOut ( uint32_t TimeOut)
+{
+	uint32_t ClkSrc;
+	ClkSrc = LPC_WDT-&gt;WDCLKSEL;
+	ClkSrc &amp;=WDT_WDCLKSEL_MASK;
+	WDT_SetTimeOut(ClkSrc,TimeOut);
+	WDT_Feed();
+}
+
+
+/********************************************************************//**
+ * @brief 		After set WDTEN, call this function to start Watchdog
+ * 				or reload the Watchdog timer
+ * @param[in]	None
+ *
+ * @return		None
+ *********************************************************************/
+void WDT_Feed (void)
+{
+	// Disable irq interrupt
+	__disable_irq();
+	LPC_WDT-&gt;WDFEED = 0xAA;
+	LPC_WDT-&gt;WDFEED = 0x55;
+	// Then enable irq interrupt
+	__enable_irq();
+}
+
+/********************************************************************//**
+ * @brief 		Get the current value of WDT
+ * @param[in]	None
+ * @return		current value of WDT
+ *********************************************************************/
+uint32_t WDT_GetCurrentCount(void)
+{
+	return LPC_WDT-&gt;WDTV;
+}
+
+/**
+ * @}
+ */
+
+#endif /* _WDT */
+
+/**
+ * @}
+ */
+
+/* --------------------------------- End Of File ------------------------------ */


Property changes on: trunk/src/platform/lpc17xx/drivers/src/lpc17xx_wdt.c
___________________________________________________________________
Deleted: svn:executable
   - *

Modified: trunk/src/platform/lpc17xx/lpc17xx_libcfg.h
===================================================================
--- trunk/src/platform/lpc17xx/lpc17xx_libcfg.h	2010-06-28 21:53:59 UTC (rev 759)
+++ trunk/src/platform/lpc17xx/lpc17xx_libcfg.h	2010-07-12 20:56:54 UTC (rev 760)
@@ -50,6 +50,9 @@
 #define _PWM	1
 #define _PWM1	1
 
+/* ADC------------------------------- */
+#define _ADC 1
+
 /************************** GLOBAL/PUBLIC MACRO DEFINITIONS *********************************/
 
 #ifdef  DEBUG

Modified: trunk/src/platform/lpc17xx/platform.c
===================================================================
--- trunk/src/platform/lpc17xx/platform.c	2010-06-28 21:53:59 UTC (rev 759)
+++ trunk/src/platform/lpc17xx/platform.c	2010-07-12 20:56:54 UTC (rev 760)
@@ -12,8 +12,10 @@
 #include &lt;stdio.h&gt;
 #include &quot;utils.h&quot;
 #include &quot;common.h&quot;
+#include &quot;elua_adc.h&quot;
 #include &quot;platform_conf.h&quot;
 #include &quot;lrotable.h&quot;
+#include &quot;buf.h&quot;
 
 // Platform includes
 #include &quot;lpc17xx_gpio.h&quot;
@@ -24,12 +26,14 @@
 #include &quot;lpc17xx_timer.h&quot;
 #include &quot;lpc17xx_clkpwr.h&quot;
 #include &quot;lpc17xx_pwm.h&quot;
+#include &quot;lpc17xx_adc.h&quot;
 
 // ****************************************************************************
 // Platform initialization
 
 static void platform_setup_timers();
 static void platform_setup_pwm();
+static void platform_setup_adcs();
 
 int platform_init()
 {
@@ -37,21 +41,21 @@
   SystemInit();
   
   // DeInit NVIC and SCBNVIC
-	NVIC_DeInit();
-	NVIC_SCBDeInit();
+  NVIC_DeInit();
+  NVIC_SCBDeInit();
 	
   // Configure the NVIC Preemption Priority Bits:
   // two (2) bits of preemption priority, six (6) bits of sub-priority.
   // Since the Number of Bits used for Priority Levels is five (5), so the
   // actual bit number of sub-priority is three (3)
-	NVIC_SetPriorityGrouping(0x05);
+  NVIC_SetPriorityGrouping(0x05);
 	
-  	//  Set Vector table offset value
-  #if (__RAM_MODE__==1)
-  	NVIC_SetVTOR(0x10000000);
-  #else
-  	NVIC_SetVTOR(0x00000000);
-  #endif
+  //  Set Vector table offset value
+#if (__RAM_MODE__==1)
+  NVIC_SetVTOR(0x10000000);
+#else
+  NVIC_SetVTOR(0x00000000);
+#endif
 
   // Setup peripherals
   platform_setup_timers();
@@ -60,6 +64,11 @@
   // Initialize console UART
   platform_uart_setup( CON_UART_ID, CON_UART_SPEED, 8, PLATFORM_UART_PARITY_NONE, PLATFORM_UART_STOPBITS_1 );
 
+#ifdef BUILD_ADC
+  // Setup ADCs
+  platform_setup_adcs();
+#endif
+
   // Common platform initialization code
   cmn_platform_init();
 
@@ -128,27 +137,27 @@
 // The other UARTs have assignable Rx/Tx pins and thus have to be configured
 // by the user
 
-static const UART_TypeDef *uart[] = { UART0, UART1, UART2, UART3 };
+static LPC_UART_TypeDef *uart[] = { LPC_UART0, LPC_UART1, LPC_UART2, LPC_UART3 };
 
 u32 platform_uart_setup( unsigned id, u32 baud, int databits, int parity, int stopbits )
 {
   u32 temp;
-	// UART Configuration structure variable
-	UART_CFG_Type UARTConfigStruct;
-	// UART FIFO configuration Struct variable
-	UART_FIFO_CFG_Type UARTFIFOConfigStruct;
-	// Pin configuration for UART0
-	PINSEL_CFG_Type PinCfg;
+  // UART Configuration structure variable
+  UART_CFG_Type UARTConfigStruct;
+  // UART FIFO configuration Struct variable
+  UART_FIFO_CFG_Type UARTFIFOConfigStruct;
+  // Pin configuration for UART0
+  PINSEL_CFG_Type PinCfg;
 	
-	// UART0 Pin Config
-	PinCfg.Funcnum = 1;
-	PinCfg.OpenDrain = 0;
-	PinCfg.Pinmode = 0;
-	PinCfg.Pinnum = 2;
-	PinCfg.Portnum = 0;
-	PINSEL_ConfigPin(&amp;PinCfg);
-	PinCfg.Pinnum = 3;
-	PINSEL_ConfigPin(&amp;PinCfg);
+  // UART0 Pin Config
+  PinCfg.Funcnum = 1;
+  PinCfg.OpenDrain = 0;
+  PinCfg.Pinmode = 0;
+  PinCfg.Pinnum = 2;
+  PinCfg.Portnum = 0;
+  PINSEL_ConfigPin(&amp;PinCfg);
+  PinCfg.Pinnum = 3;
+  PINSEL_ConfigPin(&amp;PinCfg);
 	
   UARTConfigStruct.Baud_rate = ( uint32_t )baud;
   
@@ -157,7 +166,7 @@
     case 5:
       UARTConfigStruct.Databits = UART_DATABIT_5;
       break;
-
+      
     case 6:
       UARTConfigStruct.Databits = UART_DATABIT_6;
       break;
@@ -191,15 +200,15 @@
       break;
   }
 	
-	UART_Init(uart[ id ], &amp;UARTConfigStruct);
+  UART_Init(uart[ id ], &amp;UARTConfigStruct);
 	
-	// Get default FIFO config and initialize
-	UART_FIFOConfigStructInit(&amp;UARTFIFOConfigStruct);
-	UART_FIFOConfig(uart[ id ], &amp;UARTFIFOConfigStruct);
-	
-	// Enable Transmit
-	UART_TxCmd(uart[ id ], ENABLE);
-	
+  // Get default FIFO config and initialize
+  UART_FIFOConfigStructInit(&amp;UARTFIFOConfigStruct);
+  UART_FIFOConfig(uart[ id ], &amp;UARTFIFOConfigStruct);
+  
+  // Enable Transmit
+  UART_TxCmd(uart[ id ], ENABLE);
+  
   return baud; // FIXME: find a way to actually get baud
 }
 
@@ -227,7 +236,7 @@
 // ****************************************************************************
 // Timer section
 
-static const TIM_TypeDef *tmr[] = { TIM0, TIM1, TIM2, TIM3 };
+static LPC_TIM_TypeDef *tmr[] = { LPC_TIM0, LPC_TIM1, LPC_TIM2, LPC_TIM3 };
 static const u32 tmr_pclk[] = { CLKPWR_PCLKSEL_TIMER0, CLKPWR_PCLKSEL_TIMER1, CLKPWR_PCLKSEL_TIMER2, CLKPWR_PCLKSEL_TIMER3 };
 
 // Helper function: get timer clock
@@ -244,12 +253,12 @@
   TIM_Cmd( tmr[ id ], DISABLE );
 
   // Initialize timer 0, prescale count time of 1uS
-	TIM_ConfigStruct.PrescaleOption = TIM_PRESCALE_USVAL;
-	TIM_ConfigStruct.PrescaleValue	= 1000000ULL / clock;
+  TIM_ConfigStruct.PrescaleOption = TIM_PRESCALE_USVAL;
+  TIM_ConfigStruct.PrescaleValue	= 1000000ULL / clock;
 	
   TIM_Init( tmr[ id ], TIM_TIMER_MODE, &amp;TIM_ConfigStruct );
-	TIM_Cmd( tmr[ id ], ENABLE );
-	TIM_ResetCounter( tmr[ id ] );
+  TIM_Cmd( tmr[ id ], ENABLE );
+  TIM_ResetCounter( tmr[ id ] );
   
   return clock;
 }
@@ -265,9 +274,7 @@
   
   // Set base frequency to 1MHz, as we can't use a better resolution anyway
   for( i = 0; i &lt; 4; i ++ )
-  {
     platform_timer_set_clock( i, 1000000ULL );
-  }
 }
 
 void platform_s_timer_delay( unsigned id, u32 delay_us )
@@ -328,7 +335,216 @@
 }
 
 
+// *****************************************************************************
+// ADC specific functions and variables
 
+#ifdef BUILD_ADC
+
+
+// Match trigger sources for timer 1 &amp; timer 3
+static const u32 adc_trig[] = { 0, ADC_START_ON_MAT11, 0, 0 };
+
+int platform_adc_check_timer_id( unsigned id, unsigned timer_id )
+{
+  return ( ( timer_id == 1 ) );
+}
+
+void platform_adc_stop( unsigned id )
+{  
+  elua_adc_ch_state *s = adc_get_ch_state( id );
+  elua_adc_dev_state *d = adc_get_dev_state( 0 );
+    
+  s-&gt;op_pending = 0;
+  INACTIVATE_CHANNEL( d, id );
+  
+  // If there are no more active channels, stop the sequencer
+  if( d-&gt;ch_active == 0 &amp;&amp; d-&gt;running == 1 )
+  {
+    d-&gt;running = 0;
+    NVIC_DisableIRQ( ADC_IRQn );
+  }
+}
+
+// Handle ADC interrupts
+// NOTE: This could probably be less complicated...
+void ADC_IRQHandler(void)
+{
+  elua_adc_dev_state *d = adc_get_dev_state( 0 );
+  elua_adc_ch_state *s = d-&gt;ch_state[ d-&gt;seq_ctr ];
+  int i;
+  
+  // Disable sampling &amp; current sequence channel
+  ADC_StartCmd( LPC_ADC, 0 );
+  ADC_ChannelCmd( LPC_ADC, s-&gt;id, DISABLE );
+  ADC_IntConfig( LPC_ADC, s-&gt;id, DISABLE );
+
+  if ( ADC_ChannelGetStatus( LPC_ADC, s-&gt;id, ADC_DATA_DONE ) )
+  { 
+    d-&gt;sample_buf[ d-&gt;seq_ctr ] = ( u16 )ADC_ChannelGetData( LPC_ADC, s-&gt;id );
+    s-&gt;value_fresh = 1;
+            
+    if ( s-&gt;logsmoothlen &gt; 0 &amp;&amp; s-&gt;smooth_ready == 0)
+      adc_smooth_data( s-&gt;id );
+#if defined( BUF_ENABLE_ADC )
+    else if ( s-&gt;reqsamples &gt; 1 )
+    {
+      buf_write( BUF_ID_ADC, s-&gt;id, ( t_buf_data* )s-&gt;value_ptr );
+      s-&gt;value_fresh = 0;
+    }
+#endif
+        
+    if ( adc_samples_available( s-&gt;id ) &gt;= s-&gt;reqsamples &amp;&amp; s-&gt;freerunning == 0 )
+      platform_adc_stop( s-&gt;id );      
+  }
+    
+  // Set up for next channel acquisition if we're still running
+  if( d-&gt;running == 1 )
+  {
+    // Prep next channel in sequence, if applicable
+    if( d-&gt;seq_ctr &lt; ( d-&gt;seq_len - 1 ) )
+      d-&gt;seq_ctr++;
+    else if( d-&gt;seq_ctr == ( d-&gt;seq_len - 1 ) )
+    { 
+      adc_update_dev_sequence( 0 );
+      d-&gt;seq_ctr = 0; // reset sequence counter if on last sequence entry
+    }
+          
+    ADC_ChannelCmd( LPC_ADC, d-&gt;ch_state[ d-&gt;seq_ctr ]-&gt;id, ENABLE );
+    ADC_IntConfig( LPC_ADC, d-&gt;ch_state[ d-&gt;seq_ctr ]-&gt;id, ENABLE );
+         
+    if( d-&gt;clocked == 1  &amp;&amp; d-&gt;seq_ctr == 0 ) // always use clock for first in clocked sequence
+      ADC_StartCmd( LPC_ADC, adc_trig[ d-&gt;timer_id ] );
+
+    // Start next conversion if unclocked or if clocked and sequence index &gt; 0
+    if( ( d-&gt;clocked == 1 &amp;&amp; d-&gt;seq_ctr &gt; 0 ) || d-&gt;clocked == 0 )
+      ADC_StartCmd( LPC_ADC, ADC_START_NOW );
+  }
+}
+
+
+static void platform_setup_adcs()
+{
+  unsigned id;
+  
+  for( id = 0; id &lt; NUM_ADC; id ++ )
+    adc_init_ch_state( id );
+  
+  NVIC_SetPriority(ADC_IRQn, ((0x01&lt;&lt;3)|0x01));
+
+  ADC_Init(LPC_ADC, 13000000);
+  
+  // Default enables CH0, disable channel
+  ADC_ChannelCmd( LPC_ADC, 0, DISABLE );
+  
+  // Default enables ADC interrupt only on global, switch to per-channel
+  ADC_IntConfig( LPC_ADC, ADC_ADGINTEN, DISABLE );
+    
+  platform_adc_setclock( 0, 0 );
+}
+
+
+// NOTE: On this platform, there is only one ADC, clock settings apply to the whole device
+u32 platform_adc_setclock( unsigned id, u32 frequency )
+{
+  TIM_TIMERCFG_Type TIM_ConfigStruct;
+  TIM_MATCHCFG_Type TIM_MatchConfigStruct ;
+  elua_adc_dev_state *d = adc_get_dev_state( 0 );
+
+  if ( frequency &gt; 0 )
+  {
+    d-&gt;clocked = 1;
+    
+    // Max Sampling Rate on LPC1768 is 200 kS/s
+    if ( frequency &gt; 200000 )
+      frequency = 200000;
+        
+    // Run timer at 1MHz
+    TIM_ConfigStruct.PrescaleOption = TIM_PRESCALE_USVAL;
+    TIM_ConfigStruct.PrescaleValue	= 1;
+    
+    TIM_MatchConfigStruct.MatchChannel = 1;
+    TIM_MatchConfigStruct.IntOnMatch   = FALSE;
+    TIM_MatchConfigStruct.ResetOnMatch = TRUE;
+    TIM_MatchConfigStruct.StopOnMatch  = FALSE;
+    TIM_MatchConfigStruct.ExtMatchOutputType = TIM_EXTMATCH_TOGGLE;
+    // Set match value to period (in uS) associated with frequency
+    TIM_MatchConfigStruct.MatchValue   = ( 1000000ULL / ( frequency * 2 ) ) - 1;
+        
+    frequency = 1000000ULL / (TIM_MatchConfigStruct.MatchValue + 1);
+  	
+    // Set configuration for Tim_config and Tim_MatchConfig
+    TIM_Init( tmr[ d-&gt;timer_id ], TIM_TIMER_MODE, &amp;TIM_ConfigStruct );
+    TIM_ConfigMatch( tmr[ d-&gt;timer_id ], &amp;TIM_MatchConfigStruct );
+    TIM_ResetCounter( tmr[ d-&gt;timer_id ] );
+  }
+  else
+    d-&gt;clocked = 0;
+    
+  return frequency;
+}
+
+static const u8 adc_ports[] = {  0, 0,   0,  0,  1,  1, 0, 0 };
+static const u8 adc_pins[] =  { 23, 24, 25, 26, 30, 31, 3, 2 };
+static const u8 adc_funcs[] = {  1,  1,  1,  1,  3,  3, 2, 2 };
+
+// Prepare Hardware Channel
+int platform_adc_update_sequence( )
+{ 
+  elua_adc_dev_state *d = adc_get_dev_state( 0 ); 
+  PINSEL_CFG_Type PinCfg;
+  u8 seq_tmp;
+  unsigned id;
+  
+  // Enable Needed Pins
+  PinCfg.OpenDrain = 0;
+  PinCfg.Pinmode = 0;
+  
+  for( seq_tmp = 0; seq_tmp &lt; d-&gt;seq_len; seq_tmp++ )
+  {
+    id = d-&gt;ch_state[ seq_tmp ]-&gt;id;
+       
+    PinCfg.Funcnum = adc_funcs[ id ];
+    PinCfg.Pinnum = adc_pins[ id ];
+    PinCfg.Portnum = adc_ports[ id ];
+    PINSEL_ConfigPin(&amp;PinCfg);
+  }
+  
+  return PLATFORM_OK;
+}
+
+
+int platform_adc_start_sequence()
+{ 
+  elua_adc_dev_state *d = adc_get_dev_state( 0 );
+  
+  if( d-&gt;running != 1 )
+  {
+    adc_update_dev_sequence( 0 );
+    
+    // Start sampling on first channel
+    d-&gt;seq_ctr = 0;
+    ADC_ChannelCmd( LPC_ADC, d-&gt;ch_state[ d-&gt;seq_ctr ]-&gt;id, ENABLE );
+    ADC_IntConfig( LPC_ADC, d-&gt;ch_state[ d-&gt;seq_ctr ]-&gt;id, ENABLE );
+
+    d-&gt;running = 1;
+    NVIC_EnableIRQ( ADC_IRQn );
+    
+    if( d-&gt;clocked == 1 )
+    {
+      ADC_StartCmd( LPC_ADC, adc_trig[ d-&gt;timer_id ] );
+      TIM_ResetCounter( tmr[ d-&gt;timer_id ] );
+      TIM_Cmd( tmr[ d-&gt;timer_id ], ENABLE );
+    }
+    else
+      ADC_StartCmd( LPC_ADC, ADC_START_NOW );
+  }
+  
+  return PLATFORM_OK;
+}
+
+#endif // ifdef BUILD_ADC
+
+
 // ****************************************************************************
 // PWM functions
 
@@ -336,7 +552,7 @@
 // Helper function: get timer clock
 static u32 platform_pwm_get_clock( unsigned id )
 {
-  return CLKPWR_GetPCLK( CLKPWR_PCLKSEL_PWM1 ) / ( PWM1-&gt;PR + 1 );
+  return CLKPWR_GetPCLK( CLKPWR_PCLKSEL_PWM1 ) / ( LPC_PWM1-&gt;PR + 1 );
 }
 
 // Helper function: set timer clock
@@ -346,7 +562,7 @@
   
   PWMCfgDat.PrescaleOption = PWM_TIMER_PRESCALE_USVAL;
 	PWMCfgDat.PrescaleValue = 1000000ULL / clock;
-	PWM_Init(PWM1, PWM_MODE_TIMER, &amp;PWMCfgDat);
+	PWM_Init(LPC_PWM1, PWM_MODE_TIMER, &amp;PWMCfgDat);
 	
   return clock;
 }
@@ -357,14 +573,14 @@
   PWM_MATCHCFG_Type PWMMatchCfgDat;
   
   // Keep clock in reset, set PWM code
-  PWM_ResetCounter(PWM1);
+  PWM_ResetCounter(LPC_PWM1);
   
   // Set match mode (reset on MR0 match)
   PWMMatchCfgDat.IntOnMatch = DISABLE;
 	PWMMatchCfgDat.MatchChannel = 0;
 	PWMMatchCfgDat.ResetOnMatch = ENABLE;
 	PWMMatchCfgDat.StopOnMatch = DISABLE;
-	PWM_ConfigMatch(PWM1, &amp;PWMMatchCfgDat);
+	PWM_ConfigMatch(LPC_PWM1, &amp;PWMMatchCfgDat);
 
   // Set base frequency to 1MHz
   platform_pwm_set_clock( 0, 1000000 );
@@ -375,22 +591,22 @@
   PWM_MATCHCFG_Type PWMMatchCfgDat;
   u32 divisor = platform_pwm_get_clock( id ) / frequency - 1;
     
-  PWM_MatchUpdate(PWM1, 0, divisor, PWM_MATCH_UPDATE_NOW); // PWM1 cycle rate
-  PWM_MatchUpdate(PWM1, id, ( divisor * duty ) / 100, PWM_MATCH_UPDATE_NOW); // PWM1 channel edge position
+  PWM_MatchUpdate(LPC_PWM1, 0, divisor, PWM_MATCH_UPDATE_NOW); // PWM1 cycle rate
+  PWM_MatchUpdate(LPC_PWM1, id, ( divisor * duty ) / 100, PWM_MATCH_UPDATE_NOW); // PWM1 channel edge position
   
   if ( id &gt; 1 ) // Channel one is permanently single-edge
-    PWM_ChannelConfig( PWM1, id, PWM_CHANNEL_SINGLE_EDGE );
+    PWM_ChannelConfig( LPC_PWM1, id, PWM_CHANNEL_SINGLE_EDGE );
   
   PWMMatchCfgDat.IntOnMatch = DISABLE;
 	PWMMatchCfgDat.MatchChannel = id;
 	PWMMatchCfgDat.ResetOnMatch = DISABLE;
 	PWMMatchCfgDat.StopOnMatch = DISABLE;
-	PWM_ConfigMatch(PWM1, &amp;PWMMatchCfgDat);
+	PWM_ConfigMatch(LPC_PWM1, &amp;PWMMatchCfgDat);
 	
-	PWM_ResetCounter(PWM1);
-	PWM_CounterCmd(PWM1, ENABLE);
+	PWM_ResetCounter(LPC_PWM1);
+	PWM_CounterCmd(LPC_PWM1, ENABLE);
 	
-	PWM_ChannelCmd(PWM1, id, ENABLE);
+	PWM_ChannelCmd(LPC_PWM1, id, ENABLE);
 
   return platform_pwm_get_clock( id ) / divisor;
 }
@@ -402,11 +618,11 @@
   switch( op )
   {
     case PLATFORM_PWM_OP_START:
-      PWM_Cmd(PWM1, ENABLE);
+      PWM_Cmd(LPC_PWM1, ENABLE);
       break;
 
     case PLATFORM_PWM_OP_STOP:
-      PWM_Cmd(PWM1, DISABLE);
+      PWM_Cmd(LPC_PWM1, DISABLE);
       break;
 
     case PLATFORM_PWM_OP_SET_CLOCK:

Modified: trunk/src/platform/lpc17xx/platform_conf.h
===================================================================
--- trunk/src/platform/lpc17xx/platform_conf.h	2010-06-28 21:53:59 UTC (rev 759)
+++ trunk/src/platform/lpc17xx/platform_conf.h	2010-07-12 20:56:54 UTC (rev 760)
@@ -14,8 +14,9 @@
 #define BUILD_ROMFS
 #define BUILD_TERM
 #define BUILD_CON_GENERIC
+#define BUILD_ADC
 #define BUILD_SEMIFS
-//#define BUILD_LUARPC
+#define BUILD_LUARPC
 
 // *****************************************************************************
 // UART/Timer IDs configuration data (used in main.c)
@@ -29,6 +30,12 @@
 // *****************************************************************************
 // Auxiliary libraries that will be compiled for this platform
 
+#ifdef BUILD_ADC
+#define ADCLINE _ROM( AUXLIB_ADC, luaopen_adc, adc_map )
+#else
+#define ADCLINE
+#endif
+
 // The name of the platform specific libs table
 #define PS_LIB_TABLE_NAME   &quot;mbed&quot;
 
@@ -37,6 +44,7 @@
   _ROM( AUXLIB_UART, luaopen_uart, uart_map )\
   _ROM( AUXLIB_PD, luaopen_pd, pd_map )\
   _ROM( AUXLIB_TMR, luaopen_tmr, tmr_map )\
+  ADCLINE\
   _ROM( AUXLIB_TERM, luaopen_term, term_map )\
   _ROM( AUXLIB_PACK, luaopen_pack, pack_map )\
   _ROM( AUXLIB_BIT, luaopen_bit, bit_map )\
@@ -60,7 +68,7 @@
 #define NUM_SPI               0
 #define NUM_UART              4
 #define NUM_PWM               6
-#define NUM_ADC               0
+#define NUM_ADC               8
 #define NUM_CAN               0
 // If virtual timers are enabled, the last timer will be used only for them
 #if VTMR_NUM_TIMERS == 0
@@ -75,6 +83,15 @@
 //#define BUF_ENABLE_UART
 //#define CON_BUF_SIZE          BUF_SIZE_128
 
+// ADC Configuration Params
+#define ADC_BIT_RESOLUTION    12
+#define BUF_ENABLE_ADC
+#define ADC_BUF_SIZE          BUF_SIZE_2
+
+// These should be adjusted to support multiple ADC devices
+#define ADC_TIMER_FIRST_ID    0
+#define ADC_NUM_TIMERS        4
+
 // RPC  
 #define RPC_UART_ID           CON_UART_ID
 #define RPC_TIMER_ID          CON_TIMER_ID

Modified: trunk/src/platform/lpc17xx/system_LPC17xx.c
===================================================================
--- trunk/src/platform/lpc17xx/system_LPC17xx.c	2010-06-28 21:53:59 UTC (rev 759)
+++ trunk/src/platform/lpc17xx/system_LPC17xx.c	2010-07-12 20:56:54 UTC (rev 760)
@@ -1,492 +1,559 @@
-/****************************************************************************//**
- * @file :    system_LPC17xx.c
- * @brief : CMSIS Cortex-M3 Device Peripheral Access Layer Source File
- *           for the NXP LPC17xx Device Series
- * @version : V1.0
- * @date :    26. Nov. 2008
- *----------------------------------------------------------------------------
- *
- * Copyright (C) 2008 ARM Limited. All rights reserved.
- *
- * ARM Limited (ARM) is supplying this software for use with Cortex-M3
- * processor based microcontrollers.  This file can be freely distributed
- * within development tools that are supporting such ARM based processors.
- *
- * THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
- * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
- * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
- * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
- *
- ******************************************************************************/
-
-
-#include &lt;stdint.h&gt;
-#include &quot;LPC17xx.h&quot;
-
-/** @addtogroup LPC17xx_System_Defines
-  * @{
-  */
-
-/*
-//-------- &lt;&lt;&lt; Use Configuration Wizard in Context Menu &gt;&gt;&gt; ------------------
-*/
-
-/*--------------------- Clock Configuration ----------------------------------
-//
-// &lt;e&gt; Clock Configuration
-//   &lt;h&gt; System Controls and Status Register (SCS)
-//     &lt;o1.4&gt;    OSCRANGE: Main Oscillator Range Select
-//                     &lt;0=&gt;  1 MHz to 20 MHz
-//                     &lt;1=&gt; 15 MHz to 24 MHz
-//     &lt;e1.5&gt;       OSCEN: Main Oscillator Enable
-//     &lt;/e&gt;
-//   &lt;/h&gt;
-//
-//   &lt;h&gt; Clock Source Select Register (CLKSRCSEL)
-//     &lt;o2.0..1&gt;   CLKSRC: PLL Clock Source Selection
-//                     &lt;0=&gt; Internal RC oscillator
-//                     &lt;1=&gt; Main oscillator
-//                     &lt;2=&gt; RTC oscillator
-//   &lt;/h&gt;
-//
-//   &lt;e3&gt; PLL0 Configuration (Main PLL)
-//     &lt;h&gt; PLL0 Configuration Register (PLL0CFG)
-//                     &lt;i&gt; F_cco0 = (2 * M * F_in) / N
-//                     &lt;i&gt; F_in must be in the range of 32 kHz to 50 MHz
-//                     &lt;i&gt; F_cco0 must be in the range of 275 MHz to 550 MHz
-//       &lt;o4.0..14&gt;  MSEL: PLL Multiplier Selection
-//                     &lt;6-32768&gt;&lt;#-1&gt;
-//                     &lt;i&gt; M Value
-//       &lt;o4.16..23&gt; NSEL: PLL Divider Selection
-//                     &lt;1-256&gt;&lt;#-1&gt;
-//                     &lt;i&gt; N Value
-//     &lt;/h&gt;
-//   &lt;/e&gt;
-//
-//   &lt;e5&gt; PLL1 Configuration (USB PLL)
-//     &lt;h&gt; PLL1 Configuration Register (PLL1CFG)
-//                     &lt;i&gt; F_usb = M * F_osc or F_usb = F_cco1 / (2 * P)
-//                     &lt;i&gt; F_cco1 = F_osc * M * 2 * P
-//                     &lt;i&gt; F_cco1 must be in the range of 156 MHz to 320 MHz
-//       &lt;o6.0..4&gt;   MSEL: PLL Multiplier Selection
-//                     &lt;1-32&gt;&lt;#-1&gt;
-//                     &lt;i&gt; M Value (for USB maximum value is 4)
-//       &lt;o6.5..6&gt;   PSEL: PLL Divider Selection
-//                     &lt;0=&gt; 1
-//                     &lt;1=&gt; 2
-//                     &lt;2=&gt; 4
-//                     &lt;3=&gt; 8
-//                     &lt;i&gt; P Value
-//     &lt;/h&gt;
-//   &lt;/e&gt;
-//
-//   &lt;h&gt; CPU Clock Configuration Register (CCLKCFG)
-//     &lt;o7.0..7&gt;  CCLKSEL: Divide Value for CPU Clock from PLL0
-//                     &lt;2-256:2&gt;&lt;#-1&gt;
-//   &lt;/h&gt;
-//
-//   &lt;h&gt; USB Clock Configuration Register (USBCLKCFG)
-//     &lt;o8.0..3&gt;   USBSEL: Divide Value for USB Clock from PLL1
-//                     &lt;0-15&gt;
-//                     &lt;i&gt; Divide is USBSEL + 1
-//   &lt;/h&gt;
-//
-//   &lt;h&gt; Peripheral Clock Selection Register 0 (PCLKSEL0)
-//     &lt;o9.0..1&gt;    PCLK_WDT: Peripheral Clock Selection for WDT
-//                     &lt;0=&gt; Pclk = Cclk / 4
-//                     &lt;1=&gt; Pclk = Cclk
-//                     &lt;2=&gt; Pclk = Cclk / 2
-//                     &lt;3=&gt; Pclk = Hclk / 8
-//     &lt;o9.2..3&gt;    PCLK_TIMER0: Peripheral Clock Selection for TIMER0
-//                     &lt;0=&gt; Pclk = Cclk / 4
-//                     &lt;1=&gt; Pclk = Cclk
-//                     &lt;2=&gt; Pclk = Cclk / 2
-//                     &lt;3=&gt; Pclk = Hclk / 8
-//     &lt;o9.4..5&gt;    PCLK_TIMER1: Peripheral Clock Selection for TIMER1
-//                     &lt;0=&gt; Pclk = Cclk / 4
-//                     &lt;1=&gt; Pclk = Cclk
-//                     &lt;2=&gt; Pclk = Cclk / 2
-//                     &lt;3=&gt; Pclk = Hclk / 8
-//     &lt;o9.6..7&gt;    PCLK_UART0: Peripheral Clock Selection for UART0
-//                     &lt;0=&gt; Pclk = Cclk / 4
-//                     &lt;1=&gt; Pclk = Cclk
-//                     &lt;2=&gt; Pclk = Cclk / 2
-//                     &lt;3=&gt; Pclk = Hclk / 8
-//     &lt;o9.8..9&gt;    PCLK_UART1: Peripheral Clock Selection for UART1
-//                     &lt;0=&gt; Pclk = Cclk / 4
-//                     &lt;1=&gt; Pclk = Cclk
-//                     &lt;2=&gt; Pclk = Cclk / 2
-//                     &lt;3=&gt; Pclk = Hclk / 8
-//     &lt;o9.12..13&gt;  PCLK_PWM1: Peripheral Clock Selection for PWM1
-//                     &lt;0=&gt; Pclk = Cclk / 4
-//                     &lt;1=&gt; Pclk = Cclk
-//                     &lt;2=&gt; Pclk = Cclk / 2
-//                     &lt;3=&gt; Pclk = Hclk / 8
-//     &lt;o9.14..15&gt;  PCLK_I2C0: Peripheral Clock Selection for I2C0
-//                     &lt;0=&gt; Pclk = Cclk / 4
-//                     &lt;1=&gt; Pclk = Cclk
-//                     &lt;2=&gt; Pclk = Cclk / 2
-//                     &lt;3=&gt; Pclk = Hclk / 8
-//     &lt;o9.16..17&gt;  PCLK_SPI: Peripheral Clock Selection for SPI
-//                     &lt;0=&gt; Pclk = Cclk / 4
-//                     &lt;1=&gt; Pclk = Cclk
-//                     &lt;2=&gt; Pclk = Cclk / 2
-//                     &lt;3=&gt; Pclk = Hclk / 8
-//     &lt;o9.20..21&gt;  PCLK_SSP1: Peripheral Clock Selection for SSP1
-//                     &lt;0=&gt; Pclk = Cclk / 4
-//                     &lt;1=&gt; Pclk = Cclk
-//                     &lt;2=&gt; Pclk = Cclk / 2
-//                     &lt;3=&gt; Pclk = Hclk / 8
-//     &lt;o9.22..23&gt;  PCLK_DAC: Peripheral Clock Selection for DAC
-//                     &lt;0=&gt; Pclk = Cclk / 4
-//                     &lt;1=&gt; Pclk = Cclk
-//                     &lt;2=&gt; Pclk = Cclk / 2
-//                     &lt;3=&gt; Pclk = Hclk / 8
-//     &lt;o9.24..25&gt;  PCLK_ADC: Peripheral Clock Selection for ADC
-//                     &lt;0=&gt; Pclk = Cclk / 4
-//                     &lt;1=&gt; Pclk = Cclk
-//                     &lt;2=&gt; Pclk = Cclk / 2
-//                     &lt;3=&gt; Pclk = Hclk / 8
-//     &lt;o9.26..27&gt;  PCLK_CAN1: Peripheral Clock Selection for CAN1
-//                     &lt;0=&gt; Pclk = Cclk / 4
-//                     &lt;1=&gt; Pclk = Cclk
-//                     &lt;2=&gt; Pclk = Cclk / 2
-//                     &lt;3=&gt; Pclk = Hclk / 6
-//     &lt;o9.28..29&gt;  PCLK_CAN2: Peripheral Clock Selection for CAN2
-//                     &lt;0=&gt; Pclk = Cclk / 4
-//                     &lt;1=&gt; Pclk = Cclk
-//                     &lt;2=&gt; Pclk = Cclk / 2
-//                     &lt;3=&gt; Pclk = Hclk / 6
-//     &lt;o9.30..31&gt;  PCLK_ACF: Peripheral Clock Selection for ACF
-//                     &lt;0=&gt; Pclk = Cclk / 4
-//                     &lt;1=&gt; Pclk = Cclk
-//                     &lt;2=&gt; Pclk = Cclk / 2
-//                     &lt;3=&gt; Pclk = Hclk / 6
-//   &lt;/h&gt;
-//
-//   &lt;h&gt; Peripheral Clock Selection Register 1 (PCLKSEL1)
-//     &lt;o10.0..1&gt;   PCLK_QEI: Peripheral Clock Selection for the Quadrature Encoder Interface
-//                     &lt;0=&gt; Pclk = Cclk / 4
-//                     &lt;1=&gt; Pclk = Cclk
-//                     &lt;2=&gt; Pclk = Cclk / 2
-//                     &lt;3=&gt; Pclk = Hclk / 8
-//     &lt;o10.2..3&gt;   PCLK_GPIO: Peripheral Clock Selection for GPIOs
-//                     &lt;0=&gt; Pclk = Cclk / 4
-//                     &lt;1=&gt; Pclk = Cclk
-//                     &lt;2=&gt; Pclk = Cclk / 2
-//                     &lt;3=&gt; Pclk = Hclk / 8
-//     &lt;o10.4..5&gt;   PCLK_PCB: Peripheral Clock Selection for the Pin Connect Block
-//                     &lt;0=&gt; Pclk = Cclk / 4
-//                     &lt;1=&gt; Pclk = Cclk
-//                     &lt;2=&gt; Pclk = Cclk / 2
-//                     &lt;3=&gt; Pclk = Hclk / 8
-//     &lt;o10.6..7&gt;   PCLK_I2C1: Peripheral Clock Selection for I2C1
-//                     &lt;0=&gt; Pclk = Cclk / 4
-//                     &lt;1=&gt; Pclk = Cclk
-//                     &lt;2=&gt; Pclk = Cclk / 2
-//                     &lt;3=&gt; Pclk = Hclk / 8
-//     &lt;o10.10..11&gt; PCLK_SSP0: Peripheral Clock Selection for SSP0
-//                     &lt;0=&gt; Pclk = Cclk / 4
-//                     &lt;1=&gt; Pclk = Cclk
-//                     &lt;2=&gt; Pclk = Cclk / 2
-//                     &lt;3=&gt; Pclk = Hclk / 8
-//     &lt;o10.12..13&gt; PCLK_TIMER2: Peripheral Clock Selection for TIMER2
-//                     &lt;0=&gt; Pclk = Cclk / 4
-//                     &lt;1=&gt; Pclk = Cclk
-//                     &lt;2=&gt; Pclk = Cclk / 2
-//                     &lt;3=&gt; Pclk = Hclk / 8
-//     &lt;o10.14..15&gt; PCLK_TIMER3: Peripheral Clock Selection for TIMER3
-//                     &lt;0=&gt; Pclk = Cclk / 4
-//                     &lt;1=&gt; Pclk = Cclk
-//                     &lt;2=&gt; Pclk = Cclk / 2
-//                     &lt;3=&gt; Pclk = Hclk / 8
-//     &lt;o10.16..17&gt; PCLK_UART2: Peripheral Clock Selection for UART2
-//                     &lt;0=&gt; Pclk = Cclk / 4
-//                     &lt;1=&gt; Pclk = Cclk
-//                     &lt;2=&gt; Pclk = Cclk / 2
-//                     &lt;3=&gt; Pclk = Hclk / 8
-//     &lt;o10.18..19&gt; PCLK_UART3: Peripheral Clock Selection for UART3
-//                     &lt;0=&gt; Pclk = Cclk / 4
-//                     &lt;1=&gt; Pclk = Cclk
-//                     &lt;2=&gt; Pclk = Cclk / 2
-//                     &lt;3=&gt; Pclk = Hclk / 8
-//     &lt;o10.20..21&gt; PCLK_I2C2: Peripheral Clock Selection for I2C2
-//                     &lt;0=&gt; Pclk = Cclk / 4
-//                     &lt;1=&gt; Pclk = Cclk
-//                     &lt;2=&gt; Pclk = Cclk / 2
-//                     &lt;3=&gt; Pclk = Hclk / 8
-//     &lt;o10.22..23&gt; PCLK_I2S: Peripheral Clock Selection for I2S
-//                     &lt;0=&gt; Pclk = Cclk / 4
-//                     &lt;1=&gt; Pclk = Cclk
-//                     &lt;2=&gt; Pclk = Cclk / 2
-//                     &lt;3=&gt; Pclk = Hclk / 8
-//     &lt;o10.26..27&gt; PCLK_RIT: Peripheral Clock Selection for the Repetitive Interrupt Timer
-//                     &lt;0=&gt; Pclk = Cclk / 4
-//                     &lt;1=&gt; Pclk = Cclk
-//                     &lt;2=&gt; Pclk = Cclk / 2
-//                     &lt;3=&gt; Pclk = Hclk / 8
-//     &lt;o10.28..29&gt; PCLK_SYSCON: Peripheral Clock Selection for the System Control Block
-//                     &lt;0=&gt; Pclk = Cclk / 4
-//                     &lt;1=&gt; Pclk = Cclk
-//                     &lt;2=&gt; Pclk = Cclk / 2
-//                     &lt;3=&gt; Pclk = Hclk / 8
-//     &lt;o10.30..31&gt; PCLK_MC: Peripheral Clock Selection for the Motor Control PWM
-//                     &lt;0=&gt; Pclk = Cclk / 4
-//                     &lt;1=&gt; Pclk = Cclk
-//                     &lt;2=&gt; Pclk = Cclk / 2
-//                     &lt;3=&gt; Pclk = Hclk / 8
-//   &lt;/h&gt;
-//
-//   &lt;h&gt; Power Control for Peripherals Register (PCONP)
-//     &lt;o11.1&gt;      PCTIM0: Timer/Counter 0 power/clock enable
-//     &lt;o11.2&gt;      PCTIM1: Timer/Counter 1 power/clock enable
-//     &lt;o11.3&gt;      PCUART0: UART 0 power/clock enable
-//     &lt;o11.4&gt;      PCUART1: UART 1 power/clock enable
-//     &lt;o11.6&gt;      PCPWM1: PWM 1 power/clock enable
-//     &lt;o11.7&gt;      PCI2C0: I2C interface 0 power/clock enable
-//     &lt;o11.8&gt;      PCSPI: SPI interface power/clock enable
-//     &lt;o11.9&gt;      PCRTC: RTC power/clock enable
-//     &lt;o11.10&gt;     PCSSP1: SSP interface 1 power/clock enable
-//     &lt;o11.12&gt;     PCAD: A/D converter power/clock enable
-//     &lt;o11.13&gt;     PCCAN1: CAN controller 1 power/clock enable
-//     &lt;o11.14&gt;     PCCAN2: CAN controller 2 power/clock enable
-//     &lt;o11.15&gt;     PCGPIO: GPIOs power/clock enable
-//     &lt;o11.16&gt;     PCRIT: Repetitive interrupt timer power/clock enable
-//     &lt;o11.17&gt;     PCMC: Motor control PWM power/clock enable
-//     &lt;o11.18&gt;     PCQEI: Quadrature encoder interface power/clock enable
-//     &lt;o11.19&gt;     PCI2C1: I2C interface 1 power/clock enable
-//     &lt;o11.21&gt;     PCSSP0: SSP interface 0 power/clock enable
-//     &lt;o11.22&gt;     PCTIM2: Timer 2 power/clock enable
-//     &lt;o11.23&gt;     PCTIM3: Timer 3 power/clock enable
-//     &lt;o11.24&gt;     PCUART2: UART 2 power/clock enable
-//     &lt;o11.25&gt;     PCUART3: UART 3 power/clock enable
-//     &lt;o11.26&gt;     PCI2C2: I2C interface 2 power/clock enable
-//     &lt;o11.27&gt;     PCI2S: I2S interface power/clock enable
-//     &lt;o11.29&gt;     PCGPDMA: GP DMA function power/clock enable
-//     &lt;o11.30&gt;     PCENET: Ethernet block power/clock enable
-//     &lt;o11.31&gt;     PCUSB: USB interface power/clock enable
-//   &lt;/h&gt;
-// &lt;/e&gt;
-*/
-#define CLOCK_SETUP           1
-#define SCS_Val               0x00000020
-#define CLKSRCSEL_Val         0x00000001
-#define PLL0_SETUP            1
-#define PLL0CFG_Val           0x0000000B
-#define PLL1_SETUP            1
-#define PLL1CFG_Val           0x00000023
-#define CCLKCFG_Val           0x00000003
-#define USBCLKCFG_Val         0x00000000
-#define PCLKSEL0_Val          0x00000000
-#define PCLKSEL1_Val          0x00000000
-#define PCONP_Val             0x042887DE
-
-
-/*--------------------- Flash Accelerator Configuration ----------------------
-//
-// &lt;e&gt; Flash Accelerator Configuration
-//   &lt;o1.0..1&gt;   FETCHCFG: Fetch Configuration
-//               &lt;0=&gt; Instruction fetches from flash are not buffered
-//               &lt;1=&gt; One buffer is used for all instruction fetch buffering
-//               &lt;2=&gt; All buffers may be used for instruction fetch buffering
-//               &lt;3=&gt; Reserved (do not use this setting)
-//   &lt;o1.2..3&gt;   DATACFG: Data Configuration
-//               &lt;0=&gt; Data accesses from flash are not buffered
-//               &lt;1=&gt; One buffer is used for all data access buffering
-//               &lt;2=&gt; All buffers may be used for data access buffering
-//               &lt;3=&gt; Reserved (do not use this setting)
-//   &lt;o1.4&gt;      ACCEL: Acceleration Enable
-//   &lt;o1.5&gt;      PREFEN: Prefetch Enable
-//   &lt;o1.6&gt;      PREFOVR: Prefetch Override
-//   &lt;o1.12..15&gt; FLASHTIM: Flash Access Time
-//               &lt;0=&gt; 1 CPU clock (for CPU clock up to 20 MHz)
-//               &lt;1=&gt; 2 CPU clocks (for CPU clock up to 40 MHz)
-//               &lt;2=&gt; 3 CPU clocks (for CPU clock up to 60 MHz)
-//               &lt;3=&gt; 4 CPU clocks (for CPU clock up to 80 MHz)
-//               &lt;4=&gt; 5 CPU clocks (for CPU clock up to 100 MHz)
-//               &lt;5=&gt; 6 CPU clocks (for any CPU clock)
-// &lt;/e&gt;
-*/
-#define FLASH_SETUP           1
-#define FLASHCFG_Val          0x0000303A
-
-/*
-//-------- &lt;&lt;&lt; end of configuration section &gt;&gt;&gt; ------------------------------
-*/
-
-/*----------------------------------------------------------------------------
-  Check the register settings
- *----------------------------------------------------------------------------*/
-#define CHECK_RANGE(val, min, max)                ((val &lt; min) || (val &gt; max))
-#define CHECK_RSVD(val, mask)                     (val &amp; mask)
-
-/* Clock Configuration -------------------------------------------------------*/
-#if (CHECK_RSVD((SCS_Val),       ~0x00000030))
-   #error &quot;SCS: Invalid values of reserved bits!&quot;
-#endif
-
-#if (CHECK_RANGE((CLKSRCSEL_Val), 0, 2))
-   #error &quot;CLKSRCSEL: Value out of range!&quot;
-#endif
-
-#if (CHECK_RSVD((PLL0CFG_Val),   ~0x00FF7FFF))
-   #error &quot;PLL0CFG: Invalid values of reserved bits!&quot;
-#endif
-
-#if (CHECK_RSVD((PLL1CFG_Val),   ~0x0000007F))
-   #error &quot;PLL1CFG: Invalid values of reserved bits!&quot;
-#endif
-
-#if ((CCLKCFG_Val != 0) &amp;&amp; (((CCLKCFG_Val - 1) % 2)))
-   #error &quot;CCLKCFG: CCLKSEL field does not contain only odd values or 0!&quot;
-#endif
-
-#if (CHECK_RSVD((USBCLKCFG_Val), ~0x0000000F))
-   #error &quot;USBCLKCFG: Invalid values of reserved bits!&quot;
-#endif
-
-#if (CHECK_RSVD((PCLKSEL0_Val),   0x000C0C00))
-   #error &quot;PCLKSEL0: Invalid values of reserved bits!&quot;
-#endif
-
-#if (CHECK_RSVD((PCLKSEL1_Val),   0x03000300))
-   #error &quot;PCLKSEL1: Invalid values of reserved bits!&quot;
-#endif
-
-#if (CHECK_RSVD((PCONP_Val),      0x10100821))
-   #error &quot;PCONP: Invalid values of reserved bits!&quot;
-#endif
-
-/* Flash Accelerator Configuration -------------------------------------------*/
-#if (CHECK_RSVD((FLASHCFG_Val), ~0x0000F07F))
-   #error &quot;FLASHCFG: Invalid values of reserved bits!&quot;
-#endif
-
-
-/*----------------------------------------------------------------------------
-  DEFINES
- *----------------------------------------------------------------------------*/
-
-/*----------------------------------------------------------------------------
-  Define clocks
- *----------------------------------------------------------------------------*/
-#define XTAL        (12000000UL)        /* Oscillator frequency               */
-#define OSC_CLK     (      XTAL)        /* Main oscillator frequency          */
-#define RTC_CLK     (   32000UL)        /* RTC oscillator frequency           */
-#define IRC_OSC     ( 4000000UL)        /* Internal RC oscillator frequency   */
-
-/**
- * @}
- */
-
-
-/** @addtogroup LPC17xx_System_Public_Variables
-  * @{
-  */
-
-/*----------------------------------------------------------------------------
-  Clock Variable definitions
- *----------------------------------------------------------------------------*/
-uint32_t SystemFrequency = IRC_OSC; /*!&lt; System Clock Frequency (Core Clock)  */
-
-/**
- * @}
- */
-
-/** @addtogroup LPC17xx_System_Public_Functions
-  * @{
-  */
-
-/**
- * Initialize the system
- *
- * @param  none
- * @return none
- *
- * @brief  Setup the microcontroller system.
- *         Initialize the System and update the SystemFrequency variable.
- */
-void SystemInit (void)
-{
-#if (CLOCK_SETUP)                       /* Clock Setup                        */
-  SC-&gt;SCS       = SCS_Val;
-  if (SCS_Val &amp; (1 &lt;&lt; 5)) {             /* If Main Oscillator is enabled      */
-    while ((SC-&gt;SCS &amp; (1 &lt;&lt; 6)) == 0);  /* Wait for Oscillator to be ready    */
-  }
-
-#if (PLL0_SETUP)
-  SC-&gt;CLKSRCSEL = CLKSRCSEL_Val;        /* Select Clock Source for PLL0       */
-  SC-&gt;PLL0CFG   = PLL0CFG_Val;
-  SC-&gt;PLL0CON   = 0x01;                 /* PLL0 Enable                        */
-  SC-&gt;PLL0FEED  = 0xAA;
-  SC-&gt;PLL0FEED  = 0x55;
-  while (!(SC-&gt;PLL0STAT &amp; (1 &lt;&lt; 26)));  /* Wait for PLOCK0                    */
-  SC-&gt;CCLKCFG   = CCLKCFG_Val;          /* Setup Clock Divider                */
-
-  SC-&gt;PLL0CON   = 0x03;                 /* PLL0 Enable &amp; Connect              */
-  SC-&gt;PLL0FEED  = 0xAA;
-  SC-&gt;PLL0FEED  = 0x55;
-#endif
-
-#if (PLL1_SETUP)
-  SC-&gt;PLL1CFG   = PLL1CFG_Val;
-  SC-&gt;PLL1CON   = 0x01;                 /* PLL1 Enable                        */
-  SC-&gt;PLL1FEED  = 0xAA;
-  SC-&gt;PLL1FEED  = 0x55;
-  while (!(SC-&gt;PLL1STAT &amp; (1 &lt;&lt; 10)));  /* Wait for PLOCK1                    */
-
-  SC-&gt;PLL1CON   = 0x03;                 /* PLL1 Enable &amp; Connect              */
-  SC-&gt;PLL1FEED  = 0xAA;
-  SC-&gt;PLL1FEED  = 0x55;
-#endif
-#endif
-
-  /* Determine clock frequency according to clock register values             */
-  if (((SC-&gt;PLL0STAT &gt;&gt; 24) &amp; 3) == 3) {/* If PLL0 enabled and connected      */
-    switch (SC-&gt;CLKSRCSEL &amp; 0x03) {
-      case 0:                           /* Internal RC oscillator =&gt; PLL0     */
-      case 3:                           /* Reserved, default to Internal RC   */
-        SystemFrequency = (IRC_OSC *
-                          (((2 * ((SC-&gt;PLL0STAT &amp; 0x7FFF) + 1))) /
-                          (((SC-&gt;PLL0STAT &gt;&gt; 16) &amp; 0xFF) + 1))   /
-                          ((SC-&gt;CCLKCFG &amp; 0xFF)+ 1));
-        break;
-      case 1:                           /* Main oscillator =&gt; PLL0            */
-        SystemFrequency = (OSC_CLK *
-                          (((2 * ((SC-&gt;PLL0STAT &amp; 0x7FFF) + 1))) /
-                          (((SC-&gt;PLL0STAT &gt;&gt; 16) &amp; 0xFF) + 1))   /
-                          ((SC-&gt;CCLKCFG &amp; 0xFF)+ 1));
-        break;
-      case 2:                           /* RTC oscillator =&gt; PLL0             */
-        SystemFrequency = (RTC_CLK *
-                          (((2 * ((SC-&gt;PLL0STAT &amp; 0x7FFF) + 1))) /
-                          (((SC-&gt;PLL0STAT &gt;&gt; 16) &amp; 0xFF) + 1))   /
-                          ((SC-&gt;CCLKCFG &amp; 0xFF)+ 1));
-        break;
-    }
-  } else {
-    switch (SC-&gt;CLKSRCSEL &amp; 0x03) {
-      case 0:                           /* Internal RC oscillator =&gt; PLL0     */
-      case 3:                           /* Reserved, default to Internal RC   */
-        SystemFrequency = IRC_OSC / ((SC-&gt;CCLKCFG &amp; 0xFF)+ 1);
-        break;
-      case 1:                           /* Main oscillator =&gt; PLL0            */
-        SystemFrequency = OSC_CLK / ((SC-&gt;CCLKCFG &amp; 0xFF)+ 1);
-        break;
-      case 2:                           /* RTC oscillator =&gt; PLL0             */
-        SystemFrequency = RTC_CLK / ((SC-&gt;CCLKCFG &amp; 0xFF)+ 1);
-        break;
-    }
-  }
-
-#if (FLASH_SETUP == 1)                  /* Flash Accelerator Setup            */
-  SC-&gt;FLASHCFG  = FLASHCFG_Val;
-#endif
-}
-
-/**
- * @}
- */
-
-/* End Of File ---------------------------------------------------------------- */
+/**************************************************************************//**
+ * @file     system_LPC17xx.c
+ * @brief    CMSIS Cortex-M3 Device Peripheral Access Layer Source File
+ *           for the NXP LPC17xx Device Series
+ * @version  V1.03
+ * @date     07. October 2009
+ *
+ * @note
+ * Copyright (C) 2009 ARM Limited. All rights reserved.
+ *
+ * @par
+ * ARM Limited (ARM) is supplying this software for use with Cortex-M
+ * processor based microcontrollers.  This file can be freely distributed
+ * within development tools that are supporting such ARM based processors.
+ *
+ * @par
+ * THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+ * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+ * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+ * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+ *
+ ******************************************************************************/
+
+
+#include &lt;stdint.h&gt;
+#include &quot;LPC17xx.h&quot;
+
+/*
+//-------- &lt;&lt;&lt; Use Configuration Wizard in Context Menu &gt;&gt;&gt; ------------------
+*/
+
+/*--------------------- Clock Configuration ----------------------------------
+//
+// &lt;e&gt; Clock Configuration
+//   &lt;h&gt; System Controls and Status Register (SCS)
+//     &lt;o1.4&gt;    OSCRANGE: Main Oscillator Range Select
+//                     &lt;0=&gt;  1 MHz to 20 MHz
+//                     &lt;1=&gt; 15 MHz to 24 MHz
+//     &lt;e1.5&gt;       OSCEN: Main Oscillator Enable
+//     &lt;/e&gt;
+//   &lt;/h&gt;
+//
+//   &lt;h&gt; Clock Source Select Register (CLKSRCSEL)
+//     &lt;o2.0..1&gt;   CLKSRC: PLL Clock Source Selection
+//                     &lt;0=&gt; Internal RC oscillator
+//                     &lt;1=&gt; Main oscillator
+//                     &lt;2=&gt; RTC oscillator
+//   &lt;/h&gt;
+//
+//   &lt;e3&gt; PLL0 Configuration (Main PLL)
+//     &lt;h&gt; PLL0 Configuration Register (PLL0CFG)
+//                     &lt;i&gt; F_cco0 = (2 * M * F_in) / N
+//                     &lt;i&gt; F_in must be in the range of 32 kHz to 50 MHz
+//                     &lt;i&gt; F_cco0 must be in the range of 275 MHz to 550 MHz
+//       &lt;o4.0..14&gt;  MSEL: PLL Multiplier Selection
+//                     &lt;6-32768&gt;&lt;#-1&gt;
+//                     &lt;i&gt; M Value
+//       &lt;o4.16..23&gt; NSEL: PLL Divider Selection
+//                     &lt;1-256&gt;&lt;#-1&gt;
+//                     &lt;i&gt; N Value
+//     &lt;/h&gt;
+//   &lt;/e&gt;
+//
+//   &lt;e5&gt; PLL1 Configuration (USB PLL)
+//     &lt;h&gt; PLL1 Configuration Register (PLL1CFG)
+//                     &lt;i&gt; F_usb = M * F_osc or F_usb = F_cco1 / (2 * P)
+//                     &lt;i&gt; F_cco1 = F_osc * M * 2 * P
+//                     &lt;i&gt; F_cco1 must be in the range of 156 MHz to 320 MHz
+//       &lt;o6.0..4&gt;   MSEL: PLL Multiplier Selection
+//                     &lt;1-32&gt;&lt;#-1&gt;
+//                     &lt;i&gt; M Value (for USB maximum value is 4)
+//       &lt;o6.5..6&gt;   PSEL: PLL Divider Selection
+//                     &lt;0=&gt; 1
+//                     &lt;1=&gt; 2
+//                     &lt;2=&gt; 4
+//                     &lt;3=&gt; 8
+//                     &lt;i&gt; P Value
+//     &lt;/h&gt;
+//   &lt;/e&gt;
+//
+//   &lt;h&gt; CPU Clock Configuration Register (CCLKCFG)
+//     &lt;o7.0..7&gt;  CCLKSEL: Divide Value for CPU Clock from PLL0
+//                     &lt;3-256&gt;&lt;#-1&gt;
+//   &lt;/h&gt;
+//
+//   &lt;h&gt; USB Clock Configuration Register (USBCLKCFG)
+//     &lt;o8.0..3&gt;   USBSEL: Divide Value for USB Clock from PLL0
+//                     &lt;0-15&gt;
+//                     &lt;i&gt; Divide is USBSEL + 1
+//   &lt;/h&gt;
+//
+//   &lt;h&gt; Peripheral Clock Selection Register 0 (PCLKSEL0)
+//     &lt;o9.0..1&gt;    PCLK_WDT: Peripheral Clock Selection for WDT
+//                     &lt;0=&gt; Pclk = Cclk / 4
+//                     &lt;1=&gt; Pclk = Cclk
+//                     &lt;2=&gt; Pclk = Cclk / 2
+//                     &lt;3=&gt; Pclk = Hclk / 8
+//     &lt;o9.2..3&gt;    PCLK_TIMER0: Peripheral Clock Selection for TIMER0
+//                     &lt;0=&gt; Pclk = Cclk / 4
+//                     &lt;1=&gt; Pclk = Cclk
+//                     &lt;2=&gt; Pclk = Cclk / 2
+//                     &lt;3=&gt; Pclk = Hclk / 8
+//     &lt;o9.4..5&gt;    PCLK_TIMER1: Peripheral Clock Selection for TIMER1
+//                     &lt;0=&gt; Pclk = Cclk / 4
+//                     &lt;1=&gt; Pclk = Cclk
+//                     &lt;2=&gt; Pclk = Cclk / 2
+//                     &lt;3=&gt; Pclk = Hclk / 8
+//     &lt;o9.6..7&gt;    PCLK_UART0: Peripheral Clock Selection for UART0
+//                     &lt;0=&gt; Pclk = Cclk / 4
+//                     &lt;1=&gt; Pclk = Cclk
+//                     &lt;2=&gt; Pclk = Cclk / 2
+//                     &lt;3=&gt; Pclk = Hclk / 8
+//     &lt;o9.8..9&gt;    PCLK_UART1: Peripheral Clock Selection for UART1
+//                     &lt;0=&gt; Pclk = Cclk / 4
+//                     &lt;1=&gt; Pclk = Cclk
+//                     &lt;2=&gt; Pclk = Cclk / 2
+//                     &lt;3=&gt; Pclk = Hclk / 8
+//     &lt;o9.12..13&gt;  PCLK_PWM1: Peripheral Clock Selection for PWM1
+//                     &lt;0=&gt; Pclk = Cclk / 4
+//                     &lt;1=&gt; Pclk = Cclk
+//                     &lt;2=&gt; Pclk = Cclk / 2
+//                     &lt;3=&gt; Pclk = Hclk / 8
+//     &lt;o9.14..15&gt;  PCLK_I2C0: Peripheral Clock Selection for I2C0
+//                     &lt;0=&gt; Pclk = Cclk / 4
+//                     &lt;1=&gt; Pclk = Cclk
+//                     &lt;2=&gt; Pclk = Cclk / 2
+//                     &lt;3=&gt; Pclk = Hclk / 8
+//     &lt;o9.16..17&gt;  PCLK_SPI: Peripheral Clock Selection for SPI
+//                     &lt;0=&gt; Pclk = Cclk / 4
+//                     &lt;1=&gt; Pclk = Cclk
+//                     &lt;2=&gt; Pclk = Cclk / 2
+//                     &lt;3=&gt; Pclk = Hclk / 8
+//     &lt;o9.20..21&gt;  PCLK_SSP1: Peripheral Clock Selection for SSP1
+//                     &lt;0=&gt; Pclk = Cclk / 4
+//                     &lt;1=&gt; Pclk = Cclk
+//                     &lt;2=&gt; Pclk = Cclk / 2
+//                     &lt;3=&gt; Pclk = Hclk / 8
+//     &lt;o9.22..23&gt;  PCLK_DAC: Peripheral Clock Selection for DAC
+//                     &lt;0=&gt; Pclk = Cclk / 4
+//                     &lt;1=&gt; Pclk = Cclk
+//                     &lt;2=&gt; Pclk = Cclk / 2
+//                     &lt;3=&gt; Pclk = Hclk / 8
+//     &lt;o9.24..25&gt;  PCLK_ADC: Peripheral Clock Selection for ADC
+//                     &lt;0=&gt; Pclk = Cclk / 4
+//                     &lt;1=&gt; Pclk = Cclk
+//                     &lt;2=&gt; Pclk = Cclk / 2
+//                     &lt;3=&gt; Pclk = Hclk / 8
+//     &lt;o9.26..27&gt;  PCLK_CAN1: Peripheral Clock Selection for CAN1
+//                     &lt;0=&gt; Pclk = Cclk / 4
+//                     &lt;1=&gt; Pclk = Cclk
+//                     &lt;2=&gt; Pclk = Cclk / 2
+//                     &lt;3=&gt; Pclk = Hclk / 6
+//     &lt;o9.28..29&gt;  PCLK_CAN2: Peripheral Clock Selection for CAN2
+//                     &lt;0=&gt; Pclk = Cclk / 4
+//                     &lt;1=&gt; Pclk = Cclk
+//                     &lt;2=&gt; Pclk = Cclk / 2
+//                     &lt;3=&gt; Pclk = Hclk / 6
+//     &lt;o9.30..31&gt;  PCLK_ACF: Peripheral Clock Selection for ACF
+//                     &lt;0=&gt; Pclk = Cclk / 4
+//                     &lt;1=&gt; Pclk = Cclk
+//                     &lt;2=&gt; Pclk = Cclk / 2
+//                     &lt;3=&gt; Pclk = Hclk / 6
+//   &lt;/h&gt;
+//
+//   &lt;h&gt; Peripheral Clock Selection Register 1 (PCLKSEL1)
+//     &lt;o10.0..1&gt;   PCLK_QEI: Peripheral Clock Selection for the Quadrature Encoder Interface
+//                     &lt;0=&gt; Pclk = Cclk / 4
+//                     &lt;1=&gt; Pclk = Cclk
+//                     &lt;2=&gt; Pclk = Cclk / 2
+//                     &lt;3=&gt; Pclk = Hclk / 8
+//     &lt;o10.2..3&gt;   PCLK_GPIO: Peripheral Clock Selection for GPIOs
+//                     &lt;0=&gt; Pclk = Cclk / 4
+//                     &lt;1=&gt; Pclk = Cclk
+//                     &lt;2=&gt; Pclk = Cclk / 2
+//                     &lt;3=&gt; Pclk = Hclk / 8
+//     &lt;o10.4..5&gt;   PCLK_PCB: Peripheral Clock Selection for the Pin Connect Block
+//                     &lt;0=&gt; Pclk = Cclk / 4
+//                     &lt;1=&gt; Pclk = Cclk
+//                     &lt;2=&gt; Pclk = Cclk / 2
+//                     &lt;3=&gt; Pclk = Hclk / 8
+//     &lt;o10.6..7&gt;   PCLK_I2C1: Peripheral Clock Selection for I2C1
+//                     &lt;0=&gt; Pclk = Cclk / 4
+//                     &lt;1=&gt; Pclk = Cclk
+//                     &lt;2=&gt; Pclk = Cclk / 2
+//                     &lt;3=&gt; Pclk = Hclk / 8
+//     &lt;o10.10..11&gt; PCLK_SSP0: Peripheral Clock Selection for SSP0
+//                     &lt;0=&gt; Pclk = Cclk / 4
+//                     &lt;1=&gt; Pclk = Cclk
+//                     &lt;2=&gt; Pclk = Cclk / 2
+//                     &lt;3=&gt; Pclk = Hclk / 8
+//     &lt;o10.12..13&gt; PCLK_TIMER2: Peripheral Clock Selection for TIMER2
+//                     &lt;0=&gt; Pclk = Cclk / 4
+//                     &lt;1=&gt; Pclk = Cclk
+//                     &lt;2=&gt; Pclk = Cclk / 2
+//                     &lt;3=&gt; Pclk = Hclk / 8
+//     &lt;o10.14..15&gt; PCLK_TIMER3: Peripheral Clock Selection for TIMER3
+//                     &lt;0=&gt; Pclk = Cclk / 4
+//                     &lt;1=&gt; Pclk = Cclk
+//                     &lt;2=&gt; Pclk = Cclk / 2
+//                     &lt;3=&gt; Pclk = Hclk / 8
+//     &lt;o10.16..17&gt; PCLK_UART2: Peripheral Clock Selection for UART2
+//                     &lt;0=&gt; Pclk = Cclk / 4
+//                     &lt;1=&gt; Pclk = Cclk
+//                     &lt;2=&gt; Pclk = Cclk / 2
+//                     &lt;3=&gt; Pclk = Hclk / 8
+//     &lt;o10.18..19&gt; PCLK_UART3: Peripheral Clock Selection for UART3
+//                     &lt;0=&gt; Pclk = Cclk / 4
+//                     &lt;1=&gt; Pclk = Cclk
+//                     &lt;2=&gt; Pclk = Cclk / 2
+//                     &lt;3=&gt; Pclk = Hclk / 8
+//     &lt;o10.20..21&gt; PCLK_I2C2: Peripheral Clock Selection for I2C2
+//                     &lt;0=&gt; Pclk = Cclk / 4
+//                     &lt;1=&gt; Pclk = Cclk
+//                     &lt;2=&gt; Pclk = Cclk / 2
+//                     &lt;3=&gt; Pclk = Hclk / 8
+//     &lt;o10.22..23&gt; PCLK_I2S: Peripheral Clock Selection for I2S
+//                     &lt;0=&gt; Pclk = Cclk / 4
+//                     &lt;1=&gt; Pclk = Cclk
+//                     &lt;2=&gt; Pclk = Cclk / 2
+//                     &lt;3=&gt; Pclk = Hclk / 8
+//     &lt;o10.26..27&gt; PCLK_RIT: Peripheral Clock Selection for the Repetitive Interrupt Timer
+//                     &lt;0=&gt; Pclk = Cclk / 4
+//                     &lt;1=&gt; Pclk = Cclk
+//                     &lt;2=&gt; Pclk = Cclk / 2
+//                     &lt;3=&gt; Pclk = Hclk / 8
+//     &lt;o10.28..29&gt; PCLK_SYSCON: Peripheral Clock Selection for the System Control Block
+//                     &lt;0=&gt; Pclk = Cclk / 4
+//                     &lt;1=&gt; Pclk = Cclk
+//                     &lt;2=&gt; Pclk = Cclk / 2
+//                     &lt;3=&gt; Pclk = Hclk / 8
+//     &lt;o10.30..31&gt; PCLK_MC: Peripheral Clock Selection for the Motor Control PWM
+//                     &lt;0=&gt; Pclk = Cclk / 4
+//                     &lt;1=&gt; Pclk = Cclk
+//                     &lt;2=&gt; Pclk = Cclk / 2
+//                     &lt;3=&gt; Pclk = Hclk / 8
+//   &lt;/h&gt;
+//
+//   &lt;h&gt; Power Control for Peripherals Register (PCONP)
+//     &lt;o11.1&gt;      PCTIM0: Timer/Counter 0 power/clock enable
+//     &lt;o11.2&gt;      PCTIM1: Timer/Counter 1 power/clock enable
+//     &lt;o11.3&gt;      PCUART0: UART 0 power/clock enable
+//     &lt;o11.4&gt;      PCUART1: UART 1 power/clock enable
+//     &lt;o11.6&gt;      PCPWM1: PWM 1 power/clock enable
+//     &lt;o11.7&gt;      PCI2C0: I2C interface 0 power/clock enable
+//     &lt;o11.8&gt;      PCSPI: SPI interface power/clock enable
+//     &lt;o11.9&gt;      PCRTC: RTC power/clock enable
+//     &lt;o11.10&gt;     PCSSP1: SSP interface 1 power/clock enable
+//     &lt;o11.12&gt;     PCAD: A/D converter power/clock enable
+//     &lt;o11.13&gt;     PCCAN1: CAN controller 1 power/clock enable
+//     &lt;o11.14&gt;     PCCAN2: CAN controller 2 power/clock enable
+//     &lt;o11.15&gt;     PCGPIO: GPIOs power/clock enable
+//     &lt;o11.16&gt;     PCRIT: Repetitive interrupt timer power/clock enable
+//     &lt;o11.17&gt;     PCMC: Motor control PWM power/clock enable
+//     &lt;o11.18&gt;     PCQEI: Quadrature encoder interface power/clock enable
+//     &lt;o11.19&gt;     PCI2C1: I2C interface 1 power/clock enable
+//     &lt;o11.21&gt;     PCSSP0: SSP interface 0 power/clock enable
+//     &lt;o11.22&gt;     PCTIM2: Timer 2 power/clock enable
+//     &lt;o11.23&gt;     PCTIM3: Timer 3 power/clock enable
+//     &lt;o11.24&gt;     PCUART2: UART 2 power/clock enable
+//     &lt;o11.25&gt;     PCUART3: UART 3 power/clock enable
+//     &lt;o11.26&gt;     PCI2C2: I2C interface 2 power/clock enable
+//     &lt;o11.27&gt;     PCI2S: I2S interface power/clock enable
+//     &lt;o11.29&gt;     PCGPDMA: GP DMA function power/clock enable
+//     &lt;o11.30&gt;     PCENET: Ethernet block power/clock enable
+//     &lt;o11.31&gt;     PCUSB: USB interface power/clock enable
+//   &lt;/h&gt;
+//
+//   &lt;h&gt; Clock Output Configuration Register (CLKOUTCFG)
+//     &lt;o12.0..3&gt;   CLKOUTSEL: Selects clock source for CLKOUT
+//                     &lt;0=&gt; CPU clock
+//                     &lt;1=&gt; Main oscillator
+//                     &lt;2=&gt; Internal RC oscillator
+//                     &lt;3=&gt; USB clock
+//                     &lt;4=&gt; RTC oscillator
+//     &lt;o12.4..7&gt;   CLKOUTDIV: Selects clock divider for CLKOUT
+//                     &lt;1-16&gt;&lt;#-1&gt;
+//     &lt;o12.8&gt;      CLKOUT_EN: CLKOUT enable control
+//   &lt;/h&gt;
+//
+// &lt;/e&gt;
+*/
+#define CLOCK_SETUP           1
+#define SCS_Val               0x00000020
+#define CLKSRCSEL_Val         0x00000001
+#define PLL0_SETUP            1
+#define PLL0CFG_Val           0x00050063
+#define PLL1_SETUP            1
+#define PLL1CFG_Val           0x00000023
+#define CCLKCFG_Val           0x00000003
+#define USBCLKCFG_Val         0x00000000
+#define PCLKSEL0_Val          0x00000000
+#define PCLKSEL1_Val          0x00000000
+#define PCONP_Val             0x042887DE
+#define CLKOUTCFG_Val         0x00000000
+
+
+/*--------------------- Flash Accelerator Configuration ----------------------
+//
+// &lt;e&gt; Flash Accelerator Configuration
+//   &lt;o1.0..11&gt;  Reserved
+//   &lt;o1.12..15&gt; FLASHTIM: Flash Access Time
+//               &lt;0=&gt; 1 CPU clock (for CPU clock up to 20 MHz)
+//               &lt;1=&gt; 2 CPU clocks (for CPU clock up to 40 MHz)
+//               &lt;2=&gt; 3 CPU clocks (for CPU clock up to 60 MHz)
+//               &lt;3=&gt; 4 CPU clocks (for CPU clock up to 80 MHz)
+//               &lt;4=&gt; 5 CPU clocks (for CPU clock up to 100 MHz)
+//               &lt;5=&gt; 6 CPU clocks (for any CPU clock)
+// &lt;/e&gt;
+*/
+#define FLASH_SETUP           1
+#define FLASHCFG_Val          0x0000303A
+
+/*
+//-------- &lt;&lt;&lt; end of configuration section &gt;&gt;&gt; ------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+  Check the register settings
+ *----------------------------------------------------------------------------*/
+#define CHECK_RANGE(val, min, max)                ((val &lt; min) || (val &gt; max))
+#define CHECK_RSVD(val, mask)                     (val &amp; mask)
+
+/* Clock Configuration -------------------------------------------------------*/
+#if (CHECK_RSVD((SCS_Val),       ~0x00000030))
+   #error &quot;SCS: Invalid values of reserved bits!&quot;
+#endif
+
+#if (CHECK_RANGE((CLKSRCSEL_Val), 0, 2))
+   #error &quot;CLKSRCSEL: Value out of range!&quot;
+#endif
+
+#if (CHECK_RSVD((PLL0CFG_Val),   ~0x00FF7FFF))
+   #error &quot;PLL0CFG: Invalid values of reserved bits!&quot;
+#endif
+
+#if (CHECK_RSVD((PLL1CFG_Val),   ~0x0000007F))
+   #error &quot;PLL1CFG: Invalid values of reserved bits!&quot;
+#endif
+
+#if ((CCLKCFG_Val != 0) &amp;&amp; (((CCLKCFG_Val - 1) % 2)))
+   #error &quot;CCLKCFG: CCLKSEL field does not contain only odd values or 0!&quot;
+#endif
+
+#if (CHECK_RSVD((USBCLKCFG_Val), ~0x0000000F))
+   #error &quot;USBCLKCFG: Invalid values of reserved bits!&quot;
+#endif
+
+#if (CHECK_RSVD((PCLKSEL0_Val),   0x000C0C00))
+   #error &quot;PCLKSEL0: Invalid values of reserved bits!&quot;
+#endif
+
+#if (CHECK_RSVD((PCLKSEL1_Val),   0x03000300))
+   #error &quot;PCLKSEL1: Invalid values of reserved bits!&quot;
+#endif
+
+#if (CHECK_RSVD((PCONP_Val),      0x10100821))
+   #error &quot;PCONP: Invalid values of reserved bits!&quot;
+#endif
+
+#if (CHECK_RSVD((CLKOUTCFG_Val), ~0x000001FF))
+   #error &quot;CLKOUTCFG: Invalid values of reserved bits!&quot;
+#endif
+
+/* Flash Accelerator Configuration -------------------------------------------*/
+#if (CHECK_RSVD((FLASHCFG_Val), ~0x0000F07F))
+   #error &quot;FLASHCFG: Invalid values of reserved bits!&quot;
+#endif
+
+
+/*----------------------------------------------------------------------------
+  DEFINES
+ *----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+  Define clocks
+ *----------------------------------------------------------------------------*/
+#define XTAL        (12000000UL)        /* Oscillator frequency               */
+#define OSC_CLK     (      XTAL)        /* Main oscillator frequency          */
+#define RTC_CLK     (   32000UL)        /* RTC oscillator frequency           */
+#define IRC_OSC     ( 4000000UL)        /* Internal RC oscillator frequency   */
+
+
+/* F_cco0 = (2 * M * F_in) / N  */
+#define __M               (((PLL0CFG_Val      ) &amp; 0x7FFF) + 1)
+#define __N               (((PLL0CFG_Val &gt;&gt; 16) &amp; 0x00FF) + 1)
+#define __FCCO(__F_IN)    ((2 * __M * __F_IN) / __N)
+#define __CCLK_DIV        (((CCLKCFG_Val      ) &amp; 0x00FF) + 1)
+
+/* Determine core clock frequency according to settings */
+ #if (PLL0_SETUP)
+    #if   ((CLKSRCSEL_Val &amp; 0x03) == 1)
+        #define __CORE_CLK (__FCCO(OSC_CLK) / __CCLK_DIV)
+    #elif ((CLKSRCSEL_Val &amp; 0x03) == 2)
+        #define __CORE_CLK (__FCCO(RTC_CLK) / __CCLK_DIV)
+    #else
+        #define __CORE_CLK (__FCCO(IRC_OSC) / __CCLK_DIV)
+    #endif
+ #else
+    #if   ((CLKSRCSEL_Val &amp; 0x03) == 1)
+        #define __CORE_CLK (OSC_CLK         / __CCLK_DIV)
+    #elif ((CLKSRCSEL_Val &amp; 0x03) == 2)
+        #define __CORE_CLK (RTC_CLK         / __CCLK_DIV)
+    #else
+        #define __CORE_CLK (IRC_OSC         / __CCLK_DIV)
+    #endif
+ #endif
+
+
+/*----------------------------------------------------------------------------
+  Clock Variable definitions
+ *----------------------------------------------------------------------------*/
+uint32_t SystemCoreClock = __CORE_CLK;/*!&lt; System Clock Frequency (Core Clock)*/
+
+
+/*----------------------------------------------------------------------------
+  Clock functions
+ *----------------------------------------------------------------------------*/
+void SystemCoreClockUpdate (void)            /* Get Core Clock Frequency      */
+{
+  /* Determine clock frequency according to clock register values             */
+  if (((LPC_SC-&gt;PLL0STAT &gt;&gt; 24) &amp; 3) == 3) { /* If PLL0 enabled and connected */
+    switch (LPC_SC-&gt;CLKSRCSEL &amp; 0x03) {
+      case 0:                                /* Int. RC oscillator =&gt; PLL0    */
+      case 3:                                /* Reserved, default to Int. RC  */
+        SystemCoreClock = (IRC_OSC *
+                          ((2 * ((LPC_SC-&gt;PLL0STAT &amp; 0x7FFF) + 1)))  /
+                          (((LPC_SC-&gt;PLL0STAT &gt;&gt; 16) &amp; 0xFF) + 1)    /
+                          ((LPC_SC-&gt;CCLKCFG &amp; 0xFF)+ 1));
+        break;
+      case 1:                                /* Main oscillator =&gt; PLL0       */
+        SystemCoreClock = (OSC_CLK *
+                          ((2 * ((LPC_SC-&gt;PLL0STAT &amp; 0x7FFF) + 1)))  /
+                          (((LPC_SC-&gt;PLL0STAT &gt;&gt; 16) &amp; 0xFF) + 1)    /
+                          ((LPC_SC-&gt;CCLKCFG &amp; 0xFF)+ 1));
+        break;
+      case 2:                                /* RTC oscillator =&gt; PLL0        */
+        SystemCoreClock = (RTC_CLK *
+                          ((2 * ((LPC_SC-&gt;PLL0STAT &amp; 0x7FFF) + 1)))  /
+                          (((LPC_SC-&gt;PLL0STAT &gt;&gt; 16) &amp; 0xFF) + 1)    /
+                          ((LPC_SC-&gt;CCLKCFG &amp; 0xFF)+ 1));
+        break;
+    }
+  } else {
+    switch (LPC_SC-&gt;CLKSRCSEL &amp; 0x03) {
+      case 0:                                /* Int. RC oscillator =&gt; PLL0    */
+      case 3:                                /* Reserved, default to Int. RC  */
+        SystemCoreClock = IRC_OSC / ((LPC_SC-&gt;CCLKCFG &amp; 0xFF)+ 1);
+        break;
+      case 1:                                /* Main oscillator =&gt; PLL0       */
+        SystemCoreClock = OSC_CLK / ((LPC_SC-&gt;CCLKCFG &amp; 0xFF)+ 1);
+        break;
+      case 2:                                /* RTC oscillator =&gt; PLL0        */
+        SystemCoreClock = RTC_CLK / ((LPC_SC-&gt;CCLKCFG &amp; 0xFF)+ 1);
+        break;
+    }
+  }
+
+}
+/* Exported types --------------------------------------------------------------*/
+/* Exported constants --------------------------------------------------------*/
+//extern unsigned long _sidata;		/* start address for the initialization values of the .data section. defined in linker script */
+//extern unsigned long _sdata;		/* start address for the .data section. defined in linker script */
+//extern unsigned long _edata;		/* end address for the .data section. defined in linker script */
+//
+//extern unsigned long _sbss;			/* start address for the .bss section. defined in linker script */
+//extern unsigned long _ebss;			/* end address for the .bss section. defined in linker script */
+
+//void _init(void)
+//{
+//    unsigned long *pulSrc, *pulDest;
+//
+//    //
+//    // Copy the data segment initializers from flash to SRAM in ROM mode
+//    //
+//#if (__RAM_MODE__==0)
+//    pulSrc = &amp;_sidata;
+//    for(pulDest = &amp;_sdata; pulDest &lt; &amp;_edata; )
+//    {
+//        *(pulDest++) = *(pulSrc++);
+//    }
+//#endif
+//
+//
+//    //
+//    // Zero fill the bss segment.
+//    //
+//    for(pulDest = &amp;_sbss; pulDest &lt; &amp;_ebss; )
+//    {
+//        *(pulDest++) = 0;
+//    }
+//}
+
+/**
+ * Initialize the system
+ *
+ * @param  none
+ * @return none
+ *
+ * @brief  Setup the microcontroller system.
+ *         Initialize the System.
+ */
+void SystemInit (void)
+{
+
+#if (CLOCK_SETUP)                       /* Clock Setup                        */
+  LPC_SC-&gt;SCS       = SCS_Val;
+  if (SCS_Val &amp; (1 &lt;&lt; 5)) {             /* If Main Oscillator is enabled      */
+    while ((LPC_SC-&gt;SCS &amp; (1&lt;&lt;6)) == 0);/* Wait for Oscillator to be ready    */
+  }
+
+  LPC_SC-&gt;CCLKCFG   = CCLKCFG_Val;      /* Setup Clock Divider                */
+  LPC_SC-&gt;PCLKSEL0  = PCLKSEL0_Val;     /* Peripheral Clock Selection         */
+  LPC_SC-&gt;PCLKSEL1  = PCLKSEL1_Val;
+
+#if (PLL0_SETUP)
+  LPC_SC-&gt;CLKSRCSEL = CLKSRCSEL_Val;    /* Select Clock Source for PLL0       */
+
+  LPC_SC-&gt;PLL0CFG   = PLL0CFG_Val;      /* configure PLL0                     */
+  LPC_SC-&gt;PLL0FEED  = 0xAA;
+  LPC_SC-&gt;PLL0FEED  = 0x55;
+
+  LPC_SC-&gt;PLL0CON   = 0x01;             /* PLL0 Enable                        */
+  LPC_SC-&gt;PLL0FEED  = 0xAA;
+  LPC_SC-&gt;PLL0FEED  = 0x55;
+  while (!(LPC_SC-&gt;PLL0STAT &amp; (1&lt;&lt;26)));/* Wait for PLOCK0                    */
+
+  LPC_SC-&gt;PLL0CON   = 0x03;             /* PLL0 Enable &amp; Connect              */
+  LPC_SC-&gt;PLL0FEED  = 0xAA;
+  LPC_SC-&gt;PLL0FEED  = 0x55;
+  while (!(LPC_SC-&gt;PLL0STAT &amp; ((1&lt;&lt;25) | (1&lt;&lt;24))));/* Wait for PLLC0_STAT &amp; PLLE0_STAT */
+#endif
+
+#if (PLL1_SETUP)
+  LPC_SC-&gt;PLL1CFG   = PLL1CFG_Val;
+  LPC_SC-&gt;PLL1FEED  = 0xAA;
+  LPC_SC-&gt;PLL1FEED  = 0x55;
+
+  LPC_SC-&gt;PLL1CON   = 0x01;             /* PLL1 Enable                        */
+  LPC_SC-&gt;PLL1FEED  = 0xAA;
+  LPC_SC-&gt;PLL1FEED  = 0x55;
+  while (!(LPC_SC-&gt;PLL1STAT &amp; (1&lt;&lt;10)));/* Wait for PLOCK1                    */
+
+  LPC_SC-&gt;PLL1CON   = 0x03;             /* PLL1 Enable &amp; Connect              */
+  LPC_SC-&gt;PLL1FEED  = 0xAA;
+  LPC_SC-&gt;PLL1FEED  = 0x55;
+  while (!(LPC_SC-&gt;PLL1STAT &amp; ((1&lt;&lt; 9) | (1&lt;&lt; 8))));/* Wait for PLLC1_STAT &amp; PLLE1_STAT */
+#else
+  LPC_SC-&gt;USBCLKCFG = USBCLKCFG_Val;    /* Setup USB Clock Divider            */
+#endif
+  LPC_SC-&gt;PCONP     = PCONP_Val;        /* Power Control for Peripherals      */
+
+  LPC_SC-&gt;CLKOUTCFG = CLKOUTCFG_Val;    /* Clock Output Configuration         */
+#endif
+
+#if (FLASH_SETUP == 1)                  /* Flash Accelerator Setup            */
+  LPC_SC-&gt;FLASHCFG  = FLASHCFG_Val;
+#endif
+}


Property changes on: trunk/src/platform/lpc17xx/system_LPC17xx.c
___________________________________________________________________
Deleted: svn:executable
   - *

Modified: trunk/src/platform/lpc17xx/system_LPC17xx.h
===================================================================
--- trunk/src/platform/lpc17xx/system_LPC17xx.h	2010-06-28 21:53:59 UTC (rev 759)
+++ trunk/src/platform/lpc17xx/system_LPC17xx.h	2010-07-12 20:56:54 UTC (rev 760)
@@ -1,40 +1,63 @@
-/****************************************************************************//**
- * @file :    system_LPC17xx.h
- * @brief : CMSIS Cortex-M3 Device Peripheral Access Layer Header File
- *           for the NXP LPC17xx Device Series 
- * @version : V1.0
- * @date :    25. Nov. 2008
- *----------------------------------------------------------------------------
- *
- * Copyright (C) 2008 ARM Limited. All rights reserved.
- *
- * ARM Limited (ARM) is supplying this software for use with Cortex-M3 
- * processor based microcontrollers.  This file can be freely distributed 
- * within development tools that are supporting such ARM based processors. 
- *
- * THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
- * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
- * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
- * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
- *
- ******************************************************************************/
-
-
-#ifndef __SYSTEM_LPC17xx_H
-#define __SYSTEM_LPC17xx_H
-
-extern uint32_t SystemFrequency;    /*!&lt; System Clock Frequency (Core Clock)  */
-
-
-/**
- * Initialize the system
- *
- * @param  none
- * @return none
- *
- * @brief  Setup the microcontroller system.
- *         Initialize the System and update the SystemFrequency variable.
- */
-extern void SystemInit (void);
-#endif
+/**************************************************************************//**
+ * @file     system_LPC17xx.h
+ * @brief    CMSIS Cortex-M3 Device Peripheral Access Layer Header File
+ *           for the NXP LPC17xx Device Series
+ * @version  V1.02
+ * @date     08. September 2009
+ *
+ * @note
+ * Copyright (C) 2009 ARM Limited. All rights reserved.
+ *
+ * @par
+ * ARM Limited (ARM) is supplying this software for use with Cortex-M
+ * processor based microcontrollers.  This file can be freely distributed
+ * within development tools that are supporting such ARM based processors.
+ *
+ * @par
+ * THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+ * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+ * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+ * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+ *
+ ******************************************************************************/
+
+
+#ifndef __SYSTEM_LPC17xx_H
+#define __SYSTEM_LPC17xx_H
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+#include &lt;stdint.h&gt;
+
+extern uint32_t SystemCoreClock;     /*!&lt; System Clock Frequency (Core Clock)  */
+
+
+/**
+ * Initialize the system
+ *
+ * @param  none
+ * @return none
+ *
+ * @brief  Setup the microcontroller system.
+ *         Initialize the System and update the SystemCoreClock variable.
+ */
+extern void SystemInit (void);
+
+/**
+ * Update SystemCoreClock variable
+ *
+ * @param  none
+ * @return none
+ *
+ * @brief  Updates the SystemCoreClock with current core Clock
+ *         retrieved from cpu registers.
+ */
+extern void SystemCoreClockUpdate (void);
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __SYSTEM_LPC17xx_H */


Property changes on: trunk/src/platform/lpc17xx/system_LPC17xx.h
___________________________________________________________________
Deleted: svn:executable
   - *


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	
	<LI>Next message: <A HREF="000714.html">[Elua-svn] r761 - trunk/doc
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#713">[ date ]</a>
              <a href="thread.html#713">[ thread ]</a>
              <a href="subject.html#713">[ subject ]</a>
              <a href="author.html#713">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/elua-svn">More information about the eLua-svn
mailing list</a><br>
</body></html>
