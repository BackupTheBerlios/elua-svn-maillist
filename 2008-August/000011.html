<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Elua-svn] r54 - in trunk: . inc src src/newlib
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/elua-svn/2008-August/index.html" >
   <LINK REL="made" HREF="mailto:elua-svn%40lists.berlios.de?Subject=Re%3A%20%5BElua-svn%5D%20r54%20-%20in%20trunk%3A%20.%20inc%20src%20src/newlib&In-Reply-To=%3C200808161550.m7GFoHPv015912%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000008.html">
   <LINK REL="Next"  HREF="000010.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Elua-svn] r54 - in trunk: . inc src src/newlib</H1>
    <B>bogdanm at BerliOS</B> 
    <A HREF="mailto:elua-svn%40lists.berlios.de?Subject=Re%3A%20%5BElua-svn%5D%20r54%20-%20in%20trunk%3A%20.%20inc%20src%20src/newlib&In-Reply-To=%3C200808161550.m7GFoHPv015912%40sheep.berlios.de%3E"
       TITLE="[Elua-svn] r54 - in trunk: . inc src src/newlib">bogdanm at mail.berlios.de
       </A><BR>
    <I>Sat Aug 16 17:50:17 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000008.html">[Elua-svn] r44 - tags
</A></li>
        <LI>Next message: <A HREF="000010.html">[Elua-svn] r55 - in trunk: . inc src src/newlib
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11">[ date ]</a>
              <a href="thread.html#11">[ thread ]</a>
              <a href="subject.html#11">[ subject ]</a>
              <a href="author.html#11">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: bogdanm
Date: 2008-08-16 17:50:16 +0200 (Sat, 16 Aug 2008)
New Revision: 54

Removed:
   trunk/inc/tlsf.h
   trunk/src/tlsf.c
Modified:
   trunk/SConstruct
   trunk/src/main.c
   trunk/src/newlib/stubs.c
   trunk/src/shell.c
Log:
Tried two different TLSF implementations, none of them works properly. Will try to 
use a different dlmalloc version for multiple memory spaces. In any case, TLSF is
OUT.



Modified: trunk/SConstruct
===================================================================
--- trunk/SConstruct	2008-08-14 07:39:29 UTC (rev 53)
+++ trunk/SConstruct	2008-08-16 15:50:16 UTC (rev 54)
@@ -1,7 +1,6 @@
 import os, sys 
 target = ARGUMENTS.get( 'target', 'lua' ).lower() 
 cputype = ARGUMENTS.get( 'cpu', 'at91sam7x256' ).lower()
-allocator = ARGUMENTS.get( 'allocator', '' ).lower()
 
 # List of platform/CPU combinations
 cpu_list = { 'at91sam7x' : [ 'at91sam7x256', 'at91sam7x512' ], 
@@ -11,13 +10,6 @@
               'lpc288x' : [ 'lpc2888' ]
             }
 
-# CPU -&gt; allocator mapping (if an allocator is not specified)
-if allocator == '':
-  if cputype in [ 'lpc2888' ]:
-    allocator = 'tlsf'
-  else:
-    allocator = 'newlib'
-            
 platform = None        
 # Look for the given CPU in the list of platforms            
 for p, v in cpu_list.items():
@@ -36,8 +28,6 @@
     
 output = 'elua_' + target + '_' + cputype 
 cdefs = '-D%s' % cputype
-if allocator == 'tlsf':
-  cdefs = cdefs + ' -DUSE_TLSF'
 
 # Lua source files and include path
 lua_files = &quot;&quot;&quot;lapi.c lcode.c ldebug.c ldo.c ldump.c lfunc.c lgc.c llex.c lmem.c lobject.c lopcodes.c
@@ -59,7 +49,7 @@
 local_libs = ''
   
 # Application files
-app_files = &quot; src/romfs.c src/main.c src/xmodem.c src/shell.c src/term.c src/tlsf.c&quot;
+app_files = &quot; src/romfs.c src/main.c src/xmodem.c src/shell.c src/term.c&quot;
   
 # Newlib related files  
 newlib_files = &quot; src/newlib/devman.c src/newlib/stubs.c src/newlib/genstd.c&quot;

Deleted: trunk/inc/tlsf.h
===================================================================
--- trunk/inc/tlsf.h	2008-08-14 07:39:29 UTC (rev 53)
+++ trunk/inc/tlsf.h	2008-08-16 15:50:16 UTC (rev 54)
@@ -1,44 +0,0 @@
-/*
- * Two Levels Segregate Fit memory allocator (TLSF)
- * Version 2.4.3
- *
- * Written by Miguel Masmano Tello &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">mimastel at doctor.upv.es</A>&gt;
- *
- * Thanks to Ismael Ripoll for his suggestions and reviews
- *
- * Copyright (C) 2008, 2007, 2006, 2005, 2004
- *
- * This code is released using a dual license strategy: GPL/LGPL
- * You can choose the licence that better fits your requirements.
- *
- * Released under the terms of the GNU General Public License Version 2.0
- * Released under the terms of the GNU Lesser General Public License Version 2.1
- *
- */
-
-#ifndef _TLSF_H_
-#define _TLSF_H_
-
-#include &lt;sys/types.h&gt;
-
-extern size_t init_memory_pool(size_t, void *);
-extern size_t get_used_size(void *);
-extern size_t get_max_size(void *);
-extern void destroy_memory_pool(void *);
-extern size_t add_new_area(void *, size_t, void *);
-extern void *malloc_ex(size_t, void *);
-extern void free_ex(void *, void *);
-extern void *realloc_ex(void *, size_t, void *);
-extern void *calloc_ex(size_t, size_t, void *);
-
-extern void *tlsf_malloc(size_t size);
-extern void tlsf_free(void *ptr);
-extern void *tlsf_realloc(void *ptr, size_t size);
-extern void *tlsf_calloc(size_t nelem, size_t elem_size);
-
-// BogdanM - added for eLua
-void tlsf_elua_init();
-size_t tlsf_elua_get_block_size( void* ptr );
-void* tlsf_elua_align_addr( void* ptr );
-
-#endif

Modified: trunk/src/main.c
===================================================================
--- trunk/src/main.c	2008-08-14 07:39:29 UTC (rev 53)
+++ trunk/src/main.c	2008-08-16 15:50:16 UTC (rev 54)
@@ -11,7 +11,6 @@
 #include &quot;build.h&quot;
 #include &quot;lua.h&quot;
 #include &quot;term.h&quot;
-#include &quot;tlsf.h&quot;
 
 extern char etext[];
 
@@ -164,10 +163,6 @@
     while( 1 );
   }
   
-  // Initialize the TLSF allocator 
-  // (if TLSF is not used, the next function does nothing)
-  tlsf_elua_init();
-    
   // Initialize device manager
   dm_init();
   

Modified: trunk/src/newlib/stubs.c
===================================================================
--- trunk/src/newlib/stubs.c	2008-08-14 07:39:29 UTC (rev 53)
+++ trunk/src/newlib/stubs.c	2008-08-16 15:50:16 UTC (rev 54)
@@ -9,7 +9,6 @@
 #include &quot;devman.h&quot;
 #include &quot;ioctl.h&quot;
 #include &quot;platform.h&quot;
-#include &quot;tlsf.h&quot;
 
 // Utility function: look in the device manager table and find the index
 // for the given name. Returns an index into the device structure, -1 if error.
@@ -178,8 +177,6 @@
 
 // *****************************************************************************
 // _sbrk_r
-// Only used if we're using the default Newlib allocator (dlmalloc), not TLSF
-#ifndef USE_TLSF
 static char *heap_ptr; 
 
 void* _sbrk_r( struct _reent* r, ptrdiff_t incr )
@@ -202,7 +199,6 @@
   }
   return ptr;
 }
-#endif
 
 // *****************************************************************************
 // _lseek_r
@@ -290,124 +286,3 @@
   return __svfiscanf_r( r, stream, format, ap );
 }
 #endif // #ifdef LUA_INTONLY
-
-// If USE_TLSF is defined, &quot;redirect&quot; allocator calls from Newlib to TLSF
-#ifdef USE_TLSF
-
-// malloc: try to allocate in all the memory pools
-void* _malloc_r( struct _reent* r, size_t size )
-{
-  unsigned i = 0;
-  void* temp = NULL;
-
-  while( 1 )
-  {
-    if( ( temp = platform_get_first_free_ram( i ) ) == NULL )
-      break;
-    temp = tlsf_elua_align_addr( temp );
-    if( ( temp = malloc_ex( size, temp ) ) != NULL )
-      break;
-    i ++;
-  }
-  return temp;
-}
-
-// calloc: try to allocate in all the memory pools
-void* _calloc_r( struct _reent* r, size_t nelem, size_t elem_size )
-{
-  unsigned i = 0;
-  void* temp = NULL;
-
-  while( 1 )
-  {
-    if( ( temp = platform_get_first_free_ram( i ) ) == NULL )
-      break;
-    temp = tlsf_elua_align_addr( temp );
-    if( ( temp = calloc_ex( nelem, elem_size, temp ) ) != NULL )
-      break;
-    i ++;
-  }  
-  return temp;
-}
-
-// free: find memory pool with the given pointer, then free it
-void _free_r( struct _reent* r, void* ptr )
-{
-  unsigned i = 0;
-  u32 lstart, lend;
-
-  while( 1 )
-  {
-    if( ( lstart = ( u32 )platform_get_first_free_ram( i ) ) == 0 )
-      break;
-    lstart = ( u32 )tlsf_elua_align_addr( ( void* )lstart );
-    lend = ( u32 )platform_get_last_free_ram( i );
-    if( ( lstart &lt;= ( u32 )ptr ) &amp;&amp; ( ( u32 )ptr &lt;= lend ) )
-    {
-      free_ex( ptr, ( void* )lstart );
-      break;
-    }
-    i ++;
-  }  
-}
-
-// realloc: this is a bit more complex. First we identify the correct memory
-// pool and try to realloc there. If this doesn't work, we try to realloc in 
-// another pool before giving up.
-void* _realloc_r( struct _reent* r, void* ptr, size_t size )
-{
-  void* temp;
-  u32 lstart, lend;
-  unsigned i = 0;
-  size_t prevsize;
-  
-  // Realloc with ptr == NULL : malloc
-  // Realloc with size == 0 : free
-  if( !ptr )
-    return size ? _malloc_r( r, size ) : NULL;
-  else if( !size )
-  {
-    _free_r( r, ptr );
-    return NULL;
-  }
-
-  // At this point we know that this is an actual realloc
-  // Identify the memory pool
-  while( 1 )
-  {
-    if( ( lstart = ( u32 )platform_get_first_free_ram( i ) ) == 0 )
-      return NULL;
-    lstart = ( u32 )tlsf_elua_align_addr( ( void* )lstart );
-    lend = ( u32 )platform_get_last_free_ram( i );
-    if( ( lstart &lt;= ( u32 )ptr ) &amp;&amp; ( ( u32 )ptr &lt;= lend ) )
-      break;
-    i ++;
-  }    
-  
-  // Easy case: realloc succeeds in the same memory pool
-  if( ( temp = realloc_ex( ptr, size, ( void* )lstart ) ) != NULL )
-    return temp;
-  
-  // If realloc returned NULL, look for another pool
-  prevsize = tlsf_elua_get_block_size( ptr );
-  i = 0;
-  while( 1 )
-  {
-    if( ( temp = platform_get_first_free_ram( i ) ) == NULL )
-      break;
-    temp = tlsf_elua_align_addr( temp );
-    if( ( u32 )temp != lstart )
-    {
-      if( ( temp = malloc_ex( size, temp ) ) != NULL )
-      {
-        memcpy( temp, ptr, prevsize &lt; size ? prevsize : size );
-        free_ex( ptr, ( void* )lstart );
-        break;      
-      }
-    }
-    i ++;
-  }
-  return temp;
-}
-
-#endif // #ifdef USE_TLSF

Modified: trunk/src/shell.c
===================================================================
--- trunk/src/shell.c	2008-08-14 07:39:29 UTC (rev 53)
+++ trunk/src/shell.c	2008-08-16 15:50:16 UTC (rev 54)
@@ -10,7 +10,6 @@
 #include &lt;string.h&gt;
 #include &lt;stdlib.h&gt;
 #include &lt;malloc.h&gt;
-#include &quot;tlsf.h&quot;
 #include &quot;platform.h&quot;
 
 #include &quot;build.h&quot;
@@ -45,7 +44,6 @@
   printf( &quot;  lua [args] - run Lua with the given arguments\n&quot; );
   printf( &quot;  recv - receive a file (XMODEM) and execute it\n&quot; );
   printf( &quot;  ver - print eLua version\n&quot; );
-  printf( &quot;  mem - RAM usage data\n&quot; );
   printf( &quot;  exit - exit from this shelll\n&quot; );
 }
 
@@ -156,33 +154,6 @@
   printf( &quot;For more information go to <A HREF="http://elua.berlios.de\n">http://elua.berlios.de\n</A>&quot; );
 }
 
-// 'mem' handler
-static void shell_mem( char* args )
-{
-  unsigned i = 0;
-  u32 lstart, lend;
-  
-  args = args;
-  while( 1 )
-  {
-    if( ( lstart = ( u32 )platform_get_first_free_ram( i ) ) == 0 )
-      break;
-    lend = ( u32 )platform_get_last_free_ram( i );
-    printf( &quot;Start:0x%08lX  Size:%8ld  &quot;, lstart, lend - lstart + 1 );
-#ifdef USE_TLSF
-    lstart = ( u32 )tlsf_elua_align_addr( ( void* )lstart );
-    u32 temp = get_used_size( ( void* )lstart );
-    printf( &quot;Used:%8ld  Free:%8ld\n&quot;, temp, lend - lstart + 1 - temp );
-    i ++;
-#else
-    struct mallinfo allocdata;
-    allocdata = mallinfo();  
-    printf( &quot;Used:%8ld Free:%8ld\n&quot;, ( long )allocdata.uordblks, ( long )allocdata.fordblks );      
-    break;
-#endif    
-  }
-}
-
 // Insert shell commands here
 static const SHELL_COMMAND shell_commands[] = 
 {
@@ -190,7 +161,6 @@
   { &quot;lua&quot;, shell_lua },
   { &quot;recv&quot;, shell_recv },
   { &quot;ver&quot;, shell_ver },
-  { &quot;mem&quot;, shell_mem },
   { &quot;exit&quot;, NULL },
   { NULL, NULL }
 };

Deleted: trunk/src/tlsf.c
===================================================================
--- trunk/src/tlsf.c	2008-08-14 07:39:29 UTC (rev 53)
+++ trunk/src/tlsf.c	2008-08-16 15:50:16 UTC (rev 54)
@@ -1,1044 +0,0 @@
-// TLSF allocator - modified by BogdanM for eLua
-#ifdef USE_TLSF
-
-#include &quot;platform.h&quot;
-#include &quot;type.h&quot;
-
-#define TLSF_STATISTIC    (1)
-
-/* 
- * Two Levels Segregate Fit memory allocator (TLSF)
- * Version 2.4.3
- *
- * Written by Miguel Masmano Tello &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">mimastel at doctor.upv.es</A>&gt;
- *
- * Thanks to Ismael Ripoll for his suggestions and reviews
- *
- * Copyright (C) 2008, 2007, 2006, 2005, 2004
- *
- * This code is released using a dual license strategy: GPL/LGPL
- * You can choose the licence that better fits your requirements.
- *
- * Released under the terms of the GNU General Public License Version 2.0
- * Released under the terms of the GNU Lesser General Public License Version 2.1
- *
- */
-
-/*
- * Code contributions:
- *
- * (Jul 28 2007)  Herman ten Brugge &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">hermantenbrugge at home.nl</A>&gt;:
- *
- * - Add 64 bit support. It now runs on x86_64 and solaris64.
- * - I also tested this on vxworks/32and solaris/32 and i386/32 processors.
- * - Remove assembly code. I could not measure any performance difference 
- *   on my core2 processor. This also makes the code more portable.
- * - Moved defines/typedefs from tlsf.h to tlsf.c
- * - Changed MIN_BLOCK_SIZE to sizeof (free_ptr_t) and BHDR_OVERHEAD to 
- *   (sizeof (bhdr_t) - MIN_BLOCK_SIZE). This does not change the fact 
- *    that the minumum size is still sizeof 
- *   (bhdr_t).
- * - Changed all C++ comment style to C style. (// -&gt; /.* ... *./)
- * - Used ls_bit instead of ffs and ms_bit instead of fls. I did this to 
- *   avoid confusion with the standard ffs function which returns 
- *   different values.
- * - Created set_bit/clear_bit fuctions because they are not present 
- *   on x86_64.
- * - Added locking support + extra file target.h to show how to use it.
- * - Added get_used_size function (REMOVED in 2.4)
- * - Added rtl_realloc and rtl_calloc function
- * - Implemented realloc clever support.
- * - Added some test code in the example directory.
- *        
- *
- * (Oct 23 2006) Adam Scislowicz: 
- *
- * - Support for ARMv5 implemented
- *
- */
-
-/*#define USE_SBRK        (0) */
-/*#define USE_MMAP        (0) */
-
-#include &lt;stdio.h&gt;
-#include &lt;string.h&gt;
-
-#ifndef TLSF_USE_LOCKS
-#define	TLSF_USE_LOCKS 	(0)
-#endif
-
-#ifndef TLSF_STATISTIC
-#define	TLSF_STATISTIC 	(0)
-#endif
-
-#ifndef USE_MMAP
-#define	USE_MMAP 	(0)
-#endif
-
-#ifndef USE_SBRK
-#define	USE_SBRK 	(0)
-#endif
-
-
-#if TLSF_USE_LOCKS
-#include &quot;target.h&quot;
-#else
-#define TLSF_CREATE_LOCK(_unused_)   do{}while(0)
-#define TLSF_DESTROY_LOCK(_unused_)  do{}while(0) 
-#define TLSF_ACQUIRE_LOCK(_unused_)  do{}while(0)
-#define TLSF_RELEASE_LOCK(_unused_)  do{}while(0)
-#endif
-
-#if TLSF_STATISTIC
-#define	TLSF_ADD_SIZE(tlsf, b) do {									\
-		tlsf-&gt;used_size += (b-&gt;size &amp; BLOCK_SIZE) + BHDR_OVERHEAD;	\
-		if (tlsf-&gt;used_size &gt; tlsf-&gt;max_size) {						\
-			tlsf-&gt;max_size = tlsf-&gt;used_size;						\
-		} } while(0)
-
-#define	TLSF_REMOVE_SIZE(tlsf, b) do {								\
-		tlsf-&gt;used_size -= (b-&gt;size &amp; BLOCK_SIZE) + BHDR_OVERHEAD;	\
-	} while(0)
-#else
-#define	TLSF_ADD_SIZE(tlsf, b)	     do{}while(0)
-#define	TLSF_REMOVE_SIZE(tlsf, b)    do{}while(0)
-#endif
-
-#if USE_MMAP || USE_SBRK
-#include &lt;unistd.h&gt;
-#endif
-
-#if USE_MMAP
-#include &lt;sys/mman.h&gt;
-#endif
-
-#include &quot;tlsf.h&quot;
-
-#if !defined(__GNUC__)
-#ifndef __inline__
-#define __inline__
-#endif
-#endif
-
-/* The  debug functions  only can  be used  when _DEBUG_TLSF_  is set. */
-#ifndef _DEBUG_TLSF_
-#define _DEBUG_TLSF_  (0)
-#endif
-
-/*************************************************************************/
-/* Definition of the structures used by TLSF */
-
-
-/* Some IMPORTANT TLSF parameters */
-/* Unlike the preview TLSF versions, now they are statics */
-#define BLOCK_ALIGN (sizeof(void *) * 2)
-
-#define MAX_FLI		(30)
-#define MAX_LOG2_SLI	(5)
-#define MAX_SLI		(1 &lt;&lt; MAX_LOG2_SLI)     /* MAX_SLI = 2^MAX_LOG2_SLI */
-
-#define FLI_OFFSET	(6)     /* tlsf structure just will manage blocks bigger */
-/* than 128 bytes */
-#define SMALL_BLOCK	(128)
-#define REAL_FLI	(MAX_FLI - FLI_OFFSET)
-#define MIN_BLOCK_SIZE	(sizeof (free_ptr_t))
-#define BHDR_OVERHEAD	(sizeof (bhdr_t) - MIN_BLOCK_SIZE)
-#define TLSF_SIGNATURE	(0x2A59FA59)
-
-#define	PTR_MASK	(sizeof(void *) - 1)
-#define BLOCK_SIZE	(0xFFFFFFFF - PTR_MASK)
-
-#define GET_NEXT_BLOCK(_addr, _r) ((bhdr_t *) ((char *) (_addr) + (_r)))
-#define	MEM_ALIGN		  ((BLOCK_ALIGN) - 1)
-#define ROUNDUP_SIZE(_r)          (((_r) + MEM_ALIGN) &amp; ~MEM_ALIGN)
-#define ROUNDDOWN_SIZE(_r)        ((_r) &amp; ~MEM_ALIGN)
-#define ROUNDUP(_x, _v)           ((((~(_x)) + 1) &amp; ((_v)-1)) + (_x))
-
-#define BLOCK_STATE	(0x1)
-#define PREV_STATE	(0x2)
-
-/* bit 0 of the block size */
-#define FREE_BLOCK	(0x1)
-#define USED_BLOCK	(0x0)
-
-/* bit 1 of the block size */
-#define PREV_FREE	(0x2)
-#define PREV_USED	(0x0)
-
-
-#define DEFAULT_AREA_SIZE (1024*10)
-
-#ifdef USE_MMAP
-#define PAGE_SIZE (getpagesize())
-#endif
-
-#define PRINT_MSG(fmt, args...) printf(fmt, ## args)
-#define ERROR_MSG(fmt, args...) printf(fmt, ## args)
-
-typedef unsigned int u32_t;     /* NOTE: Make sure that this type is 4 bytes long on your computer */
-typedef unsigned char u8_t;     /* NOTE: Make sure that this type is 1 byte on your computer */
-
-typedef struct free_ptr_struct {
-    struct bhdr_struct *prev;
-    struct bhdr_struct *next;
-} free_ptr_t;
-
-typedef struct bhdr_struct {
-    /* This pointer is just valid if the first bit of size is set */
-    struct bhdr_struct *prev_hdr;
-    /* The size is stored in bytes */
-    size_t size;                /* bit 0 indicates whether the block is used and */
-    /* bit 1 allows to know whether the previous block is free */
-    union {
-        struct free_ptr_struct free_ptr;
-        u8_t buffer[1];         /*sizeof(struct free_ptr_struct)]; */
-    } ptr;
-} bhdr_t;
-
-/* This structure is embedded at the beginning of each area, giving us
- * enough information to cope with a set of areas */
-
-typedef struct area_info_struct {
-    bhdr_t *end;
-    struct area_info_struct *next;
-} area_info_t;
-
-typedef struct TLSF_struct {
-    /* the TLSF's structure signature */
-    u32_t tlsf_signature;
-
-#if TLSF_USE_LOCKS
-    TLSF_MLOCK_T lock;
-#endif
-
-#if TLSF_STATISTIC
-    /* These can not be calculated outside tlsf because we
-     * do not know the sizes when freeing/reallocing memory. */
-    size_t used_size;
-    size_t max_size;
-#endif
-
-    /* A linked list holding all the existing areas */
-    area_info_t *area_head;
-
-    /* the first-level bitmap */
-    /* This array should have a size of REAL_FLI bits */
-    u32_t fl_bitmap;
-
-    /* the second-level bitmap */
-    u32_t sl_bitmap[REAL_FLI];
-
-    bhdr_t *matrix[REAL_FLI][MAX_SLI];
-} tlsf_t;
-
-
-/******************************************************************/
-/**************     Helping functions    **************************/
-/******************************************************************/
-static __inline__ void set_bit(int nr, u32_t * addr);
-static __inline__ void clear_bit(int nr, u32_t * addr);
-static __inline__ int ls_bit(int x);
-static __inline__ int ms_bit(int x);
-static __inline__ void MAPPING_SEARCH(size_t * _r, int *_fl, int *_sl);
-static __inline__ void MAPPING_INSERT(size_t _r, int *_fl, int *_sl);
-static __inline__ bhdr_t *FIND_SUITABLE_BLOCK(tlsf_t * _tlsf, int *_fl, int *_sl);
-static __inline__ bhdr_t *process_area(void *area, size_t size);
-#if USE_SBRK || USE_MMAP
-static __inline__ void *get_new_area(size_t * size);
-#endif
-
-static const int table[] = {
-    -1, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4,
-    4, 4,
-    4, 4, 4, 4, 4, 4, 4,
-    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
-    5,
-    5, 5, 5, 5, 5, 5, 5,
-    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
-    6,
-    6, 6, 6, 6, 6, 6, 6,
-    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
-    6,
-    6, 6, 6, 6, 6, 6, 6,
-    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
-    7,
-    7, 7, 7, 7, 7, 7, 7,
-    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
-    7,
-    7, 7, 7, 7, 7, 7, 7,
-    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
-    7,
-    7, 7, 7, 7, 7, 7, 7,
-    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
-    7,
-    7, 7, 7, 7, 7, 7, 7
-};
-
-static __inline__ int ls_bit(int i)
-{
-    unsigned int a;
-    unsigned int x = i &amp; -i;
-
-    a = x &lt;= 0xffff ? (x &lt;= 0xff ? 0 : 8) : (x &lt;= 0xffffff ? 16 : 24);
-    return table[x &gt;&gt; a] + a;
-}
-
-static __inline__ int ms_bit(int i)
-{
-    unsigned int a;
-    unsigned int x = (unsigned int) i;
-
-    a = x &lt;= 0xffff ? (x &lt;= 0xff ? 0 : 8) : (x &lt;= 0xffffff ? 16 : 24);
-    return table[x &gt;&gt; a] + a;
-}
-
-static __inline__ void set_bit(int nr, u32_t * addr)
-{
-    addr[nr &gt;&gt; 5] |= 1 &lt;&lt; (nr &amp; 0x1f);
-}
-
-static __inline__ void clear_bit(int nr, u32_t * addr)
-{
-    addr[nr &gt;&gt; 5] &amp;= ~(1 &lt;&lt; (nr &amp; 0x1f));
-}
-
-static __inline__ void MAPPING_SEARCH(size_t * _r, int *_fl, int *_sl)
-{
-    int _t;
-
-    if (*_r &lt; SMALL_BLOCK) {
-        *_fl = 0;
-        *_sl = *_r / (SMALL_BLOCK / MAX_SLI);
-    } else {
-        _t = (1 &lt;&lt; (ms_bit(*_r) - MAX_LOG2_SLI)) - 1;
-        *_r = *_r + _t;
-        *_fl = ms_bit(*_r);
-        *_sl = (*_r &gt;&gt; (*_fl - MAX_LOG2_SLI)) - MAX_SLI;
-        *_fl -= FLI_OFFSET;
-        /*if ((*_fl -= FLI_OFFSET) &lt; 0) // FL wil be always &gt;0!
-         *_fl = *_sl = 0;
-         */
-        *_r &amp;= ~_t;
-    }
-}
-
-static __inline__ void MAPPING_INSERT(size_t _r, int *_fl, int *_sl)
-{
-    if (_r &lt; SMALL_BLOCK) {
-        *_fl = 0;
-        *_sl = _r / (SMALL_BLOCK / MAX_SLI);
-    } else {
-        *_fl = ms_bit(_r);
-        *_sl = (_r &gt;&gt; (*_fl - MAX_LOG2_SLI)) - MAX_SLI;
-        *_fl -= FLI_OFFSET;
-    }
-}
-
-
-static __inline__ bhdr_t *FIND_SUITABLE_BLOCK(tlsf_t * _tlsf, int *_fl, int *_sl)
-{
-    u32_t _tmp = _tlsf-&gt;sl_bitmap[*_fl] &amp; (~0 &lt;&lt; *_sl);
-    bhdr_t *_b = NULL;
-
-    if (_tmp) {
-        *_sl = ls_bit(_tmp);
-        _b = _tlsf-&gt;matrix[*_fl][*_sl];
-    } else {
-        *_fl = ls_bit(_tlsf-&gt;fl_bitmap &amp; (~0 &lt;&lt; (*_fl + 1)));
-        if (*_fl &gt; 0) {         /* likely */
-            *_sl = ls_bit(_tlsf-&gt;sl_bitmap[*_fl]);
-            _b = _tlsf-&gt;matrix[*_fl][*_sl];
-        }
-    }
-    return _b;
-}
-
-
-#define EXTRACT_BLOCK_HDR(_b, _tlsf, _fl, _sl) do {					\
-		_tlsf -&gt; matrix [_fl] [_sl] = _b -&gt; ptr.free_ptr.next;		\
-		if (_tlsf -&gt; matrix[_fl][_sl])								\
-			_tlsf -&gt; matrix[_fl][_sl] -&gt; ptr.free_ptr.prev = NULL;	\
-		else {														\
-			clear_bit (_sl, &amp;_tlsf -&gt; sl_bitmap [_fl]);				\
-			if (!_tlsf -&gt; sl_bitmap [_fl])							\
-				clear_bit (_fl, &amp;_tlsf -&gt; fl_bitmap);				\
-		}															\
-		_b -&gt; ptr.free_ptr.prev =  NULL;				\
-		_b -&gt; ptr.free_ptr.next =  NULL;				\
-	}while(0)
-
-
-#define EXTRACT_BLOCK(_b, _tlsf, _fl, _sl) do {							\
-		if (_b -&gt; ptr.free_ptr.next)									\
-			_b -&gt; ptr.free_ptr.next -&gt; ptr.free_ptr.prev = _b -&gt; ptr.free_ptr.prev; \
-		if (_b -&gt; ptr.free_ptr.prev)									\
-			_b -&gt; ptr.free_ptr.prev -&gt; ptr.free_ptr.next = _b -&gt; ptr.free_ptr.next; \
-		if (_tlsf -&gt; matrix [_fl][_sl] == _b) {							\
-			_tlsf -&gt; matrix [_fl][_sl] = _b -&gt; ptr.free_ptr.next;		\
-			if (!_tlsf -&gt; matrix [_fl][_sl]) {							\
-				clear_bit (_sl, &amp;_tlsf -&gt; sl_bitmap[_fl]);				\
-				if (!_tlsf -&gt; sl_bitmap [_fl])							\
-					clear_bit (_fl, &amp;_tlsf -&gt; fl_bitmap);				\
-			}															\
-		}																\
-		_b -&gt; ptr.free_ptr.prev = NULL;					\
-		_b -&gt; ptr.free_ptr.next = NULL;					\
-	} while(0)
-
-#define INSERT_BLOCK(_b, _tlsf, _fl, _sl) do {							\
-		_b -&gt; ptr.free_ptr.prev = NULL; \
-		_b -&gt; ptr.free_ptr.next = _tlsf -&gt; matrix [_fl][_sl]; \
-		if (_tlsf -&gt; matrix [_fl][_sl])									\
-			_tlsf -&gt; matrix [_fl][_sl] -&gt; ptr.free_ptr.prev = _b;		\
-		_tlsf -&gt; matrix [_fl][_sl] = _b;								\
-		set_bit (_sl, &amp;_tlsf -&gt; sl_bitmap [_fl]);						\
-		set_bit (_fl, &amp;_tlsf -&gt; fl_bitmap);								\
-	} while(0)
-
-#if USE_SBRK || USE_MMAP
-static __inline__ void *get_new_area(size_t * size) 
-{
-    void *area;
-
-#if USE_SBRK
-    area = (void *)sbrk(0);
-    if (((void *)sbrk(*size)) != ((void *) -1))
-        return area;
-#endif
-
-#if USE_MMAP
-    *size = ROUNDUP(*size, PAGE_SIZE);
-    if ((area = mmap(0, *size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0)) != MAP_FAILED)
-        return area;
-#endif
-    return ((void *) ~0);
-}
-#endif
-
-static __inline__ bhdr_t *process_area(void *area, size_t size)
-{
-    bhdr_t *b, *lb, *ib;
-    area_info_t *ai;
-
-    ib = (bhdr_t *) area;
-    ib-&gt;size =
-        (sizeof(area_info_t) &lt;
-         MIN_BLOCK_SIZE) ? MIN_BLOCK_SIZE : ROUNDUP_SIZE(sizeof(area_info_t)) | USED_BLOCK | PREV_USED;
-    b = (bhdr_t *) GET_NEXT_BLOCK(ib-&gt;ptr.buffer, ib-&gt;size &amp; BLOCK_SIZE);
-    b-&gt;size = ROUNDDOWN_SIZE(size - 3 * BHDR_OVERHEAD - (ib-&gt;size &amp; BLOCK_SIZE)) | USED_BLOCK | PREV_USED;
-    b-&gt;ptr.free_ptr.prev = b-&gt;ptr.free_ptr.next = 0;
-    lb = GET_NEXT_BLOCK(b-&gt;ptr.buffer, b-&gt;size &amp; BLOCK_SIZE);
-    lb-&gt;prev_hdr = b;
-    lb-&gt;size = 0 | USED_BLOCK | PREV_FREE;
-    ai = (area_info_t *) ib-&gt;ptr.buffer;
-    ai-&gt;next = 0;
-    ai-&gt;end = lb;
-    return ib;
-}
-
-/******************************************************************/
-/******************** Begin of the allocator code *****************/
-/******************************************************************/
-
-static char *mp = NULL;         /* Default memory pool. */
-
-/******************************************************************/
-size_t init_memory_pool(size_t mem_pool_size, void *mem_pool)
-{
-/******************************************************************/
-    tlsf_t *tlsf;
-    bhdr_t *b, *ib;
-
-    if (!mem_pool || !mem_pool_size || mem_pool_size &lt; sizeof(tlsf_t) + BHDR_OVERHEAD * 8) {
-        ERROR_MSG(&quot;init_memory_pool (): memory_pool invalid\n&quot;);
-        return -1;
-    }
-
-    if (((unsigned long) mem_pool &amp; PTR_MASK)) {
-        ERROR_MSG(&quot;init_memory_pool (): mem_pool must be aligned to a word\n&quot;);
-        return -1;
-    }
-    tlsf = (tlsf_t *) mem_pool;
-    /* Check if already initialised */
-    if (tlsf-&gt;tlsf_signature == TLSF_SIGNATURE) {
-        mp = mem_pool;
-        b = GET_NEXT_BLOCK(mp, ROUNDUP_SIZE(sizeof(tlsf_t)));
-        return b-&gt;size &amp; BLOCK_SIZE;
-    }
-
-    mp = mem_pool;
-
-    /* Zeroing the memory pool */
-    memset(mem_pool, 0, sizeof(tlsf_t));
-
-    tlsf-&gt;tlsf_signature = TLSF_SIGNATURE;
-
-    TLSF_CREATE_LOCK(&amp;tlsf-&gt;lock);
-
-    ib = process_area(GET_NEXT_BLOCK
-                      (mem_pool, ROUNDUP_SIZE(sizeof(tlsf_t))), ROUNDDOWN_SIZE(mem_pool_size - sizeof(tlsf_t)));
-    b = GET_NEXT_BLOCK(ib-&gt;ptr.buffer, ib-&gt;size &amp; BLOCK_SIZE);
-    free_ex(b-&gt;ptr.buffer, tlsf);
-    tlsf-&gt;area_head = (area_info_t *) ib-&gt;ptr.buffer;
-
-#if TLSF_STATISTIC
-    tlsf-&gt;used_size = mem_pool_size - (b-&gt;size &amp; BLOCK_SIZE);
-    tlsf-&gt;max_size = tlsf-&gt;used_size;
-#endif
-
-    return (b-&gt;size &amp; BLOCK_SIZE);
-}
-
-/******************************************************************/
-size_t add_new_area(void *area, size_t area_size, void *mem_pool)
-{
-/******************************************************************/
-    tlsf_t *tlsf = (tlsf_t *) mem_pool;
-    area_info_t *ptr, *ptr_prev, *ai;
-    bhdr_t *ib0, *b0, *lb0, *ib1, *b1, *lb1, *next_b;
-
-    memset(area, 0, area_size);
-    ptr = tlsf-&gt;area_head;
-    ptr_prev = 0;
-
-    ib0 = process_area(area, area_size);
-    b0 = GET_NEXT_BLOCK(ib0-&gt;ptr.buffer, ib0-&gt;size &amp; BLOCK_SIZE);
-    lb0 = GET_NEXT_BLOCK(b0-&gt;ptr.buffer, b0-&gt;size &amp; BLOCK_SIZE);
-
-    /* Before inserting the new area, we have to merge this area with the
-       already existing ones */
-
-    while (ptr) {
-        ib1 = (bhdr_t *) ((char *) ptr - BHDR_OVERHEAD);
-        b1 = GET_NEXT_BLOCK(ib1-&gt;ptr.buffer, ib1-&gt;size &amp; BLOCK_SIZE);
-        lb1 = ptr-&gt;end;
-
-        /* Merging the new area with the next physically contigous one */
-        if ((unsigned long) ib1 == (unsigned long) lb0 + BHDR_OVERHEAD) {
-            if (tlsf-&gt;area_head == ptr) {
-                tlsf-&gt;area_head = ptr-&gt;next;
-                ptr = ptr-&gt;next;
-            } else {
-                ptr_prev-&gt;next = ptr-&gt;next;
-                ptr = ptr-&gt;next;
-            }
-
-            b0-&gt;size =
-                ROUNDDOWN_SIZE((b0-&gt;size &amp; BLOCK_SIZE) +
-                               (ib1-&gt;size &amp; BLOCK_SIZE) + 2 * BHDR_OVERHEAD) | USED_BLOCK | PREV_USED;
-
-            b1-&gt;prev_hdr = b0;
-            lb0 = lb1;
-
-            continue;
-        }
-
-        /* Merging the new area with the previous physically contigous
-           one */
-        if ((unsigned long) lb1-&gt;ptr.buffer == (unsigned long) ib0) {
-            if (tlsf-&gt;area_head == ptr) {
-                tlsf-&gt;area_head = ptr-&gt;next;
-                ptr = ptr-&gt;next;
-            } else {
-                ptr_prev-&gt;next = ptr-&gt;next;
-                ptr = ptr-&gt;next;
-            }
-
-            lb1-&gt;size =
-                ROUNDDOWN_SIZE((b0-&gt;size &amp; BLOCK_SIZE) +
-                               (ib0-&gt;size &amp; BLOCK_SIZE) + 2 * BHDR_OVERHEAD) | USED_BLOCK | (lb1-&gt;size &amp; PREV_STATE);
-            next_b = GET_NEXT_BLOCK(lb1-&gt;ptr.buffer, lb1-&gt;size &amp; BLOCK_SIZE);
-            next_b-&gt;prev_hdr = lb1;
-            b0 = lb1;
-            ib0 = ib1;
-
-            continue;
-        }
-        ptr_prev = ptr;
-        ptr = ptr-&gt;next;
-    }
-
-    /* Inserting the area in the list of linked areas */
-    ai = (area_info_t *) ib0-&gt;ptr.buffer;
-    ai-&gt;next = tlsf-&gt;area_head;
-    ai-&gt;end = lb0;
-    tlsf-&gt;area_head = ai;
-    free_ex(b0-&gt;ptr.buffer, mem_pool);
-    return (b0-&gt;size &amp; BLOCK_SIZE);
-}
-
-
-/******************************************************************/
-size_t get_used_size(void *mem_pool)
-{
-/******************************************************************/
-#if TLSF_STATISTIC
-    return ((tlsf_t *) mem_pool)-&gt;used_size;
-#else
-    return 0;
-#endif
-}
-
-/******************************************************************/
-size_t get_max_size(void *mem_pool)
-{
-/******************************************************************/
-#if TLSF_STATISTIC
-    return ((tlsf_t *) mem_pool)-&gt;max_size;
-#else
-    return 0;
-#endif
-}
-
-/******************************************************************/
-void destroy_memory_pool(void *mem_pool)
-{
-/******************************************************************/
-    tlsf_t *tlsf = (tlsf_t *) mem_pool;
-
-    tlsf-&gt;tlsf_signature = 0;
-
-    TLSF_DESTROY_LOCK(&amp;tlsf-&gt;lock);
-
-}
-
-
-/******************************************************************/
-void *tlsf_malloc(size_t size)
-{
-/******************************************************************/
-    void *ret;
-
-#if USE_MMAP || USE_SBRK
-    if (!mp) {
-        size_t area_size;
-        void *area;
-
-        area_size = sizeof(tlsf_t) + BHDR_OVERHEAD * 8; /* Just a safety constant */
-        area_size = (area_size &gt; DEFAULT_AREA_SIZE) ? area_size : DEFAULT_AREA_SIZE;
-        area = get_new_area(&amp;area_size);
-        if (area == ((void *) ~0))
-            return NULL;        /* Not enough system memory */
-        init_memory_pool(area_size, area);
-    }
-#endif
-
-    TLSF_ACQUIRE_LOCK(&amp;((tlsf_t *)mp)-&gt;lock);
-
-    ret = malloc_ex(size, mp);
-
-    TLSF_RELEASE_LOCK(&amp;((tlsf_t *)mp)-&gt;lock);
-
-    return ret;
-}
-
-/******************************************************************/
-void tlsf_free(void *ptr)
-{
-/******************************************************************/
-
-    TLSF_ACQUIRE_LOCK(&amp;((tlsf_t *)mp)-&gt;lock);
-
-    free_ex(ptr, mp);
-
-    TLSF_RELEASE_LOCK(&amp;((tlsf_t *)mp)-&gt;lock);
-
-}
-
-/******************************************************************/
-void *tlsf_realloc(void *ptr, size_t size)
-{
-/******************************************************************/
-    void *ret;
-
-#if USE_MMAP || USE_SBRK
-	if (!mp) {
-		return tlsf_malloc(size);
-	}
-#endif
-
-    TLSF_ACQUIRE_LOCK(&amp;((tlsf_t *)mp)-&gt;lock);
-
-    ret = realloc_ex(ptr, size, mp);
-
-    TLSF_RELEASE_LOCK(&amp;((tlsf_t *)mp)-&gt;lock);
-
-    return ret;
-}
-
-/******************************************************************/
-void *tlsf_calloc(size_t nelem, size_t elem_size)
-{
-/******************************************************************/
-    void *ret;
-
-    TLSF_ACQUIRE_LOCK(&amp;((tlsf_t *)mp)-&gt;lock);
-
-    ret = calloc_ex(nelem, elem_size, mp);
-
-    TLSF_RELEASE_LOCK(&amp;((tlsf_t *)mp)-&gt;lock);
-
-    return ret;
-}
-
-/******************************************************************/
-void *malloc_ex(size_t size, void *mem_pool)
-{
-/******************************************************************/
-    tlsf_t *tlsf = (tlsf_t *) mem_pool;
-    bhdr_t *b, *b2, *next_b;
-    int fl, sl;
-    size_t tmp_size;
-
-    size = (size &lt; MIN_BLOCK_SIZE) ? MIN_BLOCK_SIZE : ROUNDUP_SIZE(size);
-
-    /* Rounding up the requested size and calculating fl and sl */
-    MAPPING_SEARCH(&amp;size, &amp;fl, &amp;sl);
-
-    /* Searching a free block, recall that this function changes the values of fl and sl,
-       so they are not longer valid when the function fails */
-    b = FIND_SUITABLE_BLOCK(tlsf, &amp;fl, &amp;sl);
-#if USE_MMAP || USE_SBRK
-    if (!b) {
-        size_t area_size;
-        void *area;
-        /* Growing the pool size when needed */
-        area_size = size + BHDR_OVERHEAD * 8;   /* size plus enough room for the requered headers. */
-        area_size = (area_size &gt; DEFAULT_AREA_SIZE) ? area_size : DEFAULT_AREA_SIZE;
-        area = get_new_area(&amp;area_size);        /* Call sbrk or mmap */
-        if (area == ((void *) ~0))
-            return NULL;        /* Not enough system memory */
-        add_new_area(area, area_size, mem_pool);
-        /* Rounding up the requested size and calculating fl and sl */
-        MAPPING_SEARCH(&amp;size, &amp;fl, &amp;sl);
-        /* Searching a free block */
-        b = FIND_SUITABLE_BLOCK(tlsf, &amp;fl, &amp;sl);
-    }
-#endif
-    if (!b)
-        return NULL;            /* Not found */
-
-    EXTRACT_BLOCK_HDR(b, tlsf, fl, sl);
-
-    /*-- found: */
-    next_b = GET_NEXT_BLOCK(b-&gt;ptr.buffer, b-&gt;size &amp; BLOCK_SIZE);
-    /* Should the block be split? */
-    tmp_size = (b-&gt;size &amp; BLOCK_SIZE) - size;
-    if (tmp_size &gt;= sizeof(bhdr_t)) {
-        tmp_size -= BHDR_OVERHEAD;
-        b2 = GET_NEXT_BLOCK(b-&gt;ptr.buffer, size);
-        b2-&gt;size = tmp_size | FREE_BLOCK | PREV_USED;
-        next_b-&gt;prev_hdr = b2;
-        MAPPING_INSERT(tmp_size, &amp;fl, &amp;sl);
-        INSERT_BLOCK(b2, tlsf, fl, sl);
-
-        b-&gt;size = size | (b-&gt;size &amp; PREV_STATE);
-    } else {
-        next_b-&gt;size &amp;= (~PREV_FREE);
-        b-&gt;size &amp;= (~FREE_BLOCK);       /* Now it's used */
-    }
-
-    TLSF_ADD_SIZE(tlsf, b);
-
-    return (void *) b-&gt;ptr.buffer;
-}
-
-/******************************************************************/
-void free_ex(void *ptr, void *mem_pool)
-{
-/******************************************************************/
-    tlsf_t *tlsf = (tlsf_t *) mem_pool;
-    bhdr_t *b, *tmp_b;
-    int fl = 0, sl = 0;
-
-    if (!ptr) {
-        return;
-    }
-    b = (bhdr_t *) ((char *) ptr - BHDR_OVERHEAD);
-    b-&gt;size |= FREE_BLOCK;
-
-    TLSF_REMOVE_SIZE(tlsf, b);
-
-    b-&gt;ptr.free_ptr.prev = NULL;
-    b-&gt;ptr.free_ptr.next = NULL;
-    tmp_b = GET_NEXT_BLOCK(b-&gt;ptr.buffer, b-&gt;size &amp; BLOCK_SIZE);
-    if (tmp_b-&gt;size &amp; FREE_BLOCK) {
-        MAPPING_INSERT(tmp_b-&gt;size &amp; BLOCK_SIZE, &amp;fl, &amp;sl);
-        EXTRACT_BLOCK(tmp_b, tlsf, fl, sl);
-        b-&gt;size += (tmp_b-&gt;size &amp; BLOCK_SIZE) + BHDR_OVERHEAD;
-    }
-    if (b-&gt;size &amp; PREV_FREE) {
-        tmp_b = b-&gt;prev_hdr;
-        MAPPING_INSERT(tmp_b-&gt;size &amp; BLOCK_SIZE, &amp;fl, &amp;sl);
-        EXTRACT_BLOCK(tmp_b, tlsf, fl, sl);
-        tmp_b-&gt;size += (b-&gt;size &amp; BLOCK_SIZE) + BHDR_OVERHEAD;
-        b = tmp_b;
-    }
-    MAPPING_INSERT(b-&gt;size &amp; BLOCK_SIZE, &amp;fl, &amp;sl);
-    INSERT_BLOCK(b, tlsf, fl, sl);
-
-    tmp_b = GET_NEXT_BLOCK(b-&gt;ptr.buffer, b-&gt;size &amp; BLOCK_SIZE);
-    tmp_b-&gt;size |= PREV_FREE;
-    tmp_b-&gt;prev_hdr = b;
-}
-
-/******************************************************************/
-void *realloc_ex(void *ptr, size_t new_size, void *mem_pool)
-{
-/******************************************************************/
-    tlsf_t *tlsf = (tlsf_t *) mem_pool;
-    void *ptr_aux;
-    unsigned int cpsize;
-    bhdr_t *b, *tmp_b, *next_b;
-    int fl, sl;
-    size_t tmp_size;
-
-    if (!ptr) {
-        if (new_size)
-            return (void *) malloc_ex(new_size, mem_pool);
-        if (!new_size)
-            return NULL;
-    } else if (!new_size) {
-        free_ex(ptr, mem_pool);
-        return NULL;
-    }
-
-    b = (bhdr_t *) ((char *) ptr - BHDR_OVERHEAD);
-    next_b = GET_NEXT_BLOCK(b-&gt;ptr.buffer, b-&gt;size &amp; BLOCK_SIZE);
-    new_size = (new_size &lt; MIN_BLOCK_SIZE) ? MIN_BLOCK_SIZE : ROUNDUP_SIZE(new_size);
-    tmp_size = (b-&gt;size &amp; BLOCK_SIZE);
-    if (new_size &lt;= tmp_size) {
-	TLSF_REMOVE_SIZE(tlsf, b);
-        if (next_b-&gt;size &amp; FREE_BLOCK) {
-            MAPPING_INSERT(next_b-&gt;size &amp; BLOCK_SIZE, &amp;fl, &amp;sl);
-            EXTRACT_BLOCK(next_b, tlsf, fl, sl);
-            tmp_size += (next_b-&gt;size &amp; BLOCK_SIZE) + BHDR_OVERHEAD;
-            next_b = GET_NEXT_BLOCK(next_b-&gt;ptr.buffer, next_b-&gt;size &amp; BLOCK_SIZE);
-            /* We allways reenter this free block because tmp_size will
-               be greater then sizeof (bhdr_t) */
-        }
-        tmp_size -= new_size;
-        if (tmp_size &gt;= sizeof(bhdr_t)) {
-            tmp_size -= BHDR_OVERHEAD;
-            tmp_b = GET_NEXT_BLOCK(b-&gt;ptr.buffer, new_size);
-            tmp_b-&gt;size = tmp_size | FREE_BLOCK | PREV_USED;
-            next_b-&gt;prev_hdr = tmp_b;
-            next_b-&gt;size |= PREV_FREE;
-            MAPPING_INSERT(tmp_size, &amp;fl, &amp;sl);
-            INSERT_BLOCK(tmp_b, tlsf, fl, sl);
-            b-&gt;size = new_size | (b-&gt;size &amp; PREV_STATE);
-        }
-	TLSF_ADD_SIZE(tlsf, b);
-        return (void *) b-&gt;ptr.buffer;
-    }
-    if ((next_b-&gt;size &amp; FREE_BLOCK)) {
-        if (new_size &lt;= (tmp_size + (next_b-&gt;size &amp; BLOCK_SIZE))) {
-			TLSF_REMOVE_SIZE(tlsf, b);
-            MAPPING_INSERT(next_b-&gt;size &amp; BLOCK_SIZE, &amp;fl, &amp;sl);
-            EXTRACT_BLOCK(next_b, tlsf, fl, sl);
-            b-&gt;size += (next_b-&gt;size &amp; BLOCK_SIZE) + BHDR_OVERHEAD;
-            next_b = GET_NEXT_BLOCK(b-&gt;ptr.buffer, b-&gt;size &amp; BLOCK_SIZE);
-            next_b-&gt;prev_hdr = b;
-            next_b-&gt;size &amp;= ~PREV_FREE;
-            tmp_size = (b-&gt;size &amp; BLOCK_SIZE) - new_size;
-            if (tmp_size &gt;= sizeof(bhdr_t)) {
-                tmp_size -= BHDR_OVERHEAD;
-                tmp_b = GET_NEXT_BLOCK(b-&gt;ptr.buffer, new_size);
-                tmp_b-&gt;size = tmp_size | FREE_BLOCK | PREV_USED;
-                next_b-&gt;prev_hdr = tmp_b;
-                next_b-&gt;size |= PREV_FREE;
-                MAPPING_INSERT(tmp_size, &amp;fl, &amp;sl);
-                INSERT_BLOCK(tmp_b, tlsf, fl, sl);
-                b-&gt;size = new_size | (b-&gt;size &amp; PREV_STATE);
-            }
-			TLSF_ADD_SIZE(tlsf, b);
-            return (void *) b-&gt;ptr.buffer;
-        }
-    }
-
-    if( ( ptr_aux = malloc_ex(new_size, mem_pool) ) == NULL )
-      return NULL;
-
-    cpsize = ((b-&gt;size &amp; BLOCK_SIZE) &gt; new_size) ? new_size : (b-&gt;size &amp; BLOCK_SIZE);
-
-    memcpy(ptr_aux, ptr, cpsize);
-
-    free_ex(ptr, mem_pool);
-    return ptr_aux;
-}
-
-// Added for eLua: get the size of an allocated block
-size_t tlsf_elua_get_block_size( void* ptr )
-{
-    bhdr_t *b;
-
-    b = (bhdr_t *) ((char *) ptr - BHDR_OVERHEAD);  
-    return b-&gt;size &amp; BLOCK_SIZE;
-}
-
-/******************************************************************/
-void *calloc_ex(size_t nelem, size_t elem_size, void *mem_pool)
-{
-/******************************************************************/
-    void *ptr;
-
-    if (nelem &lt;= 0 || elem_size &lt;= 0)
-        return NULL;
-
-    if (!(ptr = malloc_ex(nelem * elem_size, mem_pool)))
-        return NULL;
-    memset(ptr, 0, nelem * elem_size);
-
-    return ptr;
-}
-
-
-
-#if _DEBUG_TLSF_
-
-/***************  DEBUG FUNCTIONS   **************/
-
-/* The following functions have been designed to ease the debugging of */
-/* the TLSF  structure.  For non-developing  purposes, it may  be they */
-/* haven't too much worth.  To enable them, _DEBUG_TLSF_ must be set.  */
-
-extern void dump_memory_region(unsigned char *mem_ptr, unsigned int size);
-extern void print_block(bhdr_t * b);
-extern void print_tlsf(tlsf_t * tlsf);
-void print_all_blocks(tlsf_t * tlsf);
-
-void dump_memory_region(unsigned char *mem_ptr, unsigned int size)
-{
-
-    unsigned long begin = (unsigned long) mem_ptr;
-    unsigned long end = (unsigned long) mem_ptr + size;
-    int column = 0;
-
-    begin &gt;&gt;= 2;
-    begin &lt;&lt;= 2;
-
-    end &gt;&gt;= 2;
-    end++;
-    end &lt;&lt;= 2;
-
-    PRINT_MSG(&quot;\nMemory region dumped: 0x%lx - 0x%lx\n\n&quot;, begin, end);
-
-    column = 0;
-    PRINT_MSG(&quot;0x%lx &quot;, begin);
-
-    while (begin &lt; end) {
-        if (((unsigned char *) begin)[0] == 0)
-            PRINT_MSG(&quot;00&quot;);
-        else
-            PRINT_MSG(&quot;%02x&quot;, ((unsigned char *) begin)[0]);
-        if (((unsigned char *) begin)[1] == 0)
-            PRINT_MSG(&quot;00 &quot;);
-        else
-            PRINT_MSG(&quot;%02x &quot;, ((unsigned char *) begin)[1]);
-        begin += 2;
-        column++;
-        if (column == 8) {
-            PRINT_MSG(&quot;\n0x%lx &quot;, begin);
-            column = 0;
-        }
-
-    }
-    PRINT_MSG(&quot;\n\n&quot;);
-}
-
-void print_block(bhdr_t * b)
-{
-    if (!b)
-        return;
-    PRINT_MSG(&quot;&gt;&gt; [%p] (&quot;, b);
-    if ((b-&gt;size &amp; BLOCK_SIZE))
-        PRINT_MSG(&quot;%lu bytes, &quot;, (unsigned long) (b-&gt;size &amp; BLOCK_SIZE));
-    else
-        PRINT_MSG(&quot;sentinel, &quot;);
-    if ((b-&gt;size &amp; BLOCK_STATE) == FREE_BLOCK)
-        PRINT_MSG(&quot;free [%p, %p], &quot;, b-&gt;ptr.free_ptr.prev, b-&gt;ptr.free_ptr.next);
-    else
-        PRINT_MSG(&quot;used, &quot;);
-    if ((b-&gt;size &amp; PREV_STATE) == PREV_FREE)
-        PRINT_MSG(&quot;prev. free [%p])\n&quot;, b-&gt;prev_hdr);
-    else
-        PRINT_MSG(&quot;prev used)\n&quot;);
-}
-
-void print_tlsf(tlsf_t * tlsf)
-{
-    bhdr_t *next;
-    int i, j;
-
-    PRINT_MSG(&quot;\nTLSF at %p\n&quot;, tlsf);
-
-    PRINT_MSG(&quot;FL bitmap: 0x%x\n\n&quot;, (unsigned) tlsf-&gt;fl_bitmap);
-
-    for (i = 0; i &lt; REAL_FLI; i++) {
-        if (tlsf-&gt;sl_bitmap[i])
-            PRINT_MSG(&quot;SL bitmap 0x%x\n&quot;, (unsigned) tlsf-&gt;sl_bitmap[i]);
-        for (j = 0; j &lt; MAX_SLI; j++) {
-            next = tlsf-&gt;matrix[i][j];
-            if (next)
-                PRINT_MSG(&quot;-&gt; [%d][%d]\n&quot;, i, j);
-            while (next) {
-                print_block(next);
-                next = next-&gt;ptr.free_ptr.next;
-            }
-        }
-    }
-}
-
-void print_all_blocks(tlsf_t * tlsf)
-{
-    area_info_t *ai;
-    bhdr_t *next;
-    PRINT_MSG(&quot;\nTLSF at %p\nALL BLOCKS\n\n&quot;, tlsf);
-    ai = tlsf-&gt;area_head;
-    while (ai) {
-        next = (bhdr_t *) ((char *) ai - BHDR_OVERHEAD);
-        while (next) {
-            print_block(next);
-            if ((next-&gt;size &amp; BLOCK_SIZE))
-                next = GET_NEXT_BLOCK(next-&gt;ptr.buffer, next-&gt;size &amp; BLOCK_SIZE);
-            else
-                next = NULL;
-        }
-        ai = ai-&gt;next;
-    }
-}
-
-#endif
-
-// Initialize all memory pools for eLua
-void tlsf_elua_init()
-{
-  unsigned i = 0;
-  char *pstart, *pend;
-  
-  while( 1 )
-  {
-    if( ( pstart = ( char* )platform_get_first_free_ram( i ) ) == NULL )
-      break;
-    pstart = ( char* )tlsf_elua_align_addr( pstart );
-    pend = ( char* )platform_get_last_free_ram( i );
-    init_memory_pool( ( size_t )( pend - pstart + 1 ), pstart );
-    i ++;
-  }
-}
-
-// Get the &quot;real&quot; start address (aligned if needed)
-void* tlsf_elua_align_addr( void* ptr )
-{
-  if( ( u32 )ptr &amp; PTR_MASK )
-    ptr = ( void* )( ( ( u32 )ptr + sizeof( void* ) ) &amp; ~PTR_MASK );
-  return ptr;
-}
-
-#else // #ifdef USE_TLSF
-
-void tlsf_elua_init()
-{
-}
-
-#endif // #ifdef USE_TLSF


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000008.html">[Elua-svn] r44 - tags
</A></li>
	<LI>Next message: <A HREF="000010.html">[Elua-svn] r55 - in trunk: . inc src src/newlib
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11">[ date ]</a>
              <a href="thread.html#11">[ thread ]</a>
              <a href="subject.html#11">[ subject ]</a>
              <a href="author.html#11">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/elua-svn">More information about the eLua-svn
mailing list</a><br>
</body></html>
