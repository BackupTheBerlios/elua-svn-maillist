<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Elua-svn] r89 - in trunk: . inc src src/platform/lm3s src/uip
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/elua-svn/2008-September/index.html" >
   <LINK REL="made" HREF="mailto:elua-svn%40lists.berlios.de?Subject=Re%3A%20%5BElua-svn%5D%20r89%20-%20in%20trunk%3A%20.%20inc%20src%20src/platform/lm3s%20src/uip&In-Reply-To=%3C200809152154.m8FLsHgS009585%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000044.html">
   <LINK REL="Next"  HREF="000046.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Elua-svn] r89 - in trunk: . inc src src/platform/lm3s src/uip</H1>
    <B>bogdanm at BerliOS</B> 
    <A HREF="mailto:elua-svn%40lists.berlios.de?Subject=Re%3A%20%5BElua-svn%5D%20r89%20-%20in%20trunk%3A%20.%20inc%20src%20src/platform/lm3s%20src/uip&In-Reply-To=%3C200809152154.m8FLsHgS009585%40sheep.berlios.de%3E"
       TITLE="[Elua-svn] r89 - in trunk: . inc src src/platform/lm3s src/uip">bogdanm at mail.berlios.de
       </A><BR>
    <I>Mon Sep 15 23:54:17 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000044.html">[Elua-svn] r88 - tags
</A></li>
        <LI>Next message: <A HREF="000046.html">[Elua-svn] r90 - trunk/src/platform/lm3s
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#45">[ date ]</a>
              <a href="thread.html#45">[ thread ]</a>
              <a href="subject.html#45">[ subject ]</a>
              <a href="author.html#45">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: bogdanm
Date: 2008-09-15 23:54:14 +0200 (Mon, 15 Sep 2008)
New Revision: 89

Added:
   trunk/inc/elua_uip.h
   trunk/src/elua_uip.c
   trunk/src/platform/lm3s/asmdefs.h
   trunk/src/platform/lm3s/cpu.s
   trunk/src/platform/lm3s/ethernet.c
   trunk/src/platform/lm3s/ethernet.h
   trunk/src/platform/lm3s/ethernet.o
   trunk/src/platform/lm3s/flash.c
   trunk/src/platform/lm3s/flash.h
   trunk/src/platform/lm3s/flash.o
   trunk/src/platform/lm3s/hw_ethernet.h
   trunk/src/platform/lm3s/hw_flash.h
   trunk/src/platform/lm3s/interrupt.c
   trunk/src/platform/lm3s/systick.c
   trunk/src/platform/lm3s/systick.h
   trunk/src/platform/lm3s/uip-conf.h
   trunk/src/platform/lm3s/uip_support.c
   trunk/src/uip/
   trunk/src/uip/clock.h
   trunk/src/uip/lc-addrlabels.h
   trunk/src/uip/lc-switch.h
   trunk/src/uip/lc.h
   trunk/src/uip/psock.c
   trunk/src/uip/psock.h
   trunk/src/uip/pt.h
   trunk/src/uip/timer.c
   trunk/src/uip/timer.h
   trunk/src/uip/uip-fw.c
   trunk/src/uip/uip-fw.h
   trunk/src/uip/uip-neighbor.c
   trunk/src/uip/uip-neighbor.h
   trunk/src/uip/uip-split.c
   trunk/src/uip/uip-split.h
   trunk/src/uip/uip.c
   trunk/src/uip/uip.h
   trunk/src/uip/uip_arch.h
   trunk/src/uip/uip_arp.c
   trunk/src/uip/uip_arp.h
   trunk/src/uip/uiplib.c
   trunk/src/uip/uiplib.h
   trunk/src/uip/uipopt.h
Modified:
   trunk/SConstruct
   trunk/src/main.c
   trunk/src/platform/lm3s/build.h
   trunk/src/platform/lm3s/conf.py
   trunk/src/platform/lm3s/platform.c
   trunk/src/platform/lm3s/startup_gcc.c
Log:
_PRELIMINARY_ TCP/IP support, for now only on Cortex, only with uIP, only ping (ICMP) handling, no actual TCP/IP data transfer. 



Modified: trunk/SConstruct
===================================================================
--- trunk/SConstruct	2008-09-10 18:59:17 UTC (rev 88)
+++ trunk/SConstruct	2008-09-15 21:54:14 UTC (rev 89)
@@ -90,6 +90,7 @@
   print &quot;Board:       &quot;, boardname
   print &quot;Platform:    &quot;, platform
   print &quot;Allocator:   &quot;, allocator
+  print &quot;Target:      &quot;, target
   print &quot;*********************************&quot;
   print    
 
@@ -121,6 +122,11 @@
 # Newlib related files  
 newlib_files = &quot; src/newlib/devman.c src/newlib/stubs.c src/newlib/genstd.c&quot;
 
+# UIP files
+uip_files = &quot;uip_arp.c uip.c uiplib.c&quot;
+uip_files = &quot; src/elua_uip.c &quot; + &quot; &quot;.join( [ &quot;src/uip/%s&quot; % name for name in uip_files.split() ] )
+local_include = local_include + &quot; -Isrc/uip&quot;
+
 # Lua module files
 module_files = &quot;&quot;&quot; src/modules/pio.c src/modules/spi.c src/modules/tmr.c src/modules/pd.c src/modules/uart.c
                    src/modules/term.c src/modules/pwm.c src/modules/lpack.c src/modules/bit.c&quot;&quot;&quot;
@@ -136,7 +142,7 @@
 execfile( &quot;src/platform/%s/conf.py&quot; % platform )
 
 # Complete file list
-source_files = specific_files + newlib_files + app_files + lua_full_files + module_files
+source_files = specific_files + newlib_files + uip_files + app_files + lua_full_files + module_files
   
 # Make filesystem first
 if not GetOption( 'clean' ):

Added: trunk/inc/elua_uip.h
===================================================================
--- trunk/inc/elua_uip.h	2008-09-10 18:59:17 UTC (rev 88)
+++ trunk/inc/elua_uip.h	2008-09-15 21:54:14 UTC (rev 89)
@@ -0,0 +1,16 @@
+// UIP &quot;helper&quot; for eLua
+// Implements the eLua specific UIP application
+
+#ifndef __ELUA_UIP_H__
+#define __ELUA_UIP_H__
+
+// eLua UIP state
+struct elua_uip_state
+{
+  int dummy;
+};
+
+void elua_uip_appcall();
+void elua_uip_init();
+
+#endif

Added: trunk/src/elua_uip.c
===================================================================
--- trunk/src/elua_uip.c	2008-09-10 18:59:17 UTC (rev 88)
+++ trunk/src/elua_uip.c	2008-09-15 21:54:14 UTC (rev 89)
@@ -0,0 +1,20 @@
+#include &quot;build.h&quot;
+#ifdef BUILD_UIP
+
+// UIP &quot;helper&quot; for eLua
+// Implements the eLua specific UIP application
+
+#include &quot;elua_uip.h&quot;
+#include &quot;type.h&quot;
+
+// UIP callback function
+void elua_uip_appcall()
+{
+}
+
+// Init application
+void elua_uip_init()
+{
+}
+
+#endif // #ifdef BUILD_UIP

Modified: trunk/src/main.c
===================================================================
--- trunk/src/main.c	2008-09-10 18:59:17 UTC (rev 88)
+++ trunk/src/main.c	2008-09-15 21:54:14 UTC (rev 89)
@@ -176,7 +176,7 @@
   
   // Initialize terminal
   term_init( TERMINAL_LINES, TERMINAL_COLS, term_out, term_in, term_translate );
-  
+
   // Autorun: if &quot;autorun.lua&quot; is found in the ROM file system, run it first
   if( ( fp = fopen( &quot;/rom/autorun.lua&quot;, &quot;r&quot; ) ) != NULL )
   {

Added: trunk/src/platform/lm3s/asmdefs.h
===================================================================
--- trunk/src/platform/lm3s/asmdefs.h	2008-09-10 18:59:17 UTC (rev 88)
+++ trunk/src/platform/lm3s/asmdefs.h	2008-09-15 21:54:14 UTC (rev 89)
@@ -0,0 +1,211 @@
+//*****************************************************************************
+//
+// asmdefs.h - Macros to allow assembly code be portable among toolchains.
+//
+// Copyright (c) 2005-2008 Luminary Micro, Inc.  All rights reserved.
+// 
+// Software License Agreement
+// 
+// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
+// exclusively on LMI's microcontroller products.
+// 
+// The software is owned by LMI and/or its suppliers, and is protected under
+// applicable copyright laws.  All rights are reserved.  You may not combine
+// this software with &quot;viral&quot; open-source software in order to form a larger
+// program.  Any use in violation of the foregoing restrictions may subject
+// the user to criminal sanctions under applicable laws, as well as to civil
+// liability for the breach of the terms and conditions of this license.
+// 
+// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2752 of the Stellaris Peripheral Driver Library.
+//
+//*****************************************************************************
+
+#ifndef __ASMDEFS_H__
+#define __ASMDEFS_H__
+
+//*****************************************************************************
+//
+// The defines required for code_red.
+//
+//*****************************************************************************
+#ifdef codered
+
+//
+// The assembly code preamble required to put the assembler into the correct
+// configuration.
+//
+    .syntax unified
+    .thumb
+
+//
+// Section headers.
+//
+#define __LIBRARY__             @
+#define __TEXT__                .text
+#define __DATA__                .data
+#define __BSS__                 .bss
+#define __TEXT_NOROOT__         .text
+
+//
+// Assembler nmenonics.
+//
+#define __ALIGN__               .balign 4
+#define __END__                 .end
+#define __EXPORT__              .globl
+#define __IMPORT__              .extern
+#define __LABEL__               :
+#define __STR__                 .ascii
+#define __THUMB_LABEL__         .thumb_func
+#define __WORD__                .word
+
+#endif // codered
+
+//*****************************************************************************
+//
+// The defines required for EW-ARM.
+//
+//*****************************************************************************
+#ifdef ewarm
+
+//
+// Section headers.
+//
+#define __LIBRARY__             module
+#define __TEXT__                rseg CODE:CODE(2)
+#define __DATA__                rseg DATA:DATA(2)
+#define __BSS__                 rseg DATA:DATA(2)
+#define __TEXT_NOROOT__         rseg CODE:CODE:NOROOT(2)
+
+//
+// Assembler nmenonics.
+//
+#define __ALIGN__               alignrom 2
+#define __END__                 end
+#define __EXPORT__              export
+#define __IMPORT__              import
+#define __LABEL__
+#define __STR__                 dcb
+#define __THUMB_LABEL__
+#define __WORD__                dcd
+
+#endif // ewarm
+
+//*****************************************************************************
+//
+// The defines required for GCC.
+//
+//*****************************************************************************
+#if defined(gcc)
+
+//
+// The assembly code preamble required to put the assembler into the correct
+// configuration.
+//
+    .syntax unified
+    .thumb
+
+//
+// Section headers.
+//
+#define __LIBRARY__             @
+#define __TEXT__                .text
+#define __DATA__                .data
+#define __BSS__                 .bss
+#define __TEXT_NOROOT__         .text
+
+//
+// Assembler nmenonics.
+//
+#define __ALIGN__               .balign 4
+#define __END__                 .end
+#define __EXPORT__              .globl
+#define __IMPORT__              .extern
+#define __LABEL__               :
+#define __STR__                 .ascii
+#define __THUMB_LABEL__         .thumb_func
+#define __WORD__                .word
+
+#endif // gcc
+
+//*****************************************************************************
+//
+// The defines required for RV-MDK.
+//
+//*****************************************************************************
+#ifdef rvmdk
+
+//
+// The assembly code preamble required to put the assembler into the correct
+// configuration.
+//
+    thumb
+    require8
+    preserve8
+
+//
+// Section headers.
+//
+#define __LIBRARY__             ;
+#define __TEXT__                area ||.text||, code, readonly, align=2
+#define __DATA__                area ||.data||, data, align=2
+#define __BSS__                 area ||.bss||, noinit, align=2
+#define __TEXT_NOROOT__         area ||.text||, code, readonly, align=2
+
+//
+// Assembler nmenonics.
+//
+#define __ALIGN__               align 4
+#define __END__                 end
+#define __EXPORT__              export
+#define __IMPORT__              import
+#define __LABEL__
+#define __STR__                 dcb
+#define __THUMB_LABEL__
+#define __WORD__                dcd
+
+#endif // rvmdk
+
+//*****************************************************************************
+//
+// The defines required for Sourcery G++.
+//
+//*****************************************************************************
+#if defined(sourcerygxx)
+
+//
+// The assembly code preamble required to put the assembler into the correct
+// configuration.
+//
+    .syntax unified
+    .thumb
+
+//
+// Section headers.
+//
+#define __LIBRARY__             @
+#define __TEXT__                .text
+#define __DATA__                .data
+#define __BSS__                 .bss
+#define __TEXT_NOROOT__         .text
+
+//
+// Assembler nmenonics.
+//
+#define __ALIGN__               .balign 4
+#define __END__                 .end
+#define __EXPORT__              .globl
+#define __IMPORT__              .extern
+#define __LABEL__               :
+#define __STR__                 .ascii
+#define __THUMB_LABEL__         .thumb_func
+#define __WORD__                .word
+
+#endif // sourcerygxx
+
+#endif // __ASMDEF_H__

Modified: trunk/src/platform/lm3s/build.h
===================================================================
--- trunk/src/platform/lm3s/build.h	2008-09-10 18:59:17 UTC (rev 88)
+++ trunk/src/platform/lm3s/build.h	2008-09-15 21:54:14 UTC (rev 89)
@@ -7,5 +7,6 @@
 #define BUILD_SHELL
 #define BUILD_ROMFS
 #define BUILD_TERM
+#define BUILD_UIP
 
 #endif

Modified: trunk/src/platform/lm3s/conf.py
===================================================================
--- trunk/src/platform/lm3s/conf.py	2008-09-10 18:59:17 UTC (rev 88)
+++ trunk/src/platform/lm3s/conf.py	2008-09-15 21:54:14 UTC (rev 89)
@@ -1,6 +1,6 @@
 # Configuration file for the LM3S microcontroller
 
-specific_files = &quot;startup_gcc.c platform.c usart.c sysctl.c gpio.c ssi.c timer.c pwm.c&quot;
+specific_files = &quot;startup_gcc.c platform.c usart.c sysctl.c gpio.c ssi.c timer.c pwm.c ethernet.c systick.c uip_support.c flash.c interrupt.c cpu.s&quot;
 ldscript = &quot;lm3s.ld&quot;
   
 # Prepend with path

Added: trunk/src/platform/lm3s/cpu.s
===================================================================
--- trunk/src/platform/lm3s/cpu.s	2008-09-10 18:59:17 UTC (rev 88)
+++ trunk/src/platform/lm3s/cpu.s	2008-09-15 21:54:14 UTC (rev 89)
@@ -0,0 +1,77 @@
+//*****************************************************************************
+//
+// cpu.S - Instruction wrappers for special CPU instructions needed by the
+//         drivers.
+//
+// Copyright (c) 2006-2008 Luminary Micro, Inc.  All rights reserved.
+// 
+// Software License Agreement
+// 
+// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
+// exclusively on LMI's microcontroller products.
+// 
+// The software is owned by LMI and/or its suppliers, and is protected under
+// applicable copyright laws.  All rights are reserved.  You may not combine
+// this software with &quot;viral&quot; open-source software in order to form a larger
+// program.  Any use in violation of the foregoing restrictions may subject
+// the user to criminal sanctions under applicable laws, as well as to civil
+// liability for the breach of the terms and conditions of this license.
+// 
+// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2752 of the Stellaris Peripheral Driver Library.
+//
+//*****************************************************************************
+
+#include &quot;asmdefs.h&quot;
+
+//*****************************************************************************
+//
+// The entire contents of this file go into the code section.
+//
+//*****************************************************************************
+    __LIBRARY__ __lib_cpu
+    __TEXT_NOROOT__
+
+//*****************************************************************************
+//
+// Wrapper function for the CPSID instruction.  Returns the state of PRIMASK
+// on entry.
+//
+//*****************************************************************************
+    __EXPORT__ CPUcpsid
+    __THUMB_LABEL__
+CPUcpsid __LABEL__
+    mrs     r0, PRIMASK
+    cpsid   i
+    bx      lr
+
+//*****************************************************************************
+//
+// Wrapper function for the CPSIE instruction.  Returns the state of PRIMASK
+// on entry.
+//
+//*****************************************************************************
+    __EXPORT__ CPUcpsie
+    __THUMB_LABEL__
+CPUcpsie __LABEL__
+    mrs     r0, PRIMASK
+    cpsie   i
+    bx      lr
+
+//*****************************************************************************
+//
+// Wrapper function for the WFI instruction.
+//
+//*****************************************************************************
+    __EXPORT__ CPUwfi
+    __THUMB_LABEL__
+CPUwfi __LABEL__
+    wfi
+    bx      lr
+
+    __END__

Added: trunk/src/platform/lm3s/ethernet.c
===================================================================
--- trunk/src/platform/lm3s/ethernet.c	2008-09-10 18:59:17 UTC (rev 88)
+++ trunk/src/platform/lm3s/ethernet.c	2008-09-15 21:54:14 UTC (rev 89)
@@ -0,0 +1,1282 @@
+//*****************************************************************************
+//
+// ethernet.c - Driver for the Integrated Ethernet Controller
+//
+// Copyright (c) 2006-2008 Luminary Micro, Inc.  All rights reserved.
+// 
+// Software License Agreement
+// 
+// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
+// exclusively on LMI's microcontroller products.
+// 
+// The software is owned by LMI and/or its suppliers, and is protected under
+// applicable copyright laws.  All rights are reserved.  You may not combine
+// this software with &quot;viral&quot; open-source software in order to form a larger
+// program.  Any use in violation of the foregoing restrictions may subject
+// the user to criminal sanctions under applicable laws, as well as to civil
+// liability for the breach of the terms and conditions of this license.
+// 
+// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2752 of the Stellaris Peripheral Driver Library.
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+//! \addtogroup ethernet_api
+//! @{
+//
+//*****************************************************************************
+
+#include &quot;hw_ints.h&quot;
+#include &quot;hw_memmap.h&quot;
+#include &quot;hw_types.h&quot;
+#include &quot;hw_ethernet.h&quot;
+#include &quot;debug.h&quot;
+#include &quot;interrupt.h&quot;
+#include &quot;sysctl.h&quot;
+#include &quot;ethernet.h&quot;
+
+//*****************************************************************************
+//
+//! Initializes the Ethernet controller for operation.
+//!
+//! \param ulBase is the base address of the controller.
+//! \param ulEthClk is the rate of the clock supplied to the Ethernet module.
+//!
+//! This function will prepare the Ethernet controller for first time use in
+//! a given hardware/software configuration.  This function should be called
+//! before any other Ethernet API functions are called.
+//!
+//! The peripheral clock will be the same as the processor clock.  This will be
+//! the value returned by SysCtlClockGet(), or it can be explicitly hard-coded
+//! if it is constant and known (to save the code/execution overhead of a call
+//! to SysCtlClockGet()).
+//!
+//! This function replaces the original EthernetInit() API and performs the
+//! same actions.  A macro is provided in &lt;tt&gt;ethernet.h&lt;/tt&gt; to map the
+//! original API to this API.
+//!
+//! \note If the device configuration is changed (for example, the system clock
+//! is reprogrammed to a different speed), then the Ethernet controller must be
+//! disabled by calling the EthernetDisable() function and the controller must
+//! be reinitialized by calling the EthernetInitExpClk() function again.  After
+//! the controller has been reinitialized, the controller should be
+//! reconfigured using the appropriate Ethernet API calls.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+EthernetInitExpClk(unsigned long ulBase, unsigned long ulEthClk)
+{
+    unsigned long ulDiv;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == ETH_BASE);
+
+    //
+    // Set the Management Clock Divider register for access to the PHY
+    // register set (via EthernetPHYRead/Write).
+    //
+    // The MDC clock divided down from the system clock using the following
+    // formula.  A maximum of 2.5MHz is allowed for F(mdc).
+    //
+    //      F(mdc) = F(sys) / (2 * (div + 1))
+    //      div = (F(sys) / (2 * F(mdc))) - 1
+    //      div = (F(sys) / 2 / F(mdc)) - 1
+    //
+    // Note: Because we should round up, to ensure we don't violate the
+    // maximum clock speed, we can simplify this as follows:
+    //
+    //      div = F(sys) / 2 / F(mdc)
+    //
+    // For example, given a system clock of 6.0MHz, and a div value of 1,
+    // the mdc clock would be programmed as 1.5 MHz.
+    //
+    ulDiv = (ulEthClk / 2) / 2500000;
+    HWREG(ulBase + MAC_O_MDV) = (ulDiv &amp; MAC_MDV_DIV_M);
+}
+
+//*****************************************************************************
+//
+//! Sets the configuration of the Ethernet controller.
+//!
+//! \param ulBase is the base address of the controller.
+//! \param ulConfig is the configuration for the controller.
+//!
+//! After the EthernetInitExpClk() function has been called, this API function
+//! can be used to configure the various features of the Ethernet controller.
+//!
+//! The Ethernet controller provides three control registers that are used
+//! to configure the controller's operation.  The transmit control register
+//! provides settings to enable full duplex operation, to auto-generate the
+//! frame check sequence, and to pad the transmit packets to the minimum
+//! length as required by the IEEE standard.  The receive control register
+//! provides settings to enable reception of packets with bad frame check
+//! sequence values and to enable multi-cast or promiscuous modes.  The
+//! timestamp control register provides settings that enable support logic in
+//! the controller that allow the use of the General Purpose Timer 3 to capture
+//! timestamps for the transmitted and received packets.
+//!
+//! The \e ulConfig parameter is the logical OR of the following values:
+//!
+//! - \b ETH_CFG_TS_TSEN - Enable TX and RX interrupt status as CCP timer
+//! inputs
+//! - \b ETH_CFG_RX_BADCRCDIS - Disable reception of packets with a bad CRC
+//! - \b ETH_CFG_RX_PRMSEN - Enable promiscuous mode reception (all packets)
+//! - \b ETH_CFG_RX_AMULEN - Enable reception of multicast packets
+//! - \b ETH_CFG_TX_DPLXEN - Enable full duplex transmit mode
+//! - \b ETH_CFG_TX_CRCEN - Enable transmit with auto CRC generation
+//! - \b ETH_CFG_TX_PADEN - Enable padding of transmit data to minimum size
+//!
+//! These bit-mapped values are programmed into the transmit, receive, and/or
+//! timestamp control register.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+EthernetConfigSet(unsigned long ulBase, unsigned long ulConfig)
+{
+    unsigned long ulTemp;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == ETH_BASE);
+    ASSERT((ulConfig &amp; ~(ETH_CFG_TX_DPLXEN | ETH_CFG_TX_CRCEN |
+                         ETH_CFG_TX_PADEN | ETH_CFG_RX_BADCRCDIS |
+                         ETH_CFG_RX_PRMSEN | ETH_CFG_RX_AMULEN |
+                         ETH_CFG_TS_TSEN)) == 0);
+
+    //
+    // Setup the Transmit Control Register.
+    //
+    ulTemp  = HWREG(ulBase + MAC_O_TCTL);
+    ulTemp &amp;= ~(MAC_TCTL_DUPLEX | MAC_TCTL_CRC | MAC_TCTL_PADEN);
+    ulTemp |= ulConfig &amp; 0x0FF;
+    HWREG(ulBase + MAC_O_TCTL) = ulTemp;
+
+    //
+    // Setup the Receive Control Register.
+    //
+    ulTemp  = HWREG(ulBase + MAC_O_RCTL);
+    ulTemp &amp;= ~(MAC_RCTL_BADCRC | MAC_RCTL_PRMS | MAC_RCTL_AMUL);
+    ulTemp |= (ulConfig &gt;&gt; 8) &amp; 0x0FF;
+    HWREG(ulBase + MAC_O_RCTL) = ulTemp;
+
+    //
+    // Setup the Time Stamp Configuration register.
+    //
+    ulTemp = HWREG(ulBase + MAC_O_TS);
+    ulTemp &amp;= ~(MAC_TS_TSEN);
+    ulTemp |= (ulConfig &gt;&gt; 16) &amp; 0x0FF;
+    HWREG(ulBase + MAC_O_TS) = ulTemp;
+}
+
+//*****************************************************************************
+//
+//! Gets the current configuration of the Ethernet controller.
+//!
+//! \param ulBase is the base address of the controller.
+//!
+//! This function will query the control registers of the Ethernet controller
+//! and return a bit-mapped configuration value.
+//!
+//! \sa The description of the EthernetConfigSet() function provides detailed
+//! information for the bit-mapped configuration values that will be returned.
+//!
+//! \return Returns the bit-mapped Ethernet controller configuration value.
+//
+//*****************************************************************************
+unsigned long
+EthernetConfigGet(unsigned long ulBase)
+{
+    unsigned long ulConfig;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == ETH_BASE);
+
+    //
+    // Read and return the Ethernet controller configuration parameters,
+    // properly shifted into the appropriate bit field positions.
+    //
+    ulConfig = HWREG(ulBase + MAC_O_TS) &lt;&lt; 16;
+    ulConfig |= (HWREG(ulBase + MAC_O_RCTL) &amp; ~(MAC_RCTL_RXEN)) &lt;&lt; 8;
+    ulConfig |= HWREG(ulBase + MAC_O_TCTL) &amp; ~(MAC_TCTL_TXEN);
+    return(ulConfig);
+}
+
+//*****************************************************************************
+//
+//! Sets the MAC address of the Ethernet controller.
+//!
+//! \param ulBase is the base address of the controller.
+//! \param pucMACAddr is the pointer to the array of MAC-48 address octets.
+//!
+//! This function will program the IEEE-defined MAC-48 address specified in
+//! \e pucMACAddr into the Ethernet controller.  This address is used by the
+//! Ethernet controller for hardware-level filtering of incoming Ethernet
+//! packets (when promiscuous mode is not enabled).
+//!
+//! The MAC-48 address is defined as 6 octets, illustrated by the following
+//! example address.  The numbers are shown in hexadecimal format.
+//!
+//!         AC-DE-48-00-00-80
+//!
+//! In this representation, the first three octets (AC-DE-48) are the
+//! Organizationally Unique Identifier (OUI).  This is a number assigned by
+//! the IEEE to an organization that requests a block of MAC addresses.  The
+//! last three octets (00-00-80) are a 24-bit number managed by the OUI owner
+//! to uniquely identify a piece of hardware within that organization that is
+//! to be connected to the Ethernet.
+//!
+//! In this representation, the octets are transmitted from left to right,
+//! with the ``AC'' octet being transmitted first and the ``80'' octet being
+//! transmitted last.  Within an octet, the bits are transmitted LSB to MSB.
+//! For this address, the first bit to be transmitted would be ``0'', the LSB
+//! of ``AC'', and the last bit to be transmitted would be ``1'', the MSB of
+//! ``80''.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+EthernetMACAddrSet(unsigned long ulBase, unsigned char *pucMACAddr)
+{
+    unsigned long ulTemp;
+    unsigned char *pucTemp = (unsigned char *)&ulTemp;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == ETH_BASE);
+    ASSERT(pucMACAddr != 0);
+
+    //
+    // Program the MAC Address into the device.  The first four bytes of the
+    // MAC Address are placed into the IA0 register.  The remaining two bytes
+    // of the MAC address are placed into the IA1 register.
+    //
+    pucTemp[0] = pucMACAddr[0];
+    pucTemp[1] = pucMACAddr[1];
+    pucTemp[2] = pucMACAddr[2];
+    pucTemp[3] = pucMACAddr[3];
+    HWREG(ulBase + MAC_O_IA0) = ulTemp;
+    ulTemp = 0;
+    pucTemp[0] = pucMACAddr[4];
+    pucTemp[1] = pucMACAddr[5];
+    HWREG(ulBase + MAC_O_IA1) = ulTemp;
+}
+
+//*****************************************************************************
+//
+//! Gets the MAC address of the Ethernet controller.
+//!
+//! \param ulBase is the base address of the controller.
+//! \param pucMACAddr is the pointer to the location in which to store the
+//! array of MAC-48 address octets.
+//!
+//! This function will read the currently programmed MAC address into the
+//! \e pucMACAddr buffer.
+//!
+//! \sa Refer to EthernetMACAddrSet() API description for more details about
+//! the MAC address format.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+EthernetMACAddrGet(unsigned long ulBase, unsigned char *pucMACAddr)
+{
+    unsigned long ulTemp;
+    unsigned char *pucTemp = (unsigned char *)&ulTemp;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == ETH_BASE);
+    ASSERT(pucMACAddr != 0);
+
+    //
+    // Read the MAC address from the device.  The first four bytes of the
+    // MAC address are read from the IA0 register.  The remaining two bytes
+    // of the MAC addres
+    //
+    ulTemp = HWREG(ulBase + MAC_O_IA0);
+    pucMACAddr[0] = pucTemp[0];
+    pucMACAddr[1] = pucTemp[1];
+    pucMACAddr[2] = pucTemp[2];
+    pucMACAddr[3] = pucTemp[3];
+    ulTemp = HWREG(ulBase + MAC_O_IA1);
+    pucMACAddr[4] = pucTemp[0];
+    pucMACAddr[5] = pucTemp[1];
+}
+
+//*****************************************************************************
+//
+//! Enables the Ethernet controller for normal operation.
+//!
+//! \param ulBase is the base address of the controller.
+//!
+//! Once the Ethernet controller has been configured using the
+//! EthernetConfigSet() function and the MAC address has been programmed using
+//! the EthernetMACAddrSet() function, this API function can be called to
+//! enable the controller for normal operation.
+//!
+//! This function will enable the controller's transmitter and receiver, and
+//! will reset the receive FIFO.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+EthernetEnable(unsigned long ulBase)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == ETH_BASE);
+
+    //
+    // Reset the receive FIFO.
+    //
+    HWREG(ulBase + MAC_O_RCTL) |= MAC_RCTL_RSTFIFO;
+
+    //
+    // Enable the Ethernet receiver.
+    //
+    HWREG(ulBase + MAC_O_RCTL) |= MAC_RCTL_RXEN;
+
+    //
+    // Enable Ethernet transmitter.
+    //
+    HWREG(ulBase + MAC_O_TCTL) |= MAC_TCTL_TXEN;
+
+    //
+    // Reset the receive FIFO again, after the receiver has been enabled.
+    //
+    HWREG(ulBase + MAC_O_RCTL) |= MAC_RCTL_RSTFIFO;
+}
+
+//*****************************************************************************
+//
+//! Disables the Ethernet controller.
+//!
+//! \param ulBase is the base address of the controller.
+//!
+//! When terminating operations on the Ethernet interface, this function should
+//! be called.  This function will disable the transmitter and receiver, and
+//! will clear out the receive FIFO.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+EthernetDisable(unsigned long ulBase)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == ETH_BASE);
+
+    //
+    // Reset the receive FIFO.
+    //
+    HWREG(ulBase + MAC_O_RCTL) |= MAC_RCTL_RSTFIFO;
+
+    //
+    // Disable the Ethernet transmitter.
+    //
+    HWREG(ulBase + MAC_O_TCTL) &amp;= ~(MAC_TCTL_TXEN);
+
+    //
+    // Disable the Ethernet receiver.
+    //
+    HWREG(ulBase + MAC_O_RCTL) &amp;= ~(MAC_RCTL_RXEN);
+
+    //
+    // Reset the receive FIFO again, after the receiver has been disabled.
+    //
+    HWREG(ulBase + MAC_O_RCTL) |= MAC_RCTL_RSTFIFO;
+}
+
+//*****************************************************************************
+//
+//! Check for packet available from the Ethernet controller.
+//!
+//! \param ulBase is the base address of the controller.
+//!
+//! The Ethernet controller provides a register that contains the number of
+//! packets available in the receive FIFO.  When the last bytes of a packet are
+//! successfully received (that is, the frame check sequence bytes), the packet
+//! count is incremented.  Once the packet has been fully read (including the
+//! frame check sequence bytes) from the FIFO, the packet count will be
+//! decremented.
+//!
+//! \return Returns \b true if there are one or more packets available in the
+//! receive FIFO, including the current packet being read, and \b false
+//! otherwise.
+//
+//*****************************************************************************
+tBoolean
+EthernetPacketAvail(unsigned long ulBase)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == ETH_BASE);
+
+    //
+    // Return the availability of packets.
+    //
+    return((HWREG(ulBase + MAC_O_NP) &amp; MAC_NP_NPR_M) ? true : false);
+}
+
+//*****************************************************************************
+//
+//! Checks for packet space available in the Ethernet controller.
+//!
+//! \param ulBase is the base address of the controller.
+//!
+//! The Ethernet controller's transmit FIFO is designed to support a single
+//! packet at a time.  After the packet has been written into the FIFO, the
+//! transmit request bit must be set to enable the transmission of the packet.
+//! Only after the packet has been transmitted can a new packet be written
+//! into the FIFO.  This function will simply check to see if a packet is
+//! in progress.  If so, there is no space available in the transmit FIFO.
+//!
+//! \return Returns \b true if a space is available in the transmit FIFO, and
+//! \b false otherwise.
+//
+//*****************************************************************************
+tBoolean
+EthernetSpaceAvail(unsigned long ulBase)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == ETH_BASE);
+
+    //
+    // Return the availability of space.
+    //
+    return((HWREG(ulBase + MAC_O_TR) &amp; MAC_TR_NEWTX) ? false : true);
+}
+
+//*****************************************************************************
+//
+//! \internal
+//!
+//! Internal function for reading a packet from the Ethernet controller.
+//!
+//! \param ulBase is the base address of the controller.
+//! \param pucBuf is the pointer to the packet buffer.
+//! \param lBufLen is the maximum number of bytes to be read into the buffer.
+//!
+//! Based on the following table of how the receive frame is stored in the
+//! receive FIFO, this function will extract a packet from the FIFO and store
+//! it in the packet buffer that was passed in.
+//!
+//! Format of the data in the RX FIFO is as follows:
+//!
+//! \verbatim
+//! +---------+----------+----------+----------+----------+
+//! |         | 31:24    | 23:16    | 15:8     | 7:0      |
+//! +---------+----------+----------+----------+----------+
+//! | Word 0  | DA 2     | DA 1     | FL MSB   | FL LSB   |
+//! +---------+----------+----------+----------+----------+
+//! | Word 1  | DA 6     | DA 5     | DA 4     | DA 3     |
+//! +---------+----------+----------+----------+----------+
+//! | Word 2  | SA 4     | SA 3     | SA 2     | SA 1     |
+//! +---------+----------+----------+----------+----------+
+//! | Word 3  | FT LSB   | FT MSB   | SA 6     | SA 5     |
+//! +---------+----------+----------+----------+----------+
+//! | Word 4  | DATA 4   | DATA 3   | DATA 2   | DATA 1   |
+//! +---------+----------+----------+----------+----------+
+//! | Word 5  | DATA 8   | DATA 7   | DATA 6   | DATA 5   |
+//! +---------+----------+----------+----------+----------+
+//! | Word 6  | DATA 12  | DATA 11  | DATA 10  | DATA 9   |
+//! +---------+----------+----------+----------+----------+
+//! | ...     |          |          |          |          |
+//! +---------+----------+----------+----------+----------+
+//! | Word X  | DATA n   | DATA n-1 | DATA n-2 | DATA n-3 |
+//! +---------+----------+----------+----------+----------+
+//! | Word Y  | FCS 4    | FCS 3    | FCS 2    | FCS 1    |
+//! +---------+----------+----------+----------+----------+
+//! \endverbatim
+//!
+//! Where FL is Frame Length, (FL + DA + SA + FT + DATA + FCS) Bytes.
+//! Where DA is Destination (MAC) Address.
+//! Where SA is Source (MAC) Address.
+//! Where FT is Frame Type (or Frame Length for Ethernet).
+//! Where DATA is Payload Data for the Ethernet Frame.
+//! Where FCS is the Frame Check Sequence.
+//!
+//! \return Returns the negated packet length \b -n if the packet is too large
+//! for \e pucBuf, and returns the packet length \b n otherwise.
+//
+//*****************************************************************************
+static long
+EthernetPacketGetInternal(unsigned long ulBase, unsigned char *pucBuf,
+                          long lBufLen)
+{
+    unsigned long ulTemp;
+    long lFrameLen, lTempLen;
+    long i = 0;
+
+    //
+    // Read WORD 0 (see format above) from the FIFO, set the receive
+    // Frame Length and store the first two bytes of the destination
+    // address in the receive buffer.
+    //
+    ulTemp = HWREG(ulBase + MAC_O_DATA);
+    lFrameLen = (long)(ulTemp &amp; 0xFFFF);
+    pucBuf[i++] = (unsigned char) ((ulTemp &gt;&gt; 16) &amp; 0xff);
+    pucBuf[i++] = (unsigned char) ((ulTemp &gt;&gt; 24) &amp; 0xff);
+
+    //
+    // Read all but the last WORD into the receive buffer.
+    //
+    lTempLen = (lBufLen &lt; (lFrameLen - 6)) ? lBufLen : (lFrameLen - 6);
+    while(i &lt;= (lTempLen - 4))
+    {
+        *(unsigned long *)&amp;pucBuf[i] = HWREG(ulBase + MAC_O_DATA);
+        i += 4;
+    }
+
+    //
+    // Read the last 1, 2, or 3 BYTES into the buffer
+    //
+    if(i &lt; lTempLen)
+    {
+        ulTemp = HWREG(ulBase + MAC_O_DATA);
+        if(i == lTempLen - 3)
+        {
+            pucBuf[i++] = ((ulTemp &gt;&gt;  0) &amp; 0xff);
+            pucBuf[i++] = ((ulTemp &gt;&gt;  8) &amp; 0xff);
+            pucBuf[i++] = ((ulTemp &gt;&gt; 16) &amp; 0xff);
+            i += 1;
+        }
+        else if(i == lTempLen - 2)
+        {
+            pucBuf[i++] = ((ulTemp &gt;&gt;  0) &amp; 0xff);
+            pucBuf[i++] = ((ulTemp &gt;&gt;  8) &amp; 0xff);
+            i += 2;
+        }
+        else if(i == lTempLen - 1)
+        {
+            pucBuf[i++] = ((ulTemp &gt;&gt;  0) &amp; 0xff);
+            i += 3;
+        }
+    }
+
+    //
+    // Read any remaining WORDS (that did not fit into the buffer).
+    //
+    while(i &lt; (lFrameLen - 2))
+    {
+        ulTemp = HWREG(ulBase + MAC_O_DATA);
+        i += 4;
+    }
+
+    //
+    // If frame was larger than the buffer, return the &quot;negative&quot; frame length
+    //
+    lFrameLen -= 6;
+    if(lFrameLen &gt; lBufLen)
+    {
+        return(-lFrameLen);
+    }
+
+    //
+    // Return the Frame Length
+    //
+    return(lFrameLen);
+}
+
+//*****************************************************************************
+//
+//! Receives a packet from the Ethernet controller.
+//!
+//! \param ulBase is the base address of the controller.
+//! \param pucBuf is the pointer to the packet buffer.
+//! \param lBufLen is the maximum number of bytes to be read into the buffer.
+//!
+//! This function reads a packet from the receive FIFO of the controller and
+//! places it into \e pucBuf.  If no packet is available the function will
+//! return immediately.  Otherwise, the function will read the entire packet
+//! from the receive FIFO.  If there are more bytes in the packet than will fit
+//! into \e pucBuf (as specified by \e lBufLen), the function will return the
+//! negated length of the packet and the buffer will contain \e lBufLen bytes
+//! of the packet.  Otherwise, the function will return the length of the
+//! packet that was read and \e pucBuf will contain the entire packet
+//! (excluding the frame check sequence bytes).
+//!
+//! This function replaces the original EthernetPacketNonBlockingGet() API and
+//! performs the same actions.  A macro is provided in &lt;tt&gt;ethernet.h&lt;/tt&gt; to
+//! map the original API to this API.
+//!
+//! \note This function will return immediately if no packet is available.
+//!
+//! \return Returns \b 0 if no packet is available, the negated packet length
+//! \b -n if the packet is too large for \e pucBuf, and the packet length \b n
+//! otherwise.
+//
+//*****************************************************************************
+long
+EthernetPacketGetNonBlocking(unsigned long ulBase, unsigned char *pucBuf,
+                             long lBufLen)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == ETH_BASE);
+    ASSERT(pucBuf != 0);
+    ASSERT(lBufLen &gt; 0);
+
+    //
+    // Check to see if any packets are available.
+    //
+    if((HWREG(ulBase + MAC_O_NP) &amp; MAC_NP_NPR_M) == 0)
+    {
+        return(0);
+    }
+
+    //
+    // Read the packet, and return.
+    //
+    return(EthernetPacketGetInternal(ulBase, pucBuf, lBufLen));
+}
+
+//*****************************************************************************
+//
+//! Waits for a packet from the Ethernet controller.
+//!
+//! \param ulBase is the base address of the controller.
+//! \param pucBuf is the pointer to the packet buffer.
+//! \param lBufLen is the maximum number of bytes to be read into the buffer.
+//!
+//! This function reads a packet from the receive FIFO of the controller and
+//! places it into \e pucBuf.  The function will wait until a packet is
+//! available in the FIFO.  Then the function will read the entire packet
+//! from the receive FIFO.  If there are more bytes in the packet than will
+//! fit into \e pucBuf (as specified by \e lBufLen), the function will return
+//! the negated length of the packet and the buffer will contain \e lBufLen
+//! bytes of the packet.  Otherwise, the function will return the length of
+//! the packet that was read and \e pucBuf will contain the entire packet
+//! (excluding the frame check sequence bytes).
+//!
+//! \note This function is blocking and will not return until a packet arrives.
+//!
+//! \return Returns the negated packet length \b -n if the packet is too large
+//! for \e pucBuf, and returns the packet length \b n otherwise.
+//
+//*****************************************************************************
+long
+EthernetPacketGet(unsigned long ulBase, unsigned char *pucBuf,
+                  long lBufLen)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == ETH_BASE);
+    ASSERT(pucBuf != 0);
+    ASSERT(lBufLen &gt; 0);
+
+    //
+    // Wait for a packet to become available
+    //
+    while((HWREG(ulBase + MAC_O_NP) &amp; MAC_NP_NPR_M) == 0)
+    {
+    }
+
+    //
+    // Read the packet
+    //
+    return(EthernetPacketGetInternal(ulBase, pucBuf, lBufLen));
+}
+
+//*****************************************************************************
+//
+//! \internal
+//!
+//! Internal function for sending a packet to the Ethernet controller.
+//!
+//! \param ulBase is the base address of the controller.
+//! \param pucBuf is the pointer to the packet buffer.
+//! \param lBufLen is number of bytes in the packet to be transmitted.
+//!
+//! Puts a packet into the transmit FIFO of the controller.
+//!
+//! Format of the data in the TX FIFO is as follows:
+//!
+//! \verbatim
+//! +---------+----------+----------+----------+----------+
+//! |         | 31:24    | 23:16    | 15:8     | 7:0      |
+//! +---------+----------+----------+----------+----------+
+//! | Word 0  | DA 2     | DA 1     | PL MSB   | PL LSB   |
+//! +---------+----------+----------+----------+----------+
+//! | Word 1  | DA 6     | DA 5     | DA 4     | DA 3     |
+//! +---------+----------+----------+----------+----------+
+//! | Word 2  | SA 4     | SA 3     | SA 2     | SA 1     |
+//! +---------+----------+----------+----------+----------+
+//! | Word 3  | FT LSB   | FT MSB   | SA 6     | SA 5     |
+//! +---------+----------+----------+----------+----------+
+//! | Word 4  | DATA 4   | DATA 3   | DATA 2   | DATA 1   |
+//! +---------+----------+----------+----------+----------+
+//! | Word 5  | DATA 8   | DATA 7   | DATA 6   | DATA 5   |
+//! +---------+----------+----------+----------+----------+
+//! | Word 6  | DATA 12  | DATA 11  | DATA 10  | DATA 9   |
+//! +---------+----------+----------+----------+----------+
+//! | ...     |          |          |          |          |
+//! +---------+----------+----------+----------+----------+
+//! | Word X  | DATA n   | DATA n-1 | DATA n-2 | DATA n-3 |
+//! +---------+----------+----------+----------+----------+
+//! \endverbatim
+//!
+//! Where PL is Payload Length, (DATA) only
+//! Where DA is Destination (MAC) Address
+//! Where SA is Source (MAC) Address
+//! Where FT is Frame Type (or Frame Length for Ethernet)
+//! Where DATA is Payload Data for the Ethernet Frame
+//!
+//! \return Returns the negated packet length \b -lBufLen if the packet is too
+//! large for FIFO, and the packet length \b lBufLen otherwise.
+//
+//*****************************************************************************
+static long
+EthernetPacketPutInternal(unsigned long ulBase, unsigned char *pucBuf,
+                          long lBufLen)
+{
+    unsigned long ulTemp;
+    long i = 0;
+
+    //
+    // If the packet is too large, return the negative packet length as
+    // an error code.
+    //
+    if(lBufLen &gt; (2048 - 2))
+    {
+        return(-lBufLen);
+    }
+
+    //
+    // Build and write WORD 0 (see format above) to the transmit FIFO.
+    //
+    ulTemp = (unsigned long)(lBufLen - 14);
+    ulTemp |= (pucBuf[i++] &lt;&lt; 16);
+    ulTemp |= (pucBuf[i++] &lt;&lt; 24);
+    HWREG(ulBase + MAC_O_DATA) = ulTemp;
+
+    //
+    // Write each subsequent WORD n to the transmit FIFO, except for the last
+    // WORD (if the word does not contain 4 bytes).
+    //
+    while(i &lt;= (lBufLen - 4))
+    {
+        HWREG(ulBase + MAC_O_DATA) = *(unsigned long *)&amp;pucBuf[i];
+        i += 4;
+    }
+
+    //
+    // Build the last word of the remaining 1, 2, or 3 bytes, and store
+    // the WORD into the transmit FIFO.
+    //
+    if(i != lBufLen)
+    {
+        if(i == (lBufLen - 3))
+        {
+            ulTemp  = (pucBuf[i++] &lt;&lt;  0);
+            ulTemp |= (pucBuf[i++] &lt;&lt;  8);
+            ulTemp |= (pucBuf[i++] &lt;&lt; 16);
+            HWREG(ulBase + MAC_O_DATA) = ulTemp;
+        }
+        else if(i == (lBufLen - 2))
+        {
+            ulTemp  = (pucBuf[i++] &lt;&lt;  0);
+            ulTemp |= (pucBuf[i++] &lt;&lt;  8);
+            HWREG(ulBase + MAC_O_DATA) = ulTemp;
+        }
+        else if(i == (lBufLen - 1))
+        {
+            ulTemp  = (pucBuf[i++] &lt;&lt;  0);
+            HWREG(ulBase + MAC_O_DATA) = ulTemp;
+        }
+    }
+
+    //
+    // Activate the transmitter
+    //
+    HWREG(ulBase + MAC_O_TR) = MAC_TR_NEWTX;
+
+    //
+    // Return the Buffer Length transmitted.
+    //
+    return(lBufLen);
+}
+
+//*****************************************************************************
+//
+//! Sends a packet to the Ethernet controller.
+//!
+//! \param ulBase is the base address of the controller.
+//! \param pucBuf is the pointer to the packet buffer.
+//! \param lBufLen is number of bytes in the packet to be transmitted.
+//!
+//! This function writes \e lBufLen bytes of the packet contained in \e pucBuf
+//! into the transmit FIFO of the controller and then activates the
+//! transmitter for this packet.  If no space is available in the FIFO, the
+//! function will return immediately.  If space is available, the
+//! function will return once \e lBufLen bytes of the packet have been placed
+//! into the FIFO and the transmitter has been started.  The function will not
+//! wait for the transmission to complete.  The function will return the
+//! negated \e lBufLen if the length is larger than the space available in
+//! the transmit FIFO.
+//!
+//! This function replaces the original EthernetPacketNonBlockingPut() API and
+//! performs the same actions.  A macro is provided in &lt;tt&gt;ethernet.h&lt;/tt&gt; to
+//! map the original API to this API.
+//!
+//! \note This function does not block and will return immediately if no space
+//! is available for the transmit packet.
+//!
+//! \return Returns \b 0 if no space is available in the transmit FIFO, the
+//! negated packet length \b -lBufLen if the packet is too large for FIFO, and
+//! the packet length \b lBufLen otherwise.
+//
+//*****************************************************************************
+long
+EthernetPacketPutNonBlocking(unsigned long ulBase, unsigned char *pucBuf,
+                             long lBufLen)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == ETH_BASE);
+    ASSERT(pucBuf != 0);
+    ASSERT(lBufLen &gt; 0);
+
+    //
+    // Check if the transmit FIFO is in use and return the appropriate code.
+    //
+    if(HWREG(ulBase + MAC_O_TR) &amp; MAC_TR_NEWTX)
+    {
+        return(0);
+    }
+
+    //
+    // Send the packet and return.
+    //
+    return(EthernetPacketPutInternal(ulBase, pucBuf, lBufLen));
+}
+
+//*****************************************************************************
+//
+//! Waits to send a packet from the Ethernet controller.
+//!
+//! \param ulBase is the base address of the controller.
+//! \param pucBuf is the pointer to the packet buffer.
+//! \param lBufLen is number of bytes in the packet to be transmitted.
+//!
+//! This function writes \e lBufLen bytes of the packet contained in \e pucBuf
+//! into the transmit FIFO of the controller and then activates the transmitter
+//! for this packet.  This function will wait until the transmit FIFO is empty.
+//! Once space is available, the function will return once \e lBufLen bytes of
+//! the packet have been placed into the FIFO and the transmitter has been
+//! started.  The function will not wait for the transmission to complete.  The
+//! function will return the negated \e lBufLen if the length is larger than
+//! the space available in the transmit FIFO.
+//!
+//! \note This function blocks and will wait until space is available for the
+//! transmit packet before returning.
+//!
+//! \return Returns the negated packet length \b -lBufLen if the packet is too
+//! large for FIFO, and the packet length \b lBufLen otherwise.
+//
+//*****************************************************************************
+long
+EthernetPacketPut(unsigned long ulBase, unsigned char *pucBuf,
+                  long lBufLen)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == ETH_BASE);
+    ASSERT(pucBuf != 0);
+    ASSERT(lBufLen &gt; 0);
+
+    //
+    // Wait for current packet (if any) to complete.
+    //
+    while(HWREG(ulBase + MAC_O_TR) &amp; MAC_TR_NEWTX)
+    {
+    }
+
+    //
+    // Send the packet and return.
+    //
+    return(EthernetPacketPutInternal(ulBase, pucBuf, lBufLen));
+}
+
+//*****************************************************************************
+//
+//! Registers an interrupt handler for an Ethernet interrupt.
+//!
+//! \param ulBase is the base address of the controller.
+//! \param pfnHandler is a pointer to the function to be called when the
+//! enabled Ethernet interrupts occur.
+//!
+//! This function sets the handler to be called when the Ethernet interrupt
+//! occurs.  This will enable the global interrupt in the interrupt controller;
+//! specific Ethernet interrupts must be enabled via EthernetIntEnable().  It
+//! is the interrupt handler's responsibility to clear the interrupt source.
+//!
+//! \sa IntRegister() for important information about registering interrupt
+//! handlers.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+EthernetIntRegister(unsigned long ulBase, void (*pfnHandler)(void))
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == ETH_BASE);
+    ASSERT(pfnHandler != 0);
+
+    //
+    // Register the interrupt handler.
+    //
+    IntRegister(INT_ETH, pfnHandler);
+
+    //
+    // Enable the Ethernet interrupt.
+    //
+    IntEnable(INT_ETH);
+}
+
+//*****************************************************************************
+//
+//! Unregisters an interrupt handler for an Ethernet interrupt.
+//!
+//! \param ulBase is the base address of the controller.
+//!
+//! This function unregisters the interrupt handler.  This will disable the
+//! global interrupt in the interrupt controller so that the interrupt handler
+//! no longer is called.
+//!
+//! \sa IntRegister() for important information about registering interrupt
+//! handlers.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+EthernetIntUnregister(unsigned long ulBase)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == ETH_BASE);
+
+    //
+    // Disable the interrupt.
+    //
+    IntDisable(INT_ETH);
+
+    //
+    // Unregister the interrupt handler.
+    //
+    IntUnregister(INT_ETH);
+}
+
+//*****************************************************************************
+//
+//! Enables individual Ethernet interrupt sources.
+//!
+//! \param ulBase is the base address of the controller.
+//! \param ulIntFlags is the bit mask of the interrupt sources to be enabled.
+//!
+//! Enables the indicated Ethernet interrupt sources.  Only the sources that
+//! are enabled can be reflected to the processor interrupt; disabled sources
+//! have no effect on the processor.
+//!
+//! The \e ulIntFlags parameter is the logical OR of any of the following:
+//!
+//! - \b ETH_INT_PHY - An interrupt from the PHY has occurred.  The integrated
+//! PHY supports a number of interrupt conditions.  The PHY register, PHY_MR17,
+//! must be read to determine which PHY interrupt has occurred.  This register
+//! can be read using the EthernetPHYRead() API function.
+//! - \b ETH_INT_MDIO - This interrupt indicates that a transaction on the
+//! management interface has completed successfully.
+//! - \b ETH_INT_RXER - This interrupt indicates that an error has occurred
+//! during reception of a frame.  This error can indicate a length mismatch, a
+//! CRC failure, or an error indication from the PHY.
+//! - \b ETH_INT_RXOF - This interrupt indicates that a frame has been received
+//! that exceeds the available space in the RX FIFO.
+//! - \b ETH_INT_TX - This interrupt indicates that the packet stored in the TX
+//! FIFO has been successfully transmitted.
+//! - \b ETH_INT_TXER - This interrupt indicates that an error has occurred
+//! during the transmission of a packet.  This error can be either a retry
+//! failure during the back-off process, or an invalid length stored in the TX
+//! FIFO.
+//! - \b ETH_INT_RX - This interrupt indicates that one (or more) packets are
+//! available in the RX FIFO for processing.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+EthernetIntEnable(unsigned long ulBase, unsigned long ulIntFlags)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == ETH_BASE);
+    ASSERT(!(ulIntFlags &amp; ~(ETH_INT_PHY | ETH_INT_MDIO | ETH_INT_RXER |
+                            ETH_INT_RXOF | ETH_INT_TX | ETH_INT_TXER |
+                            ETH_INT_RX)));
+
+    //
+    // Enable the specified interrupts.
+    //
+    HWREG(ulBase + MAC_O_IM) |= ulIntFlags;
+}
+
+//*****************************************************************************
+//
+//! Disables individual Ethernet interrupt sources.
+//!
+//! \param ulBase is the base address of the controller.
+//! \param ulIntFlags is the bit mask of the interrupt sources to be disabled.
+//!
+//! Disables the indicated Ethernet interrupt sources.  Only the sources that
+//! are enabled can be reflected to the processor interrupt; disabled sources
+//! have no effect on the processor.
+//!
+//! The \e ulIntFlags parameter has the same definition as the \e ulIntFlags
+//! parameter to EthernetIntEnable().
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+EthernetIntDisable(unsigned long ulBase, unsigned long ulIntFlags)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == ETH_BASE);
+    ASSERT(!(ulIntFlags &amp; ~(ETH_INT_PHY | ETH_INT_MDIO | ETH_INT_RXER |
+                            ETH_INT_RXOF | ETH_INT_TX | ETH_INT_TXER |
+                            ETH_INT_RX)));
+
+    //
+    // Disable the specified interrupts.
+    //
+    HWREG(ulBase + MAC_O_IM) &amp;= ~ulIntFlags;
+}
+
+//*****************************************************************************
+//
+//! Gets the current Ethernet interrupt status.
+//!
+//! \param ulBase is the base address of the controller.
+//! \param bMasked is false if the raw interrupt status is required and true
+//! if the masked interrupt status is required.
+//!
+//! This returns the interrupt status for the Ethernet controller.  Either the
+//! raw interrupt status or the status of interrupts that are allowed to
+//! reflect to the processor can be returned.
+//!
+//! \return Returns the current interrupt status, enumerated as a bit field of
+//! values described in EthernetIntEnable().
+//
+//*****************************************************************************
+unsigned long
+EthernetIntStatus(unsigned long ulBase, tBoolean bMasked)
+{
+    unsigned long ulStatus;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == ETH_BASE);
+
+    //
+    // Read the unmasked status.
+    //
+    ulStatus = HWREG(ulBase + MAC_O_RIS);
+
+    //
+    // If masked status is requested, mask it off.
+    //
+    if(bMasked)
+    {
+        ulStatus &amp;= HWREG(ulBase + MAC_O_IM);
+    }
+
+    //
+    // Return the interrupt status value.
+    //
+    return(ulStatus);
+}
+
+//*****************************************************************************
+//
+//! Clears Ethernet interrupt sources.
+//!
+//! \param ulBase is the base address of the controller.
+//! \param ulIntFlags is a bit mask of the interrupt sources to be cleared.
+//!
+//! The specified Ethernet interrupt sources are cleared so that they no longer
+//! assert.  This must be done in the interrupt handler to keep it from being
+//! called again immediately upon exit.
+//!
+//! The \e ulIntFlags parameter has the same definition as the \e ulIntFlags
+//! parameter to EthernetIntEnable().
+//!
+//! \note Since there is a write buffer in the Cortex-M3 processor, it may take
+//! several clock cycles before the interrupt source is actually cleared.
+//! Therefore, it is recommended that the interrupt source be cleared early in
+//! the interrupt handler (as opposed to the very last action) to avoid
+//! returning from the interrupt handler before the interrupt source is
+//! actually cleared.  Failure to do so may result in the interrupt handler
+//! being immediately reentered (since NVIC still sees the interrupt source
+//! asserted).
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+EthernetIntClear(unsigned long ulBase, unsigned long ulIntFlags)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == ETH_BASE);
+    ASSERT(!(ulIntFlags &amp; ~(ETH_INT_PHY | ETH_INT_MDIO | ETH_INT_RXER |
+                            ETH_INT_RXOF | ETH_INT_TX | ETH_INT_TXER |
+                            ETH_INT_RX)));
+
+    //
+    // Clear the requested interrupt sources.
+    //
+    HWREG(ulBase + MAC_O_IACK) = ulIntFlags;
+}
+
+//*****************************************************************************
+//
+//! Writes to the PHY register.
+//!
+//! \param ulBase is the base address of the controller.
+//! \param ucRegAddr is the address of the PHY register to be accessed.
+//! \param ulData is the data to be written to the PHY register.
+//!
+//! This function will write the \e ulData to the PHY register specified by
+//! \e ucRegAddr.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+EthernetPHYWrite(unsigned long ulBase, unsigned char ucRegAddr,
+                 unsigned long ulData)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == ETH_BASE);
+
+    //
+    // Wait for any pending transaction to complete.
+    //
+    while(HWREG(ulBase + MAC_O_MCTL) &amp; MAC_MCTL_START)
+    {
+    }
+
+    //
+    // Program the DATA to be written.
+    //
+    HWREG(ulBase + MAC_O_MTXD) = ulData &amp; MAC_MTXD_MDTX_M;
+
+    //
+    // Program the PHY register address and initiate the transaction.
+    //
+    HWREG(ulBase + MAC_O_MCTL) = (((ucRegAddr &lt;&lt; 3) &amp; MAC_MCTL_REGADR_M) |
+                                  MAC_MCTL_WRITE | MAC_MCTL_START);
+
+    //
+    // Wait for the write transaction to complete.
+    //
+    while(HWREG(ulBase + MAC_O_MCTL) &amp; MAC_MCTL_START)
+    {
+    }
+}
+
+//*****************************************************************************
+//
+//! Reads from a PHY register.
+//!
+//! \param ulBase is the base address of the controller.
+//! \param ucRegAddr is the address of the PHY register to be accessed.
+//!
+//! This function will return the contents of the PHY register specified by
+//! \e ucRegAddr.
+//!
+//! \return Returns the 16-bit value read from the PHY.
+//
+//*****************************************************************************
+unsigned long
+EthernetPHYRead(unsigned long ulBase, unsigned char ucRegAddr)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == ETH_BASE);
+
+    //
+    // Wait for any pending transaction to complete.
+    //
+    while(HWREG(ulBase + MAC_O_MCTL) &amp; MAC_MCTL_START)
+    {
+    }
+
+    //
+    // Program the PHY register address and initiate the transaction.
+    //
+    HWREG(ulBase + MAC_O_MCTL) = (((ucRegAddr &lt;&lt; 3) &amp; MAC_MCTL_REGADR_M) |
+                                  MAC_MCTL_START);
+
+    //
+    // Wait for the transaction to complete.
+    //
+    while(HWREG(ulBase + MAC_O_MCTL) &amp; MAC_MCTL_START)
+    {
+    }
+
+    //
+    // Return the PHY data that was read.
+    //
+    return(HWREG(ulBase + MAC_O_MRXD) &amp; MAC_MRXD_MDRX_M);
+}
+
+//*****************************************************************************
+//
+// Close the Doxygen group.
+//! @}
+//
+//*****************************************************************************

Added: trunk/src/platform/lm3s/ethernet.h
===================================================================
--- trunk/src/platform/lm3s/ethernet.h	2008-09-10 18:59:17 UTC (rev 88)
+++ trunk/src/platform/lm3s/ethernet.h	2008-09-15 21:54:14 UTC (rev 89)
@@ -0,0 +1,173 @@
+//*****************************************************************************
+//
+// ethernet.h - Defines and Macros for the ethernet module.
+//
+// Copyright (c) 2006-2008 Luminary Micro, Inc.  All rights reserved.
+// 
+// Software License Agreement
+// 
+// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
+// exclusively on LMI's microcontroller products.
+// 
+// The software is owned by LMI and/or its suppliers, and is protected under
+// applicable copyright laws.  All rights are reserved.  You may not combine
+// this software with &quot;viral&quot; open-source software in order to form a larger
+// program.  Any use in violation of the foregoing restrictions may subject
+// the user to criminal sanctions under applicable laws, as well as to civil
+// liability for the breach of the terms and conditions of this license.
+// 
+// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2752 of the Stellaris Peripheral Driver Library.
+//
+//*****************************************************************************
+
+#ifndef __ETHERNET_H__
+#define __ETHERNET_H__
+
+//*****************************************************************************
+//
+// If building with a C++ compiler, make all of the definitions in this header
+// have a C binding.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+extern &quot;C&quot;
+{
+#endif
+
+//*****************************************************************************
+//
+// Values that can be passed to EthernetConfigSet as the ulConfig value, and
+// returned from EthernetConfigGet.
+//
+//*****************************************************************************
+#define ETH_CFG_TS_TSEN         0x010000    // Enable Timestamp (CCP)
+#define ETH_CFG_RX_BADCRCDIS    0x000800    // Disable RX BAD CRC Packets
+#define ETH_CFG_RX_PRMSEN       0x000400    // Enable RX Promiscuous
+#define ETH_CFG_RX_AMULEN       0x000200    // Enable RX Multicast
+#define ETH_CFG_TX_DPLXEN       0x000010    // Enable TX Duplex Mode
+#define ETH_CFG_TX_CRCEN        0x000004    // Enable TX CRC Generation
+#define ETH_CFG_TX_PADEN        0x000002    // Enable TX Padding
+
+//*****************************************************************************
+//
+// Values that can be passed to EthernetIntEnable, EthernetIntDisable, and
+// EthernetIntClear as the ulIntFlags parameter, and returned from
+// EthernetIntStatus.
+//
+//*****************************************************************************
+#define ETH_INT_PHY             0x040       // PHY Event/Interrupt
+#define ETH_INT_MDIO            0x020       // Management Transaction
+#define ETH_INT_RXER            0x010       // RX Error
+#define ETH_INT_RXOF            0x008       // RX FIFO Overrun
+#define ETH_INT_TX              0x004       // TX Complete
+#define ETH_INT_TXER            0x002       // TX Error
+#define ETH_INT_RX              0x001       // RX Complete
+
+//*****************************************************************************
+//
+// Helper Macros for Ethernet Processing
+//
+//*****************************************************************************
+//
+// htonl/ntohl - big endian/little endian byte swapping macros for
+// 32-bit (long) values
+//
+//*****************************************************************************
+#ifndef htonl
+    #define htonl(a)                    \
+        ((((a) &gt;&gt; 24) &amp; 0x000000ff) |   \
+         (((a) &gt;&gt;  8) &amp; 0x0000ff00) |   \
+         (((a) &lt;&lt;  8) &amp; 0x00ff0000) |   \
+         (((a) &lt;&lt; 24) &amp; 0xff000000))
+#endif
+
+#ifndef ntohl
+    #define ntohl(a)    htonl((a))
+#endif
+
+//*****************************************************************************
+//
+// htons/ntohs - big endian/little endian byte swapping macros for
+// 16-bit (short) values
+//
+//*****************************************************************************
+#ifndef htons
+    #define htons(a)                \
+        ((((a) &gt;&gt; 8) &amp; 0x00ff) |    \
+         (((a) &lt;&lt; 8) &amp; 0xff00))
+#endif
+
+#ifndef ntohs
+    #define ntohs(a)    htons((a))
+#endif
+
+//*****************************************************************************
+//
+// API Function prototypes
+//
+//*****************************************************************************
+extern void EthernetInitExpClk(unsigned long ulBase, unsigned long ulEthClk);
+extern void EthernetConfigSet(unsigned long ulBase, unsigned long ulConfig);
+extern unsigned long EthernetConfigGet(unsigned long ulBase);
+extern void EthernetMACAddrSet(unsigned long ulBase,
+                               unsigned char *pucMACAddr);
+extern void EthernetMACAddrGet(unsigned long ulBase,
+                               unsigned char *pucMACAddr);
+extern void EthernetEnable(unsigned long ulBase);
+extern void EthernetDisable(unsigned long ulBase);
+extern tBoolean EthernetPacketAvail(unsigned long ulBase);
+extern tBoolean EthernetSpaceAvail(unsigned long ulBase);
+extern long EthernetPacketGetNonBlocking(unsigned long ulBase,
+                                         unsigned char *pucBuf,
+                                         long lBufLen);
+extern long EthernetPacketGet(unsigned long ulBase, unsigned char *pucBuf,
+                              long lBufLen);
+extern long EthernetPacketPutNonBlocking(unsigned long ulBase,
+                                         unsigned char *pucBuf,
+                                         long lBufLen);
+extern long EthernetPacketPut(unsigned long ulBase, unsigned char *pucBuf,
+                              long lBufLen);
+extern void EthernetIntRegister(unsigned long ulBase,
+                                void (*pfnHandler)(void));
+extern void EthernetIntUnregister(unsigned long ulBase);
+extern void EthernetIntEnable(unsigned long ulBase, unsigned long ulIntFlags);
+extern void EthernetIntDisable(unsigned long ulBase, unsigned long ulIntFlags);
+extern unsigned long EthernetIntStatus(unsigned long ulBase, tBoolean bMasked);
+extern void EthernetIntClear(unsigned long ulBase, unsigned long ulIntFlags);
+extern void EthernetPHYWrite(unsigned long ulBase, unsigned char ucRegAddr,
+                             unsigned long ulData);
+extern unsigned long EthernetPHYRead(unsigned long ulBase,
+                                     unsigned char ucRegAddr);
+
+//*****************************************************************************
+//
+// Several Ethernet APIs have been renamed, with the original function name
+// being deprecated.  These defines provide backward compatibility.
+//
+//*****************************************************************************
+#ifndef DEPRECATED
+#include &quot;sysctl.h&quot;
+#define EthernetInit(a)                         \
+        EthernetInitExpClk(a, SysCtlClockGet())
+#define EthernetPacketNonBlockingGet(a, b, c) \
+        EthernetPacketGetNonBlocking(a, b, c)
+#define EthernetPacketNonBlockingPut(a, b, c) \
+        EthernetPacketPutNonBlocking(a, b, c)
+#endif
+
+//*****************************************************************************
+//
+// Mark the end of the C bindings section for C++ compilers.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+}
+#endif
+
+#endif //  __ETHERNET_H__

Added: trunk/src/platform/lm3s/ethernet.o
===================================================================
(Binary files differ)


Property changes on: trunk/src/platform/lm3s/ethernet.o
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/src/platform/lm3s/flash.c
===================================================================
--- trunk/src/platform/lm3s/flash.c	2008-09-10 18:59:17 UTC (rev 88)
+++ trunk/src/platform/lm3s/flash.c	2008-09-15 21:54:14 UTC (rev 89)
@@ -0,0 +1,872 @@
+//*****************************************************************************
+//
+// flash.c - Driver for programming the on-chip flash.
+//
+// Copyright (c) 2005-2008 Luminary Micro, Inc.  All rights reserved.
+// 
+// Software License Agreement
+// 
+// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
+// exclusively on LMI's microcontroller products.
+// 
+// The software is owned by LMI and/or its suppliers, and is protected under
+// applicable copyright laws.  All rights are reserved.  You may not combine
+// this software with &quot;viral&quot; open-source software in order to form a larger
+// program.  Any use in violation of the foregoing restrictions may subject
+// the user to criminal sanctions under applicable laws, as well as to civil
+// liability for the breach of the terms and conditions of this license.
+// 
+// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2752 of the Stellaris Peripheral Driver Library.
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+//! \addtogroup flash_api
+//! @{
+//
+//*****************************************************************************
+
+#include &quot;hw_flash.h&quot;
+#include &quot;hw_ints.h&quot;
+#include &quot;hw_memmap.h&quot;
+#include &quot;hw_sysctl.h&quot;
+#include &quot;hw_types.h&quot;
+#include &quot;debug.h&quot;
+#include &quot;flash.h&quot;
+#include &quot;interrupt.h&quot;
+
+//*****************************************************************************
+//
+// An array that maps the specified memory bank to the appropriate Flash
+// Memory Protection Program Enable (FMPPE) register.
+//
+//*****************************************************************************
+static const unsigned long g_pulFMPPERegs[] =
+{
+    FLASH_FMPPE,
+    FLASH_FMPPE1,
+    FLASH_FMPPE2,
+    FLASH_FMPPE3
+};
+
+//*****************************************************************************
+//
+// An array that maps the specified memory bank to the appropriate Flash
+// Memory Protection Read Enable (FMPRE) register.
+//
+//*****************************************************************************
+static const unsigned long g_pulFMPRERegs[] =
+{
+    FLASH_FMPRE,
+    FLASH_FMPRE1,
+    FLASH_FMPRE2,
+    FLASH_FMPRE3
+};
+
+//*****************************************************************************
+//
+//! Gets the number of processor clocks per micro-second.
+//!
+//! This function returns the number of clocks per micro-second, as presently
+//! known by the flash controller.
+//!
+//! \return Returns the number of processor clocks per micro-second.
+//
+//*****************************************************************************
+unsigned long
+FlashUsecGet(void)
+{
+    //
+    // Return the number of clocks per micro-second.
+    //
+    return(HWREG(FLASH_USECRL) + 1);
+}
+
+//*****************************************************************************
+//
+//! Sets the number of processor clocks per micro-second.
+//!
+//! \param ulClocks is the number of processor clocks per micro-second.
+//!
+//! This function is used to tell the flash controller the number of processor
+//! clocks per micro-second.  This value must be programmed correctly or the
+//! flash most likely will not program correctly; it has no affect on reading
+//! flash.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+FlashUsecSet(unsigned long ulClocks)
+{
+    //
+    // Set the number of clocks per micro-second.
+    //
+    HWREG(FLASH_USECRL) = ulClocks - 1;
+}
+
+//*****************************************************************************
+//
+//! Erases a block of flash.
+//!
+//! \param ulAddress is the start address of the flash block to be erased.
+//!
+//! This function will erase a 1 kB block of the on-chip flash.  After erasing,
+//! the block will be filled with 0xFF bytes.  Read-only and execute-only
+//! blocks cannot be erased.
+//!
+//! This function will not return until the block has been erased.
+//!
+//! \return Returns 0 on success, or -1 if an invalid block address was
+//! specified or the block is write-protected.
+//
+//*****************************************************************************
+long
+FlashErase(unsigned long ulAddress)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(!(ulAddress &amp; (FLASH_ERASE_SIZE - 1)));
+
+    //
+    // Clear the flash access interrupt.
+    //
+    HWREG(FLASH_FCMISC) = FLASH_FCMISC_AMISC;
+
+    //
+    // Erase the block.
+    //
+    HWREG(FLASH_FMA) = ulAddress;
+    HWREG(FLASH_FMC) = FLASH_FMC_WRKEY | FLASH_FMC_ERASE;
+
+    //
+    // Wait until the block has been erased.
+    //
+    while(HWREG(FLASH_FMC) &amp; FLASH_FMC_ERASE)
+    {
+    }
+
+    //
+    // Return an error if an access violation occurred.
+    //
+    if(HWREG(FLASH_FCRIS) &amp; FLASH_FCRIS_ARIS)
+    {
+        return(-1);
+    }
+
+    //
+    // Success.
+    //
+    return(0);
+}
+
+//*****************************************************************************
+//
+//! Programs flash.
+//!
+//! \param pulData is a pointer to the data to be programmed.
+//! \param ulAddress is the starting address in flash to be programmed.  Must
+//! be a multiple of four.
+//! \param ulCount is the number of bytes to be programmed.  Must be a multiple
+//! of four.
+//!
+//! This function will program a sequence of words into the on-chip flash.
+//! Programming each location consists of the result of an AND operation
+//! of the new data and the existing data; in other words bits that contain
+//! 1 can remain 1 or be changed to 0, but bits that are 0 cannot be changed
+//! to 1.  Therefore, a word can be programmed multiple times as long as these
+//! rules are followed; if a program operation attempts to change a 0 bit to
+//! a 1 bit, that bit will not have its value changed.
+//!
+//! Since the flash is programmed one word at a time, the starting address and
+//! byte count must both be multiples of four.  It is up to the caller to
+//! verify the programmed contents, if such verification is required.
+//!
+//! This function will not return until the data has been programmed.
+//!
+//! \return Returns 0 on success, or -1 if a programming error is encountered.
+//
+//*****************************************************************************
+long
+FlashProgram(unsigned long *pulData, unsigned long ulAddress,
+             unsigned long ulCount)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(!(ulAddress &amp; 3));
+    ASSERT(!(ulCount &amp; 3));
+
+    //
+    // Clear the flash access interrupt.
+    //
+    HWREG(FLASH_FCMISC) = FLASH_FCMISC_AMISC;
+
+    //
+    // Loop over the words to be programmed.
+    //
+    while(ulCount)
+    {
+        //
+        // Program the next word.
+        //
+        HWREG(FLASH_FMA) = ulAddress;
+        HWREG(FLASH_FMD) = *pulData;
+        HWREG(FLASH_FMC) = FLASH_FMC_WRKEY | FLASH_FMC_WRITE;
+
+        //
+        // Wait until the word has been programmed.
+        //
+        while(HWREG(FLASH_FMC) &amp; FLASH_FMC_WRITE)
+        {
+        }
+
+        //
+        // Increment to the next word.
+        //
+        pulData++;
+        ulAddress += 4;
+        ulCount -= 4;
+    }
+
+    //
+    // Return an error if an access violation occurred.
+    //
+    if(HWREG(FLASH_FCRIS) &amp; FLASH_FCRIS_ARIS)
+    {
+        return(-1);
+    }
+
+    //
+    // Success.
+    //
+    return(0);
+}
+
+//*****************************************************************************
+//
+//! Gets the protection setting for a block of flash.
+//!
+//! \param ulAddress is the start address of the flash block to be queried.
+//!
+//! This function will get the current protection for the specified 2 kB block
+//! of flash.  Each block can be read/write, read-only, or execute-only.
+//! Read/write blocks can be read, executed, erased, and programmed.  Read-only
+//! blocks can be read and executed.  Execute-only blocks can only be executed;
+//! processor and debugger data reads are not allowed.
+//!
+//! \return Returns the protection setting for this block.  See
+//! FlashProtectSet() for possible values.
+//
+//*****************************************************************************
+tFlashProtection
+FlashProtectGet(unsigned long ulAddress)
+{
+    unsigned long ulFMPRE, ulFMPPE;
+    unsigned long ulBank;
+
+    //
+    // Check the argument.
+    //
+    ASSERT(!(ulAddress &amp; (FLASH_PROTECT_SIZE - 1)));
+
+    //
+    // Calculate the Flash Bank from Base Address, and mask off the Bank
+    // from ulAddress for subsequent reference.
+    //
+    ulBank = (((ulAddress / FLASH_PROTECT_SIZE) / 32) % 4);
+    ulAddress &amp;= ((FLASH_PROTECT_SIZE * 32) - 1);
+
+    //
+    // Read the appropriate flash protection registers for the specified
+    // flash bank.
+    //
+    ulFMPRE = HWREG(g_pulFMPRERegs[ulBank]);
+    ulFMPPE = HWREG(g_pulFMPPERegs[ulBank]);
+
+    //
+    // For Stellaris Sandstorm-class devices, revision C1 and C2, the upper
+    // bits of the FMPPE register are used for JTAG protect options, and are
+    // not available for the FLASH protection scheme.  When Querying Block
+    // Protection, assume these bits are 1.
+    //
+    if(CLASS_IS_SANDSTORM &amp;&amp; (REVISION_IS_C1 || REVISION_IS_C2))
+    {
+        ulFMPRE |= (FLASH_FMP_BLOCK_31 | FLASH_FMP_BLOCK_30);
+    }
+
+    //
+    // Check the appropriate protection bits for the block of memory that
+    // is specified by the address.
+    //
+    switch((((ulFMPRE &gt;&gt; (ulAddress / FLASH_PROTECT_SIZE)) &amp;
+             FLASH_FMP_BLOCK_0) &lt;&lt; 1) |
+           ((ulFMPPE &gt;&gt; (ulAddress / FLASH_PROTECT_SIZE)) &amp; FLASH_FMP_BLOCK_0))
+    {
+        //
+        // This block is marked as execute only (that is, it can not be erased
+        // or programmed, and the only reads allowed are via the instruction
+        // fecth interface).
+        //
+        case 0:
+        case 1:
+        {
+            return(FlashExecuteOnly);
+        }
+
+        //
+        // This block is marked as read only (that is, it can not be erased or
+        // programmed).
+        //
+        case 2:
+        {
+            return(FlashReadOnly);
+        }
+
+        //
+        // This block is read/write; it can be read, erased, and programmed.
+        //
+        case 3:
+        default:
+        {
+            return(FlashReadWrite);
+        }
+    }
+}
+
+//*****************************************************************************
+//
+//! Sets the protection setting for a block of flash.
+//!
+//! \param ulAddress is the start address of the flash block to be protected.
+//! \param eProtect is the protection to be applied to the block.  Can be one
+//! of \b FlashReadWrite, \b FlashReadOnly, or \b FlashExecuteOnly.
+//!
+//! This function will set the protection for the specified 2 kB block of
+//! flash.  Blocks which are read/write can be made read-only or execute-only.
+//! Blocks which are read-only can be made execute-only.  Blocks which are
+//! execute-only cannot have their protection modified.  Attempts to make the
+//! block protection less stringent (that is, read-only to read/write) will
+//! result in a failure (and be prevented by the hardware).
+//!
+//! Changes to the flash protection are maintained only until the next reset.
+//! This allows the application to be executed in the desired flash protection
+//! environment to check for inappropriate flash access (via the flash
+//! interrupt).  To make the flash protection permanent, use the
+//! FlashProtectSave() function.
+//!
+//! \return Returns 0 on success, or -1 if an invalid address or an invalid
+//! protection was specified.
+//
+//*****************************************************************************
+long
+FlashProtectSet(unsigned long ulAddress, tFlashProtection eProtect)
+{
+    unsigned long ulProtectRE, ulProtectPE;
+    unsigned long ulBank;
+
+    //
+    // Check the argument.
+    //
+    ASSERT(!(ulAddress &amp; (FLASH_PROTECT_SIZE - 1)));
+    ASSERT((eProtect == FlashReadWrite) || (eProtect == FlashReadOnly) ||
+           (eProtect == FlashExecuteOnly));
+
+    //
+    // Convert the address into a block number.
+    //
+    ulAddress /= FLASH_PROTECT_SIZE;
+
+    //
+    // ulAddress contains a &quot;raw&quot; block number.  Derive the Flash Bank from
+    // the &quot;raw&quot; block number, and convert ulAddress to a &quot;relative&quot;
+    // block number.
+    //
+    ulBank = ((ulAddress / 32) % 4);
+    ulAddress %= 32;
+
+    //
+    // Get the current protection for the specified flash bank.
+    //
+    ulProtectRE = HWREG(g_pulFMPRERegs[ulBank]);
+    ulProtectPE = HWREG(g_pulFMPPERegs[ulBank]);
+
+    //
+    // For Stellaris Sandstorm-class devices, revision C1 and C2, the upper
+    // bits of the FMPPE register are used for JTAG protect options, and are
+    // not available for the FLASH protection scheme.  When setting protection,
+    // check to see if block 30 or 31 and protection is FlashExecuteOnly.  If
+    // so, return an error condition.
+    //
+    if(CLASS_IS_SANDSTORM &amp;&amp; (REVISION_IS_C1 || REVISION_IS_C2))
+    {
+        if((ulAddress &gt;= 30) &amp;&amp; (eProtect == FlashExecuteOnly))
+        {
+            return(-1);
+        }
+    }
+
+    //
+    // Set the protection based on the requested proection.
+    //
+    switch(eProtect)
+    {
+        //
+        // Make this block execute only.
+        //
+        case FlashExecuteOnly:
+        {
+            //
+            // Turn off the read and program bits for this block.
+            //
+            ulProtectRE &amp;= ~(FLASH_FMP_BLOCK_0 &lt;&lt; ulAddress);
+            ulProtectPE &amp;= ~(FLASH_FMP_BLOCK_0 &lt;&lt; ulAddress);
+
+            //
+            // We're done handling this protection.
+            //
+            break;
+        }
+
+        //
+        // Make this block read only.
+        //
+        case FlashReadOnly:
+        {
+            //
+            // The block can not be made read only if it is execute only.
+            //
+            if(((ulProtectRE &gt;&gt; ulAddress) &amp; FLASH_FMP_BLOCK_0) !=
+               FLASH_FMP_BLOCK_0)
+            {
+                return(-1);
+            }
+
+            //
+            // Make this block read only.
+            //
+            ulProtectPE &amp;= ~(FLASH_FMP_BLOCK_0 &lt;&lt; ulAddress);
+
+            //
+            // We're done handling this protection.
+            //
+            break;
+        }
+
+        //
+        // Make this block read/write.
+        //
+        case FlashReadWrite:
+        default:
+        {
+            //
+            // The block can not be made read/write if it is not already
+            // read/write.
+            //
+            if((((ulProtectRE &gt;&gt; ulAddress) &amp; FLASH_FMP_BLOCK_0) !=
+                FLASH_FMP_BLOCK_0) ||
+               (((ulProtectPE &gt;&gt; ulAddress) &amp; FLASH_FMP_BLOCK_0) !=
+                FLASH_FMP_BLOCK_0))
+            {
+                return(-1);
+            }
+
+            //
+            // The block is already read/write, so there is nothing to do.
+            //
+            return(0);
+        }
+    }
+
+    //
+    // For Stellaris Sandstorm-class devices, revision C1 and C2, the upper
+    // bits of the FMPPE register are used for JTAG options, and are not
+    // available for the FLASH protection scheme.  When setting block
+    // protection, ensure that these bits are not altered.
+    //
+    if(CLASS_IS_SANDSTORM &amp;&amp; (REVISION_IS_C1 || REVISION_IS_C2))
+    {
+        ulProtectRE &amp;= ~(FLASH_FMP_BLOCK_31 | FLASH_FMP_BLOCK_30);
+        ulProtectRE |= (HWREG(g_pulFMPRERegs[ulBank]) &amp;
+                (FLASH_FMP_BLOCK_31 | FLASH_FMP_BLOCK_30));
+    }
+
+    //
+    // Set the new protection for the specified flash bank.
+    //
+    HWREG(g_pulFMPRERegs[ulBank]) = ulProtectRE;
+    HWREG(g_pulFMPPERegs[ulBank]) = ulProtectPE;
+
+    //
+    // Success.
+    //
+    return(0);
+}
+
+//*****************************************************************************
+//
+//! Saves the flash protection settings.
+//!
+//! This function will make the currently programmed flash protection settings
+//! permanent.  This is a non-reversible operation; a chip reset or power cycle
+//! will not change the flash protection.
+//!
+//! This function will not return until the protection has been saved.
+//!
+//! \return Returns 0 on success, or -1 if a hardware error is encountered.
+//
+//*****************************************************************************
+long
+FlashProtectSave(void)
+{
+    int ulTemp, ulLimit;
+
+    //
+    // If running on a Sandstorm-class device, only trigger a save of the first
+    // two protection registers (FMPRE and FMPPE).  Otherwise, save the
+    // entire bank of flash protection registers.
+    //
+    ulLimit = CLASS_IS_SANDSTORM ? 2 : 8;
+    for(ulTemp = 0; ulTemp &lt; ulLimit; ulTemp++)
+    {
+        //
+        // Tell the flash controller to write the flash protection register.
+        //
+        HWREG(FLASH_FMA) = ulTemp;
+        HWREG(FLASH_FMC) = FLASH_FMC_WRKEY | FLASH_FMC_COMT;
+
+        //
+        // Wait until the write has completed.
+        //
+        while(HWREG(FLASH_FMC) &amp; FLASH_FMC_COMT)
+        {
+        }
+    }
+
+    //
+    // Success.
+    //
+    return(0);
+}
+
+//*****************************************************************************
+//
+//! Gets the user registers.
+//!
+//! \param pulUser0 is a pointer to the location to store USER Register 0.
+//! \param pulUser1 is a pointer to the location to store USER Register 1.
+//!
+//! This function will read the contents of user registers (0 and 1), and
+//! store them in the specified locations.
+//!
+//! \return Returns 0 on success, or -1 if a hardware error is encountered.
+//
+//*****************************************************************************
+long
+FlashUserGet(unsigned long *pulUser0, unsigned long *pulUser1)
+{
+    //
+    // Verify that the pointers are valid.
+    //
+    ASSERT(pulUser0 != 0);
+    ASSERT(pulUser1 != 0);
+
+    //
+    // Verify that hardware supports user registers.
+    //
+    if(CLASS_IS_SANDSTORM)
+    {
+        return(-1);
+    }
+
+    //
+    // Get and store the current value of the user registers.
+    //
+    *pulUser0 = HWREG(FLASH_USERREG0);
+    *pulUser1 = HWREG(FLASH_USERREG1);
+
+    //
+    // Success.
+    //
+    return(0);
+}
+
+//*****************************************************************************
+//
+//! Sets the user registers.
+//!
+//! \param ulUser0 is the value to store in USER Register 0.
+//! \param ulUser1 is the value to store in USER Register 1.
+//!
+//! This function will set the contents of the user registers (0 and 1) to
+//! the specified values.
+//!
+//! \return Returns 0 on success, or -1 if a hardware error is encountered.
+//
+//*****************************************************************************
+long
+FlashUserSet(unsigned long ulUser0, unsigned long ulUser1)
+{
+    //
+    // Verify that hardware supports user registers.
+    //
+    if(CLASS_IS_SANDSTORM)
+    {
+        return(-1);
+    }
+
+    //
+    // Save the new values into the user registers.
+    //
+    HWREG(FLASH_USERREG0) = ulUser0;
+    HWREG(FLASH_USERREG1) = ulUser1;
+
+    //
+    // Success.
+    //
+    return(0);
+}
+
+//*****************************************************************************
+//
+//! Saves the user registers.
+//!
+//! This function will make the currently programmed user register settings
+//! permanent.  This is a non-reversible operation; a chip reset or power cycle
+//! will not change this setting.
+//!
+//! This function will not return until the protection has been saved.
+//!
+//! \return Returns 0 on success, or -1 if a hardware error is encountered.
+//
+//*****************************************************************************
+long
+FlashUserSave(void)
+{
+    //
+    // Verify that hardware supports user registers.
+    //
+    if(CLASS_IS_SANDSTORM)
+    {
+        return(-1);
+    }
+
+    //
+    // Setting the MSB of FMA will trigger a permanent save of a USER
+    // register.  Bit 0 will indicate User 0 (0) or User 1 (1).
+    //
+    HWREG(FLASH_FMA) = 0x80000000;
+    HWREG(FLASH_FMC) = FLASH_FMC_WRKEY | FLASH_FMC_COMT;
+
+    //
+    // Wait until the write has completed.
+    //
+    while(HWREG(FLASH_FMC) &amp; FLASH_FMC_COMT)
+    {
+    }
+
+    //
+    // Tell the flash controller to write the USER1 Register.
+    //
+    HWREG(FLASH_FMA) = 0x80000001;
+    HWREG(FLASH_FMC) = FLASH_FMC_WRKEY | FLASH_FMC_COMT;
+
+    //
+    // Wait until the write has completed.
+    //
+    while(HWREG(FLASH_FMC) &amp; FLASH_FMC_COMT)
+    {
+    }
+
+    //
+    // Success.
+    //
+    return(0);
+}
+
+//*****************************************************************************
+//
+//! Registers an interrupt handler for the flash interrupt.
+//!
+//! \param pfnHandler is a pointer to the function to be called when the flash
+//! interrupt occurs.
+//!
+//! This sets the handler to be called when the flash interrupt occurs.  The
+//! flash controller can generate an interrupt when an invalid flash access
+//! occurs, such as trying to program or erase a read-only block, or trying to
+//! read from an execute-only block.  It can also generate an interrupt when a
+//! program or erase operation has completed.  The interrupt will be
+//! automatically enabled when the handler is registered.
+//!
+//! \sa IntRegister() for important information about registering interrupt
+//! handlers.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+FlashIntRegister(void (*pfnHandler)(void))
+{
+    //
+    // Register the interrupt handler, returning an error if an error occurs.
+    //
+    IntRegister(INT_FLASH, pfnHandler);
+
+    //
+    // Enable the flash interrupt.
+    //
+    IntEnable(INT_FLASH);
+}
+
+//*****************************************************************************
+//
+//! Unregisters the interrupt handler for the flash interrupt.
+//!
+//! This function will clear the handler to be called when the flash interrupt
+//! occurs.  This will also mask off the interrupt in the interrupt controller
+//! so that the interrupt handler is no longer called.
+//!
+//! \sa IntRegister() for important information about registering interrupt
+//! handlers.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+FlashIntUnregister(void)
+{
+    //
+    // Disable the interrupt.
+    //
+    IntDisable(INT_FLASH);
+
+    //
+    // Unregister the interrupt handler.
+    //
+    IntUnregister(INT_FLASH);
+}
+
+//*****************************************************************************
+//
+//! Enables individual flash controller interrupt sources.
+//!
+//! \param ulIntFlags is a bit mask of the interrupt sources to be enabled.
+//! Can be any of the \b FLASH_FCIM_PROGRAM or \b FLASH_FCIM_ACCESS values.
+//!
+//! Enables the indicated flash controller interrupt sources.  Only the sources
+//! that are enabled can be reflected to the processor interrupt; disabled
+//! sources have no effect on the processor.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+FlashIntEnable(unsigned long ulIntFlags)
+{
+    //
+    // Enable the specified interrupts.
+    //
+    HWREG(FLASH_FCIM) |= ulIntFlags;
+}
+
+//*****************************************************************************
+//
+//! Disables individual flash controller interrupt sources.
+//!
+//! \param ulIntFlags is a bit mask of the interrupt sources to be disabled.
+//! Can be any of the \b FLASH_FCIM_PROGRAM or \b FLASH_FCIM_ACCESS values.
+//!
+//! Disables the indicated flash controller interrupt sources.  Only the
+//! sources that are enabled can be reflected to the processor interrupt;
+//! disabled sources have no effect on the processor.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+FlashIntDisable(unsigned long ulIntFlags)
+{
+    //
+    // Disable the specified interrupts.
+    //
+    HWREG(FLASH_FCIM) &amp;= ~(ulIntFlags);
+}
+
+//*****************************************************************************
+//
+//! Gets the current interrupt status.
+//!
+//! \param bMasked is false if the raw interrupt status is required and true if
+//! the masked interrupt status is required.
+//!
+//! This returns the interrupt status for the flash controller.  Either the raw
+//! interrupt status or the status of interrupts that are allowed to reflect to
+//! the processor can be returned.
+//!
+//! \return The current interrupt status, enumerated as a bit field of
+//! \b FLASH_FCMISC_PROGRAM and \b FLASH_FCMISC_AMISC.
+//
+//*****************************************************************************
+unsigned long
+FlashIntGetStatus(tBoolean bMasked)
+{
+    //
+    // Return either the interrupt status or the raw interrupt status as
+    // requested.
+    //
+    if(bMasked)
+    {
+        return(HWREG(FLASH_FCMISC));
+    }
+    else
+    {
+        return(HWREG(FLASH_FCRIS));
+    }
+}
+
+//*****************************************************************************
+//
+//! Clears flash controller interrupt sources.
+//!
+//! \param ulIntFlags is the bit mask of the interrupt sources to be cleared.
+//! Can be any of the \b FLASH_FCMISC_PROGRAM or \b FLASH_FCMISC_AMISC values.
+//!
+//! The specified flash controller interrupt sources are cleared, so that they
+//! no longer assert.  This must be done in the interrupt handler to keep it
+//! from being called again immediately upon exit.
+//!
+//! \note Since there is a write buffer in the Cortex-M3 processor, it may take
+//! several clock cycles before the interrupt source is actually cleared.
+//! Therefore, it is recommended that the interrupt source be cleared early in
+//! the interrupt handler (as opposed to the very last action) to avoid
+//! returning from the interrupt handler before the interrupt source is
+//! actually cleared.  Failure to do so may result in the interrupt handler
+//! being immediately reentered (since NVIC still sees the interrupt source
+//! asserted).
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+FlashIntClear(unsigned long ulIntFlags)
+{
+    //
+    // Clear the flash interrupt.
+    //
+    HWREG(FLASH_FCMISC) = ulIntFlags;
+}
+
+//*****************************************************************************
+//
+// Close the Doxygen group.
+//! @}
+//
+//*****************************************************************************

Added: trunk/src/platform/lm3s/flash.h
===================================================================
--- trunk/src/platform/lm3s/flash.h	2008-09-10 18:59:17 UTC (rev 88)
+++ trunk/src/platform/lm3s/flash.h	2008-09-15 21:54:14 UTC (rev 89)
@@ -0,0 +1,90 @@
+//*****************************************************************************
+//
+// flash.h - Prototypes for the flash driver.
+//
+// Copyright (c) 2005-2008 Luminary Micro, Inc.  All rights reserved.
+// 
+// Software License Agreement
+// 
+// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
+// exclusively on LMI's microcontroller products.
+// 
+// The software is owned by LMI and/or its suppliers, and is protected under
+// applicable copyright laws.  All rights are reserved.  You may not combine
+// this software with &quot;viral&quot; open-source software in order to form a larger
+// program.  Any use in violation of the foregoing restrictions may subject
+// the user to criminal sanctions under applicable laws, as well as to civil
+// liability for the breach of the terms and conditions of this license.
+// 
+// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2752 of the Stellaris Peripheral Driver Library.
+//
+//*****************************************************************************
+
+#ifndef __FLASH_H__
+#define __FLASH_H__
+
+//*****************************************************************************
+//
+// If building with a C++ compiler, make all of the definitions in this header
+// have a C binding.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+extern &quot;C&quot;
+{
+#endif
+
+//*****************************************************************************
+//
+// Values that can be passed to FlashProtectSet(), and returned by
+// FlashProtectGet().
+//
+//*****************************************************************************
+typedef enum
+{
+    FlashReadWrite,                         // Flash can be read and written
+    FlashReadOnly,                          // Flash can only be read
+    FlashExecuteOnly                        // Flash can only be executed
+}
+tFlashProtection;
+
+//*****************************************************************************
+//
+// Prototypes for the APIs.
+//
+//*****************************************************************************
+extern unsigned long FlashUsecGet(void);
+extern void FlashUsecSet(unsigned long ulClocks);
+extern long FlashErase(unsigned long ulAddress);
+extern long FlashProgram(unsigned long *pulData, unsigned long ulAddress,
+                         unsigned long ulCount);
+extern tFlashProtection FlashProtectGet(unsigned long ulAddress);
+extern long FlashProtectSet(unsigned long ulAddress,
+                            tFlashProtection eProtect);
+extern long FlashProtectSave(void);
+extern long FlashUserGet(unsigned long *pulUser0, unsigned long *pulUser1);
+extern long FlashUserSet(unsigned long ulUser0, unsigned long ulUser1);
+extern long FlashUserSave(void);
+extern void FlashIntRegister(void (*pfnHandler)(void));
+extern void FlashIntUnregister(void);
+extern void FlashIntEnable(unsigned long ulIntFlags);
+extern void FlashIntDisable(unsigned long ulIntFlags);
+extern unsigned long FlashIntGetStatus(tBoolean bMasked);
+extern void FlashIntClear(unsigned long ulIntFlags);
+
+//*****************************************************************************
+//
+// Mark the end of the C bindings section for C++ compilers.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+}
+#endif
+
+#endif // __FLASH_H__

Added: trunk/src/platform/lm3s/flash.o
===================================================================
(Binary files differ)


Property changes on: trunk/src/platform/lm3s/flash.o
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/src/platform/lm3s/hw_ethernet.h
===================================================================
--- trunk/src/platform/lm3s/hw_ethernet.h	2008-09-10 18:59:17 UTC (rev 88)
+++ trunk/src/platform/lm3s/hw_ethernet.h	2008-09-15 21:54:14 UTC (rev 89)
@@ -0,0 +1,576 @@
+//*****************************************************************************
+//
+// hw_ethernet.h - Macros used when accessing the Ethernet hardware.
+//
+// Copyright (c) 2006-2008 Luminary Micro, Inc.  All rights reserved.
+// 
+// Software License Agreement
+// 
+// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
+// exclusively on LMI's microcontroller products.
+// 
+// The software is owned by LMI and/or its suppliers, and is protected under
+// applicable copyright laws.  All rights are reserved.  You may not combine
+// this software with &quot;viral&quot; open-source software in order to form a larger
+// program.  Any use in violation of the foregoing restrictions may subject
+// the user to criminal sanctions under applicable laws, as well as to civil
+// liability for the breach of the terms and conditions of this license.
+// 
+// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2752 of the Stellaris Peripheral Driver Library.
+//
+//*****************************************************************************
+
+#ifndef __HW_ETHERNET_H__
+#define __HW_ETHERNET_H__
+
+//*****************************************************************************
+//
+// The following are defines for the MAC register offsets in the Ethernet
+// Controller.
+//
+//*****************************************************************************
+#define MAC_O_RIS               0x00000000  // Ethernet MAC Raw Interrupt
+                                            // Status
+#define MAC_O_IACK              0x00000000  // Interrupt Acknowledge Register
+#define MAC_O_IM                0x00000004  // Interrupt Mask Register
+#define MAC_O_RCTL              0x00000008  // Receive Control Register
+#define MAC_O_TCTL              0x0000000C  // Transmit Control Register
+#define MAC_O_DATA              0x00000010  // Data Register
+#define MAC_O_IA0               0x00000014  // Individual Address Register 0
+#define MAC_O_IA1               0x00000018  // Individual Address Register 1
+#define MAC_O_THR               0x0000001C  // Threshold Register
+#define MAC_O_MCTL              0x00000020  // Management Control Register
+#define MAC_O_MDV               0x00000024  // Management Divider Register
+#define MAC_O_MTXD              0x0000002C  // Management Transmit Data Reg
+#define MAC_O_MRXD              0x00000030  // Management Receive Data Reg
+#define MAC_O_NP                0x00000034  // Number of Packets Register
+#define MAC_O_TR                0x00000038  // Transmission Request Register
+#define MAC_O_TS                0x0000003C  // Timer Support Register
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_IACK register.
+//
+//*****************************************************************************
+#define MAC_IACK_PHYINT         0x00000040  // Clear PHY Interrupt
+#define MAC_IACK_MDINT          0x00000020  // Clear MDI Transaction Complete
+#define MAC_IACK_RXER           0x00000010  // Clear RX Error
+#define MAC_IACK_FOV            0x00000008  // Clear RX FIFO Overrun
+#define MAC_IACK_TXEMP          0x00000004  // Clear TX FIFO Empy
+#define MAC_IACK_TXER           0x00000002  // Clear TX Error
+#define MAC_IACK_RXINT          0x00000001  // Clear RX Packet Available
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_IM register.
+//
+//*****************************************************************************
+#define MAC_IM_PHYINTM          0x00000040  // Mask PHY Interrupt
+#define MAC_IM_MDINTM           0x00000020  // Mask MDI Transaction Complete
+#define MAC_IM_RXERM            0x00000010  // Mask RX Error
+#define MAC_IM_FOVM             0x00000008  // Mask RX FIFO Overrun
+#define MAC_IM_TXEMPM           0x00000004  // Mask TX FIFO Empy
+#define MAC_IM_TXERM            0x00000002  // Mask TX Error
+#define MAC_IM_RXINTM           0x00000001  // Mask RX Packet Available
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_RCTL register.
+//
+//*****************************************************************************
+#define MAC_RCTL_RSTFIFO        0x00000010  // Clear the Receive FIFO
+#define MAC_RCTL_BADCRC         0x00000008  // Reject Packets With Bad CRC
+#define MAC_RCTL_PRMS           0x00000004  // Enable Promiscuous Mode
+#define MAC_RCTL_AMUL           0x00000002  // Enable Multicast Packets
+#define MAC_RCTL_RXEN           0x00000001  // Enable Ethernet Receiver
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_TCTL register.
+//
+//*****************************************************************************
+#define MAC_TCTL_DUPLEX         0x00000010  // Enable Duplex mode
+#define MAC_TCTL_CRC            0x00000004  // Enable CRC Generation
+#define MAC_TCTL_PADEN          0x00000002  // Enable Automatic Padding
+#define MAC_TCTL_TXEN           0x00000001  // Enable Ethernet Transmitter
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_IA0 register.
+//
+//*****************************************************************************
+#define MAC_IA0_MACOCT4_M       0xFF000000  // MAC Address Octet 4.
+#define MAC_IA0_MACOCT3_M       0x00FF0000  // MAC Address Octet 3.
+#define MAC_IA0_MACOCT2_M       0x0000FF00  // MAC Address Octet 2.
+#define MAC_IA0_MACOCT1_M       0x000000FF  // MAC Address Octet 1.
+#define MAC_IA0_MACOCT4_S       24
+#define MAC_IA0_MACOCT3_S       16
+#define MAC_IA0_MACOCT2_S       8
+#define MAC_IA0_MACOCT1_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_IA1 register.
+//
+//*****************************************************************************
+#define MAC_IA1_MACOCT6_M       0x0000FF00  // MAC Address Octet 6.
+#define MAC_IA1_MACOCT5_M       0x000000FF  // MAC Address Octet 5.
+#define MAC_IA1_MACOCT6_S       8
+#define MAC_IA1_MACOCT5_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_TXTH register.
+//
+//*****************************************************************************
+#define MAC_THR_THRESH_M        0x0000003F  // Threshold Value.
+#define MAC_THR_THRESH_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_MCTL register.
+//
+//*****************************************************************************
+#define MAC_MCTL_REGADR_M       0x000000F8  // MII Register Address.
+#define MAC_MCTL_WRITE          0x00000002  // Next MII Transaction is Write
+#define MAC_MCTL_START          0x00000001  // Start MII Transaction
+#define MAC_MCTL_REGADR_S       3
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_MDV register.
+//
+//*****************************************************************************
+#define MAC_MDV_DIV_M           0x000000FF  // Clock Divider.
+#define MAC_MDV_DIV_S           0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_MTXD register.
+//
+//*****************************************************************************
+#define MAC_MTXD_MDTX_M         0x0000FFFF  // MII Register Transmit Data.
+#define MAC_MTXD_MDTX_S         0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_MRXD register.
+//
+//*****************************************************************************
+#define MAC_MRXD_MDRX_M         0x0000FFFF  // MII Register Receive Data.
+#define MAC_MRXD_MDRX_S         0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_NP register.
+//
+//*****************************************************************************
+#define MAC_NP_NPR_M            0x0000003F  // Number of Packets in Receive
+                                            // FIFO.
+#define MAC_NP_NPR_S            0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_TXRQ register.
+//
+//*****************************************************************************
+#define MAC_TR_NEWTX            0x00000001  // Start an Ethernet Transmission
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_TS register.
+//
+//*****************************************************************************
+#define MAC_TS_TSEN             0x00000001  // Enable Timestamp Logic
+
+//*****************************************************************************
+//
+// The following are defines for the Ethernet Controller PHY registers.
+//
+//*****************************************************************************
+#define PHY_MR0                 0x00000000  // Ethernet PHY Management Register
+                                            // 0 - Control
+#define PHY_MR1                 0x00000001  // Ethernet PHY Management Register
+                                            // 1 - Status
+#define PHY_MR2                 0x00000002  // Ethernet PHY Management Register
+                                            // 2 - PHY Identifier 1
+#define PHY_MR3                 0x00000003  // Ethernet PHY Management Register
+                                            // 3 - PHY Identifier 2
+#define PHY_MR4                 0x00000004  // Ethernet PHY Management Register
+                                            // 4 - Auto-Negotiation
+                                            // Advertisement
+#define PHY_MR5                 0x00000005  // Ethernet PHY Management Register
+                                            // 5 - Auto-Negotiation Link
+                                            // Partner Base Page Ability
+#define PHY_MR6                 0x00000006  // Ethernet PHY Management Register
+                                            // 6 - Auto-Negotiation Expansion
+#define PHY_MR16                0x00000010  // Ethernet PHY Management Register
+                                            // 16 - Vendor-Specific
+#define PHY_MR17                0x00000011  // Ethernet PHY Management Register
+                                            // 17 - Interrupt Control/Status
+#define PHY_MR18                0x00000012  // Ethernet PHY Management Register
+                                            // 18 - Diagnostic
+#define PHY_MR19                0x00000013  // Ethernet PHY Management Register
+                                            // 19 - Transceiver Control
+#define PHY_MR23                0x00000017  // Ethernet PHY Management Register
+                                            // 23 - LED Configuration
+#define PHY_MR24                0x00000018  // Ethernet PHY Management Register
+                                            // 24 -MDI/MDIX Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PHY_MR0 register.
+//
+//*****************************************************************************
+#define PHY_MR0_RESET           0x00008000  // Reset Registers.
+#define PHY_MR0_LOOPBK          0x00004000  // Loopback Mode.
+#define PHY_MR0_SPEEDSL         0x00002000  // Speed Select.
+#define PHY_MR0_ANEGEN          0x00001000  // Auto-Negotiation Enable.
+#define PHY_MR0_PWRDN           0x00000800  // Power Down.
+#define PHY_MR0_ISO             0x00000400  // Isolate.
+#define PHY_MR0_RANEG           0x00000200  // Restart Auto-Negotiation.
+#define PHY_MR0_DUPLEX          0x00000100  // Set Duplex Mode.
+#define PHY_MR0_COLT            0x00000080  // Collision Test.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_RIS register.
+//
+//*****************************************************************************
+#define MAC_RIS_PHYINT          0x00000040  // PHY Interrupt.
+#define MAC_RIS_MDINT           0x00000020  // MII Transaction Complete.
+#define MAC_RIS_RXER            0x00000010  // Receive Error.
+#define MAC_RIS_FOV             0x00000008  // FIFO Overrrun.
+#define MAC_RIS_TXEMP           0x00000004  // Transmit FIFO Empty.
+#define MAC_RIS_TXER            0x00000002  // Transmit Error.
+#define MAC_RIS_RXINT           0x00000001  // Packet Received.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PHY_MR1 register.
+//
+//*****************************************************************************
+#define PHY_MR1_100X_F          0x00004000  // 100BASE-TX Full-Duplex Mode.
+#define PHY_MR1_100X_H          0x00002000  // 100BASE-TX Half-Duplex Mode.
+#define PHY_MR1_10T_F           0x00001000  // 10BASE-T Full-Duplex Mode.
+#define PHY_MR1_10T_H           0x00000800  // 10BASE-T Half-Duplex Mode.
+#define PHY_MR1_MFPS            0x00000040  // Management Frames with Preamble
+                                            // Suppressed.
+#define PHY_MR1_ANEGC           0x00000020  // Auto-Negotiation Complete.
+#define PHY_MR1_RFAULT          0x00000010  // Remote Fault.
+#define PHY_MR1_ANEGA           0x00000008  // Auto-Negotiation.
+#define PHY_MR1_LINK            0x00000004  // Link Made.
+#define PHY_MR1_JAB             0x00000002  // Jabber Condition.
+#define PHY_MR1_EXTD            0x00000001  // Extended Capabilities.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PHY_MR2 register.
+//
+//*****************************************************************************
+#define PHY_MR2_OUI_M           0x0000FFFF  // Organizationally Unique
+                                            // Identifier[21:6].
+#define PHY_MR2_OUI_S           0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PHY_MR3 register.
+//
+//*****************************************************************************
+#define PHY_MR3_OUI_M           0x0000FC00  // Organizationally Unique
+                                            // Identifier[5:0].
+#define PHY_MR3_MN_M            0x000003F0  // Model Number.
+#define PHY_MR3_RN_M            0x0000000F  // Revision Number.
+#define PHY_MR3_OUI_S           10
+#define PHY_MR3_MN_S            4
+#define PHY_MR3_RN_S            0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PHY_MR4 register.
+//
+//*****************************************************************************
+#define PHY_MR4_NP              0x00008000  // Next Page.
+#define PHY_MR4_RF              0x00002000  // Remote Fault.
+#define PHY_MR4_A3              0x00000100  // Technology Ability Field[3].
+#define PHY_MR4_A2              0x00000080  // Technology Ability Field[2].
+#define PHY_MR4_A1              0x00000040  // Technology Ability Field[1].
+#define PHY_MR4_A0              0x00000020  // Technology Ability Field[0].
+#define PHY_MR4_S_M             0x0000001F  // Selector Field.
+#define PHY_MR4_S_S             0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PHY_MR5 register.
+//
+//*****************************************************************************
+#define PHY_MR5_NP              0x00008000  // Next Page.
+#define PHY_MR5_ACK             0x00004000  // Acknowledge.
+#define PHY_MR5_RF              0x00002000  // Remote Fault.
+#define PHY_MR5_A_M             0x00001FE0  // Technology Ability Field.
+#define PHY_MR5_S_M             0x0000001F  // Selector Field.
+#define PHY_MR5_S_8023          0x00000001  // IEEE Std 802.3
+#define PHY_MR5_S_8029          0x00000002  // IEEE Std 802.9 ISLAN-16T
+#define PHY_MR5_S_8025          0x00000003  // IEEE Std 802.5
+#define PHY_MR5_S_1394          0x00000004  // IEEE Std 1394
+#define PHY_MR5_A_S             5
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PHY_MR6 register.
+//
+//*****************************************************************************
+#define PHY_MR6_PDF             0x00000010  // Parallel Detection Fault.
+#define PHY_MR6_LPNPA           0x00000008  // Link Partner is Next Page Able.
+#define PHY_MR6_PRX             0x00000002  // New Page Received.
+#define PHY_MR6_LPANEGA         0x00000001  // Link Partner is Auto-Negotiation
+                                            // Able.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_DATA register.
+//
+//*****************************************************************************
+#define MAC_DATA_TXDATA_M       0xFFFFFFFF  // Transmit FIFO Data.
+#define MAC_DATA_RXDATA_M       0xFFFFFFFF  // Receive FIFO Data.
+#define MAC_DATA_RXDATA_S       0
+#define MAC_DATA_TXDATA_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PHY_MR16 register.
+//
+//*****************************************************************************
+#define PHY_MR16_RPTR           0x00008000  // Repeater Mode.
+#define PHY_MR16_INPOL          0x00004000  // Interrupt Polarity.
+#define PHY_MR16_TXHIM          0x00001000  // Transmit High Impedance Mode.
+#define PHY_MR16_SQEI           0x00000800  // SQE Inhibit Testing.
+#define PHY_MR16_NL10           0x00000400  // Natural Loopback Mode.
+#define PHY_MR16_APOL           0x00000020  // Auto-Polarity Disable.
+#define PHY_MR16_RVSPOL         0x00000010  // Receive Data Polarity.
+#define PHY_MR16_PCSBP          0x00000002  // PCS Bypass.
+#define PHY_MR16_RXCC           0x00000001  // Receive Clock Control.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PHY_MR17 register.
+//
+//*****************************************************************************
+#define PHY_MR17_JABBER_IE      0x00008000  // Jabber Interrupt Enable.
+#define PHY_MR17_RXER_IE        0x00004000  // Receive Error Interrupt Enable.
+#define PHY_MR17_PRX_IE         0x00002000  // Page Received Interrupt Enable.
+#define PHY_MR17_PDF_IE         0x00001000  // Parallel Detection Fault
+                                            // Interrupt Enable.
+#define PHY_MR17_LPACK_IE       0x00000800  // LP Acknowledge Interrupt Enable.
+#define PHY_MR17_LSCHG_IE       0x00000400  // Link Status Change Interrupt
+                                            // Enable.
+#define PHY_MR17_RFAULT_IE      0x00000200  // Remote Fault Interrupt Enable.
+#define PHY_MR17_ANEGCOMP_IE    0x00000100  // Auto-Negotiation Complete
+                                            // Interrupt Enable.
+#define PHY_MR17_JABBER_INT     0x00000080  // Jabber Event Interrupt.
+#define PHY_MR17_RXER_INT       0x00000040  // Receive Error Interrupt.
+#define PHY_MR17_PRX_INT        0x00000020  // Page Receive Interrupt.
+#define PHY_MR17_PDF_INT        0x00000010  // Parallel Detection Fault
+                                            // Interrupt.
+#define PHY_MR17_LPACK_INT      0x00000008  // LP Acknowledge Interrupt.
+#define PHY_MR17_LSCHG_INT      0x00000004  // Link Status Change Interrupt.
+#define PHY_MR17_RFAULT_INT     0x00000002  // Remote Fault Interrupt.
+#define PHY_MR17_ANEGCOMP_INT   0x00000001  // Auto-Negotiation Complete
+                                            // Interrupt.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PHY_MR18 register.
+//
+//*****************************************************************************
+#define PHY_MR18_ANEGF          0x00001000  // Auto-Negotiation Failure.
+#define PHY_MR18_DPLX           0x00000800  // Duplex Mode.
+#define PHY_MR18_RATE           0x00000400  // Rate.
+#define PHY_MR18_RXSD           0x00000200  // Receive Detection.
+#define PHY_MR18_RX_LOCK        0x00000100  // Receive PLL Lock.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PHY_MR19 register.
+//
+//*****************************************************************************
+#define PHY_MR19_TXO_M          0x0000C000  // Transmit Amplitude Selection.
+#define PHY_MR19_TXO_00DB       0x00000000  // Gain set for 0.0dB of insertion
+                                            // loss
+#define PHY_MR19_TXO_04DB       0x00004000  // Gain set for 0.4dB of insertion
+                                            // loss
+#define PHY_MR19_TXO_08DB       0x00008000  // Gain set for 0.8dB of insertion
+                                            // loss
+#define PHY_MR19_TXO_12DB       0x0000C000  // Gain set for 1.2dB of insertion
+                                            // loss
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PHY_MR23 register.
+//
+//*****************************************************************************
+#define PHY_MR23_LED1_M         0x000000F0  // LED1 Source.
+#define PHY_MR23_LED1_LINK      0x00000000  // Link OK
+#define PHY_MR23_LED1_RXTX      0x00000010  // RX or TX Activity (Default LED1)
+#define PHY_MR23_LED1_TX        0x00000020  // TX Activity
+#define PHY_MR23_LED1_RX        0x00000030  // RX Activity
+#define PHY_MR23_LED1_COL       0x00000040  // Collision
+#define PHY_MR23_LED1_100       0x00000050  // 100BASE-TX mode
+#define PHY_MR23_LED1_10        0x00000060  // 10BASE-T mode
+#define PHY_MR23_LED1_DUPLEX    0x00000070  // Full-Duplex
+#define PHY_MR23_LED1_LINKACT   0x00000080  // Link OK &amp; Blink=RX or TX
+                                            // Activity
+#define PHY_MR23_LED0_M         0x0000000F  // LED0 Source.
+#define PHY_MR23_LED0_LINK      0x00000000  // Link OK (Default LED0)
+#define PHY_MR23_LED0_RXTX      0x00000001  // RX or TX Activity
+#define PHY_MR23_LED0_TX        0x00000002  // TX Activity
+#define PHY_MR23_LED0_RX        0x00000003  // RX Activity
+#define PHY_MR23_LED0_COL       0x00000004  // Collision
+#define PHY_MR23_LED0_100       0x00000005  // 100BASE-TX mode
+#define PHY_MR23_LED0_10        0x00000006  // 10BASE-T mode
+#define PHY_MR23_LED0_DUPLEX    0x00000007  // Full-Duplex
+#define PHY_MR23_LED0_LINKACT   0x00000008  // Link OK &amp; Blink=RX or TX
+                                            // Activity
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PHY_MR24 register.
+//
+//*****************************************************************************
+#define PHY_MR24_PD_MODE        0x00000080  // Parallel Detection Mode.
+#define PHY_MR24_AUTO_SW        0x00000040  // Auto-Switching Enable.
+#define PHY_MR24_MDIX           0x00000020  // Auto-Switching Configuration.
+#define PHY_MR24_MDIX_CM        0x00000010  // Auto-Switching Complete.
+#define PHY_MR24_MDIX_SD_M      0x0000000F  // Auto-Switching Seed.
+#define PHY_MR24_MDIX_SD_S      0
+
+//*****************************************************************************
+//
+// The following definitions are deprecated.
+//
+//*****************************************************************************
+#ifndef DEPRECATED
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the MAC register offsets in the
+// Ethernet Controller.
+//
+//*****************************************************************************
+#define MAC_O_IS                0x00000000  // Interrupt Status Register
+#define MAC_O_MADD              0x00000028  // Management Address Register
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the reset values of the MAC
+// registers.
+//
+//*****************************************************************************
+#define MAC_RV_MDV              0x00000080
+#define MAC_RV_IM               0x0000007F
+#define MAC_RV_THR              0x0000003F
+#define MAC_RV_RCTL             0x00000008
+#define MAC_RV_IA0              0x00000000
+#define MAC_RV_TCTL             0x00000000
+#define MAC_RV_DATA             0x00000000
+#define MAC_RV_MRXD             0x00000000
+#define MAC_RV_TR               0x00000000
+#define MAC_RV_IS               0x00000000
+#define MAC_RV_NP               0x00000000
+#define MAC_RV_MCTL             0x00000000
+#define MAC_RV_MTXD             0x00000000
+#define MAC_RV_IA1              0x00000000
+#define MAC_RV_IACK             0x00000000
+#define MAC_RV_MADD             0x00000000
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the MAC_IS
+// register.
+//
+//*****************************************************************************
+#define MAC_IS_PHYINT           0x00000040  // PHY Interrupt
+#define MAC_IS_MDINT            0x00000020  // MDI Transaction Complete
+#define MAC_IS_RXER             0x00000010  // RX Error
+#define MAC_IS_FOV              0x00000008  // RX FIFO Overrun
+#define MAC_IS_TXEMP            0x00000004  // TX FIFO Empy
+#define MAC_IS_TXER             0x00000002  // TX Error
+#define MAC_IS_RXINT            0x00000001  // RX Packet Available
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the MAC_IA0
+// register.
+//
+//*****************************************************************************
+#define MAC_IA0_MACOCT4         0xFF000000  // 4th Octet of MAC address
+#define MAC_IA0_MACOCT3         0x00FF0000  // 3rd Octet of MAC address
+#define MAC_IA0_MACOCT2         0x0000FF00  // 2nd Octet of MAC address
+#define MAC_IA0_MACOCT1         0x000000FF  // 1st Octet of MAC address
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the MAC_IA1
+// register.
+//
+//*****************************************************************************
+#define MAC_IA1_MACOCT6         0x0000FF00  // 6th Octet of MAC address
+#define MAC_IA1_MACOCT5         0x000000FF  // 5th Octet of MAC address
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the MAC_TXTH
+// register.
+//
+//*****************************************************************************
+#define MAC_THR_THRESH          0x0000003F  // Transmit Threshold Value
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the MAC_MCTL
+// register.
+//
+//*****************************************************************************
+#define MAC_MCTL_REGADR         0x000000F8  // Address for Next MII Transaction
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the MAC_MDV
+// register.
+//
+//*****************************************************************************
+#define MAC_MDV_DIV             0x000000FF  // Clock Divider for MDC for TX
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the MAC_MTXD
+// register.
+//
+//*****************************************************************************
+#define MAC_MTXD_MDTX           0x0000FFFF  // Data for Next MII Transaction
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the MAC_MRXD
+// register.
+//
+//*****************************************************************************
+#define MAC_MRXD_MDRX           0x0000FFFF  // Data Read from Last MII Trans.
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the MAC_NP
+// register.
+//
+//*****************************************************************************
+#define MAC_NP_NPR              0x0000003F  // Number of RX Frames in FIFO
+
+#endif
+
+#endif // __HW_ETHERNET_H__

Added: trunk/src/platform/lm3s/hw_flash.h
===================================================================
--- trunk/src/platform/lm3s/hw_flash.h	2008-09-10 18:59:17 UTC (rev 88)
+++ trunk/src/platform/lm3s/hw_flash.h	2008-09-15 21:54:14 UTC (rev 89)
@@ -0,0 +1,296 @@
+//*****************************************************************************
+//
+// hw_flash.h - Macros used when accessing the flash controller.
+//
+// Copyright (c) 2005-2008 Luminary Micro, Inc.  All rights reserved.
+// 
+// Software License Agreement
+// 
+// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
+// exclusively on LMI's microcontroller products.
+// 
+// The software is owned by LMI and/or its suppliers, and is protected under
+// applicable copyright laws.  All rights are reserved.  You may not combine
+// this software with &quot;viral&quot; open-source software in order to form a larger
+// program.  Any use in violation of the foregoing restrictions may subject
+// the user to criminal sanctions under applicable laws, as well as to civil
+// liability for the breach of the terms and conditions of this license.
+// 
+// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2752 of the Stellaris Peripheral Driver Library.
+//
+//*****************************************************************************
+
+#ifndef __HW_FLASH_H__
+#define __HW_FLASH_H__
+
+//*****************************************************************************
+//
+// The following are defines for the FLASH register offsets.
+//
+//*****************************************************************************
+#define FLASH_FMA               0x400FD000  // Memory address register
+#define FLASH_FMD               0x400FD004  // Memory data register
+#define FLASH_FMC               0x400FD008  // Memory control register
+#define FLASH_FCRIS             0x400FD00C  // Raw interrupt status register
+#define FLASH_FCIM              0x400FD010  // Interrupt mask register
+#define FLASH_FCMISC            0x400FD014  // Interrupt status register
+#define FLASH_RMCTL             0x400FE0F0  // ROM Control
+#define FLASH_RMVER             0x400FE0F4  // ROM Version Register
+#define FLASH_FMPRE             0x400FE130  // FLASH read protect register
+#define FLASH_FMPPE             0x400FE134  // FLASH program protect register
+#define FLASH_USECRL            0x400FE140  // uSec reload register
+#define FLASH_USERDBG           0x400FE1D0  // User Debug
+#define FLASH_USERREG0          0x400FE1E0  // User Register 0
+#define FLASH_USERREG1          0x400FE1E4  // User Register 1
+#define FLASH_USERREG2          0x400FE1E8  // User Register 2
+#define FLASH_USERREG3          0x400FE1EC  // User Register 3
+#define FLASH_FMPRE0            0x400FE200  // FLASH read protect register 0
+#define FLASH_FMPRE1            0x400FE204  // FLASH read protect register 1
+#define FLASH_FMPRE2            0x400FE208  // FLASH read protect register 2
+#define FLASH_FMPRE3            0x400FE20C  // FLASH read protect register 3
+#define FLASH_FMPPE0            0x400FE400  // FLASH program protect register 0
+#define FLASH_FMPPE1            0x400FE404  // FLASH program protect register 1
+#define FLASH_FMPPE2            0x400FE408  // FLASH program protect register 2
+#define FLASH_FMPPE3            0x400FE40C  // FLASH program protect register 3
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_FMC register.
+//
+//*****************************************************************************
+#define FLASH_FMC_WRKEY_M       0xFFFF0000  // FLASH write key mask
+#define FLASH_FMC_WRKEY         0xA4420000  // FLASH write key
+#define FLASH_FMC_COMT          0x00000008  // Commit user register
+#define FLASH_FMC_MERASE        0x00000004  // Mass erase FLASH
+#define FLASH_FMC_ERASE         0x00000002  // Erase FLASH page
+#define FLASH_FMC_WRITE         0x00000001  // Write FLASH word
+#define FLASH_FMC_WRKEY_S       16
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_FCRIS register.
+//
+//*****************************************************************************
+#define FLASH_FCRIS_PRIS        0x00000002  // Programming Raw Interrupt
+                                            // Status.
+#define FLASH_FCRIS_ARIS        0x00000001  // Access Raw Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_FCIM register.
+//
+//*****************************************************************************
+#define FLASH_FCIM_PMASK        0x00000002  // Programming Interrupt Mask.
+#define FLASH_FCIM_AMASK        0x00000001  // Access Interrupt Mask.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_FMIS register.
+//
+//*****************************************************************************
+#define FLASH_FCMISC_PMISC      0x00000002  // Programming Masked Interrupt
+                                            // Status and Clear.
+#define FLASH_FCMISC_AMISC      0x00000001  // Access Masked Interrupt Status
+                                            // and Clear.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_FMPRE and
+// FLASH_FMPPE registers.
+//
+//*****************************************************************************
+#define FLASH_FMP_BLOCK_31      0x80000000  // Enable for block 31
+#define FLASH_FMP_BLOCK_30      0x40000000  // Enable for block 30
+#define FLASH_FMP_BLOCK_29      0x20000000  // Enable for block 29
+#define FLASH_FMP_BLOCK_28      0x10000000  // Enable for block 28
+#define FLASH_FMP_BLOCK_27      0x08000000  // Enable for block 27
+#define FLASH_FMP_BLOCK_26      0x04000000  // Enable for block 26
+#define FLASH_FMP_BLOCK_25      0x02000000  // Enable for block 25
+#define FLASH_FMP_BLOCK_24      0x01000000  // Enable for block 24
+#define FLASH_FMP_BLOCK_23      0x00800000  // Enable for block 23
+#define FLASH_FMP_BLOCK_22      0x00400000  // Enable for block 22
+#define FLASH_FMP_BLOCK_21      0x00200000  // Enable for block 21
+#define FLASH_FMP_BLOCK_20      0x00100000  // Enable for block 20
+#define FLASH_FMP_BLOCK_19      0x00080000  // Enable for block 19
+#define FLASH_FMP_BLOCK_18      0x00040000  // Enable for block 18
+#define FLASH_FMP_BLOCK_17      0x00020000  // Enable for block 17
+#define FLASH_FMP_BLOCK_16      0x00010000  // Enable for block 16
+#define FLASH_FMP_BLOCK_15      0x00008000  // Enable for block 15
+#define FLASH_FMP_BLOCK_14      0x00004000  // Enable for block 14
+#define FLASH_FMP_BLOCK_13      0x00002000  // Enable for block 13
+#define FLASH_FMP_BLOCK_12      0x00001000  // Enable for block 12
+#define FLASH_FMP_BLOCK_11      0x00000800  // Enable for block 11
+#define FLASH_FMP_BLOCK_10      0x00000400  // Enable for block 10
+#define FLASH_FMP_BLOCK_9       0x00000200  // Enable for block 9
+#define FLASH_FMP_BLOCK_8       0x00000100  // Enable for block 8
+#define FLASH_FMP_BLOCK_7       0x00000080  // Enable for block 7
+#define FLASH_FMP_BLOCK_6       0x00000040  // Enable for block 6
+#define FLASH_FMP_BLOCK_5       0x00000020  // Enable for block 5
+#define FLASH_FMP_BLOCK_4       0x00000010  // Enable for block 4
+#define FLASH_FMP_BLOCK_3       0x00000008  // Enable for block 3
+#define FLASH_FMP_BLOCK_2       0x00000004  // Enable for block 2
+#define FLASH_FMP_BLOCK_1       0x00000002  // Enable for block 1
+#define FLASH_FMP_BLOCK_0       0x00000001  // Enable for block 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_USECRL register.
+//
+//*****************************************************************************
+#define FLASH_USECRL_M          0x000000FF  // Microsecond Reload Value.
+#define FLASH_USECRL_S          0
+
+//*****************************************************************************
+//
+// The following are defines for the erase size of the FLASH block that is
+// erased by an erase operation, and the protect size is the size of the FLASH
+// block that is protected by each protection register.
+//
+//*****************************************************************************
+#define FLASH_PROTECT_SIZE      0x00000800
+#define FLASH_ERASE_SIZE        0x00000400
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_FMA register.
+//
+//*****************************************************************************
+#define FLASH_FMA_OFFSET_M      0x0003FFFF  // Address Offset.
+#define FLASH_FMA_OFFSET_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_FMD register.
+//
+//*****************************************************************************
+#define FLASH_FMD_DATA_M        0xFFFFFFFF  // Data Value.
+#define FLASH_FMD_DATA_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_USERDBG register.
+//
+//*****************************************************************************
+#define FLASH_USERDBG_NW        0x80000000  // User Debug Not Written.
+#define FLASH_USERDBG_DATA_M    0x7FFFFFFC  // User Data.
+#define FLASH_USERDBG_DBG1      0x00000002  // Debug Control 1.
+#define FLASH_USERDBG_DBG0      0x00000001  // Debug Control 0.
+#define FLASH_USERDBG_DATA_S    2
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_USERREG0 register.
+//
+//*****************************************************************************
+#define FLASH_USERREG0_NW       0x80000000  // Not Written.
+#define FLASH_USERREG0_DATA_M   0x7FFFFFFF  // User Data.
+#define FLASH_USERREG0_DATA_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_USERREG1 register.
+//
+//*****************************************************************************
+#define FLASH_USERREG1_NW       0x80000000  // Not Written.
+#define FLASH_USERREG1_DATA_M   0x7FFFFFFF  // User Data.
+#define FLASH_USERREG1_DATA_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_RMCTL register.
+//
+//*****************************************************************************
+#define FLASH_RMCTL_BA          0x00000001  // Boot Alias.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_RMVER register.
+//
+//*****************************************************************************
+#define FLASH_RMVER_CONT_M      0xFF000000  // ROM Contents.
+#define FLASH_RMVER_CONT_LM     0x00000000  // Boot Loader &amp; DriverLib
+#define FLASH_RMVER_SIZE_M      0x00FF0000  // ROM Size.
+#define FLASH_RMVER_SIZE_11K    0x00000000  // 11KB Size
+#define FLASH_RMVER_VER_M       0x0000FF00  // ROM Version.
+#define FLASH_RMVER_REV_M       0x000000FF  // ROM Revision.
+#define FLASH_RMVER_VER_S       8
+#define FLASH_RMVER_REV_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_USERREG2 register.
+//
+//*****************************************************************************
+#define FLASH_USERREG2_NW       0x80000000  // Not Written.
+#define FLASH_USERREG2_DATA_M   0x7FFFFFFF  // User Data.
+#define FLASH_USERREG2_DATA_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_USERREG3 register.
+//
+//*****************************************************************************
+#define FLASH_USERREG3_NW       0x80000000  // Not Written.
+#define FLASH_USERREG3_DATA_M   0x7FFFFFFF  // User Data.
+#define FLASH_USERREG3_DATA_S   0
+
+//*****************************************************************************
+//
+// The following definitions are deprecated.
+//
+//*****************************************************************************
+#ifndef DEPRECATED
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the FLASH_FMC
+// register.
+//
+//*****************************************************************************
+#define FLASH_FMC_WRKEY_MASK    0xFFFF0000  // FLASH write key mask
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the FLASH_FCRIS
+// register.
+//
+//*****************************************************************************
+#define FLASH_FCRIS_PROGRAM     0x00000002  // Programming status
+#define FLASH_FCRIS_ACCESS      0x00000001  // Invalid access status
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the FLASH_FCIM
+// register.
+//
+//*****************************************************************************
+#define FLASH_FCIM_PROGRAM      0x00000002  // Programming mask
+#define FLASH_FCIM_ACCESS       0x00000001  // Invalid access mask
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the FLASH_FMIS
+// register.
+//
+//*****************************************************************************
+#define FLASH_FCMISC_PROGRAM    0x00000002  // Programming status
+#define FLASH_FCMISC_ACCESS     0x00000001  // Invalid access status
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the FLASH_USECRL
+// register.
+//
+//*****************************************************************************
+#define FLASH_USECRL_MASK       0x000000FF  // Clock per uSec
+#define FLASH_USECRL_SHIFT      0
+
+#endif
+
+#endif // __HW_FLASH_H__

Added: trunk/src/platform/lm3s/interrupt.c
===================================================================
--- trunk/src/platform/lm3s/interrupt.c	2008-09-10 18:59:17 UTC (rev 88)
+++ trunk/src/platform/lm3s/interrupt.c	2008-09-15 21:54:14 UTC (rev 89)
@@ -0,0 +1,549 @@
+//*****************************************************************************
+//
+// interrupt.c - Driver for the NVIC Interrupt Controller.
+//
+// Copyright (c) 2005-2008 Luminary Micro, Inc.  All rights reserved.
+// 
+// Software License Agreement
+// 
+// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
+// exclusively on LMI's microcontroller products.
+// 
+// The software is owned by LMI and/or its suppliers, and is protected under
+// applicable copyright laws.  All rights are reserved.  You may not combine
+// this software with &quot;viral&quot; open-source software in order to form a larger
+// program.  Any use in violation of the foregoing restrictions may subject
+// the user to criminal sanctions under applicable laws, as well as to civil
+// liability for the breach of the terms and conditions of this license.
+// 
+// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2752 of the Stellaris Peripheral Driver Library.
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+//! \addtogroup interrupt_api
+//! @{
+//
+//*****************************************************************************
+
+#include &quot;hw_ints.h&quot;
+#include &quot;hw_nvic.h&quot;
+#include &quot;hw_types.h&quot;
+#include &quot;cpu.h&quot;
+#include &quot;debug.h&quot;
+#include &quot;interrupt.h&quot;
+
+//*****************************************************************************
+//
+// This is a mapping between priority grouping encodings and the number of
+// preemption priority bits.
+//
+//*****************************************************************************
+static const unsigned long g_pulPriority[] =
+{
+    NVIC_APINT_PRIGROUP_0_8, NVIC_APINT_PRIGROUP_1_7, NVIC_APINT_PRIGROUP_2_6,
+    NVIC_APINT_PRIGROUP_3_5, NVIC_APINT_PRIGROUP_4_4, NVIC_APINT_PRIGROUP_5_3,
+    NVIC_APINT_PRIGROUP_6_2, NVIC_APINT_PRIGROUP_7_1
+};
+
+//*****************************************************************************
+//
+// This is a mapping between interrupt number and the register that contains
+// the priority encoding for that interrupt.
+//
+//*****************************************************************************
+static const unsigned long g_pulRegs[] =
+{
+    0, NVIC_SYS_PRI1, NVIC_SYS_PRI2, NVIC_SYS_PRI3, NVIC_PRI0, NVIC_PRI1,
+    NVIC_PRI2, NVIC_PRI3, NVIC_PRI4, NVIC_PRI5, NVIC_PRI6, NVIC_PRI7,
+    NVIC_PRI8, NVIC_PRI9, NVIC_PRI10, NVIC_PRI11
+};
+
+//*****************************************************************************
+//
+//! \internal
+//! The default interrupt handler.
+//!
+//! This is the default interrupt handler for all interrupts.  It simply loops
+//! forever so that the system state is preserved for observation by a
+//! debugger.  Since interrupts should be disabled before unregistering the
+//! corresponding handler, this should never be called.
+//!
+//! \return None.
+//
+//*****************************************************************************
+static void
+IntDefaultHandler(void)
+{
+    //
+    // Go into an infinite loop.
+    //
+    while(1)
+    {
+    }
+}
+
+//*****************************************************************************
+//
+// The processor vector table.
+//
+// This contains a list of the handlers for the various interrupt sources in
+// the system.  The layout of this list is defined by the hardware; assertion
+// of an interrupt causes the processor to start executing directly at the
+// address given in the corresponding location in this list.
+//
+//*****************************************************************************
+#if defined(ewarm)
+static __no_init void (*g_pfnRAMVectors[NUM_INTERRUPTS])(void) @ &quot;VTABLE&quot;;
+#elif defined(sourcerygxx)
+static __attribute__((section(&quot;.cs3.region-head.ram&quot;)))
+void (*g_pfnRAMVectors[NUM_INTERRUPTS])(void);
+#else
+static __attribute__((section(&quot;vtable&quot;)))
+void (*g_pfnRAMVectors[NUM_INTERRUPTS])(void);
+#endif
+
+//*****************************************************************************
+//
+//! Enables the processor interrupt.
+//!
+//! Allows the processor to respond to interrupts.  This does not affect the
+//! set of interrupts enabled in the interrupt controller; it just gates the
+//! single interrupt from the controller to the processor.
+//!
+//! \note Previously, this function had no return value.  As such, it was
+//! possible to include &lt;tt&gt;interrupt.h&lt;/tt&gt; and call this function without
+//! having included &lt;tt&gt;hw_types.h&lt;/tt&gt;.  Now that the return is a
+//! &lt;tt&gt;tBoolean&lt;/tt&gt;, a compiler error will occur in this case.  The solution
+//! is to include &lt;tt&gt;hw_types.h&lt;/tt&gt; before including &lt;tt&gt;interrupt.h&lt;/tt&gt;.
+//!
+//! \return Returns \b true if interrupts were disabled when the function was
+//! called or \b false if they were initially enabled.
+//
+//*****************************************************************************
+tBoolean
+IntMasterEnable(void)
+{
+    //
+    // Enable processor interrupts.
+    //
+    return(CPUcpsie());
+}
+
+//*****************************************************************************
+//
+//! Disables the processor interrupt.
+//!
+//! Prevents the processor from receiving interrupts.  This does not affect the
+//! set of interrupts enabled in the interrupt controller; it just gates the
+//! single interrupt from the controller to the processor.
+//!
+//! \note Previously, this function had no return value.  As such, it was
+//! possible to include &lt;tt&gt;interrupt.h&lt;/tt&gt; and call this function without
+//! having included &lt;tt&gt;hw_types.h&lt;/tt&gt;.  Now that the return is a
+//! &lt;tt&gt;tBoolean&lt;/tt&gt;, a compiler error will occur in this case.  The solution
+//! is to include &lt;tt&gt;hw_types.h&lt;/tt&gt; before including &lt;tt&gt;interrupt.h&lt;/tt&gt;.
+//!
+//! \return Returns \b true if interrupts were already disabled when the
+//! function was called or \b false if they were initially enabled.
+//
+//*****************************************************************************
+tBoolean
+IntMasterDisable(void)
+{
+    //
+    // Disable processor interrupts.
+    //
+    return(CPUcpsid());
+}
+
+//*****************************************************************************
+//
+//! Registers a function to be called when an interrupt occurs.
+//!
+//! \param ulInterrupt specifies the interrupt in question.
+//! \param pfnHandler is a pointer to the function to be called.
+//!
+//! This function is used to specify the handler function to be called when the
+//! given interrupt is asserted to the processor.  When the interrupt occurs,
+//! if it is enabled (via IntEnable()), the handler function will be called in
+//! interrupt context.  Since the handler function can preempt other code, care
+//! must be taken to protect memory or peripherals that are accessed by the
+//! handler and other non-handler code.
+//!
+//! \note The use of this function (directly or indirectly via a peripheral
+//! driver interrupt register function) moves the interrupt vector table from
+//! flash to SRAM.  Therefore, care must be taken when linking the application
+//! to ensure that the SRAM vector table is located at the beginning of SRAM;
+//! otherwise NVIC will not look in the correct portion of memory for the
+//! vector table (it requires the vector table be on a 1 kB memory alignment).
+//! Normally, the SRAM vector table is so placed via the use of linker scripts;
+//! some tool chains, such as the evaluation version of RV-MDK, do not support
+//! linker scripts and therefore will not produce a valid executable.  See the
+//! discussion of compile-time versus run-time interrupt handler registration
+//! in the introduction to this chapter.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+IntRegister(unsigned long ulInterrupt, void (*pfnHandler)(void))
+{
+    unsigned long ulIdx;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulInterrupt &lt; NUM_INTERRUPTS);
+
+    //
+    // Make sure that the RAM vector table is correctly aligned.
+    //
+    ASSERT(((unsigned long)g_pfnRAMVectors &amp; 0x000003ff) == 0);
+
+    //
+    // See if the RAM vector table has been initialized.
+    //
+    if(HWREG(NVIC_VTABLE) != (unsigned long)g_pfnRAMVectors)
+    {
+        //
+        // Copy the vector table from the beginning of FLASH to the RAM vector
+        // table.
+        //
+        for(ulIdx = 0; ulIdx &lt; NUM_INTERRUPTS; ulIdx++)
+        {
+            g_pfnRAMVectors[ulIdx] = (void (*)(void))HWREG(ulIdx * 4);
+        }
+
+        //
+        // Point NVIC at the RAM vector table.
+        //
+        HWREG(NVIC_VTABLE) = (unsigned long)g_pfnRAMVectors;
+    }
+
+    //
+    // Save the interrupt handler.
+    //
+    g_pfnRAMVectors[ulInterrupt] = pfnHandler;
+}
+
+//*****************************************************************************
+//
+//! Unregisters the function to be called when an interrupt occurs.
+//!
+//! \param ulInterrupt specifies the interrupt in question.
+//!
+//! This function is used to indicate that no handler should be called when the
+//! given interrupt is asserted to the processor.  The interrupt source will be
+//! automatically disabled (via IntDisable()) if necessary.
+//!
+//! \sa IntRegister() for important information about registering interrupt
+//! handlers.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+IntUnregister(unsigned long ulInterrupt)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulInterrupt &lt; NUM_INTERRUPTS);
+
+    //
+    // Reset the interrupt handler.
+    //
+    g_pfnRAMVectors[ulInterrupt] = IntDefaultHandler;
+}
+
+//*****************************************************************************
+//
+//! Sets the priority grouping of the interrupt controller.
+//!
+//! \param ulBits specifies the number of bits of preemptable priority.
+//!
+//! This function specifies the split between preemptable priority levels and
+//! subpriority levels in the interrupt priority specification.  The range of
+//! the grouping values are dependent upon the hardware implementation; on
+//! the Stellaris family, three bits are available for hardware interrupt
+//! prioritization and therefore priority grouping values of three through
+//! seven have the same effect.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+IntPriorityGroupingSet(unsigned long ulBits)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBits &lt; NUM_PRIORITY);
+
+    //
+    // Set the priority grouping.
+    //
+    HWREG(NVIC_APINT) = NVIC_APINT_VECTKEY | g_pulPriority[ulBits];
+}
+
+//*****************************************************************************
+//
+//! Gets the priority grouping of the interrupt controller.
+//!
+//! This function returns the split between preemptable priority levels and
+//! subpriority levels in the interrupt priority specification.
+//!
+//! \return The number of bits of preemptable priority.
+//
+//*****************************************************************************
+unsigned long
+IntPriorityGroupingGet(void)
+{
+    unsigned long ulLoop, ulValue;
+
+    //
+    // Read the priority grouping.
+    //
+    ulValue = HWREG(NVIC_APINT) &amp; NVIC_APINT_PRIGROUP_M;
+
+    //
+    // Loop through the priority grouping values.
+    //
+    for(ulLoop = 0; ulLoop &lt; NUM_PRIORITY; ulLoop++)
+    {
+        //
+        // Stop looping if this value matches.
+        //
+        if(ulValue == g_pulPriority[ulLoop])
+        {
+            break;
+        }
+    }
+
+    //
+    // Return the number of priority bits.
+    //
+    return(ulLoop);
+}
+
+//*****************************************************************************
+//
+//! Sets the priority of an interrupt.
+//!
+//! \param ulInterrupt specifies the interrupt in question.
+//! \param ucPriority specifies the priority of the interrupt.
+//!
+//! This function is used to set the priority of an interrupt.  When multiple
+//! interrupts are asserted simultaneously, the ones with the highest priority
+//! are processed before the lower priority interrupts.  Smaller numbers
+//! correspond to higher interrupt priorities; priority 0 is the highest
+//! interrupt priority.
+//!
+//! The hardware priority mechanism will only look at the upper N bits of the
+//! priority level (where N is 3 for the Stellaris family), so any
+//! prioritization must be performed in those bits.  The remaining bits can be
+//! used to sub-prioritize the interrupt sources, and may be used by the
+//! hardware priority mechanism on a future part.  This arrangement allows
+//! priorities to migrate to different NVIC implementations without changing
+//! the gross prioritization of the interrupts.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+IntPrioritySet(unsigned long ulInterrupt, unsigned char ucPriority)
+{
+    unsigned long ulTemp;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT((ulInterrupt &gt;= 4) &amp;&amp; (ulInterrupt &lt; NUM_INTERRUPTS));
+
+    //
+    // Set the interrupt priority.
+    //
+    ulTemp = HWREG(g_pulRegs[ulInterrupt &gt;&gt; 2]);
+    ulTemp &amp;= ~(0xFF &lt;&lt; (8 * (ulInterrupt &amp; 3)));
+    ulTemp |= ucPriority &lt;&lt; (8 * (ulInterrupt &amp; 3));
+    HWREG(g_pulRegs[ulInterrupt &gt;&gt; 2]) = ulTemp;
+}
+
+//*****************************************************************************
+//
+//! Gets the priority of an interrupt.
+//!
+//! \param ulInterrupt specifies the interrupt in question.
+//!
+//! This function gets the priority of an interrupt.  See IntPrioritySet() for
+//! a definition of the priority value.
+//!
+//! \return Returns the interrupt priority, or -1 if an invalid interrupt was
+//! specified.
+//
+//*****************************************************************************
+long
+IntPriorityGet(unsigned long ulInterrupt)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT((ulInterrupt &gt;= 4) &amp;&amp; (ulInterrupt &lt; NUM_INTERRUPTS));
+
+    //
+    // Return the interrupt priority.
+    //
+    return((HWREG(g_pulRegs[ulInterrupt &gt;&gt; 2]) &gt;&gt; (8 * (ulInterrupt &amp; 3))) &amp;
+           0xFF);
+}
+
+//*****************************************************************************
+//
+//! Enables an interrupt.
+//!
+//! \param ulInterrupt specifies the interrupt to be enabled.
+//!
+//! The specified interrupt is enabled in the interrupt controller.  Other
+//! enables for the interrupt (such as at the peripheral level) are unaffected
+//! by this function.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+IntEnable(unsigned long ulInterrupt)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulInterrupt &lt; NUM_INTERRUPTS);
+
+    //
+    // Determine the interrupt to enable.
+    //
+    if(ulInterrupt == FAULT_MPU)
+    {
+        //
+        // Enable the MemManage interrupt.
+        //
+        HWREG(NVIC_SYS_HND_CTRL) |= NVIC_SYS_HND_CTRL_MEM;
+    }
+    else if(ulInterrupt == FAULT_BUS)
+    {
+        //
+        // Enable the bus fault interrupt.
+        //
+        HWREG(NVIC_SYS_HND_CTRL) |= NVIC_SYS_HND_CTRL_BUS;
+    }
+    else if(ulInterrupt == FAULT_USAGE)
+    {
+        //
+        // Enable the usage fault interrupt.
+        //
+        HWREG(NVIC_SYS_HND_CTRL) |= NVIC_SYS_HND_CTRL_USAGE;
+    }
+    else if(ulInterrupt == FAULT_SYSTICK)
+    {
+        //
+        // Enable the System Tick interrupt.
+        //
+        HWREG(NVIC_ST_CTRL) |= NVIC_ST_CTRL_INTEN;
+    }
+    else if((ulInterrupt &gt;= 16) &amp;&amp; (ulInterrupt &lt;= 47))
+    {
+        //
+        // Enable the general interrupt.
+        //
+        HWREG(NVIC_EN0) = 1 &lt;&lt; (ulInterrupt - 16);
+    }
+    else if(ulInterrupt &gt;= 48)
+    {
+        //
+        // Enable the general interrupt.
+        //
+        HWREG(NVIC_EN1) = 1 &lt;&lt; (ulInterrupt - 48);
+    }
+}
+
+//*****************************************************************************
+//
+//! Disables an interrupt.
+//!
+//! \param ulInterrupt specifies the interrupt to be disabled.
+//!
+//! The specified interrupt is disabled in the interrupt controller.  Other
+//! enables for the interrupt (such as at the peripheral level) are unaffected
+//! by this function.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+IntDisable(unsigned long ulInterrupt)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulInterrupt &lt; NUM_INTERRUPTS);
+
+    //
+    // Determine the interrupt to disable.
+    //
+    if(ulInterrupt == FAULT_MPU)
+    {
+        //
+        // Disable the MemManage interrupt.
+        //
+        HWREG(NVIC_SYS_HND_CTRL) &amp;= ~(NVIC_SYS_HND_CTRL_MEM);
+    }
+    else if(ulInterrupt == FAULT_BUS)
+    {
+        //
+        // Disable the bus fault interrupt.
+        //
+        HWREG(NVIC_SYS_HND_CTRL) &amp;= ~(NVIC_SYS_HND_CTRL_BUS);
+    }
+    else if(ulInterrupt == FAULT_USAGE)
+    {
+        //
+        // Disable the usage fault interrupt.
+        //
+        HWREG(NVIC_SYS_HND_CTRL) &amp;= ~(NVIC_SYS_HND_CTRL_USAGE);
+    }
+    else if(ulInterrupt == FAULT_SYSTICK)
+    {
+        //
+        // Disable the System Tick interrupt.
+        //
+        HWREG(NVIC_ST_CTRL) &amp;= ~(NVIC_ST_CTRL_INTEN);
+    }
+    else if((ulInterrupt &gt;= 16) &amp;&amp; (ulInterrupt &lt;= 47))
+    {
+        //
+        // Disable the general interrupt.
+        //
+        HWREG(NVIC_DIS0) = 1 &lt;&lt; (ulInterrupt - 16);
+    }
+    else if(ulInterrupt &gt;= 48)
+    {
+        //
+        // Disable the general interrupt.
+        //
+        HWREG(NVIC_DIS1) = 1 &lt;&lt; (ulInterrupt - 48);
+    }
+}
+
+//*****************************************************************************
+//
+// Close the Doxygen group.
+//! @}
+//
+//*****************************************************************************

Modified: trunk/src/platform/lm3s/platform.c
===================================================================
--- trunk/src/platform/lm3s/platform.c	2008-09-10 18:59:17 UTC (rev 88)
+++ trunk/src/platform/lm3s/platform.c	2008-09-15 21:54:14 UTC (rev 89)
@@ -9,6 +9,11 @@
 #include &lt;string.h&gt;
 #include &lt;ctype.h&gt;
 #include &lt;stdio.h&gt;
+#include &quot;uip.h&quot;
+#include &quot;uip_arp.h&quot;
+#include &quot;elua_uip.h&quot; 
+#include &quot;uip-conf.h&quot;
+#include &quot;build.h&quot;
 
 // Platform specific includes
 #include &quot;hw_ints.h&quot;
@@ -24,6 +29,10 @@
 #include &quot;timer.h&quot;
 #include &quot;pwm.h&quot;
 #include &quot;utils.h&quot;
+#include &quot;ethernet.h&quot;
+#include &quot;systick.h&quot;
+#include &quot;flash.h&quot;
+#include &quot;interrupt.h&quot;
 
 // *****************************************************************************
 // std function
@@ -47,10 +56,11 @@
 static void spis_init();
 static void pios_init();
 static void pwms_init();
+static void eth_init();
 
 int platform_init()
 { 
-  // Set the clocking to run directly from the crystal.
+  // Set the clocking to run from PLL
   SysCtlClockSet(SYSCTL_SYSDIV_4 | SYSCTL_USE_PLL | SYSCTL_OSC_MAIN | SYSCTL_XTAL_8MHZ);
   
   // Setup PIO
@@ -67,6 +77,9 @@
   
   // Setup PWMs
   pwms_init();                 
+  
+  // Setup ethernet (TCP/IP)
+  eth_init();
 
   // Set the send/recv functions                          
   std_set_send_func( uart_send );
@@ -527,6 +540,101 @@
 }
 
 // ****************************************************************************
+// Ethernet
+
+#define DEFAULT_IPADDR0         192
+#define DEFAULT_IPADDR1         168
+#define DEFAULT_IPADDR2         1
+#define DEFAULT_IPADDR3         13
+#define DEFAULT_NETMASK0        255
+#define DEFAULT_NETMASK1        255
+#define DEFAULT_NETMASK2        255
+#define DEFAULT_NETMASK3        0
+
+static void eth_init()
+{
+#ifdef BUILD_UIP
+  u32 user0, user1, temp;
+  uip_ipaddr_t ipaddr;  
+  static struct uip_eth_addr sTempAddr;     
+
+  // Initialize the TCP/IP Application
+  elua_uip_init();    
+  
+  // Enable and reset the controller
+  SysCtlPeripheralEnable( SYSCTL_PERIPH_ETH );
+  SysCtlPeripheralReset( SYSCTL_PERIPH_ETH );
+  
+  // Enable Ethernet LEDs
+  GPIODirModeSet( GPIO_PORTF_BASE, GPIO_PIN_2 | GPIO_PIN_3, GPIO_DIR_MODE_HW );
+  GPIOPadConfigSet( GPIO_PORTF_BASE, GPIO_PIN_2 | GPIO_PIN_3, GPIO_STRENGTH_2MA, GPIO_PIN_TYPE_STD );
+
+  // Configure SysTick for a periodic interrupt.
+  SysTickPeriodSet(SysCtlClockGet() / SYSTICKHZ);
+  SysTickEnable();
+  SysTickIntEnable();
+  
+  // Intialize the Ethernet Controller and disable all Ethernet Controller interrupt sources.
+  EthernetIntDisable(ETH_BASE, (ETH_INT_PHY | ETH_INT_MDIO | ETH_INT_RXER |
+                     ETH_INT_RXOF | ETH_INT_TX | ETH_INT_TXER | ETH_INT_RX));
+  temp = EthernetIntStatus(ETH_BASE, false);
+  EthernetIntClear(ETH_BASE, temp);  
+  
+  // Initialize the Ethernet Controller for operation.
+  EthernetInitExpClk(ETH_BASE, SysCtlClockGet());
+
+  // Configure the Ethernet Controller for normal operation.
+  // - Full Duplex
+  // - TX CRC Auto Generation
+  // - TX Padding Enabled
+  EthernetConfigSet(ETH_BASE, (ETH_CFG_TX_DPLXEN | ETH_CFG_TX_CRCEN |
+                               ETH_CFG_TX_PADEN));
+
+  // Enable the Ethernet Controller.
+  EthernetEnable(ETH_BASE);
+
+  // Enable the Ethernet interrupt.
+  IntEnable(INT_ETH);
+
+  // Enable the Ethernet RX Packet interrupt source.
+  EthernetIntEnable(ETH_BASE, ETH_INT_RX);  
+
+  // Enable all processor interrupts.
+  IntMasterEnable();
+
+  // Initialize the uIP TCP/IP stack.
+  uip_init();
+  uip_arp_init();
+  uip_ipaddr(ipaddr, DEFAULT_IPADDR0, DEFAULT_IPADDR1, DEFAULT_IPADDR2, DEFAULT_IPADDR3);
+  uip_sethostaddr(ipaddr);
+  uip_ipaddr(ipaddr, DEFAULT_NETMASK0, DEFAULT_NETMASK1, DEFAULT_NETMASK2, DEFAULT_NETMASK3);
+  uip_setnetmask(ipaddr);     
+
+  // Configure the hardware MAC address for Ethernet Controller filtering of
+  // incoming packets.
+  //
+  // For the Ethernet Eval Kits, the MAC address will be stored in the
+  // non-volatile USER0 and USER1 registers.  These registers can be read
+  // using the FlashUserGet function, as illustrated below.
+  FlashUserGet(&amp;user0, &amp;user1);
+  
+  // Convert the 24/24 split MAC address from NV ram into a 32/16 split MAC
+  // address needed to program the hardware registers, then program the MAC
+  // address into the Ethernet Controller registers.
+  sTempAddr.addr[0] = ((user0 &gt;&gt;  0) &amp; 0xff);
+  sTempAddr.addr[1] = ((user0 &gt;&gt;  8) &amp; 0xff);
+  sTempAddr.addr[2] = ((user0 &gt;&gt; 16) &amp; 0xff);
+  sTempAddr.addr[3] = ((user1 &gt;&gt;  0) &amp; 0xff);
+  sTempAddr.addr[4] = ((user1 &gt;&gt;  8) &amp; 0xff);
+  sTempAddr.addr[5] = ((user1 &gt;&gt; 16) &amp; 0xff);  
+
+  // Program the hardware with it's MAC address (for filtering).
+  EthernetMACAddrSet(ETH_BASE, (unsigned char *)&amp;sTempAddr);  
+  uip_setethaddr(sTempAddr);
+#endif
+}
+
+// ****************************************************************************
 // Platform data
 
 u32 platform_pd_get_cpu_frequency()

Modified: trunk/src/platform/lm3s/startup_gcc.c
===================================================================
--- trunk/src/platform/lm3s/startup_gcc.c	2008-09-10 18:59:17 UTC (rev 88)
+++ trunk/src/platform/lm3s/startup_gcc.c	2008-09-15 21:54:14 UTC (rev 89)
@@ -36,6 +36,10 @@
 static void FaultISR(void);
 static void IntDefaultHandler(void);
 
+// External interrupt handlers (used by Ethernet)
+extern void EthernetIntHandler();
+extern void SysTickIntHandler(); 
+
 #include &quot;hw_memmap.h&quot;
 
 //*****************************************************************************
@@ -71,7 +75,7 @@
     IntDefaultHandler,                      // Debug monitor handler
     0,                                      // Reserved
     IntDefaultHandler,                      // The PendSV handler
-    IntDefaultHandler,                      // The SysTick handler
+    SysTickIntHandler,                      // The SysTick handler
     IntDefaultHandler,                      // GPIO Port A
     IntDefaultHandler,                      // GPIO Port B
     IntDefaultHandler,                      // GPIO Port C
@@ -114,7 +118,7 @@
     IntDefaultHandler,                      // CAN0
     IntDefaultHandler,                      // CAN1
     IntDefaultHandler,                      // CAN2
-    IntDefaultHandler,                      // Ethernet
+    EthernetIntHandler,                     // Ethernet
     IntDefaultHandler                       // Hibernate
 };
 

Added: trunk/src/platform/lm3s/systick.c
===================================================================
--- trunk/src/platform/lm3s/systick.c	2008-09-10 18:59:17 UTC (rev 88)
+++ trunk/src/platform/lm3s/systick.c	2008-09-15 21:54:14 UTC (rev 89)
@@ -0,0 +1,263 @@
+//*****************************************************************************
+//
+// systick.c - Driver for the SysTick timer in NVIC.
+//
+// Copyright (c) 2005-2008 Luminary Micro, Inc.  All rights reserved.
+// 
+// Software License Agreement
+// 
+// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
+// exclusively on LMI's microcontroller products.
+// 
+// The software is owned by LMI and/or its suppliers, and is protected under
+// applicable copyright laws.  All rights are reserved.  You may not combine
+// this software with &quot;viral&quot; open-source software in order to form a larger
+// program.  Any use in violation of the foregoing restrictions may subject
+// the user to criminal sanctions under applicable laws, as well as to civil
+// liability for the breach of the terms and conditions of this license.
+// 
+// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2752 of the Stellaris Peripheral Driver Library.
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+//! \addtogroup systick_api
+//! @{
+//
+//*****************************************************************************
+
+#include &quot;hw_ints.h&quot;
+#include &quot;hw_nvic.h&quot;
+#include &quot;hw_types.h&quot;
+#include &quot;debug.h&quot;
+#include &quot;interrupt.h&quot;
+#include &quot;systick.h&quot;
+
+//*****************************************************************************
+//
+//! Enables the SysTick counter.
+//!
+//! This will start the SysTick counter.  If an interrupt handler has been
+//! registered, it will be called when the SysTick counter rolls over.
+//!
+//! \note Calling this function will cause the SysTick counter to (re)commence
+//! counting from its current value.  The counter is not automatically reloaded
+//! with the period as specified in a previous call to SysTickPeriodSet().  If
+//! an immediate reload is required, the \b NVIC_ST_CURRENT register must be
+//! written to force this.  Any write to this register clears the SysTick
+//! counter to 0 and will cause a reload with the supplied period on the next
+//! clock.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+SysTickEnable(void)
+{
+    //
+    // Enable SysTick.
+    //
+    HWREG(NVIC_ST_CTRL) |= NVIC_ST_CTRL_CLK_SRC | NVIC_ST_CTRL_ENABLE;
+}
+
+//*****************************************************************************
+//
+//! Disables the SysTick counter.
+//!
+//! This will stop the SysTick counter.  If an interrupt handler has been
+//! registered, it will no longer be called until SysTick is restarted.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+SysTickDisable(void)
+{
+    //
+    // Disable SysTick.
+    //
+    HWREG(NVIC_ST_CTRL) &amp;= ~(NVIC_ST_CTRL_ENABLE);
+}
+
+//*****************************************************************************
+//
+//! Registers an interrupt handler for the SysTick interrupt.
+//!
+//! \param pfnHandler is a pointer to the function to be called when the
+//! SysTick interrupt occurs.
+//!
+//! This sets the handler to be called when a SysTick interrupt occurs.
+//!
+//! \sa IntRegister() for important information about registering interrupt
+//! handlers.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+SysTickIntRegister(void (*pfnHandler)(void))
+{
+    //
+    // Register the interrupt handler, returning an error if an error occurs.
+    //
+    IntRegister(FAULT_SYSTICK, pfnHandler);
+
+    //
+    // Enable the SysTick interrupt.
+    //
+    HWREG(NVIC_ST_CTRL) |= NVIC_ST_CTRL_INTEN;
+}
+
+//*****************************************************************************
+//
+//! Unregisters the interrupt handler for the SysTick interrupt.
+//!
+//! This function will clear the handler to be called when a SysTick interrupt
+//! occurs.
+//!
+//! \sa IntRegister() for important information about registering interrupt
+//! handlers.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+SysTickIntUnregister(void)
+{
+    //
+    // Disable the SysTick interrupt.
+    //
+    HWREG(NVIC_ST_CTRL) &amp;= ~(NVIC_ST_CTRL_INTEN);
+
+    //
+    // Unregister the interrupt handler.
+    //
+    IntUnregister(FAULT_SYSTICK);
+}
+
+//*****************************************************************************
+//
+//! Enables the SysTick interrupt.
+//!
+//! This function will enable the SysTick interrupt, allowing it to be
+//! reflected to the processor.
+//!
+//! \note The SysTick interrupt handler does not need to clear the SysTick
+//! interrupt source as this is done automatically by NVIC when the interrupt
+//! handler is called.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+SysTickIntEnable(void)
+{
+    //
+    // Enable the SysTick interrupt.
+    //
+    HWREG(NVIC_ST_CTRL) |= NVIC_ST_CTRL_INTEN;
+}
+
+//*****************************************************************************
+//
+//! Disables the SysTick interrupt.
+//!
+//! This function will disable the SysTick interrupt, preventing it from being
+//! reflected to the processor.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+SysTickIntDisable(void)
+{
+    //
+    // Disable the SysTick interrupt.
+    //
+    HWREG(NVIC_ST_CTRL) &amp;= ~(NVIC_ST_CTRL_INTEN);
+}
+
+//*****************************************************************************
+//
+//! Sets the period of the SysTick counter.
+//!
+//! \param ulPeriod is the number of clock ticks in each period of the SysTick
+//! counter; must be between 1 and 16,777,216, inclusive.
+//!
+//! This function sets the rate at which the SysTick counter wraps; this
+//! equates to the number of processor clocks between interrupts.
+//!
+//! \note Calling this function does not cause the SysTick counter to reload
+//! immediately.  If an immediate reload is required, the \b NVIC_ST_CURRENT
+//! register must be written.  Any write to this register clears the SysTick
+//! counter to 0 and will cause a reload with the \e ulPeriod supplied here on
+//! the next clock after the SysTick is enabled.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+SysTickPeriodSet(unsigned long ulPeriod)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT((ulPeriod &gt; 0) &amp;&amp; (ulPeriod &lt;= 16777216));
+
+    //
+    // Set the period of the SysTick counter.
+    //
+    HWREG(NVIC_ST_RELOAD) = ulPeriod - 1;
+}
+
+//*****************************************************************************
+//
+//! Gets the period of the SysTick counter.
+//!
+//! This function returns the rate at which the SysTick counter wraps; this
+//! equates to the number of processor clocks between interrupts.
+//!
+//! \return Returns the period of the SysTick counter.
+//
+//*****************************************************************************
+unsigned long
+SysTickPeriodGet(void)
+{
+    //
+    // Return the period of the SysTick counter.
+    //
+    return(HWREG(NVIC_ST_RELOAD) + 1);
+}
+
+//*****************************************************************************
+//
+//! Gets the current value of the SysTick counter.
+//!
+//! This function returns the current value of the SysTick counter; this will
+//! be a value between the period - 1 and zero, inclusive.
+//!
+//! \return Returns the current value of the SysTick counter.
+//
+//*****************************************************************************
+unsigned long
+SysTickValueGet(void)
+{
+    //
+    // Return the current value of the SysTick counter.
+    //
+    return(HWREG(NVIC_ST_CURRENT));
+}
+
+//*****************************************************************************
+//
+// Close the Doxygen group.
+//! @}
+//
+//*****************************************************************************

Added: trunk/src/platform/lm3s/systick.h
===================================================================
--- trunk/src/platform/lm3s/systick.h	2008-09-10 18:59:17 UTC (rev 88)
+++ trunk/src/platform/lm3s/systick.h	2008-09-15 21:54:14 UTC (rev 89)
@@ -0,0 +1,67 @@
+//*****************************************************************************
+//
+// systick.h - Prototypes for the SysTick driver.
+//
+// Copyright (c) 2005-2008 Luminary Micro, Inc.  All rights reserved.
+// 
+// Software License Agreement
+// 
+// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
+// exclusively on LMI's microcontroller products.
+// 
+// The software is owned by LMI and/or its suppliers, and is protected under
+// applicable copyright laws.  All rights are reserved.  You may not combine
+// this software with &quot;viral&quot; open-source software in order to form a larger
+// program.  Any use in violation of the foregoing restrictions may subject
+// the user to criminal sanctions under applicable laws, as well as to civil
+// liability for the breach of the terms and conditions of this license.
+// 
+// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2752 of the Stellaris Peripheral Driver Library.
+//
+//*****************************************************************************
+
+#ifndef __SYSTICK_H__
+#define __SYSTICK_H__
+
+//*****************************************************************************
+//
+// If building with a C++ compiler, make all of the definitions in this header
+// have a C binding.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+extern &quot;C&quot;
+{
+#endif
+
+//*****************************************************************************
+//
+// Prototypes for the APIs.
+//
+//*****************************************************************************
+extern void SysTickEnable(void);
+extern void SysTickDisable(void);
+extern void SysTickIntRegister(void (*pfnHandler)(void));
+extern void SysTickIntUnregister(void);
+extern void SysTickIntEnable(void);
+extern void SysTickIntDisable(void);
+extern void SysTickPeriodSet(unsigned long ulPeriod);
+extern unsigned long SysTickPeriodGet(void);
+extern unsigned long SysTickValueGet(void);
+
+//*****************************************************************************
+//
+// Mark the end of the C bindings section for C++ compilers.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+}
+#endif
+
+#endif // __SYSTICK_H__

Added: trunk/src/platform/lm3s/uip-conf.h
===================================================================
--- trunk/src/platform/lm3s/uip-conf.h	2008-09-10 18:59:17 UTC (rev 88)
+++ trunk/src/platform/lm3s/uip-conf.h	2008-09-15 21:54:14 UTC (rev 89)
@@ -0,0 +1,153 @@
+//*****************************************************************************
+//
+// uip-conf.h - uIP Project Specific Configuration File
+//
+// Copyright (c) 2007-2008 Luminary Micro, Inc.  All rights reserved.
+// 
+// Software License Agreement
+// 
+// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
+// exclusively on LMI's microcontroller products.
+// 
+// The software is owned by LMI and/or its suppliers, and is protected under
+// applicable copyright laws.  All rights are reserved.  You may not combine
+// this software with &quot;viral&quot; open-source software in order to form a larger
+// program.  Any use in violation of the foregoing restrictions may subject
+// the user to criminal sanctions under applicable laws, as well as to civil
+// liability for the breach of the terms and conditions of this license.
+// 
+// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2752 of the Stellaris Peripheral Driver Library.
+//
+//*****************************************************************************
+
+#ifndef __UIP_CONF_H__
+#define __UIP_CONF_H__
+
+// Added for eLua: SYSTICK data
+#define SYSTICKHZ               4
+#define SYSTICKMS               (1000 / SYSTICKHZ)
+#define SYSTICKUS               (1000000 / SYSTICKHZ)
+#define SYSTICKNS               (1000000000 / SYSTICKHZ)
+
+//
+// 8 bit datatype
+// This typedef defines the 8-bit type used throughout uIP.
+//
+typedef unsigned char u8_t;
+
+//
+// 16 bit datatype
+// This typedef defines the 16-bit type used throughout uIP.
+//
+typedef unsigned short u16_t;
+
+//
+// Statistics datatype
+// This typedef defines the dataype used for keeping statistics in
+// uIP.
+//
+typedef unsigned short uip_stats_t;
+
+//
+// Ping IP address assignment
+// Use first incoming &quot;ping&quot; packet to derive host IP address
+//
+#define UIP_CONF_PINGADDRCONF       0
+
+// 
+// TCP support on or off
+//
+#define UIP_CONF_TCP                1
+
+//
+// UDP support on or off
+//
+#define UIP_CONF_UDP                0
+
+//
+// UDP checksums on or off
+// (not currently supported ... should be 0)
+//
+#define UIP_CONF_UDP_CHECKSUMS      0
+
+//
+// UDP Maximum Connections
+//
+#define UIP_CONF_UDP_CONNS          2
+
+//
+// Maximum number of TCP connections.
+//
+#define UIP_CONF_MAX_CONNECTIONS    4
+
+//
+// Maximum number of listening TCP ports.
+//
+#define UIP_CONF_MAX_LISTENPORTS    4
+
+//
+// Size of advertised receiver's window
+//
+//#define UIP_CONF_RECEIVE_WINDOW     400
+
+//
+// Size of ARP table
+//
+#define UIP_CONF_ARPTAB_SIZE        4
+
+//
+// uIP buffer size.
+//
+#define UIP_CONF_BUFFER_SIZE        1600
+
+//
+// uIP statistics on or off
+//
+#define UIP_CONF_STATISTICS         0
+
+//
+// Logging on or off
+//
+#define UIP_CONF_LOGGING            0
+
+//
+// Broadcast Support
+//
+#define UIP_CONF_BROADCAST          0
+
+//
+// Link-Level Header length
+//
+#define UIP_CONF_LLH_LEN            14
+
+//
+// CPU byte order.
+//
+#define UIP_CONF_BYTE_ORDER         LITTLE_ENDIAN
+
+//
+// Here we include the header file for the application we are using in
+// this example
+#include &quot;elua_uip.h&quot;
+
+//
+// Define the uIP Application State type
+//
+typedef struct elua_uip_state uip_tcp_appstate_t;
+
+//
+// UIP_APPCALL: the name of the application function. This function
+// must return void and take no arguments (i.e., C type &quot;void
+// appfunc(void)&quot;).
+//
+#ifndef UIP_APPCALL
+#define UIP_APPCALL     elua_uip_appcall
+#endif
+
+#endif // __UIP_CONF_H_

Added: trunk/src/platform/lm3s/uip_support.c
===================================================================
--- trunk/src/platform/lm3s/uip_support.c	2008-09-10 18:59:17 UTC (rev 88)
+++ trunk/src/platform/lm3s/uip_support.c	2008-09-15 21:54:14 UTC (rev 89)
@@ -0,0 +1,182 @@
+// UIP support functions
+
+#include &quot;build.h&quot;
+#ifdef BUILD_UIP
+
+#include &quot;hw_types.h&quot;
+#include &quot;hw_ints.h&quot;
+#include &quot;hw_ethernet.h&quot;
+#include &quot;hw_memmap.h&quot;
+#include &quot;ethernet.h&quot;
+#include &quot;type.h&quot;
+#include &quot;hw_nvic.h&quot;
+#include &quot;uip.h&quot;
+#include &quot;uip_arp.h&quot;
+
+// Interrupt flags
+#define INT_TIMER     1
+#define INT_ETH_RX    2
+static u8 int_flags;
+
+// Timers
+static u32 periodic_timer;
+static u32 arp_timer;
+
+// Macro for accessing the Ethernet header information in the buffer.
+#define BUF                     ((struct uip_eth_hdr *)&amp;uip_buf[0])
+
+// UIP Timers (in ms)
+#define UIP_PERIODIC_TIMER_MS   500
+#define UIP_ARP_TIMER_MS        10000
+
+// This gets called on both Ethernet RX interrupts and timer requests,
+// but it's called only from the Ethernet interrupt handler
+static void uip_support_func()
+{
+  long packet_len;
+  u32 temp;
+  
+  // If SysTick, Clear the SysTick interrupt flag and increment the
+  // timers.
+  if( int_flags &amp; INT_TIMER )
+  {
+    int_flags &amp;= ( u8 )~INT_TIMER;
+    periodic_timer += SYSTICKMS;
+    arp_timer += SYSTICKMS;
+  }
+
+  // Check for an RX packet and read it
+  packet_len = EthernetPacketGetNonBlocking(ETH_BASE, uip_buf, sizeof(uip_buf));
+  if(packet_len &gt; 0)
+  {
+    // Set uip_len for uIP stack usage.
+    uip_len = (unsigned short)packet_len;
+
+    // Clear the RX Packet event and renable RX Packet interrupts.
+    if( int_flags &amp; INT_ETH_RX )
+    {
+      int_flags &amp;= ( u8 )~INT_ETH_RX;
+      EthernetIntEnable(ETH_BASE, ETH_INT_RX);
+    }
+
+    // Process incoming IP packets here.
+    if(BUF-&gt;type == htons(UIP_ETHTYPE_IP))
+    {
+      uip_arp_ipin();
+      uip_input();
+
+      // If the above function invocation resulted in data that
+      // should be sent out on the network, the global variable
+      // uip_len is set to a value &gt; 0.
+      if(uip_len &gt; 0)
+      {
+        uip_arp_out();
+        EthernetPacketPut(ETH_BASE, uip_buf, uip_len);
+        uip_len = 0;
+      }
+    }
+
+    // Process incoming ARP packets here.
+    else if(BUF-&gt;type == htons(UIP_ETHTYPE_ARP))
+    {
+      uip_arp_arpin();
+
+      // If the above function invocation resulted in data that
+      // should be sent out on the network, the global variable
+      // uip_len is set to a value &gt; 0.
+      if(uip_len &gt; 0)
+      {
+          EthernetPacketPut(ETH_BASE, uip_buf, uip_len);
+          uip_len = 0;
+      }
+    }
+  }  
+  
+  // Process TCP/IP Periodic Timer here.
+  if(periodic_timer &gt;= UIP_PERIODIC_TIMER_MS)
+  {
+    periodic_timer = 0;
+    for( temp = 0; temp &lt; UIP_CONNS; temp ++ )
+    {
+      uip_periodic(temp);
+
+      // If the above function invocation resulted in data that
+      // should be sent out on the network, the global variable
+      // uip_len is set to a value &gt; 0.
+      if(uip_len &gt; 0)
+      {
+        uip_arp_out();
+        EthernetPacketPut(ETH_BASE, uip_buf, uip_len);
+        uip_len = 0;
+      }
+    }
+
+#if UIP_UDP
+    for( temp = 0; temp &lt; UIP_UDP_CONNS; temp ++ )
+    {
+      uip_udp_periodic( temp );
+
+      // If the above function invocation resulted in data that
+      // should be sent out on the network, the global variable
+      // uip_len is set to a value &gt; 0.
+      if(uip_len &gt; 0)
+      {
+        uip_arp_out();
+        EthernetPacketPut(ETH_BASE, uip_buf, uip_len);
+        uip_len = 0;
+      }
+    }
+#endif // UIP_UDP
+  }  
+  
+  // Process ARP Timer here.
+  if(arp_timer &gt;= UIP_ARP_TIMER_MS)
+  {
+    arp_timer = 0;
+    uip_arp_timer();
+  }  
+}
+
+void SysTickIntHandler()
+{
+  // Indicate that a SysTick interrupt has occurred.
+  int_flags |= INT_TIMER;
+
+  // Generate a fake Ethernet interrupt.  This will perform the actual work
+  // of incrementing the timers and taking the appropriate actions.
+  HWREG(NVIC_SW_TRIG) |= INT_ETH - 16;
+}
+
+void EthernetIntHandler()
+{
+  u32 temp;
+  
+  // Read and Clear the interrupt.
+  temp = EthernetIntStatus(ETH_BASE, false);
+  EthernetIntClear(ETH_BASE, temp);
+
+  // Check to see if an RX Interrupt has occured.
+  if(temp &amp; ETH_INT_RX)
+  {
+    // Indicate that a packet has been received.
+    int_flags |= INT_ETH_RX;
+
+    // Disable Ethernet RX Interrupt.
+    EthernetIntDisable(ETH_BASE, ETH_INT_RX);
+  }
+  
+  uip_support_func();
+}
+
+#else // #ifdef BUILD_UIP
+
+// &quot;Dummy&quot; (empty) handler functions
+void EthernetIntHandler()
+{
+}
+
+void SysTickIntHandler()
+{
+}
+
+#endif // #ifdef BUILD_UIP

Added: trunk/src/uip/clock.h
===================================================================
--- trunk/src/uip/clock.h	2008-09-10 18:59:17 UTC (rev 88)
+++ trunk/src/uip/clock.h	2008-09-15 21:54:14 UTC (rev 89)
@@ -0,0 +1,88 @@
+/**
+ * \defgroup clock Clock interface
+ *
+ * The clock interface is the interface between the \ref timer &quot;timer library&quot;
+ * and the platform specific clock functionality. The clock
+ * interface must be implemented for each platform that uses the \ref
+ * timer &quot;timer library&quot;.
+ *
+ * The clock interface does only one this: it measures time. The clock
+ * interface provides a macro, CLOCK_SECOND, which corresponds to one
+ * second of system time.
+ *
+ * \sa \ref timer &quot;Timer library&quot;
+ *
+ * @{
+ */
+
+/*
+ * Copyright (c) 2004, Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the Institute nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * This file is part of the uIP TCP/IP stack
+ *
+ * Author: Adam Dunkels &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">adam at sics.se</A>&gt;
+ *
+ * $Id: clock.h,v 1.3 2006/06/11 21:46:39 adam Exp $
+ */
+#ifndef __CLOCK_H__
+#define __CLOCK_H__
+
+#include &quot;clock-arch.h&quot;
+
+/**
+ * Initialize the clock library.
+ *
+ * This function initializes the clock library and should be called
+ * from the main() function of the system.
+ *
+ */
+void clock_init(void);
+
+/**
+ * Get the current clock time.
+ *
+ * This function returns the current system clock time.
+ *
+ * \return The current clock time, measured in system ticks.
+ */
+clock_time_t clock_time(void);
+
+/**
+ * A second, measured in system clock time.
+ *
+ * \hideinitializer
+ */
+#ifdef CLOCK_CONF_SECOND
+#define CLOCK_SECOND CLOCK_CONF_SECOND
+#else
+#define CLOCK_SECOND (clock_time_t)32
+#endif
+
+#endif /* __CLOCK_H__ */
+
+/** @} */

Added: trunk/src/uip/lc-addrlabels.h
===================================================================
--- trunk/src/uip/lc-addrlabels.h	2008-09-10 18:59:17 UTC (rev 88)
+++ trunk/src/uip/lc-addrlabels.h	2008-09-15 21:54:14 UTC (rev 89)
@@ -0,0 +1,83 @@
+/*
+ * Copyright (c) 2004-2005, Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the Institute nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * This file is part of the uIP TCP/IP stack
+ *
+ * Author: Adam Dunkels &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">adam at sics.se</A>&gt;
+ *
+ * $Id: lc-addrlabels.h,v 1.3 2006/06/12 08:00:30 adam Exp $
+ */
+
+/**
+ * \addtogroup lc
+ * @{
+ */
+
+/**
+ * \file
+ * Implementation of local continuations based on the &quot;Labels as
+ * values&quot; feature of gcc
+ * \author
+ * Adam Dunkels &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">adam at sics.se</A>&gt;
+ *
+ * This implementation of local continuations is based on a special
+ * feature of the GCC C compiler called &quot;labels as values&quot;. This
+ * feature allows assigning pointers with the address of the code
+ * corresponding to a particular C label.
+ *
+ * For more information, see the GCC documentation:
+ * <A HREF="http://gcc.gnu.org/onlinedocs/gcc/Labels-as-Values.html">http://gcc.gnu.org/onlinedocs/gcc/Labels-as-Values.html</A>
+ *
+ * Thanks to dividuum for finding the nice local scope label
+ * implementation.
+ */
+
+#ifndef __LC_ADDRLABELS_H__
+#define __LC_ADDRLABELS_H__
+
+/** \hideinitializer */
+typedef void * lc_t;
+
+#define LC_INIT(s) s = NULL
+
+
+#define LC_RESUME(s)                            \
+  do {                                          \
+    if(s != NULL) {                             \
+      goto *s;                                  \
+    }                                           \
+  } while(0)
+
+#define LC_SET(s)                               \
+  do { ({ __label__ resume; resume: (s) = &amp;&resume; }); }while(0)
+
+#define LC_END(s)
+
+#endif /* __LC_ADDRLABELS_H__ */
+
+/**  @} */

Added: trunk/src/uip/lc-switch.h
===================================================================
--- trunk/src/uip/lc-switch.h	2008-09-10 18:59:17 UTC (rev 88)
+++ trunk/src/uip/lc-switch.h	2008-09-15 21:54:14 UTC (rev 89)
@@ -0,0 +1,76 @@
+/*
+ * Copyright (c) 2004-2005, Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the Institute nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * This file is part of the uIP TCP/IP stack
+ *
+ * Author: Adam Dunkels &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">adam at sics.se</A>&gt;
+ *
+ * $Id: lc-switch.h,v 1.2 2006/06/12 08:00:30 adam Exp $
+ */
+
+/**
+ * \addtogroup lc
+ * @{
+ */
+
+/**
+ * \file
+ * Implementation of local continuations based on switch() statment
+ * \author Adam Dunkels &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">adam at sics.se</A>&gt;
+ *
+ * This implementation of local continuations uses the C switch()
+ * statement to resume execution of a function somewhere inside the
+ * function's body. The implementation is based on the fact that
+ * switch() statements are able to jump directly into the bodies of
+ * control structures such as if() or while() statmenets.
+ *
+ * This implementation borrows heavily from Simon Tatham's coroutines
+ * implementation in C:
+ * <A HREF="http://www.chiark.greenend.org.uk/~sgtatham/coroutines.html">http://www.chiark.greenend.org.uk/~sgtatham/coroutines.html</A>
+ */
+
+#ifndef __LC_SWITCH_H__
+#define __LC_SWTICH_H__
+
+/* WARNING! lc implementation using switch() does not work if an
+   LC_SET() is done within another switch() statement! */
+
+/** \hideinitializer */
+typedef unsigned short lc_t;
+
+#define LC_INIT(s) s = 0;
+
+#define LC_RESUME(s) switch(s) { case 0:
+
+#define LC_SET(s) s = __LINE__; case __LINE__:
+
+#define LC_END(s) }
+
+#endif /* __LC_SWITCH_H__ */
+
+/** @} */

Added: trunk/src/uip/lc.h
===================================================================
--- trunk/src/uip/lc.h	2008-09-10 18:59:17 UTC (rev 88)
+++ trunk/src/uip/lc.h	2008-09-15 21:54:14 UTC (rev 89)
@@ -0,0 +1,131 @@
+/*
+ * Copyright (c) 2004-2005, Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the Institute nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * This file is part of the uIP TCP/IP stack
+ *
+ * Author: Adam Dunkels &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">adam at sics.se</A>&gt;
+ *
+ * $Id: lc.h,v 1.2 2006/06/12 08:00:30 adam Exp $
+ */
+
+/**
+ * \addtogroup pt
+ * @{
+ */
+
+/**
+ * \defgroup lc Local continuations
+ * @{
+ *
+ * Local continuations form the basis for implementing protothreads. A
+ * local continuation can be &lt;i&gt;set&lt;/i&gt; in a specific function to
+ * capture the state of the function. After a local continuation has
+ * been set can be &lt;i&gt;resumed&lt;/i&gt; in order to restore the state of the
+ * function at the point where the local continuation was set.
+ *
+ *
+ */
+
+/**
+ * \file lc.h
+ * Local continuations
+ * \author
+ * Adam Dunkels &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">adam at sics.se</A>&gt;
+ *
+ */
+
+#ifdef DOXYGEN
+/**
+ * Initialize a local continuation.
+ *
+ * This operation initializes the local continuation, thereby
+ * unsetting any previously set continuation state.
+ *
+ * \hideinitializer
+ */
+#define LC_INIT(lc)
+
+/**
+ * Set a local continuation.
+ *
+ * The set operation saves the state of the function at the point
+ * where the operation is executed. As far as the set operation is
+ * concerned, the state of the function does &lt;b&gt;not&lt;/b&gt; include the
+ * call-stack or local (automatic) variables, but only the program
+ * counter and such CPU registers that needs to be saved.
+ *
+ * \hideinitializer
+ */
+#define LC_SET(lc)
+
+/**
+ * Resume a local continuation.
+ *
+ * The resume operation resumes a previously set local continuation, thus
+ * restoring the state in which the function was when the local
+ * continuation was set. If the local continuation has not been
+ * previously set, the resume operation does nothing.
+ *
+ * \hideinitializer
+ */
+#define LC_RESUME(lc)
+
+/**
+ * Mark the end of local continuation usage.
+ *
+ * The end operation signifies that local continuations should not be
+ * used any more in the function. This operation is not needed for
+ * most implementations of local continuation, but is required by a
+ * few implementations.
+ *
+ * \hideinitializer
+ */
+#define LC_END(lc)
+
+/**
+ * \var typedef lc_t;
+ *
+ * The local continuation type.
+ *
+ * \hideinitializer
+ */
+#endif /* DOXYGEN */
+
+#ifndef __LC_H__
+#define __LC_H__
+
+#ifdef LC_CONF_INCLUDE
+#include LC_CONF_INCLUDE
+#else
+#include &quot;lc-switch.h&quot;
+#endif /* LC_CONF_INCLUDE */
+
+#endif /* __LC_H__ */
+
+/** @} */
+/** @} */

Added: trunk/src/uip/psock.c
===================================================================
--- trunk/src/uip/psock.c	2008-09-10 18:59:17 UTC (rev 88)
+++ trunk/src/uip/psock.c	2008-09-15 21:54:14 UTC (rev 89)
@@ -0,0 +1,344 @@
+#include &quot;build.h&quot;
+
+#ifdef BUILD_UIP
+
+/*
+ * Copyright (c) 2004, Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the Institute nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * This file is part of the uIP TCP/IP stack
+ *
+ * Author: Adam Dunkels &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">adam at sics.se</A>&gt;
+ *
+ * $Id: psock.c,v 1.2 2006/06/12 08:00:30 adam Exp $
+ */
+
+#include &lt;stdio.h&gt;
+#include &lt;string.h&gt;
+
+#include &quot;uipopt.h&quot;
+#include &quot;psock.h&quot;
+#include &quot;uip.h&quot;
+
+#define STATE_NONE 0
+#define STATE_ACKED 1
+#define STATE_READ 2
+#define STATE_BLOCKED_NEWDATA 3
+#define STATE_BLOCKED_CLOSE 4
+#define STATE_BLOCKED_SEND 5
+#define STATE_DATA_SENT 6
+
+/*
+ * Return value of the buffering functions that indicates that a
+ * buffer was not filled by incoming data.
+ *
+ */
+#define BUF_NOT_FULL 0
+#define BUF_NOT_FOUND 0
+
+/*
+ * Return value of the buffering functions that indicates that a
+ * buffer was completely filled by incoming data.
+ *
+ */
+#define BUF_FULL 1
+
+/*
+ * Return value of the buffering functions that indicates that an
+ * end-marker byte was found.
+ *
+ */
+#define BUF_FOUND 2
+
+/*---------------------------------------------------------------------------*/
+static void
+buf_setup(struct psock_buf *buf,
+	  u8_t *bufptr, u16_t bufsize)
+{
+  buf-&gt;ptr = bufptr;
+  buf-&gt;left = bufsize;
+}
+/*---------------------------------------------------------------------------*/
+static u8_t
+buf_bufdata(struct psock_buf *buf, u16_t len,
+	    u8_t **dataptr, u16_t *datalen)
+{
+  if(*datalen &lt; buf-&gt;left) {
+    memcpy(buf-&gt;ptr, *dataptr, *datalen);
+    buf-&gt;ptr += *datalen;
+    buf-&gt;left -= *datalen;
+    *dataptr += *datalen;
+    *datalen = 0;
+    return BUF_NOT_FULL;
+  } else if(*datalen == buf-&gt;left) {
+    memcpy(buf-&gt;ptr, *dataptr, *datalen);
+    buf-&gt;ptr += *datalen;
+    buf-&gt;left = 0;
+    *dataptr += *datalen;
+    *datalen = 0;
+    return BUF_FULL;
+  } else {
+    memcpy(buf-&gt;ptr, *dataptr, buf-&gt;left);
+    buf-&gt;ptr += buf-&gt;left;
+    *datalen -= buf-&gt;left;
+    *dataptr += buf-&gt;left;
+    buf-&gt;left = 0;
+    return BUF_FULL;
+  }
+}
+/*---------------------------------------------------------------------------*/
+static u8_t
+buf_bufto(register struct psock_buf *buf, u8_t endmarker,
+	  register u8_t **dataptr, register u16_t *datalen)
+{
+  u8_t c;
+  while(buf-&gt;left &gt; 0 &amp;&amp; *datalen &gt; 0) {
+    c = *buf-&gt;ptr = **dataptr;
+    ++*dataptr;
+    ++buf-&gt;ptr;
+    --*datalen;
+    --buf-&gt;left;
+    
+    if(c == endmarker) {
+      return BUF_FOUND;
+    }
+  }
+
+  if(*datalen == 0) {
+    return BUF_NOT_FOUND;
+  }
+
+  while(*datalen &gt; 0) {
+    c = **dataptr;
+    --*datalen;
+    ++*dataptr;
+    
+    if(c == endmarker) {
+      return BUF_FOUND | BUF_FULL;
+    }
+  }
+  
+  return BUF_FULL;
+}
+/*---------------------------------------------------------------------------*/
+static char
+send_data(register struct psock *s)
+{
+  if(s-&gt;state != STATE_DATA_SENT || uip_rexmit()) {
+    if(s-&gt;sendlen &gt; uip_mss()) {
+      uip_send(s-&gt;sendptr, uip_mss());
+    } else {
+      uip_send(s-&gt;sendptr, s-&gt;sendlen);
+    }
+    s-&gt;state = STATE_DATA_SENT;
+    return 1;
+  }
+  return 0;
+}
+/*---------------------------------------------------------------------------*/
+static char
+data_acked(register struct psock *s)
+{
+  if(s-&gt;state == STATE_DATA_SENT &amp;&amp; uip_acked()) {
+    if(s-&gt;sendlen &gt; uip_mss()) {
+      s-&gt;sendlen -= uip_mss();
+      s-&gt;sendptr += uip_mss();
+    } else {
+      s-&gt;sendptr += s-&gt;sendlen;
+      s-&gt;sendlen = 0;
+    }
+    s-&gt;state = STATE_ACKED;
+    return 1;
+  }
+  return 0;
+}
+/*---------------------------------------------------------------------------*/
+PT_THREAD(psock_send(register struct psock *s, const char *buf,
+		     unsigned int len))
+{
+  PT_BEGIN(&amp;s-&gt;psockpt);
+
+  /* If there is no data to send, we exit immediately. */
+  if(len == 0) {
+    PT_EXIT(&amp;s-&gt;psockpt);
+  }
+
+  /* Save the length of and a pointer to the data that is to be
+     sent. */
+  s-&gt;sendptr = buf;
+  s-&gt;sendlen = len;
+
+  s-&gt;state = STATE_NONE;
+
+  /* We loop here until all data is sent. The s-&gt;sendlen variable is
+     updated by the data_sent() function. */
+  while(s-&gt;sendlen &gt; 0) {
+
+    /*
+     * The condition for this PT_WAIT_UNTIL is a little tricky: the
+     * protothread will wait here until all data has been acknowledged
+     * (data_acked() returns true) and until all data has been sent
+     * (send_data() returns true). The two functions data_acked() and
+     * send_data() must be called in succession to ensure that all
+     * data is sent. Therefore the &amp; operator is used instead of the
+     * &amp;&amp; operator, which would cause only the data_acked() function
+     * to be called when it returns false.
+     */
+    PT_WAIT_UNTIL(&amp;s-&gt;psockpt, data_acked(s) &amp; send_data(s));
+  }
+
+  s-&gt;state = STATE_NONE;
+  
+  PT_END(&amp;s-&gt;psockpt);
+}
+/*---------------------------------------------------------------------------*/
+PT_THREAD(psock_generator_send(register struct psock *s,
+			       unsigned short (*generate)(void *), void *arg))
+{
+  PT_BEGIN(&amp;s-&gt;psockpt);
+
+  /* Ensure that there is a generator function to call. */
+  if(generate == NULL) {
+    PT_EXIT(&amp;s-&gt;psockpt);
+  }
+
+  /* Call the generator function to generate the data in the
+     uip_appdata buffer. */
+  s-&gt;sendlen = generate(arg);
+  s-&gt;sendptr = uip_appdata;
+
+  s-&gt;state = STATE_NONE;  
+  do {
+    /* Call the generator function again if we are called to perform a
+       retransmission. */
+    if(uip_rexmit()) {
+      generate(arg);
+    }
+    /* Wait until all data is sent and acknowledged. */
+    PT_WAIT_UNTIL(&amp;s-&gt;psockpt, data_acked(s) &amp; send_data(s));
+  } while(s-&gt;sendlen &gt; 0);
+  
+  s-&gt;state = STATE_NONE;
+  
+  PT_END(&amp;s-&gt;psockpt);
+}
+/*---------------------------------------------------------------------------*/
+u16_t
+psock_datalen(struct psock *psock)
+{
+  return psock-&gt;bufsize - psock-&gt;buf.left;
+}
+/*---------------------------------------------------------------------------*/
+char
+psock_newdata(struct psock *s)
+{
+  if(s-&gt;readlen &gt; 0) {
+    /* There is data in the uip_appdata buffer that has not yet been
+       read with the PSOCK_READ functions. */
+    return 1;
+  } else if(s-&gt;state == STATE_READ) {
+    /* All data in uip_appdata buffer already consumed. */
+    s-&gt;state = STATE_BLOCKED_NEWDATA;
+    return 0;
+  } else if(uip_newdata()) {
+    /* There is new data that has not been consumed. */
+    return 1;
+  } else {
+    /* There is no new data. */
+    return 0;
+  }
+}
+/*---------------------------------------------------------------------------*/
+PT_THREAD(psock_readto(register struct psock *psock, unsigned char c))
+{
+  PT_BEGIN(&amp;psock-&gt;psockpt);
+
+  buf_setup(&amp;psock-&gt;buf, psock-&gt;bufptr, psock-&gt;bufsize);
+  
+  /* XXX: Should add buf_checkmarker() before do{} loop, if
+     incoming data has been handled while waiting for a write. */
+
+  do {
+    if(psock-&gt;readlen == 0) {
+      PT_WAIT_UNTIL(&amp;psock-&gt;psockpt, psock_newdata(psock));
+      psock-&gt;state = STATE_READ;
+      psock-&gt;readptr = (u8_t *)uip_appdata;
+      psock-&gt;readlen = uip_datalen();
+    }
+  } while((buf_bufto(&amp;psock-&gt;buf, c,
+		     &amp;psock-&gt;readptr,
+		     &amp;psock-&gt;readlen) &amp; BUF_FOUND) == 0);
+  
+  if(psock_datalen(psock) == 0) {
+    psock-&gt;state = STATE_NONE;
+    PT_RESTART(&amp;psock-&gt;psockpt);
+  }
+  PT_END(&amp;psock-&gt;psockpt);
+}
+/*---------------------------------------------------------------------------*/
+PT_THREAD(psock_readbuf(register struct psock *psock))
+{
+  PT_BEGIN(&amp;psock-&gt;psockpt);
+
+  buf_setup(&amp;psock-&gt;buf, psock-&gt;bufptr, psock-&gt;bufsize);
+  
+  /* XXX: Should add buf_checkmarker() before do{} loop, if
+     incoming data has been handled while waiting for a write. */
+
+  do {
+    if(psock-&gt;readlen == 0) {
+      PT_WAIT_UNTIL(&amp;psock-&gt;psockpt, psock_newdata(psock));
+      printf(&quot;Waited for newdata\n&quot;);
+      psock-&gt;state = STATE_READ;
+      psock-&gt;readptr = (u8_t *)uip_appdata;
+      psock-&gt;readlen = uip_datalen();
+    }
+  } while(buf_bufdata(&amp;psock-&gt;buf, psock-&gt;bufsize,
+			 &amp;psock-&gt;readptr,
+			 &amp;psock-&gt;readlen) != BUF_FULL);
+
+  if(psock_datalen(psock) == 0) {
+    psock-&gt;state = STATE_NONE;
+    PT_RESTART(&amp;psock-&gt;psockpt);
+  }
+  PT_END(&amp;psock-&gt;psockpt);
+}
+/*---------------------------------------------------------------------------*/
+void
+psock_init(register struct psock *psock, char *buffer, unsigned int buffersize)
+{
+  psock-&gt;state = STATE_NONE;
+  psock-&gt;readlen = 0;
+  psock-&gt;bufptr = buffer;
+  psock-&gt;bufsize = buffersize;
+  buf_setup(&amp;psock-&gt;buf, buffer, buffersize);
+  PT_INIT(&amp;psock-&gt;pt);
+  PT_INIT(&amp;psock-&gt;psockpt);
+}
+/*---------------------------------------------------------------------------*/
+
+#endif // #ifdef BUILD_UIP
\ No newline at end of file

Added: trunk/src/uip/psock.h
===================================================================
--- trunk/src/uip/psock.h	2008-09-10 18:59:17 UTC (rev 88)
+++ trunk/src/uip/psock.h	2008-09-15 21:54:14 UTC (rev 89)
@@ -0,0 +1,380 @@
+/*
+ * Copyright (c) 2004, Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the Institute nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * This file is part of the uIP TCP/IP stack
+ *
+ * Author: Adam Dunkels &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">adam at sics.se</A>&gt;
+ *
+ * $Id: psock.h,v 1.3 2006/06/12 08:00:30 adam Exp $
+ */
+
+/**
+ * \defgroup psock Protosockets library
+ * @{
+ *
+ * The protosocket library provides an interface to the uIP stack that is
+ * similar to the traditional BSD socket interface. Unlike programs
+ * written for the ordinary uIP event-driven interface, programs
+ * written with the protosocket library are executed in a sequential
+ * fashion and does not have to be implemented as explicit state
+ * machines.
+ *
+ * Protosockets only work with TCP connections.
+ *
+ * The protosocket library uses \ref pt protothreads to provide
+ * sequential control flow. This makes the protosockets lightweight in
+ * terms of memory, but also means that protosockets inherits the
+ * functional limitations of protothreads. Each protosocket lives only
+ * within a single function. Automatic variables (stack variables) are
+ * not retained across a protosocket library function call.
+ *
+ * \note Because the protosocket library uses protothreads, local
+ * variables will not always be saved across a call to a protosocket
+ * library function. It is therefore advised that local variables are
+ * used with extreme care.
+ *
+ * The protosocket library provides functions for sending data without
+ * having to deal with retransmissions and acknowledgements, as well
+ * as functions for reading data without having to deal with data
+ * being split across more than one TCP segment.
+ *
+ * Because each protosocket runs as a protothread, the protosocket has to be
+ * started with a call to PSOCK_BEGIN() at the start of the function
+ * in which the protosocket is used. Similarly, the protosocket protothread can
+ * be terminated by a call to PSOCK_EXIT().
+ *
+ */
+
+/**
+ * \file
+ * Protosocket library header file
+ * \author
+ * Adam Dunkels &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">adam at sics.se</A>&gt;
+ *
+ */
+
+#ifndef __PSOCK_H__
+#define __PSOCK_H__
+
+#include &quot;uipopt.h&quot;
+#include &quot;pt.h&quot;
+
+ /*
+ * The structure that holds the state of a buffer.
+ *
+ * This structure holds the state of a uIP buffer. The structure has
+ * no user-visible elements, but is used through the functions
+ * provided by the library.
+ *
+ */
+struct psock_buf {
+  u8_t *ptr;
+  unsigned short left;
+};
+
+/**
+ * The representation of a protosocket.
+ *
+ * The protosocket structrure is an opaque structure with no user-visible
+ * elements.
+ */
+struct psock {
+  struct pt pt, psockpt; /* Protothreads - one that's using the psock
+			    functions, and one that runs inside the
+			    psock functions. */
+  const u8_t *sendptr;   /* Pointer to the next data to be sent. */
+  u8_t *readptr;         /* Pointer to the next data to be read. */
+  
+  char *bufptr;          /* Pointer to the buffer used for buffering
+			    incoming data. */
+  
+  u16_t sendlen;         /* The number of bytes left to be sent. */
+  u16_t readlen;         /* The number of bytes left to be read. */
+
+  struct psock_buf buf;  /* The structure holding the state of the
+			    input buffer. */
+  unsigned int bufsize;  /* The size of the input buffer. */
+  
+  unsigned char state;   /* The state of the protosocket. */
+};
+
+void psock_init(struct psock *psock, char *buffer, unsigned int buffersize);
+/**
+ * Initialize a protosocket.
+ *
+ * This macro initializes a protosocket and must be called before the
+ * protosocket is used. The initialization also specifies the input buffer
+ * for the protosocket.
+ *
+ * \param psock (struct psock *) A pointer to the protosocket to be
+ * initialized
+ *
+ * \param buffer (char *) A pointer to the input buffer for the
+ * protosocket.
+ *
+ * \param buffersize (unsigned int) The size of the input buffer.
+ *
+ * \hideinitializer
+ */
+#define PSOCK_INIT(psock, buffer, buffersize) \
+  psock_init(psock, buffer, buffersize)
+
+/**
+ * Start the protosocket protothread in a function.
+ *
+ * This macro starts the protothread associated with the protosocket and
+ * must come before other protosocket calls in the function it is used.
+ *
+ * \param psock (struct psock *) A pointer to the protosocket to be
+ * started.
+ *
+ * \hideinitializer
+ */
+#define PSOCK_BEGIN(psock) PT_BEGIN(&amp;((psock)-&gt;pt))
+
+PT_THREAD(psock_send(struct psock *psock, const char *buf, unsigned int len));
+/**
+ * Send data.
+ *
+ * This macro sends data over a protosocket. The protosocket protothread blocks
+ * until all data has been sent and is known to have been received by
+ * the remote end of the TCP connection.
+ *
+ * \param psock (struct psock *) A pointer to the protosocket over which
+ * data is to be sent.
+ *
+ * \param data (char *) A pointer to the data that is to be sent.
+ *
+ * \param datalen (unsigned int) The length of the data that is to be
+ * sent.
+ *
+ * \hideinitializer
+ */
+#define PSOCK_SEND(psock, data, datalen)		\
+    PT_WAIT_THREAD(&amp;((psock)-&gt;pt), psock_send(psock, data, datalen))
+
+/**
+ * \brief      Send a null-terminated string.
+ * \param psock Pointer to the protosocket.
+ * \param str  The string to be sent.
+ *
+ *             This function sends a null-terminated string over the
+ *             protosocket.
+ *
+ * \hideinitializer
+ */
+#define PSOCK_SEND_STR(psock, str)      		\
+    PT_WAIT_THREAD(&amp;((psock)-&gt;pt), psock_send(psock, str, strlen(str)))
+
+PT_THREAD(psock_generator_send(struct psock *psock,
+				unsigned short (*f)(void *), void *arg));
+
+/**
+ * \brief      Generate data with a function and send it
+ * \param psock Pointer to the protosocket.
+ * \param generator Pointer to the generator function
+ * \param arg   Argument to the generator function
+ *
+ *             This function generates data and sends it over the
+ *             protosocket. This can be used to dynamically generate
+ *             data for a transmission, instead of generating the data
+ *             in a buffer beforehand. This function reduces the need for
+ *             buffer memory. The generator function is implemented by
+ *             the application, and a pointer to the function is given
+ *             as an argument with the call to PSOCK_GENERATOR_SEND().
+ *
+ *             The generator function should place the generated data
+ *             directly in the uip_appdata buffer, and return the
+ *             length of the generated data. The generator function is
+ *             called by the protosocket layer when the data first is
+ *             sent, and once for every retransmission that is needed.
+ *
+ * \hideinitializer
+ */
+#define PSOCK_GENERATOR_SEND(psock, generator, arg)     \
+    PT_WAIT_THREAD(&amp;((psock)-&gt;pt),					\
+		   psock_generator_send(psock, generator, arg))
+
+
+/**
+ * Close a protosocket.
+ *
+ * This macro closes a protosocket and can only be called from within the
+ * protothread in which the protosocket lives.
+ *
+ * \param psock (struct psock *) A pointer to the protosocket that is to
+ * be closed.
+ *
+ * \hideinitializer
+ */
+#define PSOCK_CLOSE(psock) uip_close()
+
+PT_THREAD(psock_readbuf(struct psock *psock));
+/**
+ * Read data until the buffer is full.
+ *
+ * This macro will block waiting for data and read the data into the
+ * input buffer specified with the call to PSOCK_INIT(). Data is read
+ * until the buffer is full..
+ *
+ * \param psock (struct psock *) A pointer to the protosocket from which
+ * data should be read.
+ *
+ * \hideinitializer
+ */
+#define PSOCK_READBUF(psock)				\
+  PT_WAIT_THREAD(&amp;((psock)-&gt;pt), psock_readbuf(psock))
+
+PT_THREAD(psock_readto(struct psock *psock, unsigned char c));
+/**
+ * Read data up to a specified character.
+ *
+ * This macro will block waiting for data and read the data into the
+ * input buffer specified with the call to PSOCK_INIT(). Data is only
+ * read until the specifieed character appears in the data stream.
+ *
+ * \param psock (struct psock *) A pointer to the protosocket from which
+ * data should be read.
+ *
+ * \param c (char) The character at which to stop reading.
+ *
+ * \hideinitializer
+ */
+#define PSOCK_READTO(psock, c)				\
+  PT_WAIT_THREAD(&amp;((psock)-&gt;pt), psock_readto(psock, c))
+
+/**
+ * The length of the data that was previously read.
+ *
+ * This macro returns the length of the data that was previously read
+ * using PSOCK_READTO() or PSOCK_READ().
+ *
+ * \param psock (struct psock *) A pointer to the protosocket holding the data.
+ *
+ * \hideinitializer
+ */
+#define PSOCK_DATALEN(psock) psock_datalen(psock)
+
+u16_t psock_datalen(struct psock *psock);
+
+/**
+ * Exit the protosocket's protothread.
+ *
+ * This macro terminates the protothread of the protosocket and should
+ * almost always be used in conjunction with PSOCK_CLOSE().
+ *
+ * \sa PSOCK_CLOSE_EXIT()
+ *
+ * \param psock (struct psock *) A pointer to the protosocket.
+ *
+ * \hideinitializer
+ */
+#define PSOCK_EXIT(psock) PT_EXIT(&amp;((psock)-&gt;pt))
+
+/**
+ * Close a protosocket and exit the protosocket's protothread.
+ *
+ * This macro closes a protosocket and exits the protosocket's protothread.
+ *
+ * \param psock (struct psock *) A pointer to the protosocket.
+ *
+ * \hideinitializer
+ */
+#define PSOCK_CLOSE_EXIT(psock)		\
+  do {						\
+    PSOCK_CLOSE(psock);			\
+    PSOCK_EXIT(psock);			\
+  } while(0)
+
+/**
+ * Declare the end of a protosocket's protothread.
+ *
+ * This macro is used for declaring that the protosocket's protothread
+ * ends. It must always be used together with a matching PSOCK_BEGIN()
+ * macro.
+ *
+ * \param psock (struct psock *) A pointer to the protosocket.
+ *
+ * \hideinitializer
+ */
+#define PSOCK_END(psock) PT_END(&amp;((psock)-&gt;pt))
+
+char psock_newdata(struct psock *s);
+
+/**
+ * Check if new data has arrived on a protosocket.
+ *
+ * This macro is used in conjunction with the PSOCK_WAIT_UNTIL()
+ * macro to check if data has arrived on a protosocket.
+ *
+ * \param psock (struct psock *) A pointer to the protosocket.
+ *
+ * \hideinitializer
+ */
+#define PSOCK_NEWDATA(psock) psock_newdata(psock)
+
+/**
+ * Wait until a condition is true.
+ *
+ * This macro blocks the protothread until the specified condition is
+ * true. The macro PSOCK_NEWDATA() can be used to check if new data
+ * arrives when the protosocket is waiting.
+ *
+ * Typically, this macro is used as follows:
+ *
+ \code
+ PT_THREAD(thread(struct psock *s, struct timer *t))
+ {
+   PSOCK_BEGIN(s);
+
+   PSOCK_WAIT_UNTIL(s, PSOCK_NEWADATA(s) || timer_expired(t));
+   
+   if(PSOCK_NEWDATA(s)) {
+     PSOCK_READTO(s, '\n');
+   } else {
+     handle_timed_out(s);
+   }
+   
+   PSOCK_END(s);
+ }
+ \endcode
+ *
+ * \param psock (struct psock *) A pointer to the protosocket.
+ * \param condition The condition to wait for.
+ *
+ * \hideinitializer
+ */
+#define PSOCK_WAIT_UNTIL(psock, condition)    \
+  PT_WAIT_UNTIL(&amp;((psock)-&gt;pt), (condition));
+
+#define PSOCK_WAIT_THREAD(psock, condition)   \
+  PT_WAIT_THREAD(&amp;((psock)-&gt;pt), (condition))
+
+#endif /* __PSOCK_H__ */
+
+/** @} */

Added: trunk/src/uip/pt.h
===================================================================
--- trunk/src/uip/pt.h	2008-09-10 18:59:17 UTC (rev 88)
+++ trunk/src/uip/pt.h	2008-09-15 21:54:14 UTC (rev 89)
@@ -0,0 +1,323 @@
+/*
+ * Copyright (c) 2004-2005, Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the Institute nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * This file is part of the uIP TCP/IP stack
+ *
+ * Author: Adam Dunkels &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">adam at sics.se</A>&gt;
+ *
+ * $Id: pt.h,v 1.2 2006/06/12 08:00:30 adam Exp $
+ */
+
+/**
+ * \addtogroup pt
+ * @{
+ */
+
+/**
+ * \file
+ * Protothreads implementation.
+ * \author
+ * Adam Dunkels &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">adam at sics.se</A>&gt;
+ *
+ */
+
+#ifndef __PT_H__
+#define __PT_H__
+
+#include &quot;lc.h&quot;
+
+struct pt {
+  lc_t lc;
+};
+
+#define PT_WAITING 0
+#define PT_EXITED  1
+#define PT_ENDED   2
+#define PT_YIELDED 3
+
+/**
+ * \name Initialization
+ * @{
+ */
+
+/**
+ * Initialize a protothread.
+ *
+ * Initializes a protothread. Initialization must be done prior to
+ * starting to execute the protothread.
+ *
+ * \param pt A pointer to the protothread control structure.
+ *
+ * \sa PT_SPAWN()
+ *
+ * \hideinitializer
+ */
+#define PT_INIT(pt)   LC_INIT((pt)-&gt;lc)
+
+/** @} */
+
+/**
+ * \name Declaration and definition
+ * @{
+ */
+
+/**
+ * Declaration of a protothread.
+ *
+ * This macro is used to declare a protothread. All protothreads must
+ * be declared with this macro.
+ *
+ * \param name_args The name and arguments of the C function
+ * implementing the protothread.
+ *
+ * \hideinitializer
+ */
+#define PT_THREAD(name_args) char name_args
+
+/**
+ * Declare the start of a protothread inside the C function
+ * implementing the protothread.
+ *
+ * This macro is used to declare the starting point of a
+ * protothread. It should be placed at the start of the function in
+ * which the protothread runs. All C statements above the PT_BEGIN()
+ * invokation will be executed each time the protothread is scheduled.
+ *
+ * \param pt A pointer to the protothread control structure.
+ *
+ * \hideinitializer
+ */
+#define PT_BEGIN(pt) { char PT_YIELD_FLAG = 1; LC_RESUME((pt)-&gt;lc)
+
+/**
+ * Declare the end of a protothread.
+ *
+ * This macro is used for declaring that a protothread ends. It must
+ * always be used together with a matching PT_BEGIN() macro.
+ *
+ * \param pt A pointer to the protothread control structure.
+ *
+ * \hideinitializer
+ */
+#define PT_END(pt) LC_END((pt)-&gt;lc); PT_YIELD_FLAG = 0; \
+                   PT_INIT(pt); return PT_ENDED; }
+
+/** @} */
+
+/**
+ * \name Blocked wait
+ * @{
+ */
+
+/**
+ * Block and wait until condition is true.
+ *
+ * This macro blocks the protothread until the specified condition is
+ * true.
+ *
+ * \param pt A pointer to the protothread control structure.
+ * \param condition The condition.
+ *
+ * \hideinitializer
+ */
+#define PT_WAIT_UNTIL(pt, condition)	        \
+  do {						\
+    LC_SET((pt)-&gt;lc);				\
+    if(!(condition)) {				\
+      return PT_WAITING;			\
+    }						\
+  } while(0)
+
+/**
+ * Block and wait while condition is true.
+ *
+ * This function blocks and waits while condition is true. See
+ * PT_WAIT_UNTIL().
+ *
+ * \param pt A pointer to the protothread control structure.
+ * \param cond The condition.
+ *
+ * \hideinitializer
+ */
+#define PT_WAIT_WHILE(pt, cond)  PT_WAIT_UNTIL((pt), !(cond))
+
+/** @} */
+
+/**
+ * \name Hierarchical protothreads
+ * @{
+ */
+
+/**
+ * Block and wait until a child protothread completes.
+ *
+ * This macro schedules a child protothread. The current protothread
+ * will block until the child protothread completes.
+ *
+ * \note The child protothread must be manually initialized with the
+ * PT_INIT() function before this function is used.
+ *
+ * \param pt A pointer to the protothread control structure.
+ * \param thread The child protothread with arguments
+ *
+ * \sa PT_SPAWN()
+ *
+ * \hideinitializer
+ */
+#define PT_WAIT_THREAD(pt, thread) PT_WAIT_WHILE((pt), PT_SCHEDULE(thread))
+
+/**
+ * Spawn a child protothread and wait until it exits.
+ *
+ * This macro spawns a child protothread and waits until it exits. The
+ * macro can only be used within a protothread.
+ *
+ * \param pt A pointer to the protothread control structure.
+ * \param child A pointer to the child protothread's control structure.
+ * \param thread The child protothread with arguments
+ *
+ * \hideinitializer
+ */
+#define PT_SPAWN(pt, child, thread)		\
+  do {						\
+    PT_INIT((child));				\
+    PT_WAIT_THREAD((pt), (thread));		\
+  } while(0)
+
+/** @} */
+
+/**
+ * \name Exiting and restarting
+ * @{
+ */
+
+/**
+ * Restart the protothread.
+ *
+ * This macro will block and cause the running protothread to restart
+ * its execution at the place of the PT_BEGIN() call.
+ *
+ * \param pt A pointer to the protothread control structure.
+ *
+ * \hideinitializer
+ */
+#define PT_RESTART(pt)				\
+  do {						\
+    PT_INIT(pt);				\
+    return PT_WAITING;			\
+  } while(0)
+
+/**
+ * Exit the protothread.
+ *
+ * This macro causes the protothread to exit. If the protothread was
+ * spawned by another protothread, the parent protothread will become
+ * unblocked and can continue to run.
+ *
+ * \param pt A pointer to the protothread control structure.
+ *
+ * \hideinitializer
+ */
+#define PT_EXIT(pt)				\
+  do {						\
+    PT_INIT(pt);				\
+    return PT_EXITED;			\
+  } while(0)
+
+/** @} */
+
+/**
+ * \name Calling a protothread
+ * @{
+ */
+
+/**
+ * Schedule a protothread.
+ *
+ * This function shedules a protothread. The return value of the
+ * function is non-zero if the protothread is running or zero if the
+ * protothread has exited.
+ *
+ * \param f The call to the C function implementing the protothread to
+ * be scheduled
+ *
+ * \hideinitializer
+ */
+#define PT_SCHEDULE(f) ((f) == PT_WAITING)
+
+/** @} */
+
+/**
+ * \name Yielding from a protothread
+ * @{
+ */
+
+/**
+ * Yield from the current protothread.
+ *
+ * This function will yield the protothread, thereby allowing other
+ * processing to take place in the system.
+ *
+ * \param pt A pointer to the protothread control structure.
+ *
+ * \hideinitializer
+ */
+#define PT_YIELD(pt)				\
+  do {						\
+    PT_YIELD_FLAG = 0;				\
+    LC_SET((pt)-&gt;lc);				\
+    if(PT_YIELD_FLAG == 0) {			\
+      return PT_YIELDED;			\
+    }						\
+  } while(0)
+
+/**
+ * \brief      Yield from the protothread until a condition occurs.
+ * \param pt   A pointer to the protothread control structure.
+ * \param cond The condition.
+ *
+ *             This function will yield the protothread, until the
+ *             specified condition evaluates to true.
+ *
+ *
+ * \hideinitializer
+ */
+#define PT_YIELD_UNTIL(pt, cond)		\
+  do {						\
+    PT_YIELD_FLAG = 0;				\
+    LC_SET((pt)-&gt;lc);				\
+    if((PT_YIELD_FLAG == 0) || !(cond)) {	\
+      return PT_YIELDED;			\
+    }						\
+  } while(0)
+
+/** @} */
+
+#endif /* __PT_H__ */
+
+/** @} */

Added: trunk/src/uip/timer.c
===================================================================
--- trunk/src/uip/timer.c	2008-09-10 18:59:17 UTC (rev 88)
+++ trunk/src/uip/timer.c	2008-09-15 21:54:14 UTC (rev 89)
@@ -0,0 +1,132 @@
+#include &quot;build.h&quot;
+#ifdef BUILD_UIP
+
+/**
+ * \addtogroup timer
+ * @{
+ */
+
+/**
+ * \file
+ * Timer library implementation.
+ * \author
+ * Adam Dunkels &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">adam at sics.se</A>&gt;
+ */
+
+/*
+ * Copyright (c) 2004, Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the Institute nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * This file is part of the uIP TCP/IP stack
+ *
+ * Author: Adam Dunkels &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">adam at sics.se</A>&gt;
+ *
+ * $Id: timer.c,v 1.2 2006/06/12 08:00:30 adam Exp $
+ */
+
+#include &quot;clock.h&quot;
+#include &quot;timer.h&quot;
+
+/*---------------------------------------------------------------------------*/
+/**
+ * Set a timer.
+ *
+ * This function is used to set a timer for a time sometime in the
+ * future. The function timer_expired() will evaluate to true after
+ * the timer has expired.
+ *
+ * \param t A pointer to the timer
+ * \param interval The interval before the timer expires.
+ *
+ */
+void
+timer_set(struct timer *t, clock_time_t interval)
+{
+  t-&gt;interval = interval;
+  t-&gt;start = clock_time();
+}
+/*---------------------------------------------------------------------------*/
+/**
+ * Reset the timer with the same interval.
+ *
+ * This function resets the timer with the same interval that was
+ * given to the timer_set() function. The start point of the interval
+ * is the exact time that the timer last expired. Therefore, this
+ * function will cause the timer to be stable over time, unlike the
+ * timer_rester() function.
+ *
+ * \param t A pointer to the timer.
+ *
+ * \sa timer_restart()
+ */
+void
+timer_reset(struct timer *t)
+{
+  t-&gt;start += t-&gt;interval;
+}
+/*---------------------------------------------------------------------------*/
+/**
+ * Restart the timer from the current point in time
+ *
+ * This function restarts a timer with the same interval that was
+ * given to the timer_set() function. The timer will start at the
+ * current time.
+ *
+ * \note A periodic timer will drift if this function is used to reset
+ * it. For preioric timers, use the timer_reset() function instead.
+ *
+ * \param t A pointer to the timer.
+ *
+ * \sa timer_reset()
+ */
+void
+timer_restart(struct timer *t)
+{
+  t-&gt;start = clock_time();
+}
+/*---------------------------------------------------------------------------*/
+/**
+ * Check if a timer has expired.
+ *
+ * This function tests if a timer has expired and returns true or
+ * false depending on its status.
+ *
+ * \param t A pointer to the timer
+ *
+ * \return Non-zero if the timer has expired, zero otherwise.
+ *
+ */
+int
+timer_expired(struct timer *t)
+{
+  return (clock_time_t)(clock_time() - t-&gt;start) &gt;= (clock_time_t)t-&gt;interval;
+}
+/*---------------------------------------------------------------------------*/
+
+/** @} */
+
+#endif // #ifdef BUILD_UIP
\ No newline at end of file

Added: trunk/src/uip/timer.h
===================================================================
--- trunk/src/uip/timer.h	2008-09-10 18:59:17 UTC (rev 88)
+++ trunk/src/uip/timer.h	2008-09-15 21:54:14 UTC (rev 89)
@@ -0,0 +1,86 @@
+/**
+ * \defgroup timer Timer library
+ *
+ * The timer library provides functions for setting, resetting and
+ * restarting timers, and for checking if a timer has expired. An
+ * application must &quot;manually&quot; check if its timers have expired; this
+ * is not done automatically.
+ *
+ * A timer is declared as a \c struct \c timer and all access to the
+ * timer is made by a pointer to the declared timer.
+ *
+ * \note The timer library uses the \ref clock &quot;Clock library&quot; to
+ * measure time. Intervals should be specified in the format used by
+ * the clock library.
+ *
+ * @{
+ */
+
+
+/**
+ * \file
+ * Timer library header file.
+ * \author
+ * Adam Dunkels &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">adam at sics.se</A>&gt;
+ */
+
+/*
+ * Copyright (c) 2004, Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the Institute nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * This file is part of the uIP TCP/IP stack
+ *
+ * Author: Adam Dunkels &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">adam at sics.se</A>&gt;
+ *
+ * $Id: timer.h,v 1.3 2006/06/11 21:46:39 adam Exp $
+ */
+#ifndef __TIMER_H__
+#define __TIMER_H__
+
+#include &quot;clock.h&quot;
+
+/**
+ * A timer.
+ *
+ * This structure is used for declaring a timer. The timer must be set
+ * with timer_set() before it can be used.
+ *
+ * \hideinitializer
+ */
+struct timer {
+  clock_time_t start;
+  clock_time_t interval;
+};
+
+void timer_set(struct timer *t, clock_time_t interval);
+void timer_reset(struct timer *t);
+void timer_restart(struct timer *t);
+int timer_expired(struct timer *t);
+
+#endif /* __TIMER_H__ */
+
+/** @} */

Added: trunk/src/uip/uip-fw.c
===================================================================
--- trunk/src/uip/uip-fw.c	2008-09-10 18:59:17 UTC (rev 88)
+++ trunk/src/uip/uip-fw.c	2008-09-15 21:54:14 UTC (rev 89)
@@ -0,0 +1,537 @@
+#include &quot;build.h&quot;
+#ifdef BUILD_UIP
+
+/*
+ * Copyright (c) 2004, Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the Institute nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * This file is part of the uIP TCP/IP stack
+ *
+ * Author: Adam Dunkels &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">adam at sics.se</A>&gt;
+ *
+ * $Id: uip-fw.c,v 1.2 2006/06/12 08:00:30 adam Exp $
+ */
+/**
+ * \addtogroup uip
+ * @{
+ */
+
+/**
+ * \defgroup uipfw uIP packet forwarding
+ * @{
+ *
+ */
+
+/**
+ * \file
+ * uIP packet forwarding.
+ * \author Adam Dunkels &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">adam at sics.se</A>&gt;
+ *
+ * This file implements a number of simple functions which do packet
+ * forwarding over multiple network interfaces with uIP.
+ *
+ */
+
+#include &quot;uip.h&quot;
+#include &quot;uip_arch.h&quot;
+#include &quot;uip-fw.h&quot;
+
+#include &lt;string.h&gt; /* for memcpy() */
+
+/*
+ * The list of registered network interfaces.
+ */
+static struct uip_fw_netif *netifs = NULL;
+
+/*
+ * A pointer to the default network interface.
+ */
+static struct uip_fw_netif *defaultnetif = NULL;
+
+struct tcpip_hdr {
+  /* IP header. */
+  u8_t vhl,
+    tos;
+  u16_t len,
+    ipid,
+    ipoffset;
+  u8_t ttl,
+    proto;
+  u16_t ipchksum;
+  u16_t srcipaddr[2],
+    destipaddr[2];
+  
+  /* TCP header. */
+  u16_t srcport,
+    destport;
+  u8_t seqno[4],
+    ackno[4],
+    tcpoffset,
+    flags,
+    wnd[2];
+  u16_t tcpchksum;
+  u8_t urgp[2];
+  u8_t optdata[4];
+};
+
+struct icmpip_hdr {
+  /* IP header. */
+  u8_t vhl,
+    tos,
+    len[2],
+    ipid[2],
+    ipoffset[2],
+    ttl,
+    proto;
+  u16_t ipchksum;
+  u16_t srcipaddr[2],
+    destipaddr[2];
+  /* ICMP (echo) header. */
+  u8_t type, icode;
+  u16_t icmpchksum;
+  u16_t id, seqno;
+  u8_t payload[1];
+};
+
+/* ICMP ECHO. */
+#define ICMP_ECHO 8
+
+/* ICMP TIME-EXCEEDED. */
+#define ICMP_TE 11
+
+/*
+ * Pointer to the TCP/IP headers of the packet in the uip_buf buffer.
+ */
+#define BUF ((struct tcpip_hdr *)&amp;uip_buf[UIP_LLH_LEN])
+
+/*
+ * Pointer to the ICMP/IP headers of the packet in the uip_buf buffer.
+ */
+#define ICMPBUF ((struct icmpip_hdr *)&amp;uip_buf[UIP_LLH_LEN])
+
+/*
+ * Certain fields of an IP packet that are used for identifying
+ * duplicate packets.
+ */
+struct fwcache_entry {
+  u16_t timer;
+  
+  u16_t srcipaddr[2];
+  u16_t destipaddr[2];
+  u16_t ipid;
+  u8_t proto;
+  u8_t unused;
+
+#if notdef
+  u16_t payload[2];
+#endif
+
+#if UIP_REASSEMBLY &gt; 0
+  u16_t len, offset;
+#endif
+};
+
+/*
+ * The number of packets to remember when looking for duplicates.
+ */
+#ifdef UIP_CONF_FWCACHE_SIZE
+#define FWCACHE_SIZE UIP_CONF_FWCACHE_SIZE
+#else
+#define FWCACHE_SIZE 2
+#endif
+
+
+/*
+ * A cache of packet header fields which are used for
+ * identifying duplicate packets.
+ */
+static struct fwcache_entry fwcache[FWCACHE_SIZE];
+
+/**
+ * \internal
+ * The time that a packet cache is active.
+ */
+#define FW_TIME 20
+
+/*------------------------------------------------------------------------------*/
+/**
+ * Initialize the uIP packet forwarding module.
+ */
+/*------------------------------------------------------------------------------*/
+void
+uip_fw_init(void)
+{
+  struct uip_fw_netif *t;
+  defaultnetif = NULL;
+  while(netifs != NULL) {
+    t = netifs;
+    netifs = netifs-&gt;next;
+    t-&gt;next = NULL;
+  }
+}
+/*------------------------------------------------------------------------------*/
+/**
+ * \internal
+ * Check if an IP address is within the network defined by an IP
+ * address and a netmask.
+ *
+ * \param ipaddr The IP address to be checked.
+ * \param netipaddr The IP address of the network.
+ * \param netmask The netmask of the network.
+ *
+ * \return Non-zero if IP address is in network, zero otherwise.
+ */
+/*------------------------------------------------------------------------------*/
+static unsigned char
+ipaddr_maskcmp(u16_t *ipaddr, u16_t *netipaddr, u16_t *netmask)
+{
+  return (ipaddr[0] &amp; netmask [0]) == (netipaddr[0] &amp; netmask[0]) &amp;&amp;
+    (ipaddr[1] &amp; netmask[1]) == (netipaddr[1] &amp; netmask[1]);
+}
+/*------------------------------------------------------------------------------*/
+/**
+ * \internal
+ * Send out an ICMP TIME-EXCEEDED message.
+ *
+ * This function replaces the packet in the uip_buf buffer with the
+ * ICMP packet.
+ */
+/*------------------------------------------------------------------------------*/
+static void
+time_exceeded(void)
+{
+  u16_t tmp16;
+
+  /* We don't send out ICMP errors for ICMP messages. */
+  if(ICMPBUF-&gt;proto == UIP_PROTO_ICMP) {
+    uip_len = 0;
+    return;
+  }
+  /* Copy fields from packet header into payload of this ICMP packet. */
+  memcpy(&amp;(ICMPBUF-&gt;payload[0]), ICMPBUF, 28);
+
+  /* Set the ICMP type and code. */
+  ICMPBUF-&gt;type = ICMP_TE;
+  ICMPBUF-&gt;icode = 0;
+
+  /* Calculate the ICMP checksum. */
+  ICMPBUF-&gt;icmpchksum = 0;
+  ICMPBUF-&gt;icmpchksum = ~uip_chksum((u16_t *)&amp;(ICMPBUF-&gt;type), 36);
+
+  /* Set the IP destination address to be the source address of the
+     original packet. */
+  tmp16= BUF-&gt;destipaddr[0];
+  BUF-&gt;destipaddr[0] = BUF-&gt;srcipaddr[0];
+  BUF-&gt;srcipaddr[0] = tmp16;
+  tmp16 = BUF-&gt;destipaddr[1];
+  BUF-&gt;destipaddr[1] = BUF-&gt;srcipaddr[1];
+  BUF-&gt;srcipaddr[1] = tmp16;
+
+  /* Set our IP address as the source address. */
+  BUF-&gt;srcipaddr[0] = uip_hostaddr[0];
+  BUF-&gt;srcipaddr[1] = uip_hostaddr[1];
+
+  /* The size of the ICMP time exceeded packet is 36 + the size of the
+     IP header (20) = 56. */
+  uip_len = 56;
+  ICMPBUF-&gt;len[0] = 0;
+  ICMPBUF-&gt;len[1] = uip_len;
+
+  /* Fill in the other fields in the IP header. */
+  ICMPBUF-&gt;vhl = 0x45;
+  ICMPBUF-&gt;tos = 0;
+  ICMPBUF-&gt;ipoffset[0] = ICMPBUF-&gt;ipoffset[1] = 0;
+  ICMPBUF-&gt;ttl  = UIP_TTL;
+  ICMPBUF-&gt;proto = UIP_PROTO_ICMP;
+  
+  /* Calculate IP checksum. */
+  ICMPBUF-&gt;ipchksum = 0;
+  ICMPBUF-&gt;ipchksum = ~(uip_ipchksum());
+
+
+}
+/*------------------------------------------------------------------------------*/
+/**
+ * \internal
+ * Register a packet in the forwarding cache so that it won't be
+ * forwarded again.
+ */
+/*------------------------------------------------------------------------------*/
+static void
+fwcache_register(void)
+{
+  struct fwcache_entry *fw;
+  int i, oldest;
+
+  oldest = FW_TIME;
+  fw = NULL;
+  
+  /* Find the oldest entry in the cache. */
+  for(i = 0; i &lt; FWCACHE_SIZE; ++i) {
+    if(fwcache[i].timer == 0) {
+      fw = &amp;fwcache[i];
+      break;
+    } else if(fwcache[i].timer &lt;= oldest) {
+      fw = &amp;fwcache[i];
+      oldest = fwcache[i].timer;
+    }
+  }
+
+  fw-&gt;timer = FW_TIME;
+  fw-&gt;ipid = BUF-&gt;ipid;
+  fw-&gt;srcipaddr[0] = BUF-&gt;srcipaddr[0];
+  fw-&gt;srcipaddr[1] = BUF-&gt;srcipaddr[1];
+  fw-&gt;destipaddr[0] = BUF-&gt;destipaddr[0];
+  fw-&gt;destipaddr[1] = BUF-&gt;destipaddr[1];
+  fw-&gt;proto = BUF-&gt;proto;
+#if notdef
+  fw-&gt;payload[0] = BUF-&gt;srcport;
+  fw-&gt;payload[1] = BUF-&gt;destport;
+#endif
+#if UIP_REASSEMBLY &gt; 0
+  fw-&gt;len = BUF-&gt;len;
+  fw-&gt;offset = BUF-&gt;ipoffset;
+#endif
+}
+/*------------------------------------------------------------------------------*/
+/**
+ * \internal
+ * Find a network interface for the IP packet in uip_buf.
+ */
+/*------------------------------------------------------------------------------*/
+static struct uip_fw_netif *
+find_netif(void)
+{
+  struct uip_fw_netif *netif;
+  
+  /* Walk through every network interface to check for a match. */
+  for(netif = netifs; netif != NULL; netif = netif-&gt;next) {
+    if(ipaddr_maskcmp(BUF-&gt;destipaddr, netif-&gt;ipaddr,
+		      netif-&gt;netmask)) {
+      /* If there was a match, we break the loop. */
+      return netif;
+    }
+  }
+  
+  /* If no matching netif was found, we use default netif. */
+  return defaultnetif;
+}
+/*------------------------------------------------------------------------------*/
+/**
+ * Output an IP packet on the correct network interface.
+ *
+ * The IP packet should be present in the uip_buf buffer and its
+ * length in the global uip_len variable.
+ *
+ * \retval UIP_FW_ZEROLEN Indicates that a zero-length packet
+ * transmission was attempted and that no packet was sent.
+ *
+ * \retval UIP_FW_NOROUTE No suitable network interface could be found
+ * for the outbound packet, and the packet was not sent.
+ *
+ * \return The return value from the actual network interface output
+ * function is passed unmodified as a return value.
+ */
+/*------------------------------------------------------------------------------*/
+u8_t
+uip_fw_output(void)
+{
+  struct uip_fw_netif *netif;
+
+  if(uip_len == 0) {
+    return UIP_FW_ZEROLEN;
+  }
+
+  fwcache_register();
+
+#if UIP_BROADCAST
+  /* Link local broadcasts go out on all interfaces. */
+  if(/*BUF-&gt;proto == UIP_PROTO_UDP &amp;&amp;*/
+     BUF-&gt;destipaddr[0] == 0xffff &amp;&amp;
+     BUF-&gt;destipaddr[1] == 0xffff) {
+    if(defaultnetif != NULL) {
+      defaultnetif-&gt;output();
+    }
+    for(netif = netifs; netif != NULL; netif = netif-&gt;next) {
+      netif-&gt;output();
+    }
+    return UIP_FW_OK;
+  }
+#endif /* UIP_BROADCAST */
+  
+  netif = find_netif();
+  /*  printf(&quot;uip_fw_output: netif %p -&gt;output %p len %d\n&quot;, netif,
+	 netif-&gt;output,
+	 uip_len);*/
+
+  if(netif == NULL) {
+    return UIP_FW_NOROUTE;
+  }
+  /* If we now have found a suitable network interface, we call its
+     output function to send out the packet. */
+  return netif-&gt;output();
+}
+/*------------------------------------------------------------------------------*/
+/**
+ * Forward an IP packet in the uip_buf buffer.
+ *
+ *
+ *
+ * \return UIP_FW_FORWARDED if the packet was forwarded, UIP_FW_LOCAL if
+ * the packet should be processed locally.
+ */
+/*------------------------------------------------------------------------------*/
+u8_t
+uip_fw_forward(void)
+{
+  struct fwcache_entry *fw;
+
+  /* First check if the packet is destined for ourselves and return 0
+     to indicate that the packet should be processed locally. */
+  if(BUF-&gt;destipaddr[0] == uip_hostaddr[0] &amp;&amp;
+     BUF-&gt;destipaddr[1] == uip_hostaddr[1]) {
+    return UIP_FW_LOCAL;
+  }
+
+  /* If we use ping IP address configuration, and our IP address is
+     not yet configured, we should intercept all ICMP echo packets. */
+#if UIP_PINGADDRCONF
+  if((uip_hostaddr[0] | uip_hostaddr[1]) == 0 &amp;&amp;
+     BUF-&gt;proto == UIP_PROTO_ICMP &amp;&amp;
+     ICMPBUF-&gt;type == ICMP_ECHO) {
+    return UIP_FW_LOCAL;
+  }
+#endif /* UIP_PINGADDRCONF */
+
+  /* Check if the packet is in the forwarding cache already, and if so
+     we drop it. */
+
+  for(fw = fwcache; fw &lt; &amp;fwcache[FWCACHE_SIZE]; ++fw) {
+    if(fw-&gt;timer != 0 &amp;&amp;
+#if UIP_REASSEMBLY &gt; 0
+       fw-&gt;len == BUF-&gt;len &amp;&amp;
+       fw-&gt;offset == BUF-&gt;ipoffset &amp;&amp;
+#endif
+       fw-&gt;ipid == BUF-&gt;ipid &amp;&amp;
+       fw-&gt;srcipaddr[0] == BUF-&gt;srcipaddr[0] &amp;&amp;
+       fw-&gt;srcipaddr[1] == BUF-&gt;srcipaddr[1] &amp;&amp;
+       fw-&gt;destipaddr[0] == BUF-&gt;destipaddr[0] &amp;&amp;
+       fw-&gt;destipaddr[1] == BUF-&gt;destipaddr[1] &amp;&amp;
+#if notdef
+       fw-&gt;payload[0] == BUF-&gt;srcport &amp;&amp;
+       fw-&gt;payload[1] == BUF-&gt;destport &amp;&amp;
+#endif
+       fw-&gt;proto == BUF-&gt;proto) {
+      /* Drop packet. */
+      return UIP_FW_FORWARDED;
+    }
+  }
+
+  /* If the TTL reaches zero we produce an ICMP time exceeded message
+     in the uip_buf buffer and forward that packet back to the sender
+     of the packet. */
+  if(BUF-&gt;ttl &lt;= 1) {
+    /* No time exceeded for broadcasts and multicasts! */
+    if(BUF-&gt;destipaddr[0] == 0xffff &amp;&amp; BUF-&gt;destipaddr[1] == 0xffff) {
+      return UIP_FW_LOCAL;
+    }
+    time_exceeded();
+  }
+  
+  /* Decrement the TTL (time-to-live) value in the IP header */
+  BUF-&gt;ttl = BUF-&gt;ttl - 1;
+  
+  /* Update the IP checksum. */
+  if(BUF-&gt;ipchksum &gt;= HTONS(0xffff - 0x0100)) {
+    BUF-&gt;ipchksum = BUF-&gt;ipchksum + HTONS(0x0100) + 1;
+  } else {
+    BUF-&gt;ipchksum = BUF-&gt;ipchksum + HTONS(0x0100);
+  }
+
+  if(uip_len &gt; 0) {
+    uip_appdata = &amp;uip_buf[UIP_LLH_LEN + UIP_TCPIP_HLEN];
+    uip_fw_output();
+  }
+
+#if UIP_BROADCAST
+  if(BUF-&gt;destipaddr[0] == 0xffff &amp;&amp; BUF-&gt;destipaddr[1] == 0xffff) {
+    return UIP_FW_LOCAL;
+  }
+#endif /* UIP_BROADCAST */
+
+  /* Return non-zero to indicate that the packet was forwarded and that no
+     other processing should be made. */
+  return UIP_FW_FORWARDED;
+}
+/*------------------------------------------------------------------------------*/
+/**
+ * Register a network interface with the forwarding module.
+ *
+ * \param netif A pointer to the network interface that is to be
+ * registered.
+ */
+/*------------------------------------------------------------------------------*/
+void
+uip_fw_register(struct uip_fw_netif *netif)
+{
+  netif-&gt;next = netifs;
+  netifs = netif;
+}
+/*------------------------------------------------------------------------------*/
+/**
+ * Register a default network interface.
+ *
+ * All packets that don't go out on any of the other interfaces will
+ * be routed to the default interface.
+ *
+ * \param netif A pointer to the network interface that is to be
+ * registered.
+ */
+/*------------------------------------------------------------------------------*/
+void
+uip_fw_default(struct uip_fw_netif *netif)
+{
+  defaultnetif = netif;
+}
+/*------------------------------------------------------------------------------*/
+/**
+ * Perform periodic processing.
+ */
+/*------------------------------------------------------------------------------*/
+void
+uip_fw_periodic(void)
+{
+  struct fwcache_entry *fw;
+  for(fw = fwcache; fw &lt; &amp;fwcache[FWCACHE_SIZE]; ++fw) {
+    if(fw-&gt;timer &gt; 0) {
+      --fw-&gt;timer;
+    }
+  }
+}
+/*------------------------------------------------------------------------------*/
+
+#endif // #ifdef BUILD_UIP

Added: trunk/src/uip/uip-fw.h
===================================================================
--- trunk/src/uip/uip-fw.h	2008-09-10 18:59:17 UTC (rev 88)
+++ trunk/src/uip/uip-fw.h	2008-09-15 21:54:14 UTC (rev 89)
@@ -0,0 +1,176 @@
+/**
+ * \addtogroup uipfw
+ * @{
+ */
+
+/**
+ * \file
+ * uIP packet forwarding header file.
+ * \author Adam Dunkels &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">adam at sics.se</A>&gt;
+ */
+
+/*
+ * Copyright (c) 2004, Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the Institute nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * This file is part of the uIP TCP/IP stack
+ *
+ * Author: Adam Dunkels &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">adam at sics.se</A>&gt;
+ *
+ * $Id: uip-fw.h,v 1.2 2006/06/12 08:00:30 adam Exp $
+ */
+#ifndef __UIP_FW_H__
+#define __UIP_FW_H__
+
+#include &quot;uip.h&quot;
+
+/**
+ * Representation of a uIP network interface.
+ */
+struct uip_fw_netif {
+  struct uip_fw_netif *next;  /**&lt; Pointer to the next interface when
+				 linked in a list. */
+  u16_t ipaddr[2];            /**&lt; The IP address of this interface. */
+  u16_t netmask[2];           /**&lt; The netmask of the interface. */
+  u8_t (* output)(void);
+                              /**&lt; A pointer to the function that
+				 sends a packet. */
+};
+
+/**
+ * Intantiating macro for a uIP network interface.
+ *
+ * Example:
+ \code
+ struct uip_fw_netif slipnetif =
+   {UIP_FW_NETIF(192,168,76,1, 255,255,255,0, slip_output)};
+ \endcode
+ * \param ip1,ip2,ip3,ip4 The IP address of the network interface.
+ *
+ * \param nm1,nm2,nm3,nm4 The netmask of the network interface.
+ *
+ * \param outputfunc A pointer to the output function of the network interface.
+ *
+ * \hideinitializer
+ */
+#define UIP_FW_NETIF(ip1,ip2,ip3,ip4, nm1,nm2,nm3,nm4, outputfunc) \
+        NULL, \
+	{HTONS((ip1 &lt;&lt; 8) | ip2), HTONS((ip3 &lt;&lt; 8) | ip4)}, \
+	{HTONS((nm1 &lt;&lt; 8) | nm2), HTONS((nm3 &lt;&lt; 8) | nm4)}, \
+        outputfunc
+
+/**
+ * Set the IP address of a network interface.
+ *
+ * \param netif A pointer to the uip_fw_netif structure for the network interface.
+ *
+ * \param addr A pointer to an IP address.
+ *
+ * \hideinitializer
+ */
+#define uip_fw_setipaddr(netif, addr) \
+        do { (netif)-&gt;ipaddr[0] = ((u16_t *)(addr))[0]; \
+             (netif)-&gt;ipaddr[1] = ((u16_t *)(addr))[1]; } while(0)
+/**
+ * Set the netmask of a network interface.
+ *
+ * \param netif A pointer to the uip_fw_netif structure for the network interface.
+ *
+ * \param addr A pointer to an IP address representing the netmask.
+ *
+ * \hideinitializer
+ */
+#define uip_fw_setnetmask(netif, addr) \
+        do { (netif)-&gt;netmask[0] = ((u16_t *)(addr))[0]; \
+             (netif)-&gt;netmask[1] = ((u16_t *)(addr))[1]; } while(0)
+
+void uip_fw_init(void);
+u8_t uip_fw_forward(void);
+u8_t uip_fw_output(void);
+void uip_fw_register(struct uip_fw_netif *netif);
+void uip_fw_default(struct uip_fw_netif *netif);
+void uip_fw_periodic(void);
+
+
+/**
+ * A non-error message that indicates that a packet should be
+ * processed locally.
+ *
+ * \hideinitializer
+ */
+#define UIP_FW_LOCAL     0
+
+/**
+ * A non-error message that indicates that something went OK.
+ *
+ * \hideinitializer
+ */
+#define UIP_FW_OK        0
+
+/**
+ * A non-error message that indicates that a packet was forwarded.
+ *
+ * \hideinitializer
+ */
+#define UIP_FW_FORWARDED 1
+
+/**
+ * A non-error message that indicates that a zero-length packet
+ * transmission was attempted, and that no packet was sent.
+ *
+ * \hideinitializer
+ */
+#define UIP_FW_ZEROLEN   2
+
+/**
+ * An error message that indicates that a packet that was too large
+ * for the outbound network interface was detected.
+ *
+ * \hideinitializer
+ */
+#define UIP_FW_TOOLARGE  3
+
+/**
+ * An error message that indicates that no suitable interface could be
+ * found for an outbound packet.
+ *
+ * \hideinitializer
+ */
+#define UIP_FW_NOROUTE   4
+
+/**
+ * An error message that indicates that a packet that should be
+ * forwarded or output was dropped.
+ *
+ * \hideinitializer
+ */
+#define UIP_FW_DROPPED   5
+
+
+#endif /* __UIP_FW_H__ */
+
+/** @} */

Added: trunk/src/uip/uip-neighbor.c
===================================================================
--- trunk/src/uip/uip-neighbor.c	2008-09-10 18:59:17 UTC (rev 88)
+++ trunk/src/uip/uip-neighbor.c	2008-09-15 21:54:14 UTC (rev 89)
@@ -0,0 +1,163 @@
+#include &quot;build.h&quot;
+#ifdef BUILD_UIP
+
+/*
+ * Copyright (c) 2006, Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the Institute nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * This file is part of the uIP TCP/IP stack
+ *
+ * $Id: uip-neighbor.c,v 1.2 2006/06/12 08:00:30 adam Exp $
+ */
+
+/**
+ * \file
+ *         Database of link-local neighbors, used by IPv6 code and
+ *         to be used by a future ARP code rewrite.
+ * \author
+ *         Adam Dunkels &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">adam at sics.se</A>&gt;
+ */
+
+#include &quot;uip-neighbor.h&quot;
+
+#include &lt;string.h&gt;
+
+#define MAX_TIME 128
+
+#ifdef UIP_NEIGHBOR_CONF_ENTRIES
+#define ENTRIES UIP_NEIGHBOR_CONF_ENTRIES
+#else /* UIP_NEIGHBOR_CONF_ENTRIES */
+#define ENTRIES 8
+#endif /* UIP_NEIGHBOR_CONF_ENTRIES */
+
+struct neighbor_entry {
+  uip_ipaddr_t ipaddr;
+  struct uip_neighbor_addr addr;
+  u8_t time;
+};
+static struct neighbor_entry entries[ENTRIES];
+
+/*---------------------------------------------------------------------------*/
+void
+uip_neighbor_init(void)
+{
+  int i;
+
+  for(i = 0; i &lt; ENTRIES; ++i) {
+    entries[i].time = MAX_TIME;
+  }
+}
+/*---------------------------------------------------------------------------*/
+void
+uip_neighbor_periodic(void)
+{
+  int i;
+
+  for(i = 0; i &lt; ENTRIES; ++i) {
+    if(entries[i].time &lt; MAX_TIME) {
+      entries[i].time++;
+    }
+  }
+}
+/*---------------------------------------------------------------------------*/
+void
+uip_neighbor_add(uip_ipaddr_t ipaddr, struct uip_neighbor_addr *addr)
+{
+  int i, oldest;
+  u8_t oldest_time;
+
+  /*printf(&quot;Adding neighbor with link address %02x:%02x:%02x:%02x:%02x:%02x\n&quot;,
+	 addr-&gt;addr.addr[0], addr-&gt;addr.addr[1], addr-&gt;addr.addr[2], addr-&gt;addr.addr[3],
+	 addr-&gt;addr.addr[4], addr-&gt;addr.addr[5]);*/
+  
+  /* Find the first unused entry or the oldest used entry. */
+  oldest_time = 0;
+  oldest = 0;
+  for(i = 0; i &lt; ENTRIES; ++i) {
+    if(entries[i].time == MAX_TIME) {
+      oldest = i;
+      break;
+    }
+    if(uip_ipaddr_cmp(entries[i].ipaddr, addr)) {
+      oldest = i;
+      break;
+    }
+    if(entries[i].time &gt; oldest_time) {
+      oldest = i;
+      oldest_time = entries[i].time;
+    }
+  }
+
+  /* Use the oldest or first free entry (either pointed to by the
+     &quot;oldest&quot; variable). */
+  entries[oldest].time = 0;
+  uip_ipaddr_copy(entries[oldest].ipaddr, ipaddr);
+  memcpy(&amp;entries[oldest].addr, addr, sizeof(struct uip_neighbor_addr));
+}
+/*---------------------------------------------------------------------------*/
+static struct neighbor_entry *
+find_entry(uip_ipaddr_t ipaddr)
+{
+  int i;
+  
+  for(i = 0; i &lt; ENTRIES; ++i) {
+    if(uip_ipaddr_cmp(entries[i].ipaddr, ipaddr)) {
+      return &amp;entries[i];
+    }
+  }
+  return NULL;
+}
+/*---------------------------------------------------------------------------*/
+void
+uip_neighbor_update(uip_ipaddr_t ipaddr)
+{
+  struct neighbor_entry *e;
+
+  e = find_entry(ipaddr);
+  if(e != NULL) {
+    e-&gt;time = 0;
+  }
+}
+/*---------------------------------------------------------------------------*/
+struct uip_neighbor_addr *
+uip_neighbor_lookup(uip_ipaddr_t ipaddr)
+{
+  struct neighbor_entry *e;
+
+  e = find_entry(ipaddr);
+  if(e != NULL) {
+    /*    printf(&quot;Lookup neighbor with link address %02x:%02x:%02x:%02x:%02x:%02x\n&quot;,
+	   e-&gt;addr.addr.addr[0], e-&gt;addr.addr.addr[1], e-&gt;addr.addr.addr[2], e-&gt;addr.addr.addr[3],
+	   e-&gt;addr.addr.addr[4], e-&gt;addr.addr.addr[5]);*/
+
+    return &amp;e-&gt;addr;
+  }
+  return NULL;
+}
+/*---------------------------------------------------------------------------*/
+
+#endif // #ifdef BUILD_UIP

Added: trunk/src/uip/uip-neighbor.h
===================================================================
--- trunk/src/uip/uip-neighbor.h	2008-09-10 18:59:17 UTC (rev 88)
+++ trunk/src/uip/uip-neighbor.h	2008-09-15 21:54:14 UTC (rev 89)
@@ -0,0 +1,61 @@
+/*
+ * Copyright (c) 2006, Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the Institute nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * This file is part of the uIP TCP/IP stack
+ *
+ * $Id: uip-neighbor.h,v 1.2 2006/06/12 08:00:30 adam Exp $
+ */
+
+/**
+ * \file
+ *         Header file for database of link-local neighbors, used by
+ *         IPv6 code and to be used by future ARP code.
+ * \author
+ *         Adam Dunkels &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">adam at sics.se</A>&gt;
+ */
+
+#ifndef __UIP_NEIGHBOR_H__
+#define __UIP_NEIGHBOR_H__
+
+#include &quot;uip.h&quot;
+
+struct uip_neighbor_addr {
+#if UIP_NEIGHBOR_CONF_ADDRTYPE
+  UIP_NEIGHBOR_CONF_ADDRTYPE addr;
+#else
+  struct uip_eth_addr addr;
+#endif
+};
+
+void uip_neighbor_init(void);
+void uip_neighbor_add(uip_ipaddr_t ipaddr, struct uip_neighbor_addr *addr);
+void uip_neighbor_update(uip_ipaddr_t ipaddr);
+struct uip_neighbor_addr *uip_neighbor_lookup(uip_ipaddr_t ipaddr);
+void uip_neighbor_periodic(void);
+
+#endif /* __UIP-NEIGHBOR_H__ */

Added: trunk/src/uip/uip-split.c
===================================================================
--- trunk/src/uip/uip-split.c	2008-09-10 18:59:17 UTC (rev 88)
+++ trunk/src/uip/uip-split.c	2008-09-15 21:54:14 UTC (rev 89)
@@ -0,0 +1,141 @@
+#include &quot;build.h&quot;
+#ifdef BUILD_UIP
+
+/*
+ * Copyright (c) 2004, Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the Institute nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * This file is part of the uIP TCP/IP stack
+ *
+ * Author: Adam Dunkels &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">adam at sics.se</A>&gt;
+ *
+ * $Id: uip-split.c,v 1.2 2006/06/12 08:00:30 adam Exp $
+ */
+
+#include &lt;string.h&gt;
+
+#include &quot;uip-split.h&quot;
+#include &quot;uip.h&quot;
+#include &quot;uip-fw.h&quot;
+#include &quot;uip_arch.h&quot;
+
+
+
+#define BUF ((struct uip_tcpip_hdr *)&amp;uip_buf[UIP_LLH_LEN])
+
+/*-----------------------------------------------------------------------------*/
+void
+uip_split_output(void)
+{
+  u16_t tcplen, len1, len2;
+
+  /* We only try to split maximum sized TCP segments. */
+  if(BUF-&gt;proto == UIP_PROTO_TCP &amp;&amp;
+     uip_len == UIP_BUFSIZE - UIP_LLH_LEN) {
+
+    tcplen = uip_len - UIP_TCPIP_HLEN;
+    /* Split the segment in two. If the original packet length was
+       odd, we make the second packet one byte larger. */
+    len1 = len2 = tcplen / 2;
+    if(len1 + len2 &lt; tcplen) {
+      ++len2;
+    }
+
+    /* Create the first packet. This is done by altering the length
+       field of the IP header and updating the checksums. */
+    uip_len = len1 + UIP_TCPIP_HLEN;
+#if UIP_CONF_IPV6
+    /* For IPv6, the IP length field does not include the IPv6 IP header
+       length. */
+    BUF-&gt;len[0] = ((uip_len - UIP_IPH_LEN) &gt;&gt; 8);
+    BUF-&gt;len[1] = ((uip_len - UIP_IPH_LEN) &amp; 0xff);
+#else /* UIP_CONF_IPV6 */
+    BUF-&gt;len[0] = uip_len &gt;&gt; 8;
+    BUF-&gt;len[1] = uip_len &amp; 0xff;
+#endif /* UIP_CONF_IPV6 */
+    
+    /* Recalculate the TCP checksum. */
+    BUF-&gt;tcpchksum = 0;
+    BUF-&gt;tcpchksum = ~(uip_tcpchksum());
+
+#if !UIP_CONF_IPV6
+    /* Recalculate the IP checksum. */
+    BUF-&gt;ipchksum = 0;
+    BUF-&gt;ipchksum = ~(uip_ipchksum());
+#endif /* UIP_CONF_IPV6 */
+    
+    /* Transmit the first packet. */
+    /*    uip_fw_output();*/
+    tcpip_output();
+
+    /* Now, create the second packet. To do this, it is not enough to
+       just alter the length field, but we must also update the TCP
+       sequence number and point the uip_appdata to a new place in
+       memory. This place is detemined by the length of the first
+       packet (len1). */
+    uip_len = len2 + UIP_TCPIP_HLEN;
+#if UIP_CONF_IPV6
+    /* For IPv6, the IP length field does not include the IPv6 IP header
+       length. */
+    BUF-&gt;len[0] = ((uip_len - UIP_IPH_LEN) &gt;&gt; 8);
+    BUF-&gt;len[1] = ((uip_len - UIP_IPH_LEN) &amp; 0xff);
+#else /* UIP_CONF_IPV6 */
+    BUF-&gt;len[0] = uip_len &gt;&gt; 8;
+    BUF-&gt;len[1] = uip_len &amp; 0xff;
+#endif /* UIP_CONF_IPV6 */
+    
+    /*    uip_appdata += len1;*/
+    memcpy(uip_appdata, (u8_t *)uip_appdata + len1, len2);
+
+    uip_add32(BUF-&gt;seqno, len1);
+    BUF-&gt;seqno[0] = uip_acc32[0];
+    BUF-&gt;seqno[1] = uip_acc32[1];
+    BUF-&gt;seqno[2] = uip_acc32[2];
+    BUF-&gt;seqno[3] = uip_acc32[3];
+    
+    /* Recalculate the TCP checksum. */
+    BUF-&gt;tcpchksum = 0;
+    BUF-&gt;tcpchksum = ~(uip_tcpchksum());
+
+#if !UIP_CONF_IPV6
+    /* Recalculate the IP checksum. */
+    BUF-&gt;ipchksum = 0;
+    BUF-&gt;ipchksum = ~(uip_ipchksum());
+#endif /* UIP_CONF_IPV6 */
+
+    /* Transmit the second packet. */
+    /*    uip_fw_output();*/
+    tcpip_output();
+  } else {
+    /*    uip_fw_output();*/
+    tcpip_output();
+  }
+     
+}
+/*-----------------------------------------------------------------------------*/
+
+#endif // #ifdef BUILD_UIP

Added: trunk/src/uip/uip-split.h
===================================================================
--- trunk/src/uip/uip-split.h	2008-09-10 18:59:17 UTC (rev 88)
+++ trunk/src/uip/uip-split.h	2008-09-15 21:54:14 UTC (rev 89)
@@ -0,0 +1,96 @@
+/*
+ * Copyright (c) 2004, Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the Institute nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * This file is part of the uIP TCP/IP stack
+ *
+ * Author: Adam Dunkels &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">adam at sics.se</A>&gt;
+ *
+ * $Id: uip-split.h,v 1.2 2006/06/12 08:00:30 adam Exp $
+ */
+/**
+ * \addtogroup uip
+ * @{
+ */
+
+/**
+ * \defgroup uipsplit uIP TCP throughput booster hack
+ * @{
+ *
+ * The basic uIP TCP implementation only allows each TCP connection to
+ * have a single TCP segment in flight at any given time. Because of
+ * the delayed ACK algorithm employed by most TCP receivers, uIP's
+ * limit on the amount of in-flight TCP segments seriously reduces the
+ * maximum achievable throughput for sending data from uIP.
+ *
+ * The uip-split module is a hack which tries to remedy this
+ * situation. By splitting maximum sized outgoing TCP segments into
+ * two, the delayed ACK algorithm is not invoked at TCP
+ * receivers. This improves the throughput when sending data from uIP
+ * by orders of magnitude.
+ *
+ * The uip-split module uses the uip-fw module (uIP IP packet
+ * forwarding) for sending packets. Therefore, the uip-fw module must
+ * be set up with the appropriate network interfaces for this module
+ * to work.
+ */
+
+
+/**
+ * \file
+ * Module for splitting outbound TCP segments in two to avoid the
+ * delayed ACK throughput degradation.
+ * \author
+ * Adam Dunkels &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">adam at sics.se</A>&gt;
+ *
+ */
+
+#ifndef __UIP_SPLIT_H__
+#define __UIP_SPLIT_H__
+
+/**
+ * Handle outgoing packets.
+ *
+ * This function inspects an outgoing packet in the uip_buf buffer and
+ * sends it out using the uip_fw_output() function. If the packet is a
+ * full-sized TCP segment it will be split into two segments and
+ * transmitted separately. This function should be called instead of
+ * the actual device driver output function, or the uip_fw_output()
+ * function.
+ *
+ * The headers of the outgoing packet is assumed to be in the uip_buf
+ * buffer and the payload is assumed to be wherever uip_appdata
+ * points. The length of the outgoing packet is assumed to be in the
+ * uip_len variable.
+ *
+ */
+void uip_split_output(void);
+
+#endif /* __UIP_SPLIT_H__ */
+
+/** @} */
+/** @} */

Added: trunk/src/uip/uip.c
===================================================================
--- trunk/src/uip/uip.c	2008-09-10 18:59:17 UTC (rev 88)
+++ trunk/src/uip/uip.c	2008-09-15 21:54:14 UTC (rev 89)
@@ -0,0 +1,1941 @@
+#include &quot;build.h&quot;
+#ifdef BUILD_UIP
+
+#define DEBUG_PRINTF( ... )
+
+/**
+ * \defgroup uip The uIP TCP/IP stack
+ * @{
+ *
+ * uIP is an implementation of the TCP/IP protocol stack intended for
+ * small 8-bit and 16-bit microcontrollers.
+ *
+ * uIP provides the necessary protocols for Internet communication,
+ * with a very small code footprint and RAM requirements - the uIP
+ * code size is on the order of a few kilobytes and RAM usage is on
+ * the order of a few hundred bytes.
+ */
+
+/**
+ * \file
+ * The uIP TCP/IP stack code.
+ * \author Adam Dunkels &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">adam at dunkels.com</A>&gt;
+ */
+
+/*
+ * Copyright (c) 2001-2003, Adam Dunkels.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote
+ *    products derived from this software without specific prior
+ *    written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * This file is part of the uIP TCP/IP stack.
+ *
+ * $Id: uip.c,v 1.65 2006/06/11 21:46:39 adam Exp $
+ *
+ */
+
+/*
+ * uIP is a small implementation of the IP, UDP and TCP protocols (as
+ * well as some basic ICMP stuff). The implementation couples the IP,
+ * UDP, TCP and the application layers very tightly. To keep the size
+ * of the compiled code down, this code frequently uses the goto
+ * statement. While it would be possible to break the uip_process()
+ * function into many smaller functions, this would increase the code
+ * size because of the overhead of parameter passing and the fact that
+ * the optimier would not be as efficient.
+ *
+ * The principle is that we have a small buffer, called the uip_buf,
+ * in which the device driver puts an incoming packet. The TCP/IP
+ * stack parses the headers in the packet, and calls the
+ * application. If the remote host has sent data to the application,
+ * this data is present in the uip_buf and the application read the
+ * data from there. It is up to the application to put this data into
+ * a byte stream if needed. The application will not be fed with data
+ * that is out of sequence.
+ *
+ * If the application whishes to send data to the peer, it should put
+ * its data into the uip_buf. The uip_appdata pointer points to the
+ * first available byte. The TCP/IP stack will calculate the
+ * checksums, and fill in the necessary header fields and finally send
+ * the packet back to the peer.
+*/
+
+#include &quot;uip.h&quot;
+#include &quot;uipopt.h&quot;
+#include &quot;uip_arch.h&quot;
+
+#if UIP_CONF_IPV6
+#include &quot;uip-neighbor.h&quot;
+#endif /* UIP_CONF_IPV6 */
+
+#include &lt;string.h&gt;
+
+/*---------------------------------------------------------------------------*/
+/* Variable definitions. */
+
+
+/* The IP address of this host. If it is defined to be fixed (by
+   setting UIP_FIXEDADDR to 1 in uipopt.h), the address is set
+   here. Otherwise, the address */
+#if UIP_FIXEDADDR &gt; 0
+const uip_ipaddr_t uip_hostaddr =
+  {HTONS((UIP_IPADDR0 &lt;&lt; 8) | UIP_IPADDR1),
+   HTONS((UIP_IPADDR2 &lt;&lt; 8) | UIP_IPADDR3)};
+const uip_ipaddr_t uip_draddr =
+  {HTONS((UIP_DRIPADDR0 &lt;&lt; 8) | UIP_DRIPADDR1),
+   HTONS((UIP_DRIPADDR2 &lt;&lt; 8) | UIP_DRIPADDR3)};
+const uip_ipaddr_t uip_netmask =
+  {HTONS((UIP_NETMASK0 &lt;&lt; 8) | UIP_NETMASK1),
+   HTONS((UIP_NETMASK2 &lt;&lt; 8) | UIP_NETMASK3)};
+#else
+uip_ipaddr_t uip_hostaddr, uip_draddr, uip_netmask;
+#endif /* UIP_FIXEDADDR */
+
+static const uip_ipaddr_t all_ones_addr =
+#if UIP_CONF_IPV6
+  {0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff};
+#else /* UIP_CONF_IPV6 */
+  {0xffff,0xffff};
+#endif /* UIP_CONF_IPV6 */
+static const uip_ipaddr_t all_zeroes_addr =
+#if UIP_CONF_IPV6
+  {0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000};
+#else /* UIP_CONF_IPV6 */
+  {0x0000,0x0000};
+#endif /* UIP_CONF_IPV6 */
+
+
+#if UIP_FIXEDETHADDR
+const struct uip_eth_addr uip_ethaddr = {{UIP_ETHADDR0,
+					  UIP_ETHADDR1,
+					  UIP_ETHADDR2,
+					  UIP_ETHADDR3,
+					  UIP_ETHADDR4,
+					  UIP_ETHADDR5}};
+#else
+struct uip_eth_addr uip_ethaddr = {{0,0,0,0,0,0}};
+#endif
+
+#ifndef UIP_CONF_EXTERNAL_BUFFER
+u8_t uip_buf[UIP_BUFSIZE + 2];   /* The packet buffer that contains
+				    incoming packets. */
+#endif /* UIP_CONF_EXTERNAL_BUFFER */
+
+void *uip_appdata;               /* The uip_appdata pointer points to
+				    application data. */
+void *uip_sappdata;              /* The uip_appdata pointer points to
+				    the application data which is to
+				    be sent. */
+#if UIP_URGDATA &gt; 0
+void *uip_urgdata;               /* The uip_urgdata pointer points to
+   				    urgent data (out-of-band data), if
+   				    present. */
+u16_t uip_urglen, uip_surglen;
+#endif /* UIP_URGDATA &gt; 0 */
+
+u16_t uip_len, uip_slen;
+                             /* The uip_len is either 8 or 16 bits,
+				depending on the maximum packet
+				size. */
+
+u8_t uip_flags;     /* The uip_flags variable is used for
+				communication between the TCP/IP stack
+				and the application program. */
+
+#if UIP_TCP
+struct uip_conn *uip_conn;   /* uip_conn always points to the current
+				connection. */
+
+struct uip_conn uip_conns[UIP_CONNS];
+                             /* The uip_conns array holds all TCP
+				connections. */
+u16_t uip_listenports[UIP_LISTENPORTS];
+                             /* The uip_listenports list all currently
+				listning ports. */
+#endif /* UIP_TCP */
+
+#if UIP_UDP
+struct uip_udp_conn *uip_udp_conn;
+struct uip_udp_conn uip_udp_conns[UIP_UDP_CONNS];
+#endif /* UIP_UDP */
+
+static u16_t ipid;           /* Ths ipid variable is an increasing
+				number that is used for the IP ID
+				field. */
+
+void uip_setipid(u16_t id) { ipid = id; }
+
+#if UIP_TCP
+static u8_t iss[4];          /* The iss variable is used for the TCP
+				initial sequence number. */
+#endif /* UIP_TCP */
+
+#if UIP_ACTIVE_OPEN
+static u16_t lastport;       /* Keeps track of the last port used for
+				a new connection. */
+#endif /* UIP_ACTIVE_OPEN */
+
+/* Temporary variables. */
+#if UIP_TCP
+u8_t uip_acc32[4];
+static u8_t c, opt;
+static u16_t tmp16;
+#endif /* UIP_TCP */
+
+/* Structures and definitions. */
+#define TCP_FIN 0x01
+#define TCP_SYN 0x02
+#define TCP_RST 0x04
+#define TCP_PSH 0x08
+#define TCP_ACK 0x10
+#define TCP_URG 0x20
+#define TCP_CTL 0x3f
+
+#define TCP_OPT_END     0   /* End of TCP options list */
+#define TCP_OPT_NOOP    1   /* &quot;No-operation&quot; TCP option */
+#define TCP_OPT_MSS     2   /* Maximum segment size TCP option */
+
+#define TCP_OPT_MSS_LEN 4   /* Length of TCP MSS option. */
+
+#define ICMP_ECHO_REPLY 0
+#define ICMP_ECHO       8
+
+#define ICMP6_ECHO_REPLY             129
+#define ICMP6_ECHO                   128
+#define ICMP6_NEIGHBOR_SOLICITATION  135
+#define ICMP6_NEIGHBOR_ADVERTISEMENT 136
+
+#define ICMP6_FLAG_S (1 &lt;&lt; 6)
+
+#define ICMP6_OPTION_SOURCE_LINK_ADDRESS 1
+#define ICMP6_OPTION_TARGET_LINK_ADDRESS 2
+
+
+/* Macros. */
+#define BUF ((struct uip_tcpip_hdr *)&amp;uip_buf[UIP_LLH_LEN])
+#define FBUF ((struct uip_tcpip_hdr *)&amp;uip_reassbuf[0])
+#define ICMPBUF ((struct uip_icmpip_hdr *)&amp;uip_buf[UIP_LLH_LEN])
+#define UDPBUF ((struct uip_udpip_hdr *)&amp;uip_buf[UIP_LLH_LEN])
+
+
+#if UIP_STATISTICS == 1
+struct uip_stats uip_stat;
+#define UIP_STAT(s) s
+#else
+#define UIP_STAT(s)
+#endif /* UIP_STATISTICS == 1 */
+
+#if UIP_LOGGING == 1
+#include &lt;stdio.h&gt;
+void uip_log(char *msg);
+#define UIP_LOG(m) uip_log(m)
+#else
+#define UIP_LOG(m)
+#endif /* UIP_LOGGING == 1 */
+
+#include &lt;stdio.h&gt;
+#undef DEBUG_PRINTF
+#undef UIP_LOG
+#define DEBUG_PRINTF( ... ) printf( __VA_ARGS__ )
+#define UIP_LOG( x ) printf( x )
+
+#if ! UIP_ARCH_ADD32 &amp;&amp; UIP_TCP
+void
+uip_add32(u8_t *op32, u16_t op16)
+{
+  uip_acc32[3] = op32[3] + (op16 &amp; 0xff);
+  uip_acc32[2] = op32[2] + (op16 &gt;&gt; 8);
+  uip_acc32[1] = op32[1];
+  uip_acc32[0] = op32[0];
+  
+  if(uip_acc32[2] &lt; (op16 &gt;&gt; 8)) {
+    ++uip_acc32[1];
+    if(uip_acc32[1] == 0) {
+      ++uip_acc32[0];
+    }
+  }
+  
+  
+  if(uip_acc32[3] &lt; (op16 &amp; 0xff)) {
+    ++uip_acc32[2];
+    if(uip_acc32[2] == 0) {
+      ++uip_acc32[1];
+      if(uip_acc32[1] == 0) {
+	++uip_acc32[0];
+      }
+    }
+  }
+}
+
+#endif /* ! UIP_ARCH_ADD32 &amp;&amp; UIP_TCP */
+
+#if ! UIP_ARCH_CHKSUM
+/*---------------------------------------------------------------------------*/
+static u16_t
+chksum(u16_t sum, const u8_t *data, u16_t len)
+{
+  u16_t t;
+  const u8_t *dataptr;
+  const u8_t *last_byte;
+
+  dataptr = data;
+  last_byte = data + len - 1;
+  
+  while(dataptr &lt; last_byte) {	/* At least two more bytes */
+    t = (dataptr[0] &lt;&lt; 8) + dataptr[1];
+    sum += t;
+    if(sum &lt; t) {
+      sum++;		/* carry */
+    }
+    dataptr += 2;
+  }
+  
+  if(dataptr == last_byte) {
+    t = (dataptr[0] &lt;&lt; 8) + 0;
+    sum += t;
+    if(sum &lt; t) {
+      sum++;		/* carry */
+    }
+  }
+
+  /* Return sum in host byte order. */
+  return sum;
+}
+/*---------------------------------------------------------------------------*/
+u16_t
+uip_chksum(u16_t *data, u16_t len)
+{
+  return htons(chksum(0, (u8_t *)data, len));
+}
+/*---------------------------------------------------------------------------*/
+#ifndef UIP_ARCH_IPCHKSUM
+u16_t
+uip_ipchksum(void)
+{
+  u16_t sum;
+
+  sum = chksum(0, &amp;uip_buf[UIP_LLH_LEN], UIP_IPH_LEN);
+  DEBUG_PRINTF(&quot;uip_ipchksum: sum 0x%04x\n&quot;, sum);
+  return (sum == 0) ? 0xffff : htons(sum);
+}
+#endif
+/*---------------------------------------------------------------------------*/
+#if UIP_CONF_IPV6 || UIP_TCP || UIP_UDP_CHECKSUMS
+static u16_t
+upper_layer_chksum(u8_t proto)
+{
+  u16_t upper_layer_len;
+  u16_t sum;
+  
+#if UIP_CONF_IPV6
+  upper_layer_len = (((u16_t)(BUF-&gt;len[0]) &lt;&lt; 8) + BUF-&gt;len[1]);
+#else /* UIP_CONF_IPV6 */
+  upper_layer_len = (((u16_t)(BUF-&gt;len[0]) &lt;&lt; 8) + BUF-&gt;len[1]) - UIP_IPH_LEN;
+#endif /* UIP_CONF_IPV6 */
+  
+  /* First sum pseudoheader. */
+  
+  /* IP protocol and length fields. This addition cannot carry. */
+  sum = upper_layer_len + proto;
+  /* Sum IP source and destination addresses. */
+  sum = chksum(sum, (u8_t *)&amp;BUF-&gt;srcipaddr[0], 2 * sizeof(uip_ipaddr_t));
+
+  /* Sum TCP header and data. */
+  sum = chksum(sum, &amp;uip_buf[UIP_IPH_LEN + UIP_LLH_LEN],
+	       upper_layer_len);
+    
+  return (sum == 0) ? 0xffff : htons(sum);
+}
+#endif /* UIP_CONF_IPV6 || UIP_TCP || UIP_UDP_CHECKSUMS */
+/*---------------------------------------------------------------------------*/
+#if UIP_CONF_IPV6
+u16_t
+uip_icmp6chksum(void)
+{
+  return upper_layer_chksum(UIP_PROTO_ICMP6);
+  
+}
+#endif /* UIP_CONF_IPV6 */
+/*---------------------------------------------------------------------------*/
+#if UIP_TCP
+u16_t
+uip_tcpchksum(void)
+{
+  return upper_layer_chksum(UIP_PROTO_TCP);
+}
+#endif /* UIP_TCP */
+/*---------------------------------------------------------------------------*/
+#if UIP_UDP_CHECKSUMS
+u16_t
+uip_udpchksum(void)
+{
+  return upper_layer_chksum(UIP_PROTO_UDP);
+}
+#endif /* UIP_UDP_CHECKSUMS */
+#endif /* UIP_ARCH_CHKSUM */
+/*---------------------------------------------------------------------------*/
+void
+uip_init(void)
+{
+#if UIP_TCP
+  for(c = 0; c &lt; UIP_LISTENPORTS; ++c) {
+    uip_listenports[c] = 0;
+  }
+  for(c = 0; c &lt; UIP_CONNS; ++c) {
+    uip_conns[c].tcpstateflags = UIP_CLOSED;
+  }
+#endif /* UIP_TCP */
+#if UIP_ACTIVE_OPEN
+  lastport = 1024;
+#endif /* UIP_ACTIVE_OPEN */
+
+#if UIP_UDP
+  for(c = 0; c &lt; UIP_UDP_CONNS; ++c) {
+    uip_udp_conns[c].lport = 0;
+  }
+#endif /* UIP_UDP */
+  
+
+  /* IPv4 initialization. */
+#if UIP_FIXEDADDR == 0
+  /*  uip_hostaddr[0] = uip_hostaddr[1] = 0;*/
+#endif /* UIP_FIXEDADDR */
+
+}
+/*---------------------------------------------------------------------------*/
+#if UIP_ACTIVE_OPEN &amp;&amp; UIP_TCP
+struct uip_conn *
+uip_connect(uip_ipaddr_t *ripaddr, u16_t rport)
+{
+  register struct uip_conn *conn, *cconn;
+  
+  /* Find an unused local port. */
+ again:
+  ++lastport;
+
+  if(lastport &gt;= 32000) {
+    lastport = 4096;
+  }
+
+  /* Check if this port is already in use, and if so try to find
+     another one. */
+  for(c = 0; c &lt; UIP_CONNS; ++c) {
+    conn = &amp;uip_conns[c];
+    if(conn-&gt;tcpstateflags != UIP_CLOSED &amp;&amp;
+       conn-&gt;lport == htons(lastport)) {
+      goto again;
+    }
+  }
+
+  conn = 0;
+  for(c = 0; c &lt; UIP_CONNS; ++c) {
+    cconn = &amp;uip_conns[c];
+    if(cconn-&gt;tcpstateflags == UIP_CLOSED) {
+      conn = cconn;
+      break;
+    }
+    if(cconn-&gt;tcpstateflags == UIP_TIME_WAIT) {
+      if(conn == 0 ||
+	 cconn-&gt;timer &gt; conn-&gt;timer) {
+	conn = cconn;
+      }
+    }
+  }
+
+  if(conn == 0) {
+    return 0;
+  }
+  
+  conn-&gt;tcpstateflags = UIP_SYN_SENT;
+
+  conn-&gt;snd_nxt[0] = iss[0];
+  conn-&gt;snd_nxt[1] = iss[1];
+  conn-&gt;snd_nxt[2] = iss[2];
+  conn-&gt;snd_nxt[3] = iss[3];
+
+  conn-&gt;initialmss = conn-&gt;mss = UIP_TCP_MSS;
+  
+  conn-&gt;len = 1;   /* TCP length of the SYN is one. */
+  conn-&gt;nrtx = 0;
+  conn-&gt;timer = 1; /* Send the SYN next time around. */
+  conn-&gt;rto = UIP_RTO;
+  conn-&gt;sa = 0;
+  conn-&gt;sv = 16;   /* Initial value of the RTT variance. */
+  conn-&gt;lport = htons(lastport);
+  conn-&gt;rport = rport;
+  uip_ipaddr_copy(&amp;conn-&gt;ripaddr, ripaddr);
+  
+  return conn;
+}
+#endif /* UIP_ACTIVE_OPEN &amp;&amp; UIP_TCP */
+/*---------------------------------------------------------------------------*/
+#if UIP_UDP
+struct uip_udp_conn *
+uip_udp_new(uip_ipaddr_t *ripaddr, u16_t rport)
+{
+  register struct uip_udp_conn *conn;
+  
+  /* Find an unused local port. */
+ again:
+  ++lastport;
+
+  if(lastport &gt;= 32000) {
+    lastport = 4096;
+  }
+  
+  for(c = 0; c &lt; UIP_UDP_CONNS; ++c) {
+    if(uip_udp_conns[c].lport == htons(lastport)) {
+      goto again;
+    }
+  }
+
+
+  conn = 0;
+  for(c = 0; c &lt; UIP_UDP_CONNS; ++c) {
+    if(uip_udp_conns[c].lport == 0) {
+      conn = &amp;uip_udp_conns[c];
+      break;
+    }
+  }
+
+  if(conn == 0) {
+    return 0;
+  }
+  
+  conn-&gt;lport = HTONS(lastport);
+  conn-&gt;rport = rport;
+  if(ripaddr == NULL) {
+    memset(conn-&gt;ripaddr, 0, sizeof(uip_ipaddr_t));
+  } else {
+    uip_ipaddr_copy(&amp;conn-&gt;ripaddr, ripaddr);
+  }
+  conn-&gt;ttl = UIP_TTL;
+  
+  return conn;
+}
+#endif /* UIP_UDP */
+/*---------------------------------------------------------------------------*/
+#if UIP_TCP
+void
+uip_unlisten(u16_t port)
+{
+  for(c = 0; c &lt; UIP_LISTENPORTS; ++c) {
+    if(uip_listenports[c] == port) {
+      uip_listenports[c] = 0;
+      return;
+    }
+  }
+}
+#endif /* UIP_TCP */
+/*---------------------------------------------------------------------------*/
+#if UIP_TCP
+void
+uip_listen(u16_t port)
+{
+  for(c = 0; c &lt; UIP_LISTENPORTS; ++c) {
+    if(uip_listenports[c] == 0) {
+      uip_listenports[c] = port;
+      return;
+    }
+  }
+}
+#endif /* UIP_TCP */
+/*---------------------------------------------------------------------------*/
+/* XXX: IP fragment reassembly: not well-tested. */
+
+#if UIP_REASSEMBLY &amp;&amp; !UIP_CONF_IPV6
+#define UIP_REASS_BUFSIZE (UIP_BUFSIZE - UIP_LLH_LEN)
+static u8_t uip_reassbuf[UIP_REASS_BUFSIZE];
+static u8_t uip_reassbitmap[UIP_REASS_BUFSIZE / (8 * 8)];
+static const u8_t bitmap_bits[8] = {0xff, 0x7f, 0x3f, 0x1f,
+				    0x0f, 0x07, 0x03, 0x01};
+static u16_t uip_reasslen;
+static u8_t uip_reassflags;
+#define UIP_REASS_FLAG_LASTFRAG 0x01
+static u8_t uip_reasstmr;
+
+#define IP_MF   0x20
+
+static u8_t
+uip_reass(void)
+{
+  u16_t offset, len;
+  u16_t i;
+
+  /* If ip_reasstmr is zero, no packet is present in the buffer, so we
+     write the IP header of the fragment into the reassembly
+     buffer. The timer is updated with the maximum age. */
+  if(uip_reasstmr == 0) {
+    memcpy(uip_reassbuf, &amp;BUF-&gt;vhl, UIP_IPH_LEN);
+    uip_reasstmr = UIP_REASS_MAXAGE;
+    uip_reassflags = 0;
+    /* Clear the bitmap. */
+    memset(uip_reassbitmap, 0, sizeof(uip_reassbitmap));
+  }
+
+  /* Check if the incoming fragment matches the one currently present
+     in the reasembly buffer. If so, we proceed with copying the
+     fragment into the buffer. */
+  if(BUF-&gt;srcipaddr[0] == FBUF-&gt;srcipaddr[0] &amp;&amp;
+     BUF-&gt;srcipaddr[1] == FBUF-&gt;srcipaddr[1] &amp;&amp;
+     BUF-&gt;destipaddr[0] == FBUF-&gt;destipaddr[0] &amp;&amp;
+     BUF-&gt;destipaddr[1] == FBUF-&gt;destipaddr[1] &amp;&amp;
+     BUF-&gt;ipid[0] == FBUF-&gt;ipid[0] &amp;&amp;
+     BUF-&gt;ipid[1] == FBUF-&gt;ipid[1]) {
+
+    len = (BUF-&gt;len[0] &lt;&lt; 8) + BUF-&gt;len[1] - (BUF-&gt;vhl &amp; 0x0f) * 4;
+    offset = (((BUF-&gt;ipoffset[0] &amp; 0x3f) &lt;&lt; 8) + BUF-&gt;ipoffset[1]) * 8;
+
+    /* If the offset or the offset + fragment length overflows the
+       reassembly buffer, we discard the entire packet. */
+    if(offset &gt; UIP_REASS_BUFSIZE ||
+       offset + len &gt; UIP_REASS_BUFSIZE) {
+      uip_reasstmr = 0;
+      goto nullreturn;
+    }
+
+    /* Copy the fragment into the reassembly buffer, at the right
+       offset. */
+    memcpy(&amp;uip_reassbuf[UIP_IPH_LEN + offset],
+	   (char *)BUF + (int)((BUF-&gt;vhl &amp; 0x0f) * 4),
+	   len);
+      
+    /* Update the bitmap. */
+    if(offset / (8 * 8) == (offset + len) / (8 * 8)) {
+      /* If the two endpoints are in the same byte, we only update
+	 that byte. */
+	     
+      uip_reassbitmap[offset / (8 * 8)] |=
+	     bitmap_bits[(offset / 8 ) &amp; 7] &amp;
+	     ~bitmap_bits[((offset + len) / 8 ) &amp; 7];
+    } else {
+      /* If the two endpoints are in different bytes, we update the
+	 bytes in the endpoints and fill the stuff inbetween with
+	 0xff. */
+      uip_reassbitmap[offset / (8 * 8)] |=
+	bitmap_bits[(offset / 8 ) &amp; 7];
+      for(i = 1 + offset / (8 * 8); i &lt; (offset + len) / (8 * 8); ++i) {
+	uip_reassbitmap[i] = 0xff;
+      }
+      uip_reassbitmap[(offset + len) / (8 * 8)] |=
+	~bitmap_bits[((offset + len) / 8 ) &amp; 7];
+    }
+    
+    /* If this fragment has the More Fragments flag set to zero, we
+       know that this is the last fragment, so we can calculate the
+       size of the entire packet. We also set the
+       IP_REASS_FLAG_LASTFRAG flag to indicate that we have received
+       the final fragment. */
+
+    if((BUF-&gt;ipoffset[0] &amp; IP_MF) == 0) {
+      uip_reassflags |= UIP_REASS_FLAG_LASTFRAG;
+      uip_reasslen = offset + len;
+    }
+    
+    /* Finally, we check if we have a full packet in the buffer. We do
+       this by checking if we have the last fragment and if all bits
+       in the bitmap are set. */
+    if(uip_reassflags &amp; UIP_REASS_FLAG_LASTFRAG) {
+      /* Check all bytes up to and including all but the last byte in
+	 the bitmap. */
+      for(i = 0; i &lt; uip_reasslen / (8 * 8) - 1; ++i) {
+	if(uip_reassbitmap[i] != 0xff) {
+	  goto nullreturn;
+	}
+      }
+      /* Check the last byte in the bitmap. It should contain just the
+	 right amount of bits. */
+      if(uip_reassbitmap[uip_reasslen / (8 * 8)] !=
+	 (u8_t)~bitmap_bits[uip_reasslen / 8 &amp; 7]) {
+	goto nullreturn;
+      }
+
+      /* If we have come this far, we have a full packet in the
+	 buffer, so we allocate a pbuf and copy the packet into it. We
+	 also reset the timer. */
+      uip_reasstmr = 0;
+      memcpy(BUF, FBUF, uip_reasslen);
+
+      /* Pretend to be a &quot;normal&quot; (i.e., not fragmented) IP packet
+	 from now on. */
+      BUF-&gt;ipoffset[0] = BUF-&gt;ipoffset[1] = 0;
+      BUF-&gt;len[0] = uip_reasslen &gt;&gt; 8;
+      BUF-&gt;len[1] = uip_reasslen &amp; 0xff;
+      BUF-&gt;ipchksum = 0;
+      BUF-&gt;ipchksum = ~(uip_ipchksum());
+
+      return uip_reasslen;
+    }
+  }
+
+ nullreturn:
+  return 0;
+}
+#endif /* UIP_REASSEMBLY */
+/*---------------------------------------------------------------------------*/
+#if UIP_TCP
+static void
+uip_add_rcv_nxt(u16_t n)
+{
+  uip_add32(uip_conn-&gt;rcv_nxt, n);
+  uip_conn-&gt;rcv_nxt[0] = uip_acc32[0];
+  uip_conn-&gt;rcv_nxt[1] = uip_acc32[1];
+  uip_conn-&gt;rcv_nxt[2] = uip_acc32[2];
+  uip_conn-&gt;rcv_nxt[3] = uip_acc32[3];
+}
+#endif /* UIP_TCP */
+/*---------------------------------------------------------------------------*/
+void
+uip_process(u8_t flag)
+{
+#if UIP_TCP
+  register struct uip_conn *uip_connr = uip_conn;
+#endif /* UIP_TCP */
+
+#if UIP_UDP
+  if(flag == UIP_UDP_SEND_CONN) {
+    goto udp_send;
+  }
+#endif /* UIP_UDP */
+  
+  uip_sappdata = uip_appdata = &amp;uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN];
+
+  /* Check if we were invoked because of a poll request for a
+     particular connection. */
+#if UIP_TCP
+  if(flag == UIP_POLL_REQUEST) {
+    if((uip_connr-&gt;tcpstateflags &amp; UIP_TS_MASK) == UIP_ESTABLISHED &amp;&amp;
+       !uip_outstanding(uip_connr)) {
+	uip_flags = UIP_POLL;
+	UIP_APPCALL();
+	goto appsend;
+    }
+    goto drop;
+    
+    /* Check if we were invoked because of the perodic timer fireing. */
+  } else if(flag == UIP_TIMER) {
+#if UIP_REASSEMBLY
+    if(uip_reasstmr != 0) {
+      --uip_reasstmr;
+    }
+#endif /* UIP_REASSEMBLY */
+    /* Increase the initial sequence number. */
+    if(++iss[3] == 0) {
+      if(++iss[2] == 0) {
+	if(++iss[1] == 0) {
+	  ++iss[0];
+	}
+      }
+    }
+
+    /* Reset the length variables. */
+    uip_len = 0;
+    uip_slen = 0;
+
+    /* Check if the connection is in a state in which we simply wait
+       for the connection to time out. If so, we increase the
+       connection's timer and remove the connection if it times
+       out. */
+    if(uip_connr-&gt;tcpstateflags == UIP_TIME_WAIT ||
+       uip_connr-&gt;tcpstateflags == UIP_FIN_WAIT_2) {
+      ++(uip_connr-&gt;timer);
+      if(uip_connr-&gt;timer == UIP_TIME_WAIT_TIMEOUT) {
+	uip_connr-&gt;tcpstateflags = UIP_CLOSED;
+      }
+    } else if(uip_connr-&gt;tcpstateflags != UIP_CLOSED) {
+      /* If the connection has outstanding data, we increase the
+	 connection's timer and see if it has reached the RTO value
+	 in which case we retransmit. */
+      if(uip_outstanding(uip_connr)) {
+	if(uip_connr-&gt;timer-- == 0) {
+	  if(uip_connr-&gt;nrtx == UIP_MAXRTX ||
+	     ((uip_connr-&gt;tcpstateflags == UIP_SYN_SENT ||
+	       uip_connr-&gt;tcpstateflags == UIP_SYN_RCVD) &amp;&amp;
+	      uip_connr-&gt;nrtx == UIP_MAXSYNRTX)) {
+	    uip_connr-&gt;tcpstateflags = UIP_CLOSED;
+
+	    /* We call UIP_APPCALL() with uip_flags set to
+	       UIP_TIMEDOUT to inform the application that the
+	       connection has timed out. */
+	    uip_flags = UIP_TIMEDOUT;
+	    UIP_APPCALL();
+
+	    /* We also send a reset packet to the remote host. */
+	    BUF-&gt;flags = TCP_RST | TCP_ACK;
+	    goto tcp_send_nodata;
+	  }
+
+	  /* Exponential backoff. */
+	  uip_connr-&gt;timer = UIP_RTO &lt;&lt; (uip_connr-&gt;nrtx &gt; 4?
+					 4:
+					 uip_connr-&gt;nrtx);
+	  ++(uip_connr-&gt;nrtx);
+	  
+	  /* Ok, so we need to retransmit. We do this differently
+	     depending on which state we are in. In ESTABLISHED, we
+	     call upon the application so that it may prepare the
+	     data for the retransmit. In SYN_RCVD, we resend the
+	     SYNACK that we sent earlier and in LAST_ACK we have to
+	     retransmit our FINACK. */
+	  UIP_STAT(++uip_stat.tcp.rexmit);
+	  switch(uip_connr-&gt;tcpstateflags &amp; UIP_TS_MASK) {
+	  case UIP_SYN_RCVD:
+	    /* In the SYN_RCVD state, we should retransmit our
+               SYNACK. */
+	    goto tcp_send_synack;
+	    
+#if UIP_ACTIVE_OPEN
+	  case UIP_SYN_SENT:
+	    /* In the SYN_SENT state, we retransmit out SYN. */
+	    BUF-&gt;flags = 0;
+	    goto tcp_send_syn;
+#endif /* UIP_ACTIVE_OPEN */
+	    
+	  case UIP_ESTABLISHED:
+	    /* In the ESTABLISHED state, we call upon the application
+               to do the actual retransmit after which we jump into
+               the code for sending out the packet (the apprexmit
+               label). */
+	    uip_flags = UIP_REXMIT;
+	    UIP_APPCALL();
+	    goto apprexmit;
+	    
+	  case UIP_FIN_WAIT_1:
+	  case UIP_CLOSING:
+	  case UIP_LAST_ACK:
+	    /* In all these states we should retransmit a FINACK. */
+	    goto tcp_send_finack;
+	    
+	  }
+	}
+      } else if((uip_connr-&gt;tcpstateflags &amp; UIP_TS_MASK) == UIP_ESTABLISHED) {
+	/* If there was no need for a retransmission, we poll the
+           application for new data. */
+	uip_flags = UIP_POLL;
+	UIP_APPCALL();
+	goto appsend;
+      }
+    }
+    goto drop;
+  }
+#endif /* UIP_TCP */
+#if UIP_UDP
+  if(flag == UIP_UDP_TIMER) {
+    if(uip_udp_conn-&gt;lport != 0) {
+#if UIP_TCP
+      uip_conn = NULL;
+#endif /* UIP_TCP */
+      uip_sappdata = uip_appdata = &amp;uip_buf[UIP_LLH_LEN + UIP_IPUDPH_LEN];
+      uip_len = uip_slen = 0;
+      uip_flags = UIP_POLL;
+      UIP_UDP_APPCALL();
+      goto udp_send;
+    } else {
+      goto drop;
+    }
+  }
+#endif
+
+  /* This is where the input processing starts. */
+  UIP_STAT(++uip_stat.ip.recv);
+
+  /* Start of IP input header processing code. */
+  
+#if UIP_CONF_IPV6
+  /* Check validity of the IP header. */
+  if((BUF-&gt;vtc &amp; 0xf0) != 0x60)  { /* IP version and header length. */
+    UIP_STAT(++uip_stat.ip.drop);
+    UIP_STAT(++uip_stat.ip.vhlerr);
+    UIP_LOG(&quot;ipv6: invalid version.&quot;);
+    goto drop;
+  }
+#else /* UIP_CONF_IPV6 */
+  /* Check validity of the IP header. */
+  if(BUF-&gt;vhl != 0x45)  { /* IP version and header length. */
+    UIP_STAT(++uip_stat.ip.drop);
+    UIP_STAT(++uip_stat.ip.vhlerr);
+    UIP_LOG(&quot;ip: invalid version or header length.&quot;);
+    goto drop;
+  }
+#endif /* UIP_CONF_IPV6 */
+  
+  /* Check the size of the packet. If the size reported to us in
+     uip_len is smaller the size reported in the IP header, we assume
+     that the packet has been corrupted in transit. If the size of
+     uip_len is larger than the size reported in the IP packet header,
+     the packet has been padded and we set uip_len to the correct
+     value.. */
+
+  if((BUF-&gt;len[0] &lt;&lt; 8) + BUF-&gt;len[1] &lt;= uip_len) {
+    uip_len = (BUF-&gt;len[0] &lt;&lt; 8) + BUF-&gt;len[1];
+#if UIP_CONF_IPV6
+    uip_len += 40; /* The length reported in the IPv6 header is the
+		      length of the payload that follows the
+		      header. However, uIP uses the uip_len variable
+		      for holding the size of the entire packet,
+		      including the IP header. For IPv4 this is not a
+		      problem as the length field in the IPv4 header
+		      contains the length of the entire packet. But
+		      for IPv6 we need to add the size of the IPv6
+		      header (40 bytes). */
+#endif /* UIP_CONF_IPV6 */
+  } else {
+    UIP_LOG(&quot;ip: packet shorter than reported in IP header.&quot;);
+    goto drop;
+  }
+
+#if !UIP_CONF_IPV6
+  /* Check the fragment flag. */
+  if((BUF-&gt;ipoffset[0] &amp; 0x3f) != 0 ||
+     BUF-&gt;ipoffset[1] != 0) {
+#if UIP_REASSEMBLY
+    uip_len = uip_reass();
+    if(uip_len == 0) {
+      goto drop;
+    }
+#else /* UIP_REASSEMBLY */
+    UIP_STAT(++uip_stat.ip.drop);
+    UIP_STAT(++uip_stat.ip.fragerr);
+    UIP_LOG(&quot;ip: fragment dropped.&quot;);
+    goto drop;
+#endif /* UIP_REASSEMBLY */
+  }
+#endif /* UIP_CONF_IPV6 */
+
+  if(uip_ipaddr_cmp(uip_hostaddr, all_zeroes_addr)) {
+    /* If we are configured to use ping IP address configuration and
+       hasn't been assigned an IP address yet, we accept all ICMP
+       packets. */
+#if UIP_PINGADDRCONF &amp;&amp; !UIP_CONF_IPV6
+    if(BUF-&gt;proto == UIP_PROTO_ICMP) {
+      UIP_LOG(&quot;ip: possible ping config packet received.&quot;);
+      goto icmp_input;
+    } else {
+      UIP_LOG(&quot;ip: packet dropped since no address assigned.&quot;);
+      goto drop;
+    }
+#endif /* UIP_PINGADDRCONF */
+
+  } else {
+    /* If IP broadcast support is configured, we check for a broadcast
+       UDP packet, which may be destined to us. */
+#if UIP_BROADCAST
+    DEBUG_PRINTF(&quot;UDP IP checksum 0x%04x\n&quot;, uip_ipchksum());
+    if(BUF-&gt;proto == UIP_PROTO_UDP &amp;&amp;
+       uip_ipaddr_cmp(BUF-&gt;destipaddr, all_ones_addr)
+       /*&amp;&amp;
+	 uip_ipchksum() == 0xffff*/) {
+      goto udp_input;
+    }
+#endif /* UIP_BROADCAST */
+    
+    /* Check if the packet is destined for our IP address. */
+#if !UIP_CONF_IPV6
+    if(!uip_ipaddr_cmp(BUF-&gt;destipaddr, uip_hostaddr)) {
+      UIP_STAT(++uip_stat.ip.drop);
+      goto drop;
+    }
+#else /* UIP_CONF_IPV6 */
+    /* For IPv6, packet reception is a little trickier as we need to
+       make sure that we listen to certain multicast addresses (all
+       hosts multicast address, and the solicited-node multicast
+       address) as well. However, we will cheat here and accept all
+       multicast packets that are sent to the ff02::/16 addresses. */
+    if(!uip_ipaddr_cmp(BUF-&gt;destipaddr, uip_hostaddr) &amp;&amp;
+       BUF-&gt;destipaddr[0] != HTONS(0xff02)) {
+      UIP_STAT(++uip_stat.ip.drop);
+      goto drop;
+    }
+#endif /* UIP_CONF_IPV6 */
+  }
+
+#if !UIP_CONF_IPV6
+  if(uip_ipchksum() != 0xffff) { /* Compute and check the IP header
+				    checksum. */
+    UIP_STAT(++uip_stat.ip.drop);
+    UIP_STAT(++uip_stat.ip.chkerr);
+    UIP_LOG(&quot;ip: bad checksum.&quot;);
+    goto drop;
+  }
+#endif /* UIP_CONF_IPV6 */
+
+#if UIP_TCP
+  if(BUF-&gt;proto == UIP_PROTO_TCP) { /* Check for TCP packet. If so,
+				       proceed with TCP input
+				       processing. */
+    goto tcp_input;
+  }
+#endif /* UIP_TCP */
+
+#if UIP_UDP
+  if(BUF-&gt;proto == UIP_PROTO_UDP) {
+    goto udp_input;
+  }
+#endif /* UIP_UDP */
+
+#if !UIP_CONF_IPV6
+  /* ICMPv4 processing code follows. */
+  if(BUF-&gt;proto != UIP_PROTO_ICMP) { /* We only allow ICMP packets from
+					here. */
+    UIP_STAT(++uip_stat.ip.drop);
+    UIP_STAT(++uip_stat.ip.protoerr);
+    UIP_LOG(&quot;ip: neither tcp nor icmp.&quot;);
+    goto drop;
+  }
+
+#if UIP_PINGADDRCONF
+ icmp_input:
+#endif /* UIP_PINGADDRCONF */
+  UIP_STAT(++uip_stat.icmp.recv);
+
+  /* ICMP echo (i.e., ping) processing. This is simple, we only change
+     the ICMP type from ECHO to ECHO_REPLY and adjust the ICMP
+     checksum before we return the packet. */
+  if(ICMPBUF-&gt;type != ICMP_ECHO) {
+    UIP_STAT(++uip_stat.icmp.drop);
+    UIP_STAT(++uip_stat.icmp.typeerr);
+    UIP_LOG(&quot;icmp: not icmp echo.&quot;);
+    goto drop;
+  }
+
+  /* If we are configured to use ping IP address assignment, we use
+     the destination IP address of this ping packet and assign it to
+     ourself. */
+#if UIP_PINGADDRCONF
+  if((uip_hostaddr[0] | uip_hostaddr[1]) == 0) {
+    uip_hostaddr[0] = BUF-&gt;destipaddr[0];
+    uip_hostaddr[1] = BUF-&gt;destipaddr[1];
+  }
+#endif /* UIP_PINGADDRCONF */
+
+  ICMPBUF-&gt;type = ICMP_ECHO_REPLY;
+
+  if(ICMPBUF-&gt;icmpchksum &gt;= HTONS(0xffff - (ICMP_ECHO &lt;&lt; 8))) {
+    ICMPBUF-&gt;icmpchksum += HTONS(ICMP_ECHO &lt;&lt; 8) + 1;
+  } else {
+    ICMPBUF-&gt;icmpchksum += HTONS(ICMP_ECHO &lt;&lt; 8);
+  }
+
+  /* Swap IP addresses. */
+  uip_ipaddr_copy(BUF-&gt;destipaddr, BUF-&gt;srcipaddr);
+  uip_ipaddr_copy(BUF-&gt;srcipaddr, uip_hostaddr);
+
+  UIP_STAT(++uip_stat.icmp.sent);
+  goto send;
+
+  /* End of IPv4 input header processing code. */
+#else /* !UIP_CONF_IPV6 */
+
+  /* This is IPv6 ICMPv6 processing code. */
+  DEBUG_PRINTF(&quot;icmp6_input: length %d\n&quot;, uip_len);
+
+  if(BUF-&gt;proto != UIP_PROTO_ICMP6) { /* We only allow ICMPv6 packets from
+					 here. */
+    UIP_STAT(++uip_stat.ip.drop);
+    UIP_STAT(++uip_stat.ip.protoerr);
+    UIP_LOG(&quot;ip: neither tcp nor icmp6.&quot;);
+    goto drop;
+  }
+
+  UIP_STAT(++uip_stat.icmp.recv);
+
+  /* If we get a neighbor solicitation for our address we should send
+     a neighbor advertisement message back. */
+  if(ICMPBUF-&gt;type == ICMP6_NEIGHBOR_SOLICITATION) {
+    if(uip_ipaddr_cmp(ICMPBUF-&gt;icmp6data, uip_hostaddr)) {
+
+      if(ICMPBUF-&gt;options[0] == ICMP6_OPTION_SOURCE_LINK_ADDRESS) {
+	/* Save the sender's address in our neighbor list. */
+	uip_neighbor_add(ICMPBUF-&gt;srcipaddr, &amp;(ICMPBUF-&gt;options[2]));
+      }
+      
+      /* We should now send a neighbor advertisement back to where the
+	 neighbor solicication came from. */
+      ICMPBUF-&gt;type = ICMP6_NEIGHBOR_ADVERTISEMENT;
+      ICMPBUF-&gt;flags = ICMP6_FLAG_S; /* Solicited flag. */
+      
+      ICMPBUF-&gt;reserved1 = ICMPBUF-&gt;reserved2 = ICMPBUF-&gt;reserved3 = 0;
+      
+      uip_ipaddr_copy(ICMPBUF-&gt;destipaddr, ICMPBUF-&gt;srcipaddr);
+      uip_ipaddr_copy(ICMPBUF-&gt;srcipaddr, uip_hostaddr);
+      ICMPBUF-&gt;options[0] = ICMP6_OPTION_TARGET_LINK_ADDRESS;
+      ICMPBUF-&gt;options[1] = 1;  /* Options length, 1 = 8 bytes. */
+      memcpy(&amp;(ICMPBUF-&gt;options[2]), &amp;uip_ethaddr, sizeof(uip_ethaddr));
+      ICMPBUF-&gt;icmpchksum = 0;
+      ICMPBUF-&gt;icmpchksum = ~uip_icmp6chksum();
+      goto send;
+      
+    }
+    goto drop;
+  } else if(ICMPBUF-&gt;type == ICMP6_ECHO) {
+    /* ICMP echo (i.e., ping) processing. This is simple, we only
+       change the ICMP type from ECHO to ECHO_REPLY and update the
+       ICMP checksum before we return the packet. */
+
+    ICMPBUF-&gt;type = ICMP6_ECHO_REPLY;
+    
+    uip_ipaddr_copy(BUF-&gt;destipaddr, BUF-&gt;srcipaddr);
+    uip_ipaddr_copy(BUF-&gt;srcipaddr, uip_hostaddr);
+    ICMPBUF-&gt;icmpchksum = 0;
+    ICMPBUF-&gt;icmpchksum = ~uip_icmp6chksum();
+    
+    UIP_STAT(++uip_stat.icmp.sent);
+    goto send;
+  } else {
+    DEBUG_PRINTF(&quot;Unknown icmp6 message type %d\n&quot;, ICMPBUF-&gt;type);
+    UIP_STAT(++uip_stat.icmp.drop);
+    UIP_STAT(++uip_stat.icmp.typeerr);
+    UIP_LOG(&quot;icmp: unknown ICMP message.&quot;);
+    goto drop;
+  }
+
+  /* End of IPv6 ICMP processing. */
+  
+#endif /* !UIP_CONF_IPV6 */
+
+#if UIP_UDP
+  /* UDP input processing. */
+ udp_input:
+  /* UDP processing is really just a hack. We don't do anything to the
+     UDP/IP headers, but let the UDP application do all the hard
+     work. If the application sets uip_slen, it has a packet to
+     send. */
+#if UIP_UDP_CHECKSUMS
+  uip_len = uip_len - UIP_IPUDPH_LEN;
+  uip_appdata = &amp;uip_buf[UIP_LLH_LEN + UIP_IPUDPH_LEN];
+  if(UDPBUF-&gt;udpchksum != 0 &amp;&amp; uip_udpchksum() != 0xffff) {
+    UIP_STAT(++uip_stat.udp.drop);
+    UIP_STAT(++uip_stat.udp.chkerr);
+    UIP_LOG(&quot;udp: bad checksum.&quot;);
+    goto drop;
+  }
+#else /* UIP_UDP_CHECKSUMS */
+  uip_len = uip_len - UIP_IPUDPH_LEN;
+#endif /* UIP_UDP_CHECKSUMS */
+
+  /* Demultiplex this UDP packet between the UDP &quot;connections&quot;. */
+  for(uip_udp_conn = &amp;uip_udp_conns[0];
+      uip_udp_conn &lt; &amp;uip_udp_conns[UIP_UDP_CONNS];
+      ++uip_udp_conn) {
+    /* If the local UDP port is non-zero, the connection is considered
+       to be used. If so, the local port number is checked against the
+       destination port number in the received packet. If the two port
+       numbers match, the remote port number is checked if the
+       connection is bound to a remote port. Finally, if the
+       connection is bound to a remote IP address, the source IP
+       address of the packet is checked. */
+    if(uip_udp_conn-&gt;lport != 0 &amp;&amp;
+       UDPBUF-&gt;destport == uip_udp_conn-&gt;lport &amp;&amp;
+       (uip_udp_conn-&gt;rport == 0 ||
+        UDPBUF-&gt;srcport == uip_udp_conn-&gt;rport ||
+        uip_udp_conn-&gt;rport == HTONS(69)) &amp;&amp;
+       (uip_ipaddr_cmp(uip_udp_conn-&gt;ripaddr, all_zeroes_addr) ||
+	uip_ipaddr_cmp(uip_udp_conn-&gt;ripaddr, all_ones_addr) ||
+	uip_ipaddr_cmp(BUF-&gt;srcipaddr, uip_udp_conn-&gt;ripaddr))) {
+      goto udp_found;
+    }
+  }
+  UIP_LOG(&quot;udp: no matching connection found&quot;);
+  goto drop;
+  
+ udp_found:
+#if UIP_TCP
+  uip_conn = NULL;
+#endif /* UIP_TCP */
+  uip_flags = UIP_NEWDATA;
+  uip_sappdata = uip_appdata = &amp;uip_buf[UIP_LLH_LEN + UIP_IPUDPH_LEN];
+  uip_slen = 0;
+  UIP_UDP_APPCALL();
+ udp_send:
+  if(uip_slen == 0) {
+    goto drop;
+  }
+  uip_len = uip_slen + UIP_IPUDPH_LEN;
+
+#if UIP_CONF_IPV6
+  /* For IPv6, the IP length field does not include the IPv6 IP header
+     length. */
+  BUF-&gt;len[0] = ((uip_len - UIP_IPH_LEN) &gt;&gt; 8);
+  BUF-&gt;len[1] = ((uip_len - UIP_IPH_LEN) &amp; 0xff);
+#else /* UIP_CONF_IPV6 */
+  BUF-&gt;len[0] = (uip_len &gt;&gt; 8);
+  BUF-&gt;len[1] = (uip_len &amp; 0xff);
+#endif /* UIP_CONF_IPV6 */
+
+  BUF-&gt;ttl = uip_udp_conn-&gt;ttl;
+  BUF-&gt;proto = UIP_PROTO_UDP;
+
+  UDPBUF-&gt;udplen = HTONS(uip_slen + UIP_UDPH_LEN);
+  UDPBUF-&gt;udpchksum = 0;
+
+  BUF-&gt;srcport  = uip_udp_conn-&gt;lport;
+  BUF-&gt;destport = uip_udp_conn-&gt;rport;
+
+  uip_ipaddr_copy(BUF-&gt;srcipaddr, uip_hostaddr);
+  uip_ipaddr_copy(BUF-&gt;destipaddr, uip_udp_conn-&gt;ripaddr);
+   
+  uip_appdata = &amp;uip_buf[UIP_LLH_LEN + UIP_IPTCPH_LEN];
+
+#if UIP_UDP_CHECKSUMS
+  /* Calculate UDP checksum. */
+  UDPBUF-&gt;udpchksum = ~(uip_udpchksum());
+  if(UDPBUF-&gt;udpchksum == 0) {
+    UDPBUF-&gt;udpchksum = 0xffff;
+  }
+#endif /* UIP_UDP_CHECKSUMS */
+  
+  goto ip_send_nolen;
+#endif /* UIP_UDP */
+  
+  /* TCP input processing. */
+#if UIP_TCP
+ tcp_input:
+  UIP_STAT(++uip_stat.tcp.recv);
+
+  /* Start of TCP input header processing code. */
+  
+  if(uip_tcpchksum() != 0xffff) {   /* Compute and check the TCP
+				       checksum. */
+    UIP_STAT(++uip_stat.tcp.drop);
+    UIP_STAT(++uip_stat.tcp.chkerr);
+    UIP_LOG(&quot;tcp: bad checksum.&quot;);
+    goto drop;
+  }
+  
+  
+  /* Demultiplex this segment. */
+  /* First check any active connections. */
+  for(uip_connr = &amp;uip_conns[0]; uip_connr &lt;= &amp;uip_conns[UIP_CONNS - 1];
+      ++uip_connr) {
+    if(uip_connr-&gt;tcpstateflags != UIP_CLOSED &amp;&amp;
+       BUF-&gt;destport == uip_connr-&gt;lport &amp;&amp;
+       BUF-&gt;srcport == uip_connr-&gt;rport &amp;&amp;
+       uip_ipaddr_cmp(BUF-&gt;srcipaddr, uip_connr-&gt;ripaddr)) {
+      goto found;
+    }
+  }
+
+  /* If we didn't find and active connection that expected the packet,
+     either this packet is an old duplicate, or this is a SYN packet
+     destined for a connection in LISTEN. If the SYN flag isn't set,
+     it is an old packet and we send a RST. */
+  if((BUF-&gt;flags &amp; TCP_CTL) != TCP_SYN) {
+    goto reset;
+  }
+  
+  tmp16 = BUF-&gt;destport;
+  /* Next, check listening connections. */
+  for(c = 0; c &lt; UIP_LISTENPORTS; ++c) {
+    if(tmp16 == uip_listenports[c])
+      goto found_listen;
+  }
+  
+  /* No matching connection found, so we send a RST packet. */
+  UIP_STAT(++uip_stat.tcp.synrst);
+ reset:
+
+  /* We do not send resets in response to resets. */
+  if(BUF-&gt;flags &amp; TCP_RST) {
+    goto drop;
+  }
+
+  UIP_STAT(++uip_stat.tcp.rst);
+  
+  BUF-&gt;flags = TCP_RST | TCP_ACK;
+  uip_len = UIP_IPTCPH_LEN;
+  BUF-&gt;tcpoffset = 5 &lt;&lt; 4;
+
+  /* Flip the seqno and ackno fields in the TCP header. */
+  c = BUF-&gt;seqno[3];
+  BUF-&gt;seqno[3] = BUF-&gt;ackno[3];
+  BUF-&gt;ackno[3] = c;
+  
+  c = BUF-&gt;seqno[2];
+  BUF-&gt;seqno[2] = BUF-&gt;ackno[2];
+  BUF-&gt;ackno[2] = c;
+  
+  c = BUF-&gt;seqno[1];
+  BUF-&gt;seqno[1] = BUF-&gt;ackno[1];
+  BUF-&gt;ackno[1] = c;
+  
+  c = BUF-&gt;seqno[0];
+  BUF-&gt;seqno[0] = BUF-&gt;ackno[0];
+  BUF-&gt;ackno[0] = c;
+
+  /* We also have to increase the sequence number we are
+     acknowledging. If the least significant byte overflowed, we need
+     to propagate the carry to the other bytes as well. */
+  if(++BUF-&gt;ackno[3] == 0) {
+    if(++BUF-&gt;ackno[2] == 0) {
+      if(++BUF-&gt;ackno[1] == 0) {
+	++BUF-&gt;ackno[0];
+      }
+    }
+  }
+ 
+  /* Swap port numbers. */
+  tmp16 = BUF-&gt;srcport;
+  BUF-&gt;srcport = BUF-&gt;destport;
+  BUF-&gt;destport = tmp16;
+  
+  /* Swap IP addresses. */
+  uip_ipaddr_copy(BUF-&gt;destipaddr, BUF-&gt;srcipaddr);
+  uip_ipaddr_copy(BUF-&gt;srcipaddr, uip_hostaddr);
+  
+  /* And send out the RST packet! */
+  goto tcp_send_noconn;
+
+  /* This label will be jumped to if we matched the incoming packet
+     with a connection in LISTEN. In that case, we should create a new
+     connection and send a SYNACK in return. */
+ found_listen:
+  /* First we check if there are any connections avaliable. Unused
+     connections are kept in the same table as used connections, but
+     unused ones have the tcpstate set to CLOSED. Also, connections in
+     TIME_WAIT are kept track of and we'll use the oldest one if no
+     CLOSED connections are found. Thanks to Eddie C. Dost for a very
+     nice algorithm for the TIME_WAIT search. */
+  uip_connr = 0;
+  for(c = 0; c &lt; UIP_CONNS; ++c) {
+    if(uip_conns[c].tcpstateflags == UIP_CLOSED) {
+      uip_connr = &amp;uip_conns[c];
+      break;
+    }
+    if(uip_conns[c].tcpstateflags == UIP_TIME_WAIT) {
+      if(uip_connr == 0 ||
+	 uip_conns[c].timer &gt; uip_connr-&gt;timer) {
+	uip_connr = &amp;uip_conns[c];
+      }
+    }
+  }
+
+  if(uip_connr == 0) {
+    /* All connections are used already, we drop packet and hope that
+       the remote end will retransmit the packet at a time when we
+       have more spare connections. */
+    UIP_STAT(++uip_stat.tcp.syndrop);
+    UIP_LOG(&quot;tcp: found no unused connections.&quot;);
+    goto drop;
+  }
+  uip_conn = uip_connr;
+  
+  /* Fill in the necessary fields for the new connection. */
+  uip_connr-&gt;rto = uip_connr-&gt;timer = UIP_RTO;
+  uip_connr-&gt;sa = 0;
+  uip_connr-&gt;sv = 4;
+  uip_connr-&gt;nrtx = 0;
+  uip_connr-&gt;lport = BUF-&gt;destport;
+  uip_connr-&gt;rport = BUF-&gt;srcport;
+  uip_ipaddr_copy(uip_connr-&gt;ripaddr, BUF-&gt;srcipaddr);
+  uip_connr-&gt;tcpstateflags = UIP_SYN_RCVD;
+
+  uip_connr-&gt;snd_nxt[0] = iss[0];
+  uip_connr-&gt;snd_nxt[1] = iss[1];
+  uip_connr-&gt;snd_nxt[2] = iss[2];
+  uip_connr-&gt;snd_nxt[3] = iss[3];
+  uip_connr-&gt;len = 1;
+
+  /* rcv_nxt should be the seqno from the incoming packet + 1. */
+  uip_connr-&gt;rcv_nxt[3] = BUF-&gt;seqno[3];
+  uip_connr-&gt;rcv_nxt[2] = BUF-&gt;seqno[2];
+  uip_connr-&gt;rcv_nxt[1] = BUF-&gt;seqno[1];
+  uip_connr-&gt;rcv_nxt[0] = BUF-&gt;seqno[0];
+  uip_add_rcv_nxt(1);
+
+  /* Parse the TCP MSS option, if present. */
+  if((BUF-&gt;tcpoffset &amp; 0xf0) &gt; 0x50) {
+    for(c = 0; c &lt; ((BUF-&gt;tcpoffset &gt;&gt; 4) - 5) &lt;&lt; 2 ;) {
+      opt = uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + c];
+      if(opt == TCP_OPT_END) {
+	/* End of options. */
+	break;
+      } else if(opt == TCP_OPT_NOOP) {
+	++c;
+	/* NOP option. */
+      } else if(opt == TCP_OPT_MSS &amp;&amp;
+		uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
+	/* An MSS option with the right option length. */
+	tmp16 = ((u16_t)uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] &lt;&lt; 8) |
+	  (u16_t)uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + 3 + c];
+	uip_connr-&gt;initialmss = uip_connr-&gt;mss =
+	  tmp16 &gt; UIP_TCP_MSS? UIP_TCP_MSS: tmp16;
+	
+	/* And we are done processing options. */
+	break;
+      } else {
+	/* All other options have a length field, so that we easily
+	   can skip past them. */
+	if(uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0) {
+	  /* If the length field is zero, the options are malformed
+	     and we don't process them further. */
+	  break;
+	}
+	c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
+      }
+    }
+  }
+  
+  /* Our response will be a SYNACK. */
+#if UIP_ACTIVE_OPEN
+ tcp_send_synack:
+  BUF-&gt;flags = TCP_ACK;
+  
+ tcp_send_syn:
+  BUF-&gt;flags |= TCP_SYN;
+#else /* UIP_ACTIVE_OPEN */
+ tcp_send_synack:
+  BUF-&gt;flags = TCP_SYN | TCP_ACK;
+#endif /* UIP_ACTIVE_OPEN */
+  
+  /* We send out the TCP Maximum Segment Size option with our
+     SYNACK. */
+  BUF-&gt;optdata[0] = TCP_OPT_MSS;
+  BUF-&gt;optdata[1] = TCP_OPT_MSS_LEN;
+  BUF-&gt;optdata[2] = (UIP_TCP_MSS) / 256;
+  BUF-&gt;optdata[3] = (UIP_TCP_MSS) &amp; 255;
+  uip_len = UIP_IPTCPH_LEN + TCP_OPT_MSS_LEN;
+  BUF-&gt;tcpoffset = ((UIP_TCPH_LEN + TCP_OPT_MSS_LEN) / 4) &lt;&lt; 4;
+  goto tcp_send;
+
+  /* This label will be jumped to if we found an active connection. */
+ found:
+  uip_conn = uip_connr;
+  uip_flags = 0;
+  /* We do a very naive form of TCP reset processing; we just accept
+     any RST and kill our connection. We should in fact check if the
+     sequence number of this reset is wihtin our advertised window
+     before we accept the reset. */
+  if(BUF-&gt;flags &amp; TCP_RST) {
+    uip_connr-&gt;tcpstateflags = UIP_CLOSED;
+    UIP_LOG(&quot;tcp: got reset, aborting connection.&quot;);
+    uip_flags = UIP_ABORT;
+    UIP_APPCALL();
+    goto drop;
+  }
+  /* Calculated the length of the data, if the application has sent
+     any data to us. */
+  c = (BUF-&gt;tcpoffset &gt;&gt; 4) &lt;&lt; 2;
+  /* uip_len will contain the length of the actual TCP data. This is
+     calculated by subtracing the length of the TCP header (in
+     c) and the length of the IP header (20 bytes). */
+  uip_len = uip_len - c - UIP_IPH_LEN;
+
+  /* First, check if the sequence number of the incoming packet is
+     what we're expecting next. If not, we send out an ACK with the
+     correct numbers in. */
+  if(!(((uip_connr-&gt;tcpstateflags &amp; UIP_TS_MASK) == UIP_SYN_SENT) &amp;&amp;
+       ((BUF-&gt;flags &amp; TCP_CTL) == (TCP_SYN | TCP_ACK)))) {
+    if((uip_len &gt; 0 || ((BUF-&gt;flags &amp; (TCP_SYN | TCP_FIN)) != 0)) &amp;&amp;
+       (BUF-&gt;seqno[0] != uip_connr-&gt;rcv_nxt[0] ||
+	BUF-&gt;seqno[1] != uip_connr-&gt;rcv_nxt[1] ||
+	BUF-&gt;seqno[2] != uip_connr-&gt;rcv_nxt[2] ||
+	BUF-&gt;seqno[3] != uip_connr-&gt;rcv_nxt[3])) {
+      goto tcp_send_ack;
+    }
+  }
+
+  /* Next, check if the incoming segment acknowledges any outstanding
+     data. If so, we update the sequence number, reset the length of
+     the outstanding data, calculate RTT estimations, and reset the
+     retransmission timer. */
+  if((BUF-&gt;flags &amp; TCP_ACK) &amp;&amp; uip_outstanding(uip_connr)) {
+    uip_add32(uip_connr-&gt;snd_nxt, uip_connr-&gt;len);
+
+    if(BUF-&gt;ackno[0] == uip_acc32[0] &amp;&amp;
+       BUF-&gt;ackno[1] == uip_acc32[1] &amp;&amp;
+       BUF-&gt;ackno[2] == uip_acc32[2] &amp;&amp;
+       BUF-&gt;ackno[3] == uip_acc32[3]) {
+      /* Update sequence number. */
+      uip_connr-&gt;snd_nxt[0] = uip_acc32[0];
+      uip_connr-&gt;snd_nxt[1] = uip_acc32[1];
+      uip_connr-&gt;snd_nxt[2] = uip_acc32[2];
+      uip_connr-&gt;snd_nxt[3] = uip_acc32[3];
+	
+
+      /* Do RTT estimation, unless we have done retransmissions. */
+      if(uip_connr-&gt;nrtx == 0) {
+	signed char m;
+	m = uip_connr-&gt;rto - uip_connr-&gt;timer;
+	/* This is taken directly from VJs original code in his paper */
+	m = m - (uip_connr-&gt;sa &gt;&gt; 3);
+	uip_connr-&gt;sa += m;
+	if(m &lt; 0) {
+	  m = -m;
+	}
+	m = m - (uip_connr-&gt;sv &gt;&gt; 2);
+	uip_connr-&gt;sv += m;
+	uip_connr-&gt;rto = (uip_connr-&gt;sa &gt;&gt; 3) + uip_connr-&gt;sv;
+
+      }
+      /* Set the acknowledged flag. */
+      uip_flags = UIP_ACKDATA;
+      /* Reset the retransmission timer. */
+      uip_connr-&gt;timer = uip_connr-&gt;rto;
+
+      /* Reset length of outstanding data. */
+      uip_connr-&gt;len = 0;
+    }
+    
+  }
+
+  /* Do different things depending on in what state the connection is. */
+  switch(uip_connr-&gt;tcpstateflags &amp; UIP_TS_MASK) {
+    /* CLOSED and LISTEN are not handled here. CLOSE_WAIT is not
+	implemented, since we force the application to close when the
+	peer sends a FIN (hence the application goes directly from
+	ESTABLISHED to LAST_ACK). */
+  case UIP_SYN_RCVD:
+    /* In SYN_RCVD we have sent out a SYNACK in response to a SYN, and
+       we are waiting for an ACK that acknowledges the data we sent
+       out the last time. Therefore, we want to have the UIP_ACKDATA
+       flag set. If so, we enter the ESTABLISHED state. */
+    if(uip_flags &amp; UIP_ACKDATA) {
+      uip_connr-&gt;tcpstateflags = UIP_ESTABLISHED;
+      uip_flags = UIP_CONNECTED;
+      uip_connr-&gt;len = 0;
+      if(uip_len &gt; 0) {
+        uip_flags |= UIP_NEWDATA;
+        uip_add_rcv_nxt(uip_len);
+      }
+      uip_slen = 0;
+      UIP_APPCALL();
+      goto appsend;
+    }
+    goto drop;
+#if UIP_ACTIVE_OPEN
+  case UIP_SYN_SENT:
+    /* In SYN_SENT, we wait for a SYNACK that is sent in response to
+       our SYN. The rcv_nxt is set to sequence number in the SYNACK
+       plus one, and we send an ACK. We move into the ESTABLISHED
+       state. */
+    if((uip_flags &amp; UIP_ACKDATA) &amp;&amp;
+       (BUF-&gt;flags &amp; TCP_CTL) == (TCP_SYN | TCP_ACK)) {
+
+      /* Parse the TCP MSS option, if present. */
+      if((BUF-&gt;tcpoffset &amp; 0xf0) &gt; 0x50) {
+	for(c = 0; c &lt; ((BUF-&gt;tcpoffset &gt;&gt; 4) - 5) &lt;&lt; 2 ;) {
+	  opt = uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + c];
+	  if(opt == TCP_OPT_END) {
+	    /* End of options. */
+	    break;
+	  } else if(opt == TCP_OPT_NOOP) {
+	    ++c;
+	    /* NOP option. */
+	  } else if(opt == TCP_OPT_MSS &amp;&amp;
+		    uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
+	    /* An MSS option with the right option length. */
+	    tmp16 = (uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] &lt;&lt; 8) |
+	      uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 3 + c];
+	    uip_connr-&gt;initialmss =
+	      uip_connr-&gt;mss = tmp16 &gt; UIP_TCP_MSS? UIP_TCP_MSS: tmp16;
+
+	    /* And we are done processing options. */
+	    break;
+	  } else {
+	    /* All other options have a length field, so that we easily
+	       can skip past them. */
+	    if(uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0) {
+	      /* If the length field is zero, the options are malformed
+		 and we don't process them further. */
+	      break;
+	    }
+	    c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
+	  }
+	}
+      }
+      uip_connr-&gt;tcpstateflags = UIP_ESTABLISHED;
+      uip_connr-&gt;rcv_nxt[0] = BUF-&gt;seqno[0];
+      uip_connr-&gt;rcv_nxt[1] = BUF-&gt;seqno[1];
+      uip_connr-&gt;rcv_nxt[2] = BUF-&gt;seqno[2];
+      uip_connr-&gt;rcv_nxt[3] = BUF-&gt;seqno[3];
+      uip_add_rcv_nxt(1);
+      uip_flags = UIP_CONNECTED | UIP_NEWDATA;
+      uip_connr-&gt;len = 0;
+      uip_len = 0;
+      uip_slen = 0;
+      UIP_APPCALL();
+      goto appsend;
+    }
+    /* Inform the application that the connection failed */
+    uip_flags = UIP_ABORT;
+    UIP_APPCALL();
+    /* The connection is closed after we send the RST */
+    uip_conn-&gt;tcpstateflags = UIP_CLOSED;
+    goto reset;
+#endif /* UIP_ACTIVE_OPEN */
+    
+  case UIP_ESTABLISHED:
+    /* In the ESTABLISHED state, we call upon the application to feed
+    data into the uip_buf. If the UIP_ACKDATA flag is set, the
+    application should put new data into the buffer, otherwise we are
+    retransmitting an old segment, and the application should put that
+    data into the buffer.
+
+    If the incoming packet is a FIN, we should close the connection on
+    this side as well, and we send out a FIN and enter the LAST_ACK
+    state. We require that there is no outstanding data; otherwise the
+    sequence numbers will be screwed up. */
+
+    if(BUF-&gt;flags &amp; TCP_FIN &amp;&amp; !(uip_connr-&gt;tcpstateflags &amp; UIP_STOPPED)) {
+      if(uip_outstanding(uip_connr)) {
+	goto drop;
+      }
+      uip_add_rcv_nxt(1 + uip_len);
+      uip_flags |= UIP_CLOSE;
+      if(uip_len &gt; 0) {
+	uip_flags |= UIP_NEWDATA;
+      }
+      UIP_APPCALL();
+      uip_connr-&gt;len = 1;
+      uip_connr-&gt;tcpstateflags = UIP_LAST_ACK;
+      uip_connr-&gt;nrtx = 0;
+    tcp_send_finack:
+      BUF-&gt;flags = TCP_FIN | TCP_ACK;
+      goto tcp_send_nodata;
+    }
+
+    /* Check the URG flag. If this is set, the segment carries urgent
+       data that we must pass to the application. */
+    if((BUF-&gt;flags &amp; TCP_URG) != 0) {
+#if UIP_URGDATA &gt; 0
+      uip_urglen = (BUF-&gt;urgp[0] &lt;&lt; 8) | BUF-&gt;urgp[1];
+      if(uip_urglen &gt; uip_len) {
+	/* There is more urgent data in the next segment to come. */
+	uip_urglen = uip_len;
+      }
+      uip_add_rcv_nxt(uip_urglen);
+      uip_len -= uip_urglen;
+      uip_urgdata = uip_appdata;
+      uip_appdata += uip_urglen;
+    } else {
+      uip_urglen = 0;
+#else /* UIP_URGDATA &gt; 0 */
+      uip_appdata = ((char *)uip_appdata) + ((BUF-&gt;urgp[0] &lt;&lt; 8) | BUF-&gt;urgp[1]);
+      uip_len -= (BUF-&gt;urgp[0] &lt;&lt; 8) | BUF-&gt;urgp[1];
+#endif /* UIP_URGDATA &gt; 0 */
+    }
+
+    /* If uip_len &gt; 0 we have TCP data in the packet, and we flag this
+       by setting the UIP_NEWDATA flag and update the sequence number
+       we acknowledge. If the application has stopped the dataflow
+       using uip_stop(), we must not accept any data packets from the
+       remote host. */
+    if(uip_len &gt; 0 &amp;&amp; !(uip_connr-&gt;tcpstateflags &amp; UIP_STOPPED)) {
+      uip_flags |= UIP_NEWDATA;
+      uip_add_rcv_nxt(uip_len);
+    }
+
+    /* Check if the available buffer space advertised by the other end
+       is smaller than the initial MSS for this connection. If so, we
+       set the current MSS to the window size to ensure that the
+       application does not send more data than the other end can
+       handle.
+
+       If the remote host advertises a zero window, we set the MSS to
+       the initial MSS so that the application will send an entire MSS
+       of data. This data will not be acknowledged by the receiver,
+       and the application will retransmit it. This is called the
+       &quot;persistent timer&quot; and uses the retransmission mechanim.
+    */
+    tmp16 = ((u16_t)BUF-&gt;wnd[0] &lt;&lt; 8) + (u16_t)BUF-&gt;wnd[1];
+    if(tmp16 &gt; uip_connr-&gt;initialmss ||
+       tmp16 == 0) {
+      tmp16 = uip_connr-&gt;initialmss;
+    }
+    uip_connr-&gt;mss = tmp16;
+
+    /* If this packet constitutes an ACK for outstanding data (flagged
+       by the UIP_ACKDATA flag, we should call the application since it
+       might want to send more data. If the incoming packet had data
+       from the peer (as flagged by the UIP_NEWDATA flag), the
+       application must also be notified.
+
+       When the application is called, the global variable uip_len
+       contains the length of the incoming data. The application can
+       access the incoming data through the global pointer
+       uip_appdata, which usually points UIP_IPTCPH_LEN + UIP_LLH_LEN
+       bytes into the uip_buf array.
+
+       If the application wishes to send any data, this data should be
+       put into the uip_appdata and the length of the data should be
+       put into uip_len. If the application don't have any data to
+       send, uip_len must be set to 0. */
+    if(uip_flags &amp; (UIP_NEWDATA | UIP_ACKDATA)) {
+      uip_slen = 0;
+      UIP_APPCALL();
+
+    appsend:
+      
+      if(uip_flags &amp; UIP_ABORT) {
+	uip_slen = 0;
+	uip_connr-&gt;tcpstateflags = UIP_CLOSED;
+	BUF-&gt;flags = TCP_RST | TCP_ACK;
+	goto tcp_send_nodata;
+      }
+
+      if(uip_flags &amp; UIP_CLOSE) {
+	uip_slen = 0;
+	uip_connr-&gt;len = 1;
+	uip_connr-&gt;tcpstateflags = UIP_FIN_WAIT_1;
+	uip_connr-&gt;nrtx = 0;
+	BUF-&gt;flags = TCP_FIN | TCP_ACK;
+	goto tcp_send_nodata;
+      }
+
+      /* If uip_slen &gt; 0, the application has data to be sent. */
+      if(uip_slen &gt; 0) {
+
+	/* If the connection has acknowledged data, the contents of
+	   the -&gt;len variable should be discarded. */
+	if((uip_flags &amp; UIP_ACKDATA) != 0) {
+	  uip_connr-&gt;len = 0;
+	}
+
+	/* If the -&gt;len variable is non-zero the connection has
+	   already data in transit and cannot send anymore right
+	   now. */
+	if(uip_connr-&gt;len == 0) {
+
+	  /* The application cannot send more than what is allowed by
+	     the mss (the minumum of the MSS and the available
+	     window). */
+	  if(uip_slen &gt; uip_connr-&gt;mss) {
+	    uip_slen = uip_connr-&gt;mss;
+	  }
+
+	  /* Remember how much data we send out now so that we know
+	     when everything has been acknowledged. */
+	  uip_connr-&gt;len = uip_slen;
+	} else {
+
+	  /* If the application already had unacknowledged data, we
+	     make sure that the application does not send (i.e.,
+	     retransmit) out more than it previously sent out. */
+	  uip_slen = uip_connr-&gt;len;
+	}
+      }
+      uip_connr-&gt;nrtx = 0;
+    apprexmit:
+      uip_appdata = uip_sappdata;
+      
+      /* If the application has data to be sent, or if the incoming
+         packet had new data in it, we must send out a packet. */
+      if(uip_slen &gt; 0 &amp;&amp; uip_connr-&gt;len &gt; 0) {
+	/* Add the length of the IP and TCP headers. */
+	uip_len = uip_connr-&gt;len + UIP_TCPIP_HLEN;
+	/* We always set the ACK flag in response packets. */
+	BUF-&gt;flags = TCP_ACK | TCP_PSH;
+	/* Send the packet. */
+	goto tcp_send_noopts;
+      }
+      /* If there is no data to send, just send out a pure ACK if
+	 there is newdata. */
+      if(uip_flags &amp; UIP_NEWDATA) {
+	uip_len = UIP_TCPIP_HLEN;
+	BUF-&gt;flags = TCP_ACK;
+	goto tcp_send_noopts;
+      }
+    }
+    goto drop;
+  case UIP_LAST_ACK:
+    /* We can close this connection if the peer has acknowledged our
+       FIN. This is indicated by the UIP_ACKDATA flag. */
+    if(uip_flags &amp; UIP_ACKDATA) {
+      uip_connr-&gt;tcpstateflags = UIP_CLOSED;
+      uip_flags = UIP_CLOSE;
+      UIP_APPCALL();
+    }
+    break;
+    
+  case UIP_FIN_WAIT_1:
+    /* The application has closed the connection, but the remote host
+       hasn't closed its end yet. Thus we do nothing but wait for a
+       FIN from the other side. */
+    if(uip_len &gt; 0) {
+      uip_add_rcv_nxt(uip_len);
+    }
+    if(BUF-&gt;flags &amp; TCP_FIN) {
+      if(uip_flags &amp; UIP_ACKDATA) {
+	uip_connr-&gt;tcpstateflags = UIP_TIME_WAIT;
+	uip_connr-&gt;timer = 0;
+	uip_connr-&gt;len = 0;
+      } else {
+	uip_connr-&gt;tcpstateflags = UIP_CLOSING;
+      }
+      uip_add_rcv_nxt(1);
+      uip_flags = UIP_CLOSE;
+      UIP_APPCALL();
+      goto tcp_send_ack;
+    } else if(uip_flags &amp; UIP_ACKDATA) {
+      uip_connr-&gt;tcpstateflags = UIP_FIN_WAIT_2;
+      uip_connr-&gt;len = 0;
+      goto drop;
+    }
+    if(uip_len &gt; 0) {
+      goto tcp_send_ack;
+    }
+    goto drop;
+      
+  case UIP_FIN_WAIT_2:
+    if(uip_len &gt; 0) {
+      uip_add_rcv_nxt(uip_len);
+    }
+    if(BUF-&gt;flags &amp; TCP_FIN) {
+      uip_connr-&gt;tcpstateflags = UIP_TIME_WAIT;
+      uip_connr-&gt;timer = 0;
+      uip_add_rcv_nxt(1);
+      uip_flags = UIP_CLOSE;
+      UIP_APPCALL();
+      goto tcp_send_ack;
+    }
+    if(uip_len &gt; 0) {
+      goto tcp_send_ack;
+    }
+    goto drop;
+
+  case UIP_TIME_WAIT:
+    goto tcp_send_ack;
+    
+  case UIP_CLOSING:
+    if(uip_flags &amp; UIP_ACKDATA) {
+      uip_connr-&gt;tcpstateflags = UIP_TIME_WAIT;
+      uip_connr-&gt;timer = 0;
+    }
+  }
+  goto drop;
+  
+
+  /* We jump here when we are ready to send the packet, and just want
+     to set the appropriate TCP sequence numbers in the TCP header. */
+ tcp_send_ack:
+  BUF-&gt;flags = TCP_ACK;
+ tcp_send_nodata:
+  uip_len = UIP_IPTCPH_LEN;
+ tcp_send_noopts:
+  BUF-&gt;tcpoffset = (UIP_TCPH_LEN / 4) &lt;&lt; 4;
+ tcp_send:
+  /* We're done with the input processing. We are now ready to send a
+     reply. Our job is to fill in all the fields of the TCP and IP
+     headers before calculating the checksum and finally send the
+     packet. */
+  BUF-&gt;ackno[0] = uip_connr-&gt;rcv_nxt[0];
+  BUF-&gt;ackno[1] = uip_connr-&gt;rcv_nxt[1];
+  BUF-&gt;ackno[2] = uip_connr-&gt;rcv_nxt[2];
+  BUF-&gt;ackno[3] = uip_connr-&gt;rcv_nxt[3];
+  
+  BUF-&gt;seqno[0] = uip_connr-&gt;snd_nxt[0];
+  BUF-&gt;seqno[1] = uip_connr-&gt;snd_nxt[1];
+  BUF-&gt;seqno[2] = uip_connr-&gt;snd_nxt[2];
+  BUF-&gt;seqno[3] = uip_connr-&gt;snd_nxt[3];
+
+  BUF-&gt;proto = UIP_PROTO_TCP;
+  
+  BUF-&gt;srcport  = uip_connr-&gt;lport;
+  BUF-&gt;destport = uip_connr-&gt;rport;
+
+  uip_ipaddr_copy(BUF-&gt;srcipaddr, uip_hostaddr);
+  uip_ipaddr_copy(BUF-&gt;destipaddr, uip_connr-&gt;ripaddr);
+
+  if(uip_connr-&gt;tcpstateflags &amp; UIP_STOPPED) {
+    /* If the connection has issued uip_stop(), we advertise a zero
+       window so that the remote host will stop sending data. */
+    BUF-&gt;wnd[0] = BUF-&gt;wnd[1] = 0;
+  } else {
+    BUF-&gt;wnd[0] = ((UIP_RECEIVE_WINDOW) &gt;&gt; 8);
+    BUF-&gt;wnd[1] = ((UIP_RECEIVE_WINDOW) &amp; 0xff);
+  }
+
+ tcp_send_noconn:
+  BUF-&gt;ttl = UIP_TTL;
+#if UIP_CONF_IPV6
+  /* For IPv6, the IP length field does not include the IPv6 IP header
+     length. */
+  BUF-&gt;len[0] = ((uip_len - UIP_IPH_LEN) &gt;&gt; 8);
+  BUF-&gt;len[1] = ((uip_len - UIP_IPH_LEN) &amp; 0xff);
+#else /* UIP_CONF_IPV6 */
+  BUF-&gt;len[0] = (uip_len &gt;&gt; 8);
+  BUF-&gt;len[1] = (uip_len &amp; 0xff);
+#endif /* UIP_CONF_IPV6 */
+
+  BUF-&gt;urgp[0] = BUF-&gt;urgp[1] = 0;
+  
+  /* Calculate TCP checksum. */
+  BUF-&gt;tcpchksum = 0;
+  BUF-&gt;tcpchksum = ~(uip_tcpchksum());
+#endif /* UIP_TCP */
+  
+ ip_send_nolen:
+
+#if UIP_CONF_IPV6
+  BUF-&gt;vtc = 0x60;
+  BUF-&gt;tcflow = 0x00;
+  BUF-&gt;flow = 0x00;
+#else /* UIP_CONF_IPV6 */
+  BUF-&gt;vhl = 0x45;
+  BUF-&gt;tos = 0;
+  BUF-&gt;ipoffset[0] = BUF-&gt;ipoffset[1] = 0;
+  ++ipid;
+  BUF-&gt;ipid[0] = ipid &gt;&gt; 8;
+  BUF-&gt;ipid[1] = ipid &amp; 0xff;
+  /* Calculate IP checksum. */
+  BUF-&gt;ipchksum = 0;
+  BUF-&gt;ipchksum = ~(uip_ipchksum());
+  DEBUG_PRINTF(&quot;uip ip_send_nolen: chkecum 0x%04x\n&quot;, uip_ipchksum());
+#endif /* UIP_CONF_IPV6 */
+   
+  UIP_STAT(++uip_stat.tcp.sent);
+ send:
+  DEBUG_PRINTF(&quot;Sending packet with length %d (%d)\n&quot;, uip_len,
+	       (BUF-&gt;len[0] &lt;&lt; 8) | BUF-&gt;len[1]);
+  
+  UIP_STAT(++uip_stat.ip.sent);
+  /* Return and let the caller do the actual transmission. */
+  uip_flags = 0;
+  return;
+ drop:
+  uip_len = 0;
+  uip_flags = 0;
+  return;
+}
+/*---------------------------------------------------------------------------*/
+u16_t
+htons(u16_t val)
+{
+  return HTONS(val);
+}
+/*---------------------------------------------------------------------------*/
+void
+uip_send(const void *data, int len)
+{
+  if(len &gt; 0) {
+    uip_slen = len;
+    if(data != uip_sappdata) {
+      memcpy(uip_sappdata, (data), uip_slen);
+    }
+  }
+}
+/** @} */
+
+#endif // #ifdef BUILD_UIP

Added: trunk/src/uip/uip.h
===================================================================
--- trunk/src/uip/uip.h	2008-09-10 18:59:17 UTC (rev 88)
+++ trunk/src/uip/uip.h	2008-09-15 21:54:14 UTC (rev 89)
@@ -0,0 +1,1607 @@
+
+/**
+ * \addtogroup uip
+ * @{
+ */
+
+/**
+ * \file
+ * Header file for the uIP TCP/IP stack.
+ * \author Adam Dunkels &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">adam at dunkels.com</A>&gt;
+ *
+ * The uIP TCP/IP stack header file contains definitions for a number
+ * of C macros that are used by uIP programs as well as internal uIP
+ * structures, TCP/IP header structures and function declarations.
+ *
+ */
+
+
+/*
+ * Copyright (c) 2001-2003, Adam Dunkels.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote
+ *    products derived from this software without specific prior
+ *    written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * This file is part of the uIP TCP/IP stack.
+ *
+ * $Id: uip.h,v 1.40 2006/06/08 07:12:07 adam Exp $
+ *
+ */
+
+#ifndef __UIP_H__
+#define __UIP_H__
+
+#include &quot;uipopt.h&quot;
+
+/**
+ * Repressentation of an IP address.
+ *
+ */
+typedef u16_t uip_ip4addr_t[2];
+typedef u16_t uip_ip6addr_t[8];
+#if UIP_CONF_IPV6
+typedef uip_ip6addr_t uip_ipaddr_t;
+#else /* UIP_CONF_IPV6 */
+typedef uip_ip4addr_t uip_ipaddr_t;
+#endif /* UIP_CONF_IPV6 */
+
+/*---------------------------------------------------------------------------*/
+/* First, the functions that should be called from the
+ * system. Initialization, the periodic timer and incoming packets are
+ * handled by the following three functions.
+ */
+
+/**
+ * \defgroup uipconffunc uIP configuration functions
+ * @{
+ *
+ * The uIP configuration functions are used for setting run-time
+ * parameters in uIP such as IP addresses.
+ */
+
+/**
+ * Set the IP address of this host.
+ *
+ * The IP address is represented as a 4-byte array where the first
+ * octet of the IP address is put in the first member of the 4-byte
+ * array.
+ *
+ * Example:
+ \code
+
+ uip_ipaddr_t addr;
+
+ uip_ipaddr(&amp;addr, 192,168,1,2);
+ uip_sethostaddr(&amp;addr);
+ 
+ \endcode
+ * \param addr A pointer to an IP address of type uip_ipaddr_t;
+ *
+ * \sa uip_ipaddr()
+ *
+ * \hideinitializer
+ */
+#define uip_sethostaddr(addr) uip_ipaddr_copy(uip_hostaddr, (addr))
+
+/**
+ * Get the IP address of this host.
+ *
+ * The IP address is represented as a 4-byte array where the first
+ * octet of the IP address is put in the first member of the 4-byte
+ * array.
+ *
+ * Example:
+ \code
+ uip_ipaddr_t hostaddr;
+
+ uip_gethostaddr(&amp;hostaddr);
+ \endcode
+ * \param addr A pointer to a uip_ipaddr_t variable that will be
+ * filled in with the currently configured IP address.
+ *
+ * \hideinitializer
+ */
+#define uip_gethostaddr(addr) uip_ipaddr_copy((addr), uip_hostaddr)
+
+/**
+ * Set the default router's IP address.
+ *
+ * \param addr A pointer to a uip_ipaddr_t variable containing the IP
+ * address of the default router.
+ *
+ * \sa uip_ipaddr()
+ *
+ * \hideinitializer
+ */
+#define uip_setdraddr(addr) uip_ipaddr_copy(uip_draddr, (addr))
+
+/**
+ * Set the netmask.
+ *
+ * \param addr A pointer to a uip_ipaddr_t variable containing the IP
+ * address of the netmask.
+ *
+ * \sa uip_ipaddr()
+ *
+ * \hideinitializer
+ */
+#define uip_setnetmask(addr) uip_ipaddr_copy(uip_netmask, (addr))
+
+
+/**
+ * Get the default router's IP address.
+ *
+ * \param addr A pointer to a uip_ipaddr_t variable that will be
+ * filled in with the IP address of the default router.
+ *
+ * \hideinitializer
+ */
+#define uip_getdraddr(addr) uip_ipaddr_copy((addr), uip_draddr)
+
+/**
+ * Get the netmask.
+ *
+ * \param addr A pointer to a uip_ipaddr_t variable that will be
+ * filled in with the value of the netmask.
+ *
+ * \hideinitializer
+ */
+#define uip_getnetmask(addr) uip_ipaddr_copy((addr), uip_netmask)
+
+/** @} */
+
+/**
+ * \defgroup uipinit uIP initialization functions
+ * @{
+ *
+ * The uIP initialization functions are used for booting uIP.
+ */
+
+/**
+ * uIP initialization function.
+ *
+ * This function should be called at boot up to initilize the uIP
+ * TCP/IP stack.
+ */
+void uip_init(void);
+
+/**
+ * uIP initialization function.
+ *
+ * This function may be used at boot time to set the initial ip_id.
+ */
+void uip_setipid(u16_t id);
+
+/** @} */
+
+/**
+ * \defgroup uipdevfunc uIP device driver functions
+ * @{
+ *
+ * These functions are used by a network device driver for interacting
+ * with uIP.
+ */
+
+/**
+ * Process an incoming packet.
+ *
+ * This function should be called when the device driver has received
+ * a packet from the network. The packet from the device driver must
+ * be present in the uip_buf buffer, and the length of the packet
+ * should be placed in the uip_len variable.
+ *
+ * When the function returns, there may be an outbound packet placed
+ * in the uip_buf packet buffer. If so, the uip_len variable is set to
+ * the length of the packet. If no packet is to be sent out, the
+ * uip_len variable is set to 0.
+ *
+ * The usual way of calling the function is presented by the source
+ * code below.
+ \code
+  uip_len = devicedriver_poll();
+  if(uip_len &gt; 0) {
+    uip_input();
+    if(uip_len &gt; 0) {
+      devicedriver_send();
+    }
+  }
+ \endcode
+ *
+ * \note If you are writing a uIP device driver that needs ARP
+ * (Address Resolution Protocol), e.g., when running uIP over
+ * Ethernet, you will need to call the uIP ARP code before calling
+ * this function:
+ \code
+  #define BUF ((struct uip_eth_hdr *)&amp;uip_buf[0])
+  uip_len = ethernet_devicedrver_poll();
+  if(uip_len &gt; 0) {
+    if(BUF-&gt;type == HTONS(UIP_ETHTYPE_IP)) {
+      uip_arp_ipin();
+      uip_input();
+      if(uip_len &gt; 0) {
+        uip_arp_out();
+	ethernet_devicedriver_send();
+      }
+    } else if(BUF-&gt;type == HTONS(UIP_ETHTYPE_ARP)) {
+      uip_arp_arpin();
+      if(uip_len &gt; 0) {
+	ethernet_devicedriver_send();
+      }
+    }
+ \endcode
+ *
+ * \hideinitializer
+ */
+#define uip_input()        uip_process(UIP_DATA)
+
+/**
+ * Periodic processing for a connection identified by its number.
+ *
+ * This function does the necessary periodic processing (timers,
+ * polling) for a uIP TCP conneciton, and should be called when the
+ * periodic uIP timer goes off. It should be called for every
+ * connection, regardless of whether they are open of closed.
+ *
+ * When the function returns, it may have an outbound packet waiting
+ * for service in the uIP packet buffer, and if so the uip_len
+ * variable is set to a value larger than zero. The device driver
+ * should be called to send out the packet.
+ *
+ * The ususal way of calling the function is through a for() loop like
+ * this:
+ \code
+  for(i = 0; i &lt; UIP_CONNS; ++i) {
+    uip_periodic(i);
+    if(uip_len &gt; 0) {
+      devicedriver_send();
+    }
+  }
+ \endcode
+ *
+ * \note If you are writing a uIP device driver that needs ARP
+ * (Address Resolution Protocol), e.g., when running uIP over
+ * Ethernet, you will need to call the uip_arp_out() function before
+ * calling the device driver:
+ \code
+  for(i = 0; i &lt; UIP_CONNS; ++i) {
+    uip_periodic(i);
+    if(uip_len &gt; 0) {
+      uip_arp_out();
+      ethernet_devicedriver_send();
+    }
+  }
+ \endcode
+ *
+ * \param conn The number of the connection which is to be periodically polled.
+ *
+ * \hideinitializer
+ */
+#define uip_periodic(conn) do { uip_conn = &amp;uip_conns[conn]; \
+                                uip_process(UIP_TIMER); } while (0)
+
+/**
+ *
+ *
+ */
+#define uip_conn_active(conn) (uip_conns[conn].tcpstateflags != UIP_CLOSED)
+
+/**
+ * Perform periodic processing for a connection identified by a pointer
+ * to its structure.
+ *
+ * Same as uip_periodic() but takes a pointer to the actual uip_conn
+ * struct instead of an integer as its argument. This function can be
+ * used to force periodic processing of a specific connection.
+ *
+ * \param conn A pointer to the uip_conn struct for the connection to
+ * be processed.
+ *
+ * \hideinitializer
+ */
+#define uip_periodic_conn(conn) do { uip_conn = conn; \
+                                     uip_process(UIP_TIMER); } while (0)
+
+/**
+ * Reuqest that a particular connection should be polled.
+ *
+ * Similar to uip_periodic_conn() but does not perform any timer
+ * processing. The application is polled for new data.
+ *
+ * \param conn A pointer to the uip_conn struct for the connection to
+ * be processed.
+ *
+ * \hideinitializer
+ */
+#define uip_poll_conn(conn) do { uip_conn = conn; \
+                                 uip_process(UIP_POLL_REQUEST); } while (0)
+
+
+#if UIP_UDP
+/**
+ * Periodic processing for a UDP connection identified by its number.
+ *
+ * This function is essentially the same as uip_periodic(), but for
+ * UDP connections. It is called in a similar fashion as the
+ * uip_periodic() function:
+ \code
+  for(i = 0; i &lt; UIP_UDP_CONNS; i++) {
+    uip_udp_periodic(i);
+    if(uip_len &gt; 0) {
+      devicedriver_send();
+    }
+  }
+ \endcode
+ *
+ * \note As for the uip_periodic() function, special care has to be
+ * taken when using uIP together with ARP and Ethernet:
+ \code
+  for(i = 0; i &lt; UIP_UDP_CONNS; i++) {
+    uip_udp_periodic(i);
+    if(uip_len &gt; 0) {
+      uip_arp_out();
+      ethernet_devicedriver_send();
+    }
+  }
+ \endcode
+ *
+ * \param conn The number of the UDP connection to be processed.
+ *
+ * \hideinitializer
+ */
+#define uip_udp_periodic(conn) do { uip_udp_conn = &amp;uip_udp_conns[conn]; \
+                                uip_process(UIP_UDP_TIMER); } while (0)
+
+/**
+ * Periodic processing for a UDP connection identified by a pointer to
+ * its structure.
+ *
+ * Same as uip_udp_periodic() but takes a pointer to the actual
+ * uip_conn struct instead of an integer as its argument. This
+ * function can be used to force periodic processing of a specific
+ * connection.
+ *
+ * \param conn A pointer to the uip_udp_conn struct for the connection
+ * to be processed.
+ *
+ * \hideinitializer
+ */
+#define uip_udp_periodic_conn(conn) do { uip_udp_conn = conn; \
+                                         uip_process(UIP_UDP_TIMER); } while (0)
+
+
+#endif /* UIP_UDP */
+
+/**
+ * The uIP packet buffer.
+ *
+ * The uip_buf array is used to hold incoming and outgoing
+ * packets. The device driver should place incoming data into this
+ * buffer. When sending data, the device driver should read the link
+ * level headers and the TCP/IP headers from this buffer. The size of
+ * the link level headers is configured by the UIP_LLH_LEN define.
+ *
+ * \note The application data need not be placed in this buffer, so
+ * the device driver must read it from the place pointed to by the
+ * uip_appdata pointer as illustrated by the following example:
+ \code
+ void
+ devicedriver_send(void)
+ {
+    hwsend(&amp;uip_buf[0], UIP_LLH_LEN);
+    if(uip_len &lt;= UIP_LLH_LEN + UIP_TCPIP_HLEN) {
+      hwsend(&amp;uip_buf[UIP_LLH_LEN], uip_len - UIP_LLH_LEN);
+    } else {
+      hwsend(&amp;uip_buf[UIP_LLH_LEN], UIP_TCPIP_HLEN);
+      hwsend(uip_appdata, uip_len - UIP_TCPIP_HLEN - UIP_LLH_LEN);
+    }
+ }
+ \endcode
+ */
+extern u8_t uip_buf[UIP_BUFSIZE+2];
+
+/** @} */
+
+/*---------------------------------------------------------------------------*/
+/* Functions that are used by the uIP application program. Opening and
+ * closing connections, sending and receiving data, etc. is all
+ * handled by the functions below.
+*/
+/**
+ * \defgroup uipappfunc uIP application functions
+ * @{
+ *
+ * Functions used by an application running of top of uIP.
+ */
+
+/**
+ * Start listening to the specified port.
+ *
+ * \note Since this function expects the port number in network byte
+ * order, a conversion using HTONS() or htons() is necessary.
+ *
+ \code
+ uip_listen(HTONS(80));
+ \endcode
+ *
+ * \param port A 16-bit port number in network byte order.
+ */
+void uip_listen(u16_t port);
+
+/**
+ * Stop listening to the specified port.
+ *
+ * \note Since this function expects the port number in network byte
+ * order, a conversion using HTONS() or htons() is necessary.
+ *
+ \code
+ uip_unlisten(HTONS(80));
+ \endcode
+ *
+ * \param port A 16-bit port number in network byte order.
+ */
+void uip_unlisten(u16_t port);
+
+/**
+ * Connect to a remote host using TCP.
+ *
+ * This function is used to start a new connection to the specified
+ * port on the specied host. It allocates a new connection identifier,
+ * sets the connection to the SYN_SENT state and sets the
+ * retransmission timer to 0. This will cause a TCP SYN segment to be
+ * sent out the next time this connection is periodically processed,
+ * which usually is done within 0.5 seconds after the call to
+ * uip_connect().
+ *
+ * \note This function is avaliable only if support for active open
+ * has been configured by defining UIP_ACTIVE_OPEN to 1 in uipopt.h.
+ *
+ * \note Since this function requires the port number to be in network
+ * byte order, a conversion using HTONS() or htons() is necessary.
+ *
+ \code
+ uip_ipaddr_t ipaddr;
+
+ uip_ipaddr(&amp;ipaddr, 192,168,1,2);
+ uip_connect(&amp;ipaddr, HTONS(80));
+ \endcode
+ *
+ * \param ripaddr The IP address of the remote hot.
+ *
+ * \param port A 16-bit port number in network byte order.
+ *
+ * \return A pointer to the uIP connection identifier for the new connection,
+ * or NULL if no connection could be allocated.
+ *
+ */
+struct uip_conn *uip_connect(uip_ipaddr_t *ripaddr, u16_t port);
+
+
+
+/**
+ * \internal
+ *
+ * Check if a connection has outstanding (i.e., unacknowledged) data.
+ *
+ * \param conn A pointer to the uip_conn structure for the connection.
+ *
+ * \hideinitializer
+ */
+#define uip_outstanding(conn) ((conn)-&gt;len)
+
+/**
+ * Send data on the current connection.
+ *
+ * This function is used to send out a single segment of TCP
+ * data. Only applications that have been invoked by uIP for event
+ * processing can send data.
+ *
+ * The amount of data that actually is sent out after a call to this
+ * funcion is determined by the maximum amount of data TCP allows. uIP
+ * will automatically crop the data so that only the appropriate
+ * amount of data is sent. The function uip_mss() can be used to query
+ * uIP for the amount of data that actually will be sent.
+ *
+ * \note This function does not guarantee that the sent data will
+ * arrive at the destination. If the data is lost in the network, the
+ * application will be invoked with the uip_rexmit() event being
+ * set. The application will then have to resend the data using this
+ * function.
+ *
+ * \param data A pointer to the data which is to be sent.
+ *
+ * \param len The maximum amount of data bytes to be sent.
+ *
+ * \hideinitializer
+ */
+void uip_send(const void *data, int len);
+
+/**
+ * The length of any incoming data that is currently avaliable (if avaliable)
+ * in the uip_appdata buffer.
+ *
+ * The test function uip_data() must first be used to check if there
+ * is any data available at all.
+ *
+ * \hideinitializer
+ */
+/*void uip_datalen(void);*/
+#define uip_datalen()       uip_len
+
+/**
+ * The length of any out-of-band data (urgent data) that has arrived
+ * on the connection.
+ *
+ * \note The configuration parameter UIP_URGDATA must be set for this
+ * function to be enabled.
+ *
+ * \hideinitializer
+ */
+#define uip_urgdatalen()    uip_urglen
+
+/**
+ * Close the current connection.
+ *
+ * This function will close the current connection in a nice way.
+ *
+ * \hideinitializer
+ */
+#define uip_close()         (uip_flags = UIP_CLOSE)
+
+/**
+ * Abort the current connection.
+ *
+ * This function will abort (reset) the current connection, and is
+ * usually used when an error has occured that prevents using the
+ * uip_close() function.
+ *
+ * \hideinitializer
+ */
+#define uip_abort()         (uip_flags = UIP_ABORT)
+
+/**
+ * Tell the sending host to stop sending data.
+ *
+ * This function will close our receiver's window so that we stop
+ * receiving data for the current connection.
+ *
+ * \hideinitializer
+ */
+#define uip_stop()          (uip_conn-&gt;tcpstateflags |= UIP_STOPPED)
+
+/**
+ * Find out if the current connection has been previously stopped with
+ * uip_stop().
+ *
+ * \hideinitializer
+ */
+#define uip_stopped(conn)   ((conn)-&gt;tcpstateflags &amp; UIP_STOPPED)
+
+/**
+ * Restart the current connection, if is has previously been stopped
+ * with uip_stop().
+ *
+ * This function will open the receiver's window again so that we
+ * start receiving data for the current connection.
+ *
+ * \hideinitializer
+ */
+#define uip_restart()         do { uip_flags |= UIP_NEWDATA; \
+                                   uip_conn-&gt;tcpstateflags &amp;= ~UIP_STOPPED; \
+                              } while(0)
+
+
+/* uIP tests that can be made to determine in what state the current
+   connection is, and what the application function should do. */
+
+/**
+ * Is the current connection a UDP connection?
+ *
+ * This function checks whether the current connection is a UDP connection.
+ *
+ * \hideinitializer
+ *
+ */
+#define uip_udpconnection() (uip_conn == NULL)
+
+/**
+ * Is new incoming data available?
+ *
+ * Will reduce to non-zero if there is new data for the application
+ * present at the uip_appdata pointer. The size of the data is
+ * avaliable through the uip_len variable.
+ *
+ * \hideinitializer
+ */
+#define uip_newdata()   (uip_flags &amp; UIP_NEWDATA)
+
+/**
+ * Has previously sent data been acknowledged?
+ *
+ * Will reduce to non-zero if the previously sent data has been
+ * acknowledged by the remote host. This means that the application
+ * can send new data.
+ *
+ * \hideinitializer
+ */
+#define uip_acked()   (uip_flags &amp; UIP_ACKDATA)
+
+/**
+ * Has the connection just been connected?
+ *
+ * Reduces to non-zero if the current connection has been connected to
+ * a remote host. This will happen both if the connection has been
+ * actively opened (with uip_connect()) or passively opened (with
+ * uip_listen()).
+ *
+ * \hideinitializer
+ */
+#define uip_connected() (uip_flags &amp; UIP_CONNECTED)
+
+/**
+ * Has the connection been closed by the other end?
+ *
+ * Is non-zero if the connection has been closed by the remote
+ * host. The application may then do the necessary clean-ups.
+ *
+ * \hideinitializer
+ */
+#define uip_closed()    (uip_flags &amp; UIP_CLOSE)
+
+/**
+ * Has the connection been aborted by the other end?
+ *
+ * Non-zero if the current connection has been aborted (reset) by the
+ * remote host.
+ *
+ * \hideinitializer
+ */
+#define uip_aborted()    (uip_flags &amp; UIP_ABORT)
+
+/**
+ * Has the connection timed out?
+ *
+ * Non-zero if the current connection has been aborted due to too many
+ * retransmissions.
+ *
+ * \hideinitializer
+ */
+#define uip_timedout()    (uip_flags &amp; UIP_TIMEDOUT)
+
+/**
+ * Do we need to retransmit previously data?
+ *
+ * Reduces to non-zero if the previously sent data has been lost in
+ * the network, and the application should retransmit it. The
+ * application should send the exact same data as it did the last
+ * time, using the uip_send() function.
+ *
+ * \hideinitializer
+ */
+#define uip_rexmit()     (uip_flags &amp; UIP_REXMIT)
+
+/**
+ * Is the connection being polled by uIP?
+ *
+ * Is non-zero if the reason the application is invoked is that the
+ * current connection has been idle for a while and should be
+ * polled.
+ *
+ * The polling event can be used for sending data without having to
+ * wait for the remote host to send data.
+ *
+ * \hideinitializer
+ */
+#define uip_poll()       (uip_flags &amp; UIP_POLL)
+
+/**
+ * Get the initial maxium segment size (MSS) of the current
+ * connection.
+ *
+ * \hideinitializer
+ */
+#define uip_initialmss()             (uip_conn-&gt;initialmss)
+
+/**
+ * Get the current maxium segment size that can be sent on the current
+ * connection.
+ *
+ * The current maxiumum segment size that can be sent on the
+ * connection is computed from the receiver's window and the MSS of
+ * the connection (which also is available by calling
+ * uip_initialmss()).
+ *
+ * \hideinitializer
+ */
+#define uip_mss()             (uip_conn-&gt;mss)
+
+/**
+ * Set up a new UDP connection.
+ *
+ * This function sets up a new UDP connection. The function will
+ * automatically allocate an unused local port for the new
+ * connection. However, another port can be chosen by using the
+ * uip_udp_bind() call, after the uip_udp_new() function has been
+ * called.
+ *
+ * Example:
+ \code
+ uip_ipaddr_t addr;
+ struct uip_udp_conn *c;
+ 
+ uip_ipaddr(&amp;addr, 192,168,2,1);
+ c = uip_udp_new(&amp;addr, HTONS(12345));
+ if(c != NULL) {
+   uip_udp_bind(c, HTONS(12344));
+ }
+ \endcode
+ * \param ripaddr The IP address of the remote host.
+ *
+ * \param rport The remote port number in network byte order.
+ *
+ * \return The uip_udp_conn structure for the new connection or NULL
+ * if no connection could be allocated.
+ */
+struct uip_udp_conn *uip_udp_new(uip_ipaddr_t *ripaddr, u16_t rport);
+
+/**
+ * Removed a UDP connection.
+ *
+ * \param conn A pointer to the uip_udp_conn structure for the connection.
+ *
+ * \hideinitializer
+ */
+#define uip_udp_remove(conn) (conn)-&gt;lport = 0
+
+/**
+ * Bind a UDP connection to a local port.
+ *
+ * \param conn A pointer to the uip_udp_conn structure for the
+ * connection.
+ *
+ * \param port The local port number, in network byte order.
+ *
+ * \hideinitializer
+ */
+#define uip_udp_bind(conn, port) (conn)-&gt;lport = port
+
+/**
+ * Send a UDP datagram of length len on the current connection.
+ *
+ * This function can only be called in response to a UDP event (poll
+ * or newdata). The data must be present in the uip_buf buffer, at the
+ * place pointed to by the uip_appdata pointer.
+ *
+ * \param len The length of the data in the uip_buf buffer.
+ *
+ * \hideinitializer
+ */
+#define uip_udp_send(len) uip_send((char *)uip_appdata, len)
+
+/** @} */
+
+/* uIP convenience and converting functions. */
+
+/**
+ * \defgroup uipconvfunc uIP conversion functions
+ * @{
+ *
+ * These functions can be used for converting between different data
+ * formats used by uIP.
+ */
+ 
+/**
+ * Construct an IP address from four bytes.
+ *
+ * This function constructs an IP address of the type that uIP handles
+ * internally from four bytes. The function is handy for specifying IP
+ * addresses to use with e.g. the uip_connect() function.
+ *
+ * Example:
+ \code
+ uip_ipaddr_t ipaddr;
+ struct uip_conn *c;
+ 
+ uip_ipaddr(&amp;ipaddr, 192,168,1,2);
+ c = uip_connect(&amp;ipaddr, HTONS(80));
+ \endcode
+ *
+ * \param addr A pointer to a uip_ipaddr_t variable that will be
+ * filled in with the IP address.
+ *
+ * \param addr0 The first octet of the IP address.
+ * \param addr1 The second octet of the IP address.
+ * \param addr2 The third octet of the IP address.
+ * \param addr3 The forth octet of the IP address.
+ *
+ * \hideinitializer
+ */
+#define uip_ipaddr(addr, addr0,addr1,addr2,addr3) do { \
+                     ((u16_t *)(addr))[0] = HTONS(((addr0) &lt;&lt; 8) | (addr1)); \
+                     ((u16_t *)(addr))[1] = HTONS(((addr2) &lt;&lt; 8) | (addr3)); \
+                  } while(0)
+
+/**
+ * Construct an IPv6 address from eight 16-bit words.
+ *
+ * This function constructs an IPv6 address.
+ *
+ * \hideinitializer
+ */
+#define uip_ip6addr(addr, addr0,addr1,addr2,addr3,addr4,addr5,addr6,addr7) do { \
+                     ((u16_t *)(addr))[0] = HTONS((addr0)); \
+                     ((u16_t *)(addr))[1] = HTONS((addr1)); \
+                     ((u16_t *)(addr))[2] = HTONS((addr2)); \
+                     ((u16_t *)(addr))[3] = HTONS((addr3)); \
+                     ((u16_t *)(addr))[4] = HTONS((addr4)); \
+                     ((u16_t *)(addr))[5] = HTONS((addr5)); \
+                     ((u16_t *)(addr))[6] = HTONS((addr6)); \
+                     ((u16_t *)(addr))[7] = HTONS((addr7)); \
+                  } while(0)
+
+/**
+ * Copy an IP address to another IP address.
+ *
+ * Copies an IP address from one place to another.
+ *
+ * Example:
+ \code
+ uip_ipaddr_t ipaddr1, ipaddr2;
+
+ uip_ipaddr(&amp;ipaddr1, 192,16,1,2);
+ uip_ipaddr_copy(&amp;ipaddr2, &amp;ipaddr1);
+ \endcode
+ *
+ * \param dest The destination for the copy.
+ * \param src The source from where to copy.
+ *
+ * \hideinitializer
+ */
+#if !UIP_CONF_IPV6
+#define uip_ipaddr_copy(dest, src) do { \
+                     ((u16_t *)dest)[0] = ((u16_t *)src)[0]; \
+                     ((u16_t *)dest)[1] = ((u16_t *)src)[1]; \
+                  } while(0)
+#else /* !UIP_CONF_IPV6 */
+#define uip_ipaddr_copy(dest, src) memcpy(dest, src, sizeof(uip_ip6addr_t))
+#endif /* !UIP_CONF_IPV6 */
+
+/**
+ * Compare two IP addresses
+ *
+ * Compares two IP addresses.
+ *
+ * Example:
+ \code
+ uip_ipaddr_t ipaddr1, ipaddr2;
+
+ uip_ipaddr(&amp;ipaddr1, 192,16,1,2);
+ if(uip_ipaddr_cmp(&amp;ipaddr2, &amp;ipaddr1)) {
+    printf(&quot;They are the same&quot;);
+ }
+ \endcode
+ *
+ * \param addr1 The first IP address.
+ * \param addr2 The second IP address.
+ *
+ * \hideinitializer
+ */
+#if !UIP_CONF_IPV6
+#define uip_ipaddr_cmp(addr1, addr2) (((u16_t *)addr1)[0] == ((u16_t *)addr2)[0] &amp;&amp; \
+				      ((u16_t *)addr1)[1] == ((u16_t *)addr2)[1])
+#else /* !UIP_CONF_IPV6 */
+#define uip_ipaddr_cmp(addr1, addr2) (memcmp(addr1, addr2, sizeof(uip_ip6addr_t)) == 0)
+#endif /* !UIP_CONF_IPV6 */
+
+/**
+ * Compare two IP addresses with netmasks
+ *
+ * Compares two IP addresses with netmasks. The masks are used to mask
+ * out the bits that are to be compared.
+ *
+ * Example:
+ \code
+ uip_ipaddr_t ipaddr1, ipaddr2, mask;
+
+ uip_ipaddr(&amp;mask, 255,255,255,0);
+ uip_ipaddr(&amp;ipaddr1, 192,16,1,2);
+ uip_ipaddr(&amp;ipaddr2, 192,16,1,3);
+ if(uip_ipaddr_maskcmp(&amp;ipaddr1, &amp;ipaddr2, &amp;mask)) {
+    printf(&quot;They are the same&quot;);
+ }
+ \endcode
+ *
+ * \param addr1 The first IP address.
+ * \param addr2 The second IP address.
+ * \param mask The netmask.
+ *
+ * \hideinitializer
+ */
+#define uip_ipaddr_maskcmp(addr1, addr2, mask) \
+                          (((((u16_t *)addr1)[0] &amp; ((u16_t *)mask)[0]) == \
+                            (((u16_t *)addr2)[0] &amp; ((u16_t *)mask)[0])) &amp;&amp; \
+                           ((((u16_t *)addr1)[1] &amp; ((u16_t *)mask)[1]) == \
+                            (((u16_t *)addr2)[1] &amp; ((u16_t *)mask)[1])))
+
+
+/**
+ * Mask out the network part of an IP address.
+ *
+ * Masks out the network part of an IP address, given the address and
+ * the netmask.
+ *
+ * Example:
+ \code
+ uip_ipaddr_t ipaddr1, ipaddr2, netmask;
+
+ uip_ipaddr(&amp;ipaddr1, 192,16,1,2);
+ uip_ipaddr(&amp;netmask, 255,255,255,0);
+ uip_ipaddr_mask(&amp;ipaddr2, &amp;ipaddr1, &amp;netmask);
+ \endcode
+ *
+ * In the example above, the variable &quot;ipaddr2&quot; will contain the IP
+ * address 192.168.1.0.
+ *
+ * \param dest Where the result is to be placed.
+ * \param src The IP address.
+ * \param mask The netmask.
+ *
+ * \hideinitializer
+ */
+#define uip_ipaddr_mask(dest, src, mask) do { \
+                     ((u16_t *)dest)[0] = ((u16_t *)src)[0] &amp; ((u16_t *)mask)[0]; \
+                     ((u16_t *)dest)[1] = ((u16_t *)src)[1] &amp; ((u16_t *)mask)[1]; \
+                  } while(0)
+
+/**
+ * Pick the first octet of an IP address.
+ *
+ * Picks out the first octet of an IP address.
+ *
+ * Example:
+ \code
+ uip_ipaddr_t ipaddr;
+ u8_t octet;
+
+ uip_ipaddr(&amp;ipaddr, 1,2,3,4);
+ octet = uip_ipaddr1(&amp;ipaddr);
+ \endcode
+ *
+ * In the example above, the variable &quot;octet&quot; will contain the value 1.
+ *
+ * \hideinitializer
+ */
+#define uip_ipaddr1(addr) (htons(((u16_t *)(addr))[0]) &gt;&gt; 8)
+
+/**
+ * Pick the second octet of an IP address.
+ *
+ * Picks out the second octet of an IP address.
+ *
+ * Example:
+ \code
+ uip_ipaddr_t ipaddr;
+ u8_t octet;
+
+ uip_ipaddr(&amp;ipaddr, 1,2,3,4);
+ octet = uip_ipaddr2(&amp;ipaddr);
+ \endcode
+ *
+ * In the example above, the variable &quot;octet&quot; will contain the value 2.
+ *
+ * \hideinitializer
+ */
+#define uip_ipaddr2(addr) (htons(((u16_t *)(addr))[0]) &amp; 0xff)
+
+/**
+ * Pick the third octet of an IP address.
+ *
+ * Picks out the third octet of an IP address.
+ *
+ * Example:
+ \code
+ uip_ipaddr_t ipaddr;
+ u8_t octet;
+
+ uip_ipaddr(&amp;ipaddr, 1,2,3,4);
+ octet = uip_ipaddr3(&amp;ipaddr);
+ \endcode
+ *
+ * In the example above, the variable &quot;octet&quot; will contain the value 3.
+ *
+ * \hideinitializer
+ */
+#define uip_ipaddr3(addr) (htons(((u16_t *)(addr))[1]) &gt;&gt; 8)
+
+/**
+ * Pick the fourth octet of an IP address.
+ *
+ * Picks out the fourth octet of an IP address.
+ *
+ * Example:
+ \code
+ uip_ipaddr_t ipaddr;
+ u8_t octet;
+
+ uip_ipaddr(&amp;ipaddr, 1,2,3,4);
+ octet = uip_ipaddr4(&amp;ipaddr);
+ \endcode
+ *
+ * In the example above, the variable &quot;octet&quot; will contain the value 4.
+ *
+ * \hideinitializer
+ */
+#define uip_ipaddr4(addr) (htons(((u16_t *)(addr))[1]) &amp; 0xff)
+
+/**
+ * Convert 16-bit quantity from host byte order to network byte order.
+ *
+ * This macro is primarily used for converting constants from host
+ * byte order to network byte order. For converting variables to
+ * network byte order, use the htons() function instead.
+ *
+ * \hideinitializer
+ */
+#ifndef HTONS
+#   if UIP_BYTE_ORDER == UIP_BIG_ENDIAN
+#      define HTONS(n) (n)
+#   else /* UIP_BYTE_ORDER == UIP_BIG_ENDIAN */
+#      define HTONS(n) (u16_t)((((u16_t) (n)) &lt;&lt; 8) | (((u16_t) (n)) &gt;&gt; 8))
+#   endif /* UIP_BYTE_ORDER == UIP_BIG_ENDIAN */
+#else
+#error &quot;HTONS already defined!&quot;
+#endif /* HTONS */
+
+/**
+ * Convert 16-bit quantity from host byte order to network byte order.
+ *
+ * This function is primarily used for converting variables from host
+ * byte order to network byte order. For converting constants to
+ * network byte order, use the HTONS() macro instead.
+ */
+#ifndef htons
+u16_t htons(u16_t val);
+#endif /* htons */
+#ifndef ntohs
+#define ntohs htons
+#endif
+
+/** @} */
+
+/**
+ * Pointer to the application data in the packet buffer.
+ *
+ * This pointer points to the application data when the application is
+ * called. If the application wishes to send data, the application may
+ * use this space to write the data into before calling uip_send().
+ */
+extern void *uip_appdata;
+
+#if UIP_URGDATA &gt; 0
+/* u8_t *uip_urgdata:
+ *
+ * This pointer points to any urgent data that has been received. Only
+ * present if compiled with support for urgent data (UIP_URGDATA).
+ */
+extern void *uip_urgdata;
+#endif /* UIP_URGDATA &gt; 0 */
+
+
+/**
+ * \defgroup uipdrivervars Variables used in uIP device drivers
+ * @{
+ *
+ * uIP has a few global variables that are used in device drivers for
+ * uIP.
+ */
+
+/**
+ * The length of the packet in the uip_buf buffer.
+ *
+ * The global variable uip_len holds the length of the packet in the
+ * uip_buf buffer.
+ *
+ * When the network device driver calls the uIP input function,
+ * uip_len should be set to the length of the packet in the uip_buf
+ * buffer.
+ *
+ * When sending packets, the device driver should use the contents of
+ * the uip_len variable to determine the length of the outgoing
+ * packet.
+ *
+ */
+extern u16_t uip_len;
+
+/** @} */
+
+#if UIP_URGDATA &gt; 0
+extern u16_t uip_urglen, uip_surglen;
+#endif /* UIP_URGDATA &gt; 0 */
+
+
+#if UIP_TCP
+/**
+ * Representation of a uIP TCP connection.
+ *
+ * The uip_conn structure is used for identifying a connection. All
+ * but one field in the structure are to be considered read-only by an
+ * application. The only exception is the appstate field whos purpose
+ * is to let the application store application-specific state (e.g.,
+ * file pointers) for the connection. The type of this field is
+ * configured in the &quot;uipopt.h&quot; header file.
+ */
+struct uip_conn {
+  uip_ipaddr_t ripaddr;   /**&lt; The IP address of the remote host. */
+  
+  u16_t lport;        /**&lt; The local TCP port, in network byte order. */
+  u16_t rport;        /**&lt; The local remote TCP port, in network byte
+			 order. */
+  
+  u8_t rcv_nxt[4];    /**&lt; The sequence number that we expect to
+			 receive next. */
+  u8_t snd_nxt[4];    /**&lt; The sequence number that was last sent by
+                         us. */
+  u16_t len;          /**&lt; Length of the data that was previously sent. */
+  u16_t mss;          /**&lt; Current maximum segment size for the
+			 connection. */
+  u16_t initialmss;   /**&lt; Initial maximum segment size for the
+			 connection. */
+  u8_t sa;            /**&lt; Retransmission time-out calculation state
+			 variable. */
+  u8_t sv;            /**&lt; Retransmission time-out calculation state
+			 variable. */
+  u8_t rto;           /**&lt; Retransmission time-out. */
+  u8_t tcpstateflags; /**&lt; TCP state and flags. */
+  u8_t timer;         /**&lt; The retransmission timer. */
+  u8_t nrtx;          /**&lt; The number of retransmissions for the last
+			 segment sent. */
+
+  /** The application state. */
+  uip_tcp_appstate_t appstate;
+};
+
+
+/**
+ * Pointer to the current TCP connection.
+ *
+ * The uip_conn pointer can be used to access the current TCP
+ * connection.
+ */
+extern struct uip_conn *uip_conn;
+/* The array containing all uIP connections. */
+extern struct uip_conn uip_conns[UIP_CONNS];
+#endif /* UIP_TCP */
+/**
+ * \addtogroup uiparch
+ * @{
+ */
+
+/**
+ * 4-byte array used for the 32-bit sequence number calculations.
+ */
+#if UIP_TCP
+extern u8_t uip_acc32[4];
+#endif /* UIP_TCP */
+
+/** @} */
+
+
+#if UIP_UDP
+/**
+ * Representation of a uIP UDP connection.
+ */
+struct uip_udp_conn {
+  uip_ipaddr_t ripaddr;   /**&lt; The IP address of the remote peer. */
+  u16_t lport;        /**&lt; The local port number in network byte order. */
+  u16_t rport;        /**&lt; The remote port number in network byte order. */
+  u8_t  ttl;          /**&lt; Default time-to-live. */
+
+  /** The application state. */
+  uip_udp_appstate_t appstate;
+};
+
+/**
+ * The current UDP connection.
+ */
+extern struct uip_udp_conn *uip_udp_conn;
+extern struct uip_udp_conn uip_udp_conns[UIP_UDP_CONNS];
+#endif /* UIP_UDP */
+
+/**
+ * The structure holding the TCP/IP statistics that are gathered if
+ * UIP_STATISTICS is set to 1.
+ *
+ */
+struct uip_stats {
+  struct {
+    uip_stats_t drop;     /**&lt; Number of dropped packets at the IP
+			     layer. */
+    uip_stats_t recv;     /**&lt; Number of received packets at the IP
+			     layer. */
+    uip_stats_t sent;     /**&lt; Number of sent packets at the IP
+			     layer. */
+    uip_stats_t vhlerr;   /**&lt; Number of packets dropped due to wrong
+			     IP version or header length. */
+    uip_stats_t hblenerr; /**&lt; Number of packets dropped due to wrong
+			     IP length, high byte. */
+    uip_stats_t lblenerr; /**&lt; Number of packets dropped due to wrong
+			     IP length, low byte. */
+    uip_stats_t fragerr;  /**&lt; Number of packets dropped since they
+			     were IP fragments. */
+    uip_stats_t chkerr;   /**&lt; Number of packets dropped due to IP
+			     checksum errors. */
+    uip_stats_t protoerr; /**&lt; Number of packets dropped since they
+			     were neither ICMP, UDP nor TCP. */
+  } ip;                   /**&lt; IP statistics. */
+  struct {
+    uip_stats_t drop;     /**&lt; Number of dropped ICMP packets. */
+    uip_stats_t recv;     /**&lt; Number of received ICMP packets. */
+    uip_stats_t sent;     /**&lt; Number of sent ICMP packets. */
+    uip_stats_t typeerr;  /**&lt; Number of ICMP packets with a wrong
+			     type. */
+  } icmp;                 /**&lt; ICMP statistics. */
+#if UIP_TCP
+  struct {
+    uip_stats_t drop;     /**&lt; Number of dropped TCP segments. */
+    uip_stats_t recv;     /**&lt; Number of recived TCP segments. */
+    uip_stats_t sent;     /**&lt; Number of sent TCP segments. */
+    uip_stats_t chkerr;   /**&lt; Number of TCP segments with a bad
+			     checksum. */
+    uip_stats_t ackerr;   /**&lt; Number of TCP segments with a bad ACK
+			     number. */
+    uip_stats_t rst;      /**&lt; Number of recevied TCP RST (reset) segments. */
+    uip_stats_t rexmit;   /**&lt; Number of retransmitted TCP segments. */
+    uip_stats_t syndrop;  /**&lt; Number of dropped SYNs due to too few
+			     connections was avaliable. */
+    uip_stats_t synrst;   /**&lt; Number of SYNs for closed ports,
+			     triggering a RST. */
+  } tcp;                  /**&lt; TCP statistics. */
+#endif /* UIP_TCP */
+#if UIP_UDP
+  struct {
+    uip_stats_t drop;     /**&lt; Number of dropped UDP segments. */
+    uip_stats_t recv;     /**&lt; Number of recived UDP segments. */
+    uip_stats_t sent;     /**&lt; Number of sent UDP segments. */
+    uip_stats_t chkerr;   /**&lt; Number of UDP segments with a bad
+			     checksum. */
+  } udp;                  /**&lt; UDP statistics. */
+#endif /* UIP_UDP */
+};
+
+/**
+ * The uIP TCP/IP statistics.
+ *
+ * This is the variable in which the uIP TCP/IP statistics are gathered.
+ */
+extern struct uip_stats uip_stat;
+
+
+/*---------------------------------------------------------------------------*/
+/* All the stuff below this point is internal to uIP and should not be
+ * used directly by an application or by a device driver.
+ */
+/*---------------------------------------------------------------------------*/
+/* u8_t uip_flags:
+ *
+ * When the application is called, uip_flags will contain the flags
+ * that are defined in this file. Please read below for more
+ * infomation.
+ */
+extern u8_t uip_flags;
+
+/* The following flags may be set in the global variable uip_flags
+   before calling the application callback. The UIP_ACKDATA,
+   UIP_NEWDATA, and UIP_CLOSE flags may both be set at the same time,
+   whereas the others are mutualy exclusive. Note that these flags
+   should *NOT* be accessed directly, but only through the uIP
+   functions/macros. */
+
+#define UIP_ACKDATA   1     /* Signifies that the outstanding data was
+			       acked and the application should send
+			       out new data instead of retransmitting
+			       the last data. */
+#define UIP_NEWDATA   2     /* Flags the fact that the peer has sent
+			       us new data. */
+#define UIP_REXMIT    4     /* Tells the application to retransmit the
+			       data that was last sent. */
+#define UIP_POLL      8     /* Used for polling the application, to
+			       check if the application has data that
+			       it wants to send. */
+#define UIP_CLOSE     16    /* The remote host has closed the
+			       connection, thus the connection has
+			       gone away. Or the application signals
+			       that it wants to close the
+			       connection. */
+#define UIP_ABORT     32    /* The remote host has aborted the
+			       connection, thus the connection has
+			       gone away. Or the application signals
+			       that it wants to abort the
+			       connection. */
+#define UIP_CONNECTED 64    /* We have got a connection from a remote
+                               host and have set up a new connection
+                               for it, or an active connection has
+                               been successfully established. */
+
+#define UIP_TIMEDOUT  128   /* The connection has been aborted due to
+			       too many retransmissions. */
+
+/* uip_process(flag):
+ *
+ * The actual uIP function which does all the work.
+ */
+void uip_process(u8_t flag);
+
+/* The following flags are passed as an argument to the uip_process()
+   function. They are used to distinguish between the two cases where
+   uip_process() is called. It can be called either because we have
+   incoming data that should be processed, or because the periodic
+   timer has fired. These values are never used directly, but only in
+   the macrose defined in this file. */
+ 
+#define UIP_DATA          1     /* Tells uIP that there is incoming
+				   data in the uip_buf buffer. The
+				   length of the data is stored in the
+				   global variable uip_len. */
+#define UIP_TIMER         2     /* Tells uIP that the periodic timer
+				   has fired. */
+#define UIP_POLL_REQUEST  3     /* Tells uIP that a connection should
+				   be polled. */
+#define UIP_UDP_SEND_CONN 4     /* Tells uIP that a UDP datagram
+				   should be constructed in the
+				   uip_buf buffer. */
+#if UIP_UDP
+#define UIP_UDP_TIMER     5
+#endif /* UIP_UDP */
+
+/* The TCP states used in the uip_conn-&gt;tcpstateflags. */
+#define UIP_CLOSED      0
+#define UIP_SYN_RCVD    1
+#define UIP_SYN_SENT    2
+#define UIP_ESTABLISHED 3
+#define UIP_FIN_WAIT_1  4
+#define UIP_FIN_WAIT_2  5
+#define UIP_CLOSING     6
+#define UIP_TIME_WAIT   7
+#define UIP_LAST_ACK    8
+#define UIP_TS_MASK     15
+  
+#define UIP_STOPPED      16
+
+/* The TCP and IP headers. */
+struct uip_tcpip_hdr {
+#if UIP_CONF_IPV6
+  /* IPv6 header. */
+  u8_t vtc,
+    tcflow;
+  u16_t flow;
+  u8_t len[2];
+  u8_t proto, ttl;
+  uip_ip6addr_t srcipaddr, destipaddr;
+#else /* UIP_CONF_IPV6 */
+  /* IPv4 header. */
+  u8_t vhl,
+    tos,
+    len[2],
+    ipid[2],
+    ipoffset[2],
+    ttl,
+    proto;
+  u16_t ipchksum;
+  u16_t srcipaddr[2],
+    destipaddr[2];
+#endif /* UIP_CONF_IPV6 */
+  
+  /* TCP header. */
+  u16_t srcport,
+    destport;
+  u8_t seqno[4],
+    ackno[4],
+    tcpoffset,
+    flags,
+    wnd[2];
+  u16_t tcpchksum;
+  u8_t urgp[2];
+  u8_t optdata[4];
+} __attribute__ ((__packed__));
+
+/* The ICMP and IP headers. */
+struct uip_icmpip_hdr {
+#if UIP_CONF_IPV6
+  /* IPv6 header. */
+  u8_t vtc,
+    tcf;
+  u16_t flow;
+  u8_t len[2];
+  u8_t proto, ttl;
+  uip_ip6addr_t srcipaddr, destipaddr;
+#else /* UIP_CONF_IPV6 */
+  /* IPv4 header. */
+  u8_t vhl,
+    tos,
+    len[2],
+    ipid[2],
+    ipoffset[2],
+    ttl,
+    proto;
+  u16_t ipchksum;
+  u16_t srcipaddr[2],
+    destipaddr[2];
+#endif /* UIP_CONF_IPV6 */
+  
+  /* ICMP (echo) header. */
+  u8_t type, icode;
+  u16_t icmpchksum;
+#if !UIP_CONF_IPV6
+  u16_t id, seqno;
+#else /* !UIP_CONF_IPV6 */
+  u8_t flags, reserved1, reserved2, reserved3;
+  u8_t icmp6data[16];
+  u8_t options[1];
+#endif /* !UIP_CONF_IPV6 */
+};
+
+
+/* The UDP and IP headers. */
+struct uip_udpip_hdr {
+#if UIP_CONF_IPV6
+  /* IPv6 header. */
+  u8_t vtc,
+    tcf;
+  u16_t flow;
+  u8_t len[2];
+  u8_t proto, ttl;
+  uip_ip6addr_t srcipaddr, destipaddr;
+#else /* UIP_CONF_IPV6 */
+  /* IP header. */
+  u8_t vhl,
+    tos,
+    len[2],
+    ipid[2],
+    ipoffset[2],
+    ttl,
+    proto;
+  u16_t ipchksum;
+  u16_t srcipaddr[2],
+    destipaddr[2];
+#endif /* UIP_CONF_IPV6 */
+  
+  /* UDP header. */
+  u16_t srcport,
+    destport;
+  u16_t udplen;
+  u16_t udpchksum;
+};
+
+
+
+/**
+ * The buffer size available for user data in the \ref uip_buf buffer.
+ *
+ * This macro holds the available size for user data in the \ref
+ * uip_buf buffer. The macro is intended to be used for checking
+ * bounds of available user data.
+ *
+ * Example:
+ \code
+ snprintf(uip_appdata, UIP_APPDATA_SIZE, &quot;%u\n&quot;, i);
+ \endcode
+ *
+ * \hideinitializer
+ */
+#define UIP_APPDATA_SIZE (UIP_BUFSIZE - UIP_LLH_LEN - UIP_TCPIP_HLEN)
+
+
+#define UIP_PROTO_ICMP  1
+#define UIP_PROTO_TCP   6
+#define UIP_PROTO_UDP   17
+#define UIP_PROTO_ICMP6 58
+
+/* Header sizes. */
+#if UIP_CONF_IPV6
+#define UIP_IPH_LEN    40
+#else /* UIP_CONF_IPV6 */
+#define UIP_IPH_LEN    20    /* Size of IP header */
+#endif /* UIP_CONF_IPV6 */
+#define UIP_UDPH_LEN    8    /* Size of UDP header */
+#define UIP_TCPH_LEN   20    /* Size of TCP header */
+#define UIP_IPUDPH_LEN (UIP_UDPH_LEN + UIP_IPH_LEN)    /* Size of IP +
+							  UDP
+							  header */
+#define UIP_IPTCPH_LEN (UIP_TCPH_LEN + UIP_IPH_LEN)    /* Size of IP +
+							  TCP
+							  header */
+#define UIP_TCPIP_HLEN UIP_IPTCPH_LEN
+
+
+#if UIP_FIXEDADDR
+extern const uip_ipaddr_t uip_hostaddr, uip_netmask, uip_draddr;
+#else /* UIP_FIXEDADDR */
+extern uip_ipaddr_t uip_hostaddr, uip_netmask, uip_draddr;
+#endif /* UIP_FIXEDADDR */
+
+
+
+/**
+ * Representation of a 48-bit Ethernet address.
+ */
+struct uip_eth_addr {
+  u8_t addr[6];
+} __attribute__ ((__packed__));
+
+/**
+ * Calculate the Internet checksum over a buffer.
+ *
+ * The Internet checksum is the one's complement of the one's
+ * complement sum of all 16-bit words in the buffer.
+ *
+ * See RFC1071.
+ *
+ * \param buf A pointer to the buffer over which the checksum is to be
+ * computed.
+ *
+ * \param len The length of the buffer over which the checksum is to
+ * be computed.
+ *
+ * \return The Internet checksum of the buffer.
+ */
+u16_t uip_chksum(u16_t *buf, u16_t len);
+
+/**
+ * Calculate the IP header checksum of the packet header in uip_buf.
+ *
+ * The IP header checksum is the Internet checksum of the 20 bytes of
+ * the IP header.
+ *
+ * \return The IP header checksum of the IP header in the uip_buf
+ * buffer.
+ */
+u16_t uip_ipchksum(void);
+
+/**
+ * Calculate the TCP checksum of the packet in uip_buf and uip_appdata.
+ *
+ * The TCP checksum is the Internet checksum of data contents of the
+ * TCP segment, and a pseudo-header as defined in RFC793.
+ *
+ * \return The TCP checksum of the TCP segment in uip_buf and pointed
+ * to by uip_appdata.
+ */
+u16_t uip_tcpchksum(void);
+
+/**
+ * Calculate the UDP checksum of the packet in uip_buf and uip_appdata.
+ *
+ * The UDP checksum is the Internet checksum of data contents of the
+ * UDP segment, and a pseudo-header as defined in RFC768.
+ *
+ * \return The UDP checksum of the UDP segment in uip_buf and pointed
+ * to by uip_appdata.
+ */
+u16_t uip_udpchksum(void);
+
+
+#endif /* __UIP_H__ */
+
+
+/** @} */

Added: trunk/src/uip/uip_arch.h
===================================================================
--- trunk/src/uip/uip_arch.h	2008-09-10 18:59:17 UTC (rev 88)
+++ trunk/src/uip/uip_arch.h	2008-09-15 21:54:14 UTC (rev 89)
@@ -0,0 +1,138 @@
+/**
+ * \addtogroup uip
+ * {@
+ */
+
+/**
+ * \defgroup uiparch Architecture specific uIP functions
+ * @{
+ *
+ * The functions in the architecture specific module implement the IP
+ * check sum and 32-bit additions.
+ *
+ * The IP checksum calculation is the most computationally expensive
+ * operation in the TCP/IP stack and it therefore pays off to
+ * implement this in efficient assembler. The purpose of the uip-arch
+ * module is to let the checksum functions to be implemented in
+ * architecture specific assembler.
+ *
+ */
+
+/**
+ * \file
+ * Declarations of architecture specific functions.
+ * \author Adam Dunkels &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">adam at dunkels.com</A>&gt;
+ */
+
+/*
+ * Copyright (c) 2001, Adam Dunkels.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote
+ *    products derived from this software without specific prior
+ *    written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * This file is part of the uIP TCP/IP stack.
+ *
+ * $Id: uip_arch.h,v 1.2 2006/06/07 09:15:19 adam Exp $
+ *
+ */
+
+#ifndef __UIP_ARCH_H__
+#define __UIP_ARCH_H__
+
+#include &quot;uip.h&quot;
+
+/**
+ * Carry out a 32-bit addition.
+ *
+ * Because not all architectures for which uIP is intended has native
+ * 32-bit arithmetic, uIP uses an external C function for doing the
+ * required 32-bit additions in the TCP protocol processing. This
+ * function should add the two arguments and place the result in the
+ * global variable uip_acc32.
+ *
+ * \note The 32-bit integer pointed to by the op32 parameter and the
+ * result in the uip_acc32 variable are in network byte order (big
+ * endian).
+ *
+ * \param op32 A pointer to a 4-byte array representing a 32-bit
+ * integer in network byte order (big endian).
+ *
+ * \param op16 A 16-bit integer in host byte order.
+ */
+void uip_add32(u8_t *op32, u16_t op16);
+
+/**
+ * Calculate the Internet checksum over a buffer.
+ *
+ * The Internet checksum is the one's complement of the one's
+ * complement sum of all 16-bit words in the buffer.
+ *
+ * See RFC1071.
+ *
+ * \note This function is not called in the current version of uIP,
+ * but future versions might make use of it.
+ *
+ * \param buf A pointer to the buffer over which the checksum is to be
+ * computed.
+ *
+ * \param len The length of the buffer over which the checksum is to
+ * be computed.
+ *
+ * \return The Internet checksum of the buffer.
+ */
+u16_t uip_chksum(u16_t *buf, u16_t len);
+
+/**
+ * Calculate the IP header checksum of the packet header in uip_buf.
+ *
+ * The IP header checksum is the Internet checksum of the 20 bytes of
+ * the IP header.
+ *
+ * \return The IP header checksum of the IP header in the uip_buf
+ * buffer.
+ */
+u16_t uip_ipchksum(void);
+
+/**
+ * Calculate the TCP checksum of the packet in uip_buf and uip_appdata.
+ *
+ * The TCP checksum is the Internet checksum of data contents of the
+ * TCP segment, and a pseudo-header as defined in RFC793.
+ *
+ * \note The uip_appdata pointer that points to the packet data may
+ * point anywhere in memory, so it is not possible to simply calculate
+ * the Internet checksum of the contents of the uip_buf buffer.
+ *
+ * \return The TCP checksum of the TCP segment in uip_buf and pointed
+ * to by uip_appdata.
+ */
+u16_t uip_tcpchksum(void);
+
+u16_t uip_udpchksum(void);
+
+/** @} */
+/** @} */
+
+#endif /* __UIP_ARCH_H__ */

Added: trunk/src/uip/uip_arp.c
===================================================================
--- trunk/src/uip/uip_arp.c	2008-09-10 18:59:17 UTC (rev 88)
+++ trunk/src/uip/uip_arp.c	2008-09-15 21:54:14 UTC (rev 89)
@@ -0,0 +1,428 @@
+#include &quot;build.h&quot;
+#ifdef BUILD_UIP
+
+/**
+ * \addtogroup uip
+ * @{
+ */
+
+/**
+ * \defgroup uiparp uIP Address Resolution Protocol
+ * @{
+ *
+ * The Address Resolution Protocol ARP is used for mapping between IP
+ * addresses and link level addresses such as the Ethernet MAC
+ * addresses. ARP uses broadcast queries to ask for the link level
+ * address of a known IP address and the host which is configured with
+ * the IP address for which the query was meant, will respond with its
+ * link level address.
+ *
+ * \note This ARP implementation only supports Ethernet.
+ */
+ 
+/**
+ * \file
+ * Implementation of the ARP Address Resolution Protocol.
+ * \author Adam Dunkels &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">adam at dunkels.com</A>&gt;
+ *
+ */
+
+/*
+ * Copyright (c) 2001-2003, Adam Dunkels.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote
+ *    products derived from this software without specific prior
+ *    written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * This file is part of the uIP TCP/IP stack.
+ *
+ * $Id: uip_arp.c,v 1.8 2006/06/02 23:36:21 adam Exp $
+ *
+ */
+
+
+#include &quot;uip_arp.h&quot;
+
+#include &lt;string.h&gt;
+
+struct arp_hdr {
+  struct uip_eth_hdr ethhdr;
+  u16_t hwtype;
+  u16_t protocol;
+  u8_t hwlen;
+  u8_t protolen;
+  u16_t opcode;
+  struct uip_eth_addr shwaddr;
+  u16_t sipaddr[2];
+  struct uip_eth_addr dhwaddr;
+  u16_t dipaddr[2];
+};
+
+struct ethip_hdr {
+  struct uip_eth_hdr ethhdr;
+  /* IP header. */
+  u8_t vhl,
+    tos,
+    len[2],
+    ipid[2],
+    ipoffset[2],
+    ttl,
+    proto;
+  u16_t ipchksum;
+  u16_t srcipaddr[2],
+    destipaddr[2];
+};
+
+#define ARP_REQUEST 1
+#define ARP_REPLY   2
+
+#define ARP_HWTYPE_ETH 1
+
+struct arp_entry {
+  u16_t ipaddr[2];
+  struct uip_eth_addr ethaddr;
+  u8_t time;
+};
+
+static const struct uip_eth_addr broadcast_ethaddr =
+  {{0xff,0xff,0xff,0xff,0xff,0xff}};
+static const u16_t broadcast_ipaddr[2] = {0xffff,0xffff};
+
+static struct arp_entry arp_table[UIP_ARPTAB_SIZE];
+static u16_t ipaddr[2];
+static u8_t i, c;
+
+static u8_t arptime;
+static u8_t tmpage;
+
+#define BUF   ((struct arp_hdr *)&amp;uip_buf[0])
+#define IPBUF ((struct ethip_hdr *)&amp;uip_buf[0])
+/*-----------------------------------------------------------------------------------*/
+/**
+ * Initialize the ARP module.
+ *
+ */
+/*-----------------------------------------------------------------------------------*/
+void
+uip_arp_init(void)
+{
+  for(i = 0; i &lt; UIP_ARPTAB_SIZE; ++i) {
+    memset(arp_table[i].ipaddr, 0, 4);
+  }
+}
+/*-----------------------------------------------------------------------------------*/
+/**
+ * Periodic ARP processing function.
+ *
+ * This function performs periodic timer processing in the ARP module
+ * and should be called at regular intervals. The recommended interval
+ * is 10 seconds between the calls.
+ *
+ */
+/*-----------------------------------------------------------------------------------*/
+void
+uip_arp_timer(void)
+{
+  struct arp_entry *tabptr;
+  
+  ++arptime;
+  for(i = 0; i &lt; UIP_ARPTAB_SIZE; ++i) {
+    tabptr = &amp;arp_table[i];
+    if((tabptr-&gt;ipaddr[0] | tabptr-&gt;ipaddr[1]) != 0 &amp;&amp;
+       arptime - tabptr-&gt;time &gt;= UIP_ARP_MAXAGE) {
+      memset(tabptr-&gt;ipaddr, 0, 4);
+    }
+  }
+
+}
+/*-----------------------------------------------------------------------------------*/
+static void
+uip_arp_update(u16_t *ipaddr, struct uip_eth_addr *ethaddr)
+{
+  register struct arp_entry *tabptr;
+  /* Walk through the ARP mapping table and try to find an entry to
+     update. If none is found, the IP -&gt; MAC address mapping is
+     inserted in the ARP table. */
+  for(i = 0; i &lt; UIP_ARPTAB_SIZE; ++i) {
+
+    tabptr = &amp;arp_table[i];
+    /* Only check those entries that are actually in use. */
+    if(tabptr-&gt;ipaddr[0] != 0 &amp;&amp;
+       tabptr-&gt;ipaddr[1] != 0) {
+
+      /* Check if the source IP address of the incoming packet matches
+         the IP address in this ARP table entry. */
+      if(ipaddr[0] == tabptr-&gt;ipaddr[0] &amp;&amp;
+	 ipaddr[1] == tabptr-&gt;ipaddr[1]) {
+	 
+	/* An old entry found, update this and return. */
+	memcpy(tabptr-&gt;ethaddr.addr, ethaddr-&gt;addr, 6);
+	tabptr-&gt;time = arptime;
+
+	return;
+      }
+    }
+  }
+
+  /* If we get here, no existing ARP table entry was found, so we
+     create one. */
+
+  /* First, we try to find an unused entry in the ARP table. */
+  for(i = 0; i &lt; UIP_ARPTAB_SIZE; ++i) {
+    tabptr = &amp;arp_table[i];
+    if(tabptr-&gt;ipaddr[0] == 0 &amp;&amp;
+       tabptr-&gt;ipaddr[1] == 0) {
+      break;
+    }
+  }
+
+  /* If no unused entry is found, we try to find the oldest entry and
+     throw it away. */
+  if(i == UIP_ARPTAB_SIZE) {
+    tmpage = 0;
+    c = 0;
+    for(i = 0; i &lt; UIP_ARPTAB_SIZE; ++i) {
+      tabptr = &amp;arp_table[i];
+      if(arptime - tabptr-&gt;time &gt; tmpage) {
+	tmpage = arptime - tabptr-&gt;time;
+	c = i;
+      }
+    }
+    i = c;
+    tabptr = &amp;arp_table[i];
+  }
+
+  /* Now, i is the ARP table entry which we will fill with the new
+     information. */
+  memcpy(tabptr-&gt;ipaddr, ipaddr, 4);
+  memcpy(tabptr-&gt;ethaddr.addr, ethaddr-&gt;addr, 6);
+  tabptr-&gt;time = arptime;
+}
+/*-----------------------------------------------------------------------------------*/
+/**
+ * ARP processing for incoming IP packets
+ *
+ * This function should be called by the device driver when an IP
+ * packet has been received. The function will check if the address is
+ * in the ARP cache, and if so the ARP cache entry will be
+ * refreshed. If no ARP cache entry was found, a new one is created.
+ *
+ * This function expects an IP packet with a prepended Ethernet header
+ * in the uip_buf[] buffer, and the length of the packet in the global
+ * variable uip_len.
+ */
+/*-----------------------------------------------------------------------------------*/
+#if 0
+void
+uip_arp_ipin(void)
+{
+  uip_len -= sizeof(struct uip_eth_hdr);
+	
+  /* Only insert/update an entry if the source IP address of the
+     incoming IP packet comes from a host on the local network. */
+  if((IPBUF-&gt;srcipaddr[0] &amp; uip_netmask[0]) !=
+     (uip_hostaddr[0] &amp; uip_netmask[0])) {
+    return;
+  }
+  if((IPBUF-&gt;srcipaddr[1] &amp; uip_netmask[1]) !=
+     (uip_hostaddr[1] &amp; uip_netmask[1])) {
+    return;
+  }
+  uip_arp_update(IPBUF-&gt;srcipaddr, &amp;(IPBUF-&gt;ethhdr.src));
+  
+  return;
+}
+#endif /* 0 */
+/*-----------------------------------------------------------------------------------*/
+/**
+ * ARP processing for incoming ARP packets.
+ *
+ * This function should be called by the device driver when an ARP
+ * packet has been received. The function will act differently
+ * depending on the ARP packet type: if it is a reply for a request
+ * that we previously sent out, the ARP cache will be filled in with
+ * the values from the ARP reply. If the incoming ARP packet is an ARP
+ * request for our IP address, an ARP reply packet is created and put
+ * into the uip_buf[] buffer.
+ *
+ * When the function returns, the value of the global variable uip_len
+ * indicates whether the device driver should send out a packet or
+ * not. If uip_len is zero, no packet should be sent. If uip_len is
+ * non-zero, it contains the length of the outbound packet that is
+ * present in the uip_buf[] buffer.
+ *
+ * This function expects an ARP packet with a prepended Ethernet
+ * header in the uip_buf[] buffer, and the length of the packet in the
+ * global variable uip_len.
+ */
+/*-----------------------------------------------------------------------------------*/
+void
+uip_arp_arpin(void)
+{
+  
+  if(uip_len &lt; sizeof(struct arp_hdr)) {
+    uip_len = 0;
+    return;
+  }
+  uip_len = 0;
+  
+  switch(BUF-&gt;opcode) {
+  case HTONS(ARP_REQUEST):
+    /* ARP request. If it asked for our address, we send out a
+       reply. */
+    if(uip_ipaddr_cmp(BUF-&gt;dipaddr, uip_hostaddr)) {
+      /* First, we register the one who made the request in our ARP
+	 table, since it is likely that we will do more communication
+	 with this host in the future. */
+      uip_arp_update(BUF-&gt;sipaddr, &amp;BUF-&gt;shwaddr);
+      
+      /* The reply opcode is 2. */
+      BUF-&gt;opcode = HTONS(2);
+
+      memcpy(BUF-&gt;dhwaddr.addr, BUF-&gt;shwaddr.addr, 6);
+      memcpy(BUF-&gt;shwaddr.addr, uip_ethaddr.addr, 6);
+      memcpy(BUF-&gt;ethhdr.src.addr, uip_ethaddr.addr, 6);
+      memcpy(BUF-&gt;ethhdr.dest.addr, BUF-&gt;dhwaddr.addr, 6);
+      
+      BUF-&gt;dipaddr[0] = BUF-&gt;sipaddr[0];
+      BUF-&gt;dipaddr[1] = BUF-&gt;sipaddr[1];
+      BUF-&gt;sipaddr[0] = uip_hostaddr[0];
+      BUF-&gt;sipaddr[1] = uip_hostaddr[1];
+
+      BUF-&gt;ethhdr.type = HTONS(UIP_ETHTYPE_ARP);
+      uip_len = sizeof(struct arp_hdr);
+    }
+    break;
+  case HTONS(ARP_REPLY):
+    /* ARP reply. We insert or update the ARP table if it was meant
+       for us. */
+    if(uip_ipaddr_cmp(BUF-&gt;dipaddr, uip_hostaddr)) {
+      uip_arp_update(BUF-&gt;sipaddr, &amp;BUF-&gt;shwaddr);
+    }
+    break;
+  }
+
+  return;
+}
+/*-----------------------------------------------------------------------------------*/
+/**
+ * Prepend Ethernet header to an outbound IP packet and see if we need
+ * to send out an ARP request.
+ *
+ * This function should be called before sending out an IP packet. The
+ * function checks the destination IP address of the IP packet to see
+ * what Ethernet MAC address that should be used as a destination MAC
+ * address on the Ethernet.
+ *
+ * If the destination IP address is in the local network (determined
+ * by logical ANDing of netmask and our IP address), the function
+ * checks the ARP cache to see if an entry for the destination IP
+ * address is found. If so, an Ethernet header is prepended and the
+ * function returns. If no ARP cache entry is found for the
+ * destination IP address, the packet in the uip_buf[] is replaced by
+ * an ARP request packet for the IP address. The IP packet is dropped
+ * and it is assumed that they higher level protocols (e.g., TCP)
+ * eventually will retransmit the dropped packet.
+ *
+ * If the destination IP address is not on the local network, the IP
+ * address of the default router is used instead.
+ *
+ * When the function returns, a packet is present in the uip_buf[]
+ * buffer, and the length of the packet is in the global variable
+ * uip_len.
+ */
+/*-----------------------------------------------------------------------------------*/
+void
+uip_arp_out(void)
+{
+  struct arp_entry *tabptr;
+  
+  /* Find the destination IP address in the ARP table and construct
+     the Ethernet header. If the destination IP addres isn't on the
+     local network, we use the default router's IP address instead.
+
+     If not ARP table entry is found, we overwrite the original IP
+     packet with an ARP request for the IP address. */
+
+  /* First check if destination is a local broadcast. */
+  if(uip_ipaddr_cmp(IPBUF-&gt;destipaddr, broadcast_ipaddr)) {
+    memcpy(IPBUF-&gt;ethhdr.dest.addr, broadcast_ethaddr.addr, 6);
+  } else {
+    /* Check if the destination address is on the local network. */
+    if(!uip_ipaddr_maskcmp(IPBUF-&gt;destipaddr, uip_hostaddr, uip_netmask)) {
+      /* Destination address was not on the local network, so we need to
+	 use the default router's IP address instead of the destination
+	 address when determining the MAC address. */
+      uip_ipaddr_copy(ipaddr, uip_draddr);
+    } else {
+      /* Else, we use the destination IP address. */
+      uip_ipaddr_copy(ipaddr, IPBUF-&gt;destipaddr);
+    }
+      
+    for(i = 0; i &lt; UIP_ARPTAB_SIZE; ++i) {
+      tabptr = &amp;arp_table[i];
+      if(uip_ipaddr_cmp(ipaddr, tabptr-&gt;ipaddr)) {
+	break;
+      }
+    }
+
+    if(i == UIP_ARPTAB_SIZE) {
+      /* The destination address was not in our ARP table, so we
+	 overwrite the IP packet with an ARP request. */
+
+      memset(BUF-&gt;ethhdr.dest.addr, 0xff, 6);
+      memset(BUF-&gt;dhwaddr.addr, 0x00, 6);
+      memcpy(BUF-&gt;ethhdr.src.addr, uip_ethaddr.addr, 6);
+      memcpy(BUF-&gt;shwaddr.addr, uip_ethaddr.addr, 6);
+    
+      uip_ipaddr_copy(BUF-&gt;dipaddr, ipaddr);
+      uip_ipaddr_copy(BUF-&gt;sipaddr, uip_hostaddr);
+      BUF-&gt;opcode = HTONS(ARP_REQUEST); /* ARP request. */
+      BUF-&gt;hwtype = HTONS(ARP_HWTYPE_ETH);
+      BUF-&gt;protocol = HTONS(UIP_ETHTYPE_IP);
+      BUF-&gt;hwlen = 6;
+      BUF-&gt;protolen = 4;
+      BUF-&gt;ethhdr.type = HTONS(UIP_ETHTYPE_ARP);
+
+      uip_appdata = &amp;uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN];
+    
+      uip_len = sizeof(struct arp_hdr);
+      return;
+    }
+
+    /* Build an ethernet header. */
+    memcpy(IPBUF-&gt;ethhdr.dest.addr, tabptr-&gt;ethaddr.addr, 6);
+  }
+  memcpy(IPBUF-&gt;ethhdr.src.addr, uip_ethaddr.addr, 6);
+  
+  IPBUF-&gt;ethhdr.type = HTONS(UIP_ETHTYPE_IP);
+
+  uip_len += sizeof(struct uip_eth_hdr);
+}
+/*-----------------------------------------------------------------------------------*/
+
+/** @} */
+/** @} */
+
+#endif // #ifdef BUILD_UIP

Added: trunk/src/uip/uip_arp.h
===================================================================
--- trunk/src/uip/uip_arp.h	2008-09-10 18:59:17 UTC (rev 88)
+++ trunk/src/uip/uip_arp.h	2008-09-15 21:54:14 UTC (rev 89)
@@ -0,0 +1,144 @@
+/**
+ * \addtogroup uip
+ * @{
+ */
+
+/**
+ * \addtogroup uiparp
+ * @{
+ */
+ 
+/**
+ * \file
+ * Macros and definitions for the ARP module.
+ * \author Adam Dunkels &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">adam at dunkels.com</A>&gt;
+ */
+  
+
+/*
+ * Copyright (c) 2001-2003, Adam Dunkels.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote
+ *    products derived from this software without specific prior
+ *    written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * This file is part of the uIP TCP/IP stack.
+ *
+ * $Id: uip_arp.h,v 1.5 2006/06/11 21:46:39 adam Exp $
+ *
+ */
+
+#ifndef __UIP_ARP_H__
+#define __UIP_ARP_H__
+
+#include &quot;uip.h&quot;
+
+
+extern struct uip_eth_addr uip_ethaddr;
+
+/**
+ * The Ethernet header.
+ */
+struct uip_eth_hdr {
+  struct uip_eth_addr dest;
+  struct uip_eth_addr src;
+  u16_t type;
+} __attribute__ ((__packed__));
+
+#define UIP_ETHTYPE_ARP 0x0806
+#define UIP_ETHTYPE_IP  0x0800
+#define UIP_ETHTYPE_IP6 0x86dd
+
+
+/* The uip_arp_init() function must be called before any of the other
+   ARP functions. */
+void uip_arp_init(void);
+
+/* The uip_arp_ipin() function should be called whenever an IP packet
+   arrives from the Ethernet. This function refreshes the ARP table or
+   inserts a new mapping if none exists. The function assumes that an
+   IP packet with an Ethernet header is present in the uip_buf buffer
+   and that the length of the packet is in the uip_len variable. */
+/*void uip_arp_ipin(void);*/
+#define uip_arp_ipin()
+
+/* The uip_arp_arpin() should be called when an ARP packet is received
+   by the Ethernet driver. This function also assumes that the
+   Ethernet frame is present in the uip_buf buffer. When the
+   uip_arp_arpin() function returns, the contents of the uip_buf
+   buffer should be sent out on the Ethernet if the uip_len variable
+   is &gt; 0. */
+void uip_arp_arpin(void);
+
+/* The uip_arp_out() function should be called when an IP packet
+   should be sent out on the Ethernet. This function creates an
+   Ethernet header before the IP header in the uip_buf buffer. The
+   Ethernet header will have the correct Ethernet MAC destination
+   address filled in if an ARP table entry for the destination IP
+   address (or the IP address of the default router) is present. If no
+   such table entry is found, the IP packet is overwritten with an ARP
+   request and we rely on TCP to retransmit the packet that was
+   overwritten. In any case, the uip_len variable holds the length of
+   the Ethernet frame that should be transmitted. */
+void uip_arp_out(void);
+
+/* The uip_arp_timer() function should be called every ten seconds. It
+   is responsible for flushing old entries in the ARP table. */
+void uip_arp_timer(void);
+
+/** @} */
+
+/**
+ * \addtogroup uipconffunc
+ * @{
+ */
+
+
+/**
+ * Specifiy the Ethernet MAC address.
+ *
+ * The ARP code needs to know the MAC address of the Ethernet card in
+ * order to be able to respond to ARP queries and to generate working
+ * Ethernet headers.
+ *
+ * \note This macro only specifies the Ethernet MAC address to the ARP
+ * code. It cannot be used to change the MAC address of the Ethernet
+ * card.
+ *
+ * \param eaddr A pointer to a struct uip_eth_addr containing the
+ * Ethernet MAC address of the Ethernet card.
+ *
+ * \hideinitializer
+ */
+#define uip_setethaddr(eaddr) do {uip_ethaddr.addr[0] = eaddr.addr[0]; \
+                              uip_ethaddr.addr[1] = eaddr.addr[1];\
+                              uip_ethaddr.addr[2] = eaddr.addr[2];\
+                              uip_ethaddr.addr[3] = eaddr.addr[3];\
+                              uip_ethaddr.addr[4] = eaddr.addr[4];\
+                              uip_ethaddr.addr[5] = eaddr.addr[5];} while(0)
+
+/** @} */
+/** @} */
+
+#endif /* __UIP_ARP_H__ */

Added: trunk/src/uip/uiplib.c
===================================================================
--- trunk/src/uip/uiplib.c	2008-09-10 18:59:17 UTC (rev 88)
+++ trunk/src/uip/uiplib.c	2008-09-15 21:54:14 UTC (rev 89)
@@ -0,0 +1,79 @@
+#include &quot;build.h&quot;
+#ifdef BUILD_UIP
+
+/*
+ * Copyright (c) 2004, Adam Dunkels and the Swedish Institute of
+ * Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote
+ *    products derived from this software without specific prior
+ *    written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * This file is part of the uIP TCP/IP stack
+ *
+ * $Id: uiplib.c,v 1.2 2006/06/12 08:00:31 adam Exp $
+ *
+ */
+
+
+#include &quot;uip.h&quot;
+#include &quot;uiplib.h&quot;
+
+
+/*-----------------------------------------------------------------------------------*/
+unsigned char
+uiplib_ipaddrconv(char *addrstr, unsigned char *ipaddr)
+{
+  unsigned char tmp;
+  char c;
+  unsigned char i, j;
+
+  tmp = 0;
+  
+  for(i = 0; i &lt; 4; ++i) {
+    j = 0;
+    do {
+      c = *addrstr;
+      ++j;
+      if(j &gt; 4) {
+	return 0;
+      }
+      if(c == '.' || c == 0) {
+	*ipaddr = tmp;
+	++ipaddr;
+	tmp = 0;
+      } else if(c &gt;= '0' &amp;&amp; c &lt;= '9') {
+	tmp = (tmp * 10) + (c - '0');
+      } else {
+	return 0;
+      }
+      ++addrstr;
+    } while(c != '.' &amp;&amp; c != 0);
+  }
+  return 1;
+}
+
+/*-----------------------------------------------------------------------------------*/
+
+#endif // #ifdef BUILD_UIP

Added: trunk/src/uip/uiplib.h
===================================================================
--- trunk/src/uip/uiplib.h	2008-09-10 18:59:17 UTC (rev 88)
+++ trunk/src/uip/uiplib.h	2008-09-15 21:54:14 UTC (rev 89)
@@ -0,0 +1,71 @@
+/**
+ * \file
+ * Various uIP library functions.
+ * \author
+ * Adam Dunkels &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">adam at sics.se</A>&gt;
+ *
+ */
+
+/*
+ * Copyright (c) 2002, Adam Dunkels.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above
+ *    copyright notice, this list of conditions and the following
+ *    disclaimer in the documentation and/or other materials provided
+ *    with the distribution.
+ * 3. The name of the author may not be used to endorse or promote
+ *    products derived from this software without specific prior
+ *    written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * This file is part of the uIP TCP/IP stack
+ *
+ * $Id: uiplib.h,v 1.1 2006/06/07 09:15:19 adam Exp $
+ *
+ */
+#ifndef __UIPLIB_H__
+#define __UIPLIB_H__
+
+/**
+ * \addtogroup uipconvfunc
+ * @{
+ */
+
+/**
+ * Convert a textual representation of an IP address to a numerical representation.
+ *
+ * This function takes a textual representation of an IP address in
+ * the form a.b.c.d and converts it into a 4-byte array that can be
+ * used by other uIP functions.
+ *
+ * \param addrstr A pointer to a string containing the IP address in
+ * textual form.
+ *
+ * \param addr A pointer to a 4-byte array that will be filled in with
+ * the numerical representation of the address.
+ *
+ * \retval 0 If the IP address could not be parsed.
+ * \retval Non-zero If the IP address was parsed.
+ */
+unsigned char uiplib_ipaddrconv(char *addrstr, unsigned char *addr);
+
+/** @} */
+
+#endif /* __UIPLIB_H__ */

Added: trunk/src/uip/uipopt.h
===================================================================
--- trunk/src/uip/uipopt.h	2008-09-10 18:59:17 UTC (rev 88)
+++ trunk/src/uip/uipopt.h	2008-09-15 21:54:14 UTC (rev 89)
@@ -0,0 +1,550 @@
+/**
+ * \defgroup uipopt Configuration options for uIP
+ * @{
+ *
+ * uIP is configured using the per-project configuration file
+ * uipopt.h. This file contains all compile-time options for uIP and
+ * should be tweaked to match each specific project. The uIP
+ * distribution contains a documented example &quot;uipopt.h&quot; that can be
+ * copied and modified for each project.
+ *
+ * \note Most of the configuration options in the uipopt.h should not
+ * be changed, but rather the per-project uip-conf.h file.
+ */
+
+/**
+ * \file
+ * Configuration options for uIP.
+ * \author Adam Dunkels &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">adam at dunkels.com</A>&gt;
+ *
+ * This file is used for tweaking various configuration options for
+ * uIP. You should make a copy of this file into one of your project's
+ * directories instead of editing this example &quot;uipopt.h&quot; file that
+ * comes with the uIP distribution.
+ */
+
+/*
+ * Copyright (c) 2001-2003, Adam Dunkels.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote
+ *    products derived from this software without specific prior
+ *    written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * This file is part of the uIP TCP/IP stack.
+ *
+ * $Id: uipopt.h,v 1.4 2006/06/12 08:00:31 adam Exp $
+ *
+ */
+
+#ifndef __UIPOPT_H__
+#define __UIPOPT_H__
+
+#ifndef UIP_LITTLE_ENDIAN
+#define UIP_LITTLE_ENDIAN  3412
+#endif /* UIP_LITTLE_ENDIAN */
+#ifndef UIP_BIG_ENDIAN
+#define UIP_BIG_ENDIAN     1234
+#endif /* UIP_BIG_ENDIAN */
+
+#include &quot;uip-conf.h&quot;
+
+/*------------------------------------------------------------------------------*/
+
+/**
+ * \name Static configuration options
+ * @{
+ *
+ * These configuration options can be used for setting the IP address
+ * settings statically, but only if UIP_FIXEDADDR is set to 1. The
+ * configuration options for a specific node includes IP address,
+ * netmask and default router as well as the Ethernet address. The
+ * netmask, default router and Ethernet address are appliciable only
+ * if uIP should be run over Ethernet.
+ *
+ * All of these should be changed to suit your project.
+*/
+
+/**
+ * Determines if uIP should use a fixed IP address or not.
+ *
+ * If uIP should use a fixed IP address, the settings are set in the
+ * uipopt.h file. If not, the macros uip_sethostaddr(),
+ * uip_setdraddr() and uip_setnetmask() should be used instead.
+ *
+ * \hideinitializer
+ */
+#define UIP_FIXEDADDR    0
+
+/**
+ * Ping IP address asignment.
+ *
+ * uIP uses a &quot;ping&quot; packets for setting its own IP address if this
+ * option is set. If so, uIP will start with an empty IP address and
+ * the destination IP address of the first incoming &quot;ping&quot; (ICMP echo)
+ * packet will be used for setting the hosts IP address.
+ *
+ * \note This works only if UIP_FIXEDADDR is 0.
+ *
+ * \hideinitializer
+ */
+#ifdef UIP_CONF_PINGADDRCONF
+#define UIP_PINGADDRCONF UIP_CONF_PINGADDRCONF
+#else /* UIP_CONF_PINGADDRCONF */
+#define UIP_PINGADDRCONF 0
+#endif /* UIP_CONF_PINGADDRCONF */
+
+
+/**
+ * Specifies if the uIP ARP module should be compiled with a fixed
+ * Ethernet MAC address or not.
+ *
+ * If this configuration option is 0, the macro uip_setethaddr() can
+ * be used to specify the Ethernet address at run-time.
+ *
+ * \hideinitializer
+ */
+#define UIP_FIXEDETHADDR 0
+
+/** @} */
+/*------------------------------------------------------------------------------*/
+/**
+ * \name IP configuration options
+ * @{
+ *
+ */
+/**
+ * The IP TTL (time to live) of IP packets sent by uIP.
+ *
+ * This should normally not be changed.
+ */
+#define UIP_TTL         64
+
+/**
+ * Turn on support for IP packet reassembly.
+ *
+ * uIP supports reassembly of fragmented IP packets. This features
+ * requires an additonal amount of RAM to hold the reassembly buffer
+ * and the reassembly code size is approximately 700 bytes.  The
+ * reassembly buffer is of the same size as the uip_buf buffer
+ * (configured by UIP_BUFSIZE).
+ *
+ * \note IP packet reassembly is not heavily tested.
+ *
+ * \hideinitializer
+ */
+#define UIP_REASSEMBLY 0
+
+/**
+ * The maximum time an IP fragment should wait in the reassembly
+ * buffer before it is dropped.
+ *
+ */
+#define UIP_REASS_MAXAGE 40
+
+/** @} */
+
+/*------------------------------------------------------------------------------*/
+/**
+ * \name UDP configuration options
+ * @{
+ */
+
+/**
+ * Toggles wether UDP support should be compiled in or not.
+ *
+ * \hideinitializer
+ */
+#ifdef UIP_CONF_UDP
+#define UIP_UDP UIP_CONF_UDP
+#else /* UIP_CONF_UDP */
+#define UIP_UDP           0
+#endif /* UIP_CONF_UDP */
+
+/**
+ * Toggles if UDP checksums should be used or not.
+ *
+ * \note Support for UDP checksums is currently not included in uIP,
+ * so this option has no function.
+ *
+ * \hideinitializer
+ */
+#ifdef UIP_CONF_UDP_CHECKSUMS
+#define UIP_UDP_CHECKSUMS UIP_CONF_UDP_CHECKSUMS
+#else
+#define UIP_UDP_CHECKSUMS 0
+#endif
+
+/**
+ * The maximum amount of concurrent UDP connections.
+ *
+ * \hideinitializer
+ */
+#ifdef UIP_CONF_UDP_CONNS
+#define UIP_UDP_CONNS UIP_CONF_UDP_CONNS
+#else /* UIP_CONF_UDP_CONNS */
+#define UIP_UDP_CONNS    10
+#endif /* UIP_CONF_UDP_CONNS */
+
+/**
+ * The name of the function that should be called when UDP datagrams arrive.
+ *
+ * \hideinitializer
+ */
+
+
+/** @} */
+/*------------------------------------------------------------------------------*/
+/**
+ * \name TCP configuration options
+ * @{
+ */
+
+/**
+ * Toggles whether TCP support should be compiled in or not.
+ *
+ * \hideinitializer
+ */
+#ifdef UIP_CONF_TCP
+#define UIP_TCP UIP_CONF_TCP
+#else /* UIP_CONF_TCP */
+#define UIP_TCP           1
+#endif /* UIP_CONF_TCP */
+
+/**
+ * Determines if support for opening connections from uIP should be
+ * compiled in.
+ *
+ * If the applications that are running on top of uIP for this project
+ * do not need to open outgoing TCP connections, this configration
+ * option can be turned off to reduce the code size of uIP.
+ *
+ * \hideinitializer
+ */
+#define UIP_ACTIVE_OPEN 1
+
+/**
+ * The maximum number of simultaneously open TCP connections.
+ *
+ * Since the TCP connections are statically allocated, turning this
+ * configuration knob down results in less RAM used. Each TCP
+ * connection requires approximatly 30 bytes of memory.
+ *
+ * \hideinitializer
+ */
+#ifndef UIP_CONF_MAX_CONNECTIONS
+#define UIP_CONNS       10
+#else /* UIP_CONF_MAX_CONNECTIONS */
+#define UIP_CONNS UIP_CONF_MAX_CONNECTIONS
+#endif /* UIP_CONF_MAX_CONNECTIONS */
+
+
+/**
+ * The maximum number of simultaneously listening TCP ports.
+ *
+ * Each listening TCP port requires 2 bytes of memory.
+ *
+ * \hideinitializer
+ */
+#ifndef UIP_CONF_MAX_LISTENPORTS
+#define UIP_LISTENPORTS 20
+#else /* UIP_CONF_MAX_LISTENPORTS */
+#define UIP_LISTENPORTS UIP_CONF_MAX_LISTENPORTS
+#endif /* UIP_CONF_MAX_LISTENPORTS */
+
+/**
+ * Determines if support for TCP urgent data notification should be
+ * compiled in.
+ *
+ * Urgent data (out-of-band data) is a rarely used TCP feature that
+ * very seldom would be required.
+ *
+ * \hideinitializer
+ */
+#define UIP_URGDATA      0
+
+/**
+ * The initial retransmission timeout counted in timer pulses.
+ *
+ * This should not be changed.
+ */
+#define UIP_RTO         3
+
+/**
+ * The maximum number of times a segment should be retransmitted
+ * before the connection should be aborted.
+ *
+ * This should not be changed.
+ */
+#define UIP_MAXRTX      8
+
+/**
+ * The maximum number of times a SYN segment should be retransmitted
+ * before a connection request should be deemed to have been
+ * unsuccessful.
+ *
+ * This should not need to be changed.
+ */
+#define UIP_MAXSYNRTX      5
+
+/**
+ * The TCP maximum segment size.
+ *
+ * This is should not be to set to more than
+ * UIP_BUFSIZE - UIP_LLH_LEN - UIP_TCPIP_HLEN.
+ */
+#define UIP_TCP_MSS     (UIP_BUFSIZE - UIP_LLH_LEN - UIP_TCPIP_HLEN)
+
+/**
+ * The size of the advertised receiver's window.
+ *
+ * Should be set low (i.e., to the size of the uip_buf buffer) is the
+ * application is slow to process incoming data, or high (32768 bytes)
+ * if the application processes data quickly.
+ *
+ * \hideinitializer
+ */
+#ifndef UIP_CONF_RECEIVE_WINDOW
+#define UIP_RECEIVE_WINDOW UIP_TCP_MSS
+#else
+#define UIP_RECEIVE_WINDOW UIP_CONF_RECEIVE_WINDOW
+#endif
+
+/**
+ * How long a connection should stay in the TIME_WAIT state.
+ *
+ * This configiration option has no real implication, and it should be
+ * left untouched.
+ */
+#define UIP_TIME_WAIT_TIMEOUT 120
+
+
+/** @} */
+/*------------------------------------------------------------------------------*/
+/**
+ * \name ARP configuration options
+ * @{
+ */
+
+/**
+ * The size of the ARP table.
+ *
+ * This option should be set to a larger value if this uIP node will
+ * have many connections from the local network.
+ *
+ * \hideinitializer
+ */
+#ifdef UIP_CONF_ARPTAB_SIZE
+#define UIP_ARPTAB_SIZE UIP_CONF_ARPTAB_SIZE
+#else
+#define UIP_ARPTAB_SIZE 8
+#endif
+
+/**
+ * The maxium age of ARP table entries measured in 10ths of seconds.
+ *
+ * An UIP_ARP_MAXAGE of 120 corresponds to 20 minutes (BSD
+ * default).
+ */
+#define UIP_ARP_MAXAGE 120
+
+/** @} */
+
+/*------------------------------------------------------------------------------*/
+
+/**
+ * \name General configuration options
+ * @{
+ */
+
+/**
+ * The size of the uIP packet buffer.
+ *
+ * The uIP packet buffer should not be smaller than 60 bytes, and does
+ * not need to be larger than 1500 bytes. Lower size results in lower
+ * TCP throughput, larger size results in higher TCP throughput.
+ *
+ * \hideinitializer
+ */
+#ifndef UIP_CONF_BUFFER_SIZE
+#define UIP_BUFSIZE     400
+#else /* UIP_CONF_BUFFER_SIZE */
+#define UIP_BUFSIZE UIP_CONF_BUFFER_SIZE
+#endif /* UIP_CONF_BUFFER_SIZE */
+
+
+/**
+ * Determines if statistics support should be compiled in.
+ *
+ * The statistics is useful for debugging and to show the user.
+ *
+ * \hideinitializer
+ */
+#ifndef UIP_CONF_STATISTICS
+#define UIP_STATISTICS  0
+#else /* UIP_CONF_STATISTICS */
+#define UIP_STATISTICS UIP_CONF_STATISTICS
+#endif /* UIP_CONF_STATISTICS */
+
+/**
+ * Determines if logging of certain events should be compiled in.
+ *
+ * This is useful mostly for debugging. The function uip_log()
+ * must be implemented to suit the architecture of the project, if
+ * logging is turned on.
+ *
+ * \hideinitializer
+ */
+#ifndef UIP_CONF_LOGGING
+#define UIP_LOGGING     0
+#else /* UIP_CONF_LOGGING */
+#define UIP_LOGGING     UIP_CONF_LOGGING
+#endif /* UIP_CONF_LOGGING */
+
+/**
+ * Broadcast support.
+ *
+ * This flag configures IP broadcast support. This is useful only
+ * together with UDP.
+ *
+ * \hideinitializer
+ *
+ */
+#ifndef UIP_CONF_BROADCAST
+#define UIP_BROADCAST 0
+#else /* UIP_CONF_BROADCAST */
+#define UIP_BROADCAST UIP_CONF_BROADCAST
+#endif /* UIP_CONF_BROADCAST */
+
+/**
+ * Print out a uIP log message.
+ *
+ * This function must be implemented by the module that uses uIP, and
+ * is called by uIP whenever a log message is generated.
+ */
+void uip_log(char *msg);
+
+/**
+ * The link level header length.
+ *
+ * This is the offset into the uip_buf where the IP header can be
+ * found. For Ethernet, this should be set to 14. For SLIP, this
+ * should be set to 0.
+ *
+ * \hideinitializer
+ */
+#ifdef UIP_CONF_LLH_LEN
+#define UIP_LLH_LEN UIP_CONF_LLH_LEN
+#else /* UIP_CONF_LLH_LEN */
+#define UIP_LLH_LEN     14
+#endif /* UIP_CONF_LLH_LEN */
+
+/** @} */
+/*------------------------------------------------------------------------------*/
+/**
+ * \name CPU architecture configuration
+ * @{
+ *
+ * The CPU architecture configuration is where the endianess of the
+ * CPU on which uIP is to be run is specified. Most CPUs today are
+ * little endian, and the most notable exception are the Motorolas
+ * which are big endian. The BYTE_ORDER macro should be changed to
+ * reflect the CPU architecture on which uIP is to be run.
+ */
+
+/**
+ * The byte order of the CPU architecture on which uIP is to be run.
+ *
+ * This option can be either BIG_ENDIAN (Motorola byte order) or
+ * LITTLE_ENDIAN (Intel byte order).
+ *
+ * \hideinitializer
+ */
+#ifdef UIP_CONF_BYTE_ORDER
+#define UIP_BYTE_ORDER     UIP_CONF_BYTE_ORDER
+#else /* UIP_CONF_BYTE_ORDER */
+#define UIP_BYTE_ORDER     UIP_LITTLE_ENDIAN
+#endif /* UIP_CONF_BYTE_ORDER */
+
+/** @} */
+/*------------------------------------------------------------------------------*/
+
+/**
+ * \name Appication specific configurations
+ * @{
+ *
+ * An uIP application is implemented using a single application
+ * function that is called by uIP whenever a TCP/IP event occurs. The
+ * name of this function must be registered with uIP at compile time
+ * using the UIP_APPCALL definition.
+ *
+ * uIP applications can store the application state within the
+ * uip_conn structure by specifying the type of the application
+ * structure by typedef:ing the type uip_tcp_appstate_t and uip_udp_appstate_t.
+ *
+ * The file containing the definitions must be included in the
+ * uipopt.h file.
+ *
+ * The following example illustrates how this can look.
+ \code
+
+void httpd_appcall(void);
+#define UIP_APPCALL     httpd_appcall
+
+struct httpd_state {
+  u8_t state;
+  u16_t count;
+  char *dataptr;
+  char *script;
+};
+typedef struct httpd_state uip_tcp_appstate_t
+ \endcode
+ */
+
+/**
+ * \var #define UIP_APPCALL
+ *
+ * The name of the application function that uIP should call in
+ * response to TCP/IP events.
+ *
+ */
+
+/**
+ * \var typedef uip_tcp_appstate_t
+ *
+ * The type of the application state that is to be stored in the
+ * uip_conn structure. This usually is typedef:ed to a struct holding
+ * application state information.
+ */
+
+/**
+ * \var typedef uip_udp_appstate_t
+ *
+ * The type of the application state that is to be stored in the
+ * uip_conn structure. This usually is typedef:ed to a struct holding
+ * application state information.
+ */
+/** @} */
+/** @} */
+
+#endif /* __UIPOPT_H__ */


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000044.html">[Elua-svn] r88 - tags
</A></li>
	<LI>Next message: <A HREF="000046.html">[Elua-svn] r90 - trunk/src/platform/lm3s
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#45">[ date ]</a>
              <a href="thread.html#45">[ thread ]</a>
              <a href="subject.html#45">[ subject ]</a>
              <a href="author.html#45">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/elua-svn">More information about the eLua-svn
mailing list</a><br>
</body></html>
