<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Elua-svn] r91 - in trunk: . inc src src/modules src/newlib	src/platform/at91sam7x src/platform/i386 src/platform/lm3s	src/platform/lpc288x src/platform/str9 src/uip
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/elua-svn/2008-September/index.html" >
   <LINK REL="made" HREF="mailto:elua-svn%40lists.berlios.de?Subject=Re%3A%20%5BElua-svn%5D%20r91%20-%20in%20trunk%3A%20.%20inc%20src%20src/modules%20src/newlib%0A%09src/platform/at91sam7x%20src/platform/i386%20src/platform/lm3s%0A%09src/platform/lpc288x%20src/platform/str9%20src/uip&In-Reply-To=%3C200809182022.m8IKMPOG001448%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000046.html">
   <LINK REL="Next"  HREF="000048.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Elua-svn] r91 - in trunk: . inc src src/modules src/newlib	src/platform/at91sam7x src/platform/i386 src/platform/lm3s	src/platform/lpc288x src/platform/str9 src/uip</H1>
    <B>bogdanm at BerliOS</B> 
    <A HREF="mailto:elua-svn%40lists.berlios.de?Subject=Re%3A%20%5BElua-svn%5D%20r91%20-%20in%20trunk%3A%20.%20inc%20src%20src/modules%20src/newlib%0A%09src/platform/at91sam7x%20src/platform/i386%20src/platform/lm3s%0A%09src/platform/lpc288x%20src/platform/str9%20src/uip&In-Reply-To=%3C200809182022.m8IKMPOG001448%40sheep.berlios.de%3E"
       TITLE="[Elua-svn] r91 - in trunk: . inc src src/modules src/newlib	src/platform/at91sam7x src/platform/i386 src/platform/lm3s	src/platform/lpc288x src/platform/str9 src/uip">bogdanm at mail.berlios.de
       </A><BR>
    <I>Thu Sep 18 22:22:25 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000046.html">[Elua-svn] r90 - trunk/src/platform/lm3s
</A></li>
        <LI>Next message: <A HREF="000048.html">[Elua-svn] r92 - in trunk: . src/lua
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#47">[ date ]</a>
              <a href="thread.html#47">[ thread ]</a>
              <a href="subject.html#47">[ subject ]</a>
              <a href="author.html#47">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: bogdanm
Date: 2008-09-18 22:22:15 +0200 (Thu, 18 Sep 2008)
New Revision: 91

Added:
   trunk/inc/elua_net.h
   trunk/inc/validate.h
   trunk/src/newlib/stdtcp.c
Removed:
   trunk/src/platform/lm3s/uip_support.c
Modified:
   trunk/SConstruct
   trunk/inc/elua_uip.h
   trunk/inc/platform.h
   trunk/inc/utils.h
   trunk/src/elua_uip.c
   trunk/src/main.c
   trunk/src/modules/term.c
   trunk/src/newlib/devman.c
   trunk/src/newlib/genstd.c
   trunk/src/newlib/stubs.c
   trunk/src/platform/at91sam7x/build.h
   trunk/src/platform/i386/build.h
   trunk/src/platform/lm3s/build.h
   trunk/src/platform/lm3s/conf.py
   trunk/src/platform/lm3s/cpu.s
   trunk/src/platform/lm3s/platform.c
   trunk/src/platform/lm3s/uip-conf.h
   trunk/src/platform/lpc288x/build.h
   trunk/src/platform/str9/build.h
   trunk/src/shell.c
   trunk/src/uip/uip-split.c
   trunk/src/uip/uip.c
   trunk/src/uip/uip.h
Log:
eLua now works over TCP/IP instead of serial connection. This is basically printf/scanf over TCP/IP instead of UART, so it should look&amp;feel just like &quot;regular&quot; Lua, except that you don't have 
ANSI terminal support (yet) and &quot;recv&quot; doesn't work anymore because XMODEM doesn't work over TCP/IP. Only for LM3S8962/LM3S6965 for now, but it should straightforward (not easy though)
to port it to other platforms. Only static IP for now. More TCP/IP functions need to be implemented (and an eLua module must be written to access them). To enable console over TCP:

- enable &quot;BUILD_CON_TCP&quot; in build.h, also disable &quot;BUILD_XMODEM&quot; and &quot;BUILD_TERM&quot; in build.h (you'll get an error if you don't)
- disable &quot;BUILD_CON_GENERIC&quot; in build.h (you'll get an error if you don't)
- edit your network settings in build.h
- build the image&amp;burn it
- telnet to the address configured in build.h. Be sure to use a decent telnet client, like the one in Linux or putty. Don't try with telnet from Windows, as it surely won't work. Also, it might
  not work with the telnet client from Tera Term Pro (didn't test this).
- type 'exit' from shell to terminate the connection.

Also, note that from this point on you'll need a newer version of binutils to compile for Cortex. I'm using binutils-2.19.50.tar.bz2 (from the snapshots page). 2.18 might work too, but I didn't
test it.



Modified: trunk/SConstruct
===================================================================
--- trunk/SConstruct	2008-09-15 21:54:46 UTC (rev 90)
+++ trunk/SConstruct	2008-09-18 20:22:15 UTC (rev 91)
@@ -117,13 +117,13 @@
 local_libs = ''
   
 # Application files
-app_files = &quot; src/romfs.c src/main.c src/xmodem.c src/shell.c src/term.c src/dlmalloc.c&quot;
+app_files = &quot; src/main.c src/romfs.c src/xmodem.c src/shell.c src/term.c src/dlmalloc.c &quot;
   
 # Newlib related files  
-newlib_files = &quot; src/newlib/devman.c src/newlib/stubs.c src/newlib/genstd.c&quot;
+newlib_files = &quot; src/newlib/devman.c src/newlib/stubs.c src/newlib/genstd.c src/newlib/stdtcp.c&quot;
 
 # UIP files
-uip_files = &quot;uip_arp.c uip.c uiplib.c&quot;
+uip_files = &quot;uip_arp.c uip.c uiplib.c uip-split.c&quot;
 uip_files = &quot; src/elua_uip.c &quot; + &quot; &quot;.join( [ &quot;src/uip/%s&quot; % name for name in uip_files.split() ] )
 local_include = local_include + &quot; -Isrc/uip&quot;
 
@@ -142,7 +142,7 @@
 execfile( &quot;src/platform/%s/conf.py&quot; % platform )
 
 # Complete file list
-source_files = specific_files + newlib_files + uip_files + app_files + lua_full_files + module_files
+source_files = app_files + specific_files + newlib_files + uip_files + lua_full_files + module_files
   
 # Make filesystem first
 if not GetOption( 'clean' ):

Added: trunk/inc/elua_net.h
===================================================================
--- trunk/inc/elua_net.h	2008-09-15 21:54:46 UTC (rev 90)
+++ trunk/inc/elua_net.h	2008-09-18 20:22:15 UTC (rev 91)
@@ -0,0 +1,29 @@
+// Network services provided by eLua
+
+#ifndef __ELUA_NET_H__
+#define __ELUA_NET_H__
+
+#include &quot;type.h&quot;
+
+// eLua network typedefs
+typedef s16 elua_net_size;
+
+// eLua services ports
+#define ELUA_NET_TELNET_PORT          23
+
+// Different constants
+#define ELUA_NET_SOCK_STREAM          0
+#define ELUA_NET_SOCK_DGRAM           1
+
+// eLua TCP/IP functions
+int elua_net_socket( int type );
+
+int elua_net_close( int s );
+elua_net_size elua_net_recv( int s, void* buf, elua_net_size maxsize );
+elua_net_size elua_net_send( int s, const void* buf, elua_net_size len );
+int elua_accept( u16 port );
+
+int elua_net_get_last_err( int s );
+int elua_net_get_telnet_socket();
+
+#endif

Modified: trunk/inc/elua_uip.h
===================================================================
--- trunk/inc/elua_uip.h	2008-09-15 21:54:46 UTC (rev 90)
+++ trunk/inc/elua_uip.h	2008-09-18 20:22:15 UTC (rev 91)
@@ -4,13 +4,40 @@
 #ifndef __ELUA_UIP_H__
 #define __ELUA_UIP_H__
 
+#include &quot;type.h&quot;
+#include &quot;elua_net.h&quot;
+
+// eLua UIP application states
+enum
+{
+  ELUA_UIP_STATE_IDLE = 0,
+  ELUA_UIP_STATE_SEND,
+  ELUA_UIP_STATE_RECV,
+  ELUA_UIP_STATE_RECV_2,
+  ELUA_UIP_STATE_CLOSE,
+};
+
+// eLua UIP &quot;error codes&quot;
+enum
+{
+  ELUA_UIP_OK = 0,
+  ELUA_UIP_ERR_TIMEDOUT,
+  ELUA_UIP_ERR_CLOSED,
+  ELUA_UIP_ERR_ABORTED,
+  ELUA_UIP_ERR_OVERFLOW
+};
+
 // eLua UIP state
 struct elua_uip_state
 {
-  int dummy;
+  u8                state, res;
+  char*             ptr; 
+  elua_net_size     len;
 };
 
+// Helper functions
 void elua_uip_appcall();
 void elua_uip_init();
+void elua_uip_mainloop();
 
 #endif

Modified: trunk/inc/platform.h
===================================================================
--- trunk/inc/platform.h	2008-09-15 21:54:46 UTC (rev 90)
+++ trunk/inc/platform.h	2008-09-18 20:22:15 UTC (rev 91)
@@ -165,6 +165,20 @@
 u32 platform_pwm_op( unsigned id, int op, u32 data );
 
 // *****************************************************************************
+// CPU specific functions
+
+void platform_cpu_enable_interrupts();
+void platform_cpu_disable_interrupts();
+
+// *****************************************************************************
+// Ethernet specific functions
+
+void platform_eth_send_packet( const void* src, u32 size );
+u32 platform_eth_get_packet_nb( void* buf, u32 maxlen );
+void platform_eth_force_interrupt();
+u32 platform_eth_get_elapsed_time();
+
+// *****************************************************************************
 // Platform data subsection
 // Contains functions for platform identification
 

Modified: trunk/inc/utils.h
===================================================================
--- trunk/inc/utils.h	2008-09-15 21:54:46 UTC (rev 90)
+++ trunk/inc/utils.h	2008-09-18 20:22:15 UTC (rev 91)
@@ -5,6 +5,9 @@
 
 #define ABSDIFF( x, y )   ( ( x ) &gt;= ( y ) ? ( x ) - ( y ) : ( y ) - ( x ) )
 #define UMIN( x, y )      ( ( x ) &lt;= ( y ) ? ( x ) : ( y ) )
+#define UMAX( x, y )      ( ( x ) &gt;= ( y ) ? ( x ) : ( y ) )
 #define UABS( x )         ( ( x ) &gt;= 0 ? ( x ) : -( x ) )
-    
+
+#define STD_CTRLZ_CODE    26    
+
 #endif

Added: trunk/inc/validate.h
===================================================================
--- trunk/inc/validate.h	2008-09-15 21:54:46 UTC (rev 90)
+++ trunk/inc/validate.h	2008-09-18 20:22:15 UTC (rev 91)
@@ -0,0 +1,34 @@
+// Validate eLua configuration options
+// Should be included in main.c, as this is the first file that's compiled, so
+// any configuration errors are caught right at the beginning of the build
+// process
+
+#ifndef __VALIDATE_H__
+#define __VALIDATE_H__
+
+#include &quot;build.h&quot;
+
+// Can't define more than one console devices
+#if defined( BUILD_CON_TCP ) &amp;&amp; defined( BUILD_CON_GENERIC )
+#error &quot;Can't have two console devices (don't enable BUILD_CON_TCP and BUILD_CON_GENERIC in build.h at the same time)&quot;
+#endif // #if defined( BUILD_CON_TCP ) &amp;&amp; defined( BUILD_CON_GENERIC )
+
+// For TCP console we need to enable TCP support
+#ifdef BUILD_CON_TCP
+  #ifndef BUILD_UIP
+  #error &quot;BUILD_CON_TCP requires BUILD_UIP to be defined in build.h&quot; 
+  #endif // #ifndef BUILD_UIP
+#endif // #ifdef BUILD_CON_TCP
+
+// If TCP console is enabled, we don't need xmodem or term
+// (they can still function separately over UART, but this doesn't make sense)
+#ifdef BUILD_CON_TCP
+  #ifdef BUILD_XMODEM
+  #error &quot;XMODEM doesn't work with TCP console. Disable BUILD_XMODEM in build.h&quot;
+  #endif // #ifdef BUILD_XMODME
+  #ifdef BUILD_TERM
+  #error &quot;ANSI terminal support doesn't work (yet) with TCP console. Disable BUILD_TERM in build.h&quot;
+  #endif // #ifdef BUILD_TERM
+#endif // #ifdef BUILD_CON_TCP
+
+#endif // #ifndef __VALIDATE_H__

Modified: trunk/src/elua_uip.c
===================================================================
--- trunk/src/elua_uip.c	2008-09-15 21:54:46 UTC (rev 90)
+++ trunk/src/elua_uip.c	2008-09-18 20:22:15 UTC (rev 91)
@@ -5,16 +5,482 @@
 // Implements the eLua specific UIP application
 
 #include &quot;elua_uip.h&quot;
+#include &quot;elua_net.h&quot;
 #include &quot;type.h&quot;
+#include &quot;uip.h&quot;
+#include &quot;uip_arp.h&quot;
+#include &quot;platform.h&quot;
+#include &quot;utils.h&quot;
+#include &quot;uip-split.h&quot;
+#include &lt;string.h&gt;
 
-// UIP callback function
+// [REMOVE]
+// Also remove any printf()s here and MYLOGs
+#include &lt;stdio.h&gt;
+#include &quot;hw_types.h&quot;
+#include &quot;hw_uart.h&quot;
+#include &quot;hw_memmap.h&quot;
+#include &quot;usart.h&quot;
+#define MYLOG( x ) UARTCharPut( UART0_BASE, x )
+
+// UIP send buffer
+extern void* uip_sappdata;
+
+
+
+// *****************************************************************************
+// Platform independenet eLua UIP &quot;main loop&quot; implementation
+
+// Timers
+static u32 periodic_timer, arp_timer;
+
+// Macro for accessing the Ethernet header information in the buffer.
+#define BUF                     ((struct uip_eth_hdr *)&amp;uip_buf[0])
+
+// UIP Timers (in ms)
+#define UIP_PERIODIC_TIMER_MS   500
+#define UIP_ARP_TIMER_MS        10000
+
+// This is called from uip_split_output
+void tcpip_output()
+{
+  platform_eth_send_packet( uip_buf, uip_len );
+}
+
+static void device_driver_send()
+{
+  uip_split_output();  
+}
+
+// This gets called on both Ethernet RX interrupts and timer requests,
+// but it's called only from the Ethernet interrupt handler
+void elua_uip_mainloop()
+{
+  u32 temp, packet_len;
+
+  // Increment uIP timers
+  temp = platform_eth_get_elapsed_time();
+  periodic_timer += temp;
+  arp_timer += temp;  
+
+  // Check for an RX packet and read it
+  if( ( packet_len = platform_eth_get_packet_nb( uip_buf, sizeof( uip_buf ) ) ) &gt; 0 )
+  {
+    // Set uip_len for uIP stack usage.
+    uip_len = ( unsigned short )packet_len;
+
+    // Process incoming IP packets here.
+    if( BUF-&gt;type == htons( UIP_ETHTYPE_IP ) )
+    {
+      uip_arp_ipin();
+      uip_input();
+
+      // If the above function invocation resulted in data that
+      // should be sent out on the network, the global variable
+      // uip_len is set to a value &gt; 0.
+      if( uip_len &gt; 0 )
+      {
+        uip_arp_out();
+        device_driver_send();
+      }
+    }
+
+    // Process incoming ARP packets here.
+    else if( BUF-&gt;type == htons( UIP_ETHTYPE_ARP ) )
+    {
+      uip_arp_arpin();
+
+      // If the above function invocation resulted in data that
+      // should be sent out on the network, the global variable
+      // uip_len is set to a value &gt; 0.
+      if( uip_len &gt; 0 )
+        device_driver_send();
+    }
+  }
+  
+  for( temp = 0; temp &lt; UIP_UDP_CONNS; temp ++ )
+  {
+    // Poll connection
+    uip_poll_conn_num( temp );
+    if( uip_len &gt; 0 )
+    {
+      uip_arp_out();
+      device_driver_send();
+    }
+  }
+  
+  // Process TCP/IP Periodic Timer here.
+  if( periodic_timer &gt;= UIP_PERIODIC_TIMER_MS )
+  {
+    periodic_timer = 0;
+    for( temp = 0; temp &lt; UIP_CONNS; temp ++ )
+    {
+      uip_periodic( temp );
+
+      // If the above function invocation resulted in data that
+      // should be sent out on the network, the global variable
+      // uip_len is set to a value &gt; 0.
+      if( uip_len &gt; 0 )
+      {
+        uip_arp_out();
+        device_driver_send();
+      }
+    }
+
+#if UIP_UDP
+    for( temp = 0; temp &lt; UIP_UDP_CONNS; temp ++ )
+    {
+      uip_udp_periodic( temp );
+
+      // If the above function invocation resulted in data that
+      // should be sent out on the network, the global variable
+      // uip_len is set to a value &gt; 0.
+      if( uip_len &gt; 0 )
+      {
+        uip_arp_out();
+        device_driver_send();
+      }
+    }
+#endif // UIP_UDP
+  }  
+  
+  // Process ARP Timer here.
+  if( arp_timer &gt;= UIP_ARP_TIMER_MS )
+  {
+    arp_timer = 0;
+    uip_arp_timer();
+  }  
+}
+
+// *****************************************************************************
+// Console over Ethernet support
+
+#ifdef BUILD_CON_TCP
+
+// TELNET specific data
+#define TELNET_IAC_CHAR        255
+#define TELNET_IAC_3B_FIRST    251
+#define TELNET_IAC_3B_LAST     254
+#define TELNET_SB_CHAR         250
+#define TELNET_SE_CHAR         240
+#define TELNET_EOF             236
+
+// The telnet socket number
+static int elua_uip_telnet_socket = -1;
+
+// Utility function for TELNET: parse input buffer, skipping over
+// TELNET specific sequences
+// Returns the length of the buffer after processing
+static elua_net_size elua_uip_telnet_parse_input( struct elua_uip_state* s, elua_net_size size )
+{
+  u8* dptr = ( u8* )uip_appdata;
+  int skip;
+  
+  // Traverse the input buffer, skipping over TELNET sequences
+  while( ( size &gt; 0 ) &amp;&amp; ( dptr &lt; ( u8* )uip_appdata + uip_datalen() ) )
+  {
+    if( *dptr != TELNET_IAC_CHAR ) // regular char, copy it to buffer
+      *s-&gt;ptr ++ = *dptr ++;
+    else
+    {
+      // Control sequence: 2 or 3 bytes?
+      if( ( dptr[ 1 ] &gt;= TELNET_IAC_3B_FIRST ) &amp;&amp; ( dptr[ 1 ] &lt;= TELNET_IAC_3B_LAST ) )
+        skip = 3;
+      else
+      {
+        // Check EOF indication
+        if( dptr[ 1 ] == TELNET_EOF )
+        {
+          *s-&gt;ptr ++ = STD_CTRLZ_CODE;
+          size ++;
+        }
+        skip = 2;
+      }
+      dptr += skip;
+      size = UMAX( 0, size - skip );
+    }
+  } 
+  return size;
+}
+
+// Utility function for TELNET: prepend all '\n' with '\r' in buffer
+// Returns actual len
+// It is assumed that the buffer is &quot;sufficiently smaller&quot; than the UIP
+// buffer (which is true for the default configuration: 128 bytes buffer
+// in Newlib for stdin/stdout, more than 1024 bytes UIP buffer)
+static elua_net_size elua_uip_telnet_prep_send( const char* src, elua_net_size size )
+{
+  elua_net_size actsize = size, i;
+  char* dest = ( char* )uip_sappdata;
+    
+  for( i = 0; i &lt; size; i ++ )
+  {
+    if( *src == '\n' )
+    {
+      *dest ++ = '\r';
+      actsize ++;
+    } 
+    *dest ++ = *src ++;
+  }
+  return actsize;
+}
+
+#endif // #ifdef BUILD_CON_TCP
+
+// *****************************************************************************
+// eLua UIP application (used to implement the eLua TCP/IP services)
+
+// Special handling for &quot;accept&quot;
+volatile static u8 elua_uip_accept_request;
+volatile static int elua_uip_accept_sock;
+
 void elua_uip_appcall()
 {
+  struct elua_uip_state *s;
+  elua_net_size temp;
+  int sockno;
+    
+  s = ( struct elua_uip_state* )&amp;( uip_conn-&gt;appstate );
+  // Need to find the actual socket location, since UIP doesn't provide this ...
+  for( temp = 0; temp &lt; UIP_CONNS; temp ++ )
+    if( uip_conns + temp == uip_conn )
+      break;
+  sockno = ( int )temp;
+
+  if( uip_connected() )
+  {
+    // [TODO] handle locally initiated connections too (via uip_connect)
+#ifdef BUILD_CON_TCP    
+    if( uip_conn-&gt;lport == HTONS( ELUA_NET_TELNET_PORT ) ) // special case: telnet server
+      elua_uip_telnet_socket = sockno;
+    else
+#endif
+    if( elua_uip_accept_request )
+    {
+      elua_uip_accept_sock = sockno;
+      elua_uip_accept_request = 0;
+    }
+    return;
+  }
+
+  if( s-&gt;state == ELUA_UIP_STATE_IDLE )
+    return;
+    
+  // Do we need to read?
+  if( s-&gt;state == ELUA_UIP_STATE_RECV )
+  {
+    // Re-enable data transfer on the socket and change state
+    s-&gt;state = ELUA_UIP_STATE_RECV_2;
+    uip_restart();
+    return;
+  }
+  
+  if( uip_aborted() || uip_timedout() || uip_closed() )
+  {
+    // Signal this error
+    s-&gt;res = uip_aborted() ? ELUA_UIP_ERR_ABORTED : ( uip_timedout() ? ELUA_UIP_ERR_TIMEDOUT : ELUA_UIP_ERR_CLOSED );
+#ifdef BUILD_CON_TCP    
+    if( sockno == elua_uip_telnet_socket )
+      elua_uip_telnet_socket = -1;      
+#endif    
+    s-&gt;state = ELUA_UIP_STATE_IDLE;
+    return;
+  }
+       
+  // Handle data send  
+  if( ( uip_acked() || uip_rexmit() || uip_poll() ) &amp;&amp; ( s-&gt;state == ELUA_UIP_STATE_SEND ) )
+  {
+    // Special translation for TELNET: prepend all '\n' with '\r'
+    // We write directly in UIP's buffer 
+    if( uip_acked() )
+    {
+      // Send next part of the buffer (if needed)
+      if( s-&gt;len &lt; uip_mss() ) // end of transmission
+      { 
+        s-&gt;len = 0;
+        s-&gt;state = ELUA_UIP_STATE_IDLE;
+      }
+      else
+      {
+        s-&gt;len -= uip_conn-&gt;len;
+        s-&gt;ptr += uip_conn-&gt;len;
+      }
+    }
+    if( s-&gt;len &gt; 0 ) // need to (re)transmit?
+    {
+#ifdef BUILD_CON_TCP    
+      if( sockno == elua_uip_telnet_socket )
+      {
+        temp = elua_uip_telnet_prep_send( s-&gt;ptr, s-&gt;len );
+        uip_send( uip_sappdata, temp );
+      }
+      else
+#endif      
+        uip_send( s-&gt;ptr, s-&gt;len );
+    }
+    return;
+  }
+  
+  // Handle close
+  if( s-&gt;state == ELUA_UIP_STATE_CLOSE )
+  {
+    uip_close();
+    s-&gt;state = ELUA_UIP_STATE_IDLE;
+  }
+          
+  // Handle data receive  
+  if( uip_newdata() )
+  {
+    if( s-&gt;state == ELUA_UIP_STATE_RECV_2 )
+    {
+      temp = uip_datalen();
+#ifdef BUILD_CON_TCP      
+      if( sockno == elua_uip_telnet_socket )
+      {
+        if( ( temp = elua_uip_telnet_parse_input( s, temp ) ) == 0 )
+          return;
+      }
+      else
+#endif      
+        memcpy( s-&gt;ptr, uip_appdata, UMIN( s-&gt;len, temp ) );
+      s-&gt;len = UMIN( s-&gt;len, temp );  
+      if( s-&gt;len &lt; temp )
+        s-&gt;res = ELUA_UIP_ERR_OVERFLOW;
+      uip_stop();
+      s-&gt;state = ELUA_UIP_STATE_IDLE;
+    }
+    else
+      uip_stop();
+    return;
+  }
 }
 
 // Init application
 void elua_uip_init()
 {
+#ifdef BUILD_CON_TCP
+  uip_listen( HTONS( ELUA_NET_TELNET_PORT ) );
+#endif  
 }
 
+// *****************************************************************************
+// eLua TCP/IP services (from elua_net.h)
+
+#define ELUA_UIP_IS_SOCK_OK( sock ) ( sock &gt;= 0 &amp;&amp; sock &lt; UIP_CONNS )
+
+int elua_net_socket( int type )
+{
+  int i;
+  struct uip_conn* pconn;
+  
+  // [TODO] add UDP support at some point.
+  if( type == ELUA_NET_SOCK_DGRAM )
+    return -1;
+  
+  platform_cpu_disable_interrupts();
+  // Iterate through the list of connections, looking for a free one
+  for( i = 0; i &lt; UIP_CONNS; i ++ )
+  {
+    pconn = uip_conns + i;
+    if( pconn-&gt;tcpstateflags == UIP_CLOSED )
+    { 
+      // Found a free connection, reserve it for later use
+      uip_conn_reserve( i );
+      break;
+    }
+  }
+  platform_cpu_enable_interrupts();
+  return i == UIP_CONNS ? -1 : i;
+}
+
+// Send data
+elua_net_size elua_net_send( int s, const void* buf, elua_net_size len )
+{
+  volatile struct elua_uip_state *pstate = ( volatile struct elua_uip_state* )&amp;( uip_conns[ s ].appstate );
+  
+  if( !ELUA_UIP_IS_SOCK_OK( s ) || !uip_conn_active( s ) )
+    return -1;
+  if( len == 0 )
+    return 0;
+  pstate-&gt;ptr = ( char* )buf;
+  pstate-&gt;len = len;
+  pstate-&gt;res = ELUA_UIP_OK;
+  pstate-&gt;state = ELUA_UIP_STATE_SEND;  
+  platform_eth_force_interrupt();
+  while( pstate-&gt;state != ELUA_UIP_STATE_IDLE );
+  return len - pstate-&gt;len;
+}
+
+// Receive data
+elua_net_size elua_net_recv( int s, void* buf, elua_net_size maxsize )
+{
+  volatile struct elua_uip_state *pstate = ( volatile struct elua_uip_state* )&amp;( uip_conns[ s ].appstate );
+  
+  if( !ELUA_UIP_IS_SOCK_OK( s ) || !uip_conn_active( s ) )
+    return -1;
+  if( maxsize == 0 )
+    return 0;
+  pstate-&gt;ptr = ( char* )buf;
+  pstate-&gt;len = maxsize;
+  pstate-&gt;res = ELUA_UIP_OK;  
+  pstate-&gt;state = ELUA_UIP_STATE_RECV;
+  while( pstate-&gt;state != ELUA_UIP_STATE_IDLE );
+  return pstate-&gt;len;
+}
+
+// Return the socket associated with the &quot;telnet&quot; application (or -1 if it does
+// not exist). The socket only exists if a client connected to the board.
+int elua_net_get_telnet_socket()
+{
+  int res = -1;
+  
+#ifdef BUILD_CON_TCP  
+  if( elua_uip_telnet_socket != -1 )
+    if( uip_conn_active( elua_uip_telnet_socket ) )
+      res = elua_uip_telnet_socket;
+#endif      
+  return res;
+}
+
+// Close socket
+int elua_net_close( int s )
+{
+  volatile struct elua_uip_state *pstate = ( volatile struct elua_uip_state* )&amp;( uip_conns[ s ].appstate );  
+  
+  if( !ELUA_UIP_IS_SOCK_OK( s ) || !uip_conn_active( s ) )
+    return -1;
+  pstate-&gt;res = ELUA_UIP_OK;    
+  pstate-&gt;state = ELUA_UIP_STATE_CLOSE;
+  platform_eth_force_interrupt();
+  while( pstate-&gt;state != ELUA_UIP_STATE_IDLE );
+  return 0;
+}
+
+// Get last error on specific socket
+int elua_net_get_last_err( int s )
+{
+  volatile struct elua_uip_state *pstate = ( volatile struct elua_uip_state* )&amp;( uip_conns[ s ].appstate );  
+  
+  if( !ELUA_UIP_IS_SOCK_OK( s ) )
+    return -1;
+  return pstate-&gt;res;
+}
+
+// Accept a connection on the given port, return its socket id
+int elua_accept( u16 port )
+{
+#ifdef BUILD_CON_TCP
+  if( port == ELUA_NET_TELNET_PORT )
+    return -1;
+#endif  
+  platform_cpu_disable_interrupts();
+  uip_unlisten( htons( port ) );
+  uip_listen( htons( port ) );
+  platform_cpu_enable_interrupts();
+  elua_uip_accept_sock = -1;
+  elua_uip_accept_request = 1;
+  while( elua_uip_accept_request );
+  return elua_uip_accept_sock;
+}
+
 #endif // #ifdef BUILD_UIP

Modified: trunk/src/main.c
===================================================================
--- trunk/src/main.c	2008-09-15 21:54:46 UTC (rev 90)
+++ trunk/src/main.c	2008-09-18 20:22:15 UTC (rev 91)
@@ -12,6 +12,9 @@
 #include &quot;lua.h&quot;
 #include &quot;term.h&quot;
 
+// Validate eLua configuratin options
+#include &quot;validate.h&quot;
+
 extern char etext[];
 
 // ****************************************************************************

Modified: trunk/src/modules/term.c
===================================================================
--- trunk/src/modules/term.c	2008-09-15 21:54:46 UTC (rev 90)
+++ trunk/src/modules/term.c	2008-09-18 20:22:15 UTC (rev 91)
@@ -6,6 +6,7 @@
 #include &quot;platform.h&quot;
 #include &quot;auxmods.h&quot;
 #include &quot;term.h&quot;
+#include &quot;build.h&quot;
 
 // Lua: clrscr()
 static int luaterm_clrscr( lua_State* L )
@@ -209,6 +210,7 @@
 
 LUALIB_API int luaopen_term( lua_State* L )
 {
+#ifdef BUILD_TERM
   unsigned i;
   
   // Register methods
@@ -228,4 +230,7 @@
   lua_setfield( L, -2, &quot;WAIT&quot; );  
   
   return 1;
+#else // #ifdef BUILD_TERM
+  return 0;
+#endif // #ifdef BUILD_TERM  
 }

Modified: trunk/src/newlib/devman.c
===================================================================
--- trunk/src/newlib/devman.c	2008-09-15 21:54:46 UTC (rev 90)
+++ trunk/src/newlib/devman.c	2008-09-18 20:22:15 UTC (rev 91)
@@ -5,6 +5,7 @@
 #include &lt;fcntl.h&gt;
 #include &quot;devman.h&quot;
 #include &quot;genstd.h&quot;
+#include &quot;build.h&quot;
 
 static DM_DEVICE dm_list[ DM_MAX_DEVICES ];           // list of devices
 static int dm_num_devs;                               // number of devices
@@ -16,7 +17,7 @@
   int i;
   
   // First char of the name must be '/'
-  if( pdev-&gt;name == NULL || *pdev-&gt;name == '\0' || *pdev-&gt;name != '/' || strlen( pdev-&gt;name ) &gt; DM_MAX_DEV_NAME )
+  if( pdev == NULL || pdev-&gt;name == NULL || *pdev-&gt;name == '\0' || *pdev-&gt;name != '/' || strlen( pdev-&gt;name ) &gt; DM_MAX_DEV_NAME )
     return DM_ERR_INVALID_NAME;
   
   // Check if the device is not already registered
@@ -77,6 +78,8 @@
 int dm_init() 
 {
   dm_register( std_get_desc() );
+#ifndef BUILD_CON_TCP         // we need buffering on stdout for console over TCP
   setbuf( stdout, NULL );
+#endif
   return DM_OK;
 }

Modified: trunk/src/newlib/genstd.c
===================================================================
--- trunk/src/newlib/genstd.c	2008-09-15 21:54:46 UTC (rev 90)
+++ trunk/src/newlib/genstd.c	2008-09-18 20:22:15 UTC (rev 91)
@@ -1,17 +1,19 @@
 // Generic stdin/stdout/stderr support functions
 
+#include &quot;build.h&quot;
+#ifdef BUILD_CON_GENERIC
+
 #include &quot;type.h&quot;
 #include &quot;devman.h&quot;
 #include &quot;genstd.h&quot;
 #include &lt;stdio.h&gt;
 #include &lt;errno.h&gt;
 #include &lt;ctype.h&gt;
+#include &quot;utils.h&quot;
 
 static p_std_send_char std_send_char_func;
 static p_std_get_char std_get_char_func;
 
-#define STD_CTRLZ_CODE         26
-
 // 'read'
 static _ssize_t std_read( struct _reent *r, int fd, void* vptr, size_t len )
 {
@@ -91,6 +93,7 @@
     r-&gt;_errno = EINVAL;
     return -1;
   }  
+  
   for( i = 0; i &lt; len; i ++ ) 
   {
     if( ptr[ i ] == '\n' )
@@ -126,3 +129,5 @@
 {
   return &amp;std_device;
 }
+
+#endif // #ifdef BUILD_CON_GENERIC

Added: trunk/src/newlib/stdtcp.c
===================================================================
--- trunk/src/newlib/stdtcp.c	2008-09-15 21:54:46 UTC (rev 90)
+++ trunk/src/newlib/stdtcp.c	2008-09-18 20:22:15 UTC (rev 91)
@@ -0,0 +1,93 @@
+// Console (stdin/stdout/stderr) over TCP
+
+#include &quot;build.h&quot;
+#ifdef BUILD_CON_TCP
+
+#include &quot;type.h&quot;
+#include &quot;devman.h&quot;
+#include &quot;genstd.h&quot;
+#include &quot;elua_net.h&quot;
+#include &quot;utils.h&quot;
+#include &lt;stdio.h&gt;
+#include &lt;errno.h&gt;
+#include &lt;string.h&gt;
+
+// 'read'
+static _ssize_t std_read( struct _reent *r, int fd, void* vptr, size_t len )
+{
+  int sock;
+  elua_net_size pktsize;
+  size_t actsize, j;
+  char* lptr = ( char* )vptr;
+
+  // Check file number
+  if( fd != DM_STDIN_NUM )
+  {
+    r-&gt;_errno = EINVAL;
+    return -1;
+  }      
+
+  // Get (and wait for) socket
+  while( ( sock = elua_net_get_telnet_socket() ) == - 1 );
+  
+  // Read data
+  actsize = 0;
+  while( 1 )
+  {
+    pktsize = elua_net_recv( sock, lptr, len );
+    // Check EOF
+    for( j = 0; j &lt; pktsize; j ++ )
+      if( lptr[ j ] == STD_CTRLZ_CODE )
+        return 0;
+    actsize += pktsize;
+    if( actsize &gt;= len )
+    {
+      actsize = len;
+      break;
+    }
+    // Is this the final packet?
+    if( pktsize &gt;= 2 &amp;&amp; lptr[ pktsize - 2 ] == '\r' &amp;&amp; lptr[ pktsize - 1 ] == '\n' ) // final packet
+      break;    
+    lptr += pktsize;
+    len -= pktsize;
+  }
+  return actsize;
+}
+
+// 'write'
+static _ssize_t std_write( struct _reent *r, int fd, const void* vptr, size_t len )
+{   
+  int sock;
+  
+  // Check file number
+  if( ( fd != DM_STDOUT_NUM ) &amp;&amp; ( fd != DM_STDERR_NUM ) )
+  {
+    r-&gt;_errno = EINVAL;
+    return -1;
+  }  
+  
+  // Get (and wait for) socket
+  while( ( sock = elua_net_get_telnet_socket() ) == - 1 );  
+  
+  // Send data
+  elua_net_send( sock, vptr, len );
+  return len;
+}
+
+// Our UART device descriptor structure
+static DM_DEVICE std_device = 
+{
+  STD_DEV_NAME,
+  NULL,                 // we don't have 'open' on std
+  NULL,                 // we don't have 'close' on std
+  std_write,
+  std_read,
+  NULL                  // we don't have &quot;ioctl&quot; on std
+};
+
+DM_DEVICE* std_get_desc()
+{
+  return &amp;std_device;
+}
+
+#endif // #ifdef BUILD_CON_TCP

Modified: trunk/src/newlib/stubs.c
===================================================================
--- trunk/src/newlib/stubs.c	2008-09-15 21:54:46 UTC (rev 90)
+++ trunk/src/newlib/stubs.c	2008-09-18 20:22:15 UTC (rev 91)
@@ -9,6 +9,8 @@
 #include &quot;devman.h&quot;
 #include &quot;ioctl.h&quot;
 #include &quot;platform.h&quot;
+#include &quot;build.h&quot;
+#include &quot;genstd.h&quot;
 
 #ifdef USE_MULTIPLE_ALLOCATOR
 #include &quot;dlmalloc.h&quot;
@@ -362,3 +364,24 @@
 }
 
 #endif // #ifdef USE_MULTIPLE_ALLOCATOR
+
+// *****************************************************************************
+// eLua stubs (not Newlib specific)
+
+#ifndef BUILD_CON_GENERIC
+
+// Set send/recv functions
+void std_set_send_func( p_std_send_char pfunc )
+{
+}
+
+void std_set_get_func( p_std_get_char pfunc )
+{
+}
+
+DM_DEVICE* std_get_desc()
+{
+  return NULL;
+}
+
+#endif // #ifndef BUILD_CON_GENERIC

Modified: trunk/src/platform/at91sam7x/build.h
===================================================================
--- trunk/src/platform/at91sam7x/build.h	2008-09-15 21:54:46 UTC (rev 90)
+++ trunk/src/platform/at91sam7x/build.h	2008-09-18 20:22:15 UTC (rev 91)
@@ -7,5 +7,6 @@
 #define BUILD_SHELL
 #define BUILD_ROMFS
 #define BUILD_TERM
+#define BUILD_CON_GENERIC
 
 #endif

Modified: trunk/src/platform/i386/build.h
===================================================================
--- trunk/src/platform/i386/build.h	2008-09-15 21:54:46 UTC (rev 90)
+++ trunk/src/platform/i386/build.h	2008-09-18 20:22:15 UTC (rev 91)
@@ -5,5 +5,6 @@
 
 #define BUILD_ROMFS
 #define BUILD_SHELL
+#define BUILD_CON_GENERIC
 
 #endif

Modified: trunk/src/platform/lm3s/build.h
===================================================================
--- trunk/src/platform/lm3s/build.h	2008-09-15 21:54:46 UTC (rev 90)
+++ trunk/src/platform/lm3s/build.h	2008-09-18 20:22:15 UTC (rev 91)
@@ -1,4 +1,5 @@
 // Define here what components you want for this platform
+// Also used for compile-time configuration constants (like TCP/IP config)
 
 #ifndef __BUILD_H__
 #define __BUILD_H__
@@ -8,5 +9,17 @@
 #define BUILD_ROMFS
 #define BUILD_TERM
 #define BUILD_UIP
+#define BUILD_CON_GENERIC
+//#define BUILD_CON_TCP
 
+// Static TCP/IP configuration
+#define ELUA_IPADDR0         192
+#define ELUA_IPADDR1         168
+#define ELUA_IPADDR2         1
+#define ELUA_IPADDR3         13
+#define ELUA_NETMASK0        255
+#define ELUA_NETMASK1        255
+#define ELUA_NETMASK2        255
+#define ELUA_NETMASK3        0
+
 #endif

Modified: trunk/src/platform/lm3s/conf.py
===================================================================
--- trunk/src/platform/lm3s/conf.py	2008-09-15 21:54:46 UTC (rev 90)
+++ trunk/src/platform/lm3s/conf.py	2008-09-18 20:22:15 UTC (rev 91)
@@ -1,6 +1,6 @@
 # Configuration file for the LM3S microcontroller
 
-specific_files = &quot;startup_gcc.c platform.c usart.c sysctl.c gpio.c ssi.c timer.c pwm.c ethernet.c systick.c uip_support.c flash.c interrupt.c cpu.s&quot;
+specific_files = &quot;startup_gcc.c platform.c usart.c sysctl.c gpio.c ssi.c timer.c pwm.c ethernet.c systick.c flash.c interrupt.c cpu.s&quot;
 ldscript = &quot;lm3s.ld&quot;
   
 # Prepend with path

Modified: trunk/src/platform/lm3s/cpu.s
===================================================================
--- trunk/src/platform/lm3s/cpu.s	2008-09-15 21:54:46 UTC (rev 90)
+++ trunk/src/platform/lm3s/cpu.s	2008-09-18 20:22:15 UTC (rev 91)
@@ -73,5 +73,3 @@
 CPUwfi __LABEL__
     wfi
     bx      lr
-
-    __END__

Modified: trunk/src/platform/lm3s/platform.c
===================================================================
--- trunk/src/platform/lm3s/platform.c	2008-09-15 21:54:46 UTC (rev 90)
+++ trunk/src/platform/lm3s/platform.c	2008-09-18 20:22:15 UTC (rev 91)
@@ -20,6 +20,7 @@
 #include &quot;hw_memmap.h&quot;
 #include &quot;hw_types.h&quot;
 #include &quot;hw_pwm.h&quot;
+#include &quot;hw_nvic.h&quot;
 #include &quot;debug.h&quot;
 #include &quot;gpio.h&quot;
 #include &quot;interrupt.h&quot;
@@ -33,7 +34,12 @@
 #include &quot;systick.h&quot;
 #include &quot;flash.h&quot;
 #include &quot;interrupt.h&quot;
+#include &quot;elua_net.h&quot;
 
+// UIP sys tick data
+#define SYSTICKHZ               4
+#define SYSTICKMS               (1000 / SYSTICKHZ)
+
 // *****************************************************************************
 // std function
 static void uart_send( int fd, char c )
@@ -539,27 +545,30 @@
   return res;
 }
 
+
+
+// *****************************************************************************
+// CPU specific functions
+
+void platform_cpu_enable_interrupts()
+{
+  IntMasterEnable();
+}
+
+void platform_cpu_disable_interrupts()
+{
+  IntMasterDisable();
+}
+
 // ****************************************************************************
-// Ethernet
+// Ethernet functions
 
-#define DEFAULT_IPADDR0         192
-#define DEFAULT_IPADDR1         168
-#define DEFAULT_IPADDR2         1
-#define DEFAULT_IPADDR3         13
-#define DEFAULT_NETMASK0        255
-#define DEFAULT_NETMASK1        255
-#define DEFAULT_NETMASK2        255
-#define DEFAULT_NETMASK3        0
-
 static void eth_init()
 {
 #ifdef BUILD_UIP
   u32 user0, user1, temp;
   uip_ipaddr_t ipaddr;  
   static struct uip_eth_addr sTempAddr;     
-
-  // Initialize the TCP/IP Application
-  elua_uip_init();    
   
   // Enable and reset the controller
   SysCtlPeripheralEnable( SYSCTL_PERIPH_ETH );
@@ -605,9 +614,9 @@
   // Initialize the uIP TCP/IP stack.
   uip_init();
   uip_arp_init();
-  uip_ipaddr(ipaddr, DEFAULT_IPADDR0, DEFAULT_IPADDR1, DEFAULT_IPADDR2, DEFAULT_IPADDR3);
+  uip_ipaddr(ipaddr, ELUA_IPADDR0, ELUA_IPADDR1, ELUA_IPADDR2, ELUA_IPADDR3);
   uip_sethostaddr(ipaddr);
-  uip_ipaddr(ipaddr, DEFAULT_NETMASK0, DEFAULT_NETMASK1, DEFAULT_NETMASK2, DEFAULT_NETMASK3);
+  uip_ipaddr(ipaddr, ELUA_NETMASK0, ELUA_NETMASK1, ELUA_NETMASK2, ELUA_NETMASK3);
   uip_setnetmask(ipaddr);     
 
   // Configure the hardware MAC address for Ethernet Controller filtering of
@@ -631,9 +640,74 @@
   // Program the hardware with it's MAC address (for filtering).
   EthernetMACAddrSet(ETH_BASE, (unsigned char *)&amp;sTempAddr);  
   uip_setethaddr(sTempAddr);
+
+  // Initialize the TCP/IP Application
+  elua_uip_init();    
 #endif
 }
 
+#ifdef BUILD_UIP
+static int eth_timer_fired;
+
+void platform_eth_send_packet( const void* src, u32 size )
+{
+  EthernetPacketPut( ETH_BASE, uip_buf, uip_len );    
+}
+
+u32 platform_eth_get_packet_nb( void* buf, u32 maxlen )
+{
+  return EthernetPacketGetNonBlocking( ETH_BASE, uip_buf, sizeof( uip_buf ) );
+}
+
+void platform_eth_force_interrupt()
+{
+  HWREG( NVIC_SW_TRIG) |= INT_ETH - 16;  
+}
+
+u32 platform_eth_get_elapsed_time()
+{
+  if( eth_timer_fired )
+  {
+    eth_timer_fired = 0;
+    return SYSTICKMS;
+  }
+  else
+    return 0;
+}
+
+void SysTickIntHandler()
+{
+  // Indicate that a SysTick interrupt has occurred.
+  eth_timer_fired = 1;
+
+  // Generate a fake Ethernet interrupt.  This will perform the actual work
+  // of incrementing the timers and taking the appropriate actions.
+  platform_eth_force_interrupt();
+}
+
+void EthernetIntHandler()
+{
+  u32 temp;
+  
+  // Read and Clear the interrupt.
+  temp = EthernetIntStatus( ETH_BASE, false );
+  EthernetIntClear( ETH_BASE, temp );
+
+  // Call the UIP main loop  
+  elua_uip_mainloop();
+}
+
+#else  // #ifdef ELUA_UIP
+
+void SysTickIntHandler()
+{
+}
+
+void EthernetIntHandler()
+{
+}
+#endif // #ifdef ELUA_UIP
+
 // ****************************************************************************
 // Platform data
 

Modified: trunk/src/platform/lm3s/uip-conf.h
===================================================================
--- trunk/src/platform/lm3s/uip-conf.h	2008-09-15 21:54:46 UTC (rev 90)
+++ trunk/src/platform/lm3s/uip-conf.h	2008-09-18 20:22:15 UTC (rev 91)
@@ -29,12 +29,6 @@
 #ifndef __UIP_CONF_H__
 #define __UIP_CONF_H__
 
-// Added for eLua: SYSTICK data
-#define SYSTICKHZ               4
-#define SYSTICKMS               (1000 / SYSTICKHZ)
-#define SYSTICKUS               (1000000 / SYSTICKHZ)
-#define SYSTICKNS               (1000000000 / SYSTICKHZ)
-
 //
 // 8 bit datatype
 // This typedef defines the 8-bit type used throughout uIP.

Deleted: trunk/src/platform/lm3s/uip_support.c
===================================================================
--- trunk/src/platform/lm3s/uip_support.c	2008-09-15 21:54:46 UTC (rev 90)
+++ trunk/src/platform/lm3s/uip_support.c	2008-09-18 20:22:15 UTC (rev 91)
@@ -1,182 +0,0 @@
-// UIP support functions
-
-#include &quot;build.h&quot;
-#ifdef BUILD_UIP
-
-#include &quot;hw_types.h&quot;
-#include &quot;hw_ints.h&quot;
-#include &quot;hw_ethernet.h&quot;
-#include &quot;hw_memmap.h&quot;
-#include &quot;ethernet.h&quot;
-#include &quot;type.h&quot;
-#include &quot;hw_nvic.h&quot;
-#include &quot;uip.h&quot;
-#include &quot;uip_arp.h&quot;
-
-// Interrupt flags
-#define INT_TIMER     1
-#define INT_ETH_RX    2
-static u8 int_flags;
-
-// Timers
-static u32 periodic_timer;
-static u32 arp_timer;
-
-// Macro for accessing the Ethernet header information in the buffer.
-#define BUF                     ((struct uip_eth_hdr *)&amp;uip_buf[0])
-
-// UIP Timers (in ms)
-#define UIP_PERIODIC_TIMER_MS   500
-#define UIP_ARP_TIMER_MS        10000
-
-// This gets called on both Ethernet RX interrupts and timer requests,
-// but it's called only from the Ethernet interrupt handler
-static void uip_support_func()
-{
-  long packet_len;
-  u32 temp;
-  
-  // If SysTick, Clear the SysTick interrupt flag and increment the
-  // timers.
-  if( int_flags &amp; INT_TIMER )
-  {
-    int_flags &amp;= ( u8 )~INT_TIMER;
-    periodic_timer += SYSTICKMS;
-    arp_timer += SYSTICKMS;
-  }
-
-  // Check for an RX packet and read it
-  packet_len = EthernetPacketGetNonBlocking(ETH_BASE, uip_buf, sizeof(uip_buf));
-  if(packet_len &gt; 0)
-  {
-    // Set uip_len for uIP stack usage.
-    uip_len = (unsigned short)packet_len;
-
-    // Clear the RX Packet event and renable RX Packet interrupts.
-    if( int_flags &amp; INT_ETH_RX )
-    {
-      int_flags &amp;= ( u8 )~INT_ETH_RX;
-      EthernetIntEnable(ETH_BASE, ETH_INT_RX);
-    }
-
-    // Process incoming IP packets here.
-    if(BUF-&gt;type == htons(UIP_ETHTYPE_IP))
-    {
-      uip_arp_ipin();
-      uip_input();
-
-      // If the above function invocation resulted in data that
-      // should be sent out on the network, the global variable
-      // uip_len is set to a value &gt; 0.
-      if(uip_len &gt; 0)
-      {
-        uip_arp_out();
-        EthernetPacketPut(ETH_BASE, uip_buf, uip_len);
-        uip_len = 0;
-      }
-    }
-
-    // Process incoming ARP packets here.
-    else if(BUF-&gt;type == htons(UIP_ETHTYPE_ARP))
-    {
-      uip_arp_arpin();
-
-      // If the above function invocation resulted in data that
-      // should be sent out on the network, the global variable
-      // uip_len is set to a value &gt; 0.
-      if(uip_len &gt; 0)
-      {
-          EthernetPacketPut(ETH_BASE, uip_buf, uip_len);
-          uip_len = 0;
-      }
-    }
-  }  
-  
-  // Process TCP/IP Periodic Timer here.
-  if(periodic_timer &gt;= UIP_PERIODIC_TIMER_MS)
-  {
-    periodic_timer = 0;
-    for( temp = 0; temp &lt; UIP_CONNS; temp ++ )
-    {
-      uip_periodic(temp);
-
-      // If the above function invocation resulted in data that
-      // should be sent out on the network, the global variable
-      // uip_len is set to a value &gt; 0.
-      if(uip_len &gt; 0)
-      {
-        uip_arp_out();
-        EthernetPacketPut(ETH_BASE, uip_buf, uip_len);
-        uip_len = 0;
-      }
-    }
-
-#if UIP_UDP
-    for( temp = 0; temp &lt; UIP_UDP_CONNS; temp ++ )
-    {
-      uip_udp_periodic( temp );
-
-      // If the above function invocation resulted in data that
-      // should be sent out on the network, the global variable
-      // uip_len is set to a value &gt; 0.
-      if(uip_len &gt; 0)
-      {
-        uip_arp_out();
-        EthernetPacketPut(ETH_BASE, uip_buf, uip_len);
-        uip_len = 0;
-      }
-    }
-#endif // UIP_UDP
-  }  
-  
-  // Process ARP Timer here.
-  if(arp_timer &gt;= UIP_ARP_TIMER_MS)
-  {
-    arp_timer = 0;
-    uip_arp_timer();
-  }  
-}
-
-void SysTickIntHandler()
-{
-  // Indicate that a SysTick interrupt has occurred.
-  int_flags |= INT_TIMER;
-
-  // Generate a fake Ethernet interrupt.  This will perform the actual work
-  // of incrementing the timers and taking the appropriate actions.
-  HWREG(NVIC_SW_TRIG) |= INT_ETH - 16;
-}
-
-void EthernetIntHandler()
-{
-  u32 temp;
-  
-  // Read and Clear the interrupt.
-  temp = EthernetIntStatus(ETH_BASE, false);
-  EthernetIntClear(ETH_BASE, temp);
-
-  // Check to see if an RX Interrupt has occured.
-  if(temp &amp; ETH_INT_RX)
-  {
-    // Indicate that a packet has been received.
-    int_flags |= INT_ETH_RX;
-
-    // Disable Ethernet RX Interrupt.
-    EthernetIntDisable(ETH_BASE, ETH_INT_RX);
-  }
-  
-  uip_support_func();
-}
-
-#else // #ifdef BUILD_UIP
-
-// &quot;Dummy&quot; (empty) handler functions
-void EthernetIntHandler()
-{
-}
-
-void SysTickIntHandler()
-{
-}
-
-#endif // #ifdef BUILD_UIP

Modified: trunk/src/platform/lpc288x/build.h
===================================================================
--- trunk/src/platform/lpc288x/build.h	2008-09-15 21:54:46 UTC (rev 90)
+++ trunk/src/platform/lpc288x/build.h	2008-09-18 20:22:15 UTC (rev 91)
@@ -7,5 +7,6 @@
 #define BUILD_SHELL
 #define BUILD_ROMFS
 #define BUILD_TERM
+#define BUILD_CON_GENERIC
 
 #endif

Modified: trunk/src/platform/str9/build.h
===================================================================
--- trunk/src/platform/str9/build.h	2008-09-15 21:54:46 UTC (rev 90)
+++ trunk/src/platform/str9/build.h	2008-09-18 20:22:15 UTC (rev 91)
@@ -7,5 +7,6 @@
 #define BUILD_SHELL
 #define BUILD_ROMFS
 #define BUILD_TERM
+#define BUILD_CON_GENERIC
 
 #endif

Modified: trunk/src/shell.c
===================================================================
--- trunk/src/shell.c	2008-09-15 21:54:46 UTC (rev 90)
+++ trunk/src/shell.c	2008-09-18 20:22:15 UTC (rev 91)
@@ -10,6 +10,7 @@
 #include &lt;string.h&gt;
 #include &lt;stdlib.h&gt;
 #include &quot;platform.h&quot;
+#include &quot;elua_net.h&quot;
 
 #include &quot;build.h&quot;
 #ifdef BUILD_SHELL
@@ -17,6 +18,13 @@
 // Shell alternate ' ' char
 #define SHELL_ALT_SPACE           '\x07'
 
+// EOF is different in UART mode and TCP/IP mode
+#ifdef BUILD_CON_GENERIC
+  #define SHELL_EOF_STRING        &quot;CTRL+Z&quot;
+#else
+  #define SHELL_EOF_STRING        &quot;CTRL+D&quot;
+#endif
+
 // Shell command handler function
 typedef void( *p_shell_handler )( char* args );
 
@@ -43,7 +51,7 @@
   printf( &quot;  lua [args] - run Lua with the given arguments\n&quot; );
   printf( &quot;  recv - receive a file (XMODEM) and execute it\n&quot; );
   printf( &quot;  ver - print eLua version\n&quot; );
-  printf( &quot;  exit - exit from this shelll\n&quot; );
+  printf( &quot;  exit - exit from this shell\n&quot; );
 }
 
 // 'lua' handler
@@ -87,7 +95,7 @@
     }
   }
   lua_argv[ nargs + 1 ] = NULL;
-  printf( &quot;Press CTRL+Z to exit Lua\n&quot; );
+  printf( &quot;Press &quot; SHELL_EOF_STRING &quot; to exit Lua\n&quot; );
   lua_main( nargs + 1, lua_argv );  
   clearerr( stdin );
 }
@@ -267,7 +275,15 @@
     }
     // Check for 'exit' command
     if( pcmd-&gt;cmd &amp;&amp; !pcmd-&gt;handler_func )
+#ifdef BUILD_UIP
+    {
+      if( ( i = elua_net_get_telnet_socket() ) != -1 )
+        elua_net_close( i );
+    }
+#else
       break;
+#endif
+    
   }
   // Shell exit point
   if( shell_prog )

Modified: trunk/src/uip/uip-split.c
===================================================================
--- trunk/src/uip/uip-split.c	2008-09-15 21:54:46 UTC (rev 90)
+++ trunk/src/uip/uip-split.c	2008-09-18 20:22:15 UTC (rev 91)
@@ -43,9 +43,11 @@
 #include &quot;uip-fw.h&quot;
 #include &quot;uip_arch.h&quot;
 
+#define BUF ((struct uip_tcpip_hdr *)&amp;uip_buf[UIP_LLH_LEN])
 
+#define UIP_MIN_SIZE_TO_SPLIT       ( 10 + UIP_TCPIP_HLEN + UIP_LLH_LEN )
 
-#define BUF ((struct uip_tcpip_hdr *)&amp;uip_buf[UIP_LLH_LEN])
+extern void tcpip_output();
 
 /*-----------------------------------------------------------------------------*/
 void
@@ -55,9 +57,9 @@
 
   /* We only try to split maximum sized TCP segments. */
   if(BUF-&gt;proto == UIP_PROTO_TCP &amp;&amp;
-     uip_len == UIP_BUFSIZE - UIP_LLH_LEN) {
+     uip_len &gt;= UIP_MIN_SIZE_TO_SPLIT ) {
 
-    tcplen = uip_len - UIP_TCPIP_HLEN;
+    tcplen = uip_len - UIP_TCPIP_HLEN - UIP_LLH_LEN;
     /* Split the segment in two. If the original packet length was
        odd, we make the second packet one byte larger. */
     len1 = len2 = tcplen / 2;
@@ -90,6 +92,7 @@
     
     /* Transmit the first packet. */
     /*    uip_fw_output();*/
+    uip_len += UIP_LLH_LEN;
     tcpip_output();
 
     /* Now, create the second packet. To do this, it is not enough to
@@ -109,7 +112,7 @@
 #endif /* UIP_CONF_IPV6 */
     
     /*    uip_appdata += len1;*/
-    memcpy(uip_appdata, (u8_t *)uip_appdata + len1, len2);
+    memmove(uip_appdata, (u8_t *)uip_appdata + len1, len2);
 
     uip_add32(BUF-&gt;seqno, len1);
     BUF-&gt;seqno[0] = uip_acc32[0];
@@ -129,6 +132,7 @@
 
     /* Transmit the second packet. */
     /*    uip_fw_output();*/
+    uip_len += UIP_LLH_LEN;
     tcpip_output();
   } else {
     /*    uip_fw_output();*/

Modified: trunk/src/uip/uip.c
===================================================================
--- trunk/src/uip/uip.c	2008-09-15 21:54:46 UTC (rev 90)
+++ trunk/src/uip/uip.c	2008-09-18 20:22:15 UTC (rev 91)
@@ -1,1941 +1,1975 @@
-#include &quot;build.h&quot;
-#ifdef BUILD_UIP
-
-#define DEBUG_PRINTF( ... )
-
-/**
- * \defgroup uip The uIP TCP/IP stack
- * @{
- *
- * uIP is an implementation of the TCP/IP protocol stack intended for
- * small 8-bit and 16-bit microcontrollers.
- *
- * uIP provides the necessary protocols for Internet communication,
- * with a very small code footprint and RAM requirements - the uIP
- * code size is on the order of a few kilobytes and RAM usage is on
- * the order of a few hundred bytes.
- */
-
-/**
- * \file
- * The uIP TCP/IP stack code.
- * \author Adam Dunkels &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">adam at dunkels.com</A>&gt;
- */
-
-/*
- * Copyright (c) 2001-2003, Adam Dunkels.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote
- *    products derived from this software without specific prior
- *    written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
- * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
- * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- * This file is part of the uIP TCP/IP stack.
- *
- * $Id: uip.c,v 1.65 2006/06/11 21:46:39 adam Exp $
- *
- */
-
-/*
- * uIP is a small implementation of the IP, UDP and TCP protocols (as
- * well as some basic ICMP stuff). The implementation couples the IP,
- * UDP, TCP and the application layers very tightly. To keep the size
- * of the compiled code down, this code frequently uses the goto
- * statement. While it would be possible to break the uip_process()
- * function into many smaller functions, this would increase the code
- * size because of the overhead of parameter passing and the fact that
- * the optimier would not be as efficient.
- *
- * The principle is that we have a small buffer, called the uip_buf,
- * in which the device driver puts an incoming packet. The TCP/IP
- * stack parses the headers in the packet, and calls the
- * application. If the remote host has sent data to the application,
- * this data is present in the uip_buf and the application read the
- * data from there. It is up to the application to put this data into
- * a byte stream if needed. The application will not be fed with data
- * that is out of sequence.
- *
- * If the application whishes to send data to the peer, it should put
- * its data into the uip_buf. The uip_appdata pointer points to the
- * first available byte. The TCP/IP stack will calculate the
- * checksums, and fill in the necessary header fields and finally send
- * the packet back to the peer.
-*/
-
-#include &quot;uip.h&quot;
-#include &quot;uipopt.h&quot;
-#include &quot;uip_arch.h&quot;
-
-#if UIP_CONF_IPV6
-#include &quot;uip-neighbor.h&quot;
-#endif /* UIP_CONF_IPV6 */
-
-#include &lt;string.h&gt;
-
-/*---------------------------------------------------------------------------*/
-/* Variable definitions. */
-
-
-/* The IP address of this host. If it is defined to be fixed (by
-   setting UIP_FIXEDADDR to 1 in uipopt.h), the address is set
-   here. Otherwise, the address */
-#if UIP_FIXEDADDR &gt; 0
-const uip_ipaddr_t uip_hostaddr =
-  {HTONS((UIP_IPADDR0 &lt;&lt; 8) | UIP_IPADDR1),
-   HTONS((UIP_IPADDR2 &lt;&lt; 8) | UIP_IPADDR3)};
-const uip_ipaddr_t uip_draddr =
-  {HTONS((UIP_DRIPADDR0 &lt;&lt; 8) | UIP_DRIPADDR1),
-   HTONS((UIP_DRIPADDR2 &lt;&lt; 8) | UIP_DRIPADDR3)};
-const uip_ipaddr_t uip_netmask =
-  {HTONS((UIP_NETMASK0 &lt;&lt; 8) | UIP_NETMASK1),
-   HTONS((UIP_NETMASK2 &lt;&lt; 8) | UIP_NETMASK3)};
-#else
-uip_ipaddr_t uip_hostaddr, uip_draddr, uip_netmask;
-#endif /* UIP_FIXEDADDR */
-
-static const uip_ipaddr_t all_ones_addr =
-#if UIP_CONF_IPV6
-  {0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff};
-#else /* UIP_CONF_IPV6 */
-  {0xffff,0xffff};
-#endif /* UIP_CONF_IPV6 */
-static const uip_ipaddr_t all_zeroes_addr =
-#if UIP_CONF_IPV6
-  {0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000};
-#else /* UIP_CONF_IPV6 */
-  {0x0000,0x0000};
-#endif /* UIP_CONF_IPV6 */
-
-
-#if UIP_FIXEDETHADDR
-const struct uip_eth_addr uip_ethaddr = {{UIP_ETHADDR0,
-					  UIP_ETHADDR1,
-					  UIP_ETHADDR2,
-					  UIP_ETHADDR3,
-					  UIP_ETHADDR4,
-					  UIP_ETHADDR5}};
-#else
-struct uip_eth_addr uip_ethaddr = {{0,0,0,0,0,0}};
-#endif
-
-#ifndef UIP_CONF_EXTERNAL_BUFFER
-u8_t uip_buf[UIP_BUFSIZE + 2];   /* The packet buffer that contains
-				    incoming packets. */
-#endif /* UIP_CONF_EXTERNAL_BUFFER */
-
-void *uip_appdata;               /* The uip_appdata pointer points to
-				    application data. */
-void *uip_sappdata;              /* The uip_appdata pointer points to
-				    the application data which is to
-				    be sent. */
-#if UIP_URGDATA &gt; 0
-void *uip_urgdata;               /* The uip_urgdata pointer points to
-   				    urgent data (out-of-band data), if
-   				    present. */
-u16_t uip_urglen, uip_surglen;
-#endif /* UIP_URGDATA &gt; 0 */
-
-u16_t uip_len, uip_slen;
-                             /* The uip_len is either 8 or 16 bits,
-				depending on the maximum packet
-				size. */
-
-u8_t uip_flags;     /* The uip_flags variable is used for
-				communication between the TCP/IP stack
-				and the application program. */
-
-#if UIP_TCP
-struct uip_conn *uip_conn;   /* uip_conn always points to the current
-				connection. */
-
-struct uip_conn uip_conns[UIP_CONNS];
-                             /* The uip_conns array holds all TCP
-				connections. */
-u16_t uip_listenports[UIP_LISTENPORTS];
-                             /* The uip_listenports list all currently
-				listning ports. */
-#endif /* UIP_TCP */
-
-#if UIP_UDP
-struct uip_udp_conn *uip_udp_conn;
-struct uip_udp_conn uip_udp_conns[UIP_UDP_CONNS];
-#endif /* UIP_UDP */
-
-static u16_t ipid;           /* Ths ipid variable is an increasing
-				number that is used for the IP ID
-				field. */
-
-void uip_setipid(u16_t id) { ipid = id; }
-
-#if UIP_TCP
-static u8_t iss[4];          /* The iss variable is used for the TCP
-				initial sequence number. */
-#endif /* UIP_TCP */
-
-#if UIP_ACTIVE_OPEN
-static u16_t lastport;       /* Keeps track of the last port used for
-				a new connection. */
-#endif /* UIP_ACTIVE_OPEN */
-
-/* Temporary variables. */
-#if UIP_TCP
-u8_t uip_acc32[4];
-static u8_t c, opt;
-static u16_t tmp16;
-#endif /* UIP_TCP */
-
-/* Structures and definitions. */
-#define TCP_FIN 0x01
-#define TCP_SYN 0x02
-#define TCP_RST 0x04
-#define TCP_PSH 0x08
-#define TCP_ACK 0x10
-#define TCP_URG 0x20
-#define TCP_CTL 0x3f
-
-#define TCP_OPT_END     0   /* End of TCP options list */
-#define TCP_OPT_NOOP    1   /* &quot;No-operation&quot; TCP option */
-#define TCP_OPT_MSS     2   /* Maximum segment size TCP option */
-
-#define TCP_OPT_MSS_LEN 4   /* Length of TCP MSS option. */
-
-#define ICMP_ECHO_REPLY 0
-#define ICMP_ECHO       8
-
-#define ICMP6_ECHO_REPLY             129
-#define ICMP6_ECHO                   128
-#define ICMP6_NEIGHBOR_SOLICITATION  135
-#define ICMP6_NEIGHBOR_ADVERTISEMENT 136
-
-#define ICMP6_FLAG_S (1 &lt;&lt; 6)
-
-#define ICMP6_OPTION_SOURCE_LINK_ADDRESS 1
-#define ICMP6_OPTION_TARGET_LINK_ADDRESS 2
-
-
-/* Macros. */
-#define BUF ((struct uip_tcpip_hdr *)&amp;uip_buf[UIP_LLH_LEN])
-#define FBUF ((struct uip_tcpip_hdr *)&amp;uip_reassbuf[0])
-#define ICMPBUF ((struct uip_icmpip_hdr *)&amp;uip_buf[UIP_LLH_LEN])
-#define UDPBUF ((struct uip_udpip_hdr *)&amp;uip_buf[UIP_LLH_LEN])
-
-
-#if UIP_STATISTICS == 1
-struct uip_stats uip_stat;
-#define UIP_STAT(s) s
-#else
-#define UIP_STAT(s)
-#endif /* UIP_STATISTICS == 1 */
-
-#if UIP_LOGGING == 1
-#include &lt;stdio.h&gt;
-void uip_log(char *msg);
-#define UIP_LOG(m) uip_log(m)
-#else
-#define UIP_LOG(m)
-#endif /* UIP_LOGGING == 1 */
-
-#include &lt;stdio.h&gt;
-#undef DEBUG_PRINTF
-#undef UIP_LOG
-#define DEBUG_PRINTF( ... ) printf( __VA_ARGS__ )
-#define UIP_LOG( x ) printf( x )
-
-#if ! UIP_ARCH_ADD32 &amp;&amp; UIP_TCP
-void
-uip_add32(u8_t *op32, u16_t op16)
-{
-  uip_acc32[3] = op32[3] + (op16 &amp; 0xff);
-  uip_acc32[2] = op32[2] + (op16 &gt;&gt; 8);
-  uip_acc32[1] = op32[1];
-  uip_acc32[0] = op32[0];
-  
-  if(uip_acc32[2] &lt; (op16 &gt;&gt; 8)) {
-    ++uip_acc32[1];
-    if(uip_acc32[1] == 0) {
-      ++uip_acc32[0];
-    }
-  }
-  
-  
-  if(uip_acc32[3] &lt; (op16 &amp; 0xff)) {
-    ++uip_acc32[2];
-    if(uip_acc32[2] == 0) {
-      ++uip_acc32[1];
-      if(uip_acc32[1] == 0) {
-	++uip_acc32[0];
-      }
-    }
-  }
-}
-
-#endif /* ! UIP_ARCH_ADD32 &amp;&amp; UIP_TCP */
-
-#if ! UIP_ARCH_CHKSUM
-/*---------------------------------------------------------------------------*/
-static u16_t
-chksum(u16_t sum, const u8_t *data, u16_t len)
-{
-  u16_t t;
-  const u8_t *dataptr;
-  const u8_t *last_byte;
-
-  dataptr = data;
-  last_byte = data + len - 1;
-  
-  while(dataptr &lt; last_byte) {	/* At least two more bytes */
-    t = (dataptr[0] &lt;&lt; 8) + dataptr[1];
-    sum += t;
-    if(sum &lt; t) {
-      sum++;		/* carry */
-    }
-    dataptr += 2;
-  }
-  
-  if(dataptr == last_byte) {
-    t = (dataptr[0] &lt;&lt; 8) + 0;
-    sum += t;
-    if(sum &lt; t) {
-      sum++;		/* carry */
-    }
-  }
-
-  /* Return sum in host byte order. */
-  return sum;
-}
-/*---------------------------------------------------------------------------*/
-u16_t
-uip_chksum(u16_t *data, u16_t len)
-{
-  return htons(chksum(0, (u8_t *)data, len));
-}
-/*---------------------------------------------------------------------------*/
-#ifndef UIP_ARCH_IPCHKSUM
-u16_t
-uip_ipchksum(void)
-{
-  u16_t sum;
-
-  sum = chksum(0, &amp;uip_buf[UIP_LLH_LEN], UIP_IPH_LEN);
-  DEBUG_PRINTF(&quot;uip_ipchksum: sum 0x%04x\n&quot;, sum);
-  return (sum == 0) ? 0xffff : htons(sum);
-}
-#endif
-/*---------------------------------------------------------------------------*/
-#if UIP_CONF_IPV6 || UIP_TCP || UIP_UDP_CHECKSUMS
-static u16_t
-upper_layer_chksum(u8_t proto)
-{
-  u16_t upper_layer_len;
-  u16_t sum;
-  
-#if UIP_CONF_IPV6
-  upper_layer_len = (((u16_t)(BUF-&gt;len[0]) &lt;&lt; 8) + BUF-&gt;len[1]);
-#else /* UIP_CONF_IPV6 */
-  upper_layer_len = (((u16_t)(BUF-&gt;len[0]) &lt;&lt; 8) + BUF-&gt;len[1]) - UIP_IPH_LEN;
-#endif /* UIP_CONF_IPV6 */
-  
-  /* First sum pseudoheader. */
-  
-  /* IP protocol and length fields. This addition cannot carry. */
-  sum = upper_layer_len + proto;
-  /* Sum IP source and destination addresses. */
-  sum = chksum(sum, (u8_t *)&amp;BUF-&gt;srcipaddr[0], 2 * sizeof(uip_ipaddr_t));
-
-  /* Sum TCP header and data. */
-  sum = chksum(sum, &amp;uip_buf[UIP_IPH_LEN + UIP_LLH_LEN],
-	       upper_layer_len);
-    
-  return (sum == 0) ? 0xffff : htons(sum);
-}
-#endif /* UIP_CONF_IPV6 || UIP_TCP || UIP_UDP_CHECKSUMS */
-/*---------------------------------------------------------------------------*/
-#if UIP_CONF_IPV6
-u16_t
-uip_icmp6chksum(void)
-{
-  return upper_layer_chksum(UIP_PROTO_ICMP6);
-  
-}
-#endif /* UIP_CONF_IPV6 */
-/*---------------------------------------------------------------------------*/
-#if UIP_TCP
-u16_t
-uip_tcpchksum(void)
-{
-  return upper_layer_chksum(UIP_PROTO_TCP);
-}
-#endif /* UIP_TCP */
-/*---------------------------------------------------------------------------*/
-#if UIP_UDP_CHECKSUMS
-u16_t
-uip_udpchksum(void)
-{
-  return upper_layer_chksum(UIP_PROTO_UDP);
-}
-#endif /* UIP_UDP_CHECKSUMS */
-#endif /* UIP_ARCH_CHKSUM */
-/*---------------------------------------------------------------------------*/
-void
-uip_init(void)
-{
-#if UIP_TCP
-  for(c = 0; c &lt; UIP_LISTENPORTS; ++c) {
-    uip_listenports[c] = 0;
-  }
-  for(c = 0; c &lt; UIP_CONNS; ++c) {
-    uip_conns[c].tcpstateflags = UIP_CLOSED;
-  }
-#endif /* UIP_TCP */
-#if UIP_ACTIVE_OPEN
-  lastport = 1024;
-#endif /* UIP_ACTIVE_OPEN */
-
-#if UIP_UDP
-  for(c = 0; c &lt; UIP_UDP_CONNS; ++c) {
-    uip_udp_conns[c].lport = 0;
-  }
-#endif /* UIP_UDP */
-  
-
-  /* IPv4 initialization. */
-#if UIP_FIXEDADDR == 0
-  /*  uip_hostaddr[0] = uip_hostaddr[1] = 0;*/
-#endif /* UIP_FIXEDADDR */
-
-}
-/*---------------------------------------------------------------------------*/
-#if UIP_ACTIVE_OPEN &amp;&amp; UIP_TCP
-struct uip_conn *
-uip_connect(uip_ipaddr_t *ripaddr, u16_t rport)
-{
-  register struct uip_conn *conn, *cconn;
-  
-  /* Find an unused local port. */
- again:
-  ++lastport;
-
-  if(lastport &gt;= 32000) {
-    lastport = 4096;
-  }
-
-  /* Check if this port is already in use, and if so try to find
-     another one. */
-  for(c = 0; c &lt; UIP_CONNS; ++c) {
-    conn = &amp;uip_conns[c];
-    if(conn-&gt;tcpstateflags != UIP_CLOSED &amp;&amp;
-       conn-&gt;lport == htons(lastport)) {
-      goto again;
-    }
-  }
-
-  conn = 0;
-  for(c = 0; c &lt; UIP_CONNS; ++c) {
-    cconn = &amp;uip_conns[c];
-    if(cconn-&gt;tcpstateflags == UIP_CLOSED) {
-      conn = cconn;
-      break;
-    }
-    if(cconn-&gt;tcpstateflags == UIP_TIME_WAIT) {
-      if(conn == 0 ||
-	 cconn-&gt;timer &gt; conn-&gt;timer) {
-	conn = cconn;
-      }
-    }
-  }
-
-  if(conn == 0) {
-    return 0;
-  }
-  
-  conn-&gt;tcpstateflags = UIP_SYN_SENT;
-
-  conn-&gt;snd_nxt[0] = iss[0];
-  conn-&gt;snd_nxt[1] = iss[1];
-  conn-&gt;snd_nxt[2] = iss[2];
-  conn-&gt;snd_nxt[3] = iss[3];
-
-  conn-&gt;initialmss = conn-&gt;mss = UIP_TCP_MSS;
-  
-  conn-&gt;len = 1;   /* TCP length of the SYN is one. */
-  conn-&gt;nrtx = 0;
-  conn-&gt;timer = 1; /* Send the SYN next time around. */
-  conn-&gt;rto = UIP_RTO;
-  conn-&gt;sa = 0;
-  conn-&gt;sv = 16;   /* Initial value of the RTT variance. */
-  conn-&gt;lport = htons(lastport);
-  conn-&gt;rport = rport;
-  uip_ipaddr_copy(&amp;conn-&gt;ripaddr, ripaddr);
-  
-  return conn;
-}
-#endif /* UIP_ACTIVE_OPEN &amp;&amp; UIP_TCP */
-/*---------------------------------------------------------------------------*/
-#if UIP_UDP
-struct uip_udp_conn *
-uip_udp_new(uip_ipaddr_t *ripaddr, u16_t rport)
-{
-  register struct uip_udp_conn *conn;
-  
-  /* Find an unused local port. */
- again:
-  ++lastport;
-
-  if(lastport &gt;= 32000) {
-    lastport = 4096;
-  }
-  
-  for(c = 0; c &lt; UIP_UDP_CONNS; ++c) {
-    if(uip_udp_conns[c].lport == htons(lastport)) {
-      goto again;
-    }
-  }
-
-
-  conn = 0;
-  for(c = 0; c &lt; UIP_UDP_CONNS; ++c) {
-    if(uip_udp_conns[c].lport == 0) {
-      conn = &amp;uip_udp_conns[c];
-      break;
-    }
-  }
-
-  if(conn == 0) {
-    return 0;
-  }
-  
-  conn-&gt;lport = HTONS(lastport);
-  conn-&gt;rport = rport;
-  if(ripaddr == NULL) {
-    memset(conn-&gt;ripaddr, 0, sizeof(uip_ipaddr_t));
-  } else {
-    uip_ipaddr_copy(&amp;conn-&gt;ripaddr, ripaddr);
-  }
-  conn-&gt;ttl = UIP_TTL;
-  
-  return conn;
-}
-#endif /* UIP_UDP */
-/*---------------------------------------------------------------------------*/
-#if UIP_TCP
-void
-uip_unlisten(u16_t port)
-{
-  for(c = 0; c &lt; UIP_LISTENPORTS; ++c) {
-    if(uip_listenports[c] == port) {
-      uip_listenports[c] = 0;
-      return;
-    }
-  }
-}
-#endif /* UIP_TCP */
-/*---------------------------------------------------------------------------*/
-#if UIP_TCP
-void
-uip_listen(u16_t port)
-{
-  for(c = 0; c &lt; UIP_LISTENPORTS; ++c) {
-    if(uip_listenports[c] == 0) {
-      uip_listenports[c] = port;
-      return;
-    }
-  }
-}
-#endif /* UIP_TCP */
-/*---------------------------------------------------------------------------*/
-/* XXX: IP fragment reassembly: not well-tested. */
-
-#if UIP_REASSEMBLY &amp;&amp; !UIP_CONF_IPV6
-#define UIP_REASS_BUFSIZE (UIP_BUFSIZE - UIP_LLH_LEN)
-static u8_t uip_reassbuf[UIP_REASS_BUFSIZE];
-static u8_t uip_reassbitmap[UIP_REASS_BUFSIZE / (8 * 8)];
-static const u8_t bitmap_bits[8] = {0xff, 0x7f, 0x3f, 0x1f,
-				    0x0f, 0x07, 0x03, 0x01};
-static u16_t uip_reasslen;
-static u8_t uip_reassflags;
-#define UIP_REASS_FLAG_LASTFRAG 0x01
-static u8_t uip_reasstmr;
-
-#define IP_MF   0x20
-
-static u8_t
-uip_reass(void)
-{
-  u16_t offset, len;
-  u16_t i;
-
-  /* If ip_reasstmr is zero, no packet is present in the buffer, so we
-     write the IP header of the fragment into the reassembly
-     buffer. The timer is updated with the maximum age. */
-  if(uip_reasstmr == 0) {
-    memcpy(uip_reassbuf, &amp;BUF-&gt;vhl, UIP_IPH_LEN);
-    uip_reasstmr = UIP_REASS_MAXAGE;
-    uip_reassflags = 0;
-    /* Clear the bitmap. */
-    memset(uip_reassbitmap, 0, sizeof(uip_reassbitmap));
-  }
-
-  /* Check if the incoming fragment matches the one currently present
-     in the reasembly buffer. If so, we proceed with copying the
-     fragment into the buffer. */
-  if(BUF-&gt;srcipaddr[0] == FBUF-&gt;srcipaddr[0] &amp;&amp;
-     BUF-&gt;srcipaddr[1] == FBUF-&gt;srcipaddr[1] &amp;&amp;
-     BUF-&gt;destipaddr[0] == FBUF-&gt;destipaddr[0] &amp;&amp;
-     BUF-&gt;destipaddr[1] == FBUF-&gt;destipaddr[1] &amp;&amp;
-     BUF-&gt;ipid[0] == FBUF-&gt;ipid[0] &amp;&amp;
-     BUF-&gt;ipid[1] == FBUF-&gt;ipid[1]) {
-
-    len = (BUF-&gt;len[0] &lt;&lt; 8) + BUF-&gt;len[1] - (BUF-&gt;vhl &amp; 0x0f) * 4;
-    offset = (((BUF-&gt;ipoffset[0] &amp; 0x3f) &lt;&lt; 8) + BUF-&gt;ipoffset[1]) * 8;
-
-    /* If the offset or the offset + fragment length overflows the
-       reassembly buffer, we discard the entire packet. */
-    if(offset &gt; UIP_REASS_BUFSIZE ||
-       offset + len &gt; UIP_REASS_BUFSIZE) {
-      uip_reasstmr = 0;
-      goto nullreturn;
-    }
-
-    /* Copy the fragment into the reassembly buffer, at the right
-       offset. */
-    memcpy(&amp;uip_reassbuf[UIP_IPH_LEN + offset],
-	   (char *)BUF + (int)((BUF-&gt;vhl &amp; 0x0f) * 4),
-	   len);
-      
-    /* Update the bitmap. */
-    if(offset / (8 * 8) == (offset + len) / (8 * 8)) {
-      /* If the two endpoints are in the same byte, we only update
-	 that byte. */
-	     
-      uip_reassbitmap[offset / (8 * 8)] |=
-	     bitmap_bits[(offset / 8 ) &amp; 7] &amp;
-	     ~bitmap_bits[((offset + len) / 8 ) &amp; 7];
-    } else {
-      /* If the two endpoints are in different bytes, we update the
-	 bytes in the endpoints and fill the stuff inbetween with
-	 0xff. */
-      uip_reassbitmap[offset / (8 * 8)] |=
-	bitmap_bits[(offset / 8 ) &amp; 7];
-      for(i = 1 + offset / (8 * 8); i &lt; (offset + len) / (8 * 8); ++i) {
-	uip_reassbitmap[i] = 0xff;
-      }
-      uip_reassbitmap[(offset + len) / (8 * 8)] |=
-	~bitmap_bits[((offset + len) / 8 ) &amp; 7];
-    }
-    
-    /* If this fragment has the More Fragments flag set to zero, we
-       know that this is the last fragment, so we can calculate the
-       size of the entire packet. We also set the
-       IP_REASS_FLAG_LASTFRAG flag to indicate that we have received
-       the final fragment. */
-
-    if((BUF-&gt;ipoffset[0] &amp; IP_MF) == 0) {
-      uip_reassflags |= UIP_REASS_FLAG_LASTFRAG;
-      uip_reasslen = offset + len;
-    }
-    
-    /* Finally, we check if we have a full packet in the buffer. We do
-       this by checking if we have the last fragment and if all bits
-       in the bitmap are set. */
-    if(uip_reassflags &amp; UIP_REASS_FLAG_LASTFRAG) {
-      /* Check all bytes up to and including all but the last byte in
-	 the bitmap. */
-      for(i = 0; i &lt; uip_reasslen / (8 * 8) - 1; ++i) {
-	if(uip_reassbitmap[i] != 0xff) {
-	  goto nullreturn;
-	}
-      }
-      /* Check the last byte in the bitmap. It should contain just the
-	 right amount of bits. */
-      if(uip_reassbitmap[uip_reasslen / (8 * 8)] !=
-	 (u8_t)~bitmap_bits[uip_reasslen / 8 &amp; 7]) {
-	goto nullreturn;
-      }
-
-      /* If we have come this far, we have a full packet in the
-	 buffer, so we allocate a pbuf and copy the packet into it. We
-	 also reset the timer. */
-      uip_reasstmr = 0;
-      memcpy(BUF, FBUF, uip_reasslen);
-
-      /* Pretend to be a &quot;normal&quot; (i.e., not fragmented) IP packet
-	 from now on. */
-      BUF-&gt;ipoffset[0] = BUF-&gt;ipoffset[1] = 0;
-      BUF-&gt;len[0] = uip_reasslen &gt;&gt; 8;
-      BUF-&gt;len[1] = uip_reasslen &amp; 0xff;
-      BUF-&gt;ipchksum = 0;
-      BUF-&gt;ipchksum = ~(uip_ipchksum());
-
-      return uip_reasslen;
-    }
-  }
-
- nullreturn:
-  return 0;
-}
-#endif /* UIP_REASSEMBLY */
-/*---------------------------------------------------------------------------*/
-#if UIP_TCP
-static void
-uip_add_rcv_nxt(u16_t n)
-{
-  uip_add32(uip_conn-&gt;rcv_nxt, n);
-  uip_conn-&gt;rcv_nxt[0] = uip_acc32[0];
-  uip_conn-&gt;rcv_nxt[1] = uip_acc32[1];
-  uip_conn-&gt;rcv_nxt[2] = uip_acc32[2];
-  uip_conn-&gt;rcv_nxt[3] = uip_acc32[3];
-}
-#endif /* UIP_TCP */
-/*---------------------------------------------------------------------------*/
-void
-uip_process(u8_t flag)
-{
-#if UIP_TCP
-  register struct uip_conn *uip_connr = uip_conn;
-#endif /* UIP_TCP */
-
-#if UIP_UDP
-  if(flag == UIP_UDP_SEND_CONN) {
-    goto udp_send;
-  }
-#endif /* UIP_UDP */
-  
-  uip_sappdata = uip_appdata = &amp;uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN];
-
-  /* Check if we were invoked because of a poll request for a
-     particular connection. */
-#if UIP_TCP
-  if(flag == UIP_POLL_REQUEST) {
-    if((uip_connr-&gt;tcpstateflags &amp; UIP_TS_MASK) == UIP_ESTABLISHED &amp;&amp;
-       !uip_outstanding(uip_connr)) {
-	uip_flags = UIP_POLL;
-	UIP_APPCALL();
-	goto appsend;
-    }
-    goto drop;
-    
-    /* Check if we were invoked because of the perodic timer fireing. */
-  } else if(flag == UIP_TIMER) {
-#if UIP_REASSEMBLY
-    if(uip_reasstmr != 0) {
-      --uip_reasstmr;
-    }
-#endif /* UIP_REASSEMBLY */
-    /* Increase the initial sequence number. */
-    if(++iss[3] == 0) {
-      if(++iss[2] == 0) {
-	if(++iss[1] == 0) {
-	  ++iss[0];
-	}
-      }
-    }
-
-    /* Reset the length variables. */
-    uip_len = 0;
-    uip_slen = 0;
-
-    /* Check if the connection is in a state in which we simply wait
-       for the connection to time out. If so, we increase the
-       connection's timer and remove the connection if it times
-       out. */
-    if(uip_connr-&gt;tcpstateflags == UIP_TIME_WAIT ||
-       uip_connr-&gt;tcpstateflags == UIP_FIN_WAIT_2) {
-      ++(uip_connr-&gt;timer);
-      if(uip_connr-&gt;timer == UIP_TIME_WAIT_TIMEOUT) {
-	uip_connr-&gt;tcpstateflags = UIP_CLOSED;
-      }
-    } else if(uip_connr-&gt;tcpstateflags != UIP_CLOSED) {
-      /* If the connection has outstanding data, we increase the
-	 connection's timer and see if it has reached the RTO value
-	 in which case we retransmit. */
-      if(uip_outstanding(uip_connr)) {
-	if(uip_connr-&gt;timer-- == 0) {
-	  if(uip_connr-&gt;nrtx == UIP_MAXRTX ||
-	     ((uip_connr-&gt;tcpstateflags == UIP_SYN_SENT ||
-	       uip_connr-&gt;tcpstateflags == UIP_SYN_RCVD) &amp;&amp;
-	      uip_connr-&gt;nrtx == UIP_MAXSYNRTX)) {
-	    uip_connr-&gt;tcpstateflags = UIP_CLOSED;
-
-	    /* We call UIP_APPCALL() with uip_flags set to
-	       UIP_TIMEDOUT to inform the application that the
-	       connection has timed out. */
-	    uip_flags = UIP_TIMEDOUT;
-	    UIP_APPCALL();
-
-	    /* We also send a reset packet to the remote host. */
-	    BUF-&gt;flags = TCP_RST | TCP_ACK;
-	    goto tcp_send_nodata;
-	  }
-
-	  /* Exponential backoff. */
-	  uip_connr-&gt;timer = UIP_RTO &lt;&lt; (uip_connr-&gt;nrtx &gt; 4?
-					 4:
-					 uip_connr-&gt;nrtx);
-	  ++(uip_connr-&gt;nrtx);
-	  
-	  /* Ok, so we need to retransmit. We do this differently
-	     depending on which state we are in. In ESTABLISHED, we
-	     call upon the application so that it may prepare the
-	     data for the retransmit. In SYN_RCVD, we resend the
-	     SYNACK that we sent earlier and in LAST_ACK we have to
-	     retransmit our FINACK. */
-	  UIP_STAT(++uip_stat.tcp.rexmit);
-	  switch(uip_connr-&gt;tcpstateflags &amp; UIP_TS_MASK) {
-	  case UIP_SYN_RCVD:
-	    /* In the SYN_RCVD state, we should retransmit our
-               SYNACK. */
-	    goto tcp_send_synack;
-	    
-#if UIP_ACTIVE_OPEN
-	  case UIP_SYN_SENT:
-	    /* In the SYN_SENT state, we retransmit out SYN. */
-	    BUF-&gt;flags = 0;
-	    goto tcp_send_syn;
-#endif /* UIP_ACTIVE_OPEN */
-	    
-	  case UIP_ESTABLISHED:
-	    /* In the ESTABLISHED state, we call upon the application
-               to do the actual retransmit after which we jump into
-               the code for sending out the packet (the apprexmit
-               label). */
-	    uip_flags = UIP_REXMIT;
-	    UIP_APPCALL();
-	    goto apprexmit;
-	    
-	  case UIP_FIN_WAIT_1:
-	  case UIP_CLOSING:
-	  case UIP_LAST_ACK:
-	    /* In all these states we should retransmit a FINACK. */
-	    goto tcp_send_finack;
-	    
-	  }
-	}
-      } else if((uip_connr-&gt;tcpstateflags &amp; UIP_TS_MASK) == UIP_ESTABLISHED) {
-	/* If there was no need for a retransmission, we poll the
-           application for new data. */
-	uip_flags = UIP_POLL;
-	UIP_APPCALL();
-	goto appsend;
-      }
-    }
-    goto drop;
-  }
-#endif /* UIP_TCP */
-#if UIP_UDP
-  if(flag == UIP_UDP_TIMER) {
-    if(uip_udp_conn-&gt;lport != 0) {
-#if UIP_TCP
-      uip_conn = NULL;
-#endif /* UIP_TCP */
-      uip_sappdata = uip_appdata = &amp;uip_buf[UIP_LLH_LEN + UIP_IPUDPH_LEN];
-      uip_len = uip_slen = 0;
-      uip_flags = UIP_POLL;
-      UIP_UDP_APPCALL();
-      goto udp_send;
-    } else {
-      goto drop;
-    }
-  }
-#endif
-
-  /* This is where the input processing starts. */
-  UIP_STAT(++uip_stat.ip.recv);
-
-  /* Start of IP input header processing code. */
-  
-#if UIP_CONF_IPV6
-  /* Check validity of the IP header. */
-  if((BUF-&gt;vtc &amp; 0xf0) != 0x60)  { /* IP version and header length. */
-    UIP_STAT(++uip_stat.ip.drop);
-    UIP_STAT(++uip_stat.ip.vhlerr);
-    UIP_LOG(&quot;ipv6: invalid version.&quot;);
-    goto drop;
-  }
-#else /* UIP_CONF_IPV6 */
-  /* Check validity of the IP header. */
-  if(BUF-&gt;vhl != 0x45)  { /* IP version and header length. */
-    UIP_STAT(++uip_stat.ip.drop);
-    UIP_STAT(++uip_stat.ip.vhlerr);
-    UIP_LOG(&quot;ip: invalid version or header length.&quot;);
-    goto drop;
-  }
-#endif /* UIP_CONF_IPV6 */
-  
-  /* Check the size of the packet. If the size reported to us in
-     uip_len is smaller the size reported in the IP header, we assume
-     that the packet has been corrupted in transit. If the size of
-     uip_len is larger than the size reported in the IP packet header,
-     the packet has been padded and we set uip_len to the correct
-     value.. */
-
-  if((BUF-&gt;len[0] &lt;&lt; 8) + BUF-&gt;len[1] &lt;= uip_len) {
-    uip_len = (BUF-&gt;len[0] &lt;&lt; 8) + BUF-&gt;len[1];
-#if UIP_CONF_IPV6
-    uip_len += 40; /* The length reported in the IPv6 header is the
-		      length of the payload that follows the
-		      header. However, uIP uses the uip_len variable
-		      for holding the size of the entire packet,
-		      including the IP header. For IPv4 this is not a
-		      problem as the length field in the IPv4 header
-		      contains the length of the entire packet. But
-		      for IPv6 we need to add the size of the IPv6
-		      header (40 bytes). */
-#endif /* UIP_CONF_IPV6 */
-  } else {
-    UIP_LOG(&quot;ip: packet shorter than reported in IP header.&quot;);
-    goto drop;
-  }
-
-#if !UIP_CONF_IPV6
-  /* Check the fragment flag. */
-  if((BUF-&gt;ipoffset[0] &amp; 0x3f) != 0 ||
-     BUF-&gt;ipoffset[1] != 0) {
-#if UIP_REASSEMBLY
-    uip_len = uip_reass();
-    if(uip_len == 0) {
-      goto drop;
-    }
-#else /* UIP_REASSEMBLY */
-    UIP_STAT(++uip_stat.ip.drop);
-    UIP_STAT(++uip_stat.ip.fragerr);
-    UIP_LOG(&quot;ip: fragment dropped.&quot;);
-    goto drop;
-#endif /* UIP_REASSEMBLY */
-  }
-#endif /* UIP_CONF_IPV6 */
-
-  if(uip_ipaddr_cmp(uip_hostaddr, all_zeroes_addr)) {
-    /* If we are configured to use ping IP address configuration and
-       hasn't been assigned an IP address yet, we accept all ICMP
-       packets. */
-#if UIP_PINGADDRCONF &amp;&amp; !UIP_CONF_IPV6
-    if(BUF-&gt;proto == UIP_PROTO_ICMP) {
-      UIP_LOG(&quot;ip: possible ping config packet received.&quot;);
-      goto icmp_input;
-    } else {
-      UIP_LOG(&quot;ip: packet dropped since no address assigned.&quot;);
-      goto drop;
-    }
-#endif /* UIP_PINGADDRCONF */
-
-  } else {
-    /* If IP broadcast support is configured, we check for a broadcast
-       UDP packet, which may be destined to us. */
-#if UIP_BROADCAST
-    DEBUG_PRINTF(&quot;UDP IP checksum 0x%04x\n&quot;, uip_ipchksum());
-    if(BUF-&gt;proto == UIP_PROTO_UDP &amp;&amp;
-       uip_ipaddr_cmp(BUF-&gt;destipaddr, all_ones_addr)
-       /*&amp;&amp;
-	 uip_ipchksum() == 0xffff*/) {
-      goto udp_input;
-    }
-#endif /* UIP_BROADCAST */
-    
-    /* Check if the packet is destined for our IP address. */
-#if !UIP_CONF_IPV6
-    if(!uip_ipaddr_cmp(BUF-&gt;destipaddr, uip_hostaddr)) {
-      UIP_STAT(++uip_stat.ip.drop);
-      goto drop;
-    }
-#else /* UIP_CONF_IPV6 */
-    /* For IPv6, packet reception is a little trickier as we need to
-       make sure that we listen to certain multicast addresses (all
-       hosts multicast address, and the solicited-node multicast
-       address) as well. However, we will cheat here and accept all
-       multicast packets that are sent to the ff02::/16 addresses. */
-    if(!uip_ipaddr_cmp(BUF-&gt;destipaddr, uip_hostaddr) &amp;&amp;
-       BUF-&gt;destipaddr[0] != HTONS(0xff02)) {
-      UIP_STAT(++uip_stat.ip.drop);
-      goto drop;
-    }
-#endif /* UIP_CONF_IPV6 */
-  }
-
-#if !UIP_CONF_IPV6
-  if(uip_ipchksum() != 0xffff) { /* Compute and check the IP header
-				    checksum. */
-    UIP_STAT(++uip_stat.ip.drop);
-    UIP_STAT(++uip_stat.ip.chkerr);
-    UIP_LOG(&quot;ip: bad checksum.&quot;);
-    goto drop;
-  }
-#endif /* UIP_CONF_IPV6 */
-
-#if UIP_TCP
-  if(BUF-&gt;proto == UIP_PROTO_TCP) { /* Check for TCP packet. If so,
-				       proceed with TCP input
-				       processing. */
-    goto tcp_input;
-  }
-#endif /* UIP_TCP */
-
-#if UIP_UDP
-  if(BUF-&gt;proto == UIP_PROTO_UDP) {
-    goto udp_input;
-  }
-#endif /* UIP_UDP */
-
-#if !UIP_CONF_IPV6
-  /* ICMPv4 processing code follows. */
-  if(BUF-&gt;proto != UIP_PROTO_ICMP) { /* We only allow ICMP packets from
-					here. */
-    UIP_STAT(++uip_stat.ip.drop);
-    UIP_STAT(++uip_stat.ip.protoerr);
-    UIP_LOG(&quot;ip: neither tcp nor icmp.&quot;);
-    goto drop;
-  }
-
-#if UIP_PINGADDRCONF
- icmp_input:
-#endif /* UIP_PINGADDRCONF */
-  UIP_STAT(++uip_stat.icmp.recv);
-
-  /* ICMP echo (i.e., ping) processing. This is simple, we only change
-     the ICMP type from ECHO to ECHO_REPLY and adjust the ICMP
-     checksum before we return the packet. */
-  if(ICMPBUF-&gt;type != ICMP_ECHO) {
-    UIP_STAT(++uip_stat.icmp.drop);
-    UIP_STAT(++uip_stat.icmp.typeerr);
-    UIP_LOG(&quot;icmp: not icmp echo.&quot;);
-    goto drop;
-  }
-
-  /* If we are configured to use ping IP address assignment, we use
-     the destination IP address of this ping packet and assign it to
-     ourself. */
-#if UIP_PINGADDRCONF
-  if((uip_hostaddr[0] | uip_hostaddr[1]) == 0) {
-    uip_hostaddr[0] = BUF-&gt;destipaddr[0];
-    uip_hostaddr[1] = BUF-&gt;destipaddr[1];
-  }
-#endif /* UIP_PINGADDRCONF */
-
-  ICMPBUF-&gt;type = ICMP_ECHO_REPLY;
-
-  if(ICMPBUF-&gt;icmpchksum &gt;= HTONS(0xffff - (ICMP_ECHO &lt;&lt; 8))) {
-    ICMPBUF-&gt;icmpchksum += HTONS(ICMP_ECHO &lt;&lt; 8) + 1;
-  } else {
-    ICMPBUF-&gt;icmpchksum += HTONS(ICMP_ECHO &lt;&lt; 8);
-  }
-
-  /* Swap IP addresses. */
-  uip_ipaddr_copy(BUF-&gt;destipaddr, BUF-&gt;srcipaddr);
-  uip_ipaddr_copy(BUF-&gt;srcipaddr, uip_hostaddr);
-
-  UIP_STAT(++uip_stat.icmp.sent);
-  goto send;
-
-  /* End of IPv4 input header processing code. */
-#else /* !UIP_CONF_IPV6 */
-
-  /* This is IPv6 ICMPv6 processing code. */
-  DEBUG_PRINTF(&quot;icmp6_input: length %d\n&quot;, uip_len);
-
-  if(BUF-&gt;proto != UIP_PROTO_ICMP6) { /* We only allow ICMPv6 packets from
-					 here. */
-    UIP_STAT(++uip_stat.ip.drop);
-    UIP_STAT(++uip_stat.ip.protoerr);
-    UIP_LOG(&quot;ip: neither tcp nor icmp6.&quot;);
-    goto drop;
-  }
-
-  UIP_STAT(++uip_stat.icmp.recv);
-
-  /* If we get a neighbor solicitation for our address we should send
-     a neighbor advertisement message back. */
-  if(ICMPBUF-&gt;type == ICMP6_NEIGHBOR_SOLICITATION) {
-    if(uip_ipaddr_cmp(ICMPBUF-&gt;icmp6data, uip_hostaddr)) {
-
-      if(ICMPBUF-&gt;options[0] == ICMP6_OPTION_SOURCE_LINK_ADDRESS) {
-	/* Save the sender's address in our neighbor list. */
-	uip_neighbor_add(ICMPBUF-&gt;srcipaddr, &amp;(ICMPBUF-&gt;options[2]));
-      }
-      
-      /* We should now send a neighbor advertisement back to where the
-	 neighbor solicication came from. */
-      ICMPBUF-&gt;type = ICMP6_NEIGHBOR_ADVERTISEMENT;
-      ICMPBUF-&gt;flags = ICMP6_FLAG_S; /* Solicited flag. */
-      
-      ICMPBUF-&gt;reserved1 = ICMPBUF-&gt;reserved2 = ICMPBUF-&gt;reserved3 = 0;
-      
-      uip_ipaddr_copy(ICMPBUF-&gt;destipaddr, ICMPBUF-&gt;srcipaddr);
-      uip_ipaddr_copy(ICMPBUF-&gt;srcipaddr, uip_hostaddr);
-      ICMPBUF-&gt;options[0] = ICMP6_OPTION_TARGET_LINK_ADDRESS;
-      ICMPBUF-&gt;options[1] = 1;  /* Options length, 1 = 8 bytes. */
-      memcpy(&amp;(ICMPBUF-&gt;options[2]), &amp;uip_ethaddr, sizeof(uip_ethaddr));
-      ICMPBUF-&gt;icmpchksum = 0;
-      ICMPBUF-&gt;icmpchksum = ~uip_icmp6chksum();
-      goto send;
-      
-    }
-    goto drop;
-  } else if(ICMPBUF-&gt;type == ICMP6_ECHO) {
-    /* ICMP echo (i.e., ping) processing. This is simple, we only
-       change the ICMP type from ECHO to ECHO_REPLY and update the
-       ICMP checksum before we return the packet. */
-
-    ICMPBUF-&gt;type = ICMP6_ECHO_REPLY;
-    
-    uip_ipaddr_copy(BUF-&gt;destipaddr, BUF-&gt;srcipaddr);
-    uip_ipaddr_copy(BUF-&gt;srcipaddr, uip_hostaddr);
-    ICMPBUF-&gt;icmpchksum = 0;
-    ICMPBUF-&gt;icmpchksum = ~uip_icmp6chksum();
-    
-    UIP_STAT(++uip_stat.icmp.sent);
-    goto send;
-  } else {
-    DEBUG_PRINTF(&quot;Unknown icmp6 message type %d\n&quot;, ICMPBUF-&gt;type);
-    UIP_STAT(++uip_stat.icmp.drop);
-    UIP_STAT(++uip_stat.icmp.typeerr);
-    UIP_LOG(&quot;icmp: unknown ICMP message.&quot;);
-    goto drop;
-  }
-
-  /* End of IPv6 ICMP processing. */
-  
-#endif /* !UIP_CONF_IPV6 */
-
-#if UIP_UDP
-  /* UDP input processing. */
- udp_input:
-  /* UDP processing is really just a hack. We don't do anything to the
-     UDP/IP headers, but let the UDP application do all the hard
-     work. If the application sets uip_slen, it has a packet to
-     send. */
-#if UIP_UDP_CHECKSUMS
-  uip_len = uip_len - UIP_IPUDPH_LEN;
-  uip_appdata = &amp;uip_buf[UIP_LLH_LEN + UIP_IPUDPH_LEN];
-  if(UDPBUF-&gt;udpchksum != 0 &amp;&amp; uip_udpchksum() != 0xffff) {
-    UIP_STAT(++uip_stat.udp.drop);
-    UIP_STAT(++uip_stat.udp.chkerr);
-    UIP_LOG(&quot;udp: bad checksum.&quot;);
-    goto drop;
-  }
-#else /* UIP_UDP_CHECKSUMS */
-  uip_len = uip_len - UIP_IPUDPH_LEN;
-#endif /* UIP_UDP_CHECKSUMS */
-
-  /* Demultiplex this UDP packet between the UDP &quot;connections&quot;. */
-  for(uip_udp_conn = &amp;uip_udp_conns[0];
-      uip_udp_conn &lt; &amp;uip_udp_conns[UIP_UDP_CONNS];
-      ++uip_udp_conn) {
-    /* If the local UDP port is non-zero, the connection is considered
-       to be used. If so, the local port number is checked against the
-       destination port number in the received packet. If the two port
-       numbers match, the remote port number is checked if the
-       connection is bound to a remote port. Finally, if the
-       connection is bound to a remote IP address, the source IP
-       address of the packet is checked. */
-    if(uip_udp_conn-&gt;lport != 0 &amp;&amp;
-       UDPBUF-&gt;destport == uip_udp_conn-&gt;lport &amp;&amp;
-       (uip_udp_conn-&gt;rport == 0 ||
-        UDPBUF-&gt;srcport == uip_udp_conn-&gt;rport ||
-        uip_udp_conn-&gt;rport == HTONS(69)) &amp;&amp;
-       (uip_ipaddr_cmp(uip_udp_conn-&gt;ripaddr, all_zeroes_addr) ||
-	uip_ipaddr_cmp(uip_udp_conn-&gt;ripaddr, all_ones_addr) ||
-	uip_ipaddr_cmp(BUF-&gt;srcipaddr, uip_udp_conn-&gt;ripaddr))) {
-      goto udp_found;
-    }
-  }
-  UIP_LOG(&quot;udp: no matching connection found&quot;);
-  goto drop;
-  
- udp_found:
-#if UIP_TCP
-  uip_conn = NULL;
-#endif /* UIP_TCP */
-  uip_flags = UIP_NEWDATA;
-  uip_sappdata = uip_appdata = &amp;uip_buf[UIP_LLH_LEN + UIP_IPUDPH_LEN];
-  uip_slen = 0;
-  UIP_UDP_APPCALL();
- udp_send:
-  if(uip_slen == 0) {
-    goto drop;
-  }
-  uip_len = uip_slen + UIP_IPUDPH_LEN;
-
-#if UIP_CONF_IPV6
-  /* For IPv6, the IP length field does not include the IPv6 IP header
-     length. */
-  BUF-&gt;len[0] = ((uip_len - UIP_IPH_LEN) &gt;&gt; 8);
-  BUF-&gt;len[1] = ((uip_len - UIP_IPH_LEN) &amp; 0xff);
-#else /* UIP_CONF_IPV6 */
-  BUF-&gt;len[0] = (uip_len &gt;&gt; 8);
-  BUF-&gt;len[1] = (uip_len &amp; 0xff);
-#endif /* UIP_CONF_IPV6 */
-
-  BUF-&gt;ttl = uip_udp_conn-&gt;ttl;
-  BUF-&gt;proto = UIP_PROTO_UDP;
-
-  UDPBUF-&gt;udplen = HTONS(uip_slen + UIP_UDPH_LEN);
-  UDPBUF-&gt;udpchksum = 0;
-
-  BUF-&gt;srcport  = uip_udp_conn-&gt;lport;
-  BUF-&gt;destport = uip_udp_conn-&gt;rport;
-
-  uip_ipaddr_copy(BUF-&gt;srcipaddr, uip_hostaddr);
-  uip_ipaddr_copy(BUF-&gt;destipaddr, uip_udp_conn-&gt;ripaddr);
-   
-  uip_appdata = &amp;uip_buf[UIP_LLH_LEN + UIP_IPTCPH_LEN];
-
-#if UIP_UDP_CHECKSUMS
-  /* Calculate UDP checksum. */
-  UDPBUF-&gt;udpchksum = ~(uip_udpchksum());
-  if(UDPBUF-&gt;udpchksum == 0) {
-    UDPBUF-&gt;udpchksum = 0xffff;
-  }
-#endif /* UIP_UDP_CHECKSUMS */
-  
-  goto ip_send_nolen;
-#endif /* UIP_UDP */
-  
-  /* TCP input processing. */
-#if UIP_TCP
- tcp_input:
-  UIP_STAT(++uip_stat.tcp.recv);
-
-  /* Start of TCP input header processing code. */
-  
-  if(uip_tcpchksum() != 0xffff) {   /* Compute and check the TCP
-				       checksum. */
-    UIP_STAT(++uip_stat.tcp.drop);
-    UIP_STAT(++uip_stat.tcp.chkerr);
-    UIP_LOG(&quot;tcp: bad checksum.&quot;);
-    goto drop;
-  }
-  
-  
-  /* Demultiplex this segment. */
-  /* First check any active connections. */
-  for(uip_connr = &amp;uip_conns[0]; uip_connr &lt;= &amp;uip_conns[UIP_CONNS - 1];
-      ++uip_connr) {
-    if(uip_connr-&gt;tcpstateflags != UIP_CLOSED &amp;&amp;
-       BUF-&gt;destport == uip_connr-&gt;lport &amp;&amp;
-       BUF-&gt;srcport == uip_connr-&gt;rport &amp;&amp;
-       uip_ipaddr_cmp(BUF-&gt;srcipaddr, uip_connr-&gt;ripaddr)) {
-      goto found;
-    }
-  }
-
-  /* If we didn't find and active connection that expected the packet,
-     either this packet is an old duplicate, or this is a SYN packet
-     destined for a connection in LISTEN. If the SYN flag isn't set,
-     it is an old packet and we send a RST. */
-  if((BUF-&gt;flags &amp; TCP_CTL) != TCP_SYN) {
-    goto reset;
-  }
-  
-  tmp16 = BUF-&gt;destport;
-  /* Next, check listening connections. */
-  for(c = 0; c &lt; UIP_LISTENPORTS; ++c) {
-    if(tmp16 == uip_listenports[c])
-      goto found_listen;
-  }
-  
-  /* No matching connection found, so we send a RST packet. */
-  UIP_STAT(++uip_stat.tcp.synrst);
- reset:
-
-  /* We do not send resets in response to resets. */
-  if(BUF-&gt;flags &amp; TCP_RST) {
-    goto drop;
-  }
-
-  UIP_STAT(++uip_stat.tcp.rst);
-  
-  BUF-&gt;flags = TCP_RST | TCP_ACK;
-  uip_len = UIP_IPTCPH_LEN;
-  BUF-&gt;tcpoffset = 5 &lt;&lt; 4;
-
-  /* Flip the seqno and ackno fields in the TCP header. */
-  c = BUF-&gt;seqno[3];
-  BUF-&gt;seqno[3] = BUF-&gt;ackno[3];
-  BUF-&gt;ackno[3] = c;
-  
-  c = BUF-&gt;seqno[2];
-  BUF-&gt;seqno[2] = BUF-&gt;ackno[2];
-  BUF-&gt;ackno[2] = c;
-  
-  c = BUF-&gt;seqno[1];
-  BUF-&gt;seqno[1] = BUF-&gt;ackno[1];
-  BUF-&gt;ackno[1] = c;
-  
-  c = BUF-&gt;seqno[0];
-  BUF-&gt;seqno[0] = BUF-&gt;ackno[0];
-  BUF-&gt;ackno[0] = c;
-
-  /* We also have to increase the sequence number we are
-     acknowledging. If the least significant byte overflowed, we need
-     to propagate the carry to the other bytes as well. */
-  if(++BUF-&gt;ackno[3] == 0) {
-    if(++BUF-&gt;ackno[2] == 0) {
-      if(++BUF-&gt;ackno[1] == 0) {
-	++BUF-&gt;ackno[0];
-      }
-    }
-  }
- 
-  /* Swap port numbers. */
-  tmp16 = BUF-&gt;srcport;
-  BUF-&gt;srcport = BUF-&gt;destport;
-  BUF-&gt;destport = tmp16;
-  
-  /* Swap IP addresses. */
-  uip_ipaddr_copy(BUF-&gt;destipaddr, BUF-&gt;srcipaddr);
-  uip_ipaddr_copy(BUF-&gt;srcipaddr, uip_hostaddr);
-  
-  /* And send out the RST packet! */
-  goto tcp_send_noconn;
-
-  /* This label will be jumped to if we matched the incoming packet
-     with a connection in LISTEN. In that case, we should create a new
-     connection and send a SYNACK in return. */
- found_listen:
-  /* First we check if there are any connections avaliable. Unused
-     connections are kept in the same table as used connections, but
-     unused ones have the tcpstate set to CLOSED. Also, connections in
-     TIME_WAIT are kept track of and we'll use the oldest one if no
-     CLOSED connections are found. Thanks to Eddie C. Dost for a very
-     nice algorithm for the TIME_WAIT search. */
-  uip_connr = 0;
-  for(c = 0; c &lt; UIP_CONNS; ++c) {
-    if(uip_conns[c].tcpstateflags == UIP_CLOSED) {
-      uip_connr = &amp;uip_conns[c];
-      break;
-    }
-    if(uip_conns[c].tcpstateflags == UIP_TIME_WAIT) {
-      if(uip_connr == 0 ||
-	 uip_conns[c].timer &gt; uip_connr-&gt;timer) {
-	uip_connr = &amp;uip_conns[c];
-      }
-    }
-  }
-
-  if(uip_connr == 0) {
-    /* All connections are used already, we drop packet and hope that
-       the remote end will retransmit the packet at a time when we
-       have more spare connections. */
-    UIP_STAT(++uip_stat.tcp.syndrop);
-    UIP_LOG(&quot;tcp: found no unused connections.&quot;);
-    goto drop;
-  }
-  uip_conn = uip_connr;
-  
-  /* Fill in the necessary fields for the new connection. */
-  uip_connr-&gt;rto = uip_connr-&gt;timer = UIP_RTO;
-  uip_connr-&gt;sa = 0;
-  uip_connr-&gt;sv = 4;
-  uip_connr-&gt;nrtx = 0;
-  uip_connr-&gt;lport = BUF-&gt;destport;
-  uip_connr-&gt;rport = BUF-&gt;srcport;
-  uip_ipaddr_copy(uip_connr-&gt;ripaddr, BUF-&gt;srcipaddr);
-  uip_connr-&gt;tcpstateflags = UIP_SYN_RCVD;
-
-  uip_connr-&gt;snd_nxt[0] = iss[0];
-  uip_connr-&gt;snd_nxt[1] = iss[1];
-  uip_connr-&gt;snd_nxt[2] = iss[2];
-  uip_connr-&gt;snd_nxt[3] = iss[3];
-  uip_connr-&gt;len = 1;
-
-  /* rcv_nxt should be the seqno from the incoming packet + 1. */
-  uip_connr-&gt;rcv_nxt[3] = BUF-&gt;seqno[3];
-  uip_connr-&gt;rcv_nxt[2] = BUF-&gt;seqno[2];
-  uip_connr-&gt;rcv_nxt[1] = BUF-&gt;seqno[1];
-  uip_connr-&gt;rcv_nxt[0] = BUF-&gt;seqno[0];
-  uip_add_rcv_nxt(1);
-
-  /* Parse the TCP MSS option, if present. */
-  if((BUF-&gt;tcpoffset &amp; 0xf0) &gt; 0x50) {
-    for(c = 0; c &lt; ((BUF-&gt;tcpoffset &gt;&gt; 4) - 5) &lt;&lt; 2 ;) {
-      opt = uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + c];
-      if(opt == TCP_OPT_END) {
-	/* End of options. */
-	break;
-      } else if(opt == TCP_OPT_NOOP) {
-	++c;
-	/* NOP option. */
-      } else if(opt == TCP_OPT_MSS &amp;&amp;
-		uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
-	/* An MSS option with the right option length. */
-	tmp16 = ((u16_t)uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] &lt;&lt; 8) |
-	  (u16_t)uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + 3 + c];
-	uip_connr-&gt;initialmss = uip_connr-&gt;mss =
-	  tmp16 &gt; UIP_TCP_MSS? UIP_TCP_MSS: tmp16;
-	
-	/* And we are done processing options. */
-	break;
-      } else {
-	/* All other options have a length field, so that we easily
-	   can skip past them. */
-	if(uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0) {
-	  /* If the length field is zero, the options are malformed
-	     and we don't process them further. */
-	  break;
-	}
-	c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
-      }
-    }
-  }
-  
-  /* Our response will be a SYNACK. */
-#if UIP_ACTIVE_OPEN
- tcp_send_synack:
-  BUF-&gt;flags = TCP_ACK;
-  
- tcp_send_syn:
-  BUF-&gt;flags |= TCP_SYN;
-#else /* UIP_ACTIVE_OPEN */
- tcp_send_synack:
-  BUF-&gt;flags = TCP_SYN | TCP_ACK;
-#endif /* UIP_ACTIVE_OPEN */
-  
-  /* We send out the TCP Maximum Segment Size option with our
-     SYNACK. */
-  BUF-&gt;optdata[0] = TCP_OPT_MSS;
-  BUF-&gt;optdata[1] = TCP_OPT_MSS_LEN;
-  BUF-&gt;optdata[2] = (UIP_TCP_MSS) / 256;
-  BUF-&gt;optdata[3] = (UIP_TCP_MSS) &amp; 255;
-  uip_len = UIP_IPTCPH_LEN + TCP_OPT_MSS_LEN;
-  BUF-&gt;tcpoffset = ((UIP_TCPH_LEN + TCP_OPT_MSS_LEN) / 4) &lt;&lt; 4;
-  goto tcp_send;
-
-  /* This label will be jumped to if we found an active connection. */
- found:
-  uip_conn = uip_connr;
-  uip_flags = 0;
-  /* We do a very naive form of TCP reset processing; we just accept
-     any RST and kill our connection. We should in fact check if the
-     sequence number of this reset is wihtin our advertised window
-     before we accept the reset. */
-  if(BUF-&gt;flags &amp; TCP_RST) {
-    uip_connr-&gt;tcpstateflags = UIP_CLOSED;
-    UIP_LOG(&quot;tcp: got reset, aborting connection.&quot;);
-    uip_flags = UIP_ABORT;
-    UIP_APPCALL();
-    goto drop;
-  }
-  /* Calculated the length of the data, if the application has sent
-     any data to us. */
-  c = (BUF-&gt;tcpoffset &gt;&gt; 4) &lt;&lt; 2;
-  /* uip_len will contain the length of the actual TCP data. This is
-     calculated by subtracing the length of the TCP header (in
-     c) and the length of the IP header (20 bytes). */
-  uip_len = uip_len - c - UIP_IPH_LEN;
-
-  /* First, check if the sequence number of the incoming packet is
-     what we're expecting next. If not, we send out an ACK with the
-     correct numbers in. */
-  if(!(((uip_connr-&gt;tcpstateflags &amp; UIP_TS_MASK) == UIP_SYN_SENT) &amp;&amp;
-       ((BUF-&gt;flags &amp; TCP_CTL) == (TCP_SYN | TCP_ACK)))) {
-    if((uip_len &gt; 0 || ((BUF-&gt;flags &amp; (TCP_SYN | TCP_FIN)) != 0)) &amp;&amp;
-       (BUF-&gt;seqno[0] != uip_connr-&gt;rcv_nxt[0] ||
-	BUF-&gt;seqno[1] != uip_connr-&gt;rcv_nxt[1] ||
-	BUF-&gt;seqno[2] != uip_connr-&gt;rcv_nxt[2] ||
-	BUF-&gt;seqno[3] != uip_connr-&gt;rcv_nxt[3])) {
-      goto tcp_send_ack;
-    }
-  }
-
-  /* Next, check if the incoming segment acknowledges any outstanding
-     data. If so, we update the sequence number, reset the length of
-     the outstanding data, calculate RTT estimations, and reset the
-     retransmission timer. */
-  if((BUF-&gt;flags &amp; TCP_ACK) &amp;&amp; uip_outstanding(uip_connr)) {
-    uip_add32(uip_connr-&gt;snd_nxt, uip_connr-&gt;len);
-
-    if(BUF-&gt;ackno[0] == uip_acc32[0] &amp;&amp;
-       BUF-&gt;ackno[1] == uip_acc32[1] &amp;&amp;
-       BUF-&gt;ackno[2] == uip_acc32[2] &amp;&amp;
-       BUF-&gt;ackno[3] == uip_acc32[3]) {
-      /* Update sequence number. */
-      uip_connr-&gt;snd_nxt[0] = uip_acc32[0];
-      uip_connr-&gt;snd_nxt[1] = uip_acc32[1];
-      uip_connr-&gt;snd_nxt[2] = uip_acc32[2];
-      uip_connr-&gt;snd_nxt[3] = uip_acc32[3];
-	
-
-      /* Do RTT estimation, unless we have done retransmissions. */
-      if(uip_connr-&gt;nrtx == 0) {
-	signed char m;
-	m = uip_connr-&gt;rto - uip_connr-&gt;timer;
-	/* This is taken directly from VJs original code in his paper */
-	m = m - (uip_connr-&gt;sa &gt;&gt; 3);
-	uip_connr-&gt;sa += m;
-	if(m &lt; 0) {
-	  m = -m;
-	}
-	m = m - (uip_connr-&gt;sv &gt;&gt; 2);
-	uip_connr-&gt;sv += m;
-	uip_connr-&gt;rto = (uip_connr-&gt;sa &gt;&gt; 3) + uip_connr-&gt;sv;
-
-      }
-      /* Set the acknowledged flag. */
-      uip_flags = UIP_ACKDATA;
-      /* Reset the retransmission timer. */
-      uip_connr-&gt;timer = uip_connr-&gt;rto;
-
-      /* Reset length of outstanding data. */
-      uip_connr-&gt;len = 0;
-    }
-    
-  }
-
-  /* Do different things depending on in what state the connection is. */
-  switch(uip_connr-&gt;tcpstateflags &amp; UIP_TS_MASK) {
-    /* CLOSED and LISTEN are not handled here. CLOSE_WAIT is not
-	implemented, since we force the application to close when the
-	peer sends a FIN (hence the application goes directly from
-	ESTABLISHED to LAST_ACK). */
-  case UIP_SYN_RCVD:
-    /* In SYN_RCVD we have sent out a SYNACK in response to a SYN, and
-       we are waiting for an ACK that acknowledges the data we sent
-       out the last time. Therefore, we want to have the UIP_ACKDATA
-       flag set. If so, we enter the ESTABLISHED state. */
-    if(uip_flags &amp; UIP_ACKDATA) {
-      uip_connr-&gt;tcpstateflags = UIP_ESTABLISHED;
-      uip_flags = UIP_CONNECTED;
-      uip_connr-&gt;len = 0;
-      if(uip_len &gt; 0) {
-        uip_flags |= UIP_NEWDATA;
-        uip_add_rcv_nxt(uip_len);
-      }
-      uip_slen = 0;
-      UIP_APPCALL();
-      goto appsend;
-    }
-    goto drop;
-#if UIP_ACTIVE_OPEN
-  case UIP_SYN_SENT:
-    /* In SYN_SENT, we wait for a SYNACK that is sent in response to
-       our SYN. The rcv_nxt is set to sequence number in the SYNACK
-       plus one, and we send an ACK. We move into the ESTABLISHED
-       state. */
-    if((uip_flags &amp; UIP_ACKDATA) &amp;&amp;
-       (BUF-&gt;flags &amp; TCP_CTL) == (TCP_SYN | TCP_ACK)) {
-
-      /* Parse the TCP MSS option, if present. */
-      if((BUF-&gt;tcpoffset &amp; 0xf0) &gt; 0x50) {
-	for(c = 0; c &lt; ((BUF-&gt;tcpoffset &gt;&gt; 4) - 5) &lt;&lt; 2 ;) {
-	  opt = uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + c];
-	  if(opt == TCP_OPT_END) {
-	    /* End of options. */
-	    break;
-	  } else if(opt == TCP_OPT_NOOP) {
-	    ++c;
-	    /* NOP option. */
-	  } else if(opt == TCP_OPT_MSS &amp;&amp;
-		    uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
-	    /* An MSS option with the right option length. */
-	    tmp16 = (uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] &lt;&lt; 8) |
-	      uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 3 + c];
-	    uip_connr-&gt;initialmss =
-	      uip_connr-&gt;mss = tmp16 &gt; UIP_TCP_MSS? UIP_TCP_MSS: tmp16;
-
-	    /* And we are done processing options. */
-	    break;
-	  } else {
-	    /* All other options have a length field, so that we easily
-	       can skip past them. */
-	    if(uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0) {
-	      /* If the length field is zero, the options are malformed
-		 and we don't process them further. */
-	      break;
-	    }
-	    c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
-	  }
-	}
-      }
-      uip_connr-&gt;tcpstateflags = UIP_ESTABLISHED;
-      uip_connr-&gt;rcv_nxt[0] = BUF-&gt;seqno[0];
-      uip_connr-&gt;rcv_nxt[1] = BUF-&gt;seqno[1];
-      uip_connr-&gt;rcv_nxt[2] = BUF-&gt;seqno[2];
-      uip_connr-&gt;rcv_nxt[3] = BUF-&gt;seqno[3];
-      uip_add_rcv_nxt(1);
-      uip_flags = UIP_CONNECTED | UIP_NEWDATA;
-      uip_connr-&gt;len = 0;
-      uip_len = 0;
-      uip_slen = 0;
-      UIP_APPCALL();
-      goto appsend;
-    }
-    /* Inform the application that the connection failed */
-    uip_flags = UIP_ABORT;
-    UIP_APPCALL();
-    /* The connection is closed after we send the RST */
-    uip_conn-&gt;tcpstateflags = UIP_CLOSED;
-    goto reset;
-#endif /* UIP_ACTIVE_OPEN */
-    
-  case UIP_ESTABLISHED:
-    /* In the ESTABLISHED state, we call upon the application to feed
-    data into the uip_buf. If the UIP_ACKDATA flag is set, the
-    application should put new data into the buffer, otherwise we are
-    retransmitting an old segment, and the application should put that
-    data into the buffer.
-
-    If the incoming packet is a FIN, we should close the connection on
-    this side as well, and we send out a FIN and enter the LAST_ACK
-    state. We require that there is no outstanding data; otherwise the
-    sequence numbers will be screwed up. */
-
-    if(BUF-&gt;flags &amp; TCP_FIN &amp;&amp; !(uip_connr-&gt;tcpstateflags &amp; UIP_STOPPED)) {
-      if(uip_outstanding(uip_connr)) {
-	goto drop;
-      }
-      uip_add_rcv_nxt(1 + uip_len);
-      uip_flags |= UIP_CLOSE;
-      if(uip_len &gt; 0) {
-	uip_flags |= UIP_NEWDATA;
-      }
-      UIP_APPCALL();
-      uip_connr-&gt;len = 1;
-      uip_connr-&gt;tcpstateflags = UIP_LAST_ACK;
-      uip_connr-&gt;nrtx = 0;
-    tcp_send_finack:
-      BUF-&gt;flags = TCP_FIN | TCP_ACK;
-      goto tcp_send_nodata;
-    }
-
-    /* Check the URG flag. If this is set, the segment carries urgent
-       data that we must pass to the application. */
-    if((BUF-&gt;flags &amp; TCP_URG) != 0) {
-#if UIP_URGDATA &gt; 0
-      uip_urglen = (BUF-&gt;urgp[0] &lt;&lt; 8) | BUF-&gt;urgp[1];
-      if(uip_urglen &gt; uip_len) {
-	/* There is more urgent data in the next segment to come. */
-	uip_urglen = uip_len;
-      }
-      uip_add_rcv_nxt(uip_urglen);
-      uip_len -= uip_urglen;
-      uip_urgdata = uip_appdata;
-      uip_appdata += uip_urglen;
-    } else {
-      uip_urglen = 0;
-#else /* UIP_URGDATA &gt; 0 */
-      uip_appdata = ((char *)uip_appdata) + ((BUF-&gt;urgp[0] &lt;&lt; 8) | BUF-&gt;urgp[1]);
-      uip_len -= (BUF-&gt;urgp[0] &lt;&lt; 8) | BUF-&gt;urgp[1];
-#endif /* UIP_URGDATA &gt; 0 */
-    }
-
-    /* If uip_len &gt; 0 we have TCP data in the packet, and we flag this
-       by setting the UIP_NEWDATA flag and update the sequence number
-       we acknowledge. If the application has stopped the dataflow
-       using uip_stop(), we must not accept any data packets from the
-       remote host. */
-    if(uip_len &gt; 0 &amp;&amp; !(uip_connr-&gt;tcpstateflags &amp; UIP_STOPPED)) {
-      uip_flags |= UIP_NEWDATA;
-      uip_add_rcv_nxt(uip_len);
-    }
-
-    /* Check if the available buffer space advertised by the other end
-       is smaller than the initial MSS for this connection. If so, we
-       set the current MSS to the window size to ensure that the
-       application does not send more data than the other end can
-       handle.
-
-       If the remote host advertises a zero window, we set the MSS to
-       the initial MSS so that the application will send an entire MSS
-       of data. This data will not be acknowledged by the receiver,
-       and the application will retransmit it. This is called the
-       &quot;persistent timer&quot; and uses the retransmission mechanim.
-    */
-    tmp16 = ((u16_t)BUF-&gt;wnd[0] &lt;&lt; 8) + (u16_t)BUF-&gt;wnd[1];
-    if(tmp16 &gt; uip_connr-&gt;initialmss ||
-       tmp16 == 0) {
-      tmp16 = uip_connr-&gt;initialmss;
-    }
-    uip_connr-&gt;mss = tmp16;
-
-    /* If this packet constitutes an ACK for outstanding data (flagged
-       by the UIP_ACKDATA flag, we should call the application since it
-       might want to send more data. If the incoming packet had data
-       from the peer (as flagged by the UIP_NEWDATA flag), the
-       application must also be notified.
-
-       When the application is called, the global variable uip_len
-       contains the length of the incoming data. The application can
-       access the incoming data through the global pointer
-       uip_appdata, which usually points UIP_IPTCPH_LEN + UIP_LLH_LEN
-       bytes into the uip_buf array.
-
-       If the application wishes to send any data, this data should be
-       put into the uip_appdata and the length of the data should be
-       put into uip_len. If the application don't have any data to
-       send, uip_len must be set to 0. */
-    if(uip_flags &amp; (UIP_NEWDATA | UIP_ACKDATA)) {
-      uip_slen = 0;
-      UIP_APPCALL();
-
-    appsend:
-      
-      if(uip_flags &amp; UIP_ABORT) {
-	uip_slen = 0;
-	uip_connr-&gt;tcpstateflags = UIP_CLOSED;
-	BUF-&gt;flags = TCP_RST | TCP_ACK;
-	goto tcp_send_nodata;
-      }
-
-      if(uip_flags &amp; UIP_CLOSE) {
-	uip_slen = 0;
-	uip_connr-&gt;len = 1;
-	uip_connr-&gt;tcpstateflags = UIP_FIN_WAIT_1;
-	uip_connr-&gt;nrtx = 0;
-	BUF-&gt;flags = TCP_FIN | TCP_ACK;
-	goto tcp_send_nodata;
-      }
-
-      /* If uip_slen &gt; 0, the application has data to be sent. */
-      if(uip_slen &gt; 0) {
-
-	/* If the connection has acknowledged data, the contents of
-	   the -&gt;len variable should be discarded. */
-	if((uip_flags &amp; UIP_ACKDATA) != 0) {
-	  uip_connr-&gt;len = 0;
-	}
-
-	/* If the -&gt;len variable is non-zero the connection has
-	   already data in transit and cannot send anymore right
-	   now. */
-	if(uip_connr-&gt;len == 0) {
-
-	  /* The application cannot send more than what is allowed by
-	     the mss (the minumum of the MSS and the available
-	     window). */
-	  if(uip_slen &gt; uip_connr-&gt;mss) {
-	    uip_slen = uip_connr-&gt;mss;
-	  }
-
-	  /* Remember how much data we send out now so that we know
-	     when everything has been acknowledged. */
-	  uip_connr-&gt;len = uip_slen;
-	} else {
-
-	  /* If the application already had unacknowledged data, we
-	     make sure that the application does not send (i.e.,
-	     retransmit) out more than it previously sent out. */
-	  uip_slen = uip_connr-&gt;len;
-	}
-      }
-      uip_connr-&gt;nrtx = 0;
-    apprexmit:
-      uip_appdata = uip_sappdata;
-      
-      /* If the application has data to be sent, or if the incoming
-         packet had new data in it, we must send out a packet. */
-      if(uip_slen &gt; 0 &amp;&amp; uip_connr-&gt;len &gt; 0) {
-	/* Add the length of the IP and TCP headers. */
-	uip_len = uip_connr-&gt;len + UIP_TCPIP_HLEN;
-	/* We always set the ACK flag in response packets. */
-	BUF-&gt;flags = TCP_ACK | TCP_PSH;
-	/* Send the packet. */
-	goto tcp_send_noopts;
-      }
-      /* If there is no data to send, just send out a pure ACK if
-	 there is newdata. */
-      if(uip_flags &amp; UIP_NEWDATA) {
-	uip_len = UIP_TCPIP_HLEN;
-	BUF-&gt;flags = TCP_ACK;
-	goto tcp_send_noopts;
-      }
-    }
-    goto drop;
-  case UIP_LAST_ACK:
-    /* We can close this connection if the peer has acknowledged our
-       FIN. This is indicated by the UIP_ACKDATA flag. */
-    if(uip_flags &amp; UIP_ACKDATA) {
-      uip_connr-&gt;tcpstateflags = UIP_CLOSED;
-      uip_flags = UIP_CLOSE;
-      UIP_APPCALL();
-    }
-    break;
-    
-  case UIP_FIN_WAIT_1:
-    /* The application has closed the connection, but the remote host
-       hasn't closed its end yet. Thus we do nothing but wait for a
-       FIN from the other side. */
-    if(uip_len &gt; 0) {
-      uip_add_rcv_nxt(uip_len);
-    }
-    if(BUF-&gt;flags &amp; TCP_FIN) {
-      if(uip_flags &amp; UIP_ACKDATA) {
-	uip_connr-&gt;tcpstateflags = UIP_TIME_WAIT;
-	uip_connr-&gt;timer = 0;
-	uip_connr-&gt;len = 0;
-      } else {
-	uip_connr-&gt;tcpstateflags = UIP_CLOSING;
-      }
-      uip_add_rcv_nxt(1);
-      uip_flags = UIP_CLOSE;
-      UIP_APPCALL();
-      goto tcp_send_ack;
-    } else if(uip_flags &amp; UIP_ACKDATA) {
-      uip_connr-&gt;tcpstateflags = UIP_FIN_WAIT_2;
-      uip_connr-&gt;len = 0;
-      goto drop;
-    }
-    if(uip_len &gt; 0) {
-      goto tcp_send_ack;
-    }
-    goto drop;
-      
-  case UIP_FIN_WAIT_2:
-    if(uip_len &gt; 0) {
-      uip_add_rcv_nxt(uip_len);
-    }
-    if(BUF-&gt;flags &amp; TCP_FIN) {
-      uip_connr-&gt;tcpstateflags = UIP_TIME_WAIT;
-      uip_connr-&gt;timer = 0;
-      uip_add_rcv_nxt(1);
-      uip_flags = UIP_CLOSE;
-      UIP_APPCALL();
-      goto tcp_send_ack;
-    }
-    if(uip_len &gt; 0) {
-      goto tcp_send_ack;
-    }
-    goto drop;
-
-  case UIP_TIME_WAIT:
-    goto tcp_send_ack;
-    
-  case UIP_CLOSING:
-    if(uip_flags &amp; UIP_ACKDATA) {
-      uip_connr-&gt;tcpstateflags = UIP_TIME_WAIT;
-      uip_connr-&gt;timer = 0;
-    }
-  }
-  goto drop;
-  
-
-  /* We jump here when we are ready to send the packet, and just want
-     to set the appropriate TCP sequence numbers in the TCP header. */
- tcp_send_ack:
-  BUF-&gt;flags = TCP_ACK;
- tcp_send_nodata:
-  uip_len = UIP_IPTCPH_LEN;
- tcp_send_noopts:
-  BUF-&gt;tcpoffset = (UIP_TCPH_LEN / 4) &lt;&lt; 4;
- tcp_send:
-  /* We're done with the input processing. We are now ready to send a
-     reply. Our job is to fill in all the fields of the TCP and IP
-     headers before calculating the checksum and finally send the
-     packet. */
-  BUF-&gt;ackno[0] = uip_connr-&gt;rcv_nxt[0];
-  BUF-&gt;ackno[1] = uip_connr-&gt;rcv_nxt[1];
-  BUF-&gt;ackno[2] = uip_connr-&gt;rcv_nxt[2];
-  BUF-&gt;ackno[3] = uip_connr-&gt;rcv_nxt[3];
-  
-  BUF-&gt;seqno[0] = uip_connr-&gt;snd_nxt[0];
-  BUF-&gt;seqno[1] = uip_connr-&gt;snd_nxt[1];
-  BUF-&gt;seqno[2] = uip_connr-&gt;snd_nxt[2];
-  BUF-&gt;seqno[3] = uip_connr-&gt;snd_nxt[3];
-
-  BUF-&gt;proto = UIP_PROTO_TCP;
-  
-  BUF-&gt;srcport  = uip_connr-&gt;lport;
-  BUF-&gt;destport = uip_connr-&gt;rport;
-
-  uip_ipaddr_copy(BUF-&gt;srcipaddr, uip_hostaddr);
-  uip_ipaddr_copy(BUF-&gt;destipaddr, uip_connr-&gt;ripaddr);
-
-  if(uip_connr-&gt;tcpstateflags &amp; UIP_STOPPED) {
-    /* If the connection has issued uip_stop(), we advertise a zero
-       window so that the remote host will stop sending data. */
-    BUF-&gt;wnd[0] = BUF-&gt;wnd[1] = 0;
-  } else {
-    BUF-&gt;wnd[0] = ((UIP_RECEIVE_WINDOW) &gt;&gt; 8);
-    BUF-&gt;wnd[1] = ((UIP_RECEIVE_WINDOW) &amp; 0xff);
-  }
-
- tcp_send_noconn:
-  BUF-&gt;ttl = UIP_TTL;
-#if UIP_CONF_IPV6
-  /* For IPv6, the IP length field does not include the IPv6 IP header
-     length. */
-  BUF-&gt;len[0] = ((uip_len - UIP_IPH_LEN) &gt;&gt; 8);
-  BUF-&gt;len[1] = ((uip_len - UIP_IPH_LEN) &amp; 0xff);
-#else /* UIP_CONF_IPV6 */
-  BUF-&gt;len[0] = (uip_len &gt;&gt; 8);
-  BUF-&gt;len[1] = (uip_len &amp; 0xff);
-#endif /* UIP_CONF_IPV6 */
-
-  BUF-&gt;urgp[0] = BUF-&gt;urgp[1] = 0;
-  
-  /* Calculate TCP checksum. */
-  BUF-&gt;tcpchksum = 0;
-  BUF-&gt;tcpchksum = ~(uip_tcpchksum());
-#endif /* UIP_TCP */
-  
- ip_send_nolen:
-
-#if UIP_CONF_IPV6
-  BUF-&gt;vtc = 0x60;
-  BUF-&gt;tcflow = 0x00;
-  BUF-&gt;flow = 0x00;
-#else /* UIP_CONF_IPV6 */
-  BUF-&gt;vhl = 0x45;
-  BUF-&gt;tos = 0;
-  BUF-&gt;ipoffset[0] = BUF-&gt;ipoffset[1] = 0;
-  ++ipid;
-  BUF-&gt;ipid[0] = ipid &gt;&gt; 8;
-  BUF-&gt;ipid[1] = ipid &amp; 0xff;
-  /* Calculate IP checksum. */
-  BUF-&gt;ipchksum = 0;
-  BUF-&gt;ipchksum = ~(uip_ipchksum());
-  DEBUG_PRINTF(&quot;uip ip_send_nolen: chkecum 0x%04x\n&quot;, uip_ipchksum());
-#endif /* UIP_CONF_IPV6 */
-   
-  UIP_STAT(++uip_stat.tcp.sent);
- send:
-  DEBUG_PRINTF(&quot;Sending packet with length %d (%d)\n&quot;, uip_len,
-	       (BUF-&gt;len[0] &lt;&lt; 8) | BUF-&gt;len[1]);
-  
-  UIP_STAT(++uip_stat.ip.sent);
-  /* Return and let the caller do the actual transmission. */
-  uip_flags = 0;
-  return;
- drop:
-  uip_len = 0;
-  uip_flags = 0;
-  return;
-}
-/*---------------------------------------------------------------------------*/
-u16_t
-htons(u16_t val)
-{
-  return HTONS(val);
-}
-/*---------------------------------------------------------------------------*/
-void
-uip_send(const void *data, int len)
-{
-  if(len &gt; 0) {
-    uip_slen = len;
-    if(data != uip_sappdata) {
-      memcpy(uip_sappdata, (data), uip_slen);
-    }
-  }
-}
-/** @} */
-
-#endif // #ifdef BUILD_UIP
+#include &quot;build.h&quot;
+#ifdef BUILD_UIP
+
+#define DEBUG_PRINTF(...) /*printf(__VA_ARGS__)*/
+
+/**
+ * \defgroup uip The uIP TCP/IP stack
+ * @{
+ *
+ * uIP is an implementation of the TCP/IP protocol stack intended for
+ * small 8-bit and 16-bit microcontrollers.
+ *
+ * uIP provides the necessary protocols for Internet communication,
+ * with a very small code footprint and RAM requirements - the uIP
+ * code size is on the order of a few kilobytes and RAM usage is on
+ * the order of a few hundred bytes.
+ */
+
+/**
+ * \file
+ * The uIP TCP/IP stack code.
+ * \author Adam Dunkels &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">adam at dunkels.com</A>&gt;
+ */
+
+/*
+ * Copyright (c) 2001-2003, Adam Dunkels.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote
+ *    products derived from this software without specific prior
+ *    written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * This file is part of the uIP TCP/IP stack.
+ *
+ * $Id: uip.c,v 1.65 2006/06/11 21:46:39 adam Exp $
+ *
+ */
+
+/*
+ * uIP is a small implementation of the IP, UDP and TCP protocols (as
+ * well as some basic ICMP stuff). The implementation couples the IP,
+ * UDP, TCP and the application layers very tightly. To keep the size
+ * of the compiled code down, this code frequently uses the goto
+ * statement. While it would be possible to break the uip_process()
+ * function into many smaller functions, this would increase the code
+ * size because of the overhead of parameter passing and the fact that
+ * the optimier would not be as efficient.
+ *
+ * The principle is that we have a small buffer, called the uip_buf,
+ * in which the device driver puts an incoming packet. The TCP/IP
+ * stack parses the headers in the packet, and calls the
+ * application. If the remote host has sent data to the application,
+ * this data is present in the uip_buf and the application read the
+ * data from there. It is up to the application to put this data into
+ * a byte stream if needed. The application will not be fed with data
+ * that is out of sequence.
+ *
+ * If the application whishes to send data to the peer, it should put
+ * its data into the uip_buf. The uip_appdata pointer points to the
+ * first available byte. The TCP/IP stack will calculate the
+ * checksums, and fill in the necessary header fields and finally send
+ * the packet back to the peer.
+*/
+
+#include &quot;uip.h&quot;
+#include &quot;uipopt.h&quot;
+#include &quot;uip_arch.h&quot;
+
+#if UIP_CONF_IPV6
+#include &quot;uip-neighbor.h&quot;
+#endif /* UIP_CONF_IPV6 */
+
+#include &lt;string.h&gt;
+
+/*---------------------------------------------------------------------------*/
+/* Variable definitions. */
+
+
+/* The IP address of this host. If it is defined to be fixed (by
+   setting UIP_FIXEDADDR to 1 in uipopt.h), the address is set
+   here. Otherwise, the address */
+#if UIP_FIXEDADDR &gt; 0
+const uip_ipaddr_t uip_hostaddr =
+  {HTONS((UIP_IPADDR0 &lt;&lt; 8) | UIP_IPADDR1),
+   HTONS((UIP_IPADDR2 &lt;&lt; 8) | UIP_IPADDR3)};
+const uip_ipaddr_t uip_draddr =
+  {HTONS((UIP_DRIPADDR0 &lt;&lt; 8) | UIP_DRIPADDR1),
+   HTONS((UIP_DRIPADDR2 &lt;&lt; 8) | UIP_DRIPADDR3)};
+const uip_ipaddr_t uip_netmask =
+  {HTONS((UIP_NETMASK0 &lt;&lt; 8) | UIP_NETMASK1),
+   HTONS((UIP_NETMASK2 &lt;&lt; 8) | UIP_NETMASK3)};
+#else
+uip_ipaddr_t uip_hostaddr, uip_draddr, uip_netmask;
+#endif /* UIP_FIXEDADDR */
+
+static const uip_ipaddr_t all_ones_addr =
+#if UIP_CONF_IPV6
+  {0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff};
+#else /* UIP_CONF_IPV6 */
+  {0xffff,0xffff};
+#endif /* UIP_CONF_IPV6 */
+static const uip_ipaddr_t all_zeroes_addr =
+#if UIP_CONF_IPV6
+  {0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000};
+#else /* UIP_CONF_IPV6 */
+  {0x0000,0x0000};
+#endif /* UIP_CONF_IPV6 */
+
+
+#if UIP_FIXEDETHADDR
+const struct uip_eth_addr uip_ethaddr = {{UIP_ETHADDR0,
+					  UIP_ETHADDR1,
+					  UIP_ETHADDR2,
+					  UIP_ETHADDR3,
+					  UIP_ETHADDR4,
+					  UIP_ETHADDR5}};
+#else
+struct uip_eth_addr uip_ethaddr = {{0,0,0,0,0,0}};
+#endif
+
+#ifndef UIP_CONF_EXTERNAL_BUFFER
+u8_t uip_buf[UIP_BUFSIZE + 2];   /* The packet buffer that contains
+				    incoming packets. */
+#endif /* UIP_CONF_EXTERNAL_BUFFER */
+
+void *uip_appdata;               /* The uip_appdata pointer points to
+				    application data. */
+void *uip_sappdata;              /* The uip_appdata pointer points to
+				    the application data which is to
+				    be sent. */
+#if UIP_URGDATA &gt; 0
+void *uip_urgdata;               /* The uip_urgdata pointer points to
+   				    urgent data (out-of-band data), if
+   				    present. */
+u16_t uip_urglen, uip_surglen;
+#endif /* UIP_URGDATA &gt; 0 */
+
+u16_t uip_len, uip_slen;
+                             /* The uip_len is either 8 or 16 bits,
+				depending on the maximum packet
+				size. */
+
+u8_t uip_flags;     /* The uip_flags variable is used for
+				communication between the TCP/IP stack
+				and the application program. */
+
+#if UIP_TCP
+struct uip_conn *uip_conn;   /* uip_conn always points to the current
+				connection. */
+
+struct uip_conn uip_conns[UIP_CONNS];
+                             /* The uip_conns array holds all TCP
+				connections. */
+u16_t uip_listenports[UIP_LISTENPORTS];
+                             /* The uip_listenports list all currently
+				listning ports. */
+#endif /* UIP_TCP */
+
+#if UIP_UDP
+struct uip_udp_conn *uip_udp_conn;
+struct uip_udp_conn uip_udp_conns[UIP_UDP_CONNS];
+#endif /* UIP_UDP */
+
+static u16_t ipid;           /* Ths ipid variable is an increasing
+				number that is used for the IP ID
+				field. */
+
+void uip_setipid(u16_t id) { ipid = id; }
+
+#if UIP_TCP
+static u8_t iss[4];          /* The iss variable is used for the TCP
+				initial sequence number. */
+#endif /* UIP_TCP */
+
+#if UIP_ACTIVE_OPEN
+static u16_t lastport;       /* Keeps track of the last port used for
+				a new connection. */
+#endif /* UIP_ACTIVE_OPEN */
+
+/* Temporary variables. */
+#if UIP_TCP
+u8_t uip_acc32[4];
+static u8_t c, opt;
+static u16_t tmp16;
+#endif /* UIP_TCP */
+
+/* Structures and definitions. */
+#define TCP_FIN 0x01
+#define TCP_SYN 0x02
+#define TCP_RST 0x04
+#define TCP_PSH 0x08
+#define TCP_ACK 0x10
+#define TCP_URG 0x20
+#define TCP_CTL 0x3f
+
+#define TCP_OPT_END     0   /* End of TCP options list */
+#define TCP_OPT_NOOP    1   /* &quot;No-operation&quot; TCP option */
+#define TCP_OPT_MSS     2   /* Maximum segment size TCP option */
+
+#define TCP_OPT_MSS_LEN 4   /* Length of TCP MSS option. */
+
+#define ICMP_ECHO_REPLY 0
+#define ICMP_ECHO       8
+
+#define ICMP6_ECHO_REPLY             129
+#define ICMP6_ECHO                   128
+#define ICMP6_NEIGHBOR_SOLICITATION  135
+#define ICMP6_NEIGHBOR_ADVERTISEMENT 136
+
+#define ICMP6_FLAG_S (1 &lt;&lt; 6)
+
+#define ICMP6_OPTION_SOURCE_LINK_ADDRESS 1
+#define ICMP6_OPTION_TARGET_LINK_ADDRESS 2
+
+
+/* Macros. */
+#define BUF ((struct uip_tcpip_hdr *)&amp;uip_buf[UIP_LLH_LEN])
+#define FBUF ((struct uip_tcpip_hdr *)&amp;uip_reassbuf[0])
+#define ICMPBUF ((struct uip_icmpip_hdr *)&amp;uip_buf[UIP_LLH_LEN])
+#define UDPBUF ((struct uip_udpip_hdr *)&amp;uip_buf[UIP_LLH_LEN])
+
+
+#if UIP_STATISTICS == 1
+struct uip_stats uip_stat;
+#define UIP_STAT(s) s
+#else
+#define UIP_STAT(s)
+#endif /* UIP_STATISTICS == 1 */
+
+#if UIP_LOGGING == 1
+#include &lt;stdio.h&gt;
+void uip_log(char *msg);
+#define UIP_LOG(m) uip_log(m)
+#else
+#define UIP_LOG(m)
+#endif /* UIP_LOGGING == 1 */
+
+#if 0
+#include &lt;stdio.h&gt;
+#undef DEBUG_PRINTF
+#define DEBUG_PRINTF(...) printf(__VA_ARGS__)
+#undef UIP_LOG
+#define UIP_LOG( x ) printf( x )
+#endif 
+
+#if ! UIP_ARCH_ADD32 &amp;&amp; UIP_TCP
+
+#include &quot;type.h&quot;
+
+void
+uip_add32(u8_t *op32, u16_t op16)
+{
+  uip_acc32[3] = op32[3] + (op16 &amp; 0xff);
+  uip_acc32[2] = op32[2] + (op16 &gt;&gt; 8);
+  uip_acc32[1] = op32[1];
+  uip_acc32[0] = op32[0];
+  
+  if(uip_acc32[2] &lt; (op16 &gt;&gt; 8)) {
+    ++uip_acc32[1];
+    if(uip_acc32[1] == 0) {
+      ++uip_acc32[0];
+    }
+  }
+  
+  
+  if(uip_acc32[3] &lt; (op16 &amp; 0xff)) {
+    ++uip_acc32[2];
+    if(uip_acc32[2] == 0) {
+      ++uip_acc32[1];
+      if(uip_acc32[1] == 0) {
+	++uip_acc32[0];
+      }
+    }
+  }
+}
+
+#endif /* ! UIP_ARCH_ADD32 &amp;&amp; UIP_TCP */
+
+#if ! UIP_ARCH_CHKSUM
+/*---------------------------------------------------------------------------*/
+/*static*/ u16_t
+chksum(u16_t sum, const u8_t *data, u16_t len)
+{
+  u16_t t;
+  const u8_t *dataptr;
+  const u8_t *last_byte;
+
+  dataptr = data;
+  last_byte = data + len - 1;
+  
+  while(dataptr &lt; last_byte) {	/* At least two more bytes */
+    t = (dataptr[0] &lt;&lt; 8) + dataptr[1];
+    sum += t;
+    if(sum &lt; t) {
+      sum++;		/* carry */
+    }
+    dataptr += 2;
+  }
+  
+  if(dataptr == last_byte) {
+    t = (dataptr[0] &lt;&lt; 8) + 0;
+    sum += t;
+    if(sum &lt; t) {
+      sum++;		/* carry */
+    }
+  }
+
+  /* Return sum in host byte order. */
+  return sum;
+}
+/*---------------------------------------------------------------------------*/
+u16_t
+uip_chksum(u16_t *data, u16_t len)
+{
+  return htons(chksum(0, (u8_t *)data, len));
+}
+/*---------------------------------------------------------------------------*/
+#ifndef UIP_ARCH_IPCHKSUM
+u16_t
+uip_ipchksum(void)
+{
+  u16_t sum;
+
+  sum = chksum(0, &amp;uip_buf[UIP_LLH_LEN], UIP_IPH_LEN);
+  DEBUG_PRINTF(&quot;uip_ipchksum: sum 0x%04x\n&quot;, sum);
+  return (sum == 0) ? 0xffff : htons(sum);
+}
+#endif
+/*---------------------------------------------------------------------------*/
+#if UIP_CONF_IPV6 || UIP_TCP || UIP_UDP_CHECKSUMS
+static u16_t
+upper_layer_chksum(u8_t proto)
+{
+  u16_t upper_layer_len;
+  u16_t sum;
+  
+#if UIP_CONF_IPV6
+  upper_layer_len = (((u16_t)(BUF-&gt;len[0]) &lt;&lt; 8) + BUF-&gt;len[1]);
+#else /* UIP_CONF_IPV6 */
+  upper_layer_len = (((u16_t)(BUF-&gt;len[0]) &lt;&lt; 8) + BUF-&gt;len[1]) - UIP_IPH_LEN;
+#endif /* UIP_CONF_IPV6 */
+  
+  /* First sum pseudoheader. */
+  
+  /* IP protocol and length fields. This addition cannot carry. */
+  sum = upper_layer_len + proto;
+  /* Sum IP source and destination addresses. */
+  sum = chksum(sum, (u8_t *)&amp;BUF-&gt;srcipaddr[0], 2 * sizeof(uip_ipaddr_t));
+
+  /* Sum TCP header and data. */
+  sum = chksum(sum, &amp;uip_buf[UIP_IPH_LEN + UIP_LLH_LEN],
+	       upper_layer_len);
+    
+  return (sum == 0) ? 0xffff : htons(sum);
+}
+#endif /* UIP_CONF_IPV6 || UIP_TCP || UIP_UDP_CHECKSUMS */
+/*---------------------------------------------------------------------------*/
+#if UIP_CONF_IPV6
+u16_t
+uip_icmp6chksum(void)
+{
+  return upper_layer_chksum(UIP_PROTO_ICMP6);
+  
+}
+#endif /* UIP_CONF_IPV6 */
+/*---------------------------------------------------------------------------*/
+#if UIP_TCP
+u16_t
+uip_tcpchksum(void)
+{
+  return upper_layer_chksum(UIP_PROTO_TCP);
+}
+#endif /* UIP_TCP */
+/*---------------------------------------------------------------------------*/
+#if UIP_UDP_CHECKSUMS
+u16_t
+uip_udpchksum(void)
+{
+  return upper_layer_chksum(UIP_PROTO_UDP);
+}
+#endif /* UIP_UDP_CHECKSUMS */
+#endif /* UIP_ARCH_CHKSUM */
+/*---------------------------------------------------------------------------*/
+void
+uip_init(void)
+{
+#if UIP_TCP
+  for(c = 0; c &lt; UIP_LISTENPORTS; ++c) {
+    uip_listenports[c] = 0;
+  }
+  for(c = 0; c &lt; UIP_CONNS; ++c) {
+    uip_conns[c].tcpstateflags = UIP_CLOSED;
+  }
+#endif /* UIP_TCP */
+#if UIP_ACTIVE_OPEN
+  lastport = 1024;
+#endif /* UIP_ACTIVE_OPEN */
+
+#if UIP_UDP
+  for(c = 0; c &lt; UIP_UDP_CONNS; ++c) {
+    uip_udp_conns[c].lport = 0;
+  }
+#endif /* UIP_UDP */
+  
+
+  /* IPv4 initialization. */
+#if UIP_FIXEDADDR == 0
+  /*  uip_hostaddr[0] = uip_hostaddr[1] = 0;*/
+#endif /* UIP_FIXEDADDR */
+
+}
+/*---------------------------------------------------------------------------*/
+#if UIP_ACTIVE_OPEN &amp;&amp; UIP_TCP
+static void 
+uip_find_unused_port()
+{
+  register struct uip_conn *conn;
+  
+  /* Find an unused local port. */
+ again:
+  ++lastport;
+
+  if(lastport &gt;= 32000) {
+    lastport = 4096;
+  }
+
+  /* Check if this port is already in use, and if so try to find
+     another one. */
+  for(c = 0; c &lt; UIP_CONNS; ++c) {
+    conn = &amp;uip_conns[c];
+    if(conn-&gt;tcpstateflags != UIP_CLOSED &amp;&amp; conn-&gt;tcpstateflags != UIP_RESERVED &amp;&amp;
+       conn-&gt;lport == htons(lastport)) {
+      goto again;
+    }
+  }
+}
+
+static void
+uip_prepare_conn( struct uip_conn* conn, uip_ipaddr_t *ripaddr, u16_t rport )
+{
+  conn-&gt;tcpstateflags = UIP_SYN_SENT;
+
+  conn-&gt;snd_nxt[0] = iss[0];
+  conn-&gt;snd_nxt[1] = iss[1];
+  conn-&gt;snd_nxt[2] = iss[2];
+  conn-&gt;snd_nxt[3] = iss[3];
+
+  conn-&gt;initialmss = conn-&gt;mss = UIP_TCP_MSS;
+  
+  conn-&gt;len = 1;   /* TCP length of the SYN is one. */
+  conn-&gt;nrtx = 0;
+  conn-&gt;timer = 1; /* Send the SYN next time around. */
+  conn-&gt;rto = UIP_RTO;
+  conn-&gt;sa = 0;
+  conn-&gt;sv = 16;   /* Initial value of the RTT variance. */
+  conn-&gt;lport = htons(lastport);
+  conn-&gt;rport = rport;
+  uip_ipaddr_copy(&amp;conn-&gt;ripaddr, ripaddr);
+}
+
+struct uip_conn *
+uip_connect(uip_ipaddr_t *ripaddr, u16_t rport)
+{
+  register struct uip_conn *conn, *cconn;
+  
+  uip_find_unused_port();
+  
+  conn = 0;
+  for(c = 0; c &lt; UIP_CONNS; ++c) {
+    cconn = &amp;uip_conns[c];
+    if(cconn-&gt;tcpstateflags == UIP_CLOSED) {
+      conn = cconn;
+      break;
+    }
+    if(cconn-&gt;tcpstateflags == UIP_TIME_WAIT) {
+      if(conn == 0 ||
+	 cconn-&gt;timer &gt; conn-&gt;timer) {
+	conn = cconn;
+      }
+    }
+  }
+
+  if(conn == 0) {
+    return 0;
+  }
+  
+  uip_prepare_conn( conn, ripaddr, rport );
+  
+  return conn;
+}
+
+struct uip_conn *uip_connect_socket( int conn, uip_ipaddr_t *ripaddr, u16_t port )
+{
+  register struct uip_conn *pconn;
+  
+  pconn = uip_conns + conn;
+  if( pconn-&gt;tcpstateflags != UIP_RESERVED )
+    return 0;
+    
+  uip_find_unused_port();
+  
+  uip_prepare_conn( pconn, ripaddr, port );
+  
+  return pconn;
+}
+#endif /* UIP_ACTIVE_OPEN &amp;&amp; UIP_TCP */
+/*---------------------------------------------------------------------------*/
+#if UIP_UDP
+struct uip_udp_conn *
+uip_udp_new(uip_ipaddr_t *ripaddr, u16_t rport)
+{
+  register struct uip_udp_conn *conn;
+  
+  /* Find an unused local port. */
+ again:
+  ++lastport;
+
+  if(lastport &gt;= 32000) {
+    lastport = 4096;
+  }
+  
+  for(c = 0; c &lt; UIP_UDP_CONNS; ++c) {
+    if(uip_udp_conns[c].lport == htons(lastport)) {
+      goto again;
+    }
+  }
+
+
+  conn = 0;
+  for(c = 0; c &lt; UIP_UDP_CONNS; ++c) {
+    if(uip_udp_conns[c].lport == 0) {
+      conn = &amp;uip_udp_conns[c];
+      break;
+    }
+  }
+
+  if(conn == 0) {
+    return 0;
+  }
+  
+  conn-&gt;lport = HTONS(lastport);
+  conn-&gt;rport = rport;
+  if(ripaddr == NULL) {
+    memset(conn-&gt;ripaddr, 0, sizeof(uip_ipaddr_t));
+  } else {
+    uip_ipaddr_copy(&amp;conn-&gt;ripaddr, ripaddr);
+  }
+  conn-&gt;ttl = UIP_TTL;
+  
+  return conn;
+}
+#endif /* UIP_UDP */
+/*---------------------------------------------------------------------------*/
+#if UIP_TCP
+void
+uip_unlisten(u16_t port)
+{
+  for(c = 0; c &lt; UIP_LISTENPORTS; ++c) {
+    if(uip_listenports[c] == port) {
+      uip_listenports[c] = 0;
+      return;
+    }
+  }
+}
+#endif /* UIP_TCP */
+/*---------------------------------------------------------------------------*/
+#if UIP_TCP
+void
+uip_listen(u16_t port)
+{
+  for(c = 0; c &lt; UIP_LISTENPORTS; ++c) {
+    if(uip_listenports[c] == 0) {
+      uip_listenports[c] = port;
+      return;
+    }
+  }
+}
+#endif /* UIP_TCP */
+/*---------------------------------------------------------------------------*/
+/* XXX: IP fragment reassembly: not well-tested. */
+
+#if UIP_REASSEMBLY &amp;&amp; !UIP_CONF_IPV6
+#define UIP_REASS_BUFSIZE (UIP_BUFSIZE - UIP_LLH_LEN)
+static u8_t uip_reassbuf[UIP_REASS_BUFSIZE];
+static u8_t uip_reassbitmap[UIP_REASS_BUFSIZE / (8 * 8)];
+static const u8_t bitmap_bits[8] = {0xff, 0x7f, 0x3f, 0x1f,
+				    0x0f, 0x07, 0x03, 0x01};
+static u16_t uip_reasslen;
+static u8_t uip_reassflags;
+#define UIP_REASS_FLAG_LASTFRAG 0x01
+static u8_t uip_reasstmr;
+
+#define IP_MF   0x20
+
+static u8_t
+uip_reass(void)
+{
+  u16_t offset, len;
+  u16_t i;
+
+  /* If ip_reasstmr is zero, no packet is present in the buffer, so we
+     write the IP header of the fragment into the reassembly
+     buffer. The timer is updated with the maximum age. */
+  if(uip_reasstmr == 0) {
+    memcpy(uip_reassbuf, &amp;BUF-&gt;vhl, UIP_IPH_LEN);
+    uip_reasstmr = UIP_REASS_MAXAGE;
+    uip_reassflags = 0;
+    /* Clear the bitmap. */
+    memset(uip_reassbitmap, 0, sizeof(uip_reassbitmap));
+  }
+
+  /* Check if the incoming fragment matches the one currently present
+     in the reasembly buffer. If so, we proceed with copying the
+     fragment into the buffer. */
+  if(BUF-&gt;srcipaddr[0] == FBUF-&gt;srcipaddr[0] &amp;&amp;
+     BUF-&gt;srcipaddr[1] == FBUF-&gt;srcipaddr[1] &amp;&amp;
+     BUF-&gt;destipaddr[0] == FBUF-&gt;destipaddr[0] &amp;&amp;
+     BUF-&gt;destipaddr[1] == FBUF-&gt;destipaddr[1] &amp;&amp;
+     BUF-&gt;ipid[0] == FBUF-&gt;ipid[0] &amp;&amp;
+     BUF-&gt;ipid[1] == FBUF-&gt;ipid[1]) {
+
+    len = (BUF-&gt;len[0] &lt;&lt; 8) + BUF-&gt;len[1] - (BUF-&gt;vhl &amp; 0x0f) * 4;
+    offset = (((BUF-&gt;ipoffset[0] &amp; 0x3f) &lt;&lt; 8) + BUF-&gt;ipoffset[1]) * 8;
+
+    /* If the offset or the offset + fragment length overflows the
+       reassembly buffer, we discard the entire packet. */
+    if(offset &gt; UIP_REASS_BUFSIZE ||
+       offset + len &gt; UIP_REASS_BUFSIZE) {
+      uip_reasstmr = 0;
+      goto nullreturn;
+    }
+
+    /* Copy the fragment into the reassembly buffer, at the right
+       offset. */
+    memcpy(&amp;uip_reassbuf[UIP_IPH_LEN + offset],
+	   (char *)BUF + (int)((BUF-&gt;vhl &amp; 0x0f) * 4),
+	   len);
+      
+    /* Update the bitmap. */
+    if(offset / (8 * 8) == (offset + len) / (8 * 8)) {
+      /* If the two endpoints are in the same byte, we only update
+	 that byte. */
+	     
+      uip_reassbitmap[offset / (8 * 8)] |=
+	     bitmap_bits[(offset / 8 ) &amp; 7] &amp;
+	     ~bitmap_bits[((offset + len) / 8 ) &amp; 7];
+    } else {
+      /* If the two endpoints are in different bytes, we update the
+	 bytes in the endpoints and fill the stuff inbetween with
+	 0xff. */
+      uip_reassbitmap[offset / (8 * 8)] |=
+	bitmap_bits[(offset / 8 ) &amp; 7];
+      for(i = 1 + offset / (8 * 8); i &lt; (offset + len) / (8 * 8); ++i) {
+	uip_reassbitmap[i] = 0xff;
+      }
+      uip_reassbitmap[(offset + len) / (8 * 8)] |=
+	~bitmap_bits[((offset + len) / 8 ) &amp; 7];
+    }
+    
+    /* If this fragment has the More Fragments flag set to zero, we
+       know that this is the last fragment, so we can calculate the
+       size of the entire packet. We also set the
+       IP_REASS_FLAG_LASTFRAG flag to indicate that we have received
+       the final fragment. */
+
+    if((BUF-&gt;ipoffset[0] &amp; IP_MF) == 0) {
+      uip_reassflags |= UIP_REASS_FLAG_LASTFRAG;
+      uip_reasslen = offset + len;
+    }
+    
+    /* Finally, we check if we have a full packet in the buffer. We do
+       this by checking if we have the last fragment and if all bits
+       in the bitmap are set. */
+    if(uip_reassflags &amp; UIP_REASS_FLAG_LASTFRAG) {
+      /* Check all bytes up to and including all but the last byte in
+	 the bitmap. */
+      for(i = 0; i &lt; uip_reasslen / (8 * 8) - 1; ++i) {
+	if(uip_reassbitmap[i] != 0xff) {
+	  goto nullreturn;
+	}
+      }
+      /* Check the last byte in the bitmap. It should contain just the
+	 right amount of bits. */
+      if(uip_reassbitmap[uip_reasslen / (8 * 8)] !=
+	 (u8_t)~bitmap_bits[uip_reasslen / 8 &amp; 7]) {
+	goto nullreturn;
+      }
+
+      /* If we have come this far, we have a full packet in the
+	 buffer, so we allocate a pbuf and copy the packet into it. We
+	 also reset the timer. */
+      uip_reasstmr = 0;
+      memcpy(BUF, FBUF, uip_reasslen);
+
+      /* Pretend to be a &quot;normal&quot; (i.e., not fragmented) IP packet
+	 from now on. */
+      BUF-&gt;ipoffset[0] = BUF-&gt;ipoffset[1] = 0;
+      BUF-&gt;len[0] = uip_reasslen &gt;&gt; 8;
+      BUF-&gt;len[1] = uip_reasslen &amp; 0xff;
+      BUF-&gt;ipchksum = 0;
+      BUF-&gt;ipchksum = ~(uip_ipchksum());
+
+      return uip_reasslen;
+    }
+  }
+
+ nullreturn:
+  return 0;
+}
+#endif /* UIP_REASSEMBLY */
+/*---------------------------------------------------------------------------*/
+#if UIP_TCP
+static void
+uip_add_rcv_nxt(u16_t n)
+{
+  uip_add32(uip_conn-&gt;rcv_nxt, n);
+  uip_conn-&gt;rcv_nxt[0] = uip_acc32[0];
+  uip_conn-&gt;rcv_nxt[1] = uip_acc32[1];
+  uip_conn-&gt;rcv_nxt[2] = uip_acc32[2];
+  uip_conn-&gt;rcv_nxt[3] = uip_acc32[3];
+}
+#endif /* UIP_TCP */
+/*---------------------------------------------------------------------------*/
+void
+uip_process(u8_t flag)
+{
+#if UIP_TCP
+  register struct uip_conn *uip_connr = uip_conn;
+#endif /* UIP_TCP */
+
+#if UIP_UDP
+  if(flag == UIP_UDP_SEND_CONN) {
+    goto udp_send;
+  }
+#endif /* UIP_UDP */
+  
+  uip_sappdata = uip_appdata = &amp;uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN];
+
+  /* Check if we were invoked because of a poll request for a
+     particular connection. */
+#if UIP_TCP
+  if(flag == UIP_POLL_REQUEST) {
+    if((uip_connr-&gt;tcpstateflags &amp; UIP_TS_MASK) == UIP_ESTABLISHED &amp;&amp;
+       !uip_outstanding(uip_connr)) {
+	uip_flags = UIP_POLL;
+	UIP_APPCALL();
+	goto appsend;
+    }
+    goto drop;
+    
+    /* Check if we were invoked because of the perodic timer fireing. */
+  } else if(flag == UIP_TIMER) {
+#if UIP_REASSEMBLY
+    if(uip_reasstmr != 0) {
+      --uip_reasstmr;
+    }
+#endif /* UIP_REASSEMBLY */
+    /* Increase the initial sequence number. */
+    if(++iss[3] == 0) {
+      if(++iss[2] == 0) {
+	if(++iss[1] == 0) {
+	  ++iss[0];
+	}
+      }
+    }
+
+    /* Reset the length variables. */
+    uip_len = 0;
+    uip_slen = 0;
+
+    /* Check if the connection is in a state in which we simply wait
+       for the connection to time out. If so, we increase the
+       connection's timer and remove the connection if it times
+       out. */
+    if(uip_connr-&gt;tcpstateflags == UIP_TIME_WAIT ||
+       uip_connr-&gt;tcpstateflags == UIP_FIN_WAIT_2) {
+      ++(uip_connr-&gt;timer);
+      if(uip_connr-&gt;timer == UIP_TIME_WAIT_TIMEOUT) {
+	uip_connr-&gt;tcpstateflags = UIP_CLOSED;
+      }
+    } else if(uip_connr-&gt;tcpstateflags != UIP_CLOSED &amp;&amp; uip_connr-&gt;tcpstateflags != UIP_RESERVED) {
+      /* If the connection has outstanding data, we increase the
+	 connection's timer and see if it has reached the RTO value
+	 in which case we retransmit. */
+      if(uip_outstanding(uip_connr)) {
+	if(uip_connr-&gt;timer-- == 0) {
+	  if(uip_connr-&gt;nrtx == UIP_MAXRTX ||
+	     ((uip_connr-&gt;tcpstateflags == UIP_SYN_SENT ||
+	       uip_connr-&gt;tcpstateflags == UIP_SYN_RCVD) &amp;&amp;
+	      uip_connr-&gt;nrtx == UIP_MAXSYNRTX)) {
+	    uip_connr-&gt;tcpstateflags = UIP_CLOSED;
+
+	    /* We call UIP_APPCALL() with uip_flags set to
+	       UIP_TIMEDOUT to inform the application that the
+	       connection has timed out. */
+	    uip_flags = UIP_TIMEDOUT;
+	    UIP_APPCALL();
+
+	    /* We also send a reset packet to the remote host. */
+	    BUF-&gt;flags = TCP_RST | TCP_ACK;
+	    goto tcp_send_nodata;
+	  }
+
+	  /* Exponential backoff. */
+	  uip_connr-&gt;timer = UIP_RTO &lt;&lt; (uip_connr-&gt;nrtx &gt; 4?
+					 4:
+					 uip_connr-&gt;nrtx);
+	  ++(uip_connr-&gt;nrtx);
+	  
+	  /* Ok, so we need to retransmit. We do this differently
+	     depending on which state we are in. In ESTABLISHED, we
+	     call upon the application so that it may prepare the
+	     data for the retransmit. In SYN_RCVD, we resend the
+	     SYNACK that we sent earlier and in LAST_ACK we have to
+	     retransmit our FINACK. */
+	  UIP_STAT(++uip_stat.tcp.rexmit);
+	  switch(uip_connr-&gt;tcpstateflags &amp; UIP_TS_MASK) {
+	  case UIP_SYN_RCVD:
+	    /* In the SYN_RCVD state, we should retransmit our
+               SYNACK. */
+	    goto tcp_send_synack;
+	    
+#if UIP_ACTIVE_OPEN
+	  case UIP_SYN_SENT:
+	    /* In the SYN_SENT state, we retransmit out SYN. */
+	    BUF-&gt;flags = 0;
+	    goto tcp_send_syn;
+#endif /* UIP_ACTIVE_OPEN */
+	    
+	  case UIP_ESTABLISHED:
+	    /* In the ESTABLISHED state, we call upon the application
+               to do the actual retransmit after which we jump into
+               the code for sending out the packet (the apprexmit
+               label). */
+	    uip_flags = UIP_REXMIT;
+	    UIP_APPCALL();
+	    goto apprexmit;
+	    
+	  case UIP_FIN_WAIT_1:
+	  case UIP_CLOSING:
+	  case UIP_LAST_ACK:
+	    /* In all these states we should retransmit a FINACK. */
+	    goto tcp_send_finack;
+	    
+	  }
+	}
+      } else if((uip_connr-&gt;tcpstateflags &amp; UIP_TS_MASK) == UIP_ESTABLISHED) {
+	/* If there was no need for a retransmission, we poll the
+           application for new data. */
+	uip_flags = UIP_POLL;
+	UIP_APPCALL();
+	goto appsend;
+      }
+    }
+    goto drop;
+  }
+#endif /* UIP_TCP */
+#if UIP_UDP
+  if(flag == UIP_UDP_TIMER) {
+    if(uip_udp_conn-&gt;lport != 0) {
+#if UIP_TCP
+      uip_conn = NULL;
+#endif /* UIP_TCP */
+      uip_sappdata = uip_appdata = &amp;uip_buf[UIP_LLH_LEN + UIP_IPUDPH_LEN];
+      uip_len = uip_slen = 0;
+      uip_flags = UIP_POLL;
+      UIP_UDP_APPCALL();
+      goto udp_send;
+    } else {
+      goto drop;
+    }
+  }
+#endif
+
+  /* This is where the input processing starts. */
+  UIP_STAT(++uip_stat.ip.recv);
+
+  /* Start of IP input header processing code. */
+  
+#if UIP_CONF_IPV6
+  /* Check validity of the IP header. */
+  if((BUF-&gt;vtc &amp; 0xf0) != 0x60)  { /* IP version and header length. */
+    UIP_STAT(++uip_stat.ip.drop);
+    UIP_STAT(++uip_stat.ip.vhlerr);
+    UIP_LOG(&quot;ipv6: invalid version.&quot;);
+    goto drop;
+  }
+#else /* UIP_CONF_IPV6 */
+  /* Check validity of the IP header. */
+  if(BUF-&gt;vhl != 0x45)  { /* IP version and header length. */
+    UIP_STAT(++uip_stat.ip.drop);
+    UIP_STAT(++uip_stat.ip.vhlerr);
+    UIP_LOG(&quot;ip: invalid version or header length.&quot;);
+    goto drop;
+  }
+#endif /* UIP_CONF_IPV6 */
+  
+  /* Check the size of the packet. If the size reported to us in
+     uip_len is smaller the size reported in the IP header, we assume
+     that the packet has been corrupted in transit. If the size of
+     uip_len is larger than the size reported in the IP packet header,
+     the packet has been padded and we set uip_len to the correct
+     value.. */
+
+  if((BUF-&gt;len[0] &lt;&lt; 8) + BUF-&gt;len[1] &lt;= uip_len) {
+    uip_len = (BUF-&gt;len[0] &lt;&lt; 8) + BUF-&gt;len[1];
+#if UIP_CONF_IPV6
+    uip_len += 40; /* The length reported in the IPv6 header is the
+		      length of the payload that follows the
+		      header. However, uIP uses the uip_len variable
+		      for holding the size of the entire packet,
+		      including the IP header. For IPv4 this is not a
+		      problem as the length field in the IPv4 header
+		      contains the length of the entire packet. But
+		      for IPv6 we need to add the size of the IPv6
+		      header (40 bytes). */
+#endif /* UIP_CONF_IPV6 */
+  } else {
+    UIP_LOG(&quot;ip: packet shorter than reported in IP header.&quot;);
+    goto drop;
+  }
+
+#if !UIP_CONF_IPV6
+  /* Check the fragment flag. */
+  if((BUF-&gt;ipoffset[0] &amp; 0x3f) != 0 ||
+     BUF-&gt;ipoffset[1] != 0) {
+#if UIP_REASSEMBLY
+    uip_len = uip_reass();
+    if(uip_len == 0) {
+      goto drop;
+    }
+#else /* UIP_REASSEMBLY */
+    UIP_STAT(++uip_stat.ip.drop);
+    UIP_STAT(++uip_stat.ip.fragerr);
+    UIP_LOG(&quot;ip: fragment dropped.&quot;);
+    goto drop;
+#endif /* UIP_REASSEMBLY */
+  }
+#endif /* UIP_CONF_IPV6 */
+
+  if(uip_ipaddr_cmp(uip_hostaddr, all_zeroes_addr)) {
+    /* If we are configured to use ping IP address configuration and
+       hasn't been assigned an IP address yet, we accept all ICMP
+       packets. */
+#if UIP_PINGADDRCONF &amp;&amp; !UIP_CONF_IPV6
+    if(BUF-&gt;proto == UIP_PROTO_ICMP) {
+      UIP_LOG(&quot;ip: possible ping config packet received.&quot;);
+      goto icmp_input;
+    } else {
+      UIP_LOG(&quot;ip: packet dropped since no address assigned.&quot;);
+      goto drop;
+    }
+#endif /* UIP_PINGADDRCONF */
+
+  } else {
+    /* If IP broadcast support is configured, we check for a broadcast
+       UDP packet, which may be destined to us. */
+#if UIP_BROADCAST
+    DEBUG_PRINTF(&quot;UDP IP checksum 0x%04x\n&quot;, uip_ipchksum());
+    if(BUF-&gt;proto == UIP_PROTO_UDP &amp;&amp;
+       uip_ipaddr_cmp(BUF-&gt;destipaddr, all_ones_addr)
+       /*&amp;&amp;
+	 uip_ipchksum() == 0xffff*/) {
+      goto udp_input;
+    }
+#endif /* UIP_BROADCAST */
+    
+    /* Check if the packet is destined for our IP address. */
+#if !UIP_CONF_IPV6
+    if(!uip_ipaddr_cmp(BUF-&gt;destipaddr, uip_hostaddr)) {
+      UIP_STAT(++uip_stat.ip.drop);
+      goto drop;
+    }
+#else /* UIP_CONF_IPV6 */
+    /* For IPv6, packet reception is a little trickier as we need to
+       make sure that we listen to certain multicast addresses (all
+       hosts multicast address, and the solicited-node multicast
+       address) as well. However, we will cheat here and accept all
+       multicast packets that are sent to the ff02::/16 addresses. */
+    if(!uip_ipaddr_cmp(BUF-&gt;destipaddr, uip_hostaddr) &amp;&amp;
+       BUF-&gt;destipaddr[0] != HTONS(0xff02)) {
+      UIP_STAT(++uip_stat.ip.drop);
+      goto drop;
+    }
+#endif /* UIP_CONF_IPV6 */
+  }
+
+#if !UIP_CONF_IPV6
+  if(uip_ipchksum() != 0xffff) { /* Compute and check the IP header
+				    checksum. */
+    UIP_STAT(++uip_stat.ip.drop);
+    UIP_STAT(++uip_stat.ip.chkerr);
+    UIP_LOG(&quot;ip: bad checksum.&quot;);
+    goto drop;
+  }
+#endif /* UIP_CONF_IPV6 */
+
+#if UIP_TCP
+  if(BUF-&gt;proto == UIP_PROTO_TCP) { /* Check for TCP packet. If so,
+				       proceed with TCP input
+				       processing. */
+    goto tcp_input;
+  }
+#endif /* UIP_TCP */
+
+#if UIP_UDP
+  if(BUF-&gt;proto == UIP_PROTO_UDP) {
+    goto udp_input;
+  }
+#endif /* UIP_UDP */
+
+#if !UIP_CONF_IPV6
+  /* ICMPv4 processing code follows. */
+  if(BUF-&gt;proto != UIP_PROTO_ICMP) { /* We only allow ICMP packets from
+					here. */
+    UIP_STAT(++uip_stat.ip.drop);
+    UIP_STAT(++uip_stat.ip.protoerr);
+    UIP_LOG(&quot;ip: neither tcp nor icmp.&quot;);
+    goto drop;
+  }
+
+#if UIP_PINGADDRCONF
+ icmp_input:
+#endif /* UIP_PINGADDRCONF */
+  UIP_STAT(++uip_stat.icmp.recv);
+
+  /* ICMP echo (i.e., ping) processing. This is simple, we only change
+     the ICMP type from ECHO to ECHO_REPLY and adjust the ICMP
+     checksum before we return the packet. */
+  if(ICMPBUF-&gt;type != ICMP_ECHO) {
+    UIP_STAT(++uip_stat.icmp.drop);
+    UIP_STAT(++uip_stat.icmp.typeerr);
+    UIP_LOG(&quot;icmp: not icmp echo.&quot;);
+    goto drop;
+  }
+
+  /* If we are configured to use ping IP address assignment, we use
+     the destination IP address of this ping packet and assign it to
+     ourself. */
+#if UIP_PINGADDRCONF
+  if((uip_hostaddr[0] | uip_hostaddr[1]) == 0) {
+    uip_hostaddr[0] = BUF-&gt;destipaddr[0];
+    uip_hostaddr[1] = BUF-&gt;destipaddr[1];
+  }
+#endif /* UIP_PINGADDRCONF */
+
+  ICMPBUF-&gt;type = ICMP_ECHO_REPLY;
+
+  if(ICMPBUF-&gt;icmpchksum &gt;= HTONS(0xffff - (ICMP_ECHO &lt;&lt; 8))) {
+    ICMPBUF-&gt;icmpchksum += HTONS(ICMP_ECHO &lt;&lt; 8) + 1;
+  } else {
+    ICMPBUF-&gt;icmpchksum += HTONS(ICMP_ECHO &lt;&lt; 8);
+  }
+
+  /* Swap IP addresses. */
+  uip_ipaddr_copy(BUF-&gt;destipaddr, BUF-&gt;srcipaddr);
+  uip_ipaddr_copy(BUF-&gt;srcipaddr, uip_hostaddr);
+
+  UIP_STAT(++uip_stat.icmp.sent);
+  goto send;
+
+  /* End of IPv4 input header processing code. */
+#else /* !UIP_CONF_IPV6 */
+
+  /* This is IPv6 ICMPv6 processing code. */
+  DEBUG_PRINTF(&quot;icmp6_input: length %d\n&quot;, uip_len);
+
+  if(BUF-&gt;proto != UIP_PROTO_ICMP6) { /* We only allow ICMPv6 packets from
+					 here. */
+    UIP_STAT(++uip_stat.ip.drop);
+    UIP_STAT(++uip_stat.ip.protoerr);
+    UIP_LOG(&quot;ip: neither tcp nor icmp6.&quot;);
+    goto drop;
+  }
+
+  UIP_STAT(++uip_stat.icmp.recv);
+
+  /* If we get a neighbor solicitation for our address we should send
+     a neighbor advertisement message back. */
+  if(ICMPBUF-&gt;type == ICMP6_NEIGHBOR_SOLICITATION) {
+    if(uip_ipaddr_cmp(ICMPBUF-&gt;icmp6data, uip_hostaddr)) {
+
+      if(ICMPBUF-&gt;options[0] == ICMP6_OPTION_SOURCE_LINK_ADDRESS) {
+	/* Save the sender's address in our neighbor list. */
+	uip_neighbor_add(ICMPBUF-&gt;srcipaddr, &amp;(ICMPBUF-&gt;options[2]));
+      }
+      
+      /* We should now send a neighbor advertisement back to where the
+	 neighbor solicication came from. */
+      ICMPBUF-&gt;type = ICMP6_NEIGHBOR_ADVERTISEMENT;
+      ICMPBUF-&gt;flags = ICMP6_FLAG_S; /* Solicited flag. */
+      
+      ICMPBUF-&gt;reserved1 = ICMPBUF-&gt;reserved2 = ICMPBUF-&gt;reserved3 = 0;
+      
+      uip_ipaddr_copy(ICMPBUF-&gt;destipaddr, ICMPBUF-&gt;srcipaddr);
+      uip_ipaddr_copy(ICMPBUF-&gt;srcipaddr, uip_hostaddr);
+      ICMPBUF-&gt;options[0] = ICMP6_OPTION_TARGET_LINK_ADDRESS;
+      ICMPBUF-&gt;options[1] = 1;  /* Options length, 1 = 8 bytes. */
+      memcpy(&amp;(ICMPBUF-&gt;options[2]), &amp;uip_ethaddr, sizeof(uip_ethaddr));
+      ICMPBUF-&gt;icmpchksum = 0;
+      ICMPBUF-&gt;icmpchksum = ~uip_icmp6chksum();
+      goto send;
+      
+    }
+    goto drop;
+  } else if(ICMPBUF-&gt;type == ICMP6_ECHO) {
+    /* ICMP echo (i.e., ping) processing. This is simple, we only
+       change the ICMP type from ECHO to ECHO_REPLY and update the
+       ICMP checksum before we return the packet. */
+
+    ICMPBUF-&gt;type = ICMP6_ECHO_REPLY;
+    
+    uip_ipaddr_copy(BUF-&gt;destipaddr, BUF-&gt;srcipaddr);
+    uip_ipaddr_copy(BUF-&gt;srcipaddr, uip_hostaddr);
+    ICMPBUF-&gt;icmpchksum = 0;
+    ICMPBUF-&gt;icmpchksum = ~uip_icmp6chksum();
+    
+    UIP_STAT(++uip_stat.icmp.sent);
+    goto send;
+  } else {
+    DEBUG_PRINTF(&quot;Unknown icmp6 message type %d\n&quot;, ICMPBUF-&gt;type);
+    UIP_STAT(++uip_stat.icmp.drop);
+    UIP_STAT(++uip_stat.icmp.typeerr);
+    UIP_LOG(&quot;icmp: unknown ICMP message.&quot;);
+    goto drop;
+  }
+
+  /* End of IPv6 ICMP processing. */
+  
+#endif /* !UIP_CONF_IPV6 */
+
+#if UIP_UDP
+  /* UDP input processing. */
+ udp_input:
+  /* UDP processing is really just a hack. We don't do anything to the
+     UDP/IP headers, but let the UDP application do all the hard
+     work. If the application sets uip_slen, it has a packet to
+     send. */
+#if UIP_UDP_CHECKSUMS
+  uip_len = uip_len - UIP_IPUDPH_LEN;
+  uip_appdata = &amp;uip_buf[UIP_LLH_LEN + UIP_IPUDPH_LEN];
+  if(UDPBUF-&gt;udpchksum != 0 &amp;&amp; uip_udpchksum() != 0xffff) {
+    UIP_STAT(++uip_stat.udp.drop);
+    UIP_STAT(++uip_stat.udp.chkerr);
+    UIP_LOG(&quot;udp: bad checksum.&quot;);
+    goto drop;
+  }
+#else /* UIP_UDP_CHECKSUMS */
+  uip_len = uip_len - UIP_IPUDPH_LEN;
+#endif /* UIP_UDP_CHECKSUMS */
+
+  /* Demultiplex this UDP packet between the UDP &quot;connections&quot;. */
+  for(uip_udp_conn = &amp;uip_udp_conns[0];
+      uip_udp_conn &lt; &amp;uip_udp_conns[UIP_UDP_CONNS];
+      ++uip_udp_conn) {
+    /* If the local UDP port is non-zero, the connection is considered
+       to be used. If so, the local port number is checked against the
+       destination port number in the received packet. If the two port
+       numbers match, the remote port number is checked if the
+       connection is bound to a remote port. Finally, if the
+       connection is bound to a remote IP address, the source IP
+       address of the packet is checked. */
+    if(uip_udp_conn-&gt;lport != 0 &amp;&amp;
+       UDPBUF-&gt;destport == uip_udp_conn-&gt;lport &amp;&amp;
+       (uip_udp_conn-&gt;rport == 0 ||
+        UDPBUF-&gt;srcport == uip_udp_conn-&gt;rport ||
+        uip_udp_conn-&gt;rport == HTONS(69)) &amp;&amp;
+       (uip_ipaddr_cmp(uip_udp_conn-&gt;ripaddr, all_zeroes_addr) ||
+	uip_ipaddr_cmp(uip_udp_conn-&gt;ripaddr, all_ones_addr) ||
+	uip_ipaddr_cmp(BUF-&gt;srcipaddr, uip_udp_conn-&gt;ripaddr))) {
+      goto udp_found;
+    }
+  }
+  UIP_LOG(&quot;udp: no matching connection found&quot;);
+  goto drop;
+  
+ udp_found:
+#if UIP_TCP
+  uip_conn = NULL;
+#endif /* UIP_TCP */
+  uip_flags = UIP_NEWDATA;
+  uip_sappdata = uip_appdata = &amp;uip_buf[UIP_LLH_LEN + UIP_IPUDPH_LEN];
+  uip_slen = 0;
+  UIP_UDP_APPCALL();
+ udp_send:
+  if(uip_slen == 0) {
+    goto drop;
+  }
+  uip_len = uip_slen + UIP_IPUDPH_LEN;
+
+#if UIP_CONF_IPV6
+  /* For IPv6, the IP length field does not include the IPv6 IP header
+     length. */
+  BUF-&gt;len[0] = ((uip_len - UIP_IPH_LEN) &gt;&gt; 8);
+  BUF-&gt;len[1] = ((uip_len - UIP_IPH_LEN) &amp; 0xff);
+#else /* UIP_CONF_IPV6 */
+  BUF-&gt;len[0] = (uip_len &gt;&gt; 8);
+  BUF-&gt;len[1] = (uip_len &amp; 0xff);
+#endif /* UIP_CONF_IPV6 */
+
+  BUF-&gt;ttl = uip_udp_conn-&gt;ttl;
+  BUF-&gt;proto = UIP_PROTO_UDP;
+
+  UDPBUF-&gt;udplen = HTONS(uip_slen + UIP_UDPH_LEN);
+  UDPBUF-&gt;udpchksum = 0;
+
+  BUF-&gt;srcport  = uip_udp_conn-&gt;lport;
+  BUF-&gt;destport = uip_udp_conn-&gt;rport;
+
+  uip_ipaddr_copy(BUF-&gt;srcipaddr, uip_hostaddr);
+  uip_ipaddr_copy(BUF-&gt;destipaddr, uip_udp_conn-&gt;ripaddr);
+   
+  uip_appdata = &amp;uip_buf[UIP_LLH_LEN + UIP_IPTCPH_LEN];
+
+#if UIP_UDP_CHECKSUMS
+  /* Calculate UDP checksum. */
+  UDPBUF-&gt;udpchksum = ~(uip_udpchksum());
+  if(UDPBUF-&gt;udpchksum == 0) {
+    UDPBUF-&gt;udpchksum = 0xffff;
+  }
+#endif /* UIP_UDP_CHECKSUMS */
+  
+  goto ip_send_nolen;
+#endif /* UIP_UDP */
+  
+  /* TCP input processing. */
+#if UIP_TCP
+ tcp_input:
+  UIP_STAT(++uip_stat.tcp.recv);
+
+  /* Start of TCP input header processing code. */
+  
+  if(uip_tcpchksum() != 0xffff) {   /* Compute and check the TCP
+				       checksum. */
+    UIP_STAT(++uip_stat.tcp.drop);
+    UIP_STAT(++uip_stat.tcp.chkerr);
+    UIP_LOG(&quot;tcp: bad checksum.&quot;);
+    goto drop;
+  }
+  
+  
+  /* Demultiplex this segment. */
+  /* First check any active connections. */
+  for(uip_connr = &amp;uip_conns[0]; uip_connr &lt;= &amp;uip_conns[UIP_CONNS - 1];
+      ++uip_connr) {
+    if(uip_connr-&gt;tcpstateflags != UIP_CLOSED &amp;&amp; uip_connr-&gt;tcpstateflags != UIP_RESERVED &amp;&amp;
+       BUF-&gt;destport == uip_connr-&gt;lport &amp;&amp;
+       BUF-&gt;srcport == uip_connr-&gt;rport &amp;&amp;
+       uip_ipaddr_cmp(BUF-&gt;srcipaddr, uip_connr-&gt;ripaddr)) {
+      goto found;
+    }
+  }
+
+  /* If we didn't find and active connection that expected the packet,
+     either this packet is an old duplicate, or this is a SYN packet
+     destined for a connection in LISTEN. If the SYN flag isn't set,
+     it is an old packet and we send a RST. */
+  if((BUF-&gt;flags &amp; TCP_CTL) != TCP_SYN) {
+    goto reset;
+  }
+  
+  tmp16 = BUF-&gt;destport;
+  /* Next, check listening connections. */
+  for(c = 0; c &lt; UIP_LISTENPORTS; ++c) {
+    if(tmp16 == uip_listenports[c])
+      goto found_listen;
+  }
+  
+  /* No matching connection found, so we send a RST packet. */
+  UIP_STAT(++uip_stat.tcp.synrst);
+ reset:
+
+  /* We do not send resets in response to resets. */
+  if(BUF-&gt;flags &amp; TCP_RST) {
+    goto drop;
+  }
+
+  UIP_STAT(++uip_stat.tcp.rst);
+  
+  BUF-&gt;flags = TCP_RST | TCP_ACK;
+  uip_len = UIP_IPTCPH_LEN;
+  BUF-&gt;tcpoffset = 5 &lt;&lt; 4;
+
+  /* Flip the seqno and ackno fields in the TCP header. */
+  c = BUF-&gt;seqno[3];
+  BUF-&gt;seqno[3] = BUF-&gt;ackno[3];
+  BUF-&gt;ackno[3] = c;
+  
+  c = BUF-&gt;seqno[2];
+  BUF-&gt;seqno[2] = BUF-&gt;ackno[2];
+  BUF-&gt;ackno[2] = c;
+  
+  c = BUF-&gt;seqno[1];
+  BUF-&gt;seqno[1] = BUF-&gt;ackno[1];
+  BUF-&gt;ackno[1] = c;
+  
+  c = BUF-&gt;seqno[0];
+  BUF-&gt;seqno[0] = BUF-&gt;ackno[0];
+  BUF-&gt;ackno[0] = c;
+
+  /* We also have to increase the sequence number we are
+     acknowledging. If the least significant byte overflowed, we need
+     to propagate the carry to the other bytes as well. */
+  if(++BUF-&gt;ackno[3] == 0) {
+    if(++BUF-&gt;ackno[2] == 0) {
+      if(++BUF-&gt;ackno[1] == 0) {
+	++BUF-&gt;ackno[0];
+      }
+    }
+  }
+ 
+  /* Swap port numbers. */
+  tmp16 = BUF-&gt;srcport;
+  BUF-&gt;srcport = BUF-&gt;destport;
+  BUF-&gt;destport = tmp16;
+  
+  /* Swap IP addresses. */
+  uip_ipaddr_copy(BUF-&gt;destipaddr, BUF-&gt;srcipaddr);
+  uip_ipaddr_copy(BUF-&gt;srcipaddr, uip_hostaddr);
+  
+  /* And send out the RST packet! */
+  goto tcp_send_noconn;
+
+  /* This label will be jumped to if we matched the incoming packet
+     with a connection in LISTEN. In that case, we should create a new
+     connection and send a SYNACK in return. */
+ found_listen:
+  /* First we check if there are any connections avaliable. Unused
+     connections are kept in the same table as used connections, but
+     unused ones have the tcpstate set to CLOSED. Also, connections in
+     TIME_WAIT are kept track of and we'll use the oldest one if no
+     CLOSED connections are found. Thanks to Eddie C. Dost for a very
+     nice algorithm for the TIME_WAIT search. */
+  uip_connr = 0;
+  for(c = 0; c &lt; UIP_CONNS; ++c) {
+    if(uip_conns[c].tcpstateflags == UIP_CLOSED) {
+      uip_connr = &amp;uip_conns[c];
+      break;
+    }
+    if(uip_conns[c].tcpstateflags == UIP_TIME_WAIT) {
+      if(uip_connr == 0 ||
+	 uip_conns[c].timer &gt; uip_connr-&gt;timer) {
+	uip_connr = &amp;uip_conns[c];
+      }
+    }
+  }
+
+  if(uip_connr == 0) {
+    /* All connections are used already, we drop packet and hope that
+       the remote end will retransmit the packet at a time when we
+       have more spare connections. */
+    UIP_STAT(++uip_stat.tcp.syndrop);
+    UIP_LOG(&quot;tcp: found no unused connections.&quot;);
+    goto drop;
+  }
+  uip_conn = uip_connr;
+  
+  /* Fill in the necessary fields for the new connection. */
+  uip_connr-&gt;rto = uip_connr-&gt;timer = UIP_RTO;
+  uip_connr-&gt;sa = 0;
+  uip_connr-&gt;sv = 4;
+  uip_connr-&gt;nrtx = 0;
+  uip_connr-&gt;lport = BUF-&gt;destport;
+  uip_connr-&gt;rport = BUF-&gt;srcport;
+  uip_ipaddr_copy(uip_connr-&gt;ripaddr, BUF-&gt;srcipaddr);
+  uip_connr-&gt;tcpstateflags = UIP_SYN_RCVD;
+
+  uip_connr-&gt;snd_nxt[0] = iss[0];
+  uip_connr-&gt;snd_nxt[1] = iss[1];
+  uip_connr-&gt;snd_nxt[2] = iss[2];
+  uip_connr-&gt;snd_nxt[3] = iss[3];
+  uip_connr-&gt;len = 1;
+
+  /* rcv_nxt should be the seqno from the incoming packet + 1. */
+  uip_connr-&gt;rcv_nxt[3] = BUF-&gt;seqno[3];
+  uip_connr-&gt;rcv_nxt[2] = BUF-&gt;seqno[2];
+  uip_connr-&gt;rcv_nxt[1] = BUF-&gt;seqno[1];
+  uip_connr-&gt;rcv_nxt[0] = BUF-&gt;seqno[0];
+  uip_add_rcv_nxt(1);
+
+  /* Parse the TCP MSS option, if present. */
+  if((BUF-&gt;tcpoffset &amp; 0xf0) &gt; 0x50) {
+    for(c = 0; c &lt; ((BUF-&gt;tcpoffset &gt;&gt; 4) - 5) &lt;&lt; 2 ;) {
+      opt = uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + c];
+      if(opt == TCP_OPT_END) {
+	/* End of options. */
+	break;
+      } else if(opt == TCP_OPT_NOOP) {
+	++c;
+	/* NOP option. */
+      } else if(opt == TCP_OPT_MSS &amp;&amp;
+		uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
+	/* An MSS option with the right option length. */
+	tmp16 = ((u16_t)uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] &lt;&lt; 8) |
+	  (u16_t)uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + 3 + c];
+	uip_connr-&gt;initialmss = uip_connr-&gt;mss =
+	  tmp16 &gt; UIP_TCP_MSS? UIP_TCP_MSS: tmp16;
+	
+	/* And we are done processing options. */
+	break;
+      } else {
+	/* All other options have a length field, so that we easily
+	   can skip past them. */
+	if(uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0) {
+	  /* If the length field is zero, the options are malformed
+	     and we don't process them further. */
+	  break;
+	}
+	c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
+      }
+    }
+  }
+  
+  /* Our response will be a SYNACK. */
+#if UIP_ACTIVE_OPEN
+ tcp_send_synack:
+  BUF-&gt;flags = TCP_ACK;
+  
+ tcp_send_syn:
+  BUF-&gt;flags |= TCP_SYN;
+#else /* UIP_ACTIVE_OPEN */
+ tcp_send_synack:
+  BUF-&gt;flags = TCP_SYN | TCP_ACK;
+#endif /* UIP_ACTIVE_OPEN */
+  
+  /* We send out the TCP Maximum Segment Size option with our
+     SYNACK. */
+  BUF-&gt;optdata[0] = TCP_OPT_MSS;
+  BUF-&gt;optdata[1] = TCP_OPT_MSS_LEN;
+  BUF-&gt;optdata[2] = (UIP_TCP_MSS) / 256;
+  BUF-&gt;optdata[3] = (UIP_TCP_MSS) &amp; 255;
+  uip_len = UIP_IPTCPH_LEN + TCP_OPT_MSS_LEN;
+  BUF-&gt;tcpoffset = ((UIP_TCPH_LEN + TCP_OPT_MSS_LEN) / 4) &lt;&lt; 4;
+  goto tcp_send;
+
+  /* This label will be jumped to if we found an active connection. */
+ found:
+  uip_conn = uip_connr;
+  uip_flags = 0;
+  /* We do a very naive form of TCP reset processing; we just accept
+     any RST and kill our connection. We should in fact check if the
+     sequence number of this reset is wihtin our advertised window
+     before we accept the reset. */
+  if(BUF-&gt;flags &amp; TCP_RST) {
+    uip_connr-&gt;tcpstateflags = UIP_CLOSED;
+    UIP_LOG(&quot;tcp: got reset, aborting connection.&quot;);
+    uip_flags = UIP_ABORT;
+    UIP_APPCALL();
+    goto drop;
+  }
+  /* Calculated the length of the data, if the application has sent
+     any data to us. */
+  c = (BUF-&gt;tcpoffset &gt;&gt; 4) &lt;&lt; 2;
+  /* uip_len will contain the length of the actual TCP data. This is
+     calculated by subtracing the length of the TCP header (in
+     c) and the length of the IP header (20 bytes). */
+  uip_len = uip_len - c - UIP_IPH_LEN;
+
+  /* First, check if the sequence number of the incoming packet is
+     what we're expecting next. If not, we send out an ACK with the
+     correct numbers in. */
+  if(!(((uip_connr-&gt;tcpstateflags &amp; UIP_TS_MASK) == UIP_SYN_SENT) &amp;&amp;
+       ((BUF-&gt;flags &amp; TCP_CTL) == (TCP_SYN | TCP_ACK)))) {
+    if((uip_len &gt; 0 || ((BUF-&gt;flags &amp; (TCP_SYN | TCP_FIN)) != 0)) &amp;&amp;
+       (BUF-&gt;seqno[0] != uip_connr-&gt;rcv_nxt[0] ||
+	BUF-&gt;seqno[1] != uip_connr-&gt;rcv_nxt[1] ||
+	BUF-&gt;seqno[2] != uip_connr-&gt;rcv_nxt[2] ||
+	BUF-&gt;seqno[3] != uip_connr-&gt;rcv_nxt[3])) {
+      goto tcp_send_ack;
+    }
+  }
+
+  /* Next, check if the incoming segment acknowledges any outstanding
+     data. If so, we update the sequence number, reset the length of
+     the outstanding data, calculate RTT estimations, and reset the
+     retransmission timer. */
+  if((BUF-&gt;flags &amp; TCP_ACK) &amp;&amp; uip_outstanding(uip_connr)) {
+    uip_add32(uip_connr-&gt;snd_nxt, uip_connr-&gt;len);
+
+    if(BUF-&gt;ackno[0] == uip_acc32[0] &amp;&amp;
+       BUF-&gt;ackno[1] == uip_acc32[1] &amp;&amp;
+       BUF-&gt;ackno[2] == uip_acc32[2] &amp;&amp;
+       BUF-&gt;ackno[3] == uip_acc32[3]) {
+      /* Update sequence number. */
+      uip_connr-&gt;snd_nxt[0] = uip_acc32[0];
+      uip_connr-&gt;snd_nxt[1] = uip_acc32[1];
+      uip_connr-&gt;snd_nxt[2] = uip_acc32[2];
+      uip_connr-&gt;snd_nxt[3] = uip_acc32[3];
+	
+
+      /* Do RTT estimation, unless we have done retransmissions. */
+      if(uip_connr-&gt;nrtx == 0) {
+	signed char m;
+	m = uip_connr-&gt;rto - uip_connr-&gt;timer;
+	/* This is taken directly from VJs original code in his paper */
+	m = m - (uip_connr-&gt;sa &gt;&gt; 3);
+	uip_connr-&gt;sa += m;
+	if(m &lt; 0) {
+	  m = -m;
+	}
+	m = m - (uip_connr-&gt;sv &gt;&gt; 2);
+	uip_connr-&gt;sv += m;
+	uip_connr-&gt;rto = (uip_connr-&gt;sa &gt;&gt; 3) + uip_connr-&gt;sv;
+
+      }
+      /* Set the acknowledged flag. */
+      uip_flags = UIP_ACKDATA;
+      /* Reset the retransmission timer. */
+      uip_connr-&gt;timer = uip_connr-&gt;rto;
+
+      /* Reset length of outstanding data. */
+      uip_connr-&gt;len = 0;
+    }
+    
+  }
+
+  /* Do different things depending on in what state the connection is. */
+  switch(uip_connr-&gt;tcpstateflags &amp; UIP_TS_MASK) {
+    /* CLOSED and LISTEN are not handled here. CLOSE_WAIT is not
+	implemented, since we force the application to close when the
+	peer sends a FIN (hence the application goes directly from
+	ESTABLISHED to LAST_ACK). */
+  case UIP_SYN_RCVD:
+    /* In SYN_RCVD we have sent out a SYNACK in response to a SYN, and
+       we are waiting for an ACK that acknowledges the data we sent
+       out the last time. Therefore, we want to have the UIP_ACKDATA
+       flag set. If so, we enter the ESTABLISHED state. */
+    if(uip_flags &amp; UIP_ACKDATA) {
+      uip_connr-&gt;tcpstateflags = UIP_ESTABLISHED;
+      uip_flags = UIP_CONNECTED;
+      uip_connr-&gt;len = 0;
+      if(uip_len &gt; 0) {
+        uip_flags |= UIP_NEWDATA;
+        uip_add_rcv_nxt(uip_len);
+      }
+      uip_slen = 0;
+      UIP_APPCALL();
+      goto appsend;
+    }
+    goto drop;
+#if UIP_ACTIVE_OPEN
+  case UIP_SYN_SENT:
+    /* In SYN_SENT, we wait for a SYNACK that is sent in response to
+       our SYN. The rcv_nxt is set to sequence number in the SYNACK
+       plus one, and we send an ACK. We move into the ESTABLISHED
+       state. */
+    if((uip_flags &amp; UIP_ACKDATA) &amp;&amp;
+       (BUF-&gt;flags &amp; TCP_CTL) == (TCP_SYN | TCP_ACK)) {
+
+      /* Parse the TCP MSS option, if present. */
+      if((BUF-&gt;tcpoffset &amp; 0xf0) &gt; 0x50) {
+	for(c = 0; c &lt; ((BUF-&gt;tcpoffset &gt;&gt; 4) - 5) &lt;&lt; 2 ;) {
+	  opt = uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + c];
+	  if(opt == TCP_OPT_END) {
+	    /* End of options. */
+	    break;
+	  } else if(opt == TCP_OPT_NOOP) {
+	    ++c;
+	    /* NOP option. */
+	  } else if(opt == TCP_OPT_MSS &amp;&amp;
+		    uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
+	    /* An MSS option with the right option length. */
+	    tmp16 = (uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] &lt;&lt; 8) |
+	      uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 3 + c];
+	    uip_connr-&gt;initialmss =
+	      uip_connr-&gt;mss = tmp16 &gt; UIP_TCP_MSS? UIP_TCP_MSS: tmp16;
+
+	    /* And we are done processing options. */
+	    break;
+	  } else {
+	    /* All other options have a length field, so that we easily
+	       can skip past them. */
+	    if(uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0) {
+	      /* If the length field is zero, the options are malformed
+		 and we don't process them further. */
+	      break;
+	    }
+	    c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
+	  }
+	}
+      }
+      uip_connr-&gt;tcpstateflags = UIP_ESTABLISHED;
+      uip_connr-&gt;rcv_nxt[0] = BUF-&gt;seqno[0];
+      uip_connr-&gt;rcv_nxt[1] = BUF-&gt;seqno[1];
+      uip_connr-&gt;rcv_nxt[2] = BUF-&gt;seqno[2];
+      uip_connr-&gt;rcv_nxt[3] = BUF-&gt;seqno[3];
+      uip_add_rcv_nxt(1);
+      uip_flags = UIP_CONNECTED | UIP_NEWDATA;
+      uip_connr-&gt;len = 0;
+      uip_len = 0;
+      uip_slen = 0;
+      UIP_APPCALL();
+      goto appsend;
+    }
+    /* Inform the application that the connection failed */
+    uip_flags = UIP_ABORT;
+    UIP_APPCALL();
+    /* The connection is closed after we send the RST */
+    uip_conn-&gt;tcpstateflags = UIP_CLOSED;
+    goto reset;
+#endif /* UIP_ACTIVE_OPEN */
+    
+  case UIP_ESTABLISHED:
+    /* In the ESTABLISHED state, we call upon the application to feed
+    data into the uip_buf. If the UIP_ACKDATA flag is set, the
+    application should put new data into the buffer, otherwise we are
+    retransmitting an old segment, and the application should put that
+    data into the buffer.
+
+    If the incoming packet is a FIN, we should close the connection on
+    this side as well, and we send out a FIN and enter the LAST_ACK
+    state. We require that there is no outstanding data; otherwise the
+    sequence numbers will be screwed up. */
+
+    if(BUF-&gt;flags &amp; TCP_FIN &amp;&amp; !(uip_connr-&gt;tcpstateflags &amp; UIP_STOPPED)) {
+      if(uip_outstanding(uip_connr)) {
+	goto drop;
+      }
+      uip_add_rcv_nxt(1 + uip_len);
+      uip_flags |= UIP_CLOSE;
+      if(uip_len &gt; 0) {
+	uip_flags |= UIP_NEWDATA;
+      }
+      UIP_APPCALL();
+      uip_connr-&gt;len = 1;
+      uip_connr-&gt;tcpstateflags = UIP_LAST_ACK;
+      uip_connr-&gt;nrtx = 0;
+    tcp_send_finack:
+      BUF-&gt;flags = TCP_FIN | TCP_ACK;
+      goto tcp_send_nodata;
+    }
+
+    /* Check the URG flag. If this is set, the segment carries urgent
+       data that we must pass to the application. */
+    if((BUF-&gt;flags &amp; TCP_URG) != 0) {
+#if UIP_URGDATA &gt; 0
+      uip_urglen = (BUF-&gt;urgp[0] &lt;&lt; 8) | BUF-&gt;urgp[1];
+      if(uip_urglen &gt; uip_len) {
+	/* There is more urgent data in the next segment to come. */
+	uip_urglen = uip_len;
+      }
+      uip_add_rcv_nxt(uip_urglen);
+      uip_len -= uip_urglen;
+      uip_urgdata = uip_appdata;
+      uip_appdata += uip_urglen;
+    } else {
+      uip_urglen = 0;
+#else /* UIP_URGDATA &gt; 0 */
+      uip_appdata = ((char *)uip_appdata) + ((BUF-&gt;urgp[0] &lt;&lt; 8) | BUF-&gt;urgp[1]);
+      uip_len -= (BUF-&gt;urgp[0] &lt;&lt; 8) | BUF-&gt;urgp[1];
+#endif /* UIP_URGDATA &gt; 0 */
+    }
+
+    /* If uip_len &gt; 0 we have TCP data in the packet, and we flag this
+       by setting the UIP_NEWDATA flag and update the sequence number
+       we acknowledge. If the application has stopped the dataflow
+       using uip_stop(), we must not accept any data packets from the
+       remote host. */
+    if(uip_len &gt; 0 &amp;&amp; !(uip_connr-&gt;tcpstateflags &amp; UIP_STOPPED)) {
+      uip_flags |= UIP_NEWDATA;
+      uip_add_rcv_nxt(uip_len);
+    }
+
+    /* Check if the available buffer space advertised by the other end
+       is smaller than the initial MSS for this connection. If so, we
+       set the current MSS to the window size to ensure that the
+       application does not send more data than the other end can
+       handle.
+
+       If the remote host advertises a zero window, we set the MSS to
+       the initial MSS so that the application will send an entire MSS
+       of data. This data will not be acknowledged by the receiver,
+       and the application will retransmit it. This is called the
+       &quot;persistent timer&quot; and uses the retransmission mechanim.
+    */
+    tmp16 = ((u16_t)BUF-&gt;wnd[0] &lt;&lt; 8) + (u16_t)BUF-&gt;wnd[1];
+    if(tmp16 &gt; uip_connr-&gt;initialmss ||
+       tmp16 == 0) {
+      tmp16 = uip_connr-&gt;initialmss;
+    }
+    uip_connr-&gt;mss = tmp16;
+
+    /* If this packet constitutes an ACK for outstanding data (flagged
+       by the UIP_ACKDATA flag, we should call the application since it
+       might want to send more data. If the incoming packet had data
+       from the peer (as flagged by the UIP_NEWDATA flag), the
+       application must also be notified.
+
+       When the application is called, the global variable uip_len
+       contains the length of the incoming data. The application can
+       access the incoming data through the global pointer
+       uip_appdata, which usually points UIP_IPTCPH_LEN + UIP_LLH_LEN
+       bytes into the uip_buf array.
+
+       If the application wishes to send any data, this data should be
+       put into the uip_appdata and the length of the data should be
+       put into uip_len. If the application don't have any data to
+       send, uip_len must be set to 0. */
+    if(uip_flags &amp; (UIP_NEWDATA | UIP_ACKDATA)) {
+      uip_slen = 0;
+      UIP_APPCALL();
+
+    appsend:
+      
+      if(uip_flags &amp; UIP_ABORT) {
+	uip_slen = 0;
+	uip_connr-&gt;tcpstateflags = UIP_CLOSED;
+	BUF-&gt;flags = TCP_RST | TCP_ACK;
+	goto tcp_send_nodata;
+      }
+
+      if(uip_flags &amp; UIP_CLOSE) {
+	uip_slen = 0;
+	uip_connr-&gt;len = 1;
+	uip_connr-&gt;tcpstateflags = UIP_FIN_WAIT_1;
+	uip_connr-&gt;nrtx = 0;
+	BUF-&gt;flags = TCP_FIN | TCP_ACK;
+	goto tcp_send_nodata;
+      }
+
+      /* If uip_slen &gt; 0, the application has data to be sent. */
+      if(uip_slen &gt; 0) {
+
+	/* If the connection has acknowledged data, the contents of
+	   the -&gt;len variable should be discarded. */
+	if((uip_flags &amp; UIP_ACKDATA) != 0) {
+	  uip_connr-&gt;len = 0;
+	}
+
+	/* If the -&gt;len variable is non-zero the connection has
+	   already data in transit and cannot send anymore right
+	   now. */
+	if(uip_connr-&gt;len == 0) {
+
+	  /* The application cannot send more than what is allowed by
+	     the mss (the minumum of the MSS and the available
+	     window). */
+	  if(uip_slen &gt; uip_connr-&gt;mss) {
+	    uip_slen = uip_connr-&gt;mss;
+	  }
+
+	  /* Remember how much data we send out now so that we know
+	     when everything has been acknowledged. */
+	  uip_connr-&gt;len = uip_slen;
+	} else {
+
+	  /* If the application already had unacknowledged data, we
+	     make sure that the application does not send (i.e.,
+	     retransmit) out more than it previously sent out. */
+	  uip_slen = uip_connr-&gt;len;
+	}
+      }
+      uip_connr-&gt;nrtx = 0;
+    apprexmit:
+      uip_appdata = uip_sappdata;
+      
+      /* If the application has data to be sent, or if the incoming
+         packet had new data in it, we must send out a packet. */
+      if(uip_slen &gt; 0 &amp;&amp; uip_connr-&gt;len &gt; 0) {
+	/* Add the length of the IP and TCP headers. */
+	uip_len = uip_connr-&gt;len + UIP_TCPIP_HLEN;
+	/* We always set the ACK flag in response packets. */
+	BUF-&gt;flags = TCP_ACK | TCP_PSH;
+	/* Send the packet. */
+	goto tcp_send_noopts;
+      }
+      /* If there is no data to send, just send out a pure ACK if
+	 there is newdata. */
+      if(uip_flags &amp; UIP_NEWDATA) {
+	uip_len = UIP_TCPIP_HLEN;
+	BUF-&gt;flags = TCP_ACK;
+	goto tcp_send_noopts;
+      }
+    }
+    goto drop;
+  case UIP_LAST_ACK:
+    /* We can close this connection if the peer has acknowledged our
+       FIN. This is indicated by the UIP_ACKDATA flag. */
+    if(uip_flags &amp; UIP_ACKDATA) {
+      uip_connr-&gt;tcpstateflags = UIP_CLOSED;
+      uip_flags = UIP_CLOSE;
+      UIP_APPCALL();
+    }
+    break;
+    
+  case UIP_FIN_WAIT_1:
+    /* The application has closed the connection, but the remote host
+       hasn't closed its end yet. Thus we do nothing but wait for a
+       FIN from the other side. */
+    if(uip_len &gt; 0) {
+      uip_add_rcv_nxt(uip_len);
+    }
+    if(BUF-&gt;flags &amp; TCP_FIN) {
+      if(uip_flags &amp; UIP_ACKDATA) {
+	uip_connr-&gt;tcpstateflags = UIP_TIME_WAIT;
+	uip_connr-&gt;timer = 0;
+	uip_connr-&gt;len = 0;
+      } else {
+	uip_connr-&gt;tcpstateflags = UIP_CLOSING;
+      }
+      uip_add_rcv_nxt(1);
+      uip_flags = UIP_CLOSE;
+      UIP_APPCALL();
+      goto tcp_send_ack;
+    } else if(uip_flags &amp; UIP_ACKDATA) {
+      uip_connr-&gt;tcpstateflags = UIP_FIN_WAIT_2;
+      uip_connr-&gt;len = 0;
+      goto drop;
+    }
+    if(uip_len &gt; 0) {
+      goto tcp_send_ack;
+    }
+    goto drop;
+      
+  case UIP_FIN_WAIT_2:
+    if(uip_len &gt; 0) {
+      uip_add_rcv_nxt(uip_len);
+    }
+    if(BUF-&gt;flags &amp; TCP_FIN) {
+      uip_connr-&gt;tcpstateflags = UIP_TIME_WAIT;
+      uip_connr-&gt;timer = 0;
+      uip_add_rcv_nxt(1);
+      uip_flags = UIP_CLOSE;
+      UIP_APPCALL();
+      goto tcp_send_ack;
+    }
+    if(uip_len &gt; 0) {
+      goto tcp_send_ack;
+    }
+    goto drop;
+
+  case UIP_TIME_WAIT:
+    goto tcp_send_ack;
+    
+  case UIP_CLOSING:
+    if(uip_flags &amp; UIP_ACKDATA) {
+      uip_connr-&gt;tcpstateflags = UIP_TIME_WAIT;
+      uip_connr-&gt;timer = 0;
+    }
+  }
+  goto drop;
+  
+
+  /* We jump here when we are ready to send the packet, and just want
+     to set the appropriate TCP sequence numbers in the TCP header. */
+ tcp_send_ack:
+  BUF-&gt;flags = TCP_ACK;
+ tcp_send_nodata:
+  uip_len = UIP_IPTCPH_LEN;
+ tcp_send_noopts:
+  BUF-&gt;tcpoffset = (UIP_TCPH_LEN / 4) &lt;&lt; 4;
+ tcp_send:
+  /* We're done with the input processing. We are now ready to send a
+     reply. Our job is to fill in all the fields of the TCP and IP
+     headers before calculating the checksum and finally send the
+     packet. */
+  BUF-&gt;ackno[0] = uip_connr-&gt;rcv_nxt[0];
+  BUF-&gt;ackno[1] = uip_connr-&gt;rcv_nxt[1];
+  BUF-&gt;ackno[2] = uip_connr-&gt;rcv_nxt[2];
+  BUF-&gt;ackno[3] = uip_connr-&gt;rcv_nxt[3];
+  
+  BUF-&gt;seqno[0] = uip_connr-&gt;snd_nxt[0];
+  BUF-&gt;seqno[1] = uip_connr-&gt;snd_nxt[1];
+  BUF-&gt;seqno[2] = uip_connr-&gt;snd_nxt[2];
+  BUF-&gt;seqno[3] = uip_connr-&gt;snd_nxt[3];
+
+  BUF-&gt;proto = UIP_PROTO_TCP;
+  
+  BUF-&gt;srcport  = uip_connr-&gt;lport;
+  BUF-&gt;destport = uip_connr-&gt;rport;
+
+  uip_ipaddr_copy(BUF-&gt;srcipaddr, uip_hostaddr);
+  uip_ipaddr_copy(BUF-&gt;destipaddr, uip_connr-&gt;ripaddr);
+
+  if(uip_connr-&gt;tcpstateflags &amp; UIP_STOPPED) {
+    /* If the connection has issued uip_stop(), we advertise a zero
+       window so that the remote host will stop sending data. */
+    BUF-&gt;wnd[0] = BUF-&gt;wnd[1] = 0;
+  } else {
+    BUF-&gt;wnd[0] = ((UIP_RECEIVE_WINDOW) &gt;&gt; 8);
+    BUF-&gt;wnd[1] = ((UIP_RECEIVE_WINDOW) &amp; 0xff);
+  }
+
+ tcp_send_noconn:
+  BUF-&gt;ttl = UIP_TTL;
+#if UIP_CONF_IPV6
+  /* For IPv6, the IP length field does not include the IPv6 IP header
+     length. */
+  BUF-&gt;len[0] = ((uip_len - UIP_IPH_LEN) &gt;&gt; 8);
+  BUF-&gt;len[1] = ((uip_len - UIP_IPH_LEN) &amp; 0xff);
+#else /* UIP_CONF_IPV6 */
+  BUF-&gt;len[0] = (uip_len &gt;&gt; 8);
+  BUF-&gt;len[1] = (uip_len &amp; 0xff);
+#endif /* UIP_CONF_IPV6 */
+
+  BUF-&gt;urgp[0] = BUF-&gt;urgp[1] = 0;
+  
+  /* Calculate TCP checksum. */
+  BUF-&gt;tcpchksum = 0;
+  BUF-&gt;tcpchksum = ~(uip_tcpchksum());
+#endif /* UIP_TCP */
+  
+ ip_send_nolen:
+
+#if UIP_CONF_IPV6
+  BUF-&gt;vtc = 0x60;
+  BUF-&gt;tcflow = 0x00;
+  BUF-&gt;flow = 0x00;
+#else /* UIP_CONF_IPV6 */
+  BUF-&gt;vhl = 0x45;
+  BUF-&gt;tos = 0;
+  BUF-&gt;ipoffset[0] = BUF-&gt;ipoffset[1] = 0;
+  ++ipid;
+  BUF-&gt;ipid[0] = ipid &gt;&gt; 8;
+  BUF-&gt;ipid[1] = ipid &amp; 0xff;
+  /* Calculate IP checksum. */
+  BUF-&gt;ipchksum = 0;
+  BUF-&gt;ipchksum = ~(uip_ipchksum());
+  DEBUG_PRINTF(&quot;uip ip_send_nolen: chkecum 0x%04x\n&quot;, uip_ipchksum());
+#endif /* UIP_CONF_IPV6 */
+   
+  UIP_STAT(++uip_stat.tcp.sent);
+ send:
+  DEBUG_PRINTF(&quot;Sending packet with length %d (%d)\n&quot;, uip_len,
+	       (BUF-&gt;len[0] &lt;&lt; 8) | BUF-&gt;len[1]);
+  
+  UIP_STAT(++uip_stat.ip.sent);
+  /* Return and let the caller do the actual transmission. */
+  uip_flags = 0;
+  return;
+ drop:
+  uip_len = 0;
+  uip_flags = 0;
+  return;
+}
+/*---------------------------------------------------------------------------*/
+u16_t
+htons(u16_t val)
+{
+  return HTONS(val);
+}
+/*---------------------------------------------------------------------------*/
+void
+uip_send(const void *data, int len)
+{
+  if(len &gt; 0) {
+    uip_slen = len;
+    if(data != uip_sappdata) {
+      memcpy(uip_sappdata, (data), uip_slen);
+    }
+  }
+}
+/** @} */
+
+#endif // #ifdef BUILD_UIP

Modified: trunk/src/uip/uip.h
===================================================================
--- trunk/src/uip/uip.h	2008-09-15 21:54:46 UTC (rev 90)
+++ trunk/src/uip/uip.h	2008-09-18 20:22:15 UTC (rev 91)
@@ -300,14 +300,21 @@
  */
 #define uip_periodic(conn) do { uip_conn = &amp;uip_conns[conn]; \
                                 uip_process(UIP_TIMER); } while (0)
-
+                                
 /**
  *
  *
  */
-#define uip_conn_active(conn) (uip_conns[conn].tcpstateflags != UIP_CLOSED)
+#define uip_conn_active(conn) (uip_conns[conn].tcpstateflags != UIP_CLOSED &amp;&amp; \
+                               uip_conns[conn].tcpstateflags != UIP_RESERVED )
 
 /**
+ * Reserve a connection (for a later call to connect)
+ *
+ */
+#define uip_conn_reserve(conn) (uip_conns[conn].tcpstateflags = UIP_RESERVED)
+
+/**
  * Perform periodic processing for a connection identified by a pointer
  * to its structure.
  *
@@ -336,6 +343,8 @@
  */
 #define uip_poll_conn(conn) do { uip_conn = conn; \
                                  uip_process(UIP_POLL_REQUEST); } while (0)
+#define uip_poll_conn_num(conn) do { uip_conn = &amp;uip_conns[conn]; \
+                                 uip_process(UIP_POLL_REQUEST); } while (0)                                 
 
 
 #if UIP_UDP
@@ -494,11 +503,12 @@
  * \return A pointer to the uIP connection identifier for the new connection,
  * or NULL if no connection could be allocated.
  *
+ * uip_connect_socket() is the same things, except it takes a connection ID
+ * (prereserved with uip_reserve()) and uses it for connection  
  */
 struct uip_conn *uip_connect(uip_ipaddr_t *ripaddr, u16_t port);
+struct uip_conn *uip_connect_socket( int conn, uip_ipaddr_t *ripaddr, u16_t port );
 
-
-
 /**
  * \internal
  *
@@ -589,6 +599,7 @@
  * \hideinitializer
  */
 #define uip_stop()          (uip_conn-&gt;tcpstateflags |= UIP_STOPPED)
+#define uip_stop_conn(conn) (uip_conns[conn].tcpstateflags |= UIP_STOPPED)     
 
 /**
  * Find out if the current connection has been previously stopped with
@@ -596,7 +607,8 @@
  *
  * \hideinitializer
  */
-#define uip_stopped(conn)   ((conn)-&gt;tcpstateflags &amp; UIP_STOPPED)
+#define uip_stopped(conn)      ((conn)-&gt;tcpstateflags &amp; UIP_STOPPED)
+#define uip_stopped_conn(conn) (uip_conns[conn].tcpstateflags &amp; UIP_STOPPED)
 
 /**
  * Restart the current connection, if is has previously been stopped
@@ -607,11 +619,13 @@
  *
  * \hideinitializer
  */
-#define uip_restart()         do { uip_flags |= UIP_NEWDATA; \
-                                   uip_conn-&gt;tcpstateflags &amp;= ~UIP_STOPPED; \
-                              } while(0)
+#define uip_restart()           do { uip_flags |= UIP_NEWDATA; \
+                                     uip_conn-&gt;tcpstateflags &amp;= ~UIP_STOPPED; \
+                                } while(0)
+#define uip_restart_conn(conn)  do { uip_flags |= UIP_NEWDATA; \
+                                     uip_conns[conn].tcpstateflags &amp;= ~UIP_STOPPED; \
+                                } while(0)                                    
 
-
 /* uIP tests that can be made to determine in what state the current
    connection is, and what the application function should do. */
 
@@ -1384,6 +1398,7 @@
 #define UIP_CLOSING     6
 #define UIP_TIME_WAIT   7
 #define UIP_LAST_ACK    8
+#define UIP_RESERVED    9
 #define UIP_TS_MASK     15
   
 #define UIP_STOPPED      16
@@ -1459,7 +1474,7 @@
   u8_t icmp6data[16];
   u8_t options[1];
 #endif /* !UIP_CONF_IPV6 */
-};
+} __attribute__ ((__packed__));
 
 
 /* The UDP and IP headers. */
@@ -1491,7 +1506,7 @@
     destport;
   u16_t udplen;
   u16_t udpchksum;
-};
+} __attribute__ ((__packed__));
 
 
 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000046.html">[Elua-svn] r90 - trunk/src/platform/lm3s
</A></li>
	<LI>Next message: <A HREF="000048.html">[Elua-svn] r92 - in trunk: . src/lua
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#47">[ date ]</a>
              <a href="thread.html#47">[ thread ]</a>
              <a href="subject.html#47">[ subject ]</a>
              <a href="author.html#47">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/elua-svn">More information about the eLua-svn
mailing list</a><br>
</body></html>
