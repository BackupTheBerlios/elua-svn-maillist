<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Elua-svn] r881 - in trunk: . doc doc/eluadoc doc/en inc	inc/remotefs src src/modules src/platform/at91sam7x	src/platform/avr32 src/platform/avr32/EVK1100	src/platform/avr32/EVK1101 src/platform/i386	src/platform/lm3s src/platform/lpc17xx src/platform/lpc24xx	src/platform/lpc288x src/platform/sim src/platform/stm32	src/platform/str7 src/platform/str9 src/remotefs
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/elua-svn/2011-January/index.html" >
   <LINK REL="made" HREF="mailto:elua-svn%40lists.berlios.de?Subject=Re%3A%20%5BElua-svn%5D%20r881%20-%20in%20trunk%3A%20.%20doc%20doc/eluadoc%20doc/en%20inc%0A%09inc/remotefs%20src%20src/modules%20src/platform/at91sam7x%0A%09src/platform/avr32%20src/platform/avr32/EVK1100%0A%09src/platform/avr32/EVK1101%20src/platform/i386%0A%09src/platform/lm3s%20src/platform/lpc17xx%20src/platform/lpc24xx%0A%09src/platform/lpc288x%20src/platform/sim%20src/platform/stm32%0A%09src/platform/str7%20src/platform/str9%20src/remotefs&In-Reply-To=%3C20110116002320.323AE480A84%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000833.html">
   <LINK REL="Next"  HREF="000835.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Elua-svn] r881 - in trunk: . doc doc/eluadoc doc/en inc	inc/remotefs src src/modules src/platform/at91sam7x	src/platform/avr32 src/platform/avr32/EVK1100	src/platform/avr32/EVK1101 src/platform/i386	src/platform/lm3s src/platform/lpc17xx src/platform/lpc24xx	src/platform/lpc288x src/platform/sim src/platform/stm32	src/platform/str7 src/platform/str9 src/remotefs</H1>
    <B>bogdanm at mail.berlios.de</B> 
    <A HREF="mailto:elua-svn%40lists.berlios.de?Subject=Re%3A%20%5BElua-svn%5D%20r881%20-%20in%20trunk%3A%20.%20doc%20doc/eluadoc%20doc/en%20inc%0A%09inc/remotefs%20src%20src/modules%20src/platform/at91sam7x%0A%09src/platform/avr32%20src/platform/avr32/EVK1100%0A%09src/platform/avr32/EVK1101%20src/platform/i386%0A%09src/platform/lm3s%20src/platform/lpc17xx%20src/platform/lpc24xx%0A%09src/platform/lpc288x%20src/platform/sim%20src/platform/stm32%0A%09src/platform/str7%20src/platform/str9%20src/remotefs&In-Reply-To=%3C20110116002320.323AE480A84%40sheep.berlios.de%3E"
       TITLE="[Elua-svn] r881 - in trunk: . doc doc/eluadoc doc/en inc	inc/remotefs src src/modules src/platform/at91sam7x	src/platform/avr32 src/platform/avr32/EVK1100	src/platform/avr32/EVK1101 src/platform/i386	src/platform/lm3s src/platform/lpc17xx src/platform/lpc24xx	src/platform/lpc288x src/platform/sim src/platform/stm32	src/platform/str7 src/platform/str9 src/remotefs">bogdanm at mail.berlios.de
       </A><BR>
    <I>Sun Jan 16 01:23:19 CET 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="000833.html">[Elua-svn] r880 - trunk
</A></li>
        <LI>Next message: <A HREF="000835.html">[Elua-svn] r882 - trunk/src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#834">[ date ]</a>
              <a href="thread.html#834">[ thread ]</a>
              <a href="subject.html#834">[ subject ]</a>
              <a href="author.html#834">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: bogdanm
Date: 2011-01-16 01:23:19 +0100 (Sun, 16 Jan 2011)
New Revision: 881

Added:
   trunk/doc/en/arch_rfs.txt
   trunk/doc/en/sermux.txt
   trunk/inc/eluarpc.h
   trunk/inc/rtype.h
   trunk/inc/sermux.h
   trunk/mux.py
   trunk/mux_src/
   trunk/rfs_server_src/
   trunk/src/common_uart.c
   trunk/src/eluarpc.c
   trunk/src/platform/at91sam7x/platform_int.c
   trunk/src/platform/avr32/platform_int.c
   trunk/src/platform/lm3s/platform_int.c
   trunk/src/platform/stm32/platform_int.c
Removed:
   trunk/inc/remotefs/rtype.h
   trunk/rfs_server/
Modified:
   trunk/
   trunk/SConstruct
   trunk/doc/
   trunk/doc/buildall.lua
   trunk/doc/docdata.lua
   trunk/doc/eluadoc/arch_platform_uart.lua
   trunk/doc/eluadoc/refman_gen_uart.lua
   trunk/doc/en/arch_ints.txt
   trunk/doc/en/filesystems.html
   trunk/doc/style1.css
   trunk/inc/common.h
   trunk/inc/platform.h
   trunk/inc/remotefs/client.h
   trunk/inc/remotefs/remotefs.h
   trunk/inc/utils.h
   trunk/inc/validate.h
   trunk/rfs_server.py
   trunk/src/buf.c
   trunk/src/common.c
   trunk/src/common_tmr.c
   trunk/src/modules/tmr.c
   trunk/src/modules/uart.c
   trunk/src/platform/at91sam7x/conf.py
   trunk/src/platform/at91sam7x/platform.c
   trunk/src/platform/at91sam7x/platform_conf.h
   trunk/src/platform/avr32/EVK1100/evk1100_conf.h
   trunk/src/platform/avr32/EVK1101/evk1101_conf.h
   trunk/src/platform/avr32/conf.py
   trunk/src/platform/avr32/platform.c
   trunk/src/platform/i386/platform.c
   trunk/src/platform/i386/platform_conf.h
   trunk/src/platform/lm3s/conf.py
   trunk/src/platform/lm3s/platform.c
   trunk/src/platform/lm3s/platform_conf.h
   trunk/src/platform/lm3s/startup_gcc.c
   trunk/src/platform/lpc17xx/platform.c
   trunk/src/platform/lpc24xx/platform.c
   trunk/src/platform/lpc24xx/platform_conf.h
   trunk/src/platform/lpc24xx/platform_int.c
   trunk/src/platform/lpc24xx/stacks.h
   trunk/src/platform/lpc288x/platform.c
   trunk/src/platform/sim/platform.c
   trunk/src/platform/sim/platform_conf.h
   trunk/src/platform/stm32/conf.py
   trunk/src/platform/stm32/platform.c
   trunk/src/platform/stm32/platform_conf.h
   trunk/src/platform/stm32/stm32f10x_it.c
   trunk/src/platform/str7/platform.c
   trunk/src/platform/str9/platform.c
   trunk/src/remotefs/client.c
   trunk/src/remotefs/elua_os_io.c
   trunk/src/remotefs/elua_rfs.c
   trunk/src/remotefs/remotefs.c
   trunk/src/shell.c
Log:
merged remotefs_int branch on trunk, not fully tested yet


Property changes on: trunk
___________________________________________________________________
Modified: svn:ignore
   - .sconsign.dblite
mkfs.pyc
*.elf
*.bin
luac*
*.hex
*.tmp
*.map
core
build-setup.conf
config.log
.sconf_temp


   + .sconsign.dblite
mkfs.pyc
*.elf
*.bin
luac*
*.hex
*.tmp
*.map
core
build-setup.conf
config.log
.sconf_temp
*.exe
*.obj
mux
rfs_server



Modified: trunk/SConstruct
===================================================================
--- trunk/SConstruct	2011-01-10 00:08:13 UTC (rev 880)
+++ trunk/SConstruct	2011-01-16 00:23:19 UTC (rev 881)
@@ -415,7 +415,7 @@
 
   # Application files
   app_files = &quot;&quot;&quot; src/main.c src/romfs.c src/semifs.c src/xmodem.c src/shell.c src/term.c src/common.c src/common_tmr.c src/buf.c src/elua_adc.c src/dlmalloc.c 
-                  src/salloc.c src/luarpc_elua_uart.c src/elua_int.c src/linenoise.c &quot;&quot;&quot;
+                  src/salloc.c src/luarpc_elua_uart.c src/elua_int.c src/linenoise.c src/common_uart.c src/eluarpc.c &quot;&quot;&quot;
 
   # Newlib related files
   newlib_files = &quot; src/newlib/devman.c src/newlib/stubs.c src/newlib/genstd.c src/newlib/stdtcp.c&quot;


Property changes on: trunk/doc
___________________________________________________________________
Modified: svn:ignore
   - dist

   + dist
cache
.sconsign.dblite


Modified: trunk/doc/buildall.lua
===================================================================
--- trunk/doc/buildall.lua	2011-01-10 00:08:13 UTC (rev 880)
+++ trunk/doc/buildall.lua	2011-01-16 00:23:19 UTC (rev 881)
@@ -1,5 +1,6 @@
 require &quot;lfs&quot;
 require &quot;eluadoc&quot;
+require &quot;md5&quot;
 
 -- Uncomment this when generating offline docs
 local is_offline = true
@@ -20,6 +21,7 @@
 end
 
 local sf = string.format
+local cache_invalid = false
 
 -------------------------------------------------------------------------------
 -- Indexes into our menu table (defined in docdata.lua)
@@ -171,6 +173,74 @@
 end
 
 -------------------------------------------------------------------------------
+-- Cache helpers
+
+local function read_md5( filename )
+  local fullname = string.format( &quot;cache/%s.cache&quot;, filename )
+  local f = io.open( fullname, &quot;rb&quot; )
+  if not f then return &quot;&quot; end
+  local d = f:read( &quot;*a&quot; )
+  f:close()
+  return d
+end
+
+local function write_md5( filename, d )
+  local fullname = string.format( &quot;cache/%s.cache&quot;, filename )
+  local f = io.open( fullname, &quot;wb&quot; )
+  if not f then return false end
+  f:write( d )
+  f:close()
+  return true
+end
+
+local function file_md5( filename )
+  local f = io.open( filename, &quot;rb&quot; )
+  if not f then return &quot;&quot; end
+  local d = f:read( &quot;*a&quot; )
+  f:close()
+  return md5.sumhexa( d ) 
+end
+
+-------------------------------------------------------------------------------
+-- Table utils (from <A HREF="http://lua-users.org/wiki/TableUtils">http://lua-users.org/wiki/TableUtils</A>)
+
+function table.val_to_str( v )
+  if &quot;string&quot; == type( v ) then
+    v = string.gsub( v, &quot;\n&quot;, &quot;\\n&quot; )
+    if string.match( string.gsub(v,&quot;[^'\&quot;]&quot;,&quot;&quot;), '^&quot;+$' ) then
+      return &quot;'&quot; .. v .. &quot;'&quot;
+    end
+    return '&quot;' .. string.gsub(v,'&quot;', '\\&quot;' ) .. '&quot;'
+  else
+    return &quot;table&quot; == type( v ) and table.tostring( v ) or tostring( v )
+  end
+end
+
+function table.key_to_str ( k )
+  if &quot;string&quot; == type( k ) and string.match( k, &quot;^[_%a][_%a%d]*$&quot; ) then
+    return k
+  else
+    return &quot;[&quot; .. table.val_to_str( k ) .. &quot;]&quot;
+  end
+end
+
+function table.tostring( tbl )
+  local result, done = {}, {}
+  for k, v in ipairs( tbl ) do
+    table.insert( result, table.val_to_str( v ) )
+    done[ k ] = true
+  end
+  for k, v in pairs( tbl ) do
+    if not done[ k ] then
+      table.insert( result,
+        table.key_to_str( k ) .. &quot;=&quot; .. table.val_to_str( v ) )
+    end
+  end
+  return &quot;{&quot; .. table.concat( result, &quot;,&quot; ) .. &quot;}&quot;
+end
+
+
+-------------------------------------------------------------------------------
 -- Build the list of files that must be processed starting from the menu data
 
 -- Traverse a second (or higher) level menu and add relevant information to flist
@@ -374,6 +444,19 @@
   end
   local orig = f:read( &quot;*a&quot; )
   f:close()
+  
+  -- Check cache
+  local cfilename = string.format( &quot;%s_%s&quot;, lang, fname )
+  local oldsum = read_md5( cfilename )
+  local crtsum = md5.sumhexa( orig )
+  if oldsum == crtsum then
+    if not cache_invalid then 
+      return nil, &quot;#cached#&quot;
+    end
+  else
+    write_md5( cfilename, crtsum )
+  end
+      
   local asciimode = fullname:find( &quot;%.txt&quot; )
 
   -- Check the presence of $$HEADER$$ and $$FOOTER$$
@@ -489,13 +572,17 @@
 local destdir = &quot;dist&quot;
 local destdiridx = 1
 if #args &gt; 2 then
-  print &quot;Usage: buildall.lua [destdir] [-online]&quot;
+  print &quot;Usage: buildall.lua [destdir] [-online] [-clean]&quot;
   print &quot;Use -online to generate online documentation (includes BerliOS logo and counter)&quot;
+  print &quot;Use -clean to clear the cache and generate clean documentation&quot;
   return
 end
+local cleancache = false
 for i = 1, #args do
   if args[ i ] == &quot;-online&quot; then
     is_offline = false
+  elseif args[ i ] == &quot;-clean&quot; then
+    cleancache = true
   else 
     destdir = args[ i ]
   end
@@ -538,15 +625,42 @@
     print( string.format( &quot;%s is not a directory&quot;, destdir ) )
     return
   end
-  for k in lfs.dir( destdir ) do
-    if k ~= &quot;.&quot; and k ~= &quot;..&quot; then
-      rm_dir_rec( destdir )
-      lfs.mkdir( destdir )
-      break
+  rm_dir_rec( destdir )
+  lfs.mkdir( destdir )
+end
+
+-- If the cache must be cleared, do it now
+if cleancache then
+  local attr = lfs.attributes( 'cache' )
+  if attr then
+    if attr.mode ~= &quot;directory&quot; then
+      print( &quot;'cache' is not a directory&quot; )
+      return
     end
+    rm_dir_rec( 'cache' )
+    lfs.mkdir( 'cache' )
   end
 end
 
+-- Create the cache directory if it doesn't exist
+local attr = lfs.attributes( 'cache' )
+if not attr then
+  if not lfs.mkdir( 'cache' ) then
+    print( &quot;Unable to create cache directory&quot; )
+    return
+  end
+end  
+
+-- Set the global &quot;cache invalid&quot; flag
+-- It is set to 'true' if the content of docdata.lua changes
+local crtdocsum = md5.sumhexa( table.tostring( themenu ) )
+local oldsum = read_md5( &quot;docdata&quot; )
+cache_invalid = crtdocsum ~= oldsum
+if cache_invalid then 
+  write_md5( &quot;docdata&quot;, crtdocsum )
+  print &quot;Cache invalidated&quot; 
+end
+
 print &quot;\nProcessing HTML templates...&quot;
 indent_print()
 flist = get_file_list()
@@ -554,10 +668,13 @@
   for fname, entry in pairs( flist ) do
     io.write( string.format( &quot;Processing %s %s...&quot;, fname, entry.item[ name_idx ] and &quot;&quot; or &quot;(hidden entry)&quot; ) )
     local res, err = gen_html_page( fname, lang )
-    if not res then
-      print( &quot;***&quot; .. err )
+    if err == &quot;#cached#&quot; then
+      -- This file is already in the cache
+      print( &quot; (cached)&quot; )         
+    elseif not res then
+      print( &quot;***&quot; .. err ) 
     else
-      local g = io.open( string.format( &quot;%s/%s_%s&quot;, destdir, lang, fname ), &quot;wb&quot; )
+      local g = io.open( string.format( &quot;cache/%s_%s&quot;, lang, fname ), &quot;wb&quot; )
       if not g then
         print( string.format( &quot;Unable to open %s for writing&quot;, fname ) )
       else
@@ -565,6 +682,17 @@
         g:close()
       end
     end
+    -- Copy file from cache to destination directory
+    local srcf = io.open( string.format( &quot;cache/%s_%s&quot;, lang, fname ), &quot;rb&quot; )
+    local destf = io.open( string.format( &quot;%s/%s_%s&quot;, destdir, lang, fname ), &quot;wb&quot; )
+    if not srcf or not destf then
+      print &quot;Unable to copy file from cache to dist&quot;
+      return
+    end
+    local content = srcf:read( &quot;*a&quot; )
+    destf:write( content )
+    srcf:close()
+    destf:close()    
   end
 end
 regular_print()

Modified: trunk/doc/docdata.lua
===================================================================
--- trunk/doc/docdata.lua	2011-01-10 00:08:13 UTC (rev 880)
+++ trunk/doc/docdata.lua	2011-01-16 00:23:19 UTC (rev 881)
@@ -106,6 +106,7 @@
           { &quot;Linenoise&quot;, &quot;linenoise.html&quot; },
           { &quot;Cross-compiling&quot;, &quot;using.html#cross&quot; },
           { &quot;LuaRPC&quot;, &quot;using.html#rpc&quot; },
+          { &quot;The serial multiplexer&quot;, &quot;sermux.html&quot; }
         },
       },
       { { &quot;Code examples&quot;, &quot;Exemplos de C&#243;digo&quot; }, &quot;examples.html&quot; },
@@ -113,7 +114,8 @@
       { &quot;eLua file systems&quot;, &quot;filesystems.html&quot;,
         {
           { { &quot;Read-Only FS in MCU Flash&quot;, &quot;O ROM File System em Flash&quot; }, &quot;arch_romfs.html&quot; },
-          { &quot;R/W FAT FS in SD/MMC Cards&quot;, &quot;fatfs.html&quot; }
+          { &quot;R/W FAT FS in SD/MMC Cards&quot;, &quot;fatfs.html&quot; },
+          { &quot;Remote file system (RFS)&quot;, &quot;arch_rfs.html&quot; }
         }
       },
       { &quot;eLua interrupt handlers&quot;, &quot;inthandlers.html&quot;,

Modified: trunk/doc/eluadoc/arch_platform_uart.lua
===================================================================
--- trunk/doc/eluadoc/arch_platform_uart.lua	2011-01-10 00:08:13 UTC (rev 880)
+++ trunk/doc/eluadoc/arch_platform_uart.lua	2011-01-16 00:23:19 UTC (rev 881)
@@ -40,7 +40,26 @@
 #define PLATFORM_UART_INFINITE_TIMEOUT        (-1)]],
       name = &quot;UART timeout&quot;,
       desc = &quot;This constant is used as a special timeout value (infinite timeout) in the UART functions that expect a timeout as argument.&quot;,
-    }
+    },
+
+     { text = [[// Virtual UART IDs
+#define SERMUX_SERVICE_ID_FIRST  0xD0
+#define SERMUX_SERVICE_ID_LAST   0xD7
+]],
+      name = &quot;Virtual UART IDs&quot;,
+      desc = &quot;If @<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">sermux.html at virtual</A> UART@ support is enabled these constants define the IDs of the virtual UARTs in the system (defined in %inc/sermux.h%).&quot;,
+    },
+
+     { text = [[// Flow control type
+#define PLATFORM_UART_FLOW_NONE               0
+#define PLATFORM_UART_FLOW_RTS                1
+#define PLATFORM_UART_FLOW_CTS                2
+]],
+      name = &quot;Flow control type&quot;,
+      desc = &quot;Used to set the flow control type on a serial interface. These constans can be ORed together ($PLATFORM_UART_FLOW_RTS | PLATFORM_UART_FLOW_CTS$)&quot;,
+    },
+
+   
   },
 
   -- Functions
@@ -69,7 +88,9 @@
     },
 
     { sig = &quot;void #platform_uart_send#( unsigned id, u8 data );&quot;,
-      desc = &quot;Send data to an UART interface.&quot;,
+      desc = [[Send data to an UART interface. This is a blocking operation (it doesn't return until the data was sent).&lt;br&gt;
+      This function is &quot;split&quot; in two parts: a platform-independent part that is implemented in %src/common.c% and a platform-dependent part that must be implemented
+      by each platform in a function named @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platform_s_uart_send at platform_s_uart_send</A>@.]],
       args = 
       {
         &quot;$id$ - UART interface ID.&quot;,
@@ -77,10 +98,20 @@
       },
     },
 
+    { sig = &quot;void #platform_s_uart_send#( unsigned id, u8 data );&quot;,
+      desc = [[This is the platform-dependent part of @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platform_uart_send at platform_uart_send</A>@. It doesn't need to take care of @<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">sermux.html at virtual</A> UARTs@ or other system
+      configuration parameters, it just needs to instruct the CPU to send the data on the specified ID. This function will always be called with a physical uart ID.]],
+      args = 
+      {
+        &quot;$id$ - UART interface ID.&quot;,
+        &quot;$data$ - data to be sent.&quot;,
+      },
+    },
+
     { sig = &quot;int #platform_uart_recv#( unsigned id, unsigned timer_id, s32 timeout );&quot;,
       link = &quot;platform_uart_recv&quot;,
       desc = [[Receive data from the UART interface (blocking/non blocking with timeout/immediate).&lt;br&gt;
-  This function is &quot;split&quot; in two parts: a platform-independent part that is implemented in %src/common.c%, and a platform-dependent part that must be implemented by each
+  This function is &quot;split&quot; in two parts: a platform-independent part that is implemented in %src/common.c% and a platform-dependent part that must be implemented by each
   platform in a function named @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platform_s_uart_recv at platform_s_uart_recv</A>@.]],
       args = 
       {
@@ -104,7 +135,7 @@
 
     { sig = &quot;int #platform_s_uart_recv#( unsigned id, s32 timeout );&quot;,
       link = &quot;platform_s_uart_recv&quot;,
-      desc = [[This is the platform-dependent part of the UART receive function @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platform_uart_recv at platform_uart_recv</A>@, and is in fact a &quot;subset&quot; of the full function 
+      desc = [[This is the platform-dependent part of the UART receive function @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platform_uart_recv at platform_uart_recv</A>@ and is in fact a &quot;subset&quot; of the full function 
   (thus being easier to implement by each platform in part). In particular, it never needs to deal with the $timeout &gt; 0$ case, which is handled by @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platform_uart_recv at platform_uart_recv</A>@.]],
        args = 
       {
@@ -120,131 +151,43 @@
         &quot;if $timeout = 0$ and data from the UART is available when the function is called it is returned, otherwise -1 is returned&quot;,
         &quot;if $timeout$ = @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">uart_timeout at PLATFORM_UART_INIFINITE_TIMEOUT</A>@ it returns the data read from the UART after it becomes available&quot;
       }
-    }
-  }
-}
-
-data_pt = 
-{
-  -- Title
-  title = &quot;eLua platform interface - UART&quot;,
-
-  -- Menu name
-  menu_name = &quot;UART&quot;,
-
-  -- Overview
-  overview = &quot;This part of the platform interface groups functions related to the UART interface(s) of the MCU.&quot;,
-
-  -- Data structures, constants and types
-  structures = 
-  {
-    { text = [[// Parity
-enum
-{
-  PLATFORM_UART_PARITY_EVEN,
-  PLATFORM_UART_PARITY_ODD,
-  PLATFORM_UART_PARITY_NONE
-};]],
-      name = &quot;UART parity&quot;,
-      desc = &quot;Constants used to specify the UART parity mode.&quot;
     },
 
-    { text = [[// Stop bits
-enum
-{
-  PLATFORM_UART_STOPBITS_1,
-  PLATFORM_UART_STOPBITS_1_5,
-  PLATFORM_UART_STOPBITS_2
-};]],
-      name = &quot;UART stop bits&quot;,
-      desc = &quot;Constants used to specify the number of UART stop bits.&quot;,
-    },
-
-    { text = [[// &quot;Infinite timeout&quot; constant for recv
-#define PLATFORM_UART_INFINITE_TIMEOUT        (-1)]],
-      name = &quot;UART timeout&quot;,
-      desc = &quot;This constant is used as a special timeout value (infinite timeout) in the UART functions that expect a timeout as argument.&quot;,
-    }
-  },
-
-  -- Functions
-  funcs = 
-  {
-    { sig = &quot;int #platform_uart_exists#( unsigned id );&quot;,
-      desc = [[Checks if the platform has the hardware UART specified as argument. Implemented in %src/common.c%, it uses the $NUM_UART$ macro that must be defined in the
-  platform's $platform_conf.h$ file (see @arch_overview.html#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platforms at here</A>@ for details). For example:&lt;/p&gt;
-  ~#define NUM_UART   2      $// The platform has 2 UART interfaces$~&lt;p&gt;]],
-      args = &quot;$id$ - UART interface ID&quot;,
-      ret = &quot;1 if the specified UART exists, 0 otherwise&quot;
-    },
-
-    { sig = &quot;u32 #platform_uart_setup#( unsigned id, u32 baud, int databits, int parity, int stopbits );&quot;,
-      desc = &quot;This function is used to initialize the parameters of the UART interface.&quot;,
+    { sig = &quot;int #platform_uart_set_buffer#( unsigned id, unsigned log2size );&quot;,
+      desc = &quot;Sets the buffer for the specified UART. This function is fully implemented in %src/common.c%.&quot;,
       args = 
       {
         &quot;$id$ - UART interface ID.&quot;,
-        &quot;$baud$ - baud rate.&quot;,
-        &quot;$databits$ - number of databits (maximum 8).&quot;,
-        &quot;$parity$ - parity type (can be either $PLATFORM_UART_PARITY_EVEN$, $PLATFORM_UART_PARITY_ODD$ or $PLATFORM_UART_PARITY_NONE$, see @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">uart_parity at here</A>@).&quot;,
-        [[$stopbits$ - number of stop bits (can be either $PLATFORM_UART_STOPBITS_1$, $PLATFORM_UART_STOPBITS_1_5$ or $PLATFORM_UART_STOPBITS_2$, see
-           @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">uart_stop_bits at here</A>@).]],
+        &quot;$data$ - the base 2 logarithm of the buffer size or 0 to disable buffering on the UART. Note that disabling buffering on a virtual UART is an invalid operation.&quot;
       },
-      ret = &quot;the actual baud rate. Depending on the hardware, this may have a different value than the $baud$ argument.&quot;,
+      ret = &quot;$PLATFORM_OK$ if the operation succeeded, $PLATFORM_ERR$ otherwise.&quot;
     },
 
-    { sig = &quot;void #platform_uart_send#( unsigned id, u8 data );&quot;,
-      desc = &quot;Send data to an UART interface.&quot;,
+     { sig = &quot;int #platform_uart_set_flow_control#( unsigned id, int type );&quot;,
+      desc = [[Sets the flow control type.&lt;br&gt;
+      This function is &quot;split&quot; in two parts: a platform independent part that is implemented in %src/common.c% and a platform-dependent part that must be implemented by each
+      platform in a function named @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platform_s_uart_set_flow_control at platform_s_uart_set_flow_control</A>@.]],
       args = 
       {
         &quot;$id$ - UART interface ID.&quot;,
-        &quot;$data$ - data to be sent.&quot;,
+        [[$type$ - the desired flow control. It can be either $PLATFORM_UART_FLOW_NONE$, $PLATFORM_UART_FLOW_RTS$ or $PLATFORM_UART_FLOW_CTS$ or a bitwise combination of these constants
+        (see @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">flow_control_type at here</A>@ for details).]]
       },
+      ret = &quot;$PLATFORM_OK$ if the operation succeeded, $PLATFORM_ERR$ otherwise.&quot;
     },
-
-    { sig = &quot;int #platform_uart_recv#( unsigned id, unsigned timer_id, s32 timeout );&quot;,
-      link = &quot;platform_uart_recv&quot;,
-      desc = [[Receive data from the UART interface (blocking/non blocking with timeout/immediate).&lt;br&gt;
-  This function is &quot;split&quot; in two parts: a platform-independent part that is implemented in %src/common.c%, and a platform-dependent part that must be implemented by each
-  platform in a function named @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platform_s_uart_recv at platform_s_uart_recv</A>@.]],
+   
+      { sig = &quot;int #platform_s_uart_set_flow_control#( unsigned id, int type );&quot;,
+      desc = [[This is the platform-dependent part of the UART set flow control function @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platform_uart_set_flow_control at platform_uart_set_flow_control</A>@ and is in fact a &quot;subset&quot; of the
+      full function (thus being easier to implement by each platform in part). In particular, it never needs to deal with virtual UARTs.]],
       args = 
       {
         &quot;$id$ - UART interface ID.&quot;,
-        &quot;$timer_id$ - the ID of the timer used in this operation (see @<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">arch_platform_timers.html at here</A>@ for details). See also the description of the $timeout$ argument.&quot;,
-        [[$timeout$ - specifies a timeout for the receive operation as follows:
-  &lt;ul&gt;
-    &lt;li&gt;$timeout &gt; 0$: the timer with the specified $timer_id$ will be used to timeout the receive operation after $timeout$ microseconds.&lt;/li&gt;
-    &lt;li&gt;$timeout = 0$: the function returns immediately regardless of data being available or not. $timer_id$ is ignored.&lt;/li&gt;
-    &lt;li&gt;$timeout$ = @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">uart_timeout at PLATFORM_UART_INFINITE_TIMEOUT</A>@: the function waits indefinitely for UART data to be available and returns it. In this mode the function doesn't 
-        time out, so $timer_id$ is ignored.&lt;/li&gt;
-  &lt;/ul&gt;]],
+        [[$type$ - the desired flow control. It can be either $PLATFORM_UART_FLOW_NONE$, $PLATFORM_UART_FLOW_RTS$ or $PLATFORM_UART_FLOW_CTS$ or a bitwise combination of these constants
+        (see @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">flow_control_type at here</A>@ for details).]]
       },
-      ret = 
-      {
-        &quot;if $timeout &gt; 0$ and data from the UART is available in $timeout$ microseconds of less it is returned, otherwise -1 is returned&quot;,
-        &quot;if $timeout = 0$ and data from the UART is available when the function is called it is returned, otherwise -1 is returned&quot;,
-        &quot;if $timeout$ = @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">uart_timeout at PLATFORM_UART_INIFINITE_TIMEOUT</A>@ it returns the data read from the UART after it becomes available&quot;
-      }
+      ret = &quot;$PLATFORM_OK$ if the operation succeeded, $PLATFORM_ERR$ otherwise.&quot;
     },
-
-    { sig = &quot;int #platform_s_uart_recv#( unsigned id, s32 timeout );&quot;,
-      link = &quot;platform_s_uart_recv&quot;,
-      desc = [[This is the platform-dependent part of the UART receive function @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platform_uart_recv at platform_uart_recv</A>@, and is in fact a &quot;subset&quot; of the full function 
-  (thus being easier to implement by each platform in part). In particular, it never needs to deal with the $timeout &gt; 0$ case, which is handled by @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platform_uart_recv at platform_uart_recv</A>@.]],
-       args = 
-      {
-        &quot;$id$ - UART interface ID.&quot;,
-        [[$timeout$ - specifies a timeout for the receive operation as follows:
-  &lt;ul&gt;
-    &lt;li&gt;$timeout = 0$: the function returns immediately regardless of data being available or not.&lt;/li&gt;
-    &lt;li&gt;$timeout$ = @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">uart_timeout at PLATFORM_UART_INFINITE_TIMEOUT</A>@: the function waits indefinitely for UART data to be available and returns it.&lt;/li&gt;
-  &lt;/ul&gt;]],
-      },
-      ret = 
-      {
-        &quot;if $timeout = 0$ and data from the UART is available when the function is called it is returned, otherwise -1 is returned&quot;,
-        &quot;if $timeout$ = @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">uart_timeout at PLATFORM_UART_INIFINITE_TIMEOUT</A>@ it returns the data read from the UART after it becomes available&quot;
-      }
-    }
+  
   }
 }
 

Modified: trunk/doc/eluadoc/refman_gen_uart.lua
===================================================================
--- trunk/doc/eluadoc/refman_gen_uart.lua	2011-01-10 00:08:13 UTC (rev 880)
+++ trunk/doc/eluadoc/refman_gen_uart.lua	2011-01-16 00:23:19 UTC (rev 881)
@@ -12,11 +12,24 @@
   -- Overview
   overview = [[This module contains functions for accessing the serial ports (UARTs) of the eLua CPU.]],
 
+   -- Data structures, constants and types
+  structures = 
+  {
+    { text = [[uart.VUART0
+uart.VUART1
+.............
+uart.VUART7]],
+      name = &quot;UART constants&quot;,
+      desc = [[If @<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">sermux.html at virtual</A> UART@ support is enabled in eLua these constants are automatically defined
+to the IDs of the virtual UARTs in the system.]]       
+    }
+  }, 
+
   -- Functions
   funcs = 
   {
     { sig = &quot;baud = #uart.setup#( id, baud, databits, parity, stopbits )&quot;,
-      desc = &quot;Setup the serial port&quot;,
+      desc = &quot;Setup the serial port. Note that you can't call this function for a @<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">sermux.html at virtual</A> <A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">UART at .</A>&quot;,
       args = 
       {
         &quot;$id$ - the ID of the serial port&quot;,
@@ -72,8 +85,26 @@
 $timeout$ is neither $uart.NO_TIMEOUT$, nor $uart.INF_TIMEOUT$).]]
       },
       ret = [[The data read from the serial port as a string (or as a number if $format$ is $'*n'$). If a timeout occures, only the data read before the timeout is returned. If the function times out while trying to read the first character, the empty string is returned]]
+    },
+
+    { sig = &quot;#uart.set_buffer#( id, bufsize )&quot;,
+      desc = &quot;Sets the size of the UART buffer. Note that calling this function with bufsize = 0 for a @<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">sermux.html at virtual</A> UART@ is not allowed.&quot;,
+      args =
+      {
+        &quot;$id$ - the ID of the serial port&quot;,
+        &quot;$bufsize$ - the size of the buffer (must be a power of 2) or 0 to disable buffering on the specified UART.&quot;
+      },
+    },
+
+    { sig = &quot;#uart.set_flow_control#( id, type )&quot;,
+      desc = &quot;Sets the flow control on the UART. Note that this function works only on physical ports, it will return an error if called on a virtual UART.&quot;,
+      args =
+      {
+        &quot;$id$ - the ID of the serial port.&quot;,
+        [[$type$ - the flow control type, it can be either $uart.FLOW_NONE$ (no flow control), $uart.FLOW_RTS$ for RTS flow control, $uart.FLOW_CTS$ for CTS flow control or 
+          $uart.FLOW_RTS + uart.FLOW_CTS$ for full RTS/CTS flow control.]]
+      }
     }
-   
   },
 
 }

Modified: trunk/doc/en/arch_ints.txt
===================================================================
--- trunk/doc/en/arch_ints.txt	2011-01-10 00:08:13 UTC (rev 880)
+++ trunk/doc/en/arch_ints.txt	2011-01-16 00:23:19 UTC (rev 881)
@@ -67,6 +67,43 @@
 _platform_int.c_ should implement a function named *platform_int_init* (defined in _inc/platform.h_) that must initialize all the required hardware and the internal data structures of
 the interrupt subsystem. This function should be called from *platform_init*.
 
+5. *Implement the interrupt handlers*
++
+There are two simple requirements for the interrupt handlers: clear the hardware interrupt flag (if needed) and call *cmn_int_handler* (_src/common.c_) to connect the handler with the
+eLua interrupt code. An example is given below:
++
+[subs=&quot;quotes&quot;]
+-------------------------------
+// EINT3 (INT_GPIO) interrupt handler
+static void int_handler_eint3()
+{
+  elua_int_id id = ELUA_INT_INVALID_INTERRUPT;
+  pio_code resnum = 0;
+  int pidx, pin;
+  
+  EXTINT |= 1 &lt;&lt; EINT3_BIT; // clear interrupt
+  // Look for interrupt source
+  // In can only be GPIO0/GPIO2, as the EXT interrupts are not (yet) used
+  pidx = ( IO_INT_STAT &amp; 1 ) ? 0 : 1;
+  if( *posedge_status[ pidx ] )
+  {
+    id = INT_GPIO_POSEDGE;
+    pin = intlog2( *posedge_status[ pidx ] );
+  }
+  else
+  {
+    id = INT_GPIO_NEGEDGE;
+    pin = intlog2( *negedge_status[ pidx ] );
+  }
+  resnum = PLATFORM_IO_ENCODE( pidx * 2, pin, PLATFORM_IO_ENC_PIN );   
+ [bblue]** *intclr_regs[ pidx ] = 1 &lt;&lt; pin**;
+  
+  // Run the interrupt through eLua
+  [bblue]**cmn_int_handler( id, resnum )**;
+  VICVectAddr = 0; // ACK interrupt    
+}
+-------------------------------
+
 That's it. If you followed all these steps correctly, your platform should be fully able to support interrupt handlers (as described link:inthandlers.html[here]). Check the *lpc24xx*
 platform implementation (_src/platform/lpc24xx_) for a full example.
 
@@ -93,7 +130,8 @@
 ^|  Name              ^| Meaning                                    
 | INT_GPIO_POSEDGE    | Interrupt on a positive edge on a GPIO pin 
 | INT_GPIO_NEGEDGE    | Interrupt on a negative edge on a GPIO pin 
-| INT_TMR_MATCH       | Interrupt on timer match                   
+| INT_TMR_MATCH       | Interrupt on timer match
+| INT_UART_RX         | Interrupt on UART character received                            
 |===================================================================
 
 // $$FOOTER$$

Copied: trunk/doc/en/arch_rfs.txt (from rev 880, branches/remotefs_int/doc/en/arch_rfs.txt)
===================================================================
--- trunk/doc/en/arch_rfs.txt	                        (rev 0)
+++ trunk/doc/en/arch_rfs.txt	2011-01-16 00:23:19 UTC (rev 881)
@@ -0,0 +1,123 @@
+// $$HEADER$$
+eLua remote file system
+-----------------------
+*(v0.8 and above)* The RFS (Remote File System) is a file system that allows the
+user to &quot;share&quot; a directory on a PC with eLua over a serial connection. eLua will be able to access files
+on the shared PC directory just as they were local files; they can be opened,
+read, written, closed and so on. Developing in eLua becomes much easier with this
+file system: one can simply edit the source file on the desktop machine, using
+his favourite text editor, and run the file on the eLua board using *lua /rfs/&lt;file&gt;.lua*.
+The file can also be copied to (or from) the link:fatfs.html[SD/MMC file system] using the
+*cp* command in the link:using.html#shell[eLua shell]. 
+
+Enabling RFS in eLua
+~~~~~~~~~~~~~~~~~~~~
+This is the easy part, just follow the instruction in the link:building.html[building page]. 
+You need to define the following macros for RFS:
+
+[width=&quot;90%&quot;, cols=&quot;&lt;2s,&lt;5&quot;, options=&quot;header&quot;]
+|===================================================================
+^|  Option           ^| Meaning                                    
+| BUILD_RFS           | Enable RFS support in eLua 
+| RFS_BUFFER_SIZE     | Size of the RFS buffer. Needs to be one of the *BUF_SIZE_xxx* constants defined in _inc/buf.h_
+| RFS_UART_ID         | The ID of the UART that will be used by RFS. This is the physical connection over which the PC directory will be shared.
+| RFS_UART_SPEED      | Communication speed of the RFS UART interface. 
+| RFS_TIMER_ID        | The ID of a timer that will be used by RFS for internal operations
+| RFS_FLOW_TYPE       | Flow control type on the serial RFS interface, see link:arch_platform_uart.html#flow_control_type[here] for details. 
+If not specified it defaults to \'no flow control'.
+| RFS_TIMEOUT         | RFS operations timeout (in microseconds). If during a RFS operation no data is received from the PC side for the
+specified timeout, the RFS operation terminates with error.                        
+|===================================================================
+
+RFS server on the PC side
+~~~~~~~~~~~~~~~~~~~~~~~~~
+RFS needs a program running on the PC side, the *RFS server*. This is the program
+that implements the actual directory sharing (eLua connects to this program via
+the *RFS_UART_ID* UART). The RFS server was succesfully built and tested under 
+Windows 7 (32 bit) and Linux (Ubuntu 10.10 64 bit). To build it you need: 
+
+- a build environment. This means gcc under Linux (see for example link:tc_arm.html[here] for instruction on how to install a toolchain in 
+  Ubuntu Linux) and a gcc-based development environment under Windows. How to install a gcc-based development environment under Windows is
+  beyond the scope of this tutorial, but check <A HREF="http://www.mingw.org/[here">http://www.mingw.org/[here</A>] and <A HREF="http://tdm-gcc.tdragon.net/[here">http://tdm-gcc.tdragon.net/[here</A>] for possible solution
+  (RFS server was compiled and tested under Win32 using the second soluation, the tdm gcc compiler).
+- scons. See link:building_win.html[here] for details on how to install scons on Windows, or link:building_unix.html[here] for details on how
+  to install scons on Linux.
+
+If the above requirements are met, building the RFS server is a simple matter of invoking this command from the eLua source tree base directory:
+
+----------------------
+scons -f rfs_server.py  
+----------------------
+
+After this you should end up with a *rfs_server.exe* file in Windows or a *rfs_server* file in Linux. Running it without arguments prints
+the usage help:
+
+----------------------------------------------
+Usage: rfs_server &lt;transport&gt; &lt;dirname&gt; [-v]
+  Serial transport: 'ser:&lt;sername&gt;,&lt;serspeed&gt;,&lt;flow&gt; ('flow' defines the flow control and can be either 'none' or 'rtscts') 
+  UDP transport: 'udp:&lt;port&gt;'
+Use -v for verbose output.
+----------------------------------------------
+
+Note that currently the UDP transport is only implemented in the RFS server, not in eLua, so you can only use the serial transport. +
+*&lt;dirname&gt;* is the name of the directory that will be shared with eLua. In Win32, a proper server invocation can look like this:
+
+-------------------------------------
+rfs_server ser:com5,115200 c:\elua\fs
+-------------------------------------
+
+This shares the *c:\elua\fs* directory on COM5 at baud 115200 (note that the baud must match the *RFS_UART_SPEED* configuration macro). +
+In Linux:
+
+-----------------------------------------------------------
+./rfs_server ser:/dev/ttyUSB0,115200,rtscts /home/user/work/fs
+-----------------------------------------------------------
+
+This shares the */home/user/work/fs* directory on port /dev/ttyUSB0 at baud 115200. +
+Once the RFS server is in place, you can use it from eLua just like you'd use any other file system. For the previous example, if you have a file
+named */home/user/work/fs/test.lua* and you want to run in eLua, you just need to do this from the eLua shell:
+
+-----------------------
+elua# lua /rfs/test.lua
+-----------------------
+ 
+Notes
+~~~~~
+Some things you should consider when using the RFS:
+
+- the code is still in beta. It works well most of the time, but sometimes it simply crashes. If this happens, please consider submitting a bug report.
+- using hardware flow control is strongly encouraged. To do this:
+  1. make sure that your eLua board has support for hardware flow control (see link:refman_gen_uart.html#platform_uart_set_flow_control[here] for details).
+  2. specify the correct *RFS_FLOW_TYPE* value at build time (it should be *PLATFORM_UART_FLOW_RTS | PLATFORM_UART_FLOW_CTS*).
+  3. make sure that the serial cable connecting the PC and the eLua board also supports flow control. Some simple serial connection cables have only the RX, TX and GND wires. 
+     RTS/CTS flow control requires at least RX, TX, RTS, CTS and GND wires arranged in a null-modem configuration.
+  4. start *rfs_server* specifying _rtscts_ as part of the _&lt;transport&gt;_ parameter (see above).
+- eLua has a global filename size limit of 30 characters, so don't put files with longer names in the shared directory, it might lead to unexpec ted
+  behaviour. 
+- the file sharing &quot;protocol&quot; is an extremely simple one, it doesn't make provisions for error correction and has only very basic error detection. 
+  So, if there are serial communication problems on the connection used by RFS, you might encounter RFS errors (timeouts, invalid operations and so on). 
+  If the errors persist, simply restart *rfs_server* and reset the eLua board.
+- try not to share directories on devices that might go to sleep unexpectedly, such as an USB HDD attached to the PC, or a network storage device
+  with a HDD that might also go to sleep. If you try to make an operation on such a shared directory and the device is asleep, it will take a while
+  until it wakes up and during this time RFS will most likely time out (see *RFS_TIMEOUT* macro above). This, in turn, might confuse RFS completely and
+  give strange errors, like being unable to list the contents of the directory on the eLua board. If this happens, restart *rfs_server*, reset the
+  eLua board and try again.       
+- for reasons similar to the above, if you're running your server on a
+  hosted virtual machine (ex: Virtualbox, VMWare, ...), make sure the VM
+  host has a steady clock and does not keep entering and leaving some
+  energy-saving mode that changes the clock speed. If you work on this
+  configuration (usually on laptops), just go to your energy-savings
+  preferences and chose one that will not change the clock during the serial
+  transfers. This is not mandatory for all scenarios. Just keep this in mind
+  if you have some issues and change it only if needed.
+- the larger *RFS_BUFFER_SIZE* is, the better the performance, but obviously RAM consumption also increases.
+- some serial ports built around USB to RS232 adapters seem to confuse *rfs_server* sometimes. If RFS won't work after you tried all the above
+  instructions, or if *rfs_server* terminates unexpectedly, unplugging and plugging the USB cable of the RS232 adapter and restarting *rfs_server* 
+  will most likely solve your problem.
+- if you find a bug in the RFS server and wish to report it, try to reproduce the problem again, but this time run *rfs_server* with *-v* (verbose).
+  The resulting logs may help us identify the problem.  
+  
+If you like the RFS, but dislike the idea of having to connect your eLua board to the PC with two serial connections (one for the console and another
+one for the RFS) check link:sermux.html[here] for a possible solution to this. 
+
+// $$FOOTER$$

Modified: trunk/doc/en/filesystems.html
===================================================================
--- trunk/doc/en/filesystems.html	2011-01-10 00:08:13 UTC (rev 880)
+++ trunk/doc/en/filesystems.html	2011-01-16 00:23:19 UTC (rev 881)
@@ -3,8 +3,9 @@
 &lt;p&gt;You can compile and use more than one file system in &lt;b&gt;eLua&lt;/b&gt;, as listed below:&lt;/p&gt;
 &lt;ul&gt;
   &lt;li&gt;&lt;b&gt;the ROM file system&lt;/b&gt;: a very simple, very low footprint read-only file system that can be included in the &lt;b&gt;eLua&lt;/b&gt; binary image. Check &lt;a href=&quot;arch_romfs.html&quot;&gt;here&lt;/a&gt; for details.&lt;/li&gt;
-  &lt;li&gt;&lt;b&gt;the FAT file system&lt;/b&gt;: a read-write FAT filesystem implementation (platform independent) that can currently be used with SD/MMC memory cards. Check &lt;a href=&quot;fatfs.html&quot;&gt;here&lt;/a&gt; for 
+  &lt;li&gt;&lt;b&gt;the FAT file system&lt;/b&gt;: a read-write FAT file system implementation (platform independent) that can currently be used with SD/MMC memory cards. Check &lt;a href=&quot;fatfs.html&quot;&gt;here&lt;/a&gt; for 
   details. &lt;b&gt;(new in 0.7)&lt;/b&gt;&lt;/li&gt;
+  &lt;li&gt;&lt;b&gt;the remote file system (RFS)&lt;/b&gt;: a read-write file system that allows eLua to 'share' a directory on a PC, effectively accesing
+  its contents as if it was a local file system. Check &lt;a href=&quot;arch_rfs.html&quot;&gt;here&lt;/a&gt; for details. &lt;b&gt;(new in 0.8)&lt;/b&gt;&lt;/li&gt;  
 &lt;/ul&gt;
 $$FOOTER$$
-

Copied: trunk/doc/en/sermux.txt (from rev 880, branches/remotefs_int/doc/en/sermux.txt)
===================================================================
--- trunk/doc/en/sermux.txt	                        (rev 0)
+++ trunk/doc/en/sermux.txt	2011-01-16 00:23:19 UTC (rev 881)
@@ -0,0 +1,283 @@
+// $$HEADER$$
+The eLua serial multiplexer
+---------------------------
+*(v0.8 and above)* The *serial multiplexer* is an optional eLua component that allows
+using several serial ports over a single physical serial link connection. It can be a 
+very convenient feature, since some eLua components (such as link:using.html#rpc[the RPC mechanism] 
+or link:arfs_rfs.html[the remote file system]) need a serial link to the PC and 
+it's very incovenient (or even impossible sometimes) to connect the eLua board 
+to the PC with 2 or more serial cables. A common use scenario for the serial
+multiplexer is to have the eLua shell and RFS running over a single physical 
+connection to the PC, a very convenient method that will probably appeal to most
+eLua users.
+
+How does it work?
+~~~~~~~~~~~~~~~~~
+On the eLua side a number of virtual serial ports are defined. The eLua code
+can use these ports just like they would use a physical port, simply by specifing 
+a virtual port ID instead of a physical port ID. On the PC side, two things are 
+needed:
+
+- a program that can (de)multiplex UART requests from the eLua board. It is called
+  *mux* and it is part of the standard eLua distribution.
+- a mechanism for creating and using &quot;virtual serial ports&quot; on the PC itself. These
+  are actually pairs of virtual UARTs that are connected internally (inside
+  the OS) via a null-modem cable mechanism, which means that when you type something
+  on one port you can see its output on its pair (and the other way around).
+  
+See below for details on how to use virtual serial ports in Linux and Windows.  
+  
+Virtual serial ports in Linux
+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+Linux already supports the virtual serial port mechanism described above via the
+standard UNIX pseudo terminals, see <A HREF="http://en.wikipedia.org/wiki/Pseudo_terminal[here">http://en.wikipedia.org/wiki/Pseudo_terminal[here</A>]
+for details. Note that the multiplexer supports only BSD PTYs (*dev/ttypx*) and not
+Unix98 PTYs (*/dev/ptmx*). They are quite standard (although they are becoming 
+obsolete in some Linux distributions) so you shouldn't have any problems with them.
+A quick check for BSD PTYs is to look in your */dev* directory for *ttypx* and *ptypx* files.
+If they aren't there, you need to enable support for BSD PTYs in your system. How to
+do this is OS dependent and beyond the scope of this tutorial, so google is your friend.
+For an example on how to enable them in Ubuntu check 
+<A HREF="http://ubuntuforums.org/showthread.php?t=1147994[this">http://ubuntuforums.org/showthread.php?t=1147994[this</A> link].
+
+Once they are enabled you can get a quick feel of how their work. */dev/ttypx* and */dev/ptypx* 
+are paired by default, so any transmit/receive at one end is mirrored at the other end.
+A simple experiment:
+
+- start two shell sessions
+- execute *screen /dev/ttyp0 115200* in one of the shells
+- execute *screen /dev/ptyp0 115200* in the other shell
+
+Now everything you type in one of the shell sessions should be visible in the other one.
+
+Virtual serial ports in Windows
+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 
+Windows doesn't have out-of-the-box support for virtual serial ports, but
+fortunately there's an extremely nice open source program that does exactly 
+what eLua needs. It is called <A HREF="http://com0com.sourceforge.net/[com0com">http://com0com.sourceforge.net/[com0com</A>]. Download it,
+install it, then open the com0com serial port manager to create your virtual
+serial port pairs. Then give it a little spin to get used to how it works. Supposing
+that you created COM10 and COM11 as a virtual serial port pair, try this:
+
+- start your terminal emulator program. My preffered terminal emulator program in 
+  Windows is <A HREF="http://www.ayera.com/teraterm/[TeraTerm">http://www.ayera.com/teraterm/[TeraTerm</A>], but you can use any emulator 
+  you want. Open COM10 at baud 115200.
+- start another instance of the terminal emulator, but this time open COM11 at baud 115200.
+
+Now everything you type in one of the terminal emulators should be visible in the other one.
+
+NOTE: com0com can create pairs of serial ports with unusual names, for example *CNCA1* and *CNCB1*.
+While they work fine with eLua's serial multiplexer, they might not work equally well with terminal 
+emulator programs, so you're advised to stick with standard port names (*COMx*).
+
+Enabling the serial multiplexer in Lua
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+This is the easy part, just follow the instruction in the link:building.html[building page]. 
+You need to define the following macros for the serial multiplexer:
+
+[width=&quot;90%&quot;, cols=&quot;&lt;2s,&lt;5&quot;, options=&quot;header&quot;]
+|===================================================================
+^|  Option           ^| Meaning                                    
+| BUILD_SERMUX        | Enable serial multiplexer support in eLua. 
+| SERMUX_PHYS_ID      | The ID of the physical UART interface used by the serial multiplexer.
+| SERMUX_PHYS_SPEED   | Communication speed of the multiplexer UART interface. 
+| SERMUX_FLOW_TYPE    | Flow control type on the physical serial multiplexer interface, see link:arch_platform_uart.html#flow_control_type[here] for details. 
+If not specified it defaults to \'no flow control'.
+| SERMUX_NUM_VUART    | The number of virtual UART interfaces. This number can't be higher than 8. 
+| SERMUX_BUFFER_SIZES | An array of *SERMUX_NUM_VUART* integers that specify the buffer sizes for the virtual
+UART interfaces. Note that a virtual UART *MUST* have a buffer associated with it. The sizes are specified as
+*BUF_SIZE_xxx* constants defined in _inc/buf.h_                       
+|===================================================================
+
+As a simple example, let's change the configuration of an eLua board that uses UART 0 
+as its console UART to use a serial multiplexer with 2 ports (one for RFS and the other
+one for console) over UART 0. The original configuration (in _src/platform/&lt;platform&gt;/platform_conf.h_)
+will look like this:
+
+------------------------------------
+#define CON_UART_ID           0
+#define CON_UART_SPEED        115200
+------------------------------------
+
+The new configuration should be similar to the one below:
+
+[subs=&quot;quotes&quot;]
+------------------------------------
+#include &quot;sermux.h&quot;                                             [bblue]**// for virtual uart IDs**
+#include &quot;buf.h&quot;                                                [bblue]**// for buffer sizes**
+
+#define BUILD_SERMUX                                            [bblue]**// enable serial multiplexer support**
+#define CON_UART_ID         ( SERMUX_SERVICE_ID_FIRST + 1 )     [bblue]**// console runs on the second virtual UART**
+#define CON_BUF_SIZE        BUF_SIZE_128                        [bblue]**// size of console UART buffer, cannot be 0**
+#define RFS_UART_ID         ( SERMUX_SERVICE_ID_FIRST )         [bblue]**// RFS runs on the first virtual UART**   
+#define RFS_BUFFER_SIZE     BUF_SIZE_512                        [bblue]**// size of the RFS UART buffer, cannot be 0**
+// Serial multiplexer data
+#define SERMUX_PHYS_ID      0                                   [bblue]**// multiplexer runs on UART 0**
+#define SERMUX_PHYS_SPEED   115200                              [bblue]**// multiplexer runs at 115200 baud**
+#define SERMUX_NUM_VUART    2                                   [bblue]**// multiplexer creates 2 virtual UARTs**
+#define SERMUX_BUFFER_SIZES { RFS_BUFFER_SIZE, CON_BUF_SIZE }   [bblue]**// buffer sizes for the virtual UARTs**
+------------------------------------
+
+This sequence of macro definitions will enable serial multiplexer support in eLua and will allow the
+code to use two *virtual UARTs*. The virtual UART IDs start at *SERMUX_SERVICE_ID_FIRST*. A maximum
+of 8 virtual UARTs are supported by the system. In this particular example the first virtual UART
+is assigned to RFS and the second one to the system console.
+
+IMPORTANT: when using the RFS in a virtual UART configuration, remember that *RFS_UART_ID must be the
+first virtual UART ID in the system (SERMUX_SERVICE_ID_FIRST)*. Otherwise, the serial multiplexer will 
+NOT work properly in *rfsmux* mode. Check xref:rfsmux[here] for details, and link:arch_rfs.html[here] 
+for more details about the RFS.
+
+Serial multiplexer on the PC side
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+The serial multiplexer needs a program running on the PC side, the *mux server*. This is 
+the program that implements the actual serial port multiplexing (eLua connects to this program via
+the *SERMUX_PHYS_ID* UART). The mux server was succesfully built and tested under 
+Windows 7 (32 bit) and Linux (Ubuntu 64 bit). To build it you need: 
+
+- a build environment. This means gcc under Linux (see for example link:tc_arm.html[here] for instruction on how to install a toolchain in 
+  Ubuntu Linux) and a gcc-based development environment under Windows. How to install a gcc-based development environment under Windows is
+  beyond the scope of this tutorial, but check <A HREF="http://www.mingw.org/[here">http://www.mingw.org/[here</A>] and <A HREF="http://tdm-gcc.tdragon.net/[here">http://tdm-gcc.tdragon.net/[here</A>] for possible solution
+  (the mux server was compiled and tested under Win32 using the second soluation, the tdm gcc compiler).
+- scons. See link:building_win.html[here] for details on how to install scons on Windows, or link:building_unix.html[here] for details on how
+  to install scons on Linux.
+
+If the above requirements are met, building the mux server is a simple matter of invoking this command from the eLua source tree base directory:
+
+---------------
+scons -f mux.py  
+---------------
+
+After this you should end up with a *mux.exe* file in Windows, or a *mux* file in Linux. Running it without arguments prints
+the usage help:
+
+---------------
+Usage: mux &lt;mode&gt; &lt;transport&gt; &lt;vcom1&gt; [&lt;vcom2&gt;] ... [&lt;vcomn&gt;] [-v]
+  mode:
+    'mux':                 serial multiplexer mode
+    'rfsmux:&lt;directory&gt;:   combined RFS and multiplexer mode.
+  transport: '&lt;port&gt;,&lt;baud&gt;,&lt;flow&gt; ('flow' specifies the flow control type and can be 'none' or 'rtscts').
+  vcom1, ..., vcomn: multiplexer serial ports.  Use '-v' for verbose output.
+---------------
+
+Using the multiplexer in &quot;mux&quot; mode
+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+This is the basic use scenario for the serial multiplexer. Im this mode *mux* will
+simply multiplex the serial connection with the eLua board with a number of virtual
+serial ports in the system. 
+
+This is best understood by an example. We'll ask *mux*
+to multiplex two serial ports for us, these will be *dev/ptyp0* (and its pair */dev/ttyp0*)
+and */dev/ptyp1* (and its pair */dev/ttyp1*) in Linux and COM10 (and its pair COM11) 
+and COM20 (and its pair COM21) in Windows. The physical UART is /dev/ttyUSB0 in 
+Linux and COM5 in Windows. So, to run it in Linux, execute this:
+
+-------------------------------------------------------
+./mux.exe mux /dev/ttyUSB0,115200,rtscts /dev/ptyp0 /dev/ptyp1
+-------------------------------------------------------
+
+In Windows:
+
+-------------------------------
+mux mux com5,115200,rtscts com10 com20
+-------------------------------
+
+And now let's put this to good use. Remember that in the previous paragraph we 
+built an eLua configuration that assigned RFS to the first virtual UART (which corresponds
+to the *vcom1* argument of *mux*) and the console to the second one (which corresponds
+to the *vcom2* argument of *mux*). To make this happen on the PC, we start
+the respective services on the UART pairs of the *vcomx* arguments of *mux*.
+In Linux:
+
+-----------------------------------------------------
+./rfs_server ser:/dev/ttyp0,115200,none /home/user/work/fs
+screen /dev/ttyp1 115200 
+-----------------------------------------------------
+
+In Windows:
+
+----------
+rfs_server ser:com11,115200,none c:\elua\fs
+(also run TeraTerm or your preffered terminal emulator on port COM21 at 115200 baud)
+----------
+
+Reset your eLua board, and you're ready to go! *mux* will send all the RFS requests
+to */dev/ptyp0* (or COM10) which in turn gets automatically redirected to */dev/ttyp0*
+(or COM11) and will redirect all console I/O to */dev/ptyp1* (or COM20)
+which in turn gets automatically redirected to */dev/ptyp1* (or COM21).
+
+Although this works, there is a simpler, more convenient way to do it if RFS 
+support is needed: use the *rfsmux* mode instead.
+
+[[rfsmux]]
+Using the multiplexer in &quot;rfsmux&quot; mode
+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+To make things easier for RFS users *mux* includes a special operation mode (*rfsmux*) 
+that automatically &quot;talks&quot; to the RFS server. The user doesn't need to manually assign
+a virtual UART for the RFS server and start the RFS server. In this mode *mux* uses a special
+internal communication channel to the RFS server (that doesn't require a virtual UART).
+A strict requirement for this mode is that *eLua must be configured to assign the first
+virtual UART ID (SERMUX_SERVICE_ID_FIRST) to the RFS server (RFS_UART_ID)*. If this
+doesn't happen, *rfsmux* mode will not work anymore (but note that you still can use the
+*mux* mode described above with this setup). 
+
+This is best understood by an example. We'll ask *mux* to share a directory and
+to multiplex one single serial port for us (we'll use it for the console), this
+will be *dev/ptyp0* (and its pair */dev/ttyp0*) in Linux and COM10 (and its pair COM11) 
+in Windows. The physical UART is /dev/ttyUSB0 in Linux and COM5 in Windows. 
+So, to run it in Linux, execute this:
+
+------------------------------------------------------------------
+./mux.exe rfsmux:/home/user/work/fs /dev/ttyUSB0,115200,rtscts /dev/ptyp0
+------------------------------------------------------------------
+
+In Windows:
+
+---------------------------------------
+mux rfsmux:c:\elua\fs com5,115200,rtscts com10
+---------------------------------------
+
+All that's left now is to run the terminal emulator. In Linux:
+
+------------------------
+screen /dev/ttyp0 115200 
+------------------------
+
+In Windows simply start TeraTerm or your preffered terminal emulator on port COM11 at 115200 baud.
+
+Reset your eLua board, and you're ready to go! *mux* will send all the RFS requests
+to the RFS server via its internal channel and will redirect all console I/O to */dev/ptyp0* (or COM10)
+which in turn gets automatically redirected to */dev/ttyp0* (or COM11).
+
+Notes
+~~~~~
+Some things you should consider when using the serial multiplexer:
+
+- the code is still in beta. It works well most of the time, but sometimes it simply crashes. If this happens, please consider submitting a bug report.
+- if your eLua board has two hardware serial ports that you can use and the PC has also two free serial ports, consider disabling the serial multiplexer completely. Run RFS on a hardware
+  port and the system console on the other hardware port instead. This is both more realiable and more efficient.
+- to avoid problems with the serial multiplexer use this sequence to start it:
+  1. start *mux*
+  2. start the terminal emulator
+  3. reset the eLua board
+- using hardware flow control is strongly encouraged. To do this:
+  1. make sure that your eLua board has support for hardware flow control (see link:refman_gen_uart.html#platform_uart_set_flow_control[here] for details).
+  2. specify the correct *SERMUX_FLOW_TYPE* value at build time (it should be *PLATFORM_UART_FLOW_RTS | PLATFORM_UART_FLOW_CTS*).
+  3. make sure that the serial cable connecting the PC and the eLua board also supports flow control. Some simple serial connection cables have only the RX, TX and GND wires. 
+     RTS/CTS flow control requires at least RX, TX, RTS, CTS and GND wires arranged in a null-modem configuration.
+  4. start *mux* specifying _rtscts_ as part of the _&lt;transport&gt;_ parameter (see above).
+- the serial multiplexer &quot;protocol&quot; is an extremely simple one, it doesn't make provisions for error correction or detection, and it might loose
+  synchronization if there are errors on the serial line. So, if it starts behaving abnormally, you might want to restart *mux* (and *rfs_server*
+  if you're running it with *mux*) and reset your eLua board.
+- some serial ports built around USB to RS232 adapters seem to confuse *mux* sometimes. If *mux* won't work after you tried all the above
+  instructions, or if *mux* terminates unexpectedly, unplugging and plugging the USB cable of the RS232 adapter and restarting *mux* 
+  will most likely solve your problem. 
+- if you get an *&quot;Error on select, aborting program&quot;* error from *mux*, keep in mind that this is normal if you run a terminal emulator (*screen*)
+  under Linux on a virtual UART and then close it (by exiting *screen*). However, it is not normal if it happens under other circumstances in Linux, 
+  or if it happens in Windows. In these cases, please consider submitting a bug report.
+- if the serial multiplexer is enabled on the eLua board it's not possible to use the board with a regular terminal emulator anymore (without 
+  running *mux*), although it might appear so. eLua will send some output to the terminal emulator, but it won't be able to accept any input from it.     
+- if you find a bug in *mux* and wish to report it, try to reproduce the problem again, but this time run *mux* with *-v* (verbose).
+  The resulting logs may help us identify the problem.  
+
+// $$FOOTER$$

Modified: trunk/doc/style1.css
===================================================================
--- trunk/doc/style1.css	2011-01-10 00:08:13 UTC (rev 880)
+++ trunk/doc/style1.css	2011-01-16 00:23:19 UTC (rev 881)
@@ -323,8 +323,8 @@
   margin-bottom: 1.0em;
 }
 div.admonitionblock {
-  margin-top: 2.0em;
-  margin-bottom: 2.0em;
+  margin-top: 1.0em;
+  margin-bottom: 1.0em;
   margin-right: 10%;
   color: #606060;
 }

Modified: trunk/inc/common.h
===================================================================
--- trunk/inc/common.h	2011-01-10 00:08:13 UTC (rev 880)
+++ trunk/inc/common.h	2011-01-16 00:23:19 UTC (rev 881)
@@ -18,6 +18,7 @@
 int cmn_tmr_int_set_status( elua_int_resnum resnum, int status );
 int cmn_tmr_int_get_status( elua_int_resnum resnum );
 int cmn_tmr_int_get_flag( elua_int_resnum resnum, int clear );
+void cmn_uart_setup_sermux();
 
 unsigned int intlog2( unsigned int v );
 

Copied: trunk/inc/eluarpc.h (from rev 880, branches/remotefs_int/inc/eluarpc.h)
===================================================================
--- trunk/inc/eluarpc.h	                        (rev 0)
+++ trunk/inc/eluarpc.h	2011-01-16 00:23:19 UTC (rev 881)
@@ -0,0 +1,65 @@
+// Lightweight remote procedure call layer
+
+#ifndef __ELUARPC_H__
+#define __ELUARPC_H__
+
+#include &quot;type.h&quot;
+
+#define   PACKET_SIG          0x18AFC284UL
+
+// Error codes
+#define   ELUARPC_OK          0
+#define   ELUARPC_ERR         1
+
+#define   ELUARPC_OP_RES_MOD  0x80
+
+// Protocol constants
+#define   ELUARPC_START_OFFSET    4
+#define   ELUARPC_START_SIZE      6
+#define   ELUARPC_END_SIZE        6
+#define   ELUARPC_RESPONSE_SIZE   1
+#define   ELUARPC_PTR_HEADER_SIZE 6
+#define   ELUARPC_SMALL_PTR_HEADER_SIZE 4
+#define   ELUARPC_U32_SIZE        5
+#define   ELUARPC_U16_SIZE        3
+#define   ELUARPC_U8_SIZE         2
+#define   ELUARPC_OP_ID_SIZE      2
+#define   ELUARPC_READ_BUF_OFFSET ( ELUARPC_START_OFFSET + ELUARPC_START_SIZE + ELUARPC_RESPONSE_SIZE + ELUARPC_PTR_HEADER_SIZE )
+#define   ELUARPC_SMALL_READ_BUF_OFFSET ( ELUARPC_START_OFFSET + ELUARPC_START_SIZE + ELUARPC_RESPONSE_SIZE + ELUARPC_SMALL_PTR_HEADER_SIZE )
+#define   ELUARPC_WRITE_REQUEST_EXTRA ( ELUARPC_START_OFFSET + ELUARPC_START_SIZE + ELUARPC_OP_ID_SIZE + ELUARPC_U32_SIZE + ELUARPC_PTR_HEADER_SIZE + ELUARPC_END_SIZE )
+
+// Public interface
+// Get request ID
+int eluarpc_get_request_id( const u8 *p, u8 *pid );
+
+// Replace a flag with another flag
+u32 eluarpc_replace_flag( u32 val, u32 origflag, u32 newflag );
+
+// Get packet size
+int eluarpc_get_packet_size( const u8 *p, u16 *psize );
+
+// Generic write function
+// Specifiers: o - operation
+//             r - response
+//             c - u8
+//             h - u16
+//             l - u32
+//             i - int
+//             L - s32
+//             p - ptr (given as ptr, len, len is an u32)
+//             P - ptr (given as ptr, len, len is an u16)
+void eluarpc_gen_write( u8 *p, const char *fmt, ... );
+
+// Generic read function
+// Specifiers: o - operation
+//             r - response
+//             c - u8
+//             h - u16
+//             l - u32
+//             L - s32
+//             i - int
+//             p - ptr (returned as ptr, len, len is an u32)
+//             P - ptr (returned as ptr, len, len is an u16)
+int eluarpc_gen_read( const u8 *p, const char *fmt, ... );
+
+#endif

Modified: trunk/inc/platform.h
===================================================================
--- trunk/inc/platform.h	2011-01-10 00:08:13 UTC (rev 880)
+++ trunk/inc/platform.h	2011-01-16 00:23:19 UTC (rev 881)
@@ -136,12 +136,21 @@
 // &quot;Infinite timeout&quot; constant for recv
 #define PLATFORM_UART_INFINITE_TIMEOUT        (-1)
 
+// Flow control types (this is a bit mask, one can specify PLATFORM_UART_FLOW_RTS | PLATFORM_UART_FLOW_CTS )
+#define PLATFORM_UART_FLOW_NONE               0
+#define PLATFORM_UART_FLOW_RTS                1
+#define PLATFORM_UART_FLOW_CTS                2
+
 // The platform UART functions
 int platform_uart_exists( unsigned id );
 u32 platform_uart_setup( unsigned id, u32 baud, int databits, int parity, int stopbits );
+int platform_uart_set_buffer( unsigned id, unsigned size );
 void platform_uart_send( unsigned id, u8 data );
+void platform_s_uart_send( unsigned id, u8 data );
 int platform_uart_recv( unsigned id, unsigned timer_id, s32 timeout );
 int platform_s_uart_recv( unsigned id, s32 timeout );
+int platform_uart_set_flow_control( unsigned id, int type );
+int platform_s_uart_set_flow_control( unsigned id, int type );
 
 // *****************************************************************************
 // Timer subsection

Modified: trunk/inc/remotefs/client.h
===================================================================
--- trunk/inc/remotefs/client.h	2011-01-10 00:08:13 UTC (rev 880)
+++ trunk/inc/remotefs/client.h	2011-01-16 00:23:19 UTC (rev 881)
@@ -11,7 +11,7 @@
 
 // RFS client send/receive functions
 typedef u32 ( *p_rfsc_send )( const u8 *p, u32 size );
-typedef u32 ( *p_rfsc_recv )( u8 *p, u32 size, u32 timeout );
+typedef u32 ( *p_rfsc_recv )( u8 *p, u32 size, s32 timeout );
 
 // Public interface
 void rfsc_setup( u8 *pbuf, p_rfsc_send rfsc_send_func, p_rfsc_recv rfsc_recv_func, u32 timeout );

Modified: trunk/inc/remotefs/remotefs.h
===================================================================
--- trunk/inc/remotefs/remotefs.h	2011-01-10 00:08:13 UTC (rev 880)
+++ trunk/inc/remotefs/remotefs.h	2011-01-16 00:23:19 UTC (rev 881)
@@ -5,12 +5,6 @@
 
 #include &quot;type.h&quot;
 
-#define   PACKET_SIG      0x18AFC284UL
-
-// Error codes
-#define   REMOTEFS_OK     0
-#define   REMOTEFS_ERR    1
-
 // Operation IDs
 #define   RFS_OP_OPEN     0x01
 #define   RFS_OP_FIRST    RFS_OP_OPEN
@@ -24,17 +18,6 @@
 #define   RFS_OP_LAST     RFS_OP_CLOSEDIR
 #define   RFS_OP_RES_MOD  0x80
 
-// Protocol constants
-#define   RFS_START_OFFSET    4
-#define   RFS_START_SIZE      6
-#define   RFS_END_SIZE        6
-#define   RFS_RESPONSE_SIZE   1
-#define   RFS_PTR_HEADER_SIZE 6
-#define   RFS_U32_SIZE        5
-#define   RFS_OP_ID_SIZE      2
-#define   RFS_READ_BUF_OFFSET ( RFS_START_OFFSET + RFS_START_SIZE + RFS_RESPONSE_SIZE + RFS_PTR_HEADER_SIZE )
-#define   RFS_WRITE_REQUEST_EXTRA ( RFS_START_OFFSET + RFS_START_SIZE + RFS_OP_ID_SIZE + RFS_U32_SIZE + RFS_PTR_HEADER_SIZE + RFS_END_SIZE )
-
 // Platform independent constants for &quot;flags&quot; in &quot;open&quot;
 #define   RFS_OPEN_FLAG_APPEND      0x01
 #define   RFS_OPEN_FLAG_CREAT       0x02
@@ -57,16 +40,6 @@
 // Max filename size on a RFS instance
 #define   RFS_MAX_FNAME_SIZE        31
 
-// Public interface
-// Get request ID
-int remotefs_get_request_id( const u8 *p, u8 *pid );
-
-// Replace a flag with another flag
-u32 remotefs_replace_flag( u32 val, u32 origflag, u32 newflag );
-
-// Get packet size
-int remotefs_get_packet_size( const u8 *p, u16 *psize );
-
 // Function: int open(const char *pathname,int flags, mode_t mode)
 void remotefs_open_write_response( u8 *p, int result );
 int remotefs_open_read_response( const u8 *p, int *presult );

Deleted: trunk/inc/remotefs/rtype.h
===================================================================
--- trunk/inc/remotefs/rtype.h	2011-01-10 00:08:13 UTC (rev 880)
+++ trunk/inc/remotefs/rtype.h	2011-01-16 00:23:19 UTC (rev 881)
@@ -1,17 +0,0 @@
-// Type definitions for the remote file system
-
-#ifndef __RTYPE_H__
-#define __RTYPE_H__
-
-// Type codes
-#define   TYPE_INT_8      0x01
-#define   TYPE_INT_16     0x02
-#define   TYPE_INT_32     0x03
-#define   TYPE_PTR        0x04
-#define   TYPE_START      0x05
-#define   TYPE_END        0x06
-#define   TYPE_OP_ID      0x07
-#define   TYPE_PKT_SIZE   0xA5
-                                    
-#endif
-

Copied: trunk/inc/rtype.h (from rev 880, branches/remotefs_int/inc/rtype.h)
===================================================================
--- trunk/inc/rtype.h	                        (rev 0)
+++ trunk/inc/rtype.h	2011-01-16 00:23:19 UTC (rev 881)
@@ -0,0 +1,18 @@
+// Type definitions for the remote file system
+
+#ifndef __RTYPE_H__
+#define __RTYPE_H__
+
+// Type codes
+#define   TYPE_INT_8      0x01
+#define   TYPE_INT_16     0x02
+#define   TYPE_INT_32     0x03
+#define   TYPE_PTR        0x04
+#define   TYPE_START      0x05
+#define   TYPE_END        0x06
+#define   TYPE_OP_ID      0x07
+#define   TYPE_SMALL_PTR  0x08
+#define   TYPE_PKT_SIZE   0xA5
+                                    
+#endif
+

Copied: trunk/inc/sermux.h (from rev 880, branches/remotefs_int/inc/sermux.h)
===================================================================
--- trunk/inc/sermux.h	                        (rev 0)
+++ trunk/inc/sermux.h	2011-01-16 00:23:19 UTC (rev 881)
@@ -0,0 +1,16 @@
+// Serial multiplexer definitions 
+
+#ifndef __SERMUX_H__
+#define __SERMUX_H__
+
+#define SERMUX_SERVICE_ID_FIRST  0xD0
+#define SERMUX_SERVICE_ID_LAST   0xD7
+#define SERMUX_SERVICE_MAX       ( SERMUX_SERVICE_ID_LAST - SERMUX_SERVICE_ID_FIRST + 1 )
+
+#define SERMUX_ESCAPE_CHAR       0xC0
+#define SERMUX_FORCE_SID_CHAR    0xFF
+
+#define SERMUX_ESCAPE_XOR_MASK   0x20
+#define SERMUX_ESC_MASK          0x100
+
+#endif

Modified: trunk/inc/utils.h
===================================================================
--- trunk/inc/utils.h	2011-01-10 00:08:13 UTC (rev 880)
+++ trunk/inc/utils.h	2011-01-16 00:23:19 UTC (rev 881)
@@ -8,6 +8,12 @@
 #define UMAX( x, y )      ( ( x ) &gt;= ( y ) ? ( x ) : ( y ) )
 #define UABS( x )         ( ( x ) &gt;= 0 ? ( x ) : -( x ) )
 
+// Implement a very simple try-catch ike mechanism using setmp/longjmp,
+// mostly to avoid goto's :)
+#define EXC_DECLARE static jmp_buf exception_buf
+#define EXC_TRY if( setjmp( exception_buf ) == 0 )
+#define EXC_CATCH else
+#define EXC_THROW() longjmp( exception_buf, 1 )
 
 // Macro version of Duff's device found in 
 // &quot;A Reusable Duff Device&quot; by Ralf Holly

Modified: trunk/inc/validate.h
===================================================================
--- trunk/inc/validate.h	2011-01-10 00:08:13 UTC (rev 880)
+++ trunk/inc/validate.h	2011-01-16 00:23:19 UTC (rev 881)
@@ -57,4 +57,32 @@
   #endif // #ifndef BUILD_TERM
 #endif // #ifdef BUILD_LINENOISE
 
+// For BUF_ENABLE_UART we also need C interrupt handlers support and specific INT_UART_RX support
+#if defined( BUF_ENABLE_UART ) 
+  #if !defined( BUILD_C_INT_HANDLERS )
+  #error &quot;Buffering support on UART neeeds C interrupt handlers support, define BUILD_C_INT_HANDLERS in your platform_conf.h&quot;
+  #endif
+  #if !defined( INT_UART_RX )
+  #error &quot;Buffering support on UART needs support for the INT_UART_RX interrupt&quot;
+  #endif
+#endif
+
+// Virtual UARTs need buffering and a few specific macros
+#if defined( BUILD_SERMUX )
+  #if !defined( BUF_ENABLE_UART )
+  #error &quot;Virtual UARTs need buffering support, enable BUF_ENABLE_UART&quot;  
+  #endif
+#endif
+
+// CON_BUF_SIZE needs BUF_ENABLE_UART and CON_UART_ID
+#if defined( CON_BUF_SIZE )
+  #if !defined( BUF_ENABLE_UART )
+  #error &quot;Console buffering needs BUF_ENABLE_UART&quot;
+  #endif
+  #if !defined( CON_UART_ID )
+  #error &quot;Console buffering needs CON_UART_ID defined to the UART ID of the console device&quot;
+  #endif
+#endif
+  
 #endif // #ifndef __VALIDATE_H__
+

Copied: trunk/mux.py (from rev 880, branches/remotefs_int/mux.py)
===================================================================
--- trunk/mux.py	                        (rev 0)
+++ trunk/mux.py	2011-01-16 00:23:19 UTC (rev 881)
@@ -0,0 +1,33 @@
+import os, sys, platform
+
+flist = &quot;main.c&quot;
+rfs_flist = &quot;main.c server.c log.c deskutils.c&quot;
+cdefs = &quot;-DRFS_UDP_TRANSPORT -DRFS_INSIDE_MUX_MODE&quot;
+socklib = ''
+ptlib = ''
+if platform.system() == &quot;Windows&quot;:
+  cdefs = cdefs + &quot; -DWIN32_BUILD&quot;
+  rfs_flist = rfs_flist + &quot; os_io_win32.c serial_win32.c net_win32.c&quot;
+  exeprefix = &quot;.exe&quot;
+  socklib = '-lws2_32'
+else:
+  rfs_flist = rfs_flist + &quot; os_io_posix.c serial_posix.c net_posix.c&quot;
+  exeprefix = &quot;&quot;
+  socklib = ''
+
+output = &quot;mux%s&quot; % exeprefix
+
+rfs_full_files = &quot; &quot; + &quot; &quot;.join( [ &quot;rfs_server_src/%s&quot; % name for name in rfs_flist.split() ] )
+full_files = &quot; &quot; + &quot; &quot;.join( [ &quot;mux_src/%s&quot; % name for name in flist.split() ] ) + rfs_full_files + &quot; src/remotefs/remotefs.c src/eluarpc.c&quot;
+local_include = &quot;-Imux_src -Irfs_server_src -Iinc -Iinc/remotefs&quot;
+
+# Compiler/linker options
+cccom = &quot;gcc -m32 -O0 -g %s -Wall %s -c $SOURCE -o $TARGET&quot; % ( local_include, cdefs )
+linkcom = &quot;gcc -m32 -o $TARGET $SOURCES %s&quot; % socklib
+
+# Env for building the program
+comp = Environment( CCCOM = cccom,
+                    LINKCOM = linkcom,
+                    ENV = os.environ )
+Decider( 'MD5' )                  
+Default( comp.Program( output, Split( full_files ) ) )

Modified: trunk/rfs_server.py
===================================================================
--- trunk/rfs_server.py	2011-01-10 00:08:13 UTC (rev 880)
+++ trunk/rfs_server.py	2011-01-16 00:23:19 UTC (rev 881)
@@ -3,7 +3,8 @@
 sim = ARGUMENTS.get( 'sim', '0' )
 
 flist = &quot;&quot;
-cdefs = &quot;&quot;
+cdefs = &quot;-DRFS_STANDALONE_MODE&quot;
+socklib = ''
 if sim == '0':
   mainname = &quot;main.c&quot;
 else:
@@ -12,30 +13,27 @@
   if sim == '1':
     print &quot;SIM target not supported under Windows&quot;
     os.exit( 1 )
-  flist = &quot;main.c server.c client.c os_io_win32.c log.c&quot;
-  cdefs = &quot;-DWIN32_BUILD&quot;
-  exeprefix = &quot;exe&quot;
+  flist = &quot;main.c server.c os_io_win32.c log.c net_win32.c serial_win32.c deskutils.c&quot;
+  cdefs = cdefs + &quot; -DWIN32_BUILD&quot;
+  exeprefix = &quot;.exe&quot;
+  socklib = '-lws2_32'
 else:
-  flist = &quot;%s server.c client.c os_io_posix.c log.c&quot; % mainname
-  exeprefix = &quot;elf&quot;
+  flist = &quot;%s server.c os_io_posix.c log.c net_posix.c serial_posix.c deskutils.c&quot; % mainname
+  exeprefix = &quot;&quot;
 
 if sim == '0':
-  output = 'rfs_server.%s' % exeprefix
+  output = 'rfs_server%s' % exeprefix
 else:
-  output = 'rfs_sim_server.%s' % exeprefix
+  output = 'rfs_sim_server%s' % exeprefix
 #endif
 
-full_files = &quot; &quot; + &quot; &quot;.join( [ &quot;rfs_server/%s&quot; % name for name in flist.split() ] )
-full_files = full_files + &quot; src/remotefs/remotefs.c&quot;
-if platform.system() == &quot;Windows&quot;:
-  full_files = full_files + &quot; rfs_server/serial_win32.c&quot;
-else:
-  full_files = full_files + &quot; rfs_server/serial_posix.c&quot;
-local_include = &quot;-Irfs_server -Iinc/remotefs&quot;
+full_files = &quot; &quot; + &quot; &quot;.join( [ &quot;rfs_server_src/%s&quot; % name for name in flist.split() ] )
+full_files = full_files + &quot; src/remotefs/remotefs.c src/eluarpc.c&quot;
+local_include = &quot;-Irfs_server_src -Iinc/remotefs -Iinc&quot;
 
 # Compiler/linker options
 cccom = &quot;gcc -m32 -O0 -g %s -Wall %s -c $SOURCE -o $TARGET&quot; % ( local_include, cdefs )
-linkcom = &quot;gcc -m32 -o $TARGET $SOURCES&quot;
+linkcom = &quot;gcc -m32 -o $TARGET $SOURCES %s&quot; % socklib
 
 # Env for building the program
 comp = Environment( CCCOM = cccom,

Modified: trunk/src/buf.c
===================================================================
--- trunk/src/buf.c	2011-01-10 00:08:13 UTC (rev 880)
+++ trunk/src/buf.c	2011-01-16 00:23:19 UTC (rev 881)
@@ -1,23 +1,31 @@
 // eLua &quot;char device&quot; buffering system
 
 #include &quot;platform_conf.h&quot;
+#include &lt;stdio.h&gt;
 
 #if defined( BUF_ENABLE_UART ) || defined( BUF_ENABLE_ADC )
 #define BUF_ENABLE
 #endif
 
+#ifdef BUILD_SERMUX
+#define NUM_TOTAL_UART  ( NUM_UART + SERMUX_NUM_VUART )
+#else
+#define NUM_TOTAL_UART  ( NUM_UART )
+#endif
+
 #ifdef BUF_ENABLE
 
 #include &quot;buf.h&quot;
 #include &quot;type.h&quot;
 #include &quot;platform.h&quot;
 #include &quot;utils.h&quot;
+#include &quot;sermux.h&quot;
 #include &lt;stdlib.h&gt;
 #include &lt;string.h&gt;
 
 // [TODO]? Following code might need a C99 compiler (for 0-sized arrays)
 #ifdef BUF_ENABLE_UART
-  static buf_desc buf_desc_uart[ NUM_UART ];
+  static buf_desc buf_desc_uart[ NUM_TOTAL_UART ];
 #else
   static buf_desc buf_desc_uart[ 0 ];
 #endif
@@ -33,7 +41,7 @@
 static const buf_desc* buf_desc_array[ BUF_ID_TOTAL ] = 
 {
   buf_desc_uart,
-  buf_desc_adc,
+  buf_desc_adc
 };
 
 // Helper macros
@@ -48,6 +56,21 @@
 #define READ16( p )     p
 #define WRITE16( p, x ) p = x
 
+// Helper: check 'resnum' (for virtual UARTs)
+// UART resource ID translation to buffer ID translation (for serial multiplexer support)
+#ifdef BUILD_SERMUX
+static unsigned bufh_check_resnum( unsigned resid, unsigned resnum )
+{
+  if( resid == BUF_ID_UART &amp;&amp; resnum &gt;= SERMUX_SERVICE_ID_FIRST )
+    return resnum - SERMUX_SERVICE_ID_FIRST + NUM_UART;
+  else
+    return resnum;
+}
+#define BUF_CHECK_RESNUM( resid, resnum ) resnum = bufh_check_resnum( resid, resnum )    
+#else
+#define BUF_CHECK_RESNUM( resid, resnum )
+#endif
+
 // Initialize the buffer of the specified resource
 // resid - resource ID (BUF_ID_UART ...)
 // resnum - resource number (0, 1, 2...)
@@ -57,6 +80,7 @@
 // Returns 1 on success, 0 on failure
 int buf_set( unsigned resid, unsigned resnum, u8 logsize, u8 logdsize )
 {
+  BUF_CHECK_RESNUM( resid, resnum );
   BUF_GETPTR( resid, resnum );
   
   pbuf-&gt;logdsize = logdsize;
@@ -76,6 +100,7 @@
 // Marks buffer as empty
 void buf_flush( unsigned resid, unsigned resnum )
 {
+  BUF_CHECK_RESNUM( resid, resnum );
   BUF_GETPTR( resid, resnum );
   
   pbuf-&gt;rptr = pbuf-&gt;wptr = pbuf-&gt;count = 0;
@@ -89,17 +114,21 @@
 // [TODO] maybe add a buffer overflow flag
 int buf_write( unsigned resid, unsigned resnum, t_buf_data *data )
 {
+  BUF_CHECK_RESNUM( resid, resnum );
   BUF_GETPTR( resid, resnum );
   const char* s = ( const char* )data;
   char* d = ( char* )( pbuf-&gt;buf + pbuf-&gt;wptr );
   
+  if( pbuf-&gt;logsize == BUF_SIZE_NONE )
+    return PLATFORM_ERR;    
+  if( pbuf-&gt;count &gt; BUF_REALSIZE( pbuf ) )
+  {
+    fprintf( stderr, &quot;[ERROR] Buffer overflow on resid=%d, resnum=%d!\n&quot;, resid, resnum );
+    return PLATFORM_ERR; 
+  }
   DUFF_DEVICE_8( BUF_REALDSIZE( pbuf ),  *d++ = *s++ );
   
   BUF_MOD_INCR( pbuf, wptr );
-  
-  if( pbuf-&gt;count == BUF_REALSIZE( pbuf ) )
-    BUF_MOD_INCR( pbuf, rptr );
-  else
     pbuf-&gt;count ++;
     
   return PLATFORM_OK;
@@ -110,6 +139,7 @@
 // resnum - resource number (0, 1, 2...)
 int buf_is_enabled( unsigned resid, unsigned resnum )
 {
+  BUF_CHECK_RESNUM( resid, resnum );
   BUF_GETPTR( resid, resnum );
     
   return pbuf-&gt;logsize != BUF_SIZE_NONE;
@@ -118,14 +148,16 @@
 // Return the size of the buffer in number
 unsigned buf_get_size( unsigned resid, unsigned resnum )
 {
+  BUF_CHECK_RESNUM( resid, resnum );
   BUF_GETPTR( resid, resnum );
     
-  return BUF_REALSIZE( pbuf );
+  return pbuf-&gt;logsize == BUF_SIZE_NONE ? 0 : BUF_REALSIZE( pbuf );
 }
 
 // Return the size of the data in the buffer
 unsigned buf_get_count( unsigned resid, unsigned resnum )
 {
+  BUF_CHECK_RESNUM( resid, resnum );
   BUF_GETPTR( resid, resnum );
   
   return READ16( pbuf-&gt;count );  
@@ -140,21 +172,22 @@
 //   PLATFORM_UNDERFLOW on buffer empty
 int buf_read( unsigned resid, unsigned resnum, t_buf_data *data )
 {
+  BUF_CHECK_RESNUM( resid, resnum );
   BUF_GETPTR( resid, resnum );
+
   int old_status;
-  
-  if( READ16( pbuf-&gt;count ) == 0 )
-    return PLATFORM_UNDERFLOW;
-
   const char* s = ( const char* )( pbuf-&gt;buf + pbuf-&gt;rptr );
   char* d = ( char* )data;
   
+  if( pbuf-&gt;logsize == BUF_SIZE_NONE || READ16( pbuf-&gt;count ) == 0 )
+    return PLATFORM_UNDERFLOW;
+ 
   DUFF_DEVICE_8( BUF_REALDSIZE( pbuf ),  *d++ = *s++ );
 
   old_status = platform_cpu_set_global_interrupts( PLATFORM_CPU_DISABLE );
   pbuf-&gt;count --;
+  platform_cpu_set_global_interrupts( old_status );
   BUF_MOD_INCR( pbuf, rptr );
-  platform_cpu_set_global_interrupts( old_status );
   
   return PLATFORM_OK;
 }

Modified: trunk/src/common.c
===================================================================
--- trunk/src/common.c	2011-01-10 00:08:13 UTC (rev 880)
+++ trunk/src/common.c	2011-01-16 00:23:19 UTC (rev 881)
@@ -14,7 +14,9 @@
 #include &quot;term.h&quot;
 #include &quot;xmodem.h&quot;
 #include &quot;elua_int.h&quot;
+#include &quot;sermux.h&quot;
 
+// [TODO] the new builder should automatically do this
 #if defined( BUILD_LUA_INT_HANDLERS ) || defined( BUILD_C_INT_HANDLERS )
 #define BUILD_INT_HANDLERS
 
@@ -26,10 +28,26 @@
 
 #endif // #if defined( BUILD_LUA_INT_HANDLERS ) || defined( BUILD_C_INT_HANDLERS )
 
+// [TODO] the new builder should automatically do this
 #ifndef VTMR_NUM_TIMERS
 #define VTMR_NUM_TIMERS       0
 #endif // #ifndef VTMR_NUM_TIMERS
 
+// [TODO] the new builder should automatically do this
+#ifndef CON_BUF_SIZE
+#define CON_BUF_SIZE          0
+#endif // #ifndef CON_BUF_SIZE
+
+// [TODO] the new builder should automatically do this
+#ifndef SERMUX_FLOW_TYPE
+#define SERMUX_FLOW_TYPE      PLATFORM_UART_FLOW_NONE
+#endif
+
+// [TODO] the new builder should automatically do this
+#ifndef CON_FLOW_TYPE
+#define CON_FLOW_TYPE        PLATFORM_UART_FLOW_NONE
+#endif
+
 // ****************************************************************************
 // XMODEM support code
 
@@ -169,6 +187,27 @@
   platform_int_init();
 #endif
 
+#ifdef BUILD_SERMUX
+  unsigned i;
+  unsigned bufsizes[] = SERMUX_BUFFER_SIZES;  
+
+  // Setup the serial multiplexer
+  platform_uart_setup( SERMUX_PHYS_ID, SERMUX_PHYS_SPEED, 8, PLATFORM_UART_PARITY_NONE, PLATFORM_UART_STOPBITS_1 );
+  platform_uart_set_flow_control( SERMUX_PHYS_ID, SERMUX_FLOW_TYPE );
+  cmn_uart_setup_sermux();
+
+  // Set buffers for all virtual UARTs 
+  for( i = 0; i &lt; sizeof( bufsizes ) / sizeof( unsigned ); i ++ )
+    platform_uart_set_buffer( i + SERMUX_SERVICE_ID_FIRST, bufsizes[ i ] );
+#endif // #ifdef BUILD_SERMUX
+
+#if defined( CON_UART_ID ) &amp;&amp; CON_UART_ID &lt; SERMUX_SERVICE_ID_FIRST
+  // Setup console UART
+  platform_uart_setup( CON_UART_ID, CON_UART_SPEED, 8, PLATFORM_UART_PARITY_NONE, PLATFORM_UART_STOPBITS_1 );  
+  platform_uart_set_flow_control( CON_UART_ID, CON_FLOW_TYPE );
+  platform_uart_set_buffer( CON_UART_ID, CON_BUF_SIZE );
+#endif // #if defined( CON_UART_ID ) &amp;&amp; CON_UART_ID &lt; SERMUX_SERVICE_ID_FIRST
+
   // Set the send/recv functions                          
   std_set_send_func( uart_send );
   std_set_get_func( uart_recv );  
@@ -211,65 +250,7 @@
   #error &quot;You must define either PIO_PINS_PER_PORT of PIO_PIN_ARRAY in platform_conf.h&quot;
 #endif
 }
- 
-// ****************************************************************************
-// UART functions
 
-// The platform UART functions
-int platform_uart_exists( unsigned id )
-{
-  return id &lt; NUM_UART;
-}
-
-// Helper function for buffers
-static int cmn_recv_helper( unsigned id, s32 timeout )
-{
-#ifdef BUF_ENABLE_UART
-  t_buf_data data;
-  
-  if( buf_is_enabled( BUF_ID_UART, id ) )
-  {
-    if( timeout == 0 )
-    {
-      if ( ( buf_read( BUF_ID_UART, id, &amp;data ) ) == PLATFORM_UNDERFLOW )
-        return -1;
-    }
-    else
-    {
-      while( ( buf_read( BUF_ID_UART, id, &amp;data ) ) == PLATFORM_UNDERFLOW );
-    }
-    return ( int )data;
-  }
-  else
-#endif
-  return platform_s_uart_recv( id, timeout );
-}
-
-int platform_uart_recv( unsigned id, unsigned timer_id, s32 timeout )
-{
-  timer_data_type tmr_start, tmr_crt;
-  int res;
-  
-  if( timeout == 0 )
-    return cmn_recv_helper( id, timeout );
-  else if( timeout == PLATFORM_UART_INFINITE_TIMEOUT )
-    return cmn_recv_helper( id, timeout );
-  else
-  {
-    // Receive char with the specified timeout
-    tmr_start = platform_timer_op( timer_id, PLATFORM_TIMER_OP_START, 0 );
-    while( 1 )
-    {
-      if( ( res = cmn_recv_helper( id, 0 ) ) &gt;= 0 )
-        break;
-      tmr_crt = platform_timer_op( timer_id, PLATFORM_TIMER_OP_READ, 0 );
-      if( platform_timer_get_diff_us( timer_id, tmr_crt, tmr_start ) &gt;= timeout )
-        break;
-    }
-    return res;
-  }
-}
-
 // ****************************************************************************
 // CAN functions
 

Modified: trunk/src/common_tmr.c
===================================================================
--- trunk/src/common_tmr.c	2011-01-10 00:08:13 UTC (rev 880)
+++ trunk/src/common_tmr.c	2011-01-16 00:23:19 UTC (rev 881)
@@ -237,7 +237,7 @@
 #ifdef BUILD_INT_HANDLERS
 int platform_timer_set_match_int( unsigned id, u32 period_us, int type )
 {
-#if VTMR_NUM_TIMERS &gt; 0
+#if VTMR_NUM_TIMERS &gt; 0 &amp;&amp; defined( CMN_TIMER_INT_SUPPORT )
   if( TIMER_IS_VIRTUAL( id ) )
     return vtmr_set_match_int( id, period_us, type );
   else
@@ -247,7 +247,7 @@
 
 int cmn_tmr_int_set_status( elua_int_resnum resnum, int status )
 {
-#if VTMR_NUM_TIMERS &gt; 0
+#if VTMR_NUM_TIMERS &gt; 00 &amp;&amp; defined( CMN_TIMER_INT_SUPPORT )
   if( TIMER_IS_VIRTUAL( resnum ) )
     return vtmr_int_set_status( resnum, status );
 #endif
@@ -259,7 +259,7 @@
 
 int cmn_tmr_int_get_status( elua_int_resnum resnum )
 {
-#if VTMR_NUM_TIMERS &gt; 0
+#if VTMR_NUM_TIMERS &gt; 00 &amp;&amp; defined( CMN_TIMER_INT_SUPPORT )
   if( TIMER_IS_VIRTUAL( resnum ) )
     return vtmr_int_get_status( resnum );
 #endif
@@ -271,7 +271,7 @@
 
 int cmn_tmr_int_get_flag( elua_int_resnum resnum, int clear )
 {
-#if VTMR_NUM_TIMERS &gt; 0
+#if VTMR_NUM_TIMERS &gt; 00 &amp;&amp; defined( CMN_TIMER_INT_SUPPORT )
   if( TIMER_IS_VIRTUAL( resnum ) )
     return vtmr_int_get_flag( resnum, clear );
 #endif

Copied: trunk/src/common_uart.c (from rev 880, branches/remotefs_int/src/common_uart.c)
===================================================================
--- trunk/src/common_uart.c	                        (rev 0)
+++ trunk/src/common_uart.c	2011-01-16 00:23:19 UTC (rev 881)
@@ -0,0 +1,218 @@
+// Common implementation: UART functions
+
+#include &quot;common.h&quot;
+#include &quot;platform.h&quot;
+#include &quot;platform_conf.h&quot;
+#include &quot;buf.h&quot;
+#include &quot;elua_int.h&quot;
+#include &quot;sermux.h&quot;
+
+// ****************************************************************************
+// UART functions
+
+#ifdef BUILD_SERMUX
+int uart_service_id_in = -1;
+int uart_service_id_out = -1;
+u8 uart_got_esc = 0;
+int uart_last_sent = -1;
+// [TODO] add interrupt support for virtual UARTs
+#else // #ifdef BUILD_SERMUX
+#define SERMUX_PHYS_ID        ( 0xFFFF )
+#endif // #ifdef BUILD_SERMUX
+
+// The platform UART functions
+int platform_uart_exists( unsigned id )
+{
+#ifdef BUILD_SERMUX
+  return id &lt; NUM_UART || ( id &gt;= SERMUX_SERVICE_ID_FIRST &amp;&amp; id &lt; SERMUX_SERVICE_ID_FIRST + SERMUX_NUM_VUART );
+#else // #ifdef BUILD_SERMUX
+  return id &lt; NUM_UART;
+#endif // #ifdef BUILD_SERMUX
+}
+
+// Helper function for buffers
+static int cmn_recv_helper( unsigned id, s32 timeout )
+{
+#ifdef BUF_ENABLE_UART
+  t_buf_data data;
+  
+  if( buf_is_enabled( BUF_ID_UART, id ) )
+  {
+    if( timeout == 0 )
+    {
+      if ( ( buf_read( BUF_ID_UART, id, &amp;data ) ) == PLATFORM_UNDERFLOW )
+        return -1;
+    }
+    else
+    {
+      while( ( buf_read( BUF_ID_UART, id, &amp;data ) ) == PLATFORM_UNDERFLOW );
+    }
+    return ( int )data;
+  }
+  else
+#endif // #ifdef BUF_ENABLE_UART
+  return platform_s_uart_recv( id, timeout );
+}
+
+int platform_uart_recv( unsigned id, unsigned timer_id, s32 timeout )
+{
+  timer_data_type tmr_start, tmr_crt;
+  int res;
+  
+  if( timeout == 0 )
+    return cmn_recv_helper( id, timeout );
+  else if( timeout == PLATFORM_UART_INFINITE_TIMEOUT )
+    return cmn_recv_helper( id, timeout );
+  else
+  {
+    // Receive char with the specified timeout
+    tmr_start = platform_timer_op( timer_id, PLATFORM_TIMER_OP_START, 0 );
+    while( 1 )
+    {
+      if( ( res = cmn_recv_helper( id, 0 ) ) &gt;= 0 )
+        break;
+      tmr_crt = platform_timer_op( timer_id, PLATFORM_TIMER_OP_READ, 0 );
+      if( platform_timer_get_diff_us( timer_id, tmr_crt, tmr_start ) &gt;= timeout )
+        break;
+    }
+    return res;
+  }
+}
+
+static void cmn_rx_handler( int usart_id, u8 data )
+{
+#ifdef BUILD_SERMUX
+  if( usart_id == SERMUX_PHYS_ID )
+  {
+    if( data != SERMUX_ESCAPE_CHAR )
+    {
+      if( ( data &gt;= SERMUX_SERVICE_ID_FIRST ) &amp;&amp; data &lt; ( SERMUX_SERVICE_ID_FIRST + SERMUX_NUM_VUART ) )
+        uart_service_id_in = data;
+      else if( ( data == SERMUX_FORCE_SID_CHAR ) &amp;&amp; ( uart_last_sent != -1 ) )
+      {
+        // Retransmit service ID and last char
+        platform_s_uart_send( SERMUX_PHYS_ID, uart_service_id_out );
+        if( uart_last_sent &amp; SERMUX_ESC_MASK )
+          platform_s_uart_send( SERMUX_PHYS_ID, SERMUX_ESCAPE_CHAR );
+        platform_s_uart_send( SERMUX_PHYS_ID, uart_last_sent &amp; 0xFF );
+        uart_last_sent = -1;
+      }
+      else
+      {
+        // Check for an escaped char
+        if( uart_got_esc )
+        {
+          data ^= SERMUX_ESCAPE_XOR_MASK;
+          uart_got_esc = 0;
+        }
+        if( uart_service_id_in == -1 ) // request full restransmit if needed
+          platform_s_uart_send( SERMUX_PHYS_ID, SERMUX_FORCE_SID_CHAR );
+        else
+          buf_write( BUF_ID_UART, uart_service_id_in, ( t_buf_data* )&amp;data );
+      }
+    }
+    else
+      uart_got_esc = 1;
+  }
+  else
+#endif // #ifdef BUILD_SERMUX
+  buf_write( BUF_ID_UART, usart_id, ( t_buf_data* )&amp;data );
+}
+
+// Send: version with and without mux
+void platform_uart_send( unsigned id, u8 data ) 
+{
+#ifdef BUILD_SERMUX
+  if( id &gt;= SERMUX_SERVICE_ID_FIRST &amp;&amp; id &lt; SERMUX_SERVICE_ID_FIRST + SERMUX_NUM_VUART )
+  {
+    if( id != uart_service_id_out )
+      platform_s_uart_send( SERMUX_PHYS_ID, id );
+    uart_last_sent = data;
+    if( data == SERMUX_ESCAPE_CHAR || data == SERMUX_FORCE_SID_CHAR || ( data &gt;= SERMUX_SERVICE_ID_FIRST &amp;&amp; data &lt;= SERMUX_SERVICE_ID_LAST ) )
+    {
+      platform_s_uart_send( SERMUX_PHYS_ID, SERMUX_ESCAPE_CHAR );
+      platform_s_uart_send( SERMUX_PHYS_ID, data ^ SERMUX_ESCAPE_XOR_MASK );
+      uart_last_sent = SERMUX_ESC_MASK | ( data ^ SERMUX_ESCAPE_XOR_MASK );
+    }
+    else
+      platform_s_uart_send( SERMUX_PHYS_ID, data );
+    uart_service_id_out = id;
+  }
+  else
+#endif // #ifdef BUILD_SERMUX
+  platform_s_uart_send( id, data );
+}
+
+#ifdef BUF_ENABLE_UART
+static elua_int_c_handler prev_uart_rx_handler;
+
+static void cmn_uart_rx_inthandler( elua_int_resnum resnum )
+{   
+  if( buf_is_enabled( BUF_ID_UART, resnum ) || resnum == SERMUX_PHYS_ID )
+    cmn_rx_handler( resnum, platform_s_uart_recv( resnum, 0 ) );
+  
+  // Chain to previous handler
+  if( prev_uart_rx_handler != NULL )
+    prev_uart_rx_handler( resnum );  
+}
+#endif // #ifdef BUF_ENABLE_UART
+
+int platform_uart_set_buffer( unsigned id, unsigned log2size )
+{
+  if( id == SERMUX_PHYS_ID ) // mere mortals aren't allowed to mess with VUART physical interface buffering
+    return PLATFORM_ERR;
+#ifdef BUF_ENABLE_UART
+  if( log2size == 0 )
+  {
+    if( id &gt;= SERMUX_SERVICE_ID_FIRST ) // Virtual UARTs need buffers no matter what
+      return PLATFORM_ERR; 
+    // Disable buffering
+    buf_set( BUF_ID_UART, id, BUF_SIZE_NONE, BUF_DSIZE_U8 );
+  }  
+  else
+  {
+    // Enable buffering
+    if( buf_set( BUF_ID_UART, id, log2size, BUF_DSIZE_U8 ) == PLATFORM_ERR )
+      return PLATFORM_ERR;
+    if( id &gt;= SERMUX_SERVICE_ID_FIRST ) // No need for aditional setup on virtual UARTs
+      return PLATFORM_OK;    
+    // Enable UART RX interrupt 
+    if( platform_cpu_set_interrupt( INT_UART_RX, id, PLATFORM_CPU_ENABLE ) != PLATFORM_INT_OK )
+      return PLATFORM_ERR;
+    // Setup our C handler
+    if( elua_int_get_c_handler( INT_UART_RX ) != cmn_uart_rx_inthandler )
+      prev_uart_rx_handler = elua_int_set_c_handler( INT_UART_RX, cmn_uart_rx_inthandler );
+  }
+  return PLATFORM_OK;
+#else // BUF_ENABLE_UART
+  return PLATFORM_ERR;
+#endif // BUF_ENABLE_UART
+}
+
+#ifdef BUILD_SERMUX
+// Setup the serial multiplexer
+void cmn_uart_setup_sermux()
+{
+  // Enable UART RX interrupt 
+  if( platform_cpu_set_interrupt( INT_UART_RX, SERMUX_PHYS_ID, PLATFORM_CPU_ENABLE ) == PLATFORM_INT_OK )
+  {
+    // Setup our C handler
+    if( elua_int_get_c_handler( INT_UART_RX ) != cmn_uart_rx_inthandler )
+      prev_uart_rx_handler = elua_int_set_c_handler( INT_UART_RX, cmn_uart_rx_inthandler );
+  }
+  else // We don't have a choice but to get stuck here, as we can't print an error anyway, since the console most likely lives on a virtual UART
+    while( 1 );      
+}
+#endif // #ifdef BUILD_SERMUX
+
+int platform_uart_set_flow_control( unsigned id, int type )
+{ 
+#ifndef PLATFORM_UART_SET_FLOW_CONTROL // the backend does not implement flow control
+  return PLATFORM_ERR;
+#else // #ifndef PLATFORM_UART_SET_FLOW_CONTROL
+  if( id &gt;= SERMUX_SERVICE_ID_FIRST )
+    return PLATFORM_ERR;
+  return platform_s_uart_set_flow_control( id, type );
+#endif // #ifndef PLATFORM_UART_SET_FLOW_CONTROL
+}
+

Copied: trunk/src/eluarpc.c (from rev 880, branches/remotefs_int/src/eluarpc.c)
===================================================================
--- trunk/src/eluarpc.c	                        (rev 0)
+++ trunk/src/eluarpc.c	2011-01-16 00:23:19 UTC (rev 881)
@@ -0,0 +1,359 @@
+// eLua RPC mechanism
+
+#include &lt;string.h&gt;
+#include &lt;stdarg.h&gt;
+#include &lt;stdio.h&gt;
+#include &quot;type.h&quot;
+#include &quot;eluarpc.h&quot;
+#include &quot;rtype.h&quot;
+
+static u8 eluarpc_err_flag;
+
+// *****************************************************************************
+// Internal functions: fdata serialization
+
+static u8 *eluarpc_write_u8( u8 *p, u8 fdata )
+{
+  *p ++ = TYPE_INT_8;
+  *p ++ = fdata;
+  return p;  
+}
+
+static u8* eluarpc_write_op_id( u8 *p, u8 fdata )
+{
+  *p ++ = TYPE_OP_ID;
+  *p ++ = fdata;
+  return p;    
+}
+
+static u8 *eluarpc_write_u16( u8 *p, u16 fdata )
+{
+  *p ++ = TYPE_INT_16;
+  *p ++ = fdata &amp; 0xFF;
+  *p ++ = ( fdata &gt;&gt; 8 ) &amp; 0xFF;
+  return p;    
+}
+
+static u8 *eluarpc_write_u32( u8 *p, u32 fdata )
+{
+  *p ++ = TYPE_INT_32;
+  *p ++ = fdata &amp; 0xFF;
+  *p ++ = ( fdata &gt;&gt; 8 ) &amp; 0xFF;
+  *p ++ = ( fdata &gt;&gt; 16 ) &amp; 0xFF;
+  *p ++ = ( fdata &gt;&gt; 24 ) &amp; 0xFF;
+  return p;        
+}
+
+static u8 *eluarpc_write_ptr( u8 *p, const void* src, u32 srclen )
+{
+  *p ++ = TYPE_PTR;
+  p = eluarpc_write_u32( p, srclen );
+  if( src )
+    memcpy( p, src, srclen );
+  return p + srclen;    
+}
+
+static u8 *eluarpc_write_small_ptr( u8 *p, const void* src, u16 srclen )
+{
+  *p ++ = TYPE_SMALL_PTR;
+  p = eluarpc_write_u16( p, srclen );
+  if( src )
+    memcpy( p, src, srclen );
+  return p + srclen;    
+}
+
+// *****************************************************************************
+// Internal functions: fdata deserialization
+
+static const u8* eluarpc_read_expect( const u8 *p, u8 fdata )
+{
+  if( *p ++ != fdata )
+    eluarpc_err_flag = ELUARPC_ERR;
+  return p;
+}
+
+static const u8 *eluarpc_read_u8( const u8 *p, u8 *pfdata )
+{
+  p = eluarpc_read_expect( p, TYPE_INT_8 );
+  *pfdata = *p ++;
+  return p;  
+}
+
+static const u8 *eluarpc_read_op_id( const u8 *p, u8 *pfdata )
+{
+  p = eluarpc_read_expect( p, TYPE_OP_ID );
+  *pfdata = *p ++;
+  return p;  
+}
+
+static const u8* eluarpc_expect_op_id( const u8 *p, u8 id )
+{
+  u8 temp;
+  
+  p = eluarpc_read_expect( p, TYPE_OP_ID );
+  temp = *p ++;
+  if( temp != id )
+    eluarpc_err_flag = ELUARPC_ERR;
+  return p;
+}
+
+static const u8 *eluarpc_read_u16( const u8 *p, u16 *pfdata )
+{
+  p = eluarpc_read_expect( p, TYPE_INT_16 );
+  *pfdata = *p ++;
+  *pfdata |= ( u32 )( *p ++ ) &lt;&lt; 8;  
+  return p;    
+}
+
+static const u8 *eluarpc_read_u32( const u8 *p, u32 *pfdata )
+{
+  p = eluarpc_read_expect( p, TYPE_INT_32 );
+  *pfdata = *p ++;                         
+  *pfdata |= ( u32 )( *p ++ ) &lt;&lt; 8;
+  *pfdata |= ( u32 )( *p ++ ) &lt;&lt; 16;
+  *pfdata |= ( u32 )( *p ++ ) &lt;&lt; 24;      
+  return p;        
+}
+
+static const u8 *eluarpc_read_ptr( const u8 *p, void* src, u32 *psrclen )
+{                                         
+  p = eluarpc_read_expect( p, TYPE_PTR );
+  p = eluarpc_read_u32( p, psrclen );
+  if( src &amp;&amp; p )
+    memcpy( src, p, *psrclen );
+  return p + *psrclen;    
+}
+
+static const u8 *eluarpc_read_small_ptr( const u8 *p, void* src, u16 *psrclen )
+{                                         
+  p = eluarpc_read_expect( p, TYPE_SMALL_PTR );
+  p = eluarpc_read_u16( p, psrclen );
+  if( src &amp;&amp; p )
+    memcpy( src, p, *psrclen );
+  return p + *psrclen;    
+}
+
+
+// *****************************************************************************
+// Internal functions: packet handling (read and write)
+
+static u8* eluarpc_packet_ptr;
+
+static u8* eluarpc_start_packet( u8 *p )
+{
+  eluarpc_packet_ptr = p;
+  p += ELUARPC_START_OFFSET;
+  *p ++ = TYPE_START;
+  p = eluarpc_write_u32( p, PACKET_SIG );
+  return p;
+}
+
+static u8* eluarpc_end_packet( u8 *p )
+{
+  u16 len;
+  
+  *p ++ = TYPE_END;
+  p = eluarpc_write_u32( p, ~PACKET_SIG );
+  len = p - eluarpc_packet_ptr;
+  p = eluarpc_packet_ptr;
+  *p ++ = TYPE_PKT_SIZE;
+  eluarpc_write_u16( p, len );  
+  return p;  
+}
+
+static const u8* eluarpc_match_packet_start( const u8 *p )
+{
+  u32 fdata;
+  
+  p += ELUARPC_START_OFFSET;
+  p = eluarpc_read_expect( p, TYPE_START );
+  p = eluarpc_read_u32( p, &amp;fdata );
+  if( fdata != PACKET_SIG )
+    eluarpc_err_flag = ELUARPC_ERR;
+  return p;
+}
+
+static const u8* eluarpc_match_packet_end( const u8 *p )
+{
+  u32 fdata;
+  
+  p = eluarpc_read_expect( p, TYPE_END );
+  p = eluarpc_read_u32( p, &amp;fdata );
+  if( fdata != ~PACKET_SIG )
+    eluarpc_err_flag = ELUARPC_ERR;
+  return p;
+}
+
+// *****************************************************************************
+// Function serialization and deserialization
+
+int eluarpc_get_request_id( const u8 *p, u8 *pid )
+{ 
+  eluarpc_err_flag = ELUARPC_OK;
+  p = eluarpc_match_packet_start( p );
+  p = eluarpc_read_op_id( p, pid );
+  return eluarpc_err_flag;
+}
+
+u32 eluarpc_replace_flag( u32 val, u32 origflag, u32 newflag )
+{
+  return ( val &amp; origflag ) ? newflag : 0; 
+}
+
+int eluarpc_get_packet_size( const u8 *p, u16 *psize )
+{
+  eluarpc_err_flag = ELUARPC_OK;
+  p = eluarpc_read_expect( p, TYPE_PKT_SIZE );
+  p = eluarpc_read_u16( p, psize );
+  return eluarpc_err_flag;
+}
+
+// Generic write function
+// Specifiers: o - operation
+//             r - response
+//             c - u8
+//             h - u16
+//             l - u32
+//             i - int
+//             L - s32
+//             p - ptr (given as ptr, len, len is an u32)
+//             P - ptr (given as ptr, len, len is an u16)
+void eluarpc_gen_write( u8 *p, const char *fmt, ... )
+{
+  va_list ap;
+  const void *ptr;
+  u32 ptrlen;
+  
+  va_start( ap, fmt );
+  p = eluarpc_start_packet( p );
+  while( *fmt )
+    switch( *fmt ++ )
+    {
+      case 'o':
+        p = eluarpc_write_op_id( p, va_arg( ap, int ) );
+        break;
+        
+      case 'r':
+        *p++ = ELUARPC_OP_RES_MOD | ( u8 )va_arg( ap, int );
+        break;
+        
+      case 'c':
+        p = eluarpc_write_u8( p, ( u8 )va_arg( ap, int ) );
+        break;
+        
+      case 'h':
+        p = eluarpc_write_u16( p, ( u16 )va_arg( ap, int ) );
+        break;
+
+      case 'i':
+        p = eluarpc_write_u32( p, ( u32 )va_arg( ap, int ) );
+        break;
+        
+      case 'l':
+        p = eluarpc_write_u32( p, ( u32 )va_arg( ap, u32 ) );
+        break;
+
+      case 'L':
+        p = eluarpc_write_u32( p, ( u32 )va_arg( ap, s32 ) );
+        break;         
+      
+      case 'p':
+        ptr = va_arg( ap, void* );
+        ptrlen = ( u32 )va_arg( ap, u32 );
+        p = eluarpc_write_ptr( p, ptr, ptrlen );
+        break;
+        
+      case 'P':
+        ptr = va_arg( ap, void * );
+        ptrlen = ( u16 )va_arg( ap, int );
+        p = eluarpc_write_small_ptr( p, ptr, ptrlen );
+        break;        
+    }
+  eluarpc_end_packet( p );
+}
+
+// Generic read function
+// Specifiers: o - operation
+//             r - response
+//             c - u8
+//             h - u16
+//             l - u32
+//             L - s32
+//             i - int
+//             p - ptr (returned as ptr, len, len is an u32)
+//             P - ptr (returned as ptr, len, len is an u16)
+int eluarpc_gen_read( const u8 *p, const char *fmt, ... )
+{
+  va_list ap;
+  const void *pptr;
+  u32 *ptrlen;
+  const u8 *tempptr;
+  u32 temp32;
+  u16 temp16;
+  u16 *sptrlen;
+  
+  va_start( ap, fmt );
+  eluarpc_err_flag = ELUARPC_OK;
+  p = eluarpc_match_packet_start( p );
+  while( *fmt )
+    switch( *fmt ++ )
+    {
+      case 'o':
+        p = eluarpc_expect_op_id( p, va_arg( ap, int ) );
+        break;
+        
+      case 'r':
+        p = eluarpc_read_expect( p, ELUARPC_OP_RES_MOD | ( u8 )va_arg( ap, int ) );
+        break;
+        
+      case 'c':
+        p = eluarpc_read_u8( p, ( u8* )va_arg( ap, void * ) );
+        break;
+        
+      case 'h':
+        p = eluarpc_read_u16( p, ( u16* )va_arg( ap, void * ) );
+        break;
+        
+      case 'l':
+        p = eluarpc_read_u32( p, ( u32* )va_arg( ap, void * ) );
+        break;     
+
+      case 'L':
+        p = eluarpc_read_u32( p, &amp;temp32 );        
+        *( s32 *)va_arg( ap, void * ) = ( s32 )temp32;
+        break;     
+        
+      case 'i':
+        p = eluarpc_read_u32( p, &amp;temp32 );
+        *( int* )va_arg( ap, void * ) = ( int )temp32;        
+        break;     
+      
+      case 'p':
+        pptr = va_arg( ap, void** );
+        ptrlen = ( u32* )va_arg( ap, void* );
+        tempptr = p;
+        p = eluarpc_read_ptr( p, NULL, &amp;temp32 );
+        if( p == tempptr + ELUARPC_PTR_HEADER_SIZE )
+          *( const u8** )pptr = NULL;
+        else
+          *( const u8** )pptr = tempptr + ELUARPC_PTR_HEADER_SIZE;
+        if( ptrlen )
+          *ptrlen = temp32;        
+        break;
+        
+      case 'P':
+        pptr = va_arg( ap, void** );
+        sptrlen = ( u16* )va_arg( ap, void* );
+        tempptr = p;
+        p = eluarpc_read_small_ptr( p, NULL, &amp;temp16 );
+        if( p == tempptr + ELUARPC_SMALL_PTR_HEADER_SIZE )
+          *( const u8** )pptr = NULL;
+        else
+          *( const u8** )pptr = tempptr + ELUARPC_SMALL_PTR_HEADER_SIZE;
+        if( sptrlen )
+          *sptrlen = temp16;        
+        break;        
+    }
+  eluarpc_match_packet_end( p );  
+  return eluarpc_err_flag;
+}

Modified: trunk/src/modules/tmr.c
===================================================================
--- trunk/src/modules/tmr.c	2011-01-10 00:08:13 UTC (rev 880)
+++ trunk/src/modules/tmr.c	2011-01-16 00:23:19 UTC (rev 881)
@@ -13,6 +13,7 @@
 #include &lt;string.h&gt;
 
 #define MAX_VTIMER_NAME_LEN     6
+#define MIN_VTIMER_NAME_LEN     5
 
 // Helper function for the read/start functions
 static int tmrh_timer_op( lua_State* L, int op )
@@ -147,7 +148,7 @@
   char* pend;
   long res;
   
-  if( strlen( key ) &gt; MAX_VTIMER_NAME_LEN || strlen( key ) &lt; 5 )
+  if( strlen( key ) &gt; MAX_VTIMER_NAME_LEN || strlen( key ) &lt; MIN_VTIMER_NAME_LEN )
     return 0;
   if( strncmp( key, &quot;VIRT&quot;, 4 ) )
     return 0;  

Modified: trunk/src/modules/uart.c
===================================================================
--- trunk/src/modules/uart.c	2011-01-10 00:08:13 UTC (rev 880)
+++ trunk/src/modules/uart.c	2011-01-16 00:23:19 UTC (rev 881)
@@ -6,8 +6,12 @@
 #include &quot;platform.h&quot;
 #include &quot;auxmods.h&quot;
 #include &quot;lrotable.h&quot;
+#include &quot;common.h&quot;
+#include &quot;sermux.h&quot;
 #include &lt;string.h&gt;
 #include &lt;ctype.h&gt;
+#include &lt;stdlib.h&gt;
+#include &quot;platform_conf.h&quot;
 
 // Modes for the UART read function
 enum
@@ -26,6 +30,8 @@
   
   id = luaL_checkinteger( L, 1 );
   MOD_CHECK_ID( uart, id );
+  if( id &gt;= SERMUX_SERVICE_ID_FIRST )
+    return luaL_error( L, &quot;uart.setup can't be called on virtual UARTs&quot; );
   baud = luaL_checkinteger( L, 2 );
   databits = luaL_checkinteger( L, 3 );
   parity = luaL_checkinteger( L, 4 );
@@ -64,6 +70,7 @@
   }
   return 0;
 }
+
 static int uart_read( lua_State* L )
 {
   int id, res, mode, issign;
@@ -115,6 +122,8 @@
     cres = ( char )res;
     count ++;
     issign = ( count == 1 ) &amp;&amp; ( ( res == '-' ) || ( res == '+' ) );
+    // [TODO] this only works for lines that actually end with '\n', other line endings
+    // are not supported.
     if( ( cres == '\n' ) &amp;&amp; ( mode == UART_READ_MODE_LINE ) )
       break;
     if( !isdigit( cres ) &amp;&amp; !issign &amp;&amp; ( mode == UART_READ_MODE_NUMBER ) )
@@ -168,6 +177,62 @@
   return 1;  
 }
 
+
+// Lua: uart.set_buffer( id, size )
+static int uart_set_buffer( lua_State *L )
+{
+  int id = luaL_checkinteger( L, 1 );
+  u32 size = ( u32 )luaL_checkinteger( L, 2 );
+  
+  MOD_CHECK_ID( uart, id );
+  if( size &amp;&amp; ( size &amp; ( size - 1 ) ) )
+    return luaL_error( L, &quot;the buffer size must be a power of 2 or 0&quot; );
+  if( size == 0 &amp;&amp; id &gt;= SERMUX_SERVICE_ID_FIRST )
+    return luaL_error( L, &quot;disabling buffers on virtual UARTs is not allowed&quot; );
+  if( platform_uart_set_buffer( id, intlog2( size ) ) == PLATFORM_ERR )
+    return luaL_error( L, &quot;unable to set UART buffer&quot; );
+  return 0;
+}
+
+// Lua: uart.set_flow_control( id, type )
+static int uart_set_flow_control( lua_State *L )
+{
+  int id = luaL_checkinteger( L, 1 );
+  int type = luaL_checkinteger( L, 2 );
+
+  MOD_CHECK_ID( uart, id );
+  if( platform_uart_set_flow_control( id, type ) != PLATFORM_OK )
+    return luaL_error( L, &quot;unable to set the flow control on interface %d&quot;, id );
+  return 0;
+}
+
+#ifdef BUILD_SERMUX
+
+#define MAX_VUART_NAME_LEN    6
+#define MIN_VUART_NAME_LEN    6
+
+// __index metafunction for UART
+// Look for all VUARTx timer identifiers
+static int uart_mt_index( lua_State* L )
+{
+  const char *key = luaL_checkstring( L ,2 );
+  char* pend;
+  long res;
+  
+  if( strlen( key ) &gt; MAX_VUART_NAME_LEN || strlen( key ) &lt; MIN_VUART_NAME_LEN )
+    return 0;
+  if( strncmp( key, &quot;VUART&quot;, 5 ) )
+    return 0;  
+  res = strtol( key + 5, &amp;pend, 10 );
+  if( *pend != '\0' )
+    return 0;
+  if( res &gt;= SERMUX_NUM_VUART )
+    return 0;
+  lua_pushinteger( L, SERMUX_SERVICE_ID_FIRST + res );
+  return 1;
+}
+#endif // #ifdef BUILD_SERMUX
+
 // Module function map
 #define MIN_OPT_LEVEL   2
 #include &quot;lrodefs.h&quot;
@@ -177,6 +242,8 @@
   { LSTRKEY( &quot;write&quot; ), LFUNCVAL( uart_write ) },
   { LSTRKEY( &quot;read&quot; ), LFUNCVAL( uart_read ) },
   { LSTRKEY( &quot;getchar&quot; ), LFUNCVAL( uart_getchar ) },
+  { LSTRKEY( &quot;set_buffer&quot; ), LFUNCVAL( uart_set_buffer ) },
+  { LSTRKEY( &quot;set_flow_control&quot; ), LFUNCVAL( uart_set_flow_control ) },
 #if LUA_OPTIMIZE_MEMORY &gt; 0
   { LSTRKEY( &quot;PAR_EVEN&quot; ), LNUMVAL( PLATFORM_UART_PARITY_EVEN ) },
   { LSTRKEY( &quot;PAR_ODD&quot; ), LNUMVAL( PLATFORM_UART_PARITY_ODD ) },
@@ -186,7 +253,14 @@
   { LSTRKEY( &quot;STOP_2&quot; ), LNUMVAL( PLATFORM_UART_STOPBITS_2 ) },
   { LSTRKEY( &quot;NO_TIMEOUT&quot; ), LNUMVAL( 0 ) },
   { LSTRKEY( &quot;INF_TIMEOUT&quot; ), LNUMVAL( PLATFORM_UART_INFINITE_TIMEOUT ) },
+  { LSTRKEY( &quot;FLOW_NONE&quot; ), LNUMVAL( PLATFORM_UART_FLOW_NONE ) },
+  { LSTRKEY( &quot;FLOW_RTS&quot; ), LNUMVAL( PLATFORM_UART_FLOW_RTS ) },
+  { LSTRKEY( &quot;FLOW_CTS&quot; ), LNUMVAL( PLATFORM_UART_FLOW_CTS ) },
 #endif
+#if LUA_OPTIMIZE_MEMORY &gt; 0 &amp;&amp; defined( BUILD_SERMUX )
+  { LSTRKEY( &quot;__metatable&quot; ), LROVAL( uart_map ) },
+  { LSTRKEY( &quot;__index&quot; ), LFUNCVAL( uart_mt_index ) },  
+#endif
   { LNILKEY, LNILVAL }
 };
 
@@ -208,7 +282,12 @@
   // Add the &quot;none&quot; and &quot;infinite&quot; constant used in recv()
   MOD_REG_NUMBER( L, &quot;NO_TIMEOUT&quot;, 0 );
   MOD_REG_NUMBER( L, &quot;INF_TIMEOUT&quot;, PLATFORM_UART_INFINITE_TIMEOUT );
+
+  // Add the UART flow constants
+  MOD_REG_NUMBER( L, &quot;FLOW_RTS&quot;, PLATFORM_UART_FLOW_RTS );
+  MOD_REG_NUMBER( L, &quot;FLOW_CTS&quot;, PLATFORM_UART_FLOW_CTS );
   
   return 1;
 #endif // #if LUA_OPTIMIZE_MEMORY &gt; 0
 }
+

Modified: trunk/src/platform/at91sam7x/conf.py
===================================================================
--- trunk/src/platform/at91sam7x/conf.py	2011-01-10 00:08:13 UTC (rev 880)
+++ trunk/src/platform/at91sam7x/conf.py	2011-01-16 00:23:19 UTC (rev 881)
@@ -2,7 +2,7 @@
 
 cpumode = ARGUMENTS.get( 'cpumode', 'thumb' ).lower()
 
-specific_files = &quot;board_cstartup.s board_lowlevel.c board_memories.c usart.c pmc.c pio.c platform.c tc.c pwmc.c aic.c&quot;
+specific_files = &quot;board_cstartup.s board_lowlevel.c board_memories.c usart.c pmc.c pio.c platform.c tc.c pwmc.c aic.c platform_int.c&quot;
 if comp[ 'cpu' ] == 'AT91SAM7X256':
   ldscript = &quot;flash256.lds&quot;
   comp.Append(CPPDEFINES = 'at91sam7x256')

Modified: trunk/src/platform/at91sam7x/platform.c
===================================================================
--- trunk/src/platform/at91sam7x/platform.c	2011-01-10 00:08:13 UTC (rev 880)
+++ trunk/src/platform/at91sam7x/platform.c	2011-01-16 00:23:19 UTC (rev 881)
@@ -56,29 +56,10 @@
 }
 #endif
 
-// Buffered UART support
-#ifdef BUF_ENABLE_UART
-static volatile u32 c;
-static AT91S_USART* pbase = CON_UART_ID == 0 ? AT91C_BASE_US0 : AT91C_BASE_US1;      
-void __uart_rx_handler_helper()
-{
-  c = pbase-&gt;US_CSR;
-  c = pbase-&gt;US_RHR;
-  buf_write( BUF_ID_UART, CON_UART_ID, ( t_buf_data* )&amp;c );
-}
-
-static void __attribute__((naked)) uart_rx_handler()
-{
-  INT_STUB( __uart_rx_handler_helper );
-}
-#endif
-
 int platform_init()
 {
   int i;
    
-  unsigned int mode = AT91C_US_USMODE_NORMAL | AT91C_US_CLKS_CLOCK | AT91C_US_CHRL_8_BITS | 
-      AT91C_US_PAR_NONE | AT91C_US_NBSTOP_1_BIT | AT91C_US_CHMODE_NORMAL;
   // Enable the peripherals we use in the PMC
   PMC_EnablePeripheral( AT91C_ID_US0 );  
   PMC_EnablePeripheral( AT91C_ID_US1 );
@@ -87,28 +68,8 @@
   PMC_EnablePeripheral( AT91C_ID_TC0 );
   PMC_EnablePeripheral( AT91C_ID_TC1 );
   PMC_EnablePeripheral( AT91C_ID_TC2 );
-  PMC_EnablePeripheral( AT91C_ID_PWMC );
+  PMC_EnablePeripheral( AT91C_ID_PWMC );  
   
-  // Configure pins
-  PIO_Configure( platform_uart_pins[ CON_UART_ID ], PIO_LISTSIZE( platform_uart_pins[ CON_UART_ID ] ) );
-    
-  // Configure the USART in the desired mode @115200 bauds
-  AT91S_USART *pusart = CON_UART_ID == 0 ? AT91C_BASE_US0 : AT91C_BASE_US1;
-  USART_Configure( pusart, mode, CON_UART_SPEED, BOARD_MCK );  
-  // Enable receiver &amp; transmitter
-  USART_SetTransmitterEnabled( pusart, 1 );
-  USART_SetReceiverEnabled( pusart, 1 );  
-#if defined( BUF_ENABLE_UART ) &amp;&amp; defined( CON_BUF_SIZE )
-  // Enable buffering on the console UART
-  buf_set( BUF_ID_UART, CON_UART_ID, CON_BUF_SIZE, BUF_DSIZE_U8 );
-  // Set interrupt handler and interrupt flag on UART
-  unsigned uart_id = CON_UART_ID == 0 ? AT91C_ID_US0 : AT91C_ID_US1;
-  AIC_DisableIT( uart_id );
-  AIC_ConfigureIT( uart_id, 0, uart_rx_handler );
-  pusart-&gt;US_IER = AT91C_US_RXRDY;
-  AIC_EnableIT( uart_id );  
-#endif  
-  
   // Configure the timers
   AT91C_BASE_TCB-&gt;TCB_BMR = 0x15;
   for( i = 0; i &lt; 3; i ++ )
@@ -260,7 +221,7 @@
   return baud;
 }
 
-void platform_uart_send( unsigned id, u8 data )
+void platform_s_uart_send( unsigned id, u8 data )
 {
   AT91S_USART* base = id == 0 ? AT91C_BASE_US0 : AT91C_BASE_US1;  
   

Modified: trunk/src/platform/at91sam7x/platform_conf.h
===================================================================
--- trunk/src/platform/at91sam7x/platform_conf.h	2011-01-10 00:08:13 UTC (rev 880)
+++ trunk/src/platform/at91sam7x/platform_conf.h	2011-01-16 00:23:19 UTC (rev 881)
@@ -6,6 +6,9 @@
 #include &quot;auxmods.h&quot;
 #include &quot;board.h&quot;
 #include &quot;stacks.h&quot;
+#include &quot;buf.h&quot;
+#include &quot;elua_int.h&quot;
+#include &quot;sermux.h&quot;
 
 // *****************************************************************************
 // Define here what components you want for this platform
@@ -16,11 +19,15 @@
 #define BUILD_TERM
 #define BUILD_CON_GENERIC
 //#define BUILD_RPC
+#define BUILD_RFS
+#define BUILD_SERMUX
+#define BUILD_C_INT_HANDLERS
 
 // *****************************************************************************
 // UART/Timer IDs configuration data (used in main.c)
 
-#define CON_UART_ID           0
+#define CON_UART_ID         ( SERMUX_SERVICE_ID_FIRST + 1 )
+//#define CON_UART_ID         0
 #define CON_UART_SPEED        115200
 #define CON_TIMER_ID          0
 #define TERM_LINES            25
@@ -104,4 +111,22 @@
 #define MEM_START_ADDRESS     { ( void* )end }
 #define MEM_END_ADDRESS       { ( void* )( SRAM_ORIGIN + SRAM_SIZE - STACK_SIZE_TOTAL - 1 ) }
 
+#define RFS_BUFFER_SIZE       BUF_SIZE_512
+#define RFS_UART_ID           ( SERMUX_SERVICE_ID_FIRST )
+#define RFS_TIMER_ID          0
+#define RFS_TIMEOUT           100000
+#define RFS_UART_SPEED        115200
+
+#define SERMUX_PHYS_ID        0
+#define SERMUX_PHYS_SPEED     115200
+#define SERMUX_NUM_VUART      2
+#define SERMUX_BUFFER_SIZES   { RFS_BUFFER_SIZE, CON_BUF_SIZE }
+
+// Interrupt list
+#define INT_UART_RX           ELUA_INT_FIRST_ID
+#define INT_ELUA_LAST         INT_UART_RX
+
+#define PLATFORM_CPU_CONSTANTS\
+ _C( INT_UART_RX )
+
 #endif // #ifndef __PLATFORM_CONF_H__

Copied: trunk/src/platform/at91sam7x/platform_int.c (from rev 880, branches/remotefs_int/src/platform/at91sam7x/platform_int.c)
===================================================================
--- trunk/src/platform/at91sam7x/platform_int.c	                        (rev 0)
+++ trunk/src/platform/at91sam7x/platform_int.c	2011-01-16 00:23:19 UTC (rev 881)
@@ -0,0 +1,117 @@
+// AVR32 interrupt support
+
+#include &quot;platform_conf.h&quot;
+#if defined( BUILD_C_INT_HANDLERS ) || defined( BUILD_LUA_INT_HANDLERS )
+
+// Generic headers
+#include &quot;platform.h&quot;
+#include &quot;elua_int.h&quot;
+#include &quot;common.h&quot;
+
+// Platform includes
+#include &quot;aic.h&quot;
+#include &lt;board.h&gt;
+
+// &quot;Stubs&quot; used for our interrupt handlers
+// Just a trick to avoid interworking and some other complications
+
+#define INT_STUB( func )\
+  asm volatile(\
+  &quot;push {lr}\n\t&quot;\
+  &quot;bl   &quot; #func &quot;\n\t&quot;\
+  &quot;pop  {r0}\n\t&quot;\
+  &quot;bx   r0\n\t&quot;\
+ )\
+ 
+// ****************************************************************************
+// Interrupt handlers
+
+// ----------------------------------------------------------------------------
+// UART_RX interrupt
+
+static const int usart_int_ids[] = { AT91C_ID_US0, AT91C_ID_US1 };
+static AT91S_USART* const usart_bases[] = { AT91C_BASE_US0, AT91C_BASE_US1 };
+ 
+static void uart_common_rx_handler( int resnum )
+{
+  cmn_int_handler( INT_UART_RX, resnum );
+  AT91C_BASE_AIC-&gt;AIC_ICCR = 1 &lt;&lt; usart_int_ids[ resnum ];
+  AT91C_BASE_AIC-&gt;AIC_EOICR = 0;
+}
+
+void __uart0_rx_handler_helper()
+{
+  uart_common_rx_handler( 0 );
+}
+
+static void __attribute__((naked)) uart0_rx_handler()
+{
+  INT_STUB( __uart0_rx_handler_helper );
+}
+
+void __uart1_rx_handler_helper()
+{
+  uart_common_rx_handler( 1 );
+}
+
+static void __attribute__((naked)) uart1_rx_handler()
+{
+  INT_STUB( __uart1_rx_handler_helper );
+}
+
+// ****************************************************************************
+// Interrupt: INT_UART_RX
+
+static int int_uart_rx_get_status( elua_int_resnum resnum )
+{
+  volatile AT91S_USART *pusart = ( volatile AT91S_USART* )usart_bases[ resnum ];
+  return ( pusart-&gt;US_IMR &amp; AT91C_US_RXRDY ) ? 1 : 0;
+}
+
+static int int_uart_rx_set_status( elua_int_resnum resnum, int status )
+{
+  volatile AT91S_USART *pusart = ( volatile AT91S_USART* )usart_bases[ resnum ];
+  int prev = int_uart_rx_get_status( resnum );
+  
+  if( status == PLATFORM_CPU_ENABLE )      
+    pusart-&gt;US_IER = AT91C_US_RXRDY;
+  else
+    pusart-&gt;US_IDR = AT91C_US_RXRDY;    
+  return prev;
+}
+
+static int int_uart_rx_get_flag( elua_int_resnum resnum, int clear )
+{
+  volatile AT91S_USART *pusart = ( volatile AT91S_USART* )usart_bases[ resnum ];
+
+  ( void )clear; // Note: this interrupt will be cleared automatically when the RHR is read
+  return( pusart-&gt;US_CSR &amp; AT91C_US_RXRDY ) ? 1 : 0;    
+}
+
+// ****************************************************************************
+// Interrupt initialization
+
+typedef void ( *phandler )();
+static phandler phandlers[] = { uart0_rx_handler, uart1_rx_handler };
+
+void platform_int_init()
+{
+  unsigned i;
+  
+  for( i = 0; i &lt; NUM_UART; i ++ )
+  {
+    AIC_ConfigureIT( usart_int_ids[ i ], 0, phandlers[ i ] ); 
+    AIC_EnableIT( usart_int_ids[ i ] );
+  }  
+}
+
+// ****************************************************************************
+// Interrupt table
+// Must have a 1-to-1 correspondence with the interrupt enum in platform_conf.h!
+
+const elua_int_descriptor elua_int_table[ INT_ELUA_LAST ] = 
+{
+  { int_uart_rx_set_status, int_uart_rx_get_status, int_uart_rx_get_flag }
+};
+
+#endif // #if defined( BUILD_C_INT_HANDLERS ) || defined( BUILD_LUA_INT_HANDLERS )

Modified: trunk/src/platform/avr32/EVK1100/evk1100_conf.h
===================================================================
--- trunk/src/platform/avr32/EVK1100/evk1100_conf.h	2011-01-10 00:08:13 UTC (rev 880)
+++ trunk/src/platform/avr32/EVK1100/evk1100_conf.h	2011-01-16 00:23:19 UTC (rev 881)
@@ -4,6 +4,8 @@
 #define __EVK1100_CONF_H__
 
 #include &quot;sdramc.h&quot;
+#include &quot;sermux.h&quot;
+#include &quot;buf.h&quot;
 
 // *****************************************************************************
 // Define here what components you want for this platform
@@ -15,11 +17,16 @@
 #define BUILD_TERM
 #define BUILD_CON_GENERIC
 //#define BUILD_RPC
+#define BUILD_C_INT_HANDLERS
+#define BUILA_LUA_INT_HANDLERS
+#define BUILD_RFS
+#define BUILD_SERMUX
 
 // *****************************************************************************
 // UART/Timer IDs configuration data (used in main.c)
 
-#define CON_UART_ID         0
+#define CON_UART_ID         ( SERMUX_SERVICE_ID_FIRST + 1 )
+//#define CON_UART_ID         0
 #define CON_UART_SPEED      115200
 #define CON_TIMER_ID        0
 #define TERM_LINES          25
@@ -101,8 +108,6 @@
 // Enable RX buffering on UART
 #define BUF_ENABLE_UART
 #define CON_BUF_SIZE          BUF_SIZE_128
-// REMEMBER to change next line if buffering is enabled and CON_UART_ID is not 0!
-#define CON_UART_IRQ          AVR32_USART0_IRQ
 
 // SD/MMC Filesystem Setup
 #define MMCFS_TICK_HZ     10
@@ -127,6 +132,24 @@
 #define MEM_START_ADDRESS     { ( void* )end, ( void* )SDRAM }
 #define MEM_END_ADDRESS       { ( void* )( 0x10000 - STACK_SIZE_TOTAL - 1 ), ( void* )( SDRAM + SDRAM_SIZE - 1 ) }
 
+#define RFS_BUFFER_SIZE       BUF_SIZE_512
+#define RFS_UART_ID           ( SERMUX_SERVICE_ID_FIRST )
+#define RFS_TIMER_ID          0
+#define RFS_TIMEOUT           100000
+#define RFS_UART_SPEED        115200
+
+#define SERMUX_PHYS_ID        0
+#define SERMUX_PHYS_SPEED     115200
+#define SERMUX_NUM_VUART      2
+#define SERMUX_BUFFER_SIZES   { RFS_BUFFER_SIZE, CON_BUF_SIZE }
+
+// Interrupt list
+#define INT_UART_RX           ELUA_INT_FIRST_ID
+#define INT_ELUA_LAST         INT_UART_RX
+
+#define PLATFORM_CPU_CONSTANTS\
+ _C( INT_UART_RX )
+
 // *****************************************************************************
 // CPU constants that should be exposed to the eLua &quot;cpu&quot; module
 

Modified: trunk/src/platform/avr32/EVK1101/evk1101_conf.h
===================================================================
--- trunk/src/platform/avr32/EVK1101/evk1101_conf.h	2011-01-10 00:08:13 UTC (rev 880)
+++ trunk/src/platform/avr32/EVK1101/evk1101_conf.h	2011-01-16 00:23:19 UTC (rev 881)
@@ -13,6 +13,7 @@
 #define BUILD_TERM
 #define BUILD_CON_GENERIC
 //#define BUILD_RPC
+#define BUILD_C_INT_HANDLERS
 
 // *****************************************************************************
 // UART/Timer IDs configuration data (used in main.c)
@@ -89,8 +90,6 @@
 // Enable RX buffering on UART
 #define BUF_ENABLE_UART
 #define CON_BUF_SIZE          BUF_SIZE_128
-// REMEMBER to change next line if buffering is enabled and CON_UART_ID is not 0!
-#define CON_UART_IRQ          AVR32_USART1_IRQ
 
 // SD/MMC Filesystem Setup
 #define MMCFS_TICK_HZ     10
@@ -115,7 +114,13 @@
 #define MEM_START_ADDRESS     { ( void* )end }
 #define MEM_END_ADDRESS       { ( void* )( AVR32_SRAM_SIZE - STACK_SIZE_TOTAL - 1 ) }    
 
+// Interrupt list
+#define INT_UART_RX           ELUA_INT_FIRST_ID
+#define INT_ELUA_LAST         INT_UART_RX
 
+#define PLATFORM_CPU_CONSTANTS\
+ _C( INT_UART_RX )
+ 
 // *****************************************************************************
 // CPU constants that should be exposed to the eLua &quot;cpu&quot; module
 

Modified: trunk/src/platform/avr32/conf.py
===================================================================
--- trunk/src/platform/avr32/conf.py	2011-01-10 00:08:13 UTC (rev 880)
+++ trunk/src/platform/avr32/conf.py	2011-01-16 00:23:19 UTC (rev 881)
@@ -1,6 +1,6 @@
 # Configuration file for the AVR32 microcontrollers
 
-specific_files = &quot;crt0.s trampoline.s platform.c exception.s intc.c pm.c flashc.c pm_conf_clocks.c usart.c gpio.c tc.c spi.c&quot;
+specific_files = &quot;crt0.s trampoline.s platform.c exception.s intc.c pm.c flashc.c pm_conf_clocks.c usart.c gpio.c tc.c spi.c platform_int.c&quot;
 comp.Append(CPPDEFINES = 'FORAVR32')
 
 # See board.h for possible BOARD values.

Modified: trunk/src/platform/avr32/platform.c
===================================================================
--- trunk/src/platform/avr32/platform.c	2011-01-10 00:08:13 UTC (rev 880)
+++ trunk/src/platform/avr32/platform.c	2011-01-16 00:23:19 UTC (rev 881)
@@ -47,7 +47,7 @@
 }                                
 #endif
 
-static const u32 uart_base_addr[ ] = { 
+const u32 uart_base_addr[ ] = { 
     AVR32_USART0_ADDRESS, 
     AVR32_USART1_ADDRESS, 
     AVR32_USART2_ADDRESS, 
@@ -56,20 +56,6 @@
 #endif    
 };
 
-// Buffered UART support
-#ifdef BUF_ENABLE_UART
-__attribute__((__interrupt__)) static void uart_rx_handler()
-{
-  int c;
-  t_buf_data temp;
-  volatile avr32_usart_t *pusart = ( volatile avr32_usart_t* )uart_base_addr[ CON_UART_ID ];    
-  
-  usart_read_char( pusart, &amp;c );
-  temp = ( t_buf_data )c;
-  buf_write( BUF_ID_UART, CON_UART_ID, &amp;temp );
-}
-#endif
-
 extern void alloc_init();
 
 int platform_init()
@@ -124,19 +110,7 @@
 #ifdef AVR32_SDRAMC
   sdramc_init( REQ_CPU_FREQ );
 #endif 
-  
-  // Setup UART for eLua
-  platform_uart_setup( CON_UART_ID, CON_UART_SPEED, 8, PLATFORM_UART_PARITY_NONE, PLATFORM_UART_STOPBITS_1 );  
-#if defined( BUF_ENABLE_UART ) &amp;&amp; defined( CON_BUF_SIZE )
-  // Enable buffering on the console UART
-  buf_set( BUF_ID_UART, CON_UART_ID, CON_BUF_SIZE, BUF_DSIZE_U8 );
-  // Set interrupt handler and interrupt flag on UART
-  INTC_register_interrupt( &amp;uart_rx_handler, CON_UART_IRQ, AVR32_INTC_INT0 );  
-  volatile avr32_usart_t *pusart = ( volatile avr32_usart_t* )uart_base_addr[ CON_UART_ID ];      
-  pusart-&gt;ier = AVR32_USART_IER_RXRDY_MASK;  
-  Enable_global_interrupt();
-#endif
-    
+      
   // Setup timers
   for( i = 0; i &lt; 3; i ++ )
   {
@@ -439,11 +413,12 @@
   return baud;
 }
 
-void platform_uart_send( unsigned id, u8 data )
+void platform_s_uart_send( unsigned id, u8 data )
 {
   volatile avr32_usart_t *pusart = ( volatile avr32_usart_t* )uart_base_addr[ id ];  
   
-  usart_putchar( pusart, data );
+  while( !usart_tx_ready( pusart ) );
+  pusart-&gt;thr = ( data &lt;&lt; AVR32_USART_THR_TXCHR_OFFSET ) &amp; AVR32_USART_THR_TXCHR_MASK;
 }    
 
 int platform_s_uart_recv( unsigned id, s32 timeout )

Copied: trunk/src/platform/avr32/platform_int.c (from rev 880, branches/remotefs_int/src/platform/avr32/platform_int.c)
===================================================================
--- trunk/src/platform/avr32/platform_int.c	                        (rev 0)
+++ trunk/src/platform/avr32/platform_int.c	2011-01-16 00:23:19 UTC (rev 881)
@@ -0,0 +1,113 @@
+// AVR32 interrupt support
+
+#include &quot;platform_conf.h&quot;
+#if defined( BUILD_C_INT_HANDLERS ) || defined( BUILD_LUA_INT_HANDLERS )
+
+// Generic headers
+#include &quot;platform.h&quot;
+#include &quot;elua_int.h&quot;
+#include &quot;common.h&quot;
+
+// Platform includes
+#include &lt;avr32/io.h&gt;
+#include &quot;usart.h&quot;
+#include &quot;intc.h&quot;
+
+// ****************************************************************************
+// Interrupt handlers
+
+// ----------------------------------------------------------------------------
+// UART_RX interrupt
+
+#ifndef AVR32_USART2_IRQ
+#define AVR32_USART2_IRQ      ( -1 )
+#endif
+
+#ifndef AVR32_USART3_IRQ
+#define AVR32_USART3_IRQ      ( -1 )
+#endif
+
+extern const u32 uart_base_addr[];
+
+static int usart_irqs[] = { AVR32_USART0_IRQ, AVR32_USART1_IRQ, AVR32_USART2_IRQ, AVR32_USART3_IRQ };
+
+static void uart_common_rx_handler( int resnum )
+{
+  cmn_int_handler( INT_UART_RX, resnum );
+}
+
+__attribute__((__interrupt__)) static void uart0_rx_handler()
+{
+  uart_common_rx_handler( 0 );
+}
+
+__attribute__((__interrupt__)) static void uart1_rx_handler()
+{
+  uart_common_rx_handler( 1 );
+}
+
+__attribute__((__interrupt__)) static void uart2_rx_handler()
+{
+  uart_common_rx_handler( 2 );
+}
+
+__attribute__((__interrupt__)) static void uart3_rx_handler()
+{
+  uart_common_rx_handler( 3 );
+}
+
+// ****************************************************************************
+// Interrupt: INT_UART_RX
+
+static int int_uart_rx_get_status( elua_int_resnum resnum )
+{
+  volatile avr32_usart_t *pusart = ( volatile avr32_usart_t* )uart_base_addr[ resnum ];      
+  
+  return ( pusart-&gt;imr &amp; AVR32_USART_IMR_RXRDY_MASK ) ? 1 : 0;  
+}
+
+static int int_uart_rx_set_status( elua_int_resnum resnum, int status )
+{
+  volatile avr32_usart_t *pusart = ( volatile avr32_usart_t* )uart_base_addr[ resnum ];
+  int prev = int_uart_rx_get_status( resnum );
+  
+  if( status == PLATFORM_CPU_ENABLE )      
+    pusart-&gt;ier = AVR32_USART_IER_RXRDY_MASK;
+  else
+    pusart-&gt;idr = AVR32_USART_IDR_RXRDY_MASK;   
+  return prev;
+}
+
+static int int_uart_rx_get_flag( elua_int_resnum resnum, int clear )
+{
+  volatile avr32_usart_t *pusart = ( volatile avr32_usart_t* )uart_base_addr[ resnum ];
+  
+  ( void )clear; // the flag is automatically cleared after reading the UART char
+  return ( pusart-&gt;csr &amp; AVR32_USART_CSR_RXRDY_MASK ) ? 1 : 0;
+}
+
+// ****************************************************************************
+// Interrupt initialization
+
+typedef void ( *phandler )();
+static phandler phandlers[] = { uart0_rx_handler, uart1_rx_handler, uart2_rx_handler, uart3_rx_handler };
+
+void platform_int_init()
+{
+  unsigned i;
+  
+  for( i = 0; i &lt; NUM_UART; i ++ )
+   INTC_register_interrupt( phandlers[ i ], usart_irqs[ i ], AVR32_INTC_INT0 );   
+  Enable_global_interrupt();   
+}
+
+// ****************************************************************************
+// Interrupt table
+// Must have a 1-to-1 correspondence with the interrupt enum in platform_conf.h!
+
+const elua_int_descriptor elua_int_table[ INT_ELUA_LAST ] = 
+{
+  { int_uart_rx_set_status, int_uart_rx_get_status, int_uart_rx_get_flag }
+};
+
+#endif // #if defined( BUILD_C_INT_HANDLERS ) || defined( BUILD_LUA_INT_HANDLERS )

Modified: trunk/src/platform/i386/platform.c
===================================================================
--- trunk/src/platform/i386/platform.c	2011-01-10 00:08:13 UTC (rev 880)
+++ trunk/src/platform/i386/platform.c	2011-01-16 00:23:19 UTC (rev 881)
@@ -146,7 +146,7 @@
   return 0;
 }
 
-void platform_uart_send( unsigned id, u8 data )
+void platform_s_uart_send( unsigned id, u8 data )
 {
 }
 
@@ -181,6 +181,19 @@
 }
 
 // ****************************************************************************
+// &quot;Dummy&quot; CPU functions
+
+int platform_cpu_set_global_interrupts( int status )
+{
+  return 0;
+}
+
+int platform_cpu_get_global_interrupts()
+{
+  return 0;
+}
+
+// ****************************************************************************
 // Allocator support
 
 u32 platform_get_lastmem()

Modified: trunk/src/platform/i386/platform_conf.h
===================================================================
--- trunk/src/platform/i386/platform_conf.h	2011-01-10 00:08:13 UTC (rev 880)
+++ trunk/src/platform/i386/platform_conf.h	2011-01-16 00:23:19 UTC (rev 881)
@@ -28,6 +28,7 @@
 
 // Bogus defines for common.c
 #define CON_UART_ID           0
+#define CON_UART_SPEED        0
 #define CON_TIMER_ID          0
 
 // *****************************************************************************

Modified: trunk/src/platform/lm3s/conf.py
===================================================================
--- trunk/src/platform/lm3s/conf.py	2011-01-10 00:08:13 UTC (rev 880)
+++ trunk/src/platform/lm3s/conf.py	2011-01-16 00:23:19 UTC (rev 881)
@@ -1,5 +1,5 @@
 # Configuration file for the LM3S microcontroller
-specific_files = &quot;startup_gcc.c platform.c uart.c sysctl.c gpio.c ssi.c timer.c pwm.c ethernet.c systick.c flash.c interrupt.c cpu.c adc.c can.c&quot;
+specific_files = &quot;startup_gcc.c platform.c uart.c sysctl.c gpio.c ssi.c timer.c pwm.c ethernet.c systick.c flash.c interrupt.c cpu.c adc.c can.c platform_int.c&quot;
 
 if comp[ 'board' ] == 'EK-LM3S1968' or comp[ 'board' ] == 'EK-LM3S6965' or comp[ 'board' ] == 'EK-LM3S8962':
   specific_files = specific_files + &quot; rit128x96x4.c disp.c&quot;

Modified: trunk/src/platform/lm3s/platform.c
===================================================================
--- trunk/src/platform/lm3s/platform.c	2011-01-10 00:08:13 UTC (rev 880)
+++ trunk/src/platform/lm3s/platform.c	2011-01-16 00:23:19 UTC (rev 881)
@@ -402,52 +402,17 @@
 // Different configurations for LM3S8962, LM3S6918 (2 UARTs) and LM3S6965, LM3S9B92 (3 UARTs)
 
 // All possible LM3S uarts defs
-static const u32 uart_base[] = { UART0_BASE, UART1_BASE, UART2_BASE };
+const u32 uart_base[] = { UART0_BASE, UART1_BASE, UART2_BASE };
 static const u32 uart_sysctl[] = { SYSCTL_PERIPH_UART0, SYSCTL_PERIPH_UART1, SYSCTL_PERIPH_UART2 };
 static const u32 uart_gpio_base[] = { GPIO_PORTA_BASE, GPIO_PORTD_BASE, GPIO_PORTG_BASE };
 static const u8 uart_gpio_pins[] = { GPIO_PIN_0 | GPIO_PIN_1, GPIO_PIN_2 | GPIO_PIN_3, GPIO_PIN_0 | GPIO_PIN_1 };
 
-#ifdef BUF_ENABLE_UART
-void UARTIntHandler()
-{
-  u32 temp;
-  int c;
-
-  temp = MAP_UARTIntStatus(uart_base[ CON_UART_ID ], true);
-  MAP_UARTIntClear(uart_base[ CON_UART_ID ], temp);
-  while( MAP_UARTCharsAvail( uart_base[ CON_UART_ID ] ) )
-  {
-    c = MAP_UARTCharGetNonBlocking( uart_base[ CON_UART_ID ] );
-    buf_write( BUF_ID_UART, CON_UART_ID, ( t_buf_data* )&amp;c );
-  }
-}
-#endif
-
-
 static void uarts_init()
 {
   unsigned i;
 
   for( i = 0; i &lt; NUM_UART; i ++ )
     MAP_SysCtlPeripheralEnable(uart_sysctl[ i ]);
-
-  // Special case for UART 0
-  // Configure the UART for 115,200, 8-N-1 operation.
-  MAP_GPIOPinTypeUART(GPIO_PORTA_BASE, GPIO_PIN_0 | GPIO_PIN_1);
-  MAP_UARTConfigSetExpClk(UART0_BASE, SysCtlClockGet(), CON_UART_SPEED,
-                     (UART_CONFIG_WLEN_8 | UART_CONFIG_STOP_ONE |
-                      UART_CONFIG_PAR_NONE));
-                      
-                      
-#if defined( BUF_ENABLE_UART ) &amp;&amp; defined( CON_BUF_SIZE )
-  // Enable buffering on the console UART
-  buf_set( BUF_ID_UART, CON_UART_ID, CON_BUF_SIZE, BUF_DSIZE_U8 );
-  // Set interrupt handler and interrupt flag on UART
-  
-  IntEnable(INT_UART0);
-
-  MAP_UARTIntEnable( uart_base[ CON_UART_ID ], UART_INT_RX | UART_INT_RT );
-#endif
 }
 
 u32 platform_uart_setup( unsigned id, u32 baud, int databits, int parity, int stopbits )
@@ -484,7 +449,7 @@
   return baud;
 }
 
-void platform_uart_send( unsigned id, u8 data )
+void platform_s_uart_send( unsigned id, u8 data )
 {
   MAP_UARTCharPut( uart_base[ id ], data );
 }

Modified: trunk/src/platform/lm3s/platform_conf.h
===================================================================
--- trunk/src/platform/lm3s/platform_conf.h	2011-01-10 00:08:13 UTC (rev 880)
+++ trunk/src/platform/lm3s/platform_conf.h	2011-01-16 00:23:19 UTC (rev 881)
@@ -8,6 +8,7 @@
 #include &quot;hw_types.h&quot;
 #include &quot;stacks.h&quot;
 #include &quot;sysctl.h&quot;
+#include &quot;elua_int.h&quot;
 
 // *****************************************************************************
 // Define here what components you want for this platform
@@ -26,6 +27,7 @@
 #define BUILD_ADC
 #define BUILD_RPC
 //#define BUILD_CON_TCP
+#define BUILD_C_INT_HANDLERS
 
 // *****************************************************************************
 // UART/Timer IDs configuration data (used in main.c)
@@ -165,8 +167,8 @@
 #define NUM_CAN               1
 
 // Enable RX buffering on UART
-//#define BUF_ENABLE_UART
-//#define CON_BUF_SIZE          BUF_SIZE_128
+#define BUF_ENABLE_UART
+#define CON_BUF_SIZE          BUF_SIZE_128
 
 // ADC Configuration Params
 #define ADC_BIT_RESOLUTION    10
@@ -236,6 +238,10 @@
 #define MEM_START_ADDRESS     { ( void* )end }
 #define MEM_END_ADDRESS       { ( void* )( SRAM_BASE + SRAM_SIZE - STACK_SIZE_TOTAL - 1 ) }
 
+// Interrupt list
+#define INT_UART_RX           ELUA_INT_FIRST_ID
+#define INT_ELUA_LAST         INT_UART_RX
+
 // *****************************************************************************
 // CPU constants that should be exposed to the eLua &quot;cpu&quot; module
 
@@ -289,6 +295,7 @@
   _C( INT_USB0 ),\
   _C( INT_PWM3 ),\
   _C( INT_UDMA ),\
-  _C( INT_UDMAERR )
+  _C( INT_UDMAERR ),\
+  _C( INT_UART_RX )
 
 #endif // #ifndef __PLATFORM_CONF_H__

Copied: trunk/src/platform/lm3s/platform_int.c (from rev 880, branches/remotefs_int/src/platform/lm3s/platform_int.c)
===================================================================
--- trunk/src/platform/lm3s/platform_int.c	                        (rev 0)
+++ trunk/src/platform/lm3s/platform_int.c	2011-01-16 00:23:19 UTC (rev 881)
@@ -0,0 +1,109 @@
+// AVR32 interrupt support
+
+#include &quot;platform_conf.h&quot;
+#if defined( BUILD_C_INT_HANDLERS ) || defined( BUILD_LUA_INT_HANDLERS )
+
+// Generic headers
+#include &quot;platform.h&quot;
+#include &quot;elua_int.h&quot;
+#include &quot;common.h&quot;
+
+// Platform includes
+#ifdef FORLM3S9B92
+  #define TARGET_IS_TEMPEST_RB1
+
+  #include &quot;lm3s9b92.h&quot;
+#elif FORLM3S8962
+  #include &quot;lm3s8962.h&quot;
+#elif FORLM3S6965
+  #include &quot;lm3s6965.h&quot;
+#elif FORLM3S6918
+  #include &quot;lm3s6918.h&quot;
+#endif
+
+#include &quot;rom.h&quot;
+#include &quot;rom_map.h&quot;
+#include &quot;hw_ints.h&quot;
+#include &quot;uart.h&quot;
+#include &quot;interrupt.h&quot;
+
+// ****************************************************************************
+// Interrupt handlers
+
+// ----------------------------------------------------------------------------
+// UART_RX interrupt
+
+extern const u32 uart_base[]; 
+static const int uart_int_mask = UART_INT_RX | UART_INT_RT;
+ 
+static void uart_common_rx_handler( int resnum )
+{
+  MAP_UARTIntClear( uart_base[ resnum ], uart_int_mask );
+  while( MAP_UARTCharsAvail( uart_base[ resnum ] ) )  
+    cmn_int_handler( INT_UART_RX, resnum );  
+}
+
+void uart0_handler()
+{
+  uart_common_rx_handler( 0 );
+}
+
+void uart1_handler()
+{
+  uart_common_rx_handler( 1 );
+}
+
+void uart2_handler()
+{
+  uart_common_rx_handler( 2 );
+}
+
+// ****************************************************************************
+// Interrupt: INT_UART_RX
+
+static int int_uart_rx_get_status( elua_int_resnum resnum )
+{  
+  return ( MAP_UARTIntStatus( uart_base[ resnum ], false ) &amp; uart_int_mask ) == uart_int_mask ? 1 : 0;
+}
+
+static int int_uart_rx_set_status( elua_int_resnum resnum, int status )
+{
+  int prev = int_uart_rx_get_status( resnum );
+  
+  if( status == PLATFORM_CPU_ENABLE )
+    MAP_UARTIntEnable( uart_base[ resnum ], uart_int_mask );
+  else
+    MAP_UARTIntDisable( uart_base[ resnum ], uart_int_mask );  
+  return prev;
+}
+
+static int int_uart_rx_get_flag( elua_int_resnum resnum, int clear )
+{
+
+  int flag = ( UARTIntStatus( uart_base[ resnum ], false ) &amp; uart_int_mask ) == uart_int_mask ? 1 : 0;
+  
+  if( clear )
+    MAP_UARTIntClear( uart_base[ resnum ], uart_int_mask ); 
+  return flag;  
+}
+
+// ****************************************************************************
+// Interrupt initialization
+
+void platform_int_init()
+{
+  IntEnable( INT_UART0 );
+  IntEnable( INT_UART1 );
+  IntEnable( INT_UART2 );    
+}
+
+// ****************************************************************************
+// Interrupt table
+// Must have a 1-to-1 correspondence with the interrupt enum in platform_conf.h!
+
+const elua_int_descriptor elua_int_table[ INT_ELUA_LAST ] = 
+{
+  { int_uart_rx_set_status, int_uart_rx_get_status, int_uart_rx_get_flag }
+};
+
+#endif // #if defined( BUILD_C_INT_HANDLERS ) || defined( BUILD_LUA_INT_HANDLERS )

Modified: trunk/src/platform/lm3s/startup_gcc.c
===================================================================
--- trunk/src/platform/lm3s/startup_gcc.c	2011-01-10 00:08:13 UTC (rev 880)
+++ trunk/src/platform/lm3s/startup_gcc.c	2011-01-16 00:23:19 UTC (rev 881)
@@ -46,6 +46,11 @@
 #include &quot;hw_memmap.h&quot;
 #include &quot;platform_conf.h&quot;
 
+extern void uart0_handler();
+extern void uart1_handler();
+extern void uart2_handler();
+
+
 //*****************************************************************************
 //
 // The entry point for the application.
@@ -84,12 +89,16 @@
     IntDefaultHandler,                      // GPIO Port C
     IntDefaultHandler,                      // GPIO Port D
     IntDefaultHandler,                      // GPIO Port E
-#ifdef BUF_ENABLE_UART
-    UARTIntHandler,                         // UART0 Rx and Tx
+#if defined( BUILD_C_INT_HANDLERS ) || defined( BUILD_LUA_INT_HANDLERS )
+    uart0_handler,                          // UART0 Rx and Tx
 #else
     IntDefaultHandler,
 #endif
+#if defined( BUILD_C_INT_HANDLERS ) || defined( BUILD_LUA_INT_HANDLERS )
+    uart1_handler,                          // UART1 Rx and Tx
+#else
     IntDefaultHandler,                      // UART1 Rx and Tx
+#endif    
     IntDefaultHandler,                      // SSI0 Rx and Tx
     IntDefaultHandler,                      // I2C0 Master and Slave
     IntDefaultHandler,                      // PWM Fault
@@ -123,7 +132,11 @@
     IntDefaultHandler,                      // GPIO Port F
     IntDefaultHandler,                      // GPIO Port G
     IntDefaultHandler,                      // GPIO Port H
+#if defined( BUILD_C_INT_HANDLERS ) || defined( BUILD_LUA_INT_HANDLERS )
+    uart2_handler,                          // UART2 Rx and Tx
+#else    
     IntDefaultHandler,                      // UART2 Rx and Tx
+#endif    
     IntDefaultHandler,                      // SSI1 Rx and Tx
     IntDefaultHandler,                      // Timer 3 subtimer A
     IntDefaultHandler,                      // Timer 3 subtimer B

Modified: trunk/src/platform/lpc17xx/platform.c
===================================================================
--- trunk/src/platform/lpc17xx/platform.c	2011-01-10 00:08:13 UTC (rev 880)
+++ trunk/src/platform/lpc17xx/platform.c	2011-01-16 00:23:19 UTC (rev 881)
@@ -61,9 +61,6 @@
   platform_setup_timers();
   //platform_setup_pwm();
 
-  // Initialize console UART
-  platform_uart_setup( CON_UART_ID, CON_UART_SPEED, 8, PLATFORM_UART_PARITY_NONE, PLATFORM_UART_STOPBITS_1 );
-
 #ifdef BUILD_ADC
   // Setup ADCs
   platform_setup_adcs();
@@ -212,7 +209,7 @@
   return baud; // FIXME: find a way to actually get baud
 }
 
-void platform_uart_send( unsigned id, u8 data )
+void platform_s_uart_send( unsigned id, u8 data )
 {
   UART_Send(uart[ id ], &amp;data, 1, BLOCKING);
 }

Modified: trunk/src/platform/lpc24xx/platform.c
===================================================================
--- trunk/src/platform/lpc24xx/platform.c	2011-01-10 00:08:13 UTC (rev 880)
+++ trunk/src/platform/lpc24xx/platform.c	2011-01-16 00:23:19 UTC (rev 881)
@@ -139,9 +139,6 @@
   platform_setup_timers();
   platform_setup_pwm();
   
-  // Initialize console UART
-  platform_uart_setup( CON_UART_ID, CON_UART_SPEED, 8, PLATFORM_UART_PARITY_NONE, PLATFORM_UART_STOPBITS_1 );
-  
 #ifdef BUILD_ADC
   // Setup ADCs
   platform_setup_adcs();
@@ -381,7 +378,7 @@
   return ( Fpclk_UART &gt;&gt; 4 ) / temp;
 }
 
-void platform_uart_send( unsigned id, u8 data )
+void platform_s_uart_send( unsigned id, u8 data )
 {
   PREG UxTHR = ( PREG )uart_thr[ id ];
   PREG UxLSR = ( PREG )uart_lsr[ id ];

Modified: trunk/src/platform/lpc24xx/platform_conf.h
===================================================================
--- trunk/src/platform/lpc24xx/platform_conf.h	2011-01-10 00:08:13 UTC (rev 880)
+++ trunk/src/platform/lpc24xx/platform_conf.h	2011-01-16 00:23:19 UTC (rev 881)
@@ -8,6 +8,7 @@
 #include &quot;target.h&quot;
 #include &quot;buf.h&quot;
 #include &quot;elua_int.h&quot;
+#include &quot;sermux.h&quot;
 
 // *****************************************************************************
 // Define here what components you want for this platform
@@ -19,13 +20,16 @@
 #define BUILD_CON_GENERIC
 #define BUILD_ADC
 #define BUILD_RPC
+#define BUILD_RFS
+#define BUILD_SERMUX
 #define BUILD_LUA_INT_HANDLERS
 #define BUILD_C_INT_HANDLERS
 
 // *****************************************************************************
 // UART/Timer IDs configuration data (used in main.c)
 
-#define CON_UART_ID           0
+#define CON_UART_ID           ( SERMUX_SERVICE_ID_FIRST + 1 )
+//#define CON_UART_ID           0
 #define CON_UART_SPEED        115200
 #define CON_TIMER_ID          0
 #define TERM_LINES            25
@@ -90,9 +94,8 @@
 // Interrupt data
 #define PLATFORM_INT_QUEUE_LOG_SIZE   BUF_SIZE_32
 // Enable RX buffering on UART
-// [TODO] make this happen
-//#define BUF_ENABLE_UART
-//#define CON_BUF_SIZE          BUF_SIZE_128
+#define BUF_ENABLE_UART
+#define CON_BUF_SIZE          BUF_SIZE_128
 
 // ADC Configuration Params
 #define ADC_BIT_RESOLUTION    10
@@ -119,6 +122,18 @@
 // Use #define PIO_PINS_PER_PORT 0 if this isn't needed
 #define PIO_PINS_PER_PORT     32
 
+// Remote file system data
+#define RFS_BUFFER_SIZE       BUF_SIZE_512
+#define RFS_UART_ID           ( SERMUX_SERVICE_ID_FIRST )
+#define RFS_TIMER_ID          0
+#define RFS_TIMEOUT           100000
+#define RFS_UART_SPEED        115200
+
+#define SERMUX_PHYS_ID        0
+#define SERMUX_PHYS_SPEED     115200
+#define SERMUX_NUM_VUART      2
+#define SERMUX_BUFFER_SIZES   { RFS_BUFFER_SIZE, CON_BUF_SIZE }
+
 // Allocator data: define your free memory zones here in two arrays
 // (start address and end address)
 #define SRAM_ORIGIN           0x40000000
@@ -156,7 +171,8 @@
 #define INT_GPIO_POSEDGE      ELUA_INT_FIRST_ID
 #define INT_GPIO_NEGEDGE      ( ELUA_INT_FIRST_ID + 1 )
 #define INT_TMR_MATCH         ( ELUA_INT_FIRST_ID + 2 )
-#define INT_ELUA_LAST         INT_TMR_MATCH
+#define INT_UART_RX           ( ELUA_INT_FIRST_ID + 3 )
+#define INT_ELUA_LAST         INT_UART_RX
 
 #define PLATFORM_CPU_CONSTANTS\
  _C( IO_PINSEL0 ),\
@@ -172,7 +188,8 @@
  _C( IO_PINSEL10 ),\
  _C( INT_GPIO_POSEDGE ),\
  _C( INT_GPIO_NEGEDGE ),\
- _C( INT_TMR_MATCH )
+ _C( INT_TMR_MATCH ),\
+ _C( INT_UART_RX )
  
 #endif // #ifndef __PLATFORM_CONF_H__
 

Modified: trunk/src/platform/lpc24xx/platform_int.c
===================================================================
--- trunk/src/platform/lpc24xx/platform_int.c	2011-01-10 00:08:13 UTC (rev 880)
+++ trunk/src/platform/lpc24xx/platform_int.c	2011-01-16 00:23:19 UTC (rev 881)
@@ -10,10 +10,14 @@
 #include &quot;irq.h&quot;
 #include &quot;LPC23xx.h&quot;
 #include &quot;target.h&quot;
+#include &quot;uart.h&quot;
 
 // ****************************************************************************
 // Interrupt handlers
 
+// ----------------------------------------------------------------------------
+// GPIO
+
 static PREG const posedge_status[] = { ( PREG )&amp;IO0_INT_STAT_R, ( PREG )&amp;IO2_INT_STAT_R };
 static PREG const negedge_status[] = { ( PREG )&amp;IO0_INT_STAT_F, ( PREG )&amp;IO2_INT_STAT_F };
 static PREG const intclr_regs[] = { ( PREG )&amp;IO0_INT_CLR, ( PREG )&amp;IO2_INT_CLR };
@@ -49,6 +53,40 @@
   VICVectAddr = 0; // ACK interrupt    
 }
 
+// ----------------------------------------------------------------------------
+// UART
+
+static PREG const uart_ier[] = { ( PREG )&amp;U0IER, ( PREG )&amp;U1IER, ( PREG )&amp;U2IER, ( PREG )&amp;U3IER };
+static PREG const uart_iir[] = { ( PREG )&amp;U0IIR, ( PREG )&amp;U1IIR, ( PREG )&amp;U2IIR, ( PREG )&amp;U3IIR };
+
+// Common UART interrupt handler
+static void uart_rx_common_handler( elua_int_resnum resnum )
+{
+  cmn_int_handler( INT_UART_RX, resnum );
+  VICVectAddr = 0;
+}
+
+// Interrupt handlers for individual UARTs
+static void int_handler_uart0()
+{
+  uart_rx_common_handler( 0 );
+}
+
+static void int_handler_uart1()
+{
+  uart_rx_common_handler( 1 );
+}
+
+static void int_handler_uart2()
+{
+  uart_rx_common_handler( 2 );
+}
+
+static void int_handler_uart3()
+{
+  uart_rx_common_handler( 3 );
+}
+
 // ****************************************************************************
 // GPIO helper functions
 
@@ -151,25 +189,64 @@
 
 static int int_tmr_match_set_status( elua_int_resnum resnum, int status )
 {
-  return PLATFORM_INT_NOT_HANDLED;
+  return PLATFORM_INT_BAD_RESNUM;
 }
 
 static int int_tmr_match_get_status( elua_int_resnum resnum )
 {
-  return PLATFORM_INT_NOT_HANDLED;
+  return PLATFORM_INT_BAD_RESNUM;
 }
 
 static int int_tmr_match_get_flag( elua_int_resnum resnum, int clear )
 {
-  return PLATFORM_INT_NOT_HANDLED;
+  return PLATFORM_INT_BAD_RESNUM;
 }
 
 // ****************************************************************************
+// Interrupt: INT_UART_RX
+
+static int int_uart_rx_get_status( elua_int_resnum resnum )
+{
+  PREG UxIER = uart_ier[ resnum ];
+
+  return ( *UxIER &amp; IER_RBR ) ? 1 : 0; 
+}
+
+static int int_uart_rx_set_status( elua_int_resnum resnum, int status )
+{
+  PREG UxIER = uart_ier[ resnum ];
+  int prev = int_uart_rx_get_status( resnum );
+
+  if( status == PLATFORM_CPU_ENABLE )
+    *UxIER |= IER_RBR;
+  else
+    *UxIER &amp;= ~IER_RBR; 
+  return prev;
+}
+
+static int int_uart_rx_get_flag( elua_int_resnum resnum, int clear )
+{
+  PREG UxIIR = uart_iir[ resnum ];
+
+  // 'clear' is not needed here, the interrupt will be cleared when reading the RBR register
+  ( void )clear;
+  if( ( *UxIIR &amp; IIR_PEND ) == 0 )
+    return ( ( *UxIIR &gt;&gt; 1 ) &amp; 0x07 ) == IIR_RDA;
+  return 0;
+}
+
+// ****************************************************************************
 // Interrupt initialization
 
+typedef void ( *p_handler )();
+
 void platform_int_init()
 {
-  install_irq( EINT3_INT, int_handler_eint3, HIGHEST_PRIORITY - 1 );   
+  install_irq( EINT3_INT, int_handler_eint3, HIGHEST_PRIORITY + 1 );   
+  install_irq( UART0_INT, int_handler_uart0, HIGHEST_PRIORITY + 2 );
+  install_irq( UART1_INT, int_handler_uart1, HIGHEST_PRIORITY + 3 );
+  install_irq( UART2_INT, int_handler_uart2, HIGHEST_PRIORITY + 4 );
+  install_irq( UART3_INT, int_handler_uart3, HIGHEST_PRIORITY + 5 );
 }
 
 // ****************************************************************************
@@ -180,6 +257,7 @@
 {
   { int_gpio_posedge_set_status, int_gpio_posedge_get_status, int_gpio_posedge_get_flag },
   { int_gpio_negedge_set_status, int_gpio_negedge_get_status, int_gpio_negedge_get_flag },
-  { int_tmr_match_set_status, int_tmr_match_get_status, int_tmr_match_get_flag }
+  { int_tmr_match_set_status, int_tmr_match_get_status, int_tmr_match_get_flag },
+  { int_uart_rx_set_status, int_uart_rx_get_status, int_uart_rx_get_flag }
 };
 

Modified: trunk/src/platform/lpc24xx/stacks.h
===================================================================
--- trunk/src/platform/lpc24xx/stacks.h	2011-01-10 00:08:13 UTC (rev 880)
+++ trunk/src/platform/lpc24xx/stacks.h	2011-01-16 00:23:19 UTC (rev 881)
@@ -4,7 +4,7 @@
 #define __STACKS_H__
 
 #define   STACK_SIZE_USR   8192
-#define   STACK_SIZE_IRQ   64
+#define   STACK_SIZE_IRQ   128
 #define   STACK_SIZE_TOTAL ( STACK_SIZE_USR + STACK_SIZE_IRQ )
 
 #endif

Modified: trunk/src/platform/lpc288x/platform.c
===================================================================
--- trunk/src/platform/lpc288x/platform.c	2011-01-10 00:08:13 UTC (rev 880)
+++ trunk/src/platform/lpc288x/platform.c	2011-01-16 00:23:19 UTC (rev 881)
@@ -28,9 +28,6 @@
   // Initialize CPU
   lpc288x_init();
   
-  // Initialize UART
-  uart_init( CON_UART_SPEED, 8, PLATFORM_UART_PARITY_NONE, PLATFORM_UART_STOPBITS_1 );
-  
   // Initialize timers
   T0CTRL = 0;
   T1CTRL = 0;
@@ -112,10 +109,11 @@
 
 u32 platform_uart_setup( unsigned id, u32 baud, int databits, int parity, int stopbits )
 {
+  ( void )id;
   return uart_init( baud, databits, parity, stopbits );
 }
 
-void platform_uart_send( unsigned id, u8 data )
+void platform_s_uart_send( unsigned id, u8 data )
 {
   uart_write( data );
 }

Modified: trunk/src/platform/sim/platform.c
===================================================================
--- trunk/src/platform/sim/platform.c	2011-01-10 00:08:13 UTC (rev 880)
+++ trunk/src/platform/sim/platform.c	2011-01-16 00:23:19 UTC (rev 881)
@@ -128,7 +128,7 @@
   return 0;
 }
 
-void platform_uart_send( unsigned id, u8 data )
+void platform_s_uart_send( unsigned id, u8 data )
 {
 }
 

Modified: trunk/src/platform/sim/platform_conf.h
===================================================================
--- trunk/src/platform/sim/platform_conf.h	2011-01-10 00:08:13 UTC (rev 880)
+++ trunk/src/platform/sim/platform_conf.h	2011-01-16 00:23:19 UTC (rev 881)
@@ -31,6 +31,7 @@
 
 // Bogus defines for common.c
 #define CON_UART_ID           0
+#define CON_UART_SPEED        0
 #define CON_TIMER_ID          0
 
 // *****************************************************************************

Modified: trunk/src/platform/stm32/conf.py
===================================================================
--- trunk/src/platform/stm32/conf.py	2011-01-10 00:08:13 UTC (rev 880)
+++ trunk/src/platform/stm32/conf.py	2011-01-16 00:23:19 UTC (rev 881)
@@ -8,7 +8,7 @@
 fwlib_files = &quot; &quot;.join(glob.glob(&quot;src/platform/%s/FWLib/library/src/*.c&quot; % platform))
 #print &quot;FWLib: %s &quot; % fwlib_files 
 
-specific_files = &quot;core_cm3.c system_stm32f10x.c startup_stm32f10x_hd.s platform.c stm32f10x_it.c lcd.c lua_lcd.c&quot;
+specific_files = &quot;core_cm3.c system_stm32f10x.c startup_stm32f10x_hd.s platform.c stm32f10x_it.c lcd.c lua_lcd.c platform_int.c&quot;
 
 ldscript = &quot;stm32.ld&quot;
   

Modified: trunk/src/platform/stm32/platform.c
===================================================================
--- trunk/src/platform/stm32/platform.c	2011-01-10 00:08:13 UTC (rev 880)
+++ trunk/src/platform/stm32/platform.c	2011-01-16 00:23:19 UTC (rev 881)
@@ -140,28 +140,24 @@
 #endif
 
   /* Configure the NVIC Preemption Priority Bits */
-  NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
+  /* Priority group 0 disables interrupt nesting completely */
+  NVIC_PriorityGroupConfig(NVIC_PriorityGroup_0);
 
+  // Lower the priority of the SysTick interrupt to let the
+  // UART interrupt preempt it
+  nvic_init_structure.NVIC_IRQChannel = SysTick_IRQn;
+  nvic_init_structure.NVIC_IRQChannelPreemptionPriority = 0; 
+  nvic_init_structure.NVIC_IRQChannelSubPriority = 1; 
+  nvic_init_structure.NVIC_IRQChannelCmd = ENABLE; 
+  NVIC_Init(&amp;nvic_init_structure);
+
 #ifdef BUILD_ADC  
   nvic_init_structure_adc.NVIC_IRQChannel = DMA1_Channel1_IRQn; 
-  nvic_init_structure_adc.NVIC_IRQChannelPreemptionPriority = 1; 
-  nvic_init_structure_adc.NVIC_IRQChannelSubPriority = 3; 
+  nvic_init_structure_adc.NVIC_IRQChannelPreemptionPriority = 0; 
+  nvic_init_structure_adc.NVIC_IRQChannelSubPriority = 2; 
   nvic_init_structure_adc.NVIC_IRQChannelCmd = DISABLE; 
   NVIC_Init(&amp;nvic_init_structure_adc);
 #endif
-
-#if defined( BUF_ENABLE_UART ) &amp;&amp; defined( CON_BUF_SIZE )
-  /* Enable the USART1 Interrupt */
-  // [TODO]: this is hardcoded, and it shouldn't be
-  nvic_init_structure.NVIC_IRQChannel = USART3_IRQn;
-  nvic_init_structure.NVIC_IRQChannelSubPriority = 0;
-  nvic_init_structure.NVIC_IRQChannelCmd = ENABLE;
-  NVIC_Init(&amp;nvic_init_structure);
-  nvic_init_structure.NVIC_IRQChannel = USART1_IRQn;
-  nvic_init_structure.NVIC_IRQChannelSubPriority = 0;
-  nvic_init_structure.NVIC_IRQChannelCmd = ENABLE;
-  NVIC_Init(&amp;nvic_init_structure);
-#endif
 }
 
 // ****************************************************************************
@@ -532,43 +528,12 @@
 // TODO: Support timeouts.
 
 // All possible STM32 uarts defs
-static USART_TypeDef *const usart[] =          { USART1, USART2, USART3, UART4, UART5 };
+USART_TypeDef *const stm32_usart[] =          { USART1, USART2, USART3, UART4, UART5 };
 static GPIO_TypeDef *const usart_gpio_rx_port[] = { GPIOA, GPIOA, GPIOB, GPIOC, GPIOD };
 static GPIO_TypeDef *const usart_gpio_tx_port[] = { GPIOA, GPIOA, GPIOB, GPIOC, GPIOC };
 static const u16 usart_gpio_rx_pin[] = { GPIO_Pin_10, GPIO_Pin_3, GPIO_Pin_11, GPIO_Pin_11, GPIO_Pin_2 };
 static const u16 usart_gpio_tx_pin[] = { GPIO_Pin_9, GPIO_Pin_2, GPIO_Pin_10, GPIO_Pin_10, GPIO_Pin_12 };
 
-#ifdef BUF_ENABLE_UART
-static void all_usart_irqhandler( int usart_id )
-{
-  int c;
-
-  if( USART_GetITStatus( usart[ usart_id ], USART_IT_RXNE ) != RESET )
-  {
-    /* Read one byte from the receive data register */
-    c = USART_ReceiveData( usart[ usart_id ] );
-    buf_write( BUF_ID_UART, usart_id, ( t_buf_data* )&amp;c );
-  }
-}
-
-void USART1_IRQHandler( void )
-{
-  all_usart_irqhandler( 0 );
-}
-
-void USART2_IRQHandler(void)
-{
-  all_usart_irqhandler( 1 );
-}
-
-void USART3_IRQHandler(void)
-{
-  all_usart_irqhandler( 2 );
-}
-#endif
-
-
-
 static void usart_init(u32 id, USART_InitTypeDef * initVals)
 {
   /* Configure USART IO */
@@ -586,43 +551,20 @@
   GPIO_Init(usart_gpio_rx_port[id], &amp;GPIO_InitStructure);
 
   /* Configure USART */
-  USART_Init(usart[id], initVals);
-  
-#if defined( BUF_ENABLE_UART ) &amp;&amp; defined( CON_BUF_SIZE )
-  /* Enable USART1 Receive and Transmit interrupts */
-  USART_ITConfig(usart[id], USART_IT_RXNE, ENABLE);
-  //USART_ITConfig(usart[id], USART_IT_TXE, ENABLE);
-#endif
+  USART_Init(stm32_usart[id], initVals);
 
   /* Enable USART */
-  USART_Cmd(usart[id], ENABLE);
+  USART_Cmd(stm32_usart[id], ENABLE);
 }
 
 static void uarts_init()
 {
-  USART_InitTypeDef USART_InitStructure;
-
   // Enable clocks.
   RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
   RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
   RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE);
   RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART4, ENABLE);
   RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART5, ENABLE);
-
-  // Configure the U(S)ART
-  USART_InitStructure.USART_BaudRate = CON_UART_SPEED;
-  USART_InitStructure.USART_WordLength = USART_WordLength_8b;
-  USART_InitStructure.USART_StopBits = USART_StopBits_1;
-  USART_InitStructure.USART_Parity = USART_Parity_No;
-  USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
-  USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
-
-#if defined( BUF_ENABLE_UART ) &amp;&amp; defined( CON_BUF_SIZE )
-  buf_set( BUF_ID_UART, CON_UART_ID, CON_BUF_SIZE, BUF_DSIZE_U8 );
-#endif
-
-  usart_init(CON_UART_ID, &amp;USART_InitStructure);
-
 }
 
 u32 platform_uart_setup( unsigned id, u32 baud, int databits, int parity, int stopbits )
@@ -681,28 +623,48 @@
   return TRUE;
 }
 
-void platform_uart_send( unsigned id, u8 data )
+void platform_s_uart_send( unsigned id, u8 data )
 {
-  while(USART_GetFlagStatus(usart[id], USART_FLAG_TXE) == RESET)
+  while(USART_GetFlagStatus(stm32_usart[id], USART_FLAG_TXE) == RESET)
   {
   }
-  USART_SendData(usart[id], data);
+  USART_SendData(stm32_usart[id], data);
 }
 
 int platform_s_uart_recv( unsigned id, s32 timeout )
 {
   if( timeout == 0 )
   {
-    if (USART_GetFlagStatus(usart[id], USART_FLAG_RXNE) == RESET)
+    if (USART_GetFlagStatus(stm32_usart[id], USART_FLAG_RXNE) == RESET)
       return -1;
     else
-      return USART_ReceiveData(usart[id]);
+      return USART_ReceiveData(stm32_usart[id]);
   }
   // Receive char blocking
-  while(USART_GetFlagStatus(usart[id], USART_FLAG_RXNE) == RESET);
-  return USART_ReceiveData(usart[id]);
+  while(USART_GetFlagStatus(stm32_usart[id], USART_FLAG_RXNE) == RESET);
+  return USART_ReceiveData(stm32_usart[id]);
 }
 
+int platform_s_uart_set_flow_control( unsigned id, int type )
+{
+  USART_TypeDef *usart = stm32_usart[ id ]; 
+  int temp = 0;
+
+  if( type == PLATFORM_UART_FLOW_NONE )
+  {
+    usart-&gt;CR3 &amp;= ~USART_HardwareFlowControl_RTS_CTS;
+    return PLATFORM_OK;
+  }
+  if( id &gt;= 3 ) // on STM32 only USART1 through USART3 have hardware flow control ([TODO] but only on high density devices?)
+    return PLATFORM_ERR;
+  if( type &amp; PLATFORM_UART_FLOW_RTS )
+    temp |= USART_HardwareFlowControl_RTS;
+  if( type &amp; PLATFORM_UART_FLOW_CTS )
+    temp |= USART_HardwareFlowControl_CTS;
+  usart-&gt;CR3 |= temp;
+  return PLATFORM_OK;
+}
+
 // ****************************************************************************
 // Timers
 
@@ -816,6 +778,10 @@
   return res;
 }
 
+int platform_s_timer_set_match_int( unsigned id, u32 period_us, int type )
+{
+  return PLATFORM_TIMER_INT_INVALID_ID;
+}
 
 // ****************************************************************************
 // PWMs

Modified: trunk/src/platform/stm32/platform_conf.h
===================================================================
--- trunk/src/platform/stm32/platform_conf.h	2011-01-10 00:08:13 UTC (rev 880)
+++ trunk/src/platform/stm32/platform_conf.h	2011-01-16 00:23:19 UTC (rev 881)
@@ -7,6 +7,8 @@
 #include &quot;type.h&quot;
 #include &quot;stacks.h&quot;
 #include &quot;stm32f10x.h&quot;
+#include &quot;elua_int.h&quot;
+#include &quot;sermux.h&quot;
 
 // *****************************************************************************
 // Define here what components you want for this platform
@@ -25,7 +27,11 @@
 //#define BUILD_RFS
 //#define BUILD_CON_TCP
 #define BUILD_LINENOISE
+#define BUILD_C_INT_HANDLERS
+#define BUILD_LUA_INT_HANDLERS
 
+#define PLATFORM_UART_SET_FLOW_CONTROL
+
 // *****************************************************************************
 // UART/Timer IDs configuration data (used in main.c)
 
@@ -80,31 +86,7 @@
   LCDLINE\
   _ROM( AUXLIB_ELUA, luaopen_elua, elua_map )\
   _ROM( LUA_MATHLIBNAME, luaopen_math, math_map )
-	
-// *****************************************************************************
-// Configuration data
 
-// Static TCP/IP configuration
-#define ELUA_CONF_IPADDR0     192
-#define ELUA_CONF_IPADDR1     168
-#define ELUA_CONF_IPADDR2     1
-#define ELUA_CONF_IPADDR3     13
-
-#define ELUA_CONF_NETMASK0    255
-#define ELUA_CONF_NETMASK1    255
-#define ELUA_CONF_NETMASK2    255
-#define ELUA_CONF_NETMASK3    0
-
-#define ELUA_CONF_DEFGW0      192
-#define ELUA_CONF_DEFGW1      168
-#define ELUA_CONF_DEFGW2      1
-#define ELUA_CONF_DEFGW3      1
-
-#define ELUA_CONF_DNS0        192
-#define ELUA_CONF_DNS1        168
-#define ELUA_CONF_DNS2        1
-#define ELUA_CONF_DNS3        1
-
 // *****************************************************************************
 // Configuration data
 
@@ -181,5 +163,17 @@
 #define MEM_START_ADDRESS     { ( void* )end }
 #define MEM_END_ADDRESS       { ( void* )( SRAM_BASE + SRAM_SIZE - STACK_SIZE_TOTAL - 1 ) }
 
+// Interrupt queue size
+#define PLATFORM_INT_QUEUE_LOG_SIZE 5
+
+// Interrupt list
+#define INT_TMR_MATCH         ELUA_INT_FIRST_ID
+#define INT_UART_RX           ( ELUA_INT_FIRST_ID + 1 )
+#define INT_ELUA_LAST         INT_UART_RX
+
+#define PLATFORM_CPU_CONSTANTS\
+  _C( INT_TMR_MATCH ),\
+  _C( INT_UART_RX )
+
 #endif // #ifndef __PLATFORM_CONF_H__
 

Copied: trunk/src/platform/stm32/platform_int.c (from rev 880, branches/remotefs_int/src/platform/stm32/platform_int.c)
===================================================================
--- trunk/src/platform/stm32/platform_int.c	                        (rev 0)
+++ trunk/src/platform/stm32/platform_int.c	2011-01-16 00:23:19 UTC (rev 881)
@@ -0,0 +1,130 @@
+// STM32 interrupt support
+
+// Generic headers
+#include &quot;platform.h&quot;
+#include &quot;platform_conf.h&quot;
+#include &quot;elua_int.h&quot;
+#include &quot;common.h&quot;
+
+// Platform-specific headers
+#include &quot;stm32f10x.h&quot;
+
+// ****************************************************************************
+// Interrupt handlers
+
+extern USART_TypeDef *const stm32_usart[];
+
+static void all_usart_irqhandler( int resnum )
+{
+  int temp;
+
+  temp = USART_GetFlagStatus( stm32_usart[ resnum ], USART_FLAG_ORE );
+  cmn_int_handler( INT_UART_RX, resnum );
+  if( temp == SET )
+    for( temp = 0; temp &lt; 10; temp ++ )
+      platform_s_uart_send( resnum, '@' );
+}
+
+void USART1_IRQHandler()
+{
+  all_usart_irqhandler( 0 );
+}
+
+void USART2_IRQHandler()
+{
+  all_usart_irqhandler( 1 );
+}
+
+void USART3_IRQHandler()
+{
+  all_usart_irqhandler( 2 );
+}
+
+void UART4_IRQHandler()
+{
+  all_usart_irqhandler( 3 );
+}
+
+void UART5_IRQHandler()
+{
+  all_usart_irqhandler( 4 );
+}
+
+// ****************************************************************************
+// Interrupt: INT_TMR_MATCH
+
+static int int_tmr_match_set_status( elua_int_resnum resnum, int status )
+{
+  return PLATFORM_INT_NOT_HANDLED;
+}
+
+static int int_tmr_match_get_status( elua_int_resnum resnum )
+{
+  return PLATFORM_INT_NOT_HANDLED;
+}
+
+static int int_tmr_match_get_flag( elua_int_resnum resnum, int clear )
+{
+  return PLATFORM_INT_NOT_HANDLED;
+}
+
+// ****************************************************************************
+// Interrupt: INT_UART_RX
+
+static int int_uart_rx_get_status( elua_int_resnum resnum )
+{
+  return USART_GetITStatus( stm32_usart[ resnum ], USART_IT_RXNE ) == SET ? 1 : 0;
+}
+
+static int int_uart_rx_set_status( elua_int_resnum resnum, int status )
+{
+  int prev = int_uart_rx_get_status( resnum );
+  USART_ITConfig( stm32_usart[ resnum ], USART_IT_RXNE, status == PLATFORM_CPU_ENABLE ? ENABLE : DISABLE );
+  return prev;
+}
+
+static int int_uart_rx_get_flag( elua_int_resnum resnum, int clear )
+{
+  int status = USART_GetFlagStatus( stm32_usart[ resnum ], USART_FLAG_RXNE ) == SET ? 1 : 0;
+  if( clear )
+    USART_ClearFlag( stm32_usart[ resnum ], USART_FLAG_RXNE );
+  return status;
+}
+
+// ****************************************************************************
+// Initialize interrupt subsystem
+
+// UART IRQ table
+#if defined( STM32F10X_LD )
+static const u8 uart_irq_table[] = { USART1_IRQn, USART2_IRQn };
+#elseif defined( STM32F10X_MD )
+static const u8 uart_irq_table[] = { USART1_IRQn, USART2_IRQn, USART3_IRQn };
+#else // high density devices
+static const u8 uart_irq_table[] = { USART1_IRQn, USART2_IRQn, USART3_IRQn, UART4_IRQn, UART5_IRQn };
+#endif
+
+void platform_int_init()
+{
+  NVIC_InitTypeDef nvic_init_structure;
+  unsigned i;
+  
+  // Enable all USART interrupts in the NVIC
+  nvic_init_structure.NVIC_IRQChannelPreemptionPriority = 0;
+  nvic_init_structure.NVIC_IRQChannelSubPriority = 0;
+  nvic_init_structure.NVIC_IRQChannelCmd = ENABLE;  
+  for( i = 0; i &lt; sizeof( uart_irq_table ) / sizeof( u8 ); i ++ )
+  {
+    nvic_init_structure.NVIC_IRQChannel = uart_irq_table[ i ];
+    NVIC_Init( &amp;nvic_init_structure );
+  }  
+}
+
+// ****************************************************************************
+// Interrupt table
+// Must have a 1-to-1 correspondence with the interrupt enum in platform_conf.h!
+
+const elua_int_descriptor elua_int_table[ INT_ELUA_LAST ] = 
+{
+  { int_tmr_match_set_status, int_tmr_match_get_status, int_tmr_match_get_flag },
+  { int_uart_rx_set_status, int_uart_rx_get_status, int_uart_rx_get_flag }  
+};

Modified: trunk/src/platform/stm32/stm32f10x_it.c
===================================================================
--- trunk/src/platform/stm32/stm32f10x_it.c	2011-01-10 00:08:13 UTC (rev 880)
+++ trunk/src/platform/stm32/stm32f10x_it.c	2011-01-16 00:23:19 UTC (rev 881)
@@ -51,7 +51,7 @@
 #if 0
 int fputc(int ch, FILE *f)
 {
-   platform_uart_send(0, ch);
+   platform_s_uart_send(0, ch);
    return ch;
 }
 #endif
@@ -121,10 +121,10 @@
 /* Go to infinite loop when Memory Manage exception occurs */
 while (1)
 {
-  platform_uart_send(0, ' ');
-  platform_uart_send(0, 'M');
-  platform_uart_send(0, 'M');
-  platform_uart_send(0, '!');
+  platform_s_uart_send(0, ' ');
+  platform_s_uart_send(0, 'M');
+  platform_s_uart_send(0, 'M');
+  platform_s_uart_send(0, '!');
 }
 }
 
@@ -138,10 +138,10 @@
 /* Go to infinite loop when Bus Fault exception occurs */
 while (1)
 {
-  platform_uart_send(0, ' ');
-  platform_uart_send(0, 'B');
-  platform_uart_send(0, 'F');
-  platform_uart_send(0, '!');
+  platform_s_uart_send(0, ' ');
+  platform_s_uart_send(0, 'B');
+  platform_s_uart_send(0, 'F');
+  platform_s_uart_send(0, '!');
 }
 }
 
@@ -155,10 +155,10 @@
 /* Go to infinite loop when Usage Fault exception occurs */
 while (1)
 {
-  platform_uart_send(0, ' ');
-  platform_uart_send(0, 'U');
-  platform_uart_send(0, 'F');
-  platform_uart_send(0, '!');
+  platform_s_uart_send(0, ' ');
+  platform_s_uart_send(0, 'U');
+  platform_s_uart_send(0, 'F');
+  platform_s_uart_send(0, '!');
 }
 }
 

Modified: trunk/src/platform/str7/platform.c
===================================================================
--- trunk/src/platform/str7/platform.c	2011-01-10 00:08:13 UTC (rev 880)
+++ trunk/src/platform/str7/platform.c	2011-01-16 00:23:19 UTC (rev 881)
@@ -49,9 +49,6 @@
   // Initialize clocks
   clock_init();
   
-  // Setup UART1 for operation
-  platform_uart_setup( CON_UART_ID, CON_UART_SPEED, 8, PLATFORM_UART_PARITY_NONE, PLATFORM_UART_STOPBITS_1 );
-  
   // Initialize Timer 0 for XMODEM
   platform_timer_op( 0, PLATFORM_TIMER_OP_SET_CLOCK, 39000 ); 
   
@@ -176,7 +173,7 @@
   return baud;
 }
 
-void platform_uart_send( unsigned id, u8 data )
+void platform_s_uart_send( unsigned id, u8 data )
 {
   UART_TypeDef* pport = ( UART_TypeDef* )uart_periph[ id ];
   

Modified: trunk/src/platform/str9/platform.c
===================================================================
--- trunk/src/platform/str9/platform.c	2011-01-10 00:08:13 UTC (rev 880)
+++ trunk/src/platform/str9/platform.c	2011-01-16 00:23:19 UTC (rev 881)
@@ -129,7 +129,6 @@
     
   // UART setup
   platform_gpio_uart_setup();
-  platform_uart_setup( CON_UART_ID, CON_UART_SPEED, 8, PLATFORM_UART_PARITY_NONE, PLATFORM_UART_STOPBITS_1 );
 
   // Initialize timers
   for( i = 0; i &lt; NUM_PHYS_TIMER; i ++ )
@@ -261,7 +260,7 @@
   return baud;
 }
 
-void platform_uart_send( unsigned id, u8 data )
+void platform_s_uart_send( unsigned id, u8 data )
 {
   UART_TypeDef* p_uart = ( UART_TypeDef* )uarts[ id ];
 

Modified: trunk/src/remotefs/client.c
===================================================================
--- trunk/src/remotefs/client.c	2011-01-10 00:08:13 UTC (rev 880)
+++ trunk/src/remotefs/client.c	2011-01-16 00:23:19 UTC (rev 881)
@@ -4,7 +4,22 @@
 #include &quot;remotefs.h&quot;
 #include &quot;client.h&quot;
 #include &quot;os_io.h&quot;
+#include &quot;eluarpc.h&quot;
 
+#include &lt;stdio.h&gt;
+#include &quot;platform_conf.h&quot;
+#include &quot;buf.h&quot;
+
+#ifdef BUILD_RFS
+
+#if 0
+#define RFSDEBUG        printf
+#else
+void RFSDEBUG( const char* dummy, ... )
+{
+}
+#endif
+
 // ****************************************************************************
 // Client local data
 
@@ -19,6 +34,7 @@
 static int rfsch_send_request_read_response()
 {
   u16 temp16;
+  u32 readbytes;
 
 #ifndef ELUA_CPU_LINUX
   // Empty receive buffer
@@ -26,19 +42,34 @@
 #endif
 
   // Send request
-  if( remotefs_get_packet_size( rfsc_buffer, &amp;temp16 ) == REMOTEFS_ERR )
+  if( eluarpc_get_packet_size( rfsc_buffer, &amp;temp16 ) == ELUARPC_ERR )
+  {
+    RFSDEBUG( &quot;[RFS] get packet size error\n&quot; );
     return CLIENT_ERR;
+  }
   if( rfsc_send( rfsc_buffer, temp16 ) != temp16 )
+  {
+    RFSDEBUG( &quot;[RFS] rfsc_send error\n&quot; );
     return CLIENT_ERR;
+  }
   
   // Get response
   // First the length, then the rest of the data
-  if( rfsc_recv( rfsc_buffer, RFS_START_OFFSET, rfsc_timeout ) != RFS_START_OFFSET )
+  if( ( readbytes = rfsc_recv( rfsc_buffer, ELUARPC_START_OFFSET, rfsc_timeout ) ) != ELUARPC_START_OFFSET )
+  {
+    RFSDEBUG( &quot;[RFS] rfsc_recv (1) error: expected %u, got %u\n&quot;, ( unsigned )( temp16 - ELUARPC_START_OFFSET ), ( unsigned )readbytes );
     return CLIENT_ERR;
-  if( remotefs_get_packet_size( rfsc_buffer, &amp;temp16 ) == REMOTEFS_ERR )
+  }
+  if( eluarpc_get_packet_size( rfsc_buffer, &amp;temp16 ) == ELUARPC_ERR )
+  {
+    RFSDEBUG( &quot;[RFS] eluarpc_get_packet_size() error\n&quot; );
     return CLIENT_ERR;
-  if( rfsc_recv( rfsc_buffer + RFS_START_OFFSET, temp16 - RFS_START_OFFSET, rfsc_timeout ) != temp16 - RFS_START_OFFSET )
+  }
+  if( ( readbytes = rfsc_recv( rfsc_buffer + ELUARPC_START_OFFSET, temp16 - ELUARPC_START_OFFSET, rfsc_timeout ) ) != temp16 - ELUARPC_START_OFFSET )
+  {
+    RFSDEBUG( &quot;[RFS] rfsc_recv (2) error: expected %u, got %u\n&quot;, ( unsigned )( temp16 - ELUARPC_START_OFFSET ), ( unsigned )readbytes );
     return CLIENT_ERR;
+  }
   return CLIENT_OK;
 }
 
@@ -70,7 +101,7 @@
     return -1;
 
   // Interpret the response
-  if( remotefs_open_read_response( rfsc_buffer, &amp;fd ) == REMOTEFS_ERR )
+  if( remotefs_open_read_response( rfsc_buffer, &amp;fd ) == ELUARPC_ERR )
     return -1;
   return fd;
 }
@@ -85,7 +116,7 @@
     return -1;
   
   // Interpret the response
-  if( remotefs_write_read_response( rfsc_buffer, &amp;count ) == REMOTEFS_ERR )
+  if( remotefs_write_read_response( rfsc_buffer, &amp;count ) == ELUARPC_ERR )
     return -1;
   return ( s32 )count;
 }
@@ -102,7 +133,7 @@
     return -1;
 
   // Interpret the response
-  if( remotefs_read_read_response( rfsc_buffer, &amp;resbuf, &amp;count ) == REMOTEFS_ERR )
+  if( remotefs_read_read_response( rfsc_buffer, &amp;resbuf, &amp;count ) == ELUARPC_ERR )
     return -1;
   memcpy( buf, resbuf, count );
   return ( s32 )count;
@@ -120,7 +151,7 @@
     return -1;
 
   // Interpret the response
-  if( remotefs_lseek_read_response( rfsc_buffer, &amp;res ) == REMOTEFS_ERR )
+  if( remotefs_lseek_read_response( rfsc_buffer, &amp;res ) == ELUARPC_ERR )
     return -1;
   return res;
 }
@@ -137,7 +168,7 @@
     return -1;
 
   // Interpret the response
-  if( remotefs_close_read_response( rfsc_buffer, &amp;res ) == REMOTEFS_ERR )
+  if( remotefs_close_read_response( rfsc_buffer, &amp;res ) == ELUARPC_ERR )
     return -1;
   return res;
 }
@@ -152,7 +183,7 @@
     return 0;
 
   // Interpret the response
-  if( remotefs_opendir_read_response( rfsc_buffer, &amp;res ) == REMOTEFS_ERR )
+  if( remotefs_opendir_read_response( rfsc_buffer, &amp;res ) == ELUARPC_ERR )
     return 0;
   return res;
 }
@@ -168,7 +199,7 @@
   }
 
   // Interpret the response
-  if( remotefs_readdir_read_response( rfsc_buffer, pname, psize, ptime ) == REMOTEFS_ERR )
+  if( remotefs_readdir_read_response( rfsc_buffer, pname, psize, ptime ) == ELUARPC_ERR )
     *pname = NULL;
 }
 
@@ -182,8 +213,9 @@
     return -1;
 
   // Interpret the response
-  if( remotefs_closedir_read_response( rfsc_buffer, &amp;res ) == REMOTEFS_ERR )
+  if( remotefs_closedir_read_response( rfsc_buffer, &amp;res ) == ELUARPC_ERR )
     return -1;
   return res;
 }  
 
+#endif // #ifdef BUILD_RFS

Modified: trunk/src/remotefs/elua_os_io.c
===================================================================
--- trunk/src/remotefs/elua_os_io.c	2011-01-10 00:08:13 UTC (rev 880)
+++ trunk/src/remotefs/elua_os_io.c	2011-01-16 00:23:19 UTC (rev 881)
@@ -5,20 +5,21 @@
 #include &lt;fcntl.h&gt;
 #include &quot;os_io.h&quot;
 #include &quot;remotefs.h&quot;
+#include &quot;eluarpc.h&quot;
 
 u32 os_open_sys_flags_to_rfs_flags( int sysflags )
 {
   int rfsflags = 0;
 
   // Translate RFS flags to POSIX flags
-  rfsflags = remotefs_replace_flag( sysflags, O_APPEND, RFS_OPEN_FLAG_APPEND );
-  rfsflags |= remotefs_replace_flag( sysflags, O_CREAT, RFS_OPEN_FLAG_CREAT );
-  rfsflags |= remotefs_replace_flag( sysflags, O_EXCL, RFS_OPEN_FLAG_EXCL );
-  rfsflags |= remotefs_replace_flag( sysflags, O_TRUNC, RFS_OPEN_FLAG_TRUNC );
-  rfsflags |= remotefs_replace_flag( sysflags, O_SYNC, RFS_OPEN_FLAG_SYNC );
-  rfsflags |= remotefs_replace_flag( sysflags, O_RDONLY, RFS_OPEN_FLAG_RDONLY );
-  rfsflags |= remotefs_replace_flag( sysflags, O_WRONLY, RFS_OPEN_FLAG_WRONLY );
-  rfsflags |= remotefs_replace_flag( sysflags, O_RDWR, RFS_OPEN_FLAG_RDWR );
+  rfsflags = eluarpc_replace_flag( sysflags, O_APPEND, RFS_OPEN_FLAG_APPEND );
+  rfsflags |= eluarpc_replace_flag( sysflags, O_CREAT, RFS_OPEN_FLAG_CREAT );
+  rfsflags |= eluarpc_replace_flag( sysflags, O_EXCL, RFS_OPEN_FLAG_EXCL );
+  rfsflags |= eluarpc_replace_flag( sysflags, O_TRUNC, RFS_OPEN_FLAG_TRUNC );
+  rfsflags |= eluarpc_replace_flag( sysflags, O_SYNC, RFS_OPEN_FLAG_SYNC );
+  rfsflags |= eluarpc_replace_flag( sysflags, O_RDONLY, RFS_OPEN_FLAG_RDONLY );
+  rfsflags |= eluarpc_replace_flag( sysflags, O_WRONLY, RFS_OPEN_FLAG_WRONLY );
+  rfsflags |= eluarpc_replace_flag( sysflags, O_RDWR, RFS_OPEN_FLAG_RDWR );
   return rfsflags;
 }
 

Modified: trunk/src/remotefs/elua_rfs.c
===================================================================
--- trunk/src/remotefs/elua_rfs.c	2011-01-10 00:08:13 UTC (rev 880)
+++ trunk/src/remotefs/elua_rfs.c	2011-01-16 00:23:19 UTC (rev 881)
@@ -5,7 +5,9 @@
 #include &quot;type.h&quot;
 #include &quot;platform.h&quot;
 #include &quot;remotefs.h&quot;
+#include &quot;eluarpc.h&quot;
 #include &quot;client.h&quot;
+#include &quot;sermux.h&quot;
 #include &quot;buf.h&quot;
 #include &lt;fcntl.h&gt;
 #ifdef ELUA_SIMULATOR
@@ -15,11 +17,16 @@
 
 #ifdef BUILD_RFS
 
+// [TODO] the new builder should automatically do this
+#ifndef RFS_FLOW_TYPE
+#define RFS_FLOW_TYPE        PLATFORM_UART_FLOW_NONE
+#endif
+
 // Our RFS buffer
 // Compute the usable buffer size starting from RFS_BUFFER_SIZE (which is the
 // size of the serial buffer). A complete packet must fit in RFS_BUFFER_SIZE
 // bytes. Computed this to be large enough for a WRITE request.
-#define RFS_REAL_BUFFER_SIZE      ( ( 1 &lt;&lt; RFS_BUFFER_SIZE ) - RFS_WRITE_REQUEST_EXTRA )
+#define RFS_REAL_BUFFER_SIZE      ( ( 1 &lt;&lt; RFS_BUFFER_SIZE ) - ELUARPC_WRITE_REQUEST_EXTRA )
 static u8 rfs_buffer[ 1 &lt;&lt; RFS_BUFFER_SIZE ];
 
 #ifdef ELUA_SIMULATOR
@@ -124,7 +131,7 @@
   return size;
 }
 
-static u32 rfs_recv( u8 *p, u32 size, u32 timeout )
+static u32 rfs_recv( u8 *p, u32 size, s32 timeout )
 {
   u32 cnt = 0;
   int data;
@@ -150,7 +157,7 @@
   return ( u32 )hostif_write( rfs_write_fd, p, size );
 }
 
-static u32 rfs_recv( u8 *p, u32 size, u32 timeout )
+static u32 rfs_recv( u8 *p, u32 size, s32 timeout )
 {
   timeout = timeout;
   return ( u32 )hostif_read( rfs_read_fd, p, size );
@@ -173,12 +180,6 @@
 
 const DM_DEVICE *remotefs_init()
 {
-#if defined( RFS_UART_ID ) &amp;&amp; defined( RFS_UART_SPEED )
-  // Initialize RFS UART
-  platform_uart_setup( RFS_UART_ID, RFS_UART_SPEED, 8, PLATFORM_UART_PARITY_NONE, PLATFORM_UART_STOPBITS_1 );
-  // [TODO] this isn't exactly right
-  buf_set( BUF_ID_UART, RFS_UART_ID, RFS_BUFFER_SIZE, BUF_DSIZE_U8 ); 
-#endif
 #ifdef ELUA_CPU_LINUX 
   // Open our read/write pipes
   rfs_read_fd = hostif_open( RFS_SRV_WRITE_PIPE, O_RDONLY, 0 );
@@ -188,6 +189,15 @@
     hostif_putstr( &quot;unable to open read/write pipes\n&quot; );
     return NULL;
   }
+#elif RFS_UART_ID &lt; SERMUX_SERVICE_ID_FIRST  // if RFS runs on a virtual UART, buffers are already set in common.c
+  // Initialize RFS UART
+  platform_uart_setup( RFS_UART_ID, RFS_UART_SPEED, 8, PLATFORM_UART_PARITY_NONE, PLATFORM_UART_STOPBITS_1 );
+  platform_uart_set_flow_control( RFS_UART_ID, RFS_FLOW_TYPE );
+  if( platform_uart_set_buffer( RFS_UART_ID, RFS_BUFFER_SIZE ) == PLATFORM_ERR )
+  {
+    printf( &quot;WARNING: unable to initialize RFS filesystem\n&quot; );
+    return NULL;
+  } 
 #endif
   rfsc_setup( rfs_buffer, rfs_send, rfs_recv, RFS_TIMEOUT );
   return &amp;rfs_device;

Modified: trunk/src/remotefs/remotefs.c
===================================================================
--- trunk/src/remotefs/remotefs.c	2011-01-10 00:08:13 UTC (rev 880)
+++ trunk/src/remotefs/remotefs.c	2011-01-16 00:23:19 UTC (rev 881)
@@ -4,340 +4,31 @@
 #include &lt;stdarg.h&gt;
 #include &quot;type.h&quot;
 #include &quot;remotefs.h&quot;
+#include &quot;eluarpc.h&quot;
 #include &quot;rtype.h&quot;
 
-static u8 remotefs_err_flag;
-
 // *****************************************************************************
-// Internal functions: data serialization
-
-static u8 *remotefs_write_u8( u8 *p, u8 data )
-{
-  *p ++ = TYPE_INT_8;
-  *p ++ = data;
-  return p;  
-}
-
-static u8* remotefs_write_op_id( u8 *p, u8 data )
-{
-  *p ++ = TYPE_OP_ID;
-  *p ++ = data;
-  return p;    
-}
-
-static u8 *remotefs_write_u16( u8 *p, u16 data )
-{
-  *p ++ = TYPE_INT_16;
-  *p ++ = data &amp; 0xFF;
-  *p ++ = ( data &gt;&gt; 8 ) &amp; 0xFF;
-  return p;    
-}
-
-static u8 *remotefs_write_u32( u8 *p, u32 data )
-{
-  *p ++ = TYPE_INT_32;
-  *p ++ = data &amp; 0xFF;
-  *p ++ = ( data &gt;&gt; 8 ) &amp; 0xFF;
-  *p ++ = ( data &gt;&gt; 16 ) &amp; 0xFF;
-  *p ++ = ( data &gt;&gt; 24 ) &amp; 0xFF;
-  return p;        
-}
-
-static u8 *remotefs_write_ptr( u8 *p, const void* src, u32 srclen )
-{
-  *p ++ = TYPE_PTR;
-  p = remotefs_write_u32( p, srclen );
-  if( src )
-    memcpy( p, src, srclen );
-  return p + srclen;    
-}
-
-// *****************************************************************************
-// Internal functions: data deserialization
-
-static const u8* remotefs_read_expect( const u8 *p, u8 data )
-{
-  if( *p ++ != data )
-    remotefs_err_flag = REMOTEFS_ERR;
-  return p;
-}
-
-static const u8 *remotefs_read_u8( const u8 *p, u8 *pdata )
-{
-  p = remotefs_read_expect( p, TYPE_INT_8 );
-  *pdata = *p ++;
-  return p;  
-}
-
-static const u8 *remotefs_read_op_id( const u8 *p, u8 *pdata )
-{
-  p = remotefs_read_expect( p, TYPE_OP_ID );
-  *pdata = *p ++;
-  return p;  
-}
-
-static const u8* remotefs_expect_op_id( const u8 *p, u8 id )
-{
-  u8 temp;
-  
-  p = remotefs_read_expect( p, TYPE_OP_ID );
-  temp = *p ++;
-  if( temp != id )
-    remotefs_err_flag = REMOTEFS_ERR;
-  return p;
-}
-
-static const u8 *remotefs_read_u16( const u8 *p, u16 *pdata )
-{
-  p = remotefs_read_expect( p, TYPE_INT_16 );
-  *pdata = *p ++;
-  *pdata |= ( *p ++ ) &lt;&lt; 8;  
-  return p;    
-}
-
-static const u8 *remotefs_read_u32( const u8 *p, u32 *pdata )
-{
-  p = remotefs_read_expect( p, TYPE_INT_32 );
-  *pdata = *p ++;                         
-  *pdata |= ( *p ++ ) &lt;&lt; 8;
-  *pdata |= ( *p ++ ) &lt;&lt; 16;
-  *pdata |= ( *p ++ ) &lt;&lt; 24;      
-  return p;        
-}
-
-static const u8 *remotefs_read_ptr( const u8 *p, void* src, u32 *psrclen )
-{                                         
-  p = remotefs_read_expect( p, TYPE_PTR );
-  p = remotefs_read_u32( p, psrclen );
-  if( src &amp;&amp; p )
-    memcpy( src, p, *psrclen );
-  return p + *psrclen;    
-}
-
-// *****************************************************************************
-// Internal functions: packet handling (read and write)
-
-static u8* remotefs_packet_ptr;
-
-static u8* remotefs_start_packet( u8 *p )
-{
-  remotefs_packet_ptr = p;
-  p += RFS_START_OFFSET;
-  *p ++ = TYPE_START;
-  p = remotefs_write_u32( p, PACKET_SIG );
-  return p;
-}
-
-static u8* remotefs_end_packet( u8 *p )
-{
-  u16 len;
-  
-  *p ++ = TYPE_END;
-  p = remotefs_write_u32( p, ~PACKET_SIG );
-  len = p - remotefs_packet_ptr;
-  p = remotefs_packet_ptr;
-  *p ++ = TYPE_PKT_SIZE;
-  remotefs_write_u16( p, len );  
-  return p;  
-}
-
-static const u8* remotefs_match_packet_start( const u8 *p )
-{
-  u32 data;
-  
-  p += RFS_START_OFFSET;
-  p = remotefs_read_expect( p, TYPE_START );
-  p = remotefs_read_u32( p, &amp;data );
-  if( data != PACKET_SIG )
-    remotefs_err_flag = REMOTEFS_ERR;
-  return p;
-}
-
-static const u8* remotefs_match_packet_end( const u8 *p )
-{
-  u32 data;
-  
-  p = remotefs_read_expect( p, TYPE_END );
-  p = remotefs_read_u32( p, &amp;data );
-  if( data != ~PACKET_SIG )
-    remotefs_err_flag = REMOTEFS_ERR;
-  return p;
-}
-
-// *****************************************************************************
-// Function serialization and deserialization
-
-int remotefs_get_request_id( const u8 *p, u8 *pid )
-{ 
-  remotefs_err_flag = REMOTEFS_OK;
-  p = remotefs_match_packet_start( p );
-  p = remotefs_read_op_id( p, pid );
-  return remotefs_err_flag;
-}
-
-u32 remotefs_replace_flag( u32 val, u32 origflag, u32 newflag )
-{
-  return ( val &amp; origflag ) ? newflag : 0; 
-}
-
-int remotefs_get_packet_size( const u8 *p, u16 *psize )
-{
-  remotefs_err_flag = REMOTEFS_OK;
-  p = remotefs_read_expect( p, TYPE_PKT_SIZE );
-  p = remotefs_read_u16( p, psize );
-  return remotefs_err_flag;
-}
-
-// Generic write function
-// Specifiers: o - operation
-//             r - response
-//             c - u8
-//             h - u16
-//             l - u32
-//             i - int
-//             L - s32
-//             p - ptr (given as ptr, len, len is an u32)
-void remotefs_gen_write( u8 *p, const char *fmt, ... )
-{
-  va_list ap;
-  const void *ptr;
-  u32 ptrlen;
-  
-  va_start( ap, fmt );
-  p = remotefs_start_packet( p );
-  while( *fmt )
-    switch( *fmt ++ )
-    {
-      case 'o':
-        p = remotefs_write_op_id( p, va_arg( ap, int ) );
-        break;
-        
-      case 'r':
-        *p++ = RFS_OP_RES_MOD | ( u8 )va_arg( ap, int );
-        break;
-        
-      case 'c':
-        p = remotefs_write_u8( p, ( u8 )va_arg( ap, int ) );
-        break;
-        
-      case 'h':
-        p = remotefs_write_u16( p, ( u16 )va_arg( ap, int ) );
-        break;
-
-      case 'i':
-        p = remotefs_write_u32( p, ( u32 )va_arg( ap, int ) );
-        break;
-        
-      case 'l':
-        p = remotefs_write_u32( p, ( u32 )va_arg( ap, u32 ) );
-        break;
-
-      case 'L':
-        p = remotefs_write_u32( p, ( u32 )va_arg( ap, s32 ) );
-        break;         
-      
-      case 'p':
-        ptr = va_arg( ap, void * );
-        ptrlen = ( u32 )va_arg( ap, long );
-        p = remotefs_write_ptr( p, ptr, ptrlen );
-        break;
-    }
-  remotefs_end_packet( p );
-}
-
-// Generic read function
-// Specifiers: o - operation
-//             r - response
-//             c - u8
-//             h - u16
-//             l - u32
-//             L - s32
-//             i - int
-//             p - ptr (returned as ptr, len, len is an u32)
-int remotefs_gen_read( const u8 *p, const char *fmt, ... )
-{
-  va_list ap;
-  const void *pptr;
-  u32 *ptrlen;
-  const u8 *tempptr;
-  u32 temp32;
-  
-  va_start( ap, fmt );
-  remotefs_err_flag = REMOTEFS_OK;
-  p = remotefs_match_packet_start( p );
-  while( *fmt )
-    switch( *fmt ++ )
-    {
-      case 'o':
-        p = remotefs_expect_op_id( p, va_arg( ap, int ) );
-        break;
-        
-      case 'r':
-        p = remotefs_read_expect( p, RFS_OP_RES_MOD | ( u8 )va_arg( ap, int ) );
-        break;
-        
-      case 'c':
-        p = remotefs_read_u8( p, ( u8* )va_arg( ap, void* ) );
-        break;
-        
-      case 'h':
-        p = remotefs_read_u16( p, ( u16* )va_arg( ap, void* ) );
-        break;
-        
-      case 'l':
-        p = remotefs_read_u32( p, ( u32* )va_arg( ap, void* ) );
-        break;     
-
-      case 'L':
-        p = remotefs_read_u32( p, &amp;temp32 );        
-        *( s32 *)va_arg( ap, void* ) = ( s32 )temp32;
-        break;     
-        
-      case 'i':
-        p = remotefs_read_u32( p, &amp;temp32 );
-        *( int* )va_arg( ap, void* ) = ( int )temp32;        
-        break;     
-      
-      case 'p':
-        pptr = va_arg( ap, void** );
-        ptrlen = va_arg( ap, void* );
-        tempptr = p;
-        p = remotefs_read_ptr( p, NULL, &amp;temp32 );
-        if( p == tempptr + RFS_PTR_HEADER_SIZE )
-          *( const u8** )pptr = NULL;
-        else
-          *( const u8** )pptr = tempptr + RFS_PTR_HEADER_SIZE;
-        if( ptrlen )
-          *ptrlen = temp32;        
-        break;
-    }
-  remotefs_match_packet_end( p );  
-  return remotefs_err_flag;
-}
-
-
-// *****************************************************************************
 // Operation: open
 // open: int open( const char *pathname,int flags, mode_t mode )
 
 void remotefs_open_write_response( u8 *p, int result )
 {
-  remotefs_gen_write( p, &quot;ri&quot;, RFS_OP_OPEN, result );
+  eluarpc_gen_write( p, &quot;ri&quot;, RFS_OP_OPEN, result );
 }
 
 int remotefs_open_read_response( const u8 *p, int *presult )
 {
-  return remotefs_gen_read( p, &quot;ri&quot;, RFS_OP_OPEN, presult );  
+  return eluarpc_gen_read( p, &quot;ri&quot;, RFS_OP_OPEN, presult );  
 }
 
 void remotefs_open_write_request( u8 *p, const char* pathname, int flags, int mode )
 {
-  remotefs_gen_write( p, &quot;opii&quot;, RFS_OP_OPEN, pathname, strlen( pathname ) + 1, flags, mode );
+  eluarpc_gen_write( p, &quot;opii&quot;, RFS_OP_OPEN, pathname, strlen( pathname ) + 1, flags, mode );
 }
 
 int remotefs_open_read_request( const u8 *p, const char **ppathname, int *pflags, int *pmode )
 {  
-  return remotefs_gen_read( p, &quot;opii&quot;, RFS_OP_OPEN, ppathname, NULL, pflags, pmode );  
+  return eluarpc_gen_read( p, &quot;opii&quot;, RFS_OP_OPEN, ppathname, NULL, pflags, pmode );  
 }  
 
 // *****************************************************************************
@@ -346,22 +37,22 @@
  
 void remotefs_write_write_response( u8 *p, u32 result )
 {                                                   
-  remotefs_gen_write( p, &quot;rl&quot;, RFS_OP_WRITE, result );  
+  eluarpc_gen_write( p, &quot;rl&quot;, RFS_OP_WRITE, result );  
 }
 
 int remotefs_write_read_response( const u8 *p, u32 *presult )
 {
-  return remotefs_gen_read( p, &quot;rl&quot;, RFS_OP_WRITE, presult );  
+  return eluarpc_gen_read( p, &quot;rl&quot;, RFS_OP_WRITE, presult );  
 }
 
 void remotefs_write_write_request( u8 *p, int fd, const void *buf, u32 count )
 {
-  remotefs_gen_write( p, &quot;oip&quot;, RFS_OP_WRITE, fd, buf, count ); 
+  eluarpc_gen_write( p, &quot;oip&quot;, RFS_OP_WRITE, fd, buf, count ); 
 }
 
 int remotefs_write_read_request( const u8 *p, int *pfd, const void **pbuf, u32 *pcount )
 {
-  return remotefs_gen_read( p, &quot;oip&quot;, RFS_OP_WRITE, pfd, pbuf, pcount );  
+  return eluarpc_gen_read( p, &quot;oip&quot;, RFS_OP_WRITE, pfd, pbuf, pcount );  
 }
 
 // *****************************************************************************
@@ -370,22 +61,22 @@
 
 void remotefs_read_write_response( u8 *p, u32 readbytes )
 {
-  remotefs_gen_write( p, &quot;rp&quot;, RFS_OP_READ, NULL, readbytes );  
+  eluarpc_gen_write( p, &quot;rp&quot;, RFS_OP_READ, NULL, readbytes );  
 }
 
 int remotefs_read_read_response( const u8 *p, const u8 **ppdata, u32 *preadbytes )
 {
-  return remotefs_gen_read( p, &quot;rp&quot;, RFS_OP_READ, ppdata, preadbytes );  
+  return eluarpc_gen_read( p, &quot;rp&quot;, RFS_OP_READ, ppdata, preadbytes );  
 }
 
 void remotefs_read_write_request( u8 *p, int fd, u32 count )
 {
-  remotefs_gen_write( p, &quot;oil&quot;, RFS_OP_READ, fd, count ); 
+  eluarpc_gen_write( p, &quot;oil&quot;, RFS_OP_READ, fd, count ); 
 }
 
 int remotefs_read_read_request( const u8 *p, int *pfd, u32 *pcount )
 {
-  return remotefs_gen_read( p, &quot;oil&quot;, RFS_OP_READ, pfd, pcount );    
+  return eluarpc_gen_read( p, &quot;oil&quot;, RFS_OP_READ, pfd, pcount );    
 }
   
 // *****************************************************************************
@@ -394,22 +85,22 @@
   
 void remotefs_close_write_response( u8 *p, int result )
 {
-  remotefs_gen_write( p, &quot;ri&quot;, RFS_OP_CLOSE, result );  
+  eluarpc_gen_write( p, &quot;ri&quot;, RFS_OP_CLOSE, result );  
 }
 
 int remotefs_close_read_response( const u8 *p, int *presult )
 {
-  return remotefs_gen_read( p, &quot;ri&quot;, RFS_OP_CLOSE, presult );   
+  return eluarpc_gen_read( p, &quot;ri&quot;, RFS_OP_CLOSE, presult );   
 }
 
 void remotefs_close_write_request( u8 *p, int fd )
 {
-  remotefs_gen_write( p, &quot;oi&quot;, RFS_OP_CLOSE, fd ); 
+  eluarpc_gen_write( p, &quot;oi&quot;, RFS_OP_CLOSE, fd ); 
 }
 
 int remotefs_close_read_request( const u8 *p, int *pfd )
 {
-  return remotefs_gen_read( p, &quot;oi&quot;, RFS_OP_CLOSE, pfd );  
+  return eluarpc_gen_read( p, &quot;oi&quot;, RFS_OP_CLOSE, pfd );  
 }
 
 // *****************************************************************************
@@ -418,22 +109,22 @@
 
 void remotefs_lseek_write_response( u8 *p, s32 result )
 {
-  remotefs_gen_write( p, &quot;rL&quot;, RFS_OP_LSEEK, result );
+  eluarpc_gen_write( p, &quot;rL&quot;, RFS_OP_LSEEK, result );
 }
 
 int remotefs_lseek_read_response( const u8 *p, s32 *presult )
 {
-  return remotefs_gen_read( p, &quot;rL&quot;, RFS_OP_LSEEK, presult );   
+  return eluarpc_gen_read( p, &quot;rL&quot;, RFS_OP_LSEEK, presult );   
 }
 
 void remotefs_lseek_write_request( u8 *p, int fd, s32 offset, int whence )
 {
-  remotefs_gen_write( p, &quot;oiLi&quot;, RFS_OP_LSEEK, fd, offset, whence ); 
+  eluarpc_gen_write( p, &quot;oiLi&quot;, RFS_OP_LSEEK, fd, offset, whence ); 
 }
 
 int remotefs_lseek_read_request( const u8 *p, int *pfd, s32 *poffset, int *pwhence )
 {
-  return remotefs_gen_read( p, &quot;oiLi&quot;, RFS_OP_LSEEK, pfd, poffset, pwhence );
+  return eluarpc_gen_read( p, &quot;oiLi&quot;, RFS_OP_LSEEK, pfd, poffset, pwhence );
 }
 
 // ****************************************************************************
@@ -442,22 +133,22 @@
 
 void remotefs_opendir_write_response( u8 *p, u32 d )
 {
-  remotefs_gen_write( p, &quot;rl&quot;, RFS_OP_OPENDIR, d );
+  eluarpc_gen_write( p, &quot;rl&quot;, RFS_OP_OPENDIR, d );
 }
 
 int remotefs_opendir_read_response( const u8 *p, u32 *pd )
 {
-  return remotefs_gen_read( p, &quot;rl&quot;, RFS_OP_OPENDIR, pd );
+  return eluarpc_gen_read( p, &quot;rl&quot;, RFS_OP_OPENDIR, pd );
 }
 
 void remotefs_opendir_write_request( u8 *p, const char* name )
 {
-  remotefs_gen_write( p, &quot;op&quot;, RFS_OP_OPENDIR, name, strlen( name ) + 1 );
+  eluarpc_gen_write( p, &quot;op&quot;, RFS_OP_OPENDIR, name, strlen( name ) + 1 );
 }
 
 int remotefs_opendir_read_request( const u8 *p, const char **pname )
 {
-  return remotefs_gen_read( p, &quot;op&quot;, RFS_OP_OPENDIR, pname, NULL );
+  return eluarpc_gen_read( p, &quot;op&quot;, RFS_OP_OPENDIR, pname, NULL );
 }
 
 // ****************************************************************************
@@ -467,22 +158,22 @@
 
 void remotefs_readdir_write_response( u8 *p, const char *name, u32 size, u32 ftime )
 {
-  remotefs_gen_write( p, &quot;rpll&quot;, RFS_OP_READDIR, name, name ? strlen( name ) + 1 : 0, size, ftime );
+  eluarpc_gen_write( p, &quot;rpll&quot;, RFS_OP_READDIR, name, name ? strlen( name ) + 1 : 0, size, ftime );
 }
 
 int remotefs_readdir_read_response( const u8 *p, const char **pname, u32 *psize, u32 *pftime )
 {
-  return remotefs_gen_read( p, &quot;rpll&quot;,  RFS_OP_READDIR, pname, NULL, psize, pftime );
+  return eluarpc_gen_read( p, &quot;rpll&quot;,  RFS_OP_READDIR, pname, NULL, psize, pftime );
 }
 
 void remotefs_readdir_write_request( u8 *p, u32 d )
 {
-  remotefs_gen_write( p, &quot;ol&quot;, RFS_OP_READDIR, d );
+  eluarpc_gen_write( p, &quot;ol&quot;, RFS_OP_READDIR, d );
 }
 
 int remotefs_readdir_read_request( const u8 *p, u32 *pd )
 {
-  return remotefs_gen_read( p, &quot;ol&quot;, RFS_OP_READDIR, pd );
+  return eluarpc_gen_read( p, &quot;ol&quot;, RFS_OP_READDIR, pd );
 }
 
 // ****************************************************************************
@@ -491,22 +182,22 @@
 
 void remotefs_closedir_write_response( u8 *p, int d )
 {
-  remotefs_gen_write( p, &quot;ri&quot;, RFS_OP_CLOSEDIR, d );
+  eluarpc_gen_write( p, &quot;ri&quot;, RFS_OP_CLOSEDIR, d );
 }
 
 int remotefs_closedir_read_response( const u8 *p, int *pd )
 {
-  return remotefs_gen_read( p, &quot;ri&quot;, RFS_OP_CLOSEDIR, pd );
+  return eluarpc_gen_read( p, &quot;ri&quot;, RFS_OP_CLOSEDIR, pd );
 }
 
 void remotefs_closedir_write_request( u8 *p, u32 d )
 {
-  remotefs_gen_write( p, &quot;ol&quot;, RFS_OP_CLOSEDIR, d );
+  eluarpc_gen_write( p, &quot;ol&quot;, RFS_OP_CLOSEDIR, d );
 }
 
 int remotefs_closedir_read_request( const u8 *p, u32 *pd )
 {
-  return remotefs_gen_read( p, &quot;ol&quot;, RFS_OP_CLOSEDIR, pd );
+  return eluarpc_gen_read( p, &quot;ol&quot;, RFS_OP_CLOSEDIR, pd );
 }
 
 

Modified: trunk/src/shell.c
===================================================================
--- trunk/src/shell.c	2011-01-10 00:08:13 UTC (rev 880)
+++ trunk/src/shell.c	2011-01-16 00:23:19 UTC (rev 881)
@@ -12,9 +12,12 @@
 #include &quot;platform.h&quot;
 #include &quot;elua_net.h&quot;
 #include &quot;devman.h&quot;
+#include &quot;buf.h&quot;
+#include &quot;remotefs.h&quot;
+#include &quot;eluarpc.h&quot;
 #include &quot;linenoise.h&quot;
+
 #include &quot;platform_conf.h&quot;
-
 #ifdef BUILD_SHELL
 
 // Shell alternate ' ' char
@@ -54,6 +57,7 @@
   printf( &quot;  cat or type - lists file contents\n&quot; );
   printf( &quot;  lua [args]  - run Lua with the given arguments\n&quot; );
   printf( &quot;  recv        - receive a file via XMODEM and execute it\n&quot; );
+  printf( &quot;  cp &lt;src&gt; &lt;dst&gt; - copy source file 'src' to 'dst'\n&quot; );
   printf( &quot;  ver         - print eLua version\n&quot; );
 }
 
@@ -235,6 +239,71 @@
       printf( &quot;Usage: cat (or type) &lt;filename1&gt; [&lt;filename2&gt; ...]\n&quot; );
 }    
 
+// 'copy' handler
+#ifdef BUILD_RFS
+#define SHELL_COPY_BUFSIZE    ( ( 1 &lt;&lt; RFS_BUFFER_SIZE ) - ELUARPC_WRITE_REQUEST_EXTRA )
+#else
+#define SHELL_COPY_BUFSIZE    256
+#endif
+static void shell_cp( char *args )
+{
+  char *p1, *p2;
+  int res = 0;
+  FILE *fps = NULL, *fpd = NULL;
+  void *buf = NULL;
+  size_t datalen, total = 0;
+
+  if( *args )
+  {
+    p1 = strchr( args, ' ' );
+    if( p1 )
+    {
+      *p1 = 0;
+      p2 = strchr( p1 + 1, ' ' );
+      if( p2 )
+      {
+        *p2 = 0;
+        // First file is at args, second one at p1 + 1
+        if( ( fps = fopen( args, &quot;rb&quot; ) ) == NULL )
+          printf( &quot;Unable to open %s for reading\n&quot;, args );
+        else
+        {
+          if( ( fpd = fopen( p1 + 1, &quot;wb&quot; ) ) == NULL )
+            printf( &quot;Unable to open %s for writing\n&quot;, p1 + 1 );
+          else
+          {
+            // Alloc memory
+            if( ( buf = malloc( SHELL_COPY_BUFSIZE ) ) == NULL )
+              printf( &quot;Not enough memory\n&quot; );
+            else
+            {
+              // Do the actual copy
+              while( 1 )
+              {
+                datalen = fread( buf, 1, SHELL_COPY_BUFSIZE, fps );
+                fwrite( buf, 1, datalen, fpd );
+                total += datalen;
+                if( datalen &lt; SHELL_COPY_BUFSIZE )
+                  break;
+              }
+              printf( &quot;%u bytes copied\n&quot;, ( unsigned int )total );
+              res = 1;
+            }
+          }
+        } 
+      }
+    }
+  }
+  if( !res )
+    printf( &quot;Syntax error.\n&quot; );
+  if( fps )
+    fclose( fps );
+  if( fpd )
+    fclose( fpd );
+  if( buf )
+    free( buf );
+}
+
 // Insert shell commands here
 static const SHELL_COMMAND shell_commands[] =
 {
@@ -247,6 +316,7 @@
   { &quot;dir&quot;, shell_ls },
   { &quot;cat&quot;, shell_cat },
   { &quot;type&quot;, shell_cat },
+  { &quot;cp&quot;, shell_cp },
   { NULL, NULL }
 };
 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000833.html">[Elua-svn] r880 - trunk
</A></li>
	<LI>Next message: <A HREF="000835.html">[Elua-svn] r882 - trunk/src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#834">[ date ]</a>
              <a href="thread.html#834">[ thread ]</a>
              <a href="subject.html#834">[ subject ]</a>
              <a href="author.html#834">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/elua-svn">More information about the eLua-svn
mailing list</a><br>
</body></html>
