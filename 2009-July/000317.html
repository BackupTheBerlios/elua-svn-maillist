<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Elua-svn] r354 - in trunk/src/platform/stm32: . FWLib/library	FWLib/library/inc FWLib/library/src
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/elua-svn/2009-July/index.html" >
   <LINK REL="made" HREF="mailto:elua-svn%40lists.berlios.de?Subject=Re%3A%20%5BElua-svn%5D%20r354%20-%20in%20trunk/src/platform/stm32%3A%20.%20FWLib/library%0A%09FWLib/library/inc%20FWLib/library/src&In-Reply-To=%3C200907082339.n68NdfgK021191%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000309.html">
   <LINK REL="Next"  HREF="000310.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Elua-svn] r354 - in trunk/src/platform/stm32: . FWLib/library	FWLib/library/inc FWLib/library/src</H1>
    <B>jbsnyder at BerliOS</B> 
    <A HREF="mailto:elua-svn%40lists.berlios.de?Subject=Re%3A%20%5BElua-svn%5D%20r354%20-%20in%20trunk/src/platform/stm32%3A%20.%20FWLib/library%0A%09FWLib/library/inc%20FWLib/library/src&In-Reply-To=%3C200907082339.n68NdfgK021191%40sheep.berlios.de%3E"
       TITLE="[Elua-svn] r354 - in trunk/src/platform/stm32: . FWLib/library	FWLib/library/inc FWLib/library/src">jbsnyder at mail.berlios.de
       </A><BR>
    <I>Thu Jul  9 01:39:41 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="000309.html">[Elua-svn] r353 - trunk/src/modules
</A></li>
        <LI>Next message: <A HREF="000310.html">[Elua-svn] r355 - trunk/src/platform/stm32/FWLib/library/src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#317">[ date ]</a>
              <a href="thread.html#317">[ thread ]</a>
              <a href="subject.html#317">[ subject ]</a>
              <a href="author.html#317">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: jbsnyder
Date: 2009-07-09 01:39:34 +0200 (Thu, 09 Jul 2009)
New Revision: 354

Added:
   trunk/src/platform/stm32/FWLib/library/.DS_Store
   trunk/src/platform/stm32/FWLib/library/inc/misc.h
   trunk/src/platform/stm32/FWLib/library/src/misc.c
   trunk/src/platform/stm32/FWLib/library/src/misc.o
   trunk/src/platform/stm32/FWLib/library/src/stm32f10x_adc.o
   trunk/src/platform/stm32/FWLib/library/src/stm32f10x_bkp.o
   trunk/src/platform/stm32/FWLib/library/src/stm32f10x_can.o
   trunk/src/platform/stm32/FWLib/library/src/stm32f10x_crc.o
   trunk/src/platform/stm32/FWLib/library/src/stm32f10x_dac.o
   trunk/src/platform/stm32/FWLib/library/src/stm32f10x_dbgmcu.o
   trunk/src/platform/stm32/FWLib/library/src/stm32f10x_dma.o
   trunk/src/platform/stm32/FWLib/library/src/stm32f10x_exti.o
   trunk/src/platform/stm32/FWLib/library/src/stm32f10x_flash.o
   trunk/src/platform/stm32/FWLib/library/src/stm32f10x_fsmc.o
   trunk/src/platform/stm32/FWLib/library/src/stm32f10x_gpio.o
   trunk/src/platform/stm32/FWLib/library/src/stm32f10x_i2c.o
   trunk/src/platform/stm32/FWLib/library/src/stm32f10x_iwdg.o
   trunk/src/platform/stm32/FWLib/library/src/stm32f10x_pwr.o
   trunk/src/platform/stm32/FWLib/library/src/stm32f10x_rcc.o
   trunk/src/platform/stm32/FWLib/library/src/stm32f10x_rtc.o
   trunk/src/platform/stm32/FWLib/library/src/stm32f10x_sdio.o
   trunk/src/platform/stm32/FWLib/library/src/stm32f10x_spi.o
   trunk/src/platform/stm32/FWLib/library/src/stm32f10x_tim.o
   trunk/src/platform/stm32/FWLib/library/src/stm32f10x_usart.o
   trunk/src/platform/stm32/FWLib/library/src/stm32f10x_wwdg.o
   trunk/src/platform/stm32/core_cm3.c
   trunk/src/platform/stm32/core_cm3.h
   trunk/src/platform/stm32/system_stm32f10x.c
   trunk/src/platform/stm32/system_stm32f10x.h
Removed:
   trunk/src/platform/stm32/FWLib/library/inc/cortexm3_macro.h
   trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_lib.h
   trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_map.h
   trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_nvic.h
   trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_systick.h
   trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_type.h
   trunk/src/platform/stm32/FWLib/library/src/stm32f10x_lib.c
   trunk/src/platform/stm32/FWLib/library/src/stm32f10x_nvic.c
   trunk/src/platform/stm32/FWLib/library/src/stm32f10x_systick.c
   trunk/src/platform/stm32/stm32f10x_vector.c
Modified:
   trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_adc.h
   trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_bkp.h
   trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_can.h
   trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_crc.h
   trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_dac.h
   trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_dbgmcu.h
   trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_dma.h
   trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_exti.h
   trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_flash.h
   trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_fsmc.h
   trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_gpio.h
   trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_i2c.h
   trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_iwdg.h
   trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_pwr.h
   trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_rcc.h
   trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_rtc.h
   trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_sdio.h
   trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_spi.h
   trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_tim.h
   trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_usart.h
   trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_wwdg.h
   trunk/src/platform/stm32/FWLib/library/src/stm32f10x_adc.c
   trunk/src/platform/stm32/FWLib/library/src/stm32f10x_bkp.c
   trunk/src/platform/stm32/FWLib/library/src/stm32f10x_can.c
   trunk/src/platform/stm32/FWLib/library/src/stm32f10x_crc.c
   trunk/src/platform/stm32/FWLib/library/src/stm32f10x_dac.c
   trunk/src/platform/stm32/FWLib/library/src/stm32f10x_dbgmcu.c
   trunk/src/platform/stm32/FWLib/library/src/stm32f10x_dma.c
   trunk/src/platform/stm32/FWLib/library/src/stm32f10x_exti.c
   trunk/src/platform/stm32/FWLib/library/src/stm32f10x_flash.c
   trunk/src/platform/stm32/FWLib/library/src/stm32f10x_fsmc.c
   trunk/src/platform/stm32/FWLib/library/src/stm32f10x_gpio.c
   trunk/src/platform/stm32/FWLib/library/src/stm32f10x_i2c.c
   trunk/src/platform/stm32/FWLib/library/src/stm32f10x_iwdg.c
   trunk/src/platform/stm32/FWLib/library/src/stm32f10x_pwr.c
   trunk/src/platform/stm32/FWLib/library/src/stm32f10x_rcc.c
   trunk/src/platform/stm32/FWLib/library/src/stm32f10x_rtc.c
   trunk/src/platform/stm32/FWLib/library/src/stm32f10x_sdio.c
   trunk/src/platform/stm32/FWLib/library/src/stm32f10x_spi.c
   trunk/src/platform/stm32/FWLib/library/src/stm32f10x_tim.c
   trunk/src/platform/stm32/FWLib/library/src/stm32f10x_usart.c
   trunk/src/platform/stm32/FWLib/library/src/stm32f10x_wwdg.c
   trunk/src/platform/stm32/conf.py
   trunk/src/platform/stm32/fonts.h
   trunk/src/platform/stm32/lcd.h
   trunk/src/platform/stm32/platform.c
   trunk/src/platform/stm32/platform_conf.h
   trunk/src/platform/stm32/stm32.ld
   trunk/src/platform/stm32/stm32f10x_conf.h
   trunk/src/platform/stm32/stm32f10x_it.c
   trunk/src/platform/stm32/stm32f10x_it.h
   trunk/src/platform/stm32/systick.c
   trunk/src/platform/stm32/systick.h
   trunk/src/platform/stm32/type.h
Log:
Updated library to STM32 FWlib 3.1.
PWM support integrated, but not fully working.

Added: trunk/src/platform/stm32/FWLib/library/.DS_Store
===================================================================
--- trunk/src/platform/stm32/FWLib/library/.DS_Store	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/.DS_Store	2009-07-08 23:39:34 UTC (rev 354)
@@ -0,0 +1 @@
+



\ No newline at end of file

Deleted: trunk/src/platform/stm32/FWLib/library/inc/cortexm3_macro.h
===================================================================
--- trunk/src/platform/stm32/FWLib/library/inc/cortexm3_macro.h	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/inc/cortexm3_macro.h	2009-07-08 23:39:34 UTC (rev 354)
@@ -1,53 +0,0 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : cortexm3_macro.h
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : Header file for cortexm3_macro.s.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
-
-/* Define to prevent recursive inclusion -------------------------------------*/
-#ifndef __CORTEXM3_MACRO_H
-#define __CORTEXM3_MACRO_H
-
-/* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_type.h&quot;
-
-/* Exported types ------------------------------------------------------------*/
-/* Exported constants --------------------------------------------------------*/
-/* Exported macro ------------------------------------------------------------*/
-/* Exported functions ------------------------------------------------------- */
-void __WFI(void);
-void __WFE(void);
-void __SEV(void);
-void __ISB(void);
-void __DSB(void);
-void __DMB(void);
-void __SVC(void);
-u32 __MRS_CONTROL(void);
-void __MSR_CONTROL(u32 Control);
-u32 __MRS_PSP(void);
-void __MSR_PSP(u32 TopOfProcessStack);
-u32 __MRS_MSP(void);
-void __MSR_MSP(u32 TopOfMainStack);
-void __RESETPRIMASK(void);
-void __SETPRIMASK(void);
-u32 __READ_PRIMASK(void);
-void __RESETFAULTMASK(void);
-void __SETFAULTMASK(void);
-u32 __READ_FAULTMASK(void);
-void __BASEPRICONFIG(u32 NewPriority);
-u32 __GetBASEPRI(void);
-u16 __REV_HalfWord(u16 Data);
-u32 __REV_Word(u32 Data);
-
-#endif /* __CORTEXM3_MACRO_H */
-
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/

Added: trunk/src/platform/stm32/FWLib/library/inc/misc.h
===================================================================
--- trunk/src/platform/stm32/FWLib/library/inc/misc.h	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/inc/misc.h	2009-07-08 23:39:34 UTC (rev 354)
@@ -0,0 +1,219 @@
+/**
+  ******************************************************************************
+  * @file    misc.h
+  * @author  MCD Application Team
+  * @version V3.1.0
+  * @date    06/19/2009
+  * @brief   This file contains all the functions prototypes for the miscellaneous
+  *          firmware library functions (add-on to CMSIS functions).
+  ******************************************************************************
+  * @copy
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * &lt;h2&gt;&lt;center&gt;&copy; COPYRIGHT 2009 STMicroelectronics&lt;/center&gt;&lt;/h2&gt;
+  */ 
+
+/* Define to prevent recursive inclusion -------------------------------------*/
+#ifndef __MISC_H
+#define __MISC_H
+
+#ifdef __cplusplus
+ extern &quot;C&quot; {
+#endif
+
+/* Includes ------------------------------------------------------------------*/
+#include &quot;stm32f10x.h&quot;
+
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @addtogroup MISC
+  * @{
+  */
+
+/** @defgroup MISC_Exported_Types
+  * @{
+  */
+
+/** 
+  * @brief  NVIC Init Structure definition  
+  */
+
+typedef struct
+{
+  uint8_t NVIC_IRQChannel;                    /*!&lt; Specifies the IRQ channel to be enabled or disabled.
+                                                   This parameter can be a value of @ref IRQn_Type 
+                                                   (For the complete STM32 Devices IRQ Channels list, please
+                                                    refer to stm32f10x.h file) */
+
+  uint8_t NVIC_IRQChannelPreemptionPriority;  /*!&lt; Specifies the pre-emption priority for the IRQ channel
+                                                   specified in NVIC_IRQChannel. This parameter can be a value
+                                                   between 0 and 15 as described in the table @ref NVIC_Priority_Table */
+
+  uint8_t NVIC_IRQChannelSubPriority;         /*!&lt; Specifies the subpriority level for the IRQ channel specified
+                                                   in NVIC_IRQChannel. This parameter can be a value
+                                                   between 0 and 15 as described in the table @ref NVIC_Priority_Table */
+
+  FunctionalState NVIC_IRQChannelCmd;         /*!&lt; Specifies whether the IRQ channel defined in NVIC_IRQChannel
+                                                   will be enabled or disabled. 
+                                                   This parameter can be set either to ENABLE or DISABLE */   
+} NVIC_InitTypeDef;
+ 
+/**
+  * @}
+  */
+
+/** @defgroup NVIC_Priority_Table 
+  * @{
+  */
+
+/**
<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">+ at code</A>  
+ The table below gives the allowed values of the pre-emption priority and subpriority according
+ to the Priority Grouping configuration performed by NVIC_PriorityGroupConfig function
+  ============================================================================================================================
+    NVIC_PriorityGroup   | NVIC_IRQChannelPreemptionPriority | NVIC_IRQChannelSubPriority  | Description
+  ============================================================================================================================
+   NVIC_PriorityGroup_0  |                0                  |            0-15             |   0 bits for pre-emption priority
+                         |                                   |                             |   4 bits for subpriority
+  ----------------------------------------------------------------------------------------------------------------------------
+   NVIC_PriorityGroup_1  |                0-1                |            0-7              |   1 bits for pre-emption priority
+                         |                                   |                             |   3 bits for subpriority
+  ----------------------------------------------------------------------------------------------------------------------------    
+   NVIC_PriorityGroup_2  |                0-3                |            0-3              |   2 bits for pre-emption priority
+                         |                                   |                             |   2 bits for subpriority
+  ----------------------------------------------------------------------------------------------------------------------------    
+   NVIC_PriorityGroup_3  |                0-7                |            0-1              |   3 bits for pre-emption priority
+                         |                                   |                             |   1 bits for subpriority
+  ----------------------------------------------------------------------------------------------------------------------------    
+   NVIC_PriorityGroup_4  |                0-15               |            0                |   4 bits for pre-emption priority
+                         |                                   |                             |   0 bits for subpriority                       
+  ============================================================================================================================
<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">+ at endcode</A>
+*/
+
+/**
+  * @}
+  */
+
+/** @defgroup MISC_Exported_Constants
+  * @{
+  */
+
+/** @defgroup Vector_Table_Base 
+  * @{
+  */
+
+#define NVIC_VectTab_RAM             ((uint32_t)0x20000000)
+#define NVIC_VectTab_FLASH           ((uint32_t)0x08000000)
+#define IS_NVIC_VECTTAB(VECTTAB) (((VECTTAB) == NVIC_VectTab_RAM) || \
+                                  ((VECTTAB) == NVIC_VectTab_FLASH))
+/**
+  * @}
+  */
+
+/** @defgroup System_Low_Power 
+  * @{
+  */
+
+#define NVIC_LP_SEVONPEND            ((uint8_t)0x10)
+#define NVIC_LP_SLEEPDEEP            ((uint8_t)0x04)
+#define NVIC_LP_SLEEPONEXIT          ((uint8_t)0x02)
+#define IS_NVIC_LP(LP) (((LP) == NVIC_LP_SEVONPEND) || \
+                        ((LP) == NVIC_LP_SLEEPDEEP) || \
+                        ((LP) == NVIC_LP_SLEEPONEXIT))
+/**
+  * @}
+  */
+
+/** @defgroup Preemption_Priority_Group 
+  * @{
+  */
+
+#define NVIC_PriorityGroup_0         ((uint32_t)0x700) /*!&lt; 0 bits for pre-emption priority
+                                                            4 bits for subpriority */
+#define NVIC_PriorityGroup_1         ((uint32_t)0x600) /*!&lt; 1 bits for pre-emption priority
+                                                            3 bits for subpriority */
+#define NVIC_PriorityGroup_2         ((uint32_t)0x500) /*!&lt; 2 bits for pre-emption priority
+                                                            2 bits for subpriority */
+#define NVIC_PriorityGroup_3         ((uint32_t)0x400) /*!&lt; 3 bits for pre-emption priority
+                                                            1 bits for subpriority */
+#define NVIC_PriorityGroup_4         ((uint32_t)0x300) /*!&lt; 4 bits for pre-emption priority
+                                                            0 bits for subpriority */
+
+#define IS_NVIC_PRIORITY_GROUP(GROUP) (((GROUP) == NVIC_PriorityGroup_0) || \
+                                       ((GROUP) == NVIC_PriorityGroup_1) || \
+                                       ((GROUP) == NVIC_PriorityGroup_2) || \
+                                       ((GROUP) == NVIC_PriorityGroup_3) || \
+                                       ((GROUP) == NVIC_PriorityGroup_4))
+
+#define IS_NVIC_PREEMPTION_PRIORITY(PRIORITY)  ((PRIORITY) &lt; 0x10)
+
+#define IS_NVIC_SUB_PRIORITY(PRIORITY)  ((PRIORITY) &lt; 0x10)
+
+#define IS_NVIC_OFFSET(OFFSET)  ((OFFSET) &lt; 0x0007FFFF)
+
+/**
+  * @}
+  */
+
+/** @defgroup SysTick_clock_source 
+  * @{
+  */
+
+#define SysTick_CLKSource_HCLK_Div8    ((uint32_t)0xFFFFFFFB)
+#define SysTick_CLKSource_HCLK         ((uint32_t)0x00000004)
+#define IS_SYSTICK_CLK_SOURCE(SOURCE) (((SOURCE) == SysTick_CLKSource_HCLK) || \
+                                       ((SOURCE) == SysTick_CLKSource_HCLK_Div8))
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup MISC_Exported_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup MISC_Exported_Functions
+  * @{
+  */
+
+void NVIC_PriorityGroupConfig(uint32_t NVIC_PriorityGroup);
+void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct);
+void NVIC_SetVectorTable(uint32_t NVIC_VectTab, uint32_t Offset);
+void NVIC_SystemLPConfig(uint8_t LowPowerMode, FunctionalState NewState);
+void SysTick_CLKSourceConfig(uint32_t SysTick_CLKSource);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __MISC_H */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2009 STMicroelectronics *****END OF FILE****/


Property changes on: trunk/src/platform/stm32/FWLib/library/inc/misc.h
___________________________________________________________________
Name: svn:executable
   + *

Modified: trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_adc.h
===================================================================
--- trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_adc.h	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_adc.h	2009-07-08 23:39:34 UTC (rev 354)
@@ -1,58 +1,106 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_adc.h
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file contains all the functions prototypes for the
-*                      ADC firmware library.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
+/**
+  ******************************************************************************
+  * @file    stm32f10x_adc.h
+  * @author  MCD Application Team
+  * @version V3.1.0
+  * @date    06/19/2009
+  * @brief   This file contains all the functions prototypes for the ADC firmware 
+  *          library.
+  ******************************************************************************
+  * @copy
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * &lt;h2&gt;&lt;center&gt;&copy; COPYRIGHT 2009 STMicroelectronics&lt;/center&gt;&lt;/h2&gt;
+  */ 
 
 /* Define to prevent recursive inclusion -------------------------------------*/
 #ifndef __STM32F10x_ADC_H
 #define __STM32F10x_ADC_H
 
+#ifdef __cplusplus
+ extern &quot;C&quot; {
+#endif
+
 /* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_map.h&quot;
+#include &quot;stm32f10x.h&quot;
 
-/* Exported types ------------------------------------------------------------*/
-/* ADC Init structure definition */
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @addtogroup ADC
+  * @{
+  */
+
+/** @defgroup ADC_Exported_Types
+  * @{
+  */
+
+/** 
+  * @brief  ADC Init structure definition  
+  */
+
 typedef struct
 {
-  u32 ADC_Mode;
-  FunctionalState ADC_ScanConvMode; 
-  FunctionalState ADC_ContinuousConvMode;
-  u32 ADC_ExternalTrigConv;
-  u32 ADC_DataAlign;
-  u8 ADC_NbrOfChannel;
+  uint32_t ADC_Mode;                      /*!&lt; Configures the ADC to operate in independent or
+                                               dual mode. 
+                                               This parameter can be a value of @ref ADC_mode */
+
+  FunctionalState ADC_ScanConvMode;       /*!&lt; Specifies whether the conversion is performed in
+                                               Scan (multichannels) or Single (one channel) mode.
+                                               This parameter can be set to ENABLE or DISABLE */
+
+  FunctionalState ADC_ContinuousConvMode; /*!&lt; Specifies whether the conversion is performed in
+                                               Continuous or Single mode.
+                                               This parameter can be set to ENABLE or DISABLE. */
+
+  uint32_t ADC_ExternalTrigConv;          /*!&lt; Defines the external trigger used to start the analog
+                                               to digital conversion of regular channels. This parameter
+                                               can be a value of @ref ADC_external_trigger_sources_for_regular_channels_conversion */
+
+  uint32_t ADC_DataAlign;                 /*!&lt; Specifies whether the ADC data alignment is left or right.
+                                               This parameter can be a value of @ref ADC_data_align */
+
+  uint8_t ADC_NbrOfChannel;               /*!&lt; Specifies the number of ADC channels that will be converted
+                                               using the sequencer for regular channel group.
+                                               This parameter must range from 1 to 16. */
 }ADC_InitTypeDef;
+/**
+  * @}
+  */
 
-/* Exported constants --------------------------------------------------------*/
-#define IS_ADC_ALL_PERIPH(PERIPH) (((*(u32*)&amp;(PERIPH)) == ADC1_BASE) || \
-                                   ((*(u32*)&amp;(PERIPH)) == ADC2_BASE) || \
-                                   ((*(u32*)&amp;(PERIPH)) == ADC3_BASE))
-                                 
-#define IS_ADC_DMA_PERIPH(PERIPH) (((*(u32*)&amp;(PERIPH)) == ADC1_BASE) || \
-                                   ((*(u32*)&amp;(PERIPH)) == ADC3_BASE))
+/** @defgroup ADC_Exported_Constants
+  * @{
+  */
 
-/* ADC dual mode -------------------------------------------------------------*/
-#define ADC_Mode_Independent                       ((u32)0x00000000)
-#define ADC_Mode_RegInjecSimult                    ((u32)0x00010000)
-#define ADC_Mode_RegSimult_AlterTrig               ((u32)0x00020000)
-#define ADC_Mode_InjecSimult_FastInterl            ((u32)0x00030000)
-#define ADC_Mode_InjecSimult_SlowInterl            ((u32)0x00040000)
-#define ADC_Mode_InjecSimult                       ((u32)0x00050000)
-#define ADC_Mode_RegSimult                         ((u32)0x00060000)
-#define ADC_Mode_FastInterl                        ((u32)0x00070000)
-#define ADC_Mode_SlowInterl                        ((u32)0x00080000)
-#define ADC_Mode_AlterTrig                         ((u32)0x00090000)
+#define IS_ADC_ALL_PERIPH(PERIPH) (((PERIPH) == ADC1) || \
+                                   ((PERIPH) == ADC2) || \
+                                   ((PERIPH) == ADC3))
 
+#define IS_ADC_DMA_PERIPH(PERIPH) (((PERIPH) == ADC1) || \
+                                   ((PERIPH) == ADC3))
+
+/** @defgroup ADC_mode 
+  * @{
+  */
+
+#define ADC_Mode_Independent                       ((uint32_t)0x00000000)
+#define ADC_Mode_RegInjecSimult                    ((uint32_t)0x00010000)
+#define ADC_Mode_RegSimult_AlterTrig               ((uint32_t)0x00020000)
+#define ADC_Mode_InjecSimult_FastInterl            ((uint32_t)0x00030000)
+#define ADC_Mode_InjecSimult_SlowInterl            ((uint32_t)0x00040000)
+#define ADC_Mode_InjecSimult                       ((uint32_t)0x00050000)
+#define ADC_Mode_RegSimult                         ((uint32_t)0x00060000)
+#define ADC_Mode_FastInterl                        ((uint32_t)0x00070000)
+#define ADC_Mode_SlowInterl                        ((uint32_t)0x00080000)
+#define ADC_Mode_AlterTrig                         ((uint32_t)0x00090000)
+
 #define IS_ADC_MODE(MODE) (((MODE) == ADC_Mode_Independent) || \
                            ((MODE) == ADC_Mode_RegInjecSimult) || \
                            ((MODE) == ADC_Mode_RegSimult_AlterTrig) || \
@@ -63,26 +111,31 @@
                            ((MODE) == ADC_Mode_FastInterl) || \
                            ((MODE) == ADC_Mode_SlowInterl) || \
                            ((MODE) == ADC_Mode_AlterTrig))
+/**
+  * @}
+  */
 
-/* ADC external trigger sources for regular channels conversion --------------*/
-/* for ADC1 and ADC2 */
-#define ADC_ExternalTrigConv_T1_CC1                ((u32)0x00000000)
-#define ADC_ExternalTrigConv_T1_CC2                ((u32)0x00020000)
-#define ADC_ExternalTrigConv_T2_CC2                ((u32)0x00060000)
-#define ADC_ExternalTrigConv_T3_TRGO               ((u32)0x00080000)
-#define ADC_ExternalTrigConv_T4_CC4                ((u32)0x000A0000)
-#define ADC_ExternalTrigConv_Ext_IT11_TIM8_TRGO    ((u32)0x000C0000)
-/* for ADC1, ADC2 and ADC3 */
-#define ADC_ExternalTrigConv_T1_CC3                ((u32)0x00040000)
-#define ADC_ExternalTrigConv_None                  ((u32)0x000E0000)
-/* for ADC3 */
-#define ADC_ExternalTrigConv_T3_CC1                ((u32)0x00000000)
-#define ADC_ExternalTrigConv_T2_CC3                ((u32)0x00020000)
-#define ADC_ExternalTrigConv_T8_CC1                ((u32)0x00060000)
-#define ADC_ExternalTrigConv_T8_TRGO               ((u32)0x00080000)
-#define ADC_ExternalTrigConv_T5_CC1                ((u32)0x000A0000)
-#define ADC_ExternalTrigConv_T5_CC3                ((u32)0x000C0000)
+/** @defgroup ADC_external_trigger_sources_for_regular_channels_conversion 
+  * @{
+  */
 
+#define ADC_ExternalTrigConv_T1_CC1                ((uint32_t)0x00000000) /*!&lt; For ADC1 and ADC2 */
+#define ADC_ExternalTrigConv_T1_CC2                ((uint32_t)0x00020000) /*!&lt; For ADC1 and ADC2 */
+#define ADC_ExternalTrigConv_T2_CC2                ((uint32_t)0x00060000) /*!&lt; For ADC1 and ADC2 */
+#define ADC_ExternalTrigConv_T3_TRGO               ((uint32_t)0x00080000) /*!&lt; For ADC1 and ADC2 */
+#define ADC_ExternalTrigConv_T4_CC4                ((uint32_t)0x000A0000) /*!&lt; For ADC1 and ADC2 */
+#define ADC_ExternalTrigConv_Ext_IT11_TIM8_TRGO    ((uint32_t)0x000C0000) /*!&lt; For ADC1 and ADC2 */
+
+#define ADC_ExternalTrigConv_T1_CC3                ((uint32_t)0x00040000) /*!&lt; For ADC1, ADC2 and ADC3 */
+#define ADC_ExternalTrigConv_None                  ((uint32_t)0x000E0000) /*!&lt; For ADC1, ADC2 and ADC3 */
+
+#define ADC_ExternalTrigConv_T3_CC1                ((uint32_t)0x00000000) /*!&lt; For ADC3 only */
+#define ADC_ExternalTrigConv_T2_CC3                ((uint32_t)0x00020000) /*!&lt; For ADC3 only */
+#define ADC_ExternalTrigConv_T8_CC1                ((uint32_t)0x00060000) /*!&lt; For ADC3 only */
+#define ADC_ExternalTrigConv_T8_TRGO               ((uint32_t)0x00080000) /*!&lt; For ADC3 only */
+#define ADC_ExternalTrigConv_T5_CC1                ((uint32_t)0x000A0000) /*!&lt; For ADC3 only */
+#define ADC_ExternalTrigConv_T5_CC3                ((uint32_t)0x000C0000) /*!&lt; For ADC3 only */
+
 #define IS_ADC_EXT_TRIG(REGTRIG) (((REGTRIG) == ADC_ExternalTrigConv_T1_CC1) || \
                                   ((REGTRIG) == ADC_ExternalTrigConv_T1_CC2) || \
                                   ((REGTRIG) == ADC_ExternalTrigConv_T1_CC3) || \
@@ -97,34 +150,45 @@
                                   ((REGTRIG) == ADC_ExternalTrigConv_T8_TRGO) || \
                                   ((REGTRIG) == ADC_ExternalTrigConv_T5_CC1) || \
                                   ((REGTRIG) == ADC_ExternalTrigConv_T5_CC3))
+/**
+  * @}
+  */
 
-/* ADC data align ------------------------------------------------------------*/
-#define ADC_DataAlign_Right                        ((u32)0x00000000)
-#define ADC_DataAlign_Left                         ((u32)0x00000800)
+/** @defgroup ADC_data_align 
+  * @{
+  */
 
+#define ADC_DataAlign_Right                        ((uint32_t)0x00000000)
+#define ADC_DataAlign_Left                         ((uint32_t)0x00000800)
 #define IS_ADC_DATA_ALIGN(ALIGN) (((ALIGN) == ADC_DataAlign_Right) || \
                                   ((ALIGN) == ADC_DataAlign_Left))
+/**
+  * @}
+  */
 
-/* ADC channels --------------------------------------------------------------*/
-#define ADC_Channel_0                               ((u8)0x00)
-#define ADC_Channel_1                               ((u8)0x01)
-#define ADC_Channel_2                               ((u8)0x02)
-#define ADC_Channel_3                               ((u8)0x03)
-#define ADC_Channel_4                               ((u8)0x04)
-#define ADC_Channel_5                               ((u8)0x05)
-#define ADC_Channel_6                               ((u8)0x06)
-#define ADC_Channel_7                               ((u8)0x07)
-#define ADC_Channel_8                               ((u8)0x08)
-#define ADC_Channel_9                               ((u8)0x09)
-#define ADC_Channel_10                              ((u8)0x0A)
-#define ADC_Channel_11                              ((u8)0x0B)
-#define ADC_Channel_12                              ((u8)0x0C)
-#define ADC_Channel_13                              ((u8)0x0D)
-#define ADC_Channel_14                              ((u8)0x0E)
-#define ADC_Channel_15                              ((u8)0x0F)
-#define ADC_Channel_16                              ((u8)0x10)
-#define ADC_Channel_17                              ((u8)0x11)
+/** @defgroup ADC_channels 
+  * @{
+  */
 
+#define ADC_Channel_0                               ((uint8_t)0x00)
+#define ADC_Channel_1                               ((uint8_t)0x01)
+#define ADC_Channel_2                               ((uint8_t)0x02)
+#define ADC_Channel_3                               ((uint8_t)0x03)
+#define ADC_Channel_4                               ((uint8_t)0x04)
+#define ADC_Channel_5                               ((uint8_t)0x05)
+#define ADC_Channel_6                               ((uint8_t)0x06)
+#define ADC_Channel_7                               ((uint8_t)0x07)
+#define ADC_Channel_8                               ((uint8_t)0x08)
+#define ADC_Channel_9                               ((uint8_t)0x09)
+#define ADC_Channel_10                              ((uint8_t)0x0A)
+#define ADC_Channel_11                              ((uint8_t)0x0B)
+#define ADC_Channel_12                              ((uint8_t)0x0C)
+#define ADC_Channel_13                              ((uint8_t)0x0D)
+#define ADC_Channel_14                              ((uint8_t)0x0E)
+#define ADC_Channel_15                              ((uint8_t)0x0F)
+#define ADC_Channel_16                              ((uint8_t)0x10)
+#define ADC_Channel_17                              ((uint8_t)0x11)
+
 #define IS_ADC_CHANNEL(CHANNEL) (((CHANNEL) == ADC_Channel_0) || ((CHANNEL) == ADC_Channel_1) || \
                                  ((CHANNEL) == ADC_Channel_2) || ((CHANNEL) == ADC_Channel_3) || \
                                  ((CHANNEL) == ADC_Channel_4) || ((CHANNEL) == ADC_Channel_5) || \
@@ -134,17 +198,22 @@
                                  ((CHANNEL) == ADC_Channel_12) || ((CHANNEL) == ADC_Channel_13) || \
                                  ((CHANNEL) == ADC_Channel_14) || ((CHANNEL) == ADC_Channel_15) || \
                                  ((CHANNEL) == ADC_Channel_16) || ((CHANNEL) == ADC_Channel_17))
+/**
+  * @}
+  */
 
-/* ADC sampling times --------------------------------------------------------*/
-#define ADC_SampleTime_1Cycles5                    ((u8)0x00)
-#define ADC_SampleTime_7Cycles5                    ((u8)0x01)
-#define ADC_SampleTime_13Cycles5                   ((u8)0x02)
-#define ADC_SampleTime_28Cycles5                   ((u8)0x03)
-#define ADC_SampleTime_41Cycles5                   ((u8)0x04)
-#define ADC_SampleTime_55Cycles5                   ((u8)0x05)
-#define ADC_SampleTime_71Cycles5                   ((u8)0x06)
-#define ADC_SampleTime_239Cycles5                  ((u8)0x07)
+/** @defgroup ADC_sampling_time 
+  * @{
+  */
 
+#define ADC_SampleTime_1Cycles5                    ((uint8_t)0x00)
+#define ADC_SampleTime_7Cycles5                    ((uint8_t)0x01)
+#define ADC_SampleTime_13Cycles5                   ((uint8_t)0x02)
+#define ADC_SampleTime_28Cycles5                   ((uint8_t)0x03)
+#define ADC_SampleTime_41Cycles5                   ((uint8_t)0x04)
+#define ADC_SampleTime_55Cycles5                   ((uint8_t)0x05)
+#define ADC_SampleTime_71Cycles5                   ((uint8_t)0x06)
+#define ADC_SampleTime_239Cycles5                  ((uint8_t)0x07)
 #define IS_ADC_SAMPLE_TIME(TIME) (((TIME) == ADC_SampleTime_1Cycles5) || \
                                   ((TIME) == ADC_SampleTime_7Cycles5) || \
                                   ((TIME) == ADC_SampleTime_13Cycles5) || \
@@ -153,25 +222,30 @@
                                   ((TIME) == ADC_SampleTime_55Cycles5) || \
                                   ((TIME) == ADC_SampleTime_71Cycles5) || \
                                   ((TIME) == ADC_SampleTime_239Cycles5))
+/**
+  * @}
+  */
 
-/* ADC extrenal trigger sources for injected channels conversion -------------*/
-/* For ADC1 and ADC2 */
-#define ADC_ExternalTrigInjecConv_T2_TRGO           ((u32)0x00002000)
-#define ADC_ExternalTrigInjecConv_T2_CC1            ((u32)0x00003000)
-#define ADC_ExternalTrigInjecConv_T3_CC4            ((u32)0x00004000)
-#define ADC_ExternalTrigInjecConv_T4_TRGO           ((u32)0x00005000)
-#define ADC_ExternalTrigInjecConv_Ext_IT15_TIM8_CC4 ((u32)0x00006000)
-/* For ADC1, ADC2 and ADC3 */
-#define ADC_ExternalTrigInjecConv_T1_TRGO           ((u32)0x00000000)
-#define ADC_ExternalTrigInjecConv_T1_CC4            ((u32)0x00001000)
-#define ADC_ExternalTrigInjecConv_None              ((u32)0x00007000)
-/* For ADC3 */
-#define ADC_ExternalTrigInjecConv_T4_CC3            ((u32)0x00002000)
-#define ADC_ExternalTrigInjecConv_T8_CC2            ((u32)0x00003000)
-#define ADC_ExternalTrigInjecConv_T8_CC4            ((u32)0x00004000)
-#define ADC_ExternalTrigInjecConv_T5_TRGO           ((u32)0x00005000)
-#define ADC_ExternalTrigInjecConv_T5_CC4            ((u32)0x00006000)
+/** @defgroup ADC_external_trigger_sources_for_injected_channels_conversion 
+  * @{
+  */
 
+#define ADC_ExternalTrigInjecConv_T2_TRGO           ((uint32_t)0x00002000) /*!&lt; For ADC1 and ADC2 */
+#define ADC_ExternalTrigInjecConv_T2_CC1            ((uint32_t)0x00003000) /*!&lt; For ADC1 and ADC2 */
+#define ADC_ExternalTrigInjecConv_T3_CC4            ((uint32_t)0x00004000) /*!&lt; For ADC1 and ADC2 */
+#define ADC_ExternalTrigInjecConv_T4_TRGO           ((uint32_t)0x00005000) /*!&lt; For ADC1 and ADC2 */
+#define ADC_ExternalTrigInjecConv_Ext_IT15_TIM8_CC4 ((uint32_t)0x00006000) /*!&lt; For ADC1 and ADC2 */
+
+#define ADC_ExternalTrigInjecConv_T1_TRGO           ((uint32_t)0x00000000) /*!&lt; For ADC1, ADC2 and ADC3 */
+#define ADC_ExternalTrigInjecConv_T1_CC4            ((uint32_t)0x00001000) /*!&lt; For ADC1, ADC2 and ADC3 */
+#define ADC_ExternalTrigInjecConv_None              ((uint32_t)0x00007000) /*!&lt; For ADC1, ADC2 and ADC3 */
+
+#define ADC_ExternalTrigInjecConv_T4_CC3            ((uint32_t)0x00002000) /*!&lt; For ADC3 only */
+#define ADC_ExternalTrigInjecConv_T8_CC2            ((uint32_t)0x00003000) /*!&lt; For ADC3 only */
+#define ADC_ExternalTrigInjecConv_T8_CC4            ((uint32_t)0x00004000) /*!&lt; For ADC3 only */
+#define ADC_ExternalTrigInjecConv_T5_TRGO           ((uint32_t)0x00005000) /*!&lt; For ADC3 only */
+#define ADC_ExternalTrigInjecConv_T5_CC4            ((uint32_t)0x00006000) /*!&lt; For ADC3 only */
+
 #define IS_ADC_EXT_INJEC_TRIG(INJTRIG) (((INJTRIG) == ADC_ExternalTrigInjecConv_T1_TRGO) || \
                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T1_CC4) || \
                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T2_TRGO) || \
@@ -185,27 +259,38 @@
                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T8_CC4) || \
                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T5_TRGO) || \
                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T5_CC4))
+/**
+  * @}
+  */
 
-/* ADC injected channel selection --------------------------------------------*/
-#define ADC_InjectedChannel_1                       ((u8)0x14)
-#define ADC_InjectedChannel_2                       ((u8)0x18)
-#define ADC_InjectedChannel_3                       ((u8)0x1C)
-#define ADC_InjectedChannel_4                       ((u8)0x20)
+/** @defgroup ADC_injected_channel_selection 
+  * @{
+  */
 
+#define ADC_InjectedChannel_1                       ((uint8_t)0x14)
+#define ADC_InjectedChannel_2                       ((uint8_t)0x18)
+#define ADC_InjectedChannel_3                       ((uint8_t)0x1C)
+#define ADC_InjectedChannel_4                       ((uint8_t)0x20)
 #define IS_ADC_INJECTED_CHANNEL(CHANNEL) (((CHANNEL) == ADC_InjectedChannel_1) || \
                                           ((CHANNEL) == ADC_InjectedChannel_2) || \
                                           ((CHANNEL) == ADC_InjectedChannel_3) || \
                                           ((CHANNEL) == ADC_InjectedChannel_4))
+/**
+  * @}
+  */
 
-/* ADC analog watchdog selection ---------------------------------------------*/
-#define ADC_AnalogWatchdog_SingleRegEnable         ((u32)0x00800200)
-#define ADC_AnalogWatchdog_SingleInjecEnable       ((u32)0x00400200)
-#define ADC_AnalogWatchdog_SingleRegOrInjecEnable  ((u32)0x00C00200)
-#define ADC_AnalogWatchdog_AllRegEnable            ((u32)0x00800000)
-#define ADC_AnalogWatchdog_AllInjecEnable          ((u32)0x00400000)
-#define ADC_AnalogWatchdog_AllRegAllInjecEnable    ((u32)0x00C00000)
-#define ADC_AnalogWatchdog_None                    ((u32)0x00000000)
+/** @defgroup ADC_analog_watchdog_selection 
+  * @{
+  */
 
+#define ADC_AnalogWatchdog_SingleRegEnable         ((uint32_t)0x00800200)
+#define ADC_AnalogWatchdog_SingleInjecEnable       ((uint32_t)0x00400200)
+#define ADC_AnalogWatchdog_SingleRegOrInjecEnable  ((uint32_t)0x00C00200)
+#define ADC_AnalogWatchdog_AllRegEnable            ((uint32_t)0x00800000)
+#define ADC_AnalogWatchdog_AllInjecEnable          ((uint32_t)0x00400000)
+#define ADC_AnalogWatchdog_AllRegAllInjecEnable    ((uint32_t)0x00C00000)
+#define ADC_AnalogWatchdog_None                    ((uint32_t)0x00000000)
+
 #define IS_ADC_ANALOG_WATCHDOG(WATCHDOG) (((WATCHDOG) == ADC_AnalogWatchdog_SingleRegEnable) || \
                                           ((WATCHDOG) == ADC_AnalogWatchdog_SingleInjecEnable) || \
                                           ((WATCHDOG) == ADC_AnalogWatchdog_SingleRegOrInjecEnable) || \
@@ -213,88 +298,182 @@
                                           ((WATCHDOG) == ADC_AnalogWatchdog_AllInjecEnable) || \
                                           ((WATCHDOG) == ADC_AnalogWatchdog_AllRegAllInjecEnable) || \
                                           ((WATCHDOG) == ADC_AnalogWatchdog_None))
+/**
+  * @}
+  */
 
-/* ADC interrupts definition -------------------------------------------------*/
-#define ADC_IT_EOC                                 ((u16)0x0220)
-#define ADC_IT_AWD                                 ((u16)0x0140)
-#define ADC_IT_JEOC                                ((u16)0x0480)
+/** @defgroup ADC_interrupts_definition 
+  * @{
+  */
 
-#define IS_ADC_IT(IT) ((((IT) &amp; (u16)0xF81F) == 0x00) &amp;&amp; ((IT) != 0x00))
+#define ADC_IT_EOC                                 ((uint16_t)0x0220)
+#define ADC_IT_AWD                                 ((uint16_t)0x0140)
+#define ADC_IT_JEOC                                ((uint16_t)0x0480)
+
+#define IS_ADC_IT(IT) ((((IT) &amp; (uint16_t)0xF81F) == 0x00) &amp;&amp; ((IT) != 0x00))
+
 #define IS_ADC_GET_IT(IT) (((IT) == ADC_IT_EOC) || ((IT) == ADC_IT_AWD) || \
                            ((IT) == ADC_IT_JEOC))
+/**
+  * @}
+  */
 
-/* ADC flags definition ------------------------------------------------------*/
-#define ADC_FLAG_AWD                               ((u8)0x01)
-#define ADC_FLAG_EOC                               ((u8)0x02)
-#define ADC_FLAG_JEOC                              ((u8)0x04)
-#define ADC_FLAG_JSTRT                             ((u8)0x08)
-#define ADC_FLAG_STRT                              ((u8)0x10)
+/** @defgroup ADC_flags_definition 
+  * @{
+  */
 
-#define IS_ADC_CLEAR_FLAG(FLAG) ((((FLAG) &amp; (u8)0xE0) == 0x00) &amp;&amp; ((FLAG) != 0x00))
+#define ADC_FLAG_AWD                               ((uint8_t)0x01)
+#define ADC_FLAG_EOC                               ((uint8_t)0x02)
+#define ADC_FLAG_JEOC                              ((uint8_t)0x04)
+#define ADC_FLAG_JSTRT                             ((uint8_t)0x08)
+#define ADC_FLAG_STRT                              ((uint8_t)0x10)
+#define IS_ADC_CLEAR_FLAG(FLAG) ((((FLAG) &amp; (uint8_t)0xE0) == 0x00) &amp;&amp; ((FLAG) != 0x00))
 #define IS_ADC_GET_FLAG(FLAG) (((FLAG) == ADC_FLAG_AWD) || ((FLAG) == ADC_FLAG_EOC) || \
                                ((FLAG) == ADC_FLAG_JEOC) || ((FLAG)== ADC_FLAG_JSTRT) || \
                                ((FLAG) == ADC_FLAG_STRT))
+/**
+  * @}
+  */
 
-/* ADC thresholds ------------------------------------------------------------*/
+/** @defgroup ADC_thresholds 
+  * @{
+  */
+
 #define IS_ADC_THRESHOLD(THRESHOLD) ((THRESHOLD) &lt;= 0xFFF)
 
-/* ADC injected offset -------------------------------------------------------*/
+/**
+  * @}
+  */
+
+/** @defgroup ADC_injected_offset 
+  * @{
+  */
+
 #define IS_ADC_OFFSET(OFFSET) ((OFFSET) &lt;= 0xFFF)
 
-/* ADC injected length -------------------------------------------------------*/
+/**
+  * @}
+  */
+
+/** @defgroup ADC_injected_length 
+  * @{
+  */
+
 #define IS_ADC_INJECTED_LENGTH(LENGTH) (((LENGTH) &gt;= 0x1) &amp;&amp; ((LENGTH) &lt;= 0x4))
 
-/* ADC injected rank ---------------------------------------------------------*/
+/**
+  * @}
+  */
+
+/** @defgroup ADC_injected_rank 
+  * @{
+  */
+
 #define IS_ADC_INJECTED_RANK(RANK) (((RANK) &gt;= 0x1) &amp;&amp; ((RANK) &lt;= 0x4))
 
-/* ADC regular length --------------------------------------------------------*/
+/**
+  * @}
+  */ 
+
+
+/** @defgroup ADC_regular_length 
+  * @{
+  */
+
 #define IS_ADC_REGULAR_LENGTH(LENGTH) (((LENGTH) &gt;= 0x1) &amp;&amp; ((LENGTH) &lt;= 0x10))
+/**
+  * @}
+  */
 
-/* ADC regular rank ----------------------------------------------------------*/
+/** @defgroup ADC_regular_rank 
+  * @{
+  */
+
 #define IS_ADC_REGULAR_RANK(RANK) (((RANK) &gt;= 0x1) &amp;&amp; ((RANK) &lt;= 0x10))
 
-/* ADC regular discontinuous mode number -------------------------------------*/
+/**
+  * @}
+  */
+
+/** @defgroup ADC_regular_discontinuous_mode_number 
+  * @{
+  */
+
 #define IS_ADC_REGULAR_DISC_NUMBER(NUMBER) (((NUMBER) &gt;= 0x1) &amp;&amp; ((NUMBER) &lt;= 0x8))
 
-/* Exported macro ------------------------------------------------------------*/
-/* Exported functions ------------------------------------------------------- */
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup ADC_Exported_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup ADC_Exported_Functions
+  * @{
+  */
+
 void ADC_DeInit(ADC_TypeDef* ADCx);
 void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct);
 void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct);
 void ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState);
 void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState);
-void ADC_ITConfig(ADC_TypeDef* ADCx, u16 ADC_IT, FunctionalState NewState);
+void ADC_ITConfig(ADC_TypeDef* ADCx, uint16_t ADC_IT, FunctionalState NewState);
 void ADC_ResetCalibration(ADC_TypeDef* ADCx);
 FlagStatus ADC_GetResetCalibrationStatus(ADC_TypeDef* ADCx);
 void ADC_StartCalibration(ADC_TypeDef* ADCx);
 FlagStatus ADC_GetCalibrationStatus(ADC_TypeDef* ADCx);
 void ADC_SoftwareStartConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
 FlagStatus ADC_GetSoftwareStartConvStatus(ADC_TypeDef* ADCx);
-void ADC_DiscModeChannelCountConfig(ADC_TypeDef* ADCx, u8 Number);
+void ADC_DiscModeChannelCountConfig(ADC_TypeDef* ADCx, uint8_t Number);
 void ADC_DiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
-void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, u8 ADC_Channel, u8 Rank, u8 ADC_SampleTime);
+void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime);
 void ADC_ExternalTrigConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
-u16 ADC_GetConversionValue(ADC_TypeDef* ADCx);
-u32 ADC_GetDualModeConversionValue(void);
+uint16_t ADC_GetConversionValue(ADC_TypeDef* ADCx);
+uint32_t ADC_GetDualModeConversionValue(void);
 void ADC_AutoInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
 void ADC_InjectedDiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
-void ADC_ExternalTrigInjectedConvConfig(ADC_TypeDef* ADCx, u32 ADC_ExternalTrigInjecConv);
+void ADC_ExternalTrigInjectedConvConfig(ADC_TypeDef* ADCx, uint32_t ADC_ExternalTrigInjecConv);
 void ADC_ExternalTrigInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
 void ADC_SoftwareStartInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
 FlagStatus ADC_GetSoftwareStartInjectedConvCmdStatus(ADC_TypeDef* ADCx);
-void ADC_InjectedChannelConfig(ADC_TypeDef* ADCx, u8 ADC_Channel, u8 Rank, u8 ADC_SampleTime);
-void ADC_InjectedSequencerLengthConfig(ADC_TypeDef* ADCx, u8 Length);
-void ADC_SetInjectedOffset(ADC_TypeDef* ADCx, u8 ADC_InjectedChannel, u16 Offset);
-u16 ADC_GetInjectedConversionValue(ADC_TypeDef* ADCx, u8 ADC_InjectedChannel);
-void ADC_AnalogWatchdogCmd(ADC_TypeDef* ADCx, u32 ADC_AnalogWatchdog);
-void ADC_AnalogWatchdogThresholdsConfig(ADC_TypeDef* ADCx, u16 HighThreshold, u16 LowThreshold);
-void ADC_AnalogWatchdogSingleChannelConfig(ADC_TypeDef* ADCx, u8 ADC_Channel);
+void ADC_InjectedChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime);
+void ADC_InjectedSequencerLengthConfig(ADC_TypeDef* ADCx, uint8_t Length);
+void ADC_SetInjectedOffset(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel, uint16_t Offset);
+uint16_t ADC_GetInjectedConversionValue(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel);
+void ADC_AnalogWatchdogCmd(ADC_TypeDef* ADCx, uint32_t ADC_AnalogWatchdog);
+void ADC_AnalogWatchdogThresholdsConfig(ADC_TypeDef* ADCx, uint16_t HighThreshold, uint16_t LowThreshold);
+void ADC_AnalogWatchdogSingleChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel);
 void ADC_TempSensorVrefintCmd(FunctionalState NewState);
-FlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, u8 ADC_FLAG);
-void ADC_ClearFlag(ADC_TypeDef* ADCx, u8 ADC_FLAG);
-ITStatus ADC_GetITStatus(ADC_TypeDef* ADCx, u16 ADC_IT);
-void ADC_ClearITPendingBit(ADC_TypeDef* ADCx, u16 ADC_IT);
+FlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, uint8_t ADC_FLAG);
+void ADC_ClearFlag(ADC_TypeDef* ADCx, uint8_t ADC_FLAG);
+ITStatus ADC_GetITStatus(ADC_TypeDef* ADCx, uint16_t ADC_IT);
+void ADC_ClearITPendingBit(ADC_TypeDef* ADCx, uint16_t ADC_IT);
 
+#ifdef __cplusplus
+}
+#endif
+
 #endif /*__STM32F10x_ADC_H */
 
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2009 STMicroelectronics *****END OF FILE****/

Modified: trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_bkp.h
===================================================================
--- trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_bkp.h	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_bkp.h	2009-07-08 23:39:34 UTC (rev 354)
@@ -1,90 +1,130 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_bkp.h
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file contains all the functions prototypes for the
-*                      BKP firmware library.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
+/**
+  ******************************************************************************
+  * @file    stm32f10x_bkp.h
+  * @author  MCD Application Team
+  * @version V3.1.0
+  * @date    06/19/2009
+  * @brief   This file contains all the functions prototypes for the BKP firmware 
+  *          library.
+  ******************************************************************************
+  * @copy
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * &lt;h2&gt;&lt;center&gt;&copy; COPYRIGHT 2009 STMicroelectronics&lt;/center&gt;&lt;/h2&gt;
+  */ 
 
 /* Define to prevent recursive inclusion -------------------------------------*/
 #ifndef __STM32F10x_BKP_H
 #define __STM32F10x_BKP_H
 
+#ifdef __cplusplus
+ extern &quot;C&quot; {
+#endif
+
 /* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_map.h&quot;
+#include &quot;stm32f10x.h&quot;
 
-/* Exported types ------------------------------------------------------------*/
-/* Exported constants --------------------------------------------------------*/
-/* Tamper Pin active level */
-#define BKP_TamperPinLevel_High           ((u16)0x0000)
-#define BKP_TamperPinLevel_Low            ((u16)0x0001)
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
 
+/** @addtogroup BKP
+  * @{
+  */
+
+/** @defgroup BKP_Exported_Types
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup BKP_Exported_Constants
+  * @{
+  */
+
+/** @defgroup Tamper_Pin_active_level 
+  * @{
+  */
+
+#define BKP_TamperPinLevel_High           ((uint16_t)0x0000)
+#define BKP_TamperPinLevel_Low            ((uint16_t)0x0001)
 #define IS_BKP_TAMPER_PIN_LEVEL(LEVEL) (((LEVEL) == BKP_TamperPinLevel_High) || \
                                         ((LEVEL) == BKP_TamperPinLevel_Low))
+/**
+  * @}
+  */
 
-/* RTC output source to output on the Tamper pin */
-#define BKP_RTCOutputSource_None          ((u16)0x0000)
-#define BKP_RTCOutputSource_CalibClock    ((u16)0x0080)
-#define BKP_RTCOutputSource_Alarm         ((u16)0x0100)
-#define BKP_RTCOutputSource_Second        ((u16)0x0300)
+/** @defgroup RTC_output_source_to_output_on_the_Tamper_pin 
+  * @{
+  */
 
+#define BKP_RTCOutputSource_None          ((uint16_t)0x0000)
+#define BKP_RTCOutputSource_CalibClock    ((uint16_t)0x0080)
+#define BKP_RTCOutputSource_Alarm         ((uint16_t)0x0100)
+#define BKP_RTCOutputSource_Second        ((uint16_t)0x0300)
 #define IS_BKP_RTC_OUTPUT_SOURCE(SOURCE) (((SOURCE) == BKP_RTCOutputSource_None) || \
                                           ((SOURCE) == BKP_RTCOutputSource_CalibClock) || \
                                           ((SOURCE) == BKP_RTCOutputSource_Alarm) || \
                                           ((SOURCE) == BKP_RTCOutputSource_Second))
+/**
+  * @}
+  */
 
-/* Data Backup Register */
-#define BKP_DR1                           ((u16)0x0004)
-#define BKP_DR2                           ((u16)0x0008)
-#define BKP_DR3                           ((u16)0x000C)
-#define BKP_DR4                           ((u16)0x0010)
-#define BKP_DR5                           ((u16)0x0014)
-#define BKP_DR6                           ((u16)0x0018)
-#define BKP_DR7                           ((u16)0x001C)
-#define BKP_DR8                           ((u16)0x0020)
-#define BKP_DR9                           ((u16)0x0024)
-#define BKP_DR10                          ((u16)0x0028)
-#define BKP_DR11                          ((u16)0x0040)
-#define BKP_DR12                          ((u16)0x0044)
-#define BKP_DR13                          ((u16)0x0048)
-#define BKP_DR14                          ((u16)0x004C)
-#define BKP_DR15                          ((u16)0x0050)
-#define BKP_DR16                          ((u16)0x0054)
-#define BKP_DR17                          ((u16)0x0058)
-#define BKP_DR18                          ((u16)0x005C)
-#define BKP_DR19                          ((u16)0x0060)
-#define BKP_DR20                          ((u16)0x0064)
-#define BKP_DR21                          ((u16)0x0068)
-#define BKP_DR22                          ((u16)0x006C)
-#define BKP_DR23                          ((u16)0x0070)
-#define BKP_DR24                          ((u16)0x0074)
-#define BKP_DR25                          ((u16)0x0078)
-#define BKP_DR26                          ((u16)0x007C)
-#define BKP_DR27                          ((u16)0x0080)
-#define BKP_DR28                          ((u16)0x0084)
-#define BKP_DR29                          ((u16)0x0088)
-#define BKP_DR30                          ((u16)0x008C)
-#define BKP_DR31                          ((u16)0x0090)
-#define BKP_DR32                          ((u16)0x0094)
-#define BKP_DR33                          ((u16)0x0098)
-#define BKP_DR34                          ((u16)0x009C)
-#define BKP_DR35                          ((u16)0x00A0)
-#define BKP_DR36                          ((u16)0x00A4)
-#define BKP_DR37                          ((u16)0x00A8)
-#define BKP_DR38                          ((u16)0x00AC)
-#define BKP_DR39                          ((u16)0x00B0)
-#define BKP_DR40                          ((u16)0x00B4)
-#define BKP_DR41                          ((u16)0x00B8)
-#define BKP_DR42                          ((u16)0x00BC)
+/** @defgroup Data_Backup_Register 
+  * @{
+  */
 
+#define BKP_DR1                           ((uint16_t)0x0004)
+#define BKP_DR2                           ((uint16_t)0x0008)
+#define BKP_DR3                           ((uint16_t)0x000C)
+#define BKP_DR4                           ((uint16_t)0x0010)
+#define BKP_DR5                           ((uint16_t)0x0014)
+#define BKP_DR6                           ((uint16_t)0x0018)
+#define BKP_DR7                           ((uint16_t)0x001C)
+#define BKP_DR8                           ((uint16_t)0x0020)
+#define BKP_DR9                           ((uint16_t)0x0024)
+#define BKP_DR10                          ((uint16_t)0x0028)
+#define BKP_DR11                          ((uint16_t)0x0040)
+#define BKP_DR12                          ((uint16_t)0x0044)
+#define BKP_DR13                          ((uint16_t)0x0048)
+#define BKP_DR14                          ((uint16_t)0x004C)
+#define BKP_DR15                          ((uint16_t)0x0050)
+#define BKP_DR16                          ((uint16_t)0x0054)
+#define BKP_DR17                          ((uint16_t)0x0058)
+#define BKP_DR18                          ((uint16_t)0x005C)
+#define BKP_DR19                          ((uint16_t)0x0060)
+#define BKP_DR20                          ((uint16_t)0x0064)
+#define BKP_DR21                          ((uint16_t)0x0068)
+#define BKP_DR22                          ((uint16_t)0x006C)
+#define BKP_DR23                          ((uint16_t)0x0070)
+#define BKP_DR24                          ((uint16_t)0x0074)
+#define BKP_DR25                          ((uint16_t)0x0078)
+#define BKP_DR26                          ((uint16_t)0x007C)
+#define BKP_DR27                          ((uint16_t)0x0080)
+#define BKP_DR28                          ((uint16_t)0x0084)
+#define BKP_DR29                          ((uint16_t)0x0088)
+#define BKP_DR30                          ((uint16_t)0x008C)
+#define BKP_DR31                          ((uint16_t)0x0090)
+#define BKP_DR32                          ((uint16_t)0x0094)
+#define BKP_DR33                          ((uint16_t)0x0098)
+#define BKP_DR34                          ((uint16_t)0x009C)
+#define BKP_DR35                          ((uint16_t)0x00A0)
+#define BKP_DR36                          ((uint16_t)0x00A4)
+#define BKP_DR37                          ((uint16_t)0x00A8)
+#define BKP_DR38                          ((uint16_t)0x00AC)
+#define BKP_DR39                          ((uint16_t)0x00B0)
+#define BKP_DR40                          ((uint16_t)0x00B4)
+#define BKP_DR41                          ((uint16_t)0x00B8)
+#define BKP_DR42                          ((uint16_t)0x00BC)
+
 #define IS_BKP_DR(DR) (((DR) == BKP_DR1)  || ((DR) == BKP_DR2)  || ((DR) == BKP_DR3)  || \
                        ((DR) == BKP_DR4)  || ((DR) == BKP_DR5)  || ((DR) == BKP_DR6)  || \
                        ((DR) == BKP_DR7)  || ((DR) == BKP_DR8)  || ((DR) == BKP_DR9)  || \
@@ -101,22 +141,54 @@
                        ((DR) == BKP_DR40) || ((DR) == BKP_DR41) || ((DR) == BKP_DR42))
 
 #define IS_BKP_CALIBRATION_VALUE(VALUE) ((VALUE) &lt;= 0x7F)
+/**
+  * @}
+  */
 
-/* Exported macro ------------------------------------------------------------*/
-/* Exported functions ------------------------------------------------------- */
+/**
+  * @}
+  */
+
+/** @defgroup BKP_Exported_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup BKP_Exported_Functions
+  * @{
+  */
+
 void BKP_DeInit(void);
-void BKP_TamperPinLevelConfig(u16 BKP_TamperPinLevel);
+void BKP_TamperPinLevelConfig(uint16_t BKP_TamperPinLevel);
 void BKP_TamperPinCmd(FunctionalState NewState);
 void BKP_ITConfig(FunctionalState NewState);
-void BKP_RTCOutputConfig(u16 BKP_RTCOutputSource);
-void BKP_SetRTCCalibrationValue(u8 CalibrationValue);
-void BKP_WriteBackupRegister(u16 BKP_DR, u16 Data);
-u16 BKP_ReadBackupRegister(u16 BKP_DR);
+void BKP_RTCOutputConfig(uint16_t BKP_RTCOutputSource);
+void BKP_SetRTCCalibrationValue(uint8_t CalibrationValue);
+void BKP_WriteBackupRegister(uint16_t BKP_DR, uint16_t Data);
+uint16_t BKP_ReadBackupRegister(uint16_t BKP_DR);
 FlagStatus BKP_GetFlagStatus(void);
 void BKP_ClearFlag(void);
 ITStatus BKP_GetITStatus(void);
 void BKP_ClearITPendingBit(void);
 
+#ifdef __cplusplus
+}
+#endif
+
 #endif /* __STM32F10x_BKP_H */
+/**
+  * @}
+  */
 
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2009 STMicroelectronics *****END OF FILE****/

Modified: trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_can.h
===================================================================
--- trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_can.h	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_can.h	2009-07-08 23:39:34 UTC (rev 354)
@@ -1,228 +1,466 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_can.h
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file contains all the functions prototypes for the
-*                      CAN firmware library.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
+/**
+  ******************************************************************************
+  * @file    stm32f10x_can.h
+  * @author  MCD Application Team
+  * @version V3.1.0
+  * @date    06/19/2009
+  * @brief   This file contains all the functions prototypes for the CAN firmware 
+  *          library.
+  ******************************************************************************
+  * @copy
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * &lt;h2&gt;&lt;center&gt;&copy; COPYRIGHT 2009 STMicroelectronics&lt;/center&gt;&lt;/h2&gt;
+  */ 
 
 /* Define to prevent recursive inclusion -------------------------------------*/
 #ifndef __STM32F10x_CAN_H
 #define __STM32F10x_CAN_H
 
+#ifdef __cplusplus
+ extern &quot;C&quot; {
+#endif
+
 /* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_map.h&quot;
+#include &quot;stm32f10x.h&quot;
 
-/* Exported types ------------------------------------------------------------*/
-/* CAN init structure definition */
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @addtogroup CAN
+  * @{
+  */
+
+/** @defgroup CAN_Exported_Types
+  * @{
+  */
+
+#define IS_CAN_ALL_PERIPH(PERIPH) (((PERIPH) == CAN1) || \
+                                   ((PERIPH) == CAN2))
+
+/** 
+  * @brief  CAN init structure definition
+  */
+
 typedef struct
 {
-  FunctionalState CAN_TTCM;
-  FunctionalState CAN_ABOM;
-  FunctionalState CAN_AWUM;
-  FunctionalState CAN_NART;
-  FunctionalState CAN_RFLM;
-  FunctionalState CAN_TXFP;
-  u8 CAN_Mode;
-  u8 CAN_SJW;
-  u8 CAN_BS1;
-  u8 CAN_BS2;
-  u16 CAN_Prescaler;
+  uint16_t CAN_Prescaler;   /*!&lt; Specifies the length of a time quantum. It ranges from 1 to 1024. */
+  
+  uint8_t CAN_Mode;         /*!&lt; Specifies the CAN operating mode.
+                                 This parameter can be a value of @ref CAN_operating_mode */
+
+  uint8_t CAN_SJW;          /*!&lt; Specifies the maximum number of time quanta the CAN hardware
+                                 is allowed to lengthen or shorten a bit to perform resynchronization.
+                                 This parameter can be a value of @ref CAN_synchronisation_jump_width */
+
+  uint8_t CAN_BS1;          /*!&lt; Specifies the number of time quanta in Bit Segment 1.
+                                 This parameter can be a value of @ref CAN_time_quantum_in_bit_segment_1 */
+
+  uint8_t CAN_BS2;          /*!&lt; Specifies the number of time quanta in Bit Segment 2.
+                                 This parameter can be a value of @ref CAN_time_quantum_in_bit_segment_2 */
+  
+  FunctionalState CAN_TTCM; /*!&lt; Enable or disable the time triggered communication mode.
+                                 This parameter can be set either to ENABLE or DISABLE. */
+  
+  FunctionalState CAN_ABOM;  /*!&lt; Enable or disable the automatic bus-off management.
+                                 This parameter can be set either to ENABLE or DISABLE. */
+
+  FunctionalState CAN_AWUM;  /*!&lt; Enable or disable the automatic wake-up mode. 
+                                 This parameter can be set either to ENABLE or DISABLE. */
+
+  FunctionalState CAN_NART;  /*!&lt; Enable or disable the no-automatic retransmission mode.
+                                 This parameter can be set either to ENABLE or DISABLE. */
+
+  FunctionalState CAN_RFLM;  /*!&lt; Enable or disable the Receive FIFO Locked mode.
+                                 This parameter can be set either to ENABLE or DISABLE. */
+
+  FunctionalState CAN_TXFP;  /*!&lt; Enable or disable the transmit FIFO priority.
+                                 This parameter can be set either to ENABLE or DISABLE. */
 } CAN_InitTypeDef;
 
-/* CAN filter init structure definition */
+/** 
+  * @brief  CAN filter init structure definition
+  */
+
 typedef struct
 {
-  u8 CAN_FilterNumber;
-  u8 CAN_FilterMode;
-  u8 CAN_FilterScale;
-  u16 CAN_FilterIdHigh;
-  u16 CAN_FilterIdLow;
-  u16 CAN_FilterMaskIdHigh;
-  u16 CAN_FilterMaskIdLow;
-  u16 CAN_FilterFIFOAssignment;
-  FunctionalState CAN_FilterActivation;
+  uint16_t CAN_FilterIdHigh;             /*!&lt; Specifies the filter identification number (MSBs for a 32-bit
+                                              configuration, first one for a 16-bit configuration).
+                                              This parameter can be a value between 0x0000 and 0xFFFF */
+
+  uint16_t CAN_FilterIdLow;              /*!&lt; Specifies the filter identification number (LSBs for a 32-bit
+                                              configuration, second one for a 16-bit configuration).
+                                              This parameter can be a value between 0x0000 and 0xFFFF */
+
+  uint16_t CAN_FilterMaskIdHigh;         /*!&lt; Specifies the filter mask number or identification number,
+                                              according to the mode (MSBs for a 32-bit configuration,
+                                              first one for a 16-bit configuration).
+                                              This parameter can be a value between 0x0000 and 0xFFFF */
+
+  uint16_t CAN_FilterMaskIdLow;          /*!&lt; Specifies the filter mask number or identification number,
+                                              according to the mode (LSBs for a 32-bit configuration,
+                                              second one for a 16-bit configuration).
+                                              This parameter can be a value between 0x0000 and 0xFFFF */
+
+  uint16_t CAN_FilterFIFOAssignment;     /*!&lt; Specifies the FIFO (0 or 1) which will be assigned to the filter.
+                                              This parameter can be a value of @ref CAN_filter_FIFO */
+  
+  uint8_t CAN_FilterNumber;              /*!&lt; Specifies the filter which will be initialized. It ranges from 0 to 13. */
+
+  uint8_t CAN_FilterMode;                /*!&lt; Specifies the filter mode to be initialized.
+                                              This parameter can be a value of @ref CAN_filter_mode */
+
+  uint8_t CAN_FilterScale;               /*!&lt; Specifies the filter scale.
+                                              This parameter can be a value of @ref CAN_filter_scale */
+
+  FunctionalState CAN_FilterActivation;  /*!&lt; Enable or disable the filter.
+                                              This parameter can be set either to ENABLE or DISABLE. */
 } CAN_FilterInitTypeDef;
 
-/* CAN Tx message structure definition */
+/** 
+  * @brief  CAN Tx message structure definition  
+  */
+
 typedef struct
 {
-  u32 StdId;
-  u32 ExtId;
-  u8 IDE;
-  u8 RTR;
-  u8 DLC;
-  u8 Data[8];
+  uint32_t StdId;  /*!&lt; Specifies the standard identifier.
+                        This parameter can be a value between 0 to 0x7FF. */
+
+  uint32_t ExtId;  /*!&lt; Specifies the extended identifier.
+                        This parameter can be a value between 0 to 0x1FFFFFFF. */
+
+  uint8_t IDE;     /*!&lt; Specifies the type of identifier for the message that will be transmitted.
+                        This parameter can be a value of @ref CAN_identifier_type */
+
+  uint8_t RTR;     /*!&lt; Specifies the type of frame for the message that will be transmitted.
+                        This parameter can be a value of @ref CAN_remote_transmission_request */
+
+  uint8_t DLC;     /*!&lt; Specifies the length of the frame that will be transmitted.
+                        This parameter can be a value between 0 to 8 */
+
+  uint8_t Data[8]; /*!&lt; Contains the data to be transmitted. It ranges from 0 to 0xFF. */
 } CanTxMsg;
 
-/* CAN Rx message structure definition */
+/** 
+  * @brief  CAN Rx message structure definition  
+  */
+
 typedef struct
 {
-  u32 StdId;
-  u32 ExtId;
-  u8 IDE;
-  u8 RTR;
-  u8 DLC;
-  u8 Data[8];
-  u8 FMI;
+  uint32_t StdId;  /*!&lt; Specifies the standard identifier.
+                        This parameter can be a value between 0 to 0x7FF. */
+
+  uint32_t ExtId;  /*!&lt; Specifies the extended identifier.
+                        This parameter can be a value between 0 to 0x1FFFFFFF. */
+
+  uint8_t IDE;     /*!&lt; Specifies the type of identifier for the message that will be received.
+                        This parameter can be a value of @ref CAN_identifier_type */
+
+  uint8_t RTR;     /*!&lt; Specifies the type of frame for the received message.
+                        This parameter can be a value of @ref CAN_remote_transmission_request */
+
+  uint8_t DLC;     /*!&lt; Specifies the length of the frame that will be received.
+                        This parameter can be a value between 0 to 8 */
+
+  uint8_t Data[8]; /*!&lt; Contains the data to be received. It ranges from 0 to 0xFF. */
+
+  uint8_t FMI;     /*!&lt; Specifies the index of the filter the message stored in the mailbox passes through.
+                        This parameter can be a value between 0 to 0xFF */
 } CanRxMsg;
 
-/* Exported constants --------------------------------------------------------*/
+/**
+  * @}
+  */
 
-/* CAN sleep constants */
-#define CANINITFAILED              ((u8)0x00) /* CAN initialization failed */
-#define CANINITOK                  ((u8)0x01) /* CAN initialization failed */
+/** @defgroup CAN_Exported_Constants
+  * @{
+  */
 
-/* CAN operating mode */
-#define CAN_Mode_Normal             ((u8)0x00)  /* normal mode */
-#define CAN_Mode_LoopBack           ((u8)0x01)  /* loopback mode */
-#define CAN_Mode_Silent             ((u8)0x02)  /* silent mode */
-#define CAN_Mode_Silent_LoopBack    ((u8)0x03)  /* loopback combined with silent mode */
+/** @defgroup CAN_sleep_constants 
+  * @{
+  */
 
+#define CANINITFAILED              ((uint8_t)0x00) /*!&lt; CAN initialization failed */
+#define CANINITOK                  ((uint8_t)0x01) /*!&lt; CAN initialization failed */
+
+/**
+  * @}
+  */
+
+/** @defgroup CAN_operating_mode 
+  * @{
+  */
+
+#define CAN_Mode_Normal             ((uint8_t)0x00)  /*!&lt; normal mode */
+#define CAN_Mode_LoopBack           ((uint8_t)0x01)  /*!&lt; loopback mode */
+#define CAN_Mode_Silent             ((uint8_t)0x02)  /*!&lt; silent mode */
+#define CAN_Mode_Silent_LoopBack    ((uint8_t)0x03)  /*!&lt; loopback combined with silent mode */
+
 #define IS_CAN_MODE(MODE) (((MODE) == CAN_Mode_Normal) || ((MODE) == CAN_Mode_LoopBack)|| \
                            ((MODE) == CAN_Mode_Silent) || ((MODE) == CAN_Mode_Silent_LoopBack))
+/**
+  * @}
+  */
 
-/* CAN synchronisation jump width */
-#define CAN_SJW_1tq                 ((u8)0x00)  /* 1 time quantum */
-#define CAN_SJW_2tq                 ((u8)0x01)  /* 2 time quantum */
-#define CAN_SJW_3tq                 ((u8)0x02)  /* 3 time quantum */
-#define CAN_SJW_4tq                 ((u8)0x03)  /* 4 time quantum */
+/** @defgroup CAN_synchronisation_jump_width 
+  * @{
+  */
 
+#define CAN_SJW_1tq                 ((uint8_t)0x00)  /*!&lt; 1 time quantum */
+#define CAN_SJW_2tq                 ((uint8_t)0x01)  /*!&lt; 2 time quantum */
+#define CAN_SJW_3tq                 ((uint8_t)0x02)  /*!&lt; 3 time quantum */
+#define CAN_SJW_4tq                 ((uint8_t)0x03)  /*!&lt; 4 time quantum */
+
 #define IS_CAN_SJW(SJW) (((SJW) == CAN_SJW_1tq) || ((SJW) == CAN_SJW_2tq)|| \
                          ((SJW) == CAN_SJW_3tq) || ((SJW) == CAN_SJW_4tq))
+/**
+  * @}
+  */
 
-/* time quantum in bit segment 1 */
-#define CAN_BS1_1tq                 ((u8)0x00)  /* 1 time quantum */
-#define CAN_BS1_2tq                 ((u8)0x01)  /* 2 time quantum */
-#define CAN_BS1_3tq                 ((u8)0x02)  /* 3 time quantum */
-#define CAN_BS1_4tq                 ((u8)0x03)  /* 4 time quantum */
-#define CAN_BS1_5tq                 ((u8)0x04)  /* 5 time quantum */
-#define CAN_BS1_6tq                 ((u8)0x05)  /* 6 time quantum */
-#define CAN_BS1_7tq                 ((u8)0x06)  /* 7 time quantum */
-#define CAN_BS1_8tq                 ((u8)0x07)  /* 8 time quantum */
-#define CAN_BS1_9tq                 ((u8)0x08)  /* 9 time quantum */
-#define CAN_BS1_10tq                ((u8)0x09)  /* 10 time quantum */
-#define CAN_BS1_11tq                ((u8)0x0A)  /* 11 time quantum */
-#define CAN_BS1_12tq                ((u8)0x0B)  /* 12 time quantum */
-#define CAN_BS1_13tq                ((u8)0x0C)  /* 13 time quantum */
-#define CAN_BS1_14tq                ((u8)0x0D)  /* 14 time quantum */
-#define CAN_BS1_15tq                ((u8)0x0E)  /* 15 time quantum */
-#define CAN_BS1_16tq                ((u8)0x0F)  /* 16 time quantum */
+/** @defgroup CAN_time_quantum_in_bit_segment_1 
+  * @{
+  */
 
+#define CAN_BS1_1tq                 ((uint8_t)0x00)  /*!&lt; 1 time quantum */
+#define CAN_BS1_2tq                 ((uint8_t)0x01)  /*!&lt; 2 time quantum */
+#define CAN_BS1_3tq                 ((uint8_t)0x02)  /*!&lt; 3 time quantum */
+#define CAN_BS1_4tq                 ((uint8_t)0x03)  /*!&lt; 4 time quantum */
+#define CAN_BS1_5tq                 ((uint8_t)0x04)  /*!&lt; 5 time quantum */
+#define CAN_BS1_6tq                 ((uint8_t)0x05)  /*!&lt; 6 time quantum */
+#define CAN_BS1_7tq                 ((uint8_t)0x06)  /*!&lt; 7 time quantum */
+#define CAN_BS1_8tq                 ((uint8_t)0x07)  /*!&lt; 8 time quantum */
+#define CAN_BS1_9tq                 ((uint8_t)0x08)  /*!&lt; 9 time quantum */
+#define CAN_BS1_10tq                ((uint8_t)0x09)  /*!&lt; 10 time quantum */
+#define CAN_BS1_11tq                ((uint8_t)0x0A)  /*!&lt; 11 time quantum */
+#define CAN_BS1_12tq                ((uint8_t)0x0B)  /*!&lt; 12 time quantum */
+#define CAN_BS1_13tq                ((uint8_t)0x0C)  /*!&lt; 13 time quantum */
+#define CAN_BS1_14tq                ((uint8_t)0x0D)  /*!&lt; 14 time quantum */
+#define CAN_BS1_15tq                ((uint8_t)0x0E)  /*!&lt; 15 time quantum */
+#define CAN_BS1_16tq                ((uint8_t)0x0F)  /*!&lt; 16 time quantum */
+
 #define IS_CAN_BS1(BS1) ((BS1) &lt;= CAN_BS1_16tq)
+/**
+  * @}
+  */
 
-/* time quantum in bit segment 2 */
-#define CAN_BS2_1tq                 ((u8)0x00)  /* 1 time quantum */
-#define CAN_BS2_2tq                 ((u8)0x01)  /* 2 time quantum */
-#define CAN_BS2_3tq                 ((u8)0x02)  /* 3 time quantum */
-#define CAN_BS2_4tq                 ((u8)0x03)  /* 4 time quantum */
-#define CAN_BS2_5tq                 ((u8)0x04)  /* 5 time quantum */
-#define CAN_BS2_6tq                 ((u8)0x05)  /* 6 time quantum */
-#define CAN_BS2_7tq                 ((u8)0x06)  /* 7 time quantum */
-#define CAN_BS2_8tq                 ((u8)0x07)  /* 8 time quantum */
+/** @defgroup CAN_time_quantum_in_bit_segment_2 
+  * @{
+  */
 
+#define CAN_BS2_1tq                 ((uint8_t)0x00)  /*!&lt; 1 time quantum */
+#define CAN_BS2_2tq                 ((uint8_t)0x01)  /*!&lt; 2 time quantum */
+#define CAN_BS2_3tq                 ((uint8_t)0x02)  /*!&lt; 3 time quantum */
+#define CAN_BS2_4tq                 ((uint8_t)0x03)  /*!&lt; 4 time quantum */
+#define CAN_BS2_5tq                 ((uint8_t)0x04)  /*!&lt; 5 time quantum */
+#define CAN_BS2_6tq                 ((uint8_t)0x05)  /*!&lt; 6 time quantum */
+#define CAN_BS2_7tq                 ((uint8_t)0x06)  /*!&lt; 7 time quantum */
+#define CAN_BS2_8tq                 ((uint8_t)0x07)  /*!&lt; 8 time quantum */
+
 #define IS_CAN_BS2(BS2) ((BS2) &lt;= CAN_BS2_8tq)
 
-/* CAN clock prescaler */
+/**
+  * @}
+  */
+
+/** @defgroup CAN_clock_prescaler 
+  * @{
+  */
+
 #define IS_CAN_PRESCALER(PRESCALER) (((PRESCALER) &gt;= 1) &amp;&amp; ((PRESCALER) &lt;= 1024))
 
-/* CAN filter number */
-#define IS_CAN_FILTER_NUMBER(NUMBER) ((NUMBER) &lt;= 13)
+/**
+  * @}
+  */
 
-/* CAN filter mode */
-#define CAN_FilterMode_IdMask       ((u8)0x00)  /* id/mask mode */
-#define CAN_FilterMode_IdList       ((u8)0x01)  /* identifier list mode */
+/** @defgroup CAN_filter_number 
+  * @{
+  */
+#ifndef STM32F10X_CL
+  #define IS_CAN_FILTER_NUMBER(NUMBER) ((NUMBER) &lt;= 13)
+#else
+  #define IS_CAN_FILTER_NUMBER(NUMBER) ((NUMBER) &lt;= 27)
+#endif /* STM32F10X_CL */ 
+/**
+  * @}
+  */
 
+/** @defgroup CAN_filter_mode 
+  * @{
+  */
+
+#define CAN_FilterMode_IdMask       ((uint8_t)0x00)  /*!&lt; id/mask mode */
+#define CAN_FilterMode_IdList       ((uint8_t)0x01)  /*!&lt; identifier list mode */
+
 #define IS_CAN_FILTER_MODE(MODE) (((MODE) == CAN_FilterMode_IdMask) || \
                                   ((MODE) == CAN_FilterMode_IdList))
+/**
+  * @}
+  */
 
-/* CAN filter scale */
-#define CAN_FilterScale_16bit       ((u8)0x00) /* 16-bit filter scale */
-#define CAN_FilterScale_32bit       ((u8)0x01) /* 2-bit filter scale */
+/** @defgroup CAN_filter_scale 
+  * @{
+  */
 
+#define CAN_FilterScale_16bit       ((uint8_t)0x00) /*!&lt; Two 16-bit filters */
+#define CAN_FilterScale_32bit       ((uint8_t)0x01) /*!&lt; One 32-bit filter */
+
 #define IS_CAN_FILTER_SCALE(SCALE) (((SCALE) == CAN_FilterScale_16bit) || \
                                     ((SCALE) == CAN_FilterScale_32bit))
 
-/* CAN filter FIFO assignation */
-#define CAN_FilterFIFO0             ((u8)0x00)  /* Filter FIFO 0 assignment for filter x */
-#define CAN_FilterFIFO1             ((u8)0x01)  /* Filter FIFO 1 assignment for filter x */
+/**
+  * @}
+  */
 
+/** @defgroup CAN_filter_FIFO
+  * @{
+  */
+
+#define CAN_FilterFIFO0             ((uint8_t)0x00)  /*!&lt; Filter FIFO 0 assignment for filter x */
+#define CAN_FilterFIFO1             ((uint8_t)0x01)  /*!&lt; Filter FIFO 1 assignment for filter x */
 #define IS_CAN_FILTER_FIFO(FIFO) (((FIFO) == CAN_FilterFIFO0) || \
                                   ((FIFO) == CAN_FilterFIFO1))
 
-/* CAN Tx */
-#define IS_CAN_TRANSMITMAILBOX(TRANSMITMAILBOX) ((TRANSMITMAILBOX) &lt;= ((u8)0x02))
-#define IS_CAN_STDID(STDID)   ((STDID) &lt;= ((u32)0x7FF))
-#define IS_CAN_EXTID(EXTID)   ((EXTID) &lt;= ((u32)0x1FFFFFFF))
-#define IS_CAN_DLC(DLC)       ((DLC) &lt;= ((u8)0x08))
+/**
+  * @}
+  */
 
-/* CAN identifier type */
-#define CAN_ID_STD                 ((u32)0x00000000)  /* Standard Id */
-#define CAN_ID_EXT                 ((u32)0x00000004)  /* Extended Id */
+/** @defgroup Start_bank_filter_for_slave_CAN 
+  * @{
+  */
+#define IS_CAN_BANKNUMBER(BANKNUMBER) (((BANKNUMBER) &gt;= 1) &amp;&amp; ((BANKNUMBER) &lt;= 27))
+/**
+  * @}
+  */
 
+/** @defgroup CAN_Tx 
+  * @{
+  */
+
+#define IS_CAN_TRANSMITMAILBOX(TRANSMITMAILBOX) ((TRANSMITMAILBOX) &lt;= ((uint8_t)0x02))
+#define IS_CAN_STDID(STDID)   ((STDID) &lt;= ((uint32_t)0x7FF))
+#define IS_CAN_EXTID(EXTID)   ((EXTID) &lt;= ((uint32_t)0x1FFFFFFF))
+#define IS_CAN_DLC(DLC)       ((DLC) &lt;= ((uint8_t)0x08))
+
+/**
+  * @}
+  */
+
+/** @defgroup CAN_identifier_type 
+  * @{
+  */
+
+#define CAN_ID_STD                 ((uint32_t)0x00000000)  /*!&lt; Standard Id */
+#define CAN_ID_EXT                 ((uint32_t)0x00000004)  /*!&lt; Extended Id */
 #define IS_CAN_IDTYPE(IDTYPE) (((IDTYPE) == CAN_ID_STD) || ((IDTYPE) == CAN_ID_EXT))
 
-/* CAN remote transmission request */
-#define CAN_RTR_DATA                ((u32)0x00000000)  /* Data frame */
-#define CAN_RTR_REMOTE              ((u32)0x00000002)  /* Remote frame */
+/**
+  * @}
+  */
 
+/** @defgroup CAN_remote_transmission_request 
+  * @{
+  */
+
+#define CAN_RTR_DATA                ((uint32_t)0x00000000)  /*!&lt; Data frame */
+#define CAN_RTR_REMOTE              ((uint32_t)0x00000002)  /*!&lt; Remote frame */
 #define IS_CAN_RTR(RTR) (((RTR) == CAN_RTR_DATA) || ((RTR) == CAN_RTR_REMOTE))
 
-/* CAN transmit constants */
-#define CANTXFAILED                 ((u8)0x00) /* CAN transmission failed */
-#define CANTXOK                     ((u8)0x01) /* CAN transmission succeeded */
-#define CANTXPENDING                ((u8)0x02) /* CAN transmission pending */
-#define CAN_NO_MB                   ((u8)0x04) /* CAN cell did not provide an empty mailbox */
+/**
+  * @}
+  */
 
-/* CAN receive FIFO number constants */
-#define CAN_FIFO0                 ((u8)0x00) /* CAN FIFO0 used to receive */
-#define CAN_FIFO1                 ((u8)0x01) /* CAN FIFO1 used to receive */
+/** @defgroup CAN_transmit_constants 
+  * @{
+  */
 
+#define CANTXFAILED                 ((uint8_t)0x00) /*!&lt; CAN transmission failed */
+#define CANTXOK                     ((uint8_t)0x01) /*!&lt; CAN transmission succeeded */
+#define CANTXPENDING                ((uint8_t)0x02) /*!&lt; CAN transmission pending */
+#define CAN_NO_MB                   ((uint8_t)0x04) /*!&lt; CAN cell did not provide an empty mailbox */
+
+/**
+  * @}
+  */
+
+/** @defgroup CAN_receive_FIFO_number_constants 
+  * @{
+  */
+
+#define CAN_FIFO0                 ((uint8_t)0x00) /*!&lt; CAN FIFO0 used to receive */
+#define CAN_FIFO1                 ((uint8_t)0x01) /*!&lt; CAN FIFO1 used to receive */
+
 #define IS_CAN_FIFO(FIFO) (((FIFO) == CAN_FIFO0) || ((FIFO) == CAN_FIFO1))
 
-/* CAN sleep constants */
-#define CANSLEEPFAILED              ((u8)0x00) /* CAN did not enter the sleep mode */
-#define CANSLEEPOK                  ((u8)0x01) /* CAN entered the sleep mode */
+/**
+  * @}
+  */
 
-/* CAN wake up constants */
-#define CANWAKEUPFAILED             ((u8)0x00) /* CAN did not leave the sleep mode */
-#define CANWAKEUPOK                 ((u8)0x01) /* CAN leaved the sleep mode */
+/** @defgroup CAN_sleep_constants 
+  * @{
+  */
 
-/* CAN flags */
-#define CAN_FLAG_EWG                ((u32)0x00000001) /* Error Warning Flag */
-#define CAN_FLAG_EPV                ((u32)0x00000002) /* Error Passive Flag */
-#define CAN_FLAG_BOF                ((u32)0x00000004) /* Bus-Off Flag */
+#define CANSLEEPFAILED              ((uint8_t)0x00) /*!&lt; CAN did not enter the sleep mode */
+#define CANSLEEPOK                  ((uint8_t)0x01) /*!&lt; CAN entered the sleep mode */
 
+/**
+  * @}
+  */
+
+/** @defgroup CAN_wake_up_constants 
+  * @{
+  */
+
+#define CANWAKEUPFAILED             ((uint8_t)0x00) /*!&lt; CAN did not leave the sleep mode */
+#define CANWAKEUPOK                 ((uint8_t)0x01) /*!&lt; CAN leaved the sleep mode */
+
+/**
+  * @}
+  */
+
+/** @defgroup CAN_flags 
+  * @{
+  */
+
+#define CAN_FLAG_EWG                ((uint32_t)0x00000001) /*!&lt; Error Warning Flag */
+#define CAN_FLAG_EPV                ((uint32_t)0x00000002) /*!&lt; Error Passive Flag */
+#define CAN_FLAG_BOF                ((uint32_t)0x00000004) /*!&lt; Bus-Off Flag */
+
 #define IS_CAN_FLAG(FLAG) (((FLAG) == CAN_FLAG_EWG) || ((FLAG) == CAN_FLAG_EPV) ||\
                            ((FLAG) == CAN_FLAG_BOF))
 
-/* CAN interrupts */
-#define CAN_IT_RQCP0                ((u32)0x00000005) /* Request completed mailbox 0 */
-#define CAN_IT_RQCP1                ((u32)0x00000006) /* Request completed mailbox 1 */
-#define CAN_IT_RQCP2                ((u32)0x00000007) /* Request completed mailbox 2 */
-#define CAN_IT_TME                  ((u32)0x00000001) /* Transmit mailbox empty */
-#define CAN_IT_FMP0                 ((u32)0x00000002) /* FIFO 0 message pending */
-#define CAN_IT_FF0                  ((u32)0x00000004) /* FIFO 0 full */
-#define CAN_IT_FOV0                 ((u32)0x00000008) /* FIFO 0 overrun */
-#define CAN_IT_FMP1                 ((u32)0x00000010) /* FIFO 1 message pending */
-#define CAN_IT_FF1                  ((u32)0x00000020) /* FIFO 1 full */
-#define CAN_IT_FOV1                 ((u32)0x00000040) /* FIFO 1 overrun */
-#define CAN_IT_EWG                  ((u32)0x00000100) /* Error warning */
-#define CAN_IT_EPV                  ((u32)0x00000200) /* Error passive */
-#define CAN_IT_BOF                  ((u32)0x00000400) /* Bus-off */
-#define CAN_IT_LEC                  ((u32)0x00000800) /* Last error code */
-#define CAN_IT_ERR                  ((u32)0x00008000) /* Error */
-#define CAN_IT_WKU                  ((u32)0x00010000) /* Wake-up */
-#define CAN_IT_SLK                  ((u32)0x00020000) /* Sleep */
+/**
+  * @}
+  */
 
+/** @defgroup CAN_interrupts 
+  * @{
+  */
+
+#define CAN_IT_RQCP0                ((uint32_t)0x00000005) /*!&lt; Request completed mailbox 0 */
+#define CAN_IT_RQCP1                ((uint32_t)0x00000006) /*!&lt; Request completed mailbox 1 */
+#define CAN_IT_RQCP2                ((uint32_t)0x00000007) /*!&lt; Request completed mailbox 2 */
+#define CAN_IT_TME                  ((uint32_t)0x00000001) /*!&lt; Transmit mailbox empty */
+#define CAN_IT_FMP0                 ((uint32_t)0x00000002) /*!&lt; FIFO 0 message pending */
+#define CAN_IT_FF0                  ((uint32_t)0x00000004) /*!&lt; FIFO 0 full */
+#define CAN_IT_FOV0                 ((uint32_t)0x00000008) /*!&lt; FIFO 0 overrun */
+#define CAN_IT_FMP1                 ((uint32_t)0x00000010) /*!&lt; FIFO 1 message pending */
+#define CAN_IT_FF1                  ((uint32_t)0x00000020) /*!&lt; FIFO 1 full */
+#define CAN_IT_FOV1                 ((uint32_t)0x00000040) /*!&lt; FIFO 1 overrun */
+#define CAN_IT_EWG                  ((uint32_t)0x00000100) /*!&lt; Error warning */
+#define CAN_IT_EPV                  ((uint32_t)0x00000200) /*!&lt; Error passive */
+#define CAN_IT_BOF                  ((uint32_t)0x00000400) /*!&lt; Bus-off */
+#define CAN_IT_LEC                  ((uint32_t)0x00000800) /*!&lt; Last error code */
+#define CAN_IT_ERR                  ((uint32_t)0x00008000) /*!&lt; Error */
+#define CAN_IT_WKU                  ((uint32_t)0x00010000) /*!&lt; Wake-up */
+#define CAN_IT_SLK                  ((uint32_t)0x00020000) /*!&lt; Sleep */
+
 #define IS_CAN_ITConfig(IT) (((IT) == CAN_IT_TME)   || ((IT) == CAN_IT_FMP0)  ||\
                              ((IT) == CAN_IT_FF0)   || ((IT) == CAN_IT_FOV0)  ||\
                              ((IT) == CAN_IT_FMP1)  || ((IT) == CAN_IT_FF1)   ||\
@@ -237,27 +475,61 @@
                              ((IT) == CAN_IT_FOV1)   || ((IT) == CAN_IT_EWG)    ||\
                              ((IT) == CAN_IT_EPV)    || ((IT) == CAN_IT_BOF)    ||\
                              ((IT) == CAN_IT_WKU)    || ((IT) == CAN_IT_SLK))
+/**
+  * @}
+  */
 
-/* Exported macro ------------------------------------------------------------*/
-/* Exported function protypes ----------------------------------------------- */
-void CAN_DeInit(void);
-u8 CAN_Init(CAN_InitTypeDef* CAN_InitStruct);
+/**
+  * @}
+  */
+
+/** @defgroup CAN_Exported_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup CAN_Exported_Functions
+  * @{
+  */
+
+void CAN_DeInit(CAN_TypeDef* CANx);
+uint8_t CAN_Init(CAN_TypeDef* CANx, CAN_InitTypeDef* CAN_InitStruct);
 void CAN_FilterInit(CAN_FilterInitTypeDef* CAN_FilterInitStruct);
 void CAN_StructInit(CAN_InitTypeDef* CAN_InitStruct);
-void CAN_ITConfig(u32 CAN_IT, FunctionalState NewState);
-u8 CAN_Transmit(CanTxMsg* TxMessage);
-u8 CAN_TransmitStatus(u8 TransmitMailbox);
-void CAN_CancelTransmit(u8 Mailbox);
-void CAN_FIFORelease(u8 FIFONumber);
-u8 CAN_MessagePending(u8 FIFONumber);
-void CAN_Receive(u8 FIFONumber, CanRxMsg* RxMessage);
-u8 CAN_Sleep(void);
-u8 CAN_WakeUp(void);
-FlagStatus CAN_GetFlagStatus(u32 CAN_FLAG);
-void CAN_ClearFlag(u32 CAN_FLAG);
-ITStatus CAN_GetITStatus(u32 CAN_IT);
-void CAN_ClearITPendingBit(u32 CAN_IT);
+void CAN_SlaveStartBank(uint8_t CAN_BankNumber); 
+void CAN_ITConfig(CAN_TypeDef* CANx, uint32_t CAN_IT, FunctionalState NewState);
+uint8_t CAN_Transmit(CAN_TypeDef* CANx, CanTxMsg* TxMessage);
+uint8_t CAN_TransmitStatus(CAN_TypeDef* CANx, uint8_t TransmitMailbox);
+void CAN_CancelTransmit(CAN_TypeDef* CANx, uint8_t Mailbox);
+void CAN_FIFORelease(CAN_TypeDef* CANx, uint8_t FIFONumber);
+uint8_t CAN_MessagePending(CAN_TypeDef* CANx, uint8_t FIFONumber);
+void CAN_Receive(CAN_TypeDef* CANx, uint8_t FIFONumber, CanRxMsg* RxMessage);
+void CAN_DBGFreeze(CAN_TypeDef* CANx, FunctionalState NewState);
+uint8_t CAN_Sleep(CAN_TypeDef* CANx);
+uint8_t CAN_WakeUp(CAN_TypeDef* CANx);
+FlagStatus CAN_GetFlagStatus(CAN_TypeDef* CANx, uint32_t CAN_FLAG);
+void CAN_ClearFlag(CAN_TypeDef* CANx, uint32_t CAN_FLAG);
+ITStatus CAN_GetITStatus(CAN_TypeDef* CANx, uint32_t CAN_IT);
+void CAN_ClearITPendingBit(CAN_TypeDef* CANx, uint32_t CAN_IT);
 
+#ifdef __cplusplus
+}
+#endif
+
 #endif /* __STM32F10x_CAN_H */
+/**
+  * @}
+  */
 
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2009 STMicroelectronics *****END OF FILE****/

Modified: trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_crc.h
===================================================================
--- trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_crc.h	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_crc.h	2009-07-08 23:39:34 UTC (rev 354)
@@ -1,37 +1,93 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_crc.h
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file contains all the functions prototypes for the
-*                      CRC firmware library.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
+/**
+  ******************************************************************************
+  * @file    stm32f10x_crc.h
+  * @author  MCD Application Team
+  * @version V3.1.0
+  * @date    06/19/2009
+  * @brief   This file contains all the functions prototypes for the CRC firmware 
+  *          library.
+  ******************************************************************************
+  * @copy
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * &lt;h2&gt;&lt;center&gt;&copy; COPYRIGHT 2009 STMicroelectronics&lt;/center&gt;&lt;/h2&gt;
+  */ 
 
 /* Define to prevent recursive inclusion -------------------------------------*/
 #ifndef __STM32F10x_CRC_H
 #define __STM32F10x_CRC_H
 
+#ifdef __cplusplus
+ extern &quot;C&quot; {
+#endif
+
 /* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_map.h&quot;
+#include &quot;stm32f10x.h&quot;
 
-/* Exported types ------------------------------------------------------------*/
-/* Exported constants --------------------------------------------------------*/
-/* Exported macro ------------------------------------------------------------*/
-/* Exported functions ------------------------------------------------------- */
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @addtogroup CRC
+  * @{
+  */
+
+/** @defgroup CRC_Exported_Types
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup CRC_Exported_Constants
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup CRC_Exported_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup CRC_Exported_Functions
+  * @{
+  */
+
 void CRC_ResetDR(void);
-u32 CRC_CalcCRC(u32 Data);
-u32 CRC_CalcBlockCRC(u32 pBuffer[], u32 BufferLength);
-u32 CRC_GetCRC(void);
-void CRC_SetIDRegister(u8 IDValue);
-u8 CRC_GetIDRegister(void);
+uint32_t CRC_CalcCRC(uint32_t Data);
+uint32_t CRC_CalcBlockCRC(uint32_t pBuffer[], uint32_t BufferLength);
+uint32_t CRC_GetCRC(void);
+void CRC_SetIDRegister(uint8_t IDValue);
+uint8_t CRC_GetIDRegister(void);
 
+#ifdef __cplusplus
+}
+#endif
+
 #endif /* __STM32F10x_CRC_H */
+/**
+  * @}
+  */
 
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2009 STMicroelectronics *****END OF FILE****/

Modified: trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_dac.h
===================================================================
--- trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_dac.h	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_dac.h	2009-07-08 23:39:34 UTC (rev 354)
@@ -1,48 +1,94 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_dac.h
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file contains all the functions prototypes for the
-*                      DAC firmware library.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
+/**
+  ******************************************************************************
+  * @file    stm32f10x_dac.h
+  * @author  MCD Application Team
+  * @version V3.1.0
+  * @date    06/19/2009
+  * @brief   This file contains all the functions prototypes for the DAC firmware 
+  *          library.
+  ******************************************************************************
+  * @copy
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * &lt;h2&gt;&lt;center&gt;&copy; COPYRIGHT 2009 STMicroelectronics&lt;/center&gt;&lt;/h2&gt;
+  */ 
 
 /* Define to prevent recursive inclusion -------------------------------------*/
 #ifndef __STM32F10x_DAC_H
 #define __STM32F10x_DAC_H
 
+#ifdef __cplusplus
+ extern &quot;C&quot; {
+#endif
+
 /* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_map.h&quot;
+#include &quot;stm32f10x.h&quot;
 
-/* Exported types ------------------------------------------------------------*/
-/* DAC Init structure definition */
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @addtogroup DAC
+  * @{
+  */
+
+/** @defgroup DAC_Exported_Types
+  * @{
+  */
+
+/** 
+  * @brief  DAC Init structure definition
+  */
+
 typedef struct
 {
-  u32 DAC_Trigger;
-  u32 DAC_WaveGeneration;
-  u32 DAC_LFSRUnmask_TriangleAmplitude;
-  u32 DAC_OutputBuffer; 
+  uint32_t DAC_Trigger;                      /*!&lt; Specifies the external trigger for the selected DAC channel.
+                                                  This parameter can be a value of @ref DAC_trigger_selection */
+
+  uint32_t DAC_WaveGeneration;               /*!&lt; Specifies whether DAC channel noise waves or triangle waves
+                                                  are generated, or whether no wave is generated.
+                                                  This parameter can be a value of @ref DAC_wave_generation */
+
+  uint32_t DAC_LFSRUnmask_TriangleAmplitude; /*!&lt; Specifies the LFSR mask for noise wave generation or
+                                                  the maximum amplitude triangle generation for the DAC channel. 
+                                                  This parameter can be a value of @ref DAC_lfsrunmask_triangleamplitude */
+
+  uint32_t DAC_OutputBuffer;                 /*!&lt; Specifies whether the DAC channel output buffer is enabled or disabled.
+                                                  This parameter can be a value of @ref DAC_output_buffer */
 }DAC_InitTypeDef;
 
-/* Exported constants --------------------------------------------------------*/
-/* DAC trigger selection */
-#define DAC_Trigger_None                   ((u32)0x00000000)
-#define DAC_Trigger_T6_TRGO                ((u32)0x00000004)
-#define DAC_Trigger_T8_TRGO                ((u32)0x0000000C)
-#define DAC_Trigger_T7_TRGO                ((u32)0x00000014)
-#define DAC_Trigger_T5_TRGO                ((u32)0x0000001C)
-#define DAC_Trigger_T2_TRGO                ((u32)0x00000024)
-#define DAC_Trigger_T4_TRGO                ((u32)0x0000002C)
-#define DAC_Trigger_Ext_IT9                ((u32)0x00000034)
-#define DAC_Trigger_Software               ((u32)0x0000003C)
+/**
+  * @}
+  */
 
+/** @defgroup DAC_Exported_Constants
+  * @{
+  */
+
+/** @defgroup DAC_trigger_selection 
+  * @{
+  */
+
+#define DAC_Trigger_None                   ((uint32_t)0x00000000) /*!&lt; Conversion is automatic once the DAC1_DHRxxxx register 
+                                                                       has been loaded, and not by external trigger */
+#define DAC_Trigger_T6_TRGO                ((uint32_t)0x00000004) /*!&lt; TIM6 TRGO selected as external conversion trigger for DAC channel */
+#define DAC_Trigger_T8_TRGO                ((uint32_t)0x0000000C) /*!&lt; TIM8 TRGO selected as external conversion trigger for DAC channel
+                                                                       only in High-density devices*/
+#define DAC_Trigger_T3_TRGO                ((uint32_t)0x0000000C) /*!&lt; TIM8 TRGO selected as external conversion trigger for DAC channel
+                                                                       only in Connectivity line devices */
+#define DAC_Trigger_T7_TRGO                ((uint32_t)0x00000014) /*!&lt; TIM7 TRGO selected as external conversion trigger for DAC channel */
+#define DAC_Trigger_T5_TRGO                ((uint32_t)0x0000001C) /*!&lt; TIM5 TRGO selected as external conversion trigger for DAC channel */
+#define DAC_Trigger_T2_TRGO                ((uint32_t)0x00000024) /*!&lt; TIM2 TRGO selected as external conversion trigger for DAC channel */
+#define DAC_Trigger_T4_TRGO                ((uint32_t)0x0000002C) /*!&lt; TIM4 TRGO selected as external conversion trigger for DAC channel */
+#define DAC_Trigger_Ext_IT9                ((uint32_t)0x00000034) /*!&lt; EXTI Line9 event selected as external conversion trigger for DAC channel */
+#define DAC_Trigger_Software               ((uint32_t)0x0000003C) /*!&lt; Conversion started by software trigger for DAC channel */
+
 #define IS_DAC_TRIGGER(TRIGGER) (((TRIGGER) == DAC_Trigger_None) || \
                                  ((TRIGGER) == DAC_Trigger_T6_TRGO) || \
                                  ((TRIGGER) == DAC_Trigger_T8_TRGO) || \
@@ -53,41 +99,52 @@
                                  ((TRIGGER) == DAC_Trigger_Ext_IT9) || \
                                  ((TRIGGER) == DAC_Trigger_Software))
 
-/* DAC wave generation */
-#define DAC_WaveGeneration_None            ((u32)0x00000000)
-#define DAC_WaveGeneration_Noise           ((u32)0x00000040)
-#define DAC_WaveGeneration_Triangle        ((u32)0x00000080)
+/**
+  * @}
+  */
 
+/** @defgroup DAC_wave_generation 
+  * @{
+  */
+
+#define DAC_WaveGeneration_None            ((uint32_t)0x00000000)
+#define DAC_WaveGeneration_Noise           ((uint32_t)0x00000040)
+#define DAC_WaveGeneration_Triangle        ((uint32_t)0x00000080)
 #define IS_DAC_GENERATE_WAVE(WAVE) (((WAVE) == DAC_WaveGeneration_None) || \
                                     ((WAVE) == DAC_WaveGeneration_Noise) || \
                                     ((WAVE) == DAC_WaveGeneration_Triangle))
+/**
+  * @}
+  */
 
-/* DAC noise wave generation mask / triangle wave generation max amplitude */
-#define DAC_LFSRUnmask_Bit0                ((u32)0x00000000)
-#define DAC_LFSRUnmask_Bits1_0             ((u32)0x00000100)
-#define DAC_LFSRUnmask_Bits2_0             ((u32)0x00000200)
-#define DAC_LFSRUnmask_Bits3_0             ((u32)0x00000300)
-#define DAC_LFSRUnmask_Bits4_0             ((u32)0x00000400)
-#define DAC_LFSRUnmask_Bits5_0             ((u32)0x00000500)
-#define DAC_LFSRUnmask_Bits6_0             ((u32)0x00000600)
-#define DAC_LFSRUnmask_Bits7_0             ((u32)0x00000700)
-#define DAC_LFSRUnmask_Bits8_0             ((u32)0x00000800)
-#define DAC_LFSRUnmask_Bits9_0             ((u32)0x00000900)
-#define DAC_LFSRUnmask_Bits10_0            ((u32)0x00000A00)
-#define DAC_LFSRUnmask_Bits11_0            ((u32)0x00000B00)
+/** @defgroup DAC_lfsrunmask_triangleamplitude
+  * @{
+  */
 
-#define DAC_TriangleAmplitude_1            ((u32)0x00000000)
-#define DAC_TriangleAmplitude_3            ((u32)0x00000100)
-#define DAC_TriangleAmplitude_7            ((u32)0x00000200)
-#define DAC_TriangleAmplitude_15           ((u32)0x00000300)
-#define DAC_TriangleAmplitude_31           ((u32)0x00000400)
-#define DAC_TriangleAmplitude_63           ((u32)0x00000500)
-#define DAC_TriangleAmplitude_127          ((u32)0x00000600)
-#define DAC_TriangleAmplitude_255          ((u32)0x00000700)
-#define DAC_TriangleAmplitude_511          ((u32)0x00000800)
-#define DAC_TriangleAmplitude_1023         ((u32)0x00000900)
-#define DAC_TriangleAmplitude_2047         ((u32)0x00000A00)
-#define DAC_TriangleAmplitude_4095         ((u32)0x00000B00)
+#define DAC_LFSRUnmask_Bit0                ((uint32_t)0x00000000) /*!&lt; Unmask DAC channel LFSR bit0 for noise wave generation */
+#define DAC_LFSRUnmask_Bits1_0             ((uint32_t)0x00000100) /*!&lt; Unmask DAC channel LFSR bit[1:0] for noise wave generation */
+#define DAC_LFSRUnmask_Bits2_0             ((uint32_t)0x00000200) /*!&lt; Unmask DAC channel LFSR bit[2:0] for noise wave generation */
+#define DAC_LFSRUnmask_Bits3_0             ((uint32_t)0x00000300) /*!&lt; Unmask DAC channel LFSR bit[3:0] for noise wave generation */
+#define DAC_LFSRUnmask_Bits4_0             ((uint32_t)0x00000400) /*!&lt; Unmask DAC channel LFSR bit[4:0] for noise wave generation */
+#define DAC_LFSRUnmask_Bits5_0             ((uint32_t)0x00000500) /*!&lt; Unmask DAC channel LFSR bit[5:0] for noise wave generation */
+#define DAC_LFSRUnmask_Bits6_0             ((uint32_t)0x00000600) /*!&lt; Unmask DAC channel LFSR bit[6:0] for noise wave generation */
+#define DAC_LFSRUnmask_Bits7_0             ((uint32_t)0x00000700) /*!&lt; Unmask DAC channel LFSR bit[7:0] for noise wave generation */
+#define DAC_LFSRUnmask_Bits8_0             ((uint32_t)0x00000800) /*!&lt; Unmask DAC channel LFSR bit[8:0] for noise wave generation */
+#define DAC_LFSRUnmask_Bits9_0             ((uint32_t)0x00000900) /*!&lt; Unmask DAC channel LFSR bit[9:0] for noise wave generation */
+#define DAC_LFSRUnmask_Bits10_0            ((uint32_t)0x00000A00) /*!&lt; Unmask DAC channel LFSR bit[10:0] for noise wave generation */
+#define DAC_LFSRUnmask_Bits11_0            ((uint32_t)0x00000B00) /*!&lt; Unmask DAC channel LFSR bit[11:0] for noise wave generation */
+#define DAC_TriangleAmplitude_1            ((uint32_t)0x00000000) /*!&lt; Select max triangle amplitude of 1 */
+#define DAC_TriangleAmplitude_3            ((uint32_t)0x00000100) /*!&lt; Select max triangle amplitude of 3 */
+#define DAC_TriangleAmplitude_7            ((uint32_t)0x00000200) /*!&lt; Select max triangle amplitude of 7 */
+#define DAC_TriangleAmplitude_15           ((uint32_t)0x00000300) /*!&lt; Select max triangle amplitude of 15 */
+#define DAC_TriangleAmplitude_31           ((uint32_t)0x00000400) /*!&lt; Select max triangle amplitude of 31 */
+#define DAC_TriangleAmplitude_63           ((uint32_t)0x00000500) /*!&lt; Select max triangle amplitude of 63 */
+#define DAC_TriangleAmplitude_127          ((uint32_t)0x00000600) /*!&lt; Select max triangle amplitude of 127 */
+#define DAC_TriangleAmplitude_255          ((uint32_t)0x00000700) /*!&lt; Select max triangle amplitude of 255 */
+#define DAC_TriangleAmplitude_511          ((uint32_t)0x00000800) /*!&lt; Select max triangle amplitude of 511 */
+#define DAC_TriangleAmplitude_1023         ((uint32_t)0x00000900) /*!&lt; Select max triangle amplitude of 1023 */
+#define DAC_TriangleAmplitude_2047         ((uint32_t)0x00000A00) /*!&lt; Select max triangle amplitude of 2047 */
+#define DAC_TriangleAmplitude_4095         ((uint32_t)0x00000B00) /*!&lt; Select max triangle amplitude of 4095 */
 
 #define IS_DAC_LFSR_UNMASK_TRIANGLE_AMPLITUDE(VALUE) (((VALUE) == DAC_LFSRUnmask_Bit0) || \
                                                       ((VALUE) == DAC_LFSRUnmask_Bits1_0) || \
@@ -113,55 +170,113 @@
                                                       ((VALUE) == DAC_TriangleAmplitude_1023) || \
                                                       ((VALUE) == DAC_TriangleAmplitude_2047) || \
                                                       ((VALUE) == DAC_TriangleAmplitude_4095))
+/**
+  * @}
+  */
 
-/* DAC output buffer */
-#define DAC_OutputBuffer_Enable            ((u32)0x00000000)
-#define DAC_OutputBuffer_Disable           ((u32)0x00000002)
+/** @defgroup DAC_output_buffer 
+  * @{
+  */
 
+#define DAC_OutputBuffer_Enable            ((uint32_t)0x00000000)
+#define DAC_OutputBuffer_Disable           ((uint32_t)0x00000002)
 #define IS_DAC_OUTPUT_BUFFER_STATE(STATE) (((STATE) == DAC_OutputBuffer_Enable) || \
                                            ((STATE) == DAC_OutputBuffer_Disable))
+/**
+  * @}
+  */
 
-/* DAC Channel selection */
-#define DAC_Channel_1                      ((u32)0x00000000)
-#define DAC_Channel_2                      ((u32)0x00000010)
+/** @defgroup DAC_Channel_selection 
+  * @{
+  */
 
+#define DAC_Channel_1                      ((uint32_t)0x00000000)
+#define DAC_Channel_2                      ((uint32_t)0x00000010)
 #define IS_DAC_CHANNEL(CHANNEL) (((CHANNEL) == DAC_Channel_1) || \
                                  ((CHANNEL) == DAC_Channel_2))
+/**
+  * @}
+  */
 
-/* DAC data alignement */
-#define DAC_Align_12b_R                    ((u32)0x00000000)
-#define DAC_Align_12b_L                    ((u32)0x00000004)
-#define DAC_Align_8b_R                     ((u32)0x00000008)
+/** @defgroup DAC_data_alignement 
+  * @{
+  */
 
+#define DAC_Align_12b_R                    ((uint32_t)0x00000000)
+#define DAC_Align_12b_L                    ((uint32_t)0x00000004)
+#define DAC_Align_8b_R                     ((uint32_t)0x00000008)
 #define IS_DAC_ALIGN(ALIGN) (((ALIGN) == DAC_Align_12b_R) || \
                              ((ALIGN) == DAC_Align_12b_L) || \
                              ((ALIGN) == DAC_Align_8b_R))
+/**
+  * @}
+  */
 
-/* DAC wave generation */
-#define DAC_Wave_Noise                     ((u32)0x00000040)
-#define DAC_Wave_Triangle                  ((u32)0x00000080)
+/** @defgroup DAC_wave_generation 
+  * @{
+  */
 
+#define DAC_Wave_Noise                     ((uint32_t)0x00000040)
+#define DAC_Wave_Triangle                  ((uint32_t)0x00000080)
 #define IS_DAC_WAVE(WAVE) (((WAVE) == DAC_Wave_Noise) || \
                            ((WAVE) == DAC_Wave_Triangle))
+/**
+  * @}
+  */
 
-/* DAC data ------------------------------------------------------------------*/
+/** @defgroup DAC_data 
+  * @{
+  */
+
 #define IS_DAC_DATA(DATA) ((DATA) &lt;= 0xFFF0) 
+/**
+  * @}
+  */
 
-/* Exported macro ------------------------------------------------------------*/
-/* Exported functions --------------------------------------------------------*/
+/**
+  * @}
+  */
+
+/** @defgroup DAC_Exported_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup DAC_Exported_Functions
+  * @{
+  */
+
 void DAC_DeInit(void);
-void DAC_Init(u32 DAC_Channel, DAC_InitTypeDef* DAC_InitStruct);
+void DAC_Init(uint32_t DAC_Channel, DAC_InitTypeDef* DAC_InitStruct);
 void DAC_StructInit(DAC_InitTypeDef* DAC_InitStruct);
-void DAC_Cmd(u32 DAC_Channel, FunctionalState NewState);
-void DAC_DMACmd(u32 DAC_Channel, FunctionalState NewState);
-void DAC_SoftwareTriggerCmd(u32 DAC_Channel, FunctionalState NewState);
+void DAC_Cmd(uint32_t DAC_Channel, FunctionalState NewState);
+void DAC_DMACmd(uint32_t DAC_Channel, FunctionalState NewState);
+void DAC_SoftwareTriggerCmd(uint32_t DAC_Channel, FunctionalState NewState);
 void DAC_DualSoftwareTriggerCmd(FunctionalState NewState);
-void DAC_WaveGenerationCmd(u32 DAC_Channel, u32 DAC_Wave, FunctionalState NewState);
-void DAC_SetChannel1Data(u32 DAC_Align, u16 Data);
-void DAC_SetChannel2Data(u32 DAC_Align, u16 Data);
-void DAC_SetDualChannelData(u32 DAC_Align, u16 Data2, u16 Data1);
-u16 DAC_GetDataOutputValue(u32 DAC_Channel);
+void DAC_WaveGenerationCmd(uint32_t DAC_Channel, uint32_t DAC_Wave, FunctionalState NewState);
+void DAC_SetChannel1Data(uint32_t DAC_Align, uint16_t Data);
+void DAC_SetChannel2Data(uint32_t DAC_Align, uint16_t Data);
+void DAC_SetDualChannelData(uint32_t DAC_Align, uint16_t Data2, uint16_t Data1);
+uint16_t DAC_GetDataOutputValue(uint32_t DAC_Channel);
 
+#ifdef __cplusplus
+}
+#endif
+
 #endif /*__STM32F10x_DAC_H */
+/**
+  * @}
+  */
 
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2009 STMicroelectronics *****END OF FILE****/

Modified: trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_dbgmcu.h
===================================================================
--- trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_dbgmcu.h	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_dbgmcu.h	2009-07-08 23:39:34 UTC (rev 354)
@@ -1,55 +1,109 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_dbgmcu.h
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file contains all the functions prototypes for the
-*                      DBGMCU firmware library.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
+/**
+  ******************************************************************************
+  * @file    stm32f10x_dbgmcu.h
+  * @author  MCD Application Team
+  * @version V3.1.0
+  * @date    06/19/2009
+  * @brief   This file contains all the functions prototypes for the DBGMCU 
+  *          firmware library.
+  ******************************************************************************
+  * @copy
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * &lt;h2&gt;&lt;center&gt;&copy; COPYRIGHT 2009 STMicroelectronics&lt;/center&gt;&lt;/h2&gt;
+  */ 
 
 /* Define to prevent recursive inclusion -------------------------------------*/
 #ifndef __STM32F10x_DBGMCU_H
 #define __STM32F10x_DBGMCU_H
 
+#ifdef __cplusplus
+ extern &quot;C&quot; {
+#endif
+
 /* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_map.h&quot;
+#include &quot;stm32f10x.h&quot;
 
-/* Exported types ------------------------------------------------------------*/
-/* Exported constants --------------------------------------------------------*/
-#define DBGMCU_SLEEP                 ((u32)0x00000001)
-#define DBGMCU_STOP                  ((u32)0x00000002)
-#define DBGMCU_STANDBY               ((u32)0x00000004)
-#define DBGMCU_IWDG_STOP             ((u32)0x00000100)
-#define DBGMCU_WWDG_STOP             ((u32)0x00000200)
-#define DBGMCU_TIM1_STOP             ((u32)0x00000400)
-#define DBGMCU_TIM2_STOP             ((u32)0x00000800)
-#define DBGMCU_TIM3_STOP             ((u32)0x00001000)
-#define DBGMCU_TIM4_STOP             ((u32)0x00002000)
-#define DBGMCU_CAN_STOP              ((u32)0x00004000)
-#define DBGMCU_I2C1_SMBUS_TIMEOUT    ((u32)0x00008000)
-#define DBGMCU_I2C2_SMBUS_TIMEOUT    ((u32)0x00010000)
-#define DBGMCU_TIM5_STOP             ((u32)0x00020000)
-#define DBGMCU_TIM6_STOP             ((u32)0x00040000)
-#define DBGMCU_TIM7_STOP             ((u32)0x00080000)
-#define DBGMCU_TIM8_STOP             ((u32)0x00100000)
-                                           
-#define IS_DBGMCU_PERIPH(PERIPH) ((((PERIPH) &amp; 0xFFE000F8) == 0x00) &amp;&amp; ((PERIPH) != 0x00))
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
 
-/* Exported macro ------------------------------------------------------------*/
-/* Exported functions ------------------------------------------------------- */
-u32 DBGMCU_GetREVID(void);
-u32 DBGMCU_GetDEVID(void);
-void DBGMCU_Config(u32 DBGMCU_Periph, FunctionalState NewState);
+/** @addtogroup DBGMCU
+  * @{
+  */
 
+/** @defgroup DBGMCU_Exported_Types
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup DBGMCU_Exported_Constants
+  * @{
+  */
+
+#define DBGMCU_SLEEP                 ((uint32_t)0x00000001)
+#define DBGMCU_STOP                  ((uint32_t)0x00000002)
+#define DBGMCU_STANDBY               ((uint32_t)0x00000004)
+#define DBGMCU_IWDG_STOP             ((uint32_t)0x00000100)
+#define DBGMCU_WWDG_STOP             ((uint32_t)0x00000200)
+#define DBGMCU_TIM1_STOP             ((uint32_t)0x00000400)
+#define DBGMCU_TIM2_STOP             ((uint32_t)0x00000800)
+#define DBGMCU_TIM3_STOP             ((uint32_t)0x00001000)
+#define DBGMCU_TIM4_STOP             ((uint32_t)0x00002000)
+#define DBGMCU_CAN1_STOP             ((uint32_t)0x00004000)
+#define DBGMCU_I2C1_SMBUS_TIMEOUT    ((uint32_t)0x00008000)
+#define DBGMCU_I2C2_SMBUS_TIMEOUT    ((uint32_t)0x00010000)
+#define DBGMCU_TIM8_STOP             ((uint32_t)0x00020000)
+#define DBGMCU_TIM5_STOP             ((uint32_t)0x00040000)
+#define DBGMCU_TIM6_STOP             ((uint32_t)0x00080000)
+#define DBGMCU_TIM7_STOP             ((uint32_t)0x00100000)
+#define DBGMCU_CAN2_STOP             ((uint32_t)0x00200000)
+
+#define IS_DBGMCU_PERIPH(PERIPH) ((((PERIPH) &amp; 0xFFC000F8) == 0x00) &amp;&amp; ((PERIPH) != 0x00))
+/**
+  * @}
+  */ 
+
+/** @defgroup DBGMCU_Exported_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup DBGMCU_Exported_Functions
+  * @{
+  */
+
+uint32_t DBGMCU_GetREVID(void);
+uint32_t DBGMCU_GetDEVID(void);
+void DBGMCU_Config(uint32_t DBGMCU_Periph, FunctionalState NewState);
+
+#ifdef __cplusplus
+}
+#endif
+
 #endif /* __STM32F10x_DBGMCU_H */
+/**
+  * @}
+  */
 
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
+/**
+  * @}
+  */
 
+/**
+  * @}
+  */
 
+/******************* (C) COPYRIGHT 2009 STMicroelectronics *****END OF FILE****/

Modified: trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_dma.h
===================================================================
--- trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_dma.h	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_dma.h	2009-07-08 23:39:34 UTC (rev 354)
@@ -1,178 +1,273 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_dma.h
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file contains all the functions prototypes for the
-*                      DMA firmware library.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
+/**
+  ******************************************************************************
+  * @file    stm32f10x_dma.h
+  * @author  MCD Application Team
+  * @version V3.1.0
+  * @date    06/19/2009
+  * @brief   This file contains all the functions prototypes for the DMA firmware 
+  *          library.
+  ******************************************************************************
+  * @copy
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * &lt;h2&gt;&lt;center&gt;&copy; COPYRIGHT 2009 STMicroelectronics&lt;/center&gt;&lt;/h2&gt;
+  */ 
 
 /* Define to prevent recursive inclusion -------------------------------------*/
 #ifndef __STM32F10x_DMA_H
 #define __STM32F10x_DMA_H
 
+#ifdef __cplusplus
+ extern &quot;C&quot; {
+#endif
+
 /* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_map.h&quot;
+#include &quot;stm32f10x.h&quot;
 
-/* Exported types ------------------------------------------------------------*/
-/* DMA Init structure definition */
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @addtogroup DMA
+  * @{
+  */
+
+/** @defgroup DMA_Exported_Types
+  * @{
+  */
+
+/** 
+  * @brief  DMA Init structure definition
+  */
+
 typedef struct
 {
-  u32 DMA_PeripheralBaseAddr;
-  u32 DMA_MemoryBaseAddr;
-  u32 DMA_DIR;
-  u32 DMA_BufferSize;
-  u32 DMA_PeripheralInc;
-  u32 DMA_MemoryInc;
-  u32 DMA_PeripheralDataSize;
-  u32 DMA_MemoryDataSize;
-  u32 DMA_Mode;
-  u32 DMA_Priority;
-  u32 DMA_M2M;
+  uint32_t DMA_PeripheralBaseAddr; /*!&lt; Specifies the peripheral base address for DMAy Channelx. */
+
+  uint32_t DMA_MemoryBaseAddr;     /*!&lt; Specifies the memory base address for DMAy Channelx. */
+
+  uint32_t DMA_DIR;                /*!&lt; Specifies if the peripheral is the source or destination.
+                                        This parameter can be a value of @ref DMA_data_transfer_direction */
+
+  uint32_t DMA_BufferSize;         /*!&lt; Specifies the buffer size, in data unit, of the specified Channel. 
+                                        The data unit is equal to the configuration set in DMA_PeripheralDataSize
+                                        or DMA_MemoryDataSize members depending in the transfer direction. */
+
+  uint32_t DMA_PeripheralInc;      /*!&lt; Specifies whether the Peripheral address register is incremented or not.
+                                        This parameter can be a value of @ref DMA_peripheral_incremented_mode */
+
+  uint32_t DMA_MemoryInc;          /*!&lt; Specifies whether the memory address register is incremented or not.
+                                        This parameter can be a value of @ref DMA_memory_incremented_mode */
+
+  uint32_t DMA_PeripheralDataSize; /*!&lt; Specifies the Peripheral data width.
+                                        This parameter can be a value of @ref DMA_peripheral_data_size */
+
+  uint32_t DMA_MemoryDataSize;     /*!&lt; Specifies the Memory data width.
+                                        This parameter can be a value of @ref DMA_memory_data_size */
+
+  uint32_t DMA_Mode;               /*!&lt; Specifies the operation mode of the DMAy Channelx.
+                                        This parameter can be a value of @ref DMA_circular_normal_mode.
+                                        @note: The circular buffer mode cannot be used if the memory-to-memory
+                                              data transfer is configured on the selected Channel */
+
+  uint32_t DMA_Priority;           /*!&lt; Specifies the software priority for the DMAy Channelx.
+                                        This parameter can be a value of @ref DMA_priority_level */
+
+  uint32_t DMA_M2M;                /*!&lt; Specifies if the DMAy Channelx will be used in memory-to-memory transfer.
+                                        This parameter can be a value of @ref DMA_memory_to_memory */
 }DMA_InitTypeDef;
 
-/* Exported constants --------------------------------------------------------*/
-#define IS_DMA_ALL_PERIPH(PERIPH) (((*(u32*)&amp;(PERIPH)) == DMA1_Channel1_BASE) || \
-                                   ((*(u32*)&amp;(PERIPH)) == DMA1_Channel2_BASE)  || \
-                                   ((*(u32*)&amp;(PERIPH)) == DMA1_Channel3_BASE)  || \
-                                   ((*(u32*)&amp;(PERIPH)) == DMA1_Channel4_BASE)  || \
-                                   ((*(u32*)&amp;(PERIPH)) == DMA1_Channel5_BASE)  || \
-                                   ((*(u32*)&amp;(PERIPH)) == DMA1_Channel6_BASE)  || \
-                                   ((*(u32*)&amp;(PERIPH)) == DMA1_Channel7_BASE)  || \
-                                   ((*(u32*)&amp;(PERIPH)) == DMA2_Channel1_BASE)  || \
-                                   ((*(u32*)&amp;(PERIPH)) == DMA2_Channel2_BASE)  || \
-                                   ((*(u32*)&amp;(PERIPH)) == DMA2_Channel3_BASE)  || \
-                                   ((*(u32*)&amp;(PERIPH)) == DMA2_Channel4_BASE)  || \
-                                   ((*(u32*)&amp;(PERIPH)) == DMA2_Channel5_BASE))
+/**
+  * @}
+  */
 
-/* DMA data transfer direction -----------------------------------------------*/
-#define DMA_DIR_PeripheralDST              ((u32)0x00000010)
-#define DMA_DIR_PeripheralSRC              ((u32)0x00000000)
+/** @defgroup DMA_Exported_Constants
+  * @{
+  */
 
+#define IS_DMA_ALL_PERIPH(PERIPH) (((PERIPH) == DMA1_Channel1) || \
+                                   ((PERIPH) == DMA1_Channel2) || \
+                                   ((PERIPH) == DMA1_Channel3) || \
+                                   ((PERIPH) == DMA1_Channel4) || \
+                                   ((PERIPH) == DMA1_Channel5) || \
+                                   ((PERIPH) == DMA1_Channel6) || \
+                                   ((PERIPH) == DMA1_Channel7) || \
+                                   ((PERIPH) == DMA2_Channel1) || \
+                                   ((PERIPH) == DMA2_Channel2) || \
+                                   ((PERIPH) == DMA2_Channel3) || \
+                                   ((PERIPH) == DMA2_Channel4) || \
+                                   ((PERIPH) == DMA2_Channel5))
+
+/** @defgroup DMA_data_transfer_direction 
+  * @{
+  */
+
+#define DMA_DIR_PeripheralDST              ((uint32_t)0x00000010)
+#define DMA_DIR_PeripheralSRC              ((uint32_t)0x00000000)
 #define IS_DMA_DIR(DIR) (((DIR) == DMA_DIR_PeripheralDST) || \
                          ((DIR) == DMA_DIR_PeripheralSRC))
+/**
+  * @}
+  */
 
-/* DMA peripheral incremented mode -------------------------------------------*/
-#define DMA_PeripheralInc_Enable           ((u32)0x00000040)
-#define DMA_PeripheralInc_Disable          ((u32)0x00000000)
+/** @defgroup DMA_peripheral_incremented_mode 
+  * @{
+  */
 
+#define DMA_PeripheralInc_Enable           ((uint32_t)0x00000040)
+#define DMA_PeripheralInc_Disable          ((uint32_t)0x00000000)
 #define IS_DMA_PERIPHERAL_INC_STATE(STATE) (((STATE) == DMA_PeripheralInc_Enable) || \
                                             ((STATE) == DMA_PeripheralInc_Disable))
+/**
+  * @}
+  */
 
-/* DMA memory incremented mode -----------------------------------------------*/
-#define DMA_MemoryInc_Enable               ((u32)0x00000080)
-#define DMA_MemoryInc_Disable              ((u32)0x00000000)
+/** @defgroup DMA_memory_incremented_mode 
+  * @{
+  */
 
+#define DMA_MemoryInc_Enable               ((uint32_t)0x00000080)
+#define DMA_MemoryInc_Disable              ((uint32_t)0x00000000)
 #define IS_DMA_MEMORY_INC_STATE(STATE) (((STATE) == DMA_MemoryInc_Enable) || \
                                         ((STATE) == DMA_MemoryInc_Disable))
+/**
+  * @}
+  */
 
-/* DMA peripheral data size --------------------------------------------------*/
-#define DMA_PeripheralDataSize_Byte        ((u32)0x00000000)
-#define DMA_PeripheralDataSize_HalfWord    ((u32)0x00000100)
-#define DMA_PeripheralDataSize_Word        ((u32)0x00000200)
+/** @defgroup DMA_peripheral_data_size 
+  * @{
+  */
 
+#define DMA_PeripheralDataSize_Byte        ((uint32_t)0x00000000)
+#define DMA_PeripheralDataSize_HalfWord    ((uint32_t)0x00000100)
+#define DMA_PeripheralDataSize_Word        ((uint32_t)0x00000200)
 #define IS_DMA_PERIPHERAL_DATA_SIZE(SIZE) (((SIZE) == DMA_PeripheralDataSize_Byte) || \
                                            ((SIZE) == DMA_PeripheralDataSize_HalfWord) || \
                                            ((SIZE) == DMA_PeripheralDataSize_Word))
+/**
+  * @}
+  */
 
-/* DMA memory data size ------------------------------------------------------*/
-#define DMA_MemoryDataSize_Byte            ((u32)0x00000000)
-#define DMA_MemoryDataSize_HalfWord        ((u32)0x00000400)
-#define DMA_MemoryDataSize_Word            ((u32)0x00000800)
+/** @defgroup DMA_memory_data_size 
+  * @{
+  */
 
+#define DMA_MemoryDataSize_Byte            ((uint32_t)0x00000000)
+#define DMA_MemoryDataSize_HalfWord        ((uint32_t)0x00000400)
+#define DMA_MemoryDataSize_Word            ((uint32_t)0x00000800)
 #define IS_DMA_MEMORY_DATA_SIZE(SIZE) (((SIZE) == DMA_MemoryDataSize_Byte) || \
                                        ((SIZE) == DMA_MemoryDataSize_HalfWord) || \
                                        ((SIZE) == DMA_MemoryDataSize_Word))
+/**
+  * @}
+  */
 
-/* DMA circular/normal mode --------------------------------------------------*/
-#define DMA_Mode_Circular                  ((u32)0x00000020)
-#define DMA_Mode_Normal                    ((u32)0x00000000)
+/** @defgroup DMA_circular_normal_mode 
+  * @{
+  */
 
+#define DMA_Mode_Circular                  ((uint32_t)0x00000020)
+#define DMA_Mode_Normal                    ((uint32_t)0x00000000)
 #define IS_DMA_MODE(MODE) (((MODE) == DMA_Mode_Circular) || ((MODE) == DMA_Mode_Normal))
+/**
+  * @}
+  */
 
-/* DMA priority level --------------------------------------------------------*/
-#define DMA_Priority_VeryHigh              ((u32)0x00003000)
-#define DMA_Priority_High                  ((u32)0x00002000)
-#define DMA_Priority_Medium                ((u32)0x00001000)
-#define DMA_Priority_Low                   ((u32)0x00000000)
+/** @defgroup DMA_priority_level 
+  * @{
+  */
 
+#define DMA_Priority_VeryHigh              ((uint32_t)0x00003000)
+#define DMA_Priority_High                  ((uint32_t)0x00002000)
+#define DMA_Priority_Medium                ((uint32_t)0x00001000)
+#define DMA_Priority_Low                   ((uint32_t)0x00000000)
 #define IS_DMA_PRIORITY(PRIORITY) (((PRIORITY) == DMA_Priority_VeryHigh) || \
                                    ((PRIORITY) == DMA_Priority_High) || \
                                    ((PRIORITY) == DMA_Priority_Medium) || \
                                    ((PRIORITY) == DMA_Priority_Low))
+/**
+  * @}
+  */
 
-/* DMA memory to memory ------------------------------------------------------*/
-#define DMA_M2M_Enable                     ((u32)0x00004000)
-#define DMA_M2M_Disable                    ((u32)0x00000000)
+/** @defgroup DMA_memory_to_memory 
+  * @{
+  */
 
+#define DMA_M2M_Enable                     ((uint32_t)0x00004000)
+#define DMA_M2M_Disable                    ((uint32_t)0x00000000)
 #define IS_DMA_M2M_STATE(STATE) (((STATE) == DMA_M2M_Enable) || ((STATE) == DMA_M2M_Disable))
 
-/* DMA interrupts definition -------------------------------------------------*/
-#define DMA_IT_TC                          ((u32)0x00000002)
-#define DMA_IT_HT                          ((u32)0x00000004)
-#define DMA_IT_TE                          ((u32)0x00000008)
+/**
+  * @}
+  */
 
+/** @defgroup DMA_interrupts_definition 
+  * @{
+  */
+
+#define DMA_IT_TC                          ((uint32_t)0x00000002)
+#define DMA_IT_HT                          ((uint32_t)0x00000004)
+#define DMA_IT_TE                          ((uint32_t)0x00000008)
 #define IS_DMA_CONFIG_IT(IT) ((((IT) &amp; 0xFFFFFFF1) == 0x00) &amp;&amp; ((IT) != 0x00))
 
-/* For DMA1 */
-#define DMA1_IT_GL1                        ((u32)0x00000001)
-#define DMA1_IT_TC1                        ((u32)0x00000002)
-#define DMA1_IT_HT1                        ((u32)0x00000004)
-#define DMA1_IT_TE1                        ((u32)0x00000008)
-#define DMA1_IT_GL2                        ((u32)0x00000010)
-#define DMA1_IT_TC2                        ((u32)0x00000020)
-#define DMA1_IT_HT2                        ((u32)0x00000040)
-#define DMA1_IT_TE2                        ((u32)0x00000080)
-#define DMA1_IT_GL3                        ((u32)0x00000100)
-#define DMA1_IT_TC3                        ((u32)0x00000200)
-#define DMA1_IT_HT3                        ((u32)0x00000400)
-#define DMA1_IT_TE3                        ((u32)0x00000800)
-#define DMA1_IT_GL4                        ((u32)0x00001000)
-#define DMA1_IT_TC4                        ((u32)0x00002000)
-#define DMA1_IT_HT4                        ((u32)0x00004000)
-#define DMA1_IT_TE4                        ((u32)0x00008000)
-#define DMA1_IT_GL5                        ((u32)0x00010000)
-#define DMA1_IT_TC5                        ((u32)0x00020000)
-#define DMA1_IT_HT5                        ((u32)0x00040000)
-#define DMA1_IT_TE5                        ((u32)0x00080000)
-#define DMA1_IT_GL6                        ((u32)0x00100000)
-#define DMA1_IT_TC6                        ((u32)0x00200000)
-#define DMA1_IT_HT6                        ((u32)0x00400000)
-#define DMA1_IT_TE6                        ((u32)0x00800000)
-#define DMA1_IT_GL7                        ((u32)0x01000000)
-#define DMA1_IT_TC7                        ((u32)0x02000000)
-#define DMA1_IT_HT7                        ((u32)0x04000000)
-#define DMA1_IT_TE7                        ((u32)0x08000000)
-/* For DMA2 */
-#define DMA2_IT_GL1                        ((u32)0x10000001)
-#define DMA2_IT_TC1                        ((u32)0x10000002)
-#define DMA2_IT_HT1                        ((u32)0x10000004)
-#define DMA2_IT_TE1                        ((u32)0x10000008)
-#define DMA2_IT_GL2                        ((u32)0x10000010)
-#define DMA2_IT_TC2                        ((u32)0x10000020)
-#define DMA2_IT_HT2                        ((u32)0x10000040)
-#define DMA2_IT_TE2                        ((u32)0x10000080)
-#define DMA2_IT_GL3                        ((u32)0x10000100)
-#define DMA2_IT_TC3                        ((u32)0x10000200)
-#define DMA2_IT_HT3                        ((u32)0x10000400)
-#define DMA2_IT_TE3                        ((u32)0x10000800)
-#define DMA2_IT_GL4                        ((u32)0x10001000)
-#define DMA2_IT_TC4                        ((u32)0x10002000)
-#define DMA2_IT_HT4                        ((u32)0x10004000)
-#define DMA2_IT_TE4                        ((u32)0x10008000)
-#define DMA2_IT_GL5                        ((u32)0x10010000)
-#define DMA2_IT_TC5                        ((u32)0x10020000)
-#define DMA2_IT_HT5                        ((u32)0x10040000)
-#define DMA2_IT_TE5                        ((u32)0x10080000)
+#define DMA1_IT_GL1                        ((uint32_t)0x00000001)
+#define DMA1_IT_TC1                        ((uint32_t)0x00000002)
+#define DMA1_IT_HT1                        ((uint32_t)0x00000004)
+#define DMA1_IT_TE1                        ((uint32_t)0x00000008)
+#define DMA1_IT_GL2                        ((uint32_t)0x00000010)
+#define DMA1_IT_TC2                        ((uint32_t)0x00000020)
+#define DMA1_IT_HT2                        ((uint32_t)0x00000040)
+#define DMA1_IT_TE2                        ((uint32_t)0x00000080)
+#define DMA1_IT_GL3                        ((uint32_t)0x00000100)
+#define DMA1_IT_TC3                        ((uint32_t)0x00000200)
+#define DMA1_IT_HT3                        ((uint32_t)0x00000400)
+#define DMA1_IT_TE3                        ((uint32_t)0x00000800)
+#define DMA1_IT_GL4                        ((uint32_t)0x00001000)
+#define DMA1_IT_TC4                        ((uint32_t)0x00002000)
+#define DMA1_IT_HT4                        ((uint32_t)0x00004000)
+#define DMA1_IT_TE4                        ((uint32_t)0x00008000)
+#define DMA1_IT_GL5                        ((uint32_t)0x00010000)
+#define DMA1_IT_TC5                        ((uint32_t)0x00020000)
+#define DMA1_IT_HT5                        ((uint32_t)0x00040000)
+#define DMA1_IT_TE5                        ((uint32_t)0x00080000)
+#define DMA1_IT_GL6                        ((uint32_t)0x00100000)
+#define DMA1_IT_TC6                        ((uint32_t)0x00200000)
+#define DMA1_IT_HT6                        ((uint32_t)0x00400000)
+#define DMA1_IT_TE6                        ((uint32_t)0x00800000)
+#define DMA1_IT_GL7                        ((uint32_t)0x01000000)
+#define DMA1_IT_TC7                        ((uint32_t)0x02000000)
+#define DMA1_IT_HT7                        ((uint32_t)0x04000000)
+#define DMA1_IT_TE7                        ((uint32_t)0x08000000)
 
+#define DMA2_IT_GL1                        ((uint32_t)0x10000001)
+#define DMA2_IT_TC1                        ((uint32_t)0x10000002)
+#define DMA2_IT_HT1                        ((uint32_t)0x10000004)
+#define DMA2_IT_TE1                        ((uint32_t)0x10000008)
+#define DMA2_IT_GL2                        ((uint32_t)0x10000010)
+#define DMA2_IT_TC2                        ((uint32_t)0x10000020)
+#define DMA2_IT_HT2                        ((uint32_t)0x10000040)
+#define DMA2_IT_TE2                        ((uint32_t)0x10000080)
+#define DMA2_IT_GL3                        ((uint32_t)0x10000100)
+#define DMA2_IT_TC3                        ((uint32_t)0x10000200)
+#define DMA2_IT_HT3                        ((uint32_t)0x10000400)
+#define DMA2_IT_TE3                        ((uint32_t)0x10000800)
+#define DMA2_IT_GL4                        ((uint32_t)0x10001000)
+#define DMA2_IT_TC4                        ((uint32_t)0x10002000)
+#define DMA2_IT_HT4                        ((uint32_t)0x10004000)
+#define DMA2_IT_TE4                        ((uint32_t)0x10008000)
+#define DMA2_IT_GL5                        ((uint32_t)0x10010000)
+#define DMA2_IT_TC5                        ((uint32_t)0x10020000)
+#define DMA2_IT_HT5                        ((uint32_t)0x10040000)
+#define DMA2_IT_TE5                        ((uint32_t)0x10080000)
+
 #define IS_DMA_CLEAR_IT(IT) (((((IT) &amp; 0xF0000000) == 0x00) || (((IT) &amp; 0xEFF00000) == 0x00)) &amp;&amp; ((IT) != 0x00))
+
 #define IS_DMA_GET_IT(IT) (((IT) == DMA1_IT_GL1) || ((IT) == DMA1_IT_TC1) || \
                            ((IT) == DMA1_IT_HT1) || ((IT) == DMA1_IT_TE1) || \
                            ((IT) == DMA1_IT_GL2) || ((IT) == DMA1_IT_TC2) || \
@@ -198,59 +293,65 @@
                            ((IT) == DMA2_IT_GL5) || ((IT) == DMA2_IT_TC5) || \
                            ((IT) == DMA2_IT_HT5) || ((IT) == DMA2_IT_TE5))
 
-/* DMA flags definition ------------------------------------------------------*/
-/* For DMA1 */
-#define DMA1_FLAG_GL1                      ((u32)0x00000001)
-#define DMA1_FLAG_TC1                      ((u32)0x00000002)
-#define DMA1_FLAG_HT1                      ((u32)0x00000004)
-#define DMA1_FLAG_TE1                      ((u32)0x00000008)
-#define DMA1_FLAG_GL2                      ((u32)0x00000010)
-#define DMA1_FLAG_TC2                      ((u32)0x00000020)
-#define DMA1_FLAG_HT2                      ((u32)0x00000040)
-#define DMA1_FLAG_TE2                      ((u32)0x00000080)
-#define DMA1_FLAG_GL3                      ((u32)0x00000100)
-#define DMA1_FLAG_TC3                      ((u32)0x00000200)
-#define DMA1_FLAG_HT3                      ((u32)0x00000400)
-#define DMA1_FLAG_TE3                      ((u32)0x00000800)
-#define DMA1_FLAG_GL4                      ((u32)0x00001000)
-#define DMA1_FLAG_TC4                      ((u32)0x00002000)
-#define DMA1_FLAG_HT4                      ((u32)0x00004000)
-#define DMA1_FLAG_TE4                      ((u32)0x00008000)
-#define DMA1_FLAG_GL5                      ((u32)0x00010000)
-#define DMA1_FLAG_TC5                      ((u32)0x00020000)
-#define DMA1_FLAG_HT5                      ((u32)0x00040000)
-#define DMA1_FLAG_TE5                      ((u32)0x00080000)
-#define DMA1_FLAG_GL6                      ((u32)0x00100000)
-#define DMA1_FLAG_TC6                      ((u32)0x00200000)
-#define DMA1_FLAG_HT6                      ((u32)0x00400000)
-#define DMA1_FLAG_TE6                      ((u32)0x00800000)
-#define DMA1_FLAG_GL7                      ((u32)0x01000000)
-#define DMA1_FLAG_TC7                      ((u32)0x02000000)
-#define DMA1_FLAG_HT7                      ((u32)0x04000000)
-#define DMA1_FLAG_TE7                      ((u32)0x08000000)
-/* For DMA2 */
-#define DMA2_FLAG_GL1                      ((u32)0x10000001)
-#define DMA2_FLAG_TC1                      ((u32)0x10000002)
-#define DMA2_FLAG_HT1                      ((u32)0x10000004)
-#define DMA2_FLAG_TE1                      ((u32)0x10000008)
-#define DMA2_FLAG_GL2                      ((u32)0x10000010)
-#define DMA2_FLAG_TC2                      ((u32)0x10000020)
-#define DMA2_FLAG_HT2                      ((u32)0x10000040)
-#define DMA2_FLAG_TE2                      ((u32)0x10000080)
-#define DMA2_FLAG_GL3                      ((u32)0x10000100)
-#define DMA2_FLAG_TC3                      ((u32)0x10000200)
-#define DMA2_FLAG_HT3                      ((u32)0x10000400)
-#define DMA2_FLAG_TE3                      ((u32)0x10000800)
-#define DMA2_FLAG_GL4                      ((u32)0x10001000)
-#define DMA2_FLAG_TC4                      ((u32)0x10002000)
-#define DMA2_FLAG_HT4                      ((u32)0x10004000)
-#define DMA2_FLAG_TE4                      ((u32)0x10008000)
-#define DMA2_FLAG_GL5                      ((u32)0x10010000)
-#define DMA2_FLAG_TC5                      ((u32)0x10020000)
-#define DMA2_FLAG_HT5                      ((u32)0x10040000)
-#define DMA2_FLAG_TE5                      ((u32)0x10080000)
+/**
+  * @}
+  */
 
+/** @defgroup DMA_flags_definition 
+  * @{
+  */
+#define DMA1_FLAG_GL1                      ((uint32_t)0x00000001)
+#define DMA1_FLAG_TC1                      ((uint32_t)0x00000002)
+#define DMA1_FLAG_HT1                      ((uint32_t)0x00000004)
+#define DMA1_FLAG_TE1                      ((uint32_t)0x00000008)
+#define DMA1_FLAG_GL2                      ((uint32_t)0x00000010)
+#define DMA1_FLAG_TC2                      ((uint32_t)0x00000020)
+#define DMA1_FLAG_HT2                      ((uint32_t)0x00000040)
+#define DMA1_FLAG_TE2                      ((uint32_t)0x00000080)
+#define DMA1_FLAG_GL3                      ((uint32_t)0x00000100)
+#define DMA1_FLAG_TC3                      ((uint32_t)0x00000200)
+#define DMA1_FLAG_HT3                      ((uint32_t)0x00000400)
+#define DMA1_FLAG_TE3                      ((uint32_t)0x00000800)
+#define DMA1_FLAG_GL4                      ((uint32_t)0x00001000)
+#define DMA1_FLAG_TC4                      ((uint32_t)0x00002000)
+#define DMA1_FLAG_HT4                      ((uint32_t)0x00004000)
+#define DMA1_FLAG_TE4                      ((uint32_t)0x00008000)
+#define DMA1_FLAG_GL5                      ((uint32_t)0x00010000)
+#define DMA1_FLAG_TC5                      ((uint32_t)0x00020000)
+#define DMA1_FLAG_HT5                      ((uint32_t)0x00040000)
+#define DMA1_FLAG_TE5                      ((uint32_t)0x00080000)
+#define DMA1_FLAG_GL6                      ((uint32_t)0x00100000)
+#define DMA1_FLAG_TC6                      ((uint32_t)0x00200000)
+#define DMA1_FLAG_HT6                      ((uint32_t)0x00400000)
+#define DMA1_FLAG_TE6                      ((uint32_t)0x00800000)
+#define DMA1_FLAG_GL7                      ((uint32_t)0x01000000)
+#define DMA1_FLAG_TC7                      ((uint32_t)0x02000000)
+#define DMA1_FLAG_HT7                      ((uint32_t)0x04000000)
+#define DMA1_FLAG_TE7                      ((uint32_t)0x08000000)
+
+#define DMA2_FLAG_GL1                      ((uint32_t)0x10000001)
+#define DMA2_FLAG_TC1                      ((uint32_t)0x10000002)
+#define DMA2_FLAG_HT1                      ((uint32_t)0x10000004)
+#define DMA2_FLAG_TE1                      ((uint32_t)0x10000008)
+#define DMA2_FLAG_GL2                      ((uint32_t)0x10000010)
+#define DMA2_FLAG_TC2                      ((uint32_t)0x10000020)
+#define DMA2_FLAG_HT2                      ((uint32_t)0x10000040)
+#define DMA2_FLAG_TE2                      ((uint32_t)0x10000080)
+#define DMA2_FLAG_GL3                      ((uint32_t)0x10000100)
+#define DMA2_FLAG_TC3                      ((uint32_t)0x10000200)
+#define DMA2_FLAG_HT3                      ((uint32_t)0x10000400)
+#define DMA2_FLAG_TE3                      ((uint32_t)0x10000800)
+#define DMA2_FLAG_GL4                      ((uint32_t)0x10001000)
+#define DMA2_FLAG_TC4                      ((uint32_t)0x10002000)
+#define DMA2_FLAG_HT4                      ((uint32_t)0x10004000)
+#define DMA2_FLAG_TE4                      ((uint32_t)0x10008000)
+#define DMA2_FLAG_GL5                      ((uint32_t)0x10010000)
+#define DMA2_FLAG_TC5                      ((uint32_t)0x10020000)
+#define DMA2_FLAG_HT5                      ((uint32_t)0x10040000)
+#define DMA2_FLAG_TE5                      ((uint32_t)0x10080000)
+
 #define IS_DMA_CLEAR_FLAG(FLAG) (((((FLAG) &amp; 0xF0000000) == 0x00) || (((FLAG) &amp; 0xEFF00000) == 0x00)) &amp;&amp; ((FLAG) != 0x00))
+
 #define IS_DMA_GET_FLAG(FLAG) (((FLAG) == DMA1_FLAG_GL1) || ((FLAG) == DMA1_FLAG_TC1) || \
                                ((FLAG) == DMA1_FLAG_HT1) || ((FLAG) == DMA1_FLAG_TE1) || \
                                ((FLAG) == DMA1_FLAG_GL2) || ((FLAG) == DMA1_FLAG_TC2) || \
@@ -275,23 +376,62 @@
                                ((FLAG) == DMA2_FLAG_HT4) || ((FLAG) == DMA2_FLAG_TE4) || \
                                ((FLAG) == DMA2_FLAG_GL5) || ((FLAG) == DMA2_FLAG_TC5) || \
                                ((FLAG) == DMA2_FLAG_HT5) || ((FLAG) == DMA2_FLAG_TE5))
+/**
+  * @}
+  */
 
-/* DMA Buffer Size -----------------------------------------------------------*/
+/** @defgroup DMA_Buffer_Size 
+  * @{
+  */
+
 #define IS_DMA_BUFFER_SIZE(SIZE) (((SIZE) &gt;= 0x1) &amp;&amp; ((SIZE) &lt; 0x10000))
 
-/* Exported macro ------------------------------------------------------------*/
-/* Exported functions ------------------------------------------------------- */
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup DMA_Exported_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup DMA_Exported_Functions
+  * @{
+  */
+
 void DMA_DeInit(DMA_Channel_TypeDef* DMAy_Channelx);
 void DMA_Init(DMA_Channel_TypeDef* DMAy_Channelx, DMA_InitTypeDef* DMA_InitStruct);
 void DMA_StructInit(DMA_InitTypeDef* DMA_InitStruct);
 void DMA_Cmd(DMA_Channel_TypeDef* DMAy_Channelx, FunctionalState NewState);
-void DMA_ITConfig(DMA_Channel_TypeDef* DMAy_Channelx, u32 DMA_IT, FunctionalState NewState);
-u16 DMA_GetCurrDataCounter(DMA_Channel_TypeDef* DMAy_Channelx);
-FlagStatus DMA_GetFlagStatus(u32 DMA_FLAG);
-void DMA_ClearFlag(u32 DMA_FLAG);
-ITStatus DMA_GetITStatus(u32 DMA_IT);
-void DMA_ClearITPendingBit(u32 DMA_IT);
+void DMA_ITConfig(DMA_Channel_TypeDef* DMAy_Channelx, uint32_t DMA_IT, FunctionalState NewState);
+uint16_t DMA_GetCurrDataCounter(DMA_Channel_TypeDef* DMAy_Channelx);
+FlagStatus DMA_GetFlagStatus(uint32_t DMA_FLAG);
+void DMA_ClearFlag(uint32_t DMA_FLAG);
+ITStatus DMA_GetITStatus(uint32_t DMA_IT);
+void DMA_ClearITPendingBit(uint32_t DMA_IT);
 
+#ifdef __cplusplus
+}
+#endif
+
 #endif /*__STM32F10x_DMA_H */
+/**
+  * @}
+  */
 
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2009 STMicroelectronics *****END OF FILE****/

Modified: trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_exti.h
===================================================================
--- trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_exti.h	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_exti.h	2009-07-08 23:39:34 UTC (rev 354)
@@ -1,28 +1,51 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_exti.h
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file contains all the functions prototypes for the
-*                      EXTI firmware library.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
+/**
+  ******************************************************************************
+  * @file    stm32f10x_exti.h
+  * @author  MCD Application Team
+  * @version V3.1.0
+  * @date    06/19/2009
+  * @brief   This file contains all the functions prototypes for the EXTI firmware
+  *          library.
+  ******************************************************************************
+  * @copy
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * &lt;h2&gt;&lt;center&gt;&copy; COPYRIGHT 2009 STMicroelectronics&lt;/center&gt;&lt;/h2&gt;
+  */ 
 
 /* Define to prevent recursive inclusion -------------------------------------*/
 #ifndef __STM32F10x_EXTI_H
 #define __STM32F10x_EXTI_H
 
+#ifdef __cplusplus
+ extern &quot;C&quot; {
+#endif
+
 /* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_map.h&quot;
+#include &quot;stm32f10x.h&quot;
 
-/* Exported types ------------------------------------------------------------*/
-/* EXTI mode enumeration -----------------------------------------------------*/
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @addtogroup EXTI
+  * @{
+  */
+
+/** @defgroup EXTI_Exported_Types
+  * @{
+  */
+
+/** 
+  * @brief  EXTI mode enumeration  
+  */
+
 typedef enum
 {
   EXTI_Mode_Interrupt = 0x00,
@@ -30,8 +53,11 @@
 }EXTIMode_TypeDef;
 
 #define IS_EXTI_MODE(MODE) (((MODE) == EXTI_Mode_Interrupt) || ((MODE) == EXTI_Mode_Event))
-                            
-/* EXTI Trigger enumeration --------------------------------------------------*/
+
+/** 
+  * @brief  EXTI Trigger enumeration  
+  */
+
 typedef enum
 {
   EXTI_Trigger_Rising = 0x08,
@@ -42,44 +68,61 @@
 #define IS_EXTI_TRIGGER(TRIGGER) (((TRIGGER) == EXTI_Trigger_Rising) || \
                                   ((TRIGGER) == EXTI_Trigger_Falling) || \
                                   ((TRIGGER) == EXTI_Trigger_Rising_Falling))
+/** 
+  * @brief  EXTI Init Structure definition  
+  */
 
-/* EXTI Init Structure definition --------------------------------------------*/
 typedef struct
 {
-  u32 EXTI_Line;
-  EXTIMode_TypeDef EXTI_Mode;
-  EXTITrigger_TypeDef EXTI_Trigger;
-  FunctionalState EXTI_LineCmd;
+  uint32_t EXTI_Line;               /*!&lt; Specifies the EXTI lines to be enabled or disabled.
+                                         This parameter can be any combination of @ref EXTI_Lines */
+   
+  EXTIMode_TypeDef EXTI_Mode;       /*!&lt; Specifies the mode for the EXTI lines.
+                                         This parameter can be a value of @ref EXTIMode_TypeDef */
+
+  EXTITrigger_TypeDef EXTI_Trigger; /*!&lt; Specifies the trigger signal active edge for the EXTI lines.
+                                         This parameter can be a value of @ref EXTIMode_TypeDef */
+
+  FunctionalState EXTI_LineCmd;     /*!&lt; Specifies the new state of the selected EXTI lines.
+                                         This parameter can be set either to ENABLE or DISABLE */ 
 }EXTI_InitTypeDef;
 
-/* Exported constants --------------------------------------------------------*/
-/* EXTI Lines ----------------------------------------------------------------*/
-#define EXTI_Line0       ((u32)0x00001)  /* External interrupt line 0 */
-#define EXTI_Line1       ((u32)0x00002)  /* External interrupt line 1 */
-#define EXTI_Line2       ((u32)0x00004)  /* External interrupt line 2 */
-#define EXTI_Line3       ((u32)0x00008)  /* External interrupt line 3 */
-#define EXTI_Line4       ((u32)0x00010)  /* External interrupt line 4 */
-#define EXTI_Line5       ((u32)0x00020)  /* External interrupt line 5 */
-#define EXTI_Line6       ((u32)0x00040)  /* External interrupt line 6 */
-#define EXTI_Line7       ((u32)0x00080)  /* External interrupt line 7 */
-#define EXTI_Line8       ((u32)0x00100)  /* External interrupt line 8 */
-#define EXTI_Line9       ((u32)0x00200)  /* External interrupt line 9 */
-#define EXTI_Line10      ((u32)0x00400)  /* External interrupt line 10 */
-#define EXTI_Line11      ((u32)0x00800)  /* External interrupt line 11 */
-#define EXTI_Line12      ((u32)0x01000)  /* External interrupt line 12 */
-#define EXTI_Line13      ((u32)0x02000)  /* External interrupt line 13 */
-#define EXTI_Line14      ((u32)0x04000)  /* External interrupt line 14 */
-#define EXTI_Line15      ((u32)0x08000)  /* External interrupt line 15 */
-#define EXTI_Line16      ((u32)0x10000)  /* External interrupt line 16
-                                            Connected to the PVD Output */
-#define EXTI_Line17      ((u32)0x20000)  /* External interrupt line 17 
-                                            Connected to the RTC Alarm event */
-#define EXTI_Line18      ((u32)0x40000)  /* External interrupt line 18 
-                                            Connected to the USB Wakeup from 
-                                            suspend event */
+/**
+  * @}
+  */
 
-#define IS_EXTI_LINE(LINE) ((((LINE) &amp; (u32)0xFFF80000) == 0x00) &amp;&amp; ((LINE) != (u16)0x00))
+/** @defgroup EXTI_Exported_Constants
+  * @{
+  */
 
+/** @defgroup EXTI_Lines 
+  * @{
+  */
+
+#define EXTI_Line0       ((uint32_t)0x00001)  /*!&lt; External interrupt line 0 */
+#define EXTI_Line1       ((uint32_t)0x00002)  /*!&lt; External interrupt line 1 */
+#define EXTI_Line2       ((uint32_t)0x00004)  /*!&lt; External interrupt line 2 */
+#define EXTI_Line3       ((uint32_t)0x00008)  /*!&lt; External interrupt line 3 */
+#define EXTI_Line4       ((uint32_t)0x00010)  /*!&lt; External interrupt line 4 */
+#define EXTI_Line5       ((uint32_t)0x00020)  /*!&lt; External interrupt line 5 */
+#define EXTI_Line6       ((uint32_t)0x00040)  /*!&lt; External interrupt line 6 */
+#define EXTI_Line7       ((uint32_t)0x00080)  /*!&lt; External interrupt line 7 */
+#define EXTI_Line8       ((uint32_t)0x00100)  /*!&lt; External interrupt line 8 */
+#define EXTI_Line9       ((uint32_t)0x00200)  /*!&lt; External interrupt line 9 */
+#define EXTI_Line10      ((uint32_t)0x00400)  /*!&lt; External interrupt line 10 */
+#define EXTI_Line11      ((uint32_t)0x00800)  /*!&lt; External interrupt line 11 */
+#define EXTI_Line12      ((uint32_t)0x01000)  /*!&lt; External interrupt line 12 */
+#define EXTI_Line13      ((uint32_t)0x02000)  /*!&lt; External interrupt line 13 */
+#define EXTI_Line14      ((uint32_t)0x04000)  /*!&lt; External interrupt line 14 */
+#define EXTI_Line15      ((uint32_t)0x08000)  /*!&lt; External interrupt line 15 */
+#define EXTI_Line16      ((uint32_t)0x10000)  /*!&lt; External interrupt line 16 Connected to the PVD Output */
+#define EXTI_Line17      ((uint32_t)0x20000)  /*!&lt; External interrupt line 17 Connected to the RTC Alarm event */
+#define EXTI_Line18      ((uint32_t)0x40000)  /*!&lt; External interrupt line 18 Connected to the USB Device/USB OTG FS
+                                                   Wakeup from suspend event */
+#define EXTI_Line19      ((uint32_t)0x80000)  /*!&lt; External interrupt line 19 Connected to the Ethernet Wakeup event */ 
+                                            
+#define IS_EXTI_LINE(LINE) ((((LINE) &amp; (uint32_t)0xFFF00000) == 0x00) &amp;&amp; ((LINE) != (uint16_t)0x00))
+
 #define IS_GET_EXTI_LINE(LINE) (((LINE) == EXTI_Line0) || ((LINE) == EXTI_Line1) || \
                             ((LINE) == EXTI_Line2) || ((LINE) == EXTI_Line3) || \
                             ((LINE) == EXTI_Line4) || ((LINE) == EXTI_Line5) || \
@@ -89,19 +132,52 @@
                             ((LINE) == EXTI_Line12) || ((LINE) == EXTI_Line13) || \
                             ((LINE) == EXTI_Line14) || ((LINE) == EXTI_Line15) || \
                             ((LINE) == EXTI_Line16) || ((LINE) == EXTI_Line17) || \
-                            ((LINE) == EXTI_Line18))
-                                 
-/* Exported macro ------------------------------------------------------------*/
-/* Exported functions ------------------------------------------------------- */
+                            ((LINE) == EXTI_Line18) || ((LINE) == EXTI_Line19))
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup EXTI_Exported_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup EXTI_Exported_Functions
+  * @{
+  */
+
 void EXTI_DeInit(void);
 void EXTI_Init(EXTI_InitTypeDef* EXTI_InitStruct);
 void EXTI_StructInit(EXTI_InitTypeDef* EXTI_InitStruct);
-void EXTI_GenerateSWInterrupt(u32 EXTI_Line);
-FlagStatus EXTI_GetFlagStatus(u32 EXTI_Line);
-void EXTI_ClearFlag(u32 EXTI_Line);
-ITStatus EXTI_GetITStatus(u32 EXTI_Line);
-void EXTI_ClearITPendingBit(u32 EXTI_Line);
+void EXTI_GenerateSWInterrupt(uint32_t EXTI_Line);
+FlagStatus EXTI_GetFlagStatus(uint32_t EXTI_Line);
+void EXTI_ClearFlag(uint32_t EXTI_Line);
+ITStatus EXTI_GetITStatus(uint32_t EXTI_Line);
+void EXTI_ClearITPendingBit(uint32_t EXTI_Line);
 
+#ifdef __cplusplus
+}
+#endif
+
 #endif /* __STM32F10x_EXTI_H */
+/**
+  * @}
+  */
 
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2009 STMicroelectronics *****END OF FILE****/

Modified: trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_flash.h
===================================================================
--- trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_flash.h	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_flash.h	2009-07-08 23:39:34 UTC (rev 354)
@@ -1,29 +1,51 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_flash.h
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file contains all the functions prototypes for the
-*                      FLASH firmware library.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
+/**
+  ******************************************************************************
+  * @file    stm32f10x_flash.h
+  * @author  MCD Application Team
+  * @version V3.1.0
+  * @date    06/19/2009
+  * @brief   This file contains all the functions prototypes for the FLASH 
+  *          firmware library.
+  ******************************************************************************
+  * @copy
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * &lt;h2&gt;&lt;center&gt;&copy; COPYRIGHT 2009 STMicroelectronics&lt;/center&gt;&lt;/h2&gt;
+  */ 
 
 /* Define to prevent recursive inclusion -------------------------------------*/
 #ifndef __STM32F10x_FLASH_H
 #define __STM32F10x_FLASH_H
 
+#ifdef __cplusplus
+ extern &quot;C&quot; {
+#endif
+
 /* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_map.h&quot;
+#include &quot;stm32f10x.h&quot;
 
-/* Exported types ------------------------------------------------------------*/
-#ifdef _FLASH_PROG
-/* FLASH Status */
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @addtogroup FLASH
+  * @{
+  */
+
+/** @defgroup FLASH_Exported_Types
+  * @{
+  */
+
+/** 
+  * @brief  FLASH Status  
+  */
+
 typedef enum
 { 
   FLASH_BUSY = 1,
@@ -32,177 +54,293 @@
   FLASH_COMPLETE,
   FLASH_TIMEOUT
 }FLASH_Status;
-#endif
 
-/* Flash Latency -------------------------------------------------------------*/
-#define FLASH_Latency_0                ((u32)0x00000000)  /* FLASH Zero Latency cycle */
-#define FLASH_Latency_1                ((u32)0x00000001)  /* FLASH One Latency cycle */
-#define FLASH_Latency_2                ((u32)0x00000002)  /* FLASH Two Latency cycles */
+/**
+  * @}
+  */
 
+/** @defgroup FLASH_Exported_Constants
+  * @{
+  */
+
+/** @defgroup Flash_Latency 
+  * @{
+  */
+
+#define FLASH_Latency_0                ((uint32_t)0x00000000)  /*!&lt; FLASH Zero Latency cycle */
+#define FLASH_Latency_1                ((uint32_t)0x00000001)  /*!&lt; FLASH One Latency cycle */
+#define FLASH_Latency_2                ((uint32_t)0x00000002)  /*!&lt; FLASH Two Latency cycles */
 #define IS_FLASH_LATENCY(LATENCY) (((LATENCY) == FLASH_Latency_0) || \
                                    ((LATENCY) == FLASH_Latency_1) || \
                                    ((LATENCY) == FLASH_Latency_2))
+/**
+  * @}
+  */
 
-/* Half Cycle Enable/Disable -------------------------------------------------*/
-#define FLASH_HalfCycleAccess_Enable   ((u32)0x00000008)  /* FLASH Half Cycle Enable */
-#define FLASH_HalfCycleAccess_Disable  ((u32)0x00000000)  /* FLASH Half Cycle Disable */
+/** @defgroup Half_Cycle_Enable_Disable 
+  * @{
+  */
 
+#define FLASH_HalfCycleAccess_Enable   ((uint32_t)0x00000008)  /*!&lt; FLASH Half Cycle Enable */
+#define FLASH_HalfCycleAccess_Disable  ((uint32_t)0x00000000)  /*!&lt; FLASH Half Cycle Disable */
 #define IS_FLASH_HALFCYCLEACCESS_STATE(STATE) (((STATE) == FLASH_HalfCycleAccess_Enable) || \
                                                ((STATE) == FLASH_HalfCycleAccess_Disable)) 
+/**
+  * @}
+  */
 
+/** @defgroup Prefetch_Buffer_Enable_Disable 
+  * @{
+  */
 
-/* Prefetch Buffer Enable/Disable --------------------------------------------*/
-#define FLASH_PrefetchBuffer_Enable    ((u32)0x00000010)  /* FLASH Prefetch Buffer Enable */
-#define FLASH_PrefetchBuffer_Disable   ((u32)0x00000000)  /* FLASH Prefetch Buffer Disable */
-
+#define FLASH_PrefetchBuffer_Enable    ((uint32_t)0x00000010)  /*!&lt; FLASH Prefetch Buffer Enable */
+#define FLASH_PrefetchBuffer_Disable   ((uint32_t)0x00000000)  /*!&lt; FLASH Prefetch Buffer Disable */
 #define IS_FLASH_PREFETCHBUFFER_STATE(STATE) (((STATE) == FLASH_PrefetchBuffer_Enable) || \
                                               ((STATE) == FLASH_PrefetchBuffer_Disable)) 
+/**
+  * @}
+  */
 
-#ifdef _FLASH_PROG
-/* Option Bytes Write Protection ---------------------------------------------*/
-/* Values to be used with STM32F10Xxx Medium-density devices: FLASH memory density
-   ranges between 32 and 128 Kbytes with page size equal to 1 Kbytes */
-#define FLASH_WRProt_Pages0to3         ((u32)0x00000001) /* Write protection of page 0 to 3 */
-#define FLASH_WRProt_Pages4to7         ((u32)0x00000002) /* Write protection of page 4 to 7 */
-#define FLASH_WRProt_Pages8to11        ((u32)0x00000004) /* Write protection of page 8 to 11 */
-#define FLASH_WRProt_Pages12to15       ((u32)0x00000008) /* Write protection of page 12 to 15 */
-#define FLASH_WRProt_Pages16to19       ((u32)0x00000010) /* Write protection of page 16 to 19 */
-#define FLASH_WRProt_Pages20to23       ((u32)0x00000020) /* Write protection of page 20 to 23 */
-#define FLASH_WRProt_Pages24to27       ((u32)0x00000040) /* Write protection of page 24 to 27 */
-#define FLASH_WRProt_Pages28to31       ((u32)0x00000080) /* Write protection of page 28 to 31 */
-#define FLASH_WRProt_Pages32to35       ((u32)0x00000100) /* Write protection of page 32 to 35 */
-#define FLASH_WRProt_Pages36to39       ((u32)0x00000200) /* Write protection of page 36 to 39 */
-#define FLASH_WRProt_Pages40to43       ((u32)0x00000400) /* Write protection of page 40 to 43 */
-#define FLASH_WRProt_Pages44to47       ((u32)0x00000800) /* Write protection of page 44 to 47 */
-#define FLASH_WRProt_Pages48to51       ((u32)0x00001000) /* Write protection of page 48 to 51 */
-#define FLASH_WRProt_Pages52to55       ((u32)0x00002000) /* Write protection of page 52 to 55 */
-#define FLASH_WRProt_Pages56to59       ((u32)0x00004000) /* Write protection of page 56 to 59 */
-#define FLASH_WRProt_Pages60to63       ((u32)0x00008000) /* Write protection of page 60 to 63 */
-#define FLASH_WRProt_Pages64to67       ((u32)0x00010000) /* Write protection of page 64 to 67 */
-#define FLASH_WRProt_Pages68to71       ((u32)0x00020000) /* Write protection of page 68 to 71 */
-#define FLASH_WRProt_Pages72to75       ((u32)0x00040000) /* Write protection of page 72 to 75 */
-#define FLASH_WRProt_Pages76to79       ((u32)0x00080000) /* Write protection of page 76 to 79 */
-#define FLASH_WRProt_Pages80to83       ((u32)0x00100000) /* Write protection of page 80 to 83 */
-#define FLASH_WRProt_Pages84to87       ((u32)0x00200000) /* Write protection of page 84 to 87 */
-#define FLASH_WRProt_Pages88to91       ((u32)0x00400000) /* Write protection of page 88 to 91 */
-#define FLASH_WRProt_Pages92to95       ((u32)0x00800000) /* Write protection of page 92 to 95 */
-#define FLASH_WRProt_Pages96to99       ((u32)0x01000000) /* Write protection of page 96 to 99 */
-#define FLASH_WRProt_Pages100to103     ((u32)0x02000000) /* Write protection of page 100 to 103 */
-#define FLASH_WRProt_Pages104to107     ((u32)0x04000000) /* Write protection of page 104 to 107 */
-#define FLASH_WRProt_Pages108to111     ((u32)0x08000000) /* Write protection of page 108 to 111 */
-#define FLASH_WRProt_Pages112to115     ((u32)0x10000000) /* Write protection of page 112 to 115 */
-#define FLASH_WRProt_Pages116to119     ((u32)0x20000000) /* Write protection of page 115 to 119 */
-#define FLASH_WRProt_Pages120to123     ((u32)0x40000000) /* Write protection of page 120 to 123 */
-#define FLASH_WRProt_Pages124to127     ((u32)0x80000000) /* Write protection of page 124 to 127 */
-/* Values to be used with STM32F10Xxx High-density devices: FLASH memory density
-   ranges between 256 and 512 Kbytes with page size equal to 2 Kbytes */
-#define FLASH_WRProt_Pages0to1         ((u32)0x00000001) /* Write protection of page 0 to 1 */
-#define FLASH_WRProt_Pages2to3         ((u32)0x00000002) /* Write protection of page 2 to 3 */
-#define FLASH_WRProt_Pages4to5         ((u32)0x00000004) /* Write protection of page 4 to 5 */
-#define FLASH_WRProt_Pages6to7         ((u32)0x00000008) /* Write protection of page 6 to 7 */
-#define FLASH_WRProt_Pages8to9         ((u32)0x00000010) /* Write protection of page 8 to 9 */
-#define FLASH_WRProt_Pages10to11       ((u32)0x00000020) /* Write protection of page 10 to 11 */
-#define FLASH_WRProt_Pages12to13       ((u32)0x00000040) /* Write protection of page 12 to 13 */
-#define FLASH_WRProt_Pages14to15       ((u32)0x00000080) /* Write protection of page 14 to 15 */
-#define FLASH_WRProt_Pages16to17       ((u32)0x00000100) /* Write protection of page 16 to 17 */
-#define FLASH_WRProt_Pages18to19       ((u32)0x00000200) /* Write protection of page 18 to 19 */
-#define FLASH_WRProt_Pages20to21       ((u32)0x00000400) /* Write protection of page 20 to 21 */
-#define FLASH_WRProt_Pages22to23       ((u32)0x00000800) /* Write protection of page 22 to 23 */
-#define FLASH_WRProt_Pages24to25       ((u32)0x00001000) /* Write protection of page 24 to 25 */
-#define FLASH_WRProt_Pages26to27       ((u32)0x00002000) /* Write protection of page 26 to 27 */
-#define FLASH_WRProt_Pages28to29       ((u32)0x00004000) /* Write protection of page 28 to 29 */
-#define FLASH_WRProt_Pages30to31       ((u32)0x00008000) /* Write protection of page 30 to 31 */
-#define FLASH_WRProt_Pages32to33       ((u32)0x00010000) /* Write protection of page 32 to 33 */
-#define FLASH_WRProt_Pages34to35       ((u32)0x00020000) /* Write protection of page 34 to 35 */
-#define FLASH_WRProt_Pages36to37       ((u32)0x00040000) /* Write protection of page 36 to 37 */
-#define FLASH_WRProt_Pages38to39       ((u32)0x00080000) /* Write protection of page 38 to 39 */
-#define FLASH_WRProt_Pages40to41       ((u32)0x00100000) /* Write protection of page 40 to 41 */
-#define FLASH_WRProt_Pages42to43       ((u32)0x00200000) /* Write protection of page 42 to 43 */
-#define FLASH_WRProt_Pages44to45       ((u32)0x00400000) /* Write protection of page 44 to 45 */
-#define FLASH_WRProt_Pages46to47       ((u32)0x00800000) /* Write protection of page 46 to 47 */
-#define FLASH_WRProt_Pages48to49       ((u32)0x01000000) /* Write protection of page 48 to 49 */
-#define FLASH_WRProt_Pages50to51       ((u32)0x02000000) /* Write protection of page 50 to 51 */
-#define FLASH_WRProt_Pages52to53       ((u32)0x04000000) /* Write protection of page 52 to 53 */
-#define FLASH_WRProt_Pages54to55       ((u32)0x08000000) /* Write protection of page 54 to 55 */
-#define FLASH_WRProt_Pages56to57       ((u32)0x10000000) /* Write protection of page 56 to 57 */
-#define FLASH_WRProt_Pages58to59       ((u32)0x20000000) /* Write protection of page 58 to 59 */
-#define FLASH_WRProt_Pages60to61       ((u32)0x40000000) /* Write protection of page 60 to 61 */
-#define FLASH_WRProt_Pages62to255      ((u32)0x80000000) /* Write protection of page 62 to 255 */
-#define FLASH_WRProt_AllPages          ((u32)0xFFFFFFFF) /* Write protection of all Pages */
+/** @defgroup Option_Bytes_Write_Protection 
+  * @{
+  */
 
+/* Values to be used with STM32 Low and Medium density devices */
+#define FLASH_WRProt_Pages0to3         ((uint32_t)0x00000001) /*!&lt; STM32 Low and Medium density devices: Write protection of page 0 to 3 */
+#define FLASH_WRProt_Pages4to7         ((uint32_t)0x00000002) /*!&lt; STM32 Low and Medium density devices: Write protection of page 4 to 7 */
+#define FLASH_WRProt_Pages8to11        ((uint32_t)0x00000004) /*!&lt; STM32 Low and Medium density devices: Write protection of page 8 to 11 */
+#define FLASH_WRProt_Pages12to15       ((uint32_t)0x00000008) /*!&lt; STM32 Low and Medium density devices: Write protection of page 12 to 15 */
+#define FLASH_WRProt_Pages16to19       ((uint32_t)0x00000010) /*!&lt; STM32 Low and Medium density devices: Write protection of page 16 to 19 */
+#define FLASH_WRProt_Pages20to23       ((uint32_t)0x00000020) /*!&lt; STM32 Low and Medium density devices: Write protection of page 20 to 23 */
+#define FLASH_WRProt_Pages24to27       ((uint32_t)0x00000040) /*!&lt; STM32 Low and Medium density devices: Write protection of page 24 to 27 */
+#define FLASH_WRProt_Pages28to31       ((uint32_t)0x00000080) /*!&lt; STM32 Low and Medium density devices: Write protection of page 28 to 31 */
+
+/* Values to be used with STM32 Medium-density devices */
+#define FLASH_WRProt_Pages32to35       ((uint32_t)0x00000100) /*!&lt; STM32 Medium-density devices: Write protection of page 32 to 35 */
+#define FLASH_WRProt_Pages36to39       ((uint32_t)0x00000200) /*!&lt; STM32 Medium-density devices: Write protection of page 36 to 39 */
+#define FLASH_WRProt_Pages40to43       ((uint32_t)0x00000400) /*!&lt; STM32 Medium-density devices: Write protection of page 40 to 43 */
+#define FLASH_WRProt_Pages44to47       ((uint32_t)0x00000800) /*!&lt; STM32 Medium-density devices: Write protection of page 44 to 47 */
+#define FLASH_WRProt_Pages48to51       ((uint32_t)0x00001000) /*!&lt; STM32 Medium-density devices: Write protection of page 48 to 51 */
+#define FLASH_WRProt_Pages52to55       ((uint32_t)0x00002000) /*!&lt; STM32 Medium-density devices: Write protection of page 52 to 55 */
+#define FLASH_WRProt_Pages56to59       ((uint32_t)0x00004000) /*!&lt; STM32 Medium-density devices: Write protection of page 56 to 59 */
+#define FLASH_WRProt_Pages60to63       ((uint32_t)0x00008000) /*!&lt; STM32 Medium-density devices: Write protection of page 60 to 63 */
+#define FLASH_WRProt_Pages64to67       ((uint32_t)0x00010000) /*!&lt; STM32 Medium-density devices: Write protection of page 64 to 67 */
+#define FLASH_WRProt_Pages68to71       ((uint32_t)0x00020000) /*!&lt; STM32 Medium-density devices: Write protection of page 68 to 71 */
+#define FLASH_WRProt_Pages72to75       ((uint32_t)0x00040000) /*!&lt; STM32 Medium-density devices: Write protection of page 72 to 75 */
+#define FLASH_WRProt_Pages76to79       ((uint32_t)0x00080000) /*!&lt; STM32 Medium-density devices: Write protection of page 76 to 79 */
+#define FLASH_WRProt_Pages80to83       ((uint32_t)0x00100000) /*!&lt; STM32 Medium-density devices: Write protection of page 80 to 83 */
+#define FLASH_WRProt_Pages84to87       ((uint32_t)0x00200000) /*!&lt; STM32 Medium-density devices: Write protection of page 84 to 87 */
+#define FLASH_WRProt_Pages88to91       ((uint32_t)0x00400000) /*!&lt; STM32 Medium-density devices: Write protection of page 88 to 91 */
+#define FLASH_WRProt_Pages92to95       ((uint32_t)0x00800000) /*!&lt; STM32 Medium-density devices: Write protection of page 92 to 95 */
+#define FLASH_WRProt_Pages96to99       ((uint32_t)0x01000000) /*!&lt; STM32 Medium-density devices: Write protection of page 96 to 99 */
+#define FLASH_WRProt_Pages100to103     ((uint32_t)0x02000000) /*!&lt; STM32 Medium-density devices: Write protection of page 100 to 103 */
+#define FLASH_WRProt_Pages104to107     ((uint32_t)0x04000000) /*!&lt; STM32 Medium-density devices: Write protection of page 104 to 107 */
+#define FLASH_WRProt_Pages108to111     ((uint32_t)0x08000000) /*!&lt; STM32 Medium-density devices: Write protection of page 108 to 111 */
+#define FLASH_WRProt_Pages112to115     ((uint32_t)0x10000000) /*!&lt; STM32 Medium-density devices: Write protection of page 112 to 115 */
+#define FLASH_WRProt_Pages116to119     ((uint32_t)0x20000000) /*!&lt; STM32 Medium-density devices: Write protection of page 115 to 119 */
+#define FLASH_WRProt_Pages120to123     ((uint32_t)0x40000000) /*!&lt; STM32 Medium-density devices: Write protection of page 120 to 123 */
+#define FLASH_WRProt_Pages124to127     ((uint32_t)0x80000000) /*!&lt; STM32 Medium-density devices: Write protection of page 124 to 127 */
+
+/* Values to be used with STM32 High-density and STM32F10X Connectivity line devices */
+#define FLASH_WRProt_Pages0to1         ((uint32_t)0x00000001) /*!&lt; STM32 Medium-density and Connectivity line devices:
+                                                                   Write protection of page 0 to 1 */
+#define FLASH_WRProt_Pages2to3         ((uint32_t)0x00000002) /*!&lt; STM32 Medium-density and Connectivity line devices:
+                                                                   Write protection of page 2 to 3 */
+#define FLASH_WRProt_Pages4to5         ((uint32_t)0x00000004) /*!&lt; STM32 Medium-density and Connectivity line devices:
+                                                                   Write protection of page 4 to 5 */
+#define FLASH_WRProt_Pages6to7         ((uint32_t)0x00000008) /*!&lt; STM32 Medium-density and Connectivity line devices:
+                                                                   Write protection of page 6 to 7 */
+#define FLASH_WRProt_Pages8to9         ((uint32_t)0x00000010) /*!&lt; STM32 Medium-density and Connectivity line devices:
+                                                                   Write protection of page 8 to 9 */
+#define FLASH_WRProt_Pages10to11       ((uint32_t)0x00000020) /*!&lt; STM32 Medium-density and Connectivity line devices:
+                                                                   Write protection of page 10 to 11 */
+#define FLASH_WRProt_Pages12to13       ((uint32_t)0x00000040) /*!&lt; STM32 Medium-density and Connectivity line devices:
+                                                                   Write protection of page 12 to 13 */
+#define FLASH_WRProt_Pages14to15       ((uint32_t)0x00000080) /*!&lt; STM32 Medium-density and Connectivity line devices:
+                                                                   Write protection of page 14 to 15 */
+#define FLASH_WRProt_Pages16to17       ((uint32_t)0x00000100) /*!&lt; STM32 Medium-density and Connectivity line devices:
+                                                                   Write protection of page 16 to 17 */
+#define FLASH_WRProt_Pages18to19       ((uint32_t)0x00000200) /*!&lt; STM32 Medium-density and Connectivity line devices:
+                                                                   Write protection of page 18 to 19 */
+#define FLASH_WRProt_Pages20to21       ((uint32_t)0x00000400) /*!&lt; STM32 Medium-density and Connectivity line devices:
+                                                                   Write protection of page 20 to 21 */
+#define FLASH_WRProt_Pages22to23       ((uint32_t)0x00000800) /*!&lt; STM32 Medium-density and Connectivity line devices:
+                                                                   Write protection of page 22 to 23 */
+#define FLASH_WRProt_Pages24to25       ((uint32_t)0x00001000) /*!&lt; STM32 Medium-density and Connectivity line devices:
+                                                                   Write protection of page 24 to 25 */
+#define FLASH_WRProt_Pages26to27       ((uint32_t)0x00002000) /*!&lt; STM32 Medium-density and Connectivity line devices:
+                                                                   Write protection of page 26 to 27 */
+#define FLASH_WRProt_Pages28to29       ((uint32_t)0x00004000) /*!&lt; STM32 Medium-density and Connectivity line devices:
+                                                                   Write protection of page 28 to 29 */
+#define FLASH_WRProt_Pages30to31       ((uint32_t)0x00008000) /*!&lt; STM32 Medium-density and Connectivity line devices:
+                                                                   Write protection of page 30 to 31 */
+#define FLASH_WRProt_Pages32to33       ((uint32_t)0x00010000) /*!&lt; STM32 Medium-density and Connectivity line devices:
+                                                                   Write protection of page 32 to 33 */
+#define FLASH_WRProt_Pages34to35       ((uint32_t)0x00020000) /*!&lt; STM32 Medium-density and Connectivity line devices:
+                                                                   Write protection of page 34 to 35 */
+#define FLASH_WRProt_Pages36to37       ((uint32_t)0x00040000) /*!&lt; STM32 Medium-density and Connectivity line devices:
+                                                                   Write protection of page 36 to 37 */
+#define FLASH_WRProt_Pages38to39       ((uint32_t)0x00080000) /*!&lt; STM32 Medium-density and Connectivity line devices:
+                                                                   Write protection of page 38 to 39 */
+#define FLASH_WRProt_Pages40to41       ((uint32_t)0x00100000) /*!&lt; STM32 Medium-density and Connectivity line devices:
+                                                                   Write protection of page 40 to 41 */
+#define FLASH_WRProt_Pages42to43       ((uint32_t)0x00200000) /*!&lt; STM32 Medium-density and Connectivity line devices:
+                                                                   Write protection of page 42 to 43 */
+#define FLASH_WRProt_Pages44to45       ((uint32_t)0x00400000) /*!&lt; STM32 Medium-density and Connectivity line devices:
+                                                                   Write protection of page 44 to 45 */
+#define FLASH_WRProt_Pages46to47       ((uint32_t)0x00800000) /*!&lt; STM32 Medium-density and Connectivity line devices:
+                                                                   Write protection of page 46 to 47 */
+#define FLASH_WRProt_Pages48to49       ((uint32_t)0x01000000) /*!&lt; STM32 Medium-density and Connectivity line devices:
+                                                                   Write protection of page 48 to 49 */
+#define FLASH_WRProt_Pages50to51       ((uint32_t)0x02000000) /*!&lt; STM32 Medium-density and Connectivity line devices:
+                                                                   Write protection of page 50 to 51 */
+#define FLASH_WRProt_Pages52to53       ((uint32_t)0x04000000) /*!&lt; STM32 Medium-density and Connectivity line devices:
+                                                                   Write protection of page 52 to 53 */
+#define FLASH_WRProt_Pages54to55       ((uint32_t)0x08000000) /*!&lt; STM32 Medium-density and Connectivity line devices:
+                                                                   Write protection of page 54 to 55 */
+#define FLASH_WRProt_Pages56to57       ((uint32_t)0x10000000) /*!&lt; STM32 Medium-density and Connectivity line devices:
+                                                                   Write protection of page 56 to 57 */
+#define FLASH_WRProt_Pages58to59       ((uint32_t)0x20000000) /*!&lt; STM32 Medium-density and Connectivity line devices:
+                                                                   Write protection of page 58 to 59 */
+#define FLASH_WRProt_Pages60to61       ((uint32_t)0x40000000) /*!&lt; STM32 Medium-density and Connectivity line devices:
+                                                                   Write protection of page 60 to 61 */
+#define FLASH_WRProt_Pages62to127      ((uint32_t)0x80000000) /*!&lt; STM32 Connectivity line devices: Write protection of page 62 to 127 */
+#define FLASH_WRProt_Pages62to255      ((uint32_t)0x80000000) /*!&lt; STM32 Medium-density devices: Write protection of page 62 to 255 */
+
+#define FLASH_WRProt_AllPages          ((uint32_t)0xFFFFFFFF) /*!&lt; Write protection of all Pages */
+
 #define IS_FLASH_WRPROT_PAGE(PAGE) (((PAGE) != 0x00000000))
 
 #define IS_FLASH_ADDRESS(ADDRESS) (((ADDRESS) &gt;= 0x08000000) &amp;&amp; ((ADDRESS) &lt; 0x0807FFFF))
+
 #define IS_OB_DATA_ADDRESS(ADDRESS) (((ADDRESS) == 0x1FFFF804) || ((ADDRESS) == 0x1FFFF806))
 
-/* Option Bytes IWatchdog ----------------------------------------------------*/
-#define OB_IWDG_SW                     ((u16)0x0001)  /* Software IWDG selected */
-#define OB_IWDG_HW                     ((u16)0x0000)  /* Hardware IWDG selected */
+/**
+  * @}
+  */
 
+/** @defgroup Option_Bytes_IWatchdog 
+  * @{
+  */
+
+#define OB_IWDG_SW                     ((uint16_t)0x0001)  /*!&lt; Software IWDG selected */
+#define OB_IWDG_HW                     ((uint16_t)0x0000)  /*!&lt; Hardware IWDG selected */
 #define IS_OB_IWDG_SOURCE(SOURCE) (((SOURCE) == OB_IWDG_SW) || ((SOURCE) == OB_IWDG_HW))
 
-/* Option Bytes nRST_STOP ----------------------------------------------------*/
-#define OB_STOP_NoRST                  ((u16)0x0002) /* No reset generated when entering in STOP */
-#define OB_STOP_RST                    ((u16)0x0000) /* Reset generated when entering in STOP */
+/**
+  * @}
+  */
 
+/** @defgroup Option_Bytes_nRST_STOP 
+  * @{
+  */
+
+#define OB_STOP_NoRST                  ((uint16_t)0x0002) /*!&lt; No reset generated when entering in STOP */
+#define OB_STOP_RST                    ((uint16_t)0x0000) /*!&lt; Reset generated when entering in STOP */
 #define IS_OB_STOP_SOURCE(SOURCE) (((SOURCE) == OB_STOP_NoRST) || ((SOURCE) == OB_STOP_RST))
 
-/* Option Bytes nRST_STDBY ---------------------------------------------------*/
-#define OB_STDBY_NoRST                 ((u16)0x0004) /* No reset generated when entering in STANDBY */
-#define OB_STDBY_RST                   ((u16)0x0000) /* Reset generated when entering in STANDBY */
+/**
+  * @}
+  */
 
+/** @defgroup Option_Bytes_nRST_STDBY 
+  * @{
+  */
+
+#define OB_STDBY_NoRST                 ((uint16_t)0x0004) /*!&lt; No reset generated when entering in STANDBY */
+#define OB_STDBY_RST                   ((uint16_t)0x0000) /*!&lt; Reset generated when entering in STANDBY */
 #define IS_OB_STDBY_SOURCE(SOURCE) (((SOURCE) == OB_STDBY_NoRST) || ((SOURCE) == OB_STDBY_RST))
 
-/* FLASH Interrupts ----------------------------------------------------------*/
-#define FLASH_IT_ERROR                 ((u32)0x00000400)  /* FPEC error interrupt source */
-#define FLASH_IT_EOP                   ((u32)0x00001000)  /* End of FLASH Operation Interrupt source */
+/**
+  * @}
+  */
 
-#define IS_FLASH_IT(IT) ((((IT) &amp; (u32)0xFFFFEBFF) == 0x00000000) &amp;&amp; (((IT) != 0x00000000)))
+/** @defgroup FLASH_Interrupts 
+  * @{
+  */
 
-/* FLASH Flags ---------------------------------------------------------------*/
-#define FLASH_FLAG_BSY                 ((u32)0x00000001)  /* FLASH Busy flag */
-#define FLASH_FLAG_EOP                 ((u32)0x00000020)  /* FLASH End of Operation flag */
-#define FLASH_FLAG_PGERR               ((u32)0x00000004)  /* FLASH Program error flag */
-#define FLASH_FLAG_WRPRTERR            ((u32)0x00000010)  /* FLASH Write protected error flag */
-#define FLASH_FLAG_OPTERR              ((u32)0x00000001)  /* FLASH Option Byte error flag */
+#define FLASH_IT_ERROR                 ((uint32_t)0x00000400)  /*!&lt; FPEC error interrupt source */
+#define FLASH_IT_EOP                   ((uint32_t)0x00001000)  /*!&lt; End of FLASH Operation Interrupt source */
+#define IS_FLASH_IT(IT) ((((IT) &amp; (uint32_t)0xFFFFEBFF) == 0x00000000) &amp;&amp; (((IT) != 0x00000000)))
+
+/**
+  * @}
+  */
+
+/** @defgroup FLASH_Flags 
+  * @{
+  */
+
+#define FLASH_FLAG_BSY                 ((uint32_t)0x00000001)  /*!&lt; FLASH Busy flag */
+#define FLASH_FLAG_EOP                 ((uint32_t)0x00000020)  /*!&lt; FLASH End of Operation flag */
+#define FLASH_FLAG_PGERR               ((uint32_t)0x00000004)  /*!&lt; FLASH Program error flag */
+#define FLASH_FLAG_WRPRTERR            ((uint32_t)0x00000010)  /*!&lt; FLASH Write protected error flag */
+#define FLASH_FLAG_OPTERR              ((uint32_t)0x00000001)  /*!&lt; FLASH Option Byte error flag */
  
-#define IS_FLASH_CLEAR_FLAG(FLAG) ((((FLAG) &amp; (u32)0xFFFFFFCA) == 0x00000000) &amp;&amp; ((FLAG) != 0x00000000))
-
+#define IS_FLASH_CLEAR_FLAG(FLAG) ((((FLAG) &amp; (uint32_t)0xFFFFFFCA) == 0x00000000) &amp;&amp; ((FLAG) != 0x00000000))
 #define IS_FLASH_GET_FLAG(FLAG)  (((FLAG) == FLASH_FLAG_BSY) || ((FLAG) == FLASH_FLAG_EOP) || \
                                   ((FLAG) == FLASH_FLAG_PGERR) || ((FLAG) == FLASH_FLAG_WRPRTERR) || \
                                   ((FLAG) == FLASH_FLAG_OPTERR))
-#endif
-								 
-/* Exported constants --------------------------------------------------------*/
-/* Exported macro ------------------------------------------------------------*/
-/* Exported functions ------------------------------------------------------- */
-void FLASH_SetLatency(u32 FLASH_Latency);
-void FLASH_HalfCycleAccessCmd(u32 FLASH_HalfCycleAccess);
-void FLASH_PrefetchBufferCmd(u32 FLASH_PrefetchBuffer);
 
-#ifdef _FLASH_PROG
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup FLASH_Exported_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup FLASH_Exported_Functions
+  * @{
+  */
+
+void FLASH_SetLatency(uint32_t FLASH_Latency);
+void FLASH_HalfCycleAccessCmd(uint32_t FLASH_HalfCycleAccess);
+void FLASH_PrefetchBufferCmd(uint32_t FLASH_PrefetchBuffer);
 void FLASH_Unlock(void);
 void FLASH_Lock(void);
-FLASH_Status FLASH_ErasePage(u32 Page_Address);
+FLASH_Status FLASH_ErasePage(uint32_t Page_Address);
 FLASH_Status FLASH_EraseAllPages(void);
 FLASH_Status FLASH_EraseOptionBytes(void);
-FLASH_Status FLASH_ProgramWord(u32 Address, u32 Data);
-FLASH_Status FLASH_ProgramHalfWord(u32 Address, u16 Data);
-FLASH_Status FLASH_ProgramOptionByteData(u32 Address, u8 Data);
-FLASH_Status FLASH_EnableWriteProtection(u32 FLASH_Pages);
+FLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data);
+FLASH_Status FLASH_ProgramHalfWord(uint32_t Address, uint16_t Data);
+FLASH_Status FLASH_ProgramOptionByteData(uint32_t Address, uint8_t Data);
+FLASH_Status FLASH_EnableWriteProtection(uint32_t FLASH_Pages);
 FLASH_Status FLASH_ReadOutProtection(FunctionalState NewState);
-FLASH_Status FLASH_UserOptionByteConfig(u16 OB_IWDG, u16 OB_STOP, u16 OB_STDBY);
-u32 FLASH_GetUserOptionByte(void);
-u32 FLASH_GetWriteProtectionOptionByte(void);
+FLASH_Status FLASH_UserOptionByteConfig(uint16_t OB_IWDG, uint16_t OB_STOP, uint16_t OB_STDBY);
+uint32_t FLASH_GetUserOptionByte(void);
+uint32_t FLASH_GetWriteProtectionOptionByte(void);
 FlagStatus FLASH_GetReadOutProtectionStatus(void);
 FlagStatus FLASH_GetPrefetchBufferStatus(void);
-void FLASH_ITConfig(u16 FLASH_IT, FunctionalState NewState);
-FlagStatus FLASH_GetFlagStatus(u16 FLASH_FLAG);
-void FLASH_ClearFlag(u16 FLASH_FLAG);
+void FLASH_ITConfig(uint16_t FLASH_IT, FunctionalState NewState);
+FlagStatus FLASH_GetFlagStatus(uint16_t FLASH_FLAG);
+void FLASH_ClearFlag(uint16_t FLASH_FLAG);
 FLASH_Status FLASH_GetStatus(void);
-FLASH_Status FLASH_WaitForLastOperation(u32 Timeout);
+FLASH_Status FLASH_WaitForLastOperation(uint32_t Timeout);
+
+#ifdef __cplusplus
+}
 #endif
 
 #endif /* __STM32F10x_FLASH_H */
+/**
+  * @}
+  */
 
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2009 STMicroelectronics *****END OF FILE****/

Modified: trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_fsmc.h
===================================================================
--- trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_fsmc.h	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_fsmc.h	2009-07-08 23:39:34 UTC (rev 354)
@@ -1,327 +1,683 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_fsmc.h
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file contains all the functions prototypes for the
-*                      FSMC firmware library.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
+/**
+  ******************************************************************************
+  * @file    stm32f10x_fsmc.h
+  * @author  MCD Application Team
+  * @version V3.1.0
+  * @date    06/19/2009
+  * @brief   This file contains all the functions prototypes for the FSMC firmware 
+  *          library.
+  ******************************************************************************
+  * @copy
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * &lt;h2&gt;&lt;center&gt;&copy; COPYRIGHT 2009 STMicroelectronics&lt;/center&gt;&lt;/h2&gt;
+  */ 
 
 /* Define to prevent recursive inclusion -------------------------------------*/
 #ifndef __STM32F10x_FSMC_H
 #define __STM32F10x_FSMC_H
 
+#ifdef __cplusplus
+ extern &quot;C&quot; {
+#endif
+
 /* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_map.h&quot;
+#include &quot;stm32f10x.h&quot;
 
-/* Exported types ------------------------------------------------------------*/
-/* Timing parameters For NOR/SRAM Banks */
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @addtogroup FSMC
+  * @{
+  */
+
+/** @defgroup FSMC_Exported_Types
+  * @{
+  */
+
+/** 
+  * @brief  Timing parameters For NOR/SRAM Banks  
+  */
+
 typedef struct
 {
-  u32 FSMC_AddressSetupTime;
-  u32 FSMC_AddressHoldTime;
-  u32 FSMC_DataSetupTime;
-  u32 FSMC_BusTurnAroundDuration;
-  u32 FSMC_CLKDivision;
-  u32 FSMC_DataLatency;
-  u32 FSMC_AccessMode;
+  uint32_t FSMC_AddressSetupTime;       /*!&lt; Defines the number of HCLK cycles to configure
+                                             the duration of the address setup time. 
+                                             This parameter can be a value between 0 and 0xF.
+                                             @note: It is not used with synchronous NOR Flash memories. */
+
+  uint32_t FSMC_AddressHoldTime;        /*!&lt; Defines the number of HCLK cycles to configure
+                                             the duration of the address hold time.
+                                             This parameter can be a value between 0 and 0xF. 
+                                             @note: It is not used with synchronous NOR Flash memories.*/
+
+  uint32_t FSMC_DataSetupTime;          /*!&lt; Defines the number of HCLK cycles to configure
+                                             the duration of the data setup time.
+                                             This parameter can be a value between 0 and 0xFF.
+                                             @note: It is used for SRAMs, ROMs and asynchronous multiplexed NOR Flash memories. */
+
+  uint32_t FSMC_BusTurnAroundDuration;  /*!&lt; Defines the number of HCLK cycles to configure
+                                             the duration of the bus turnaround.
+                                             This parameter can be a value between 0 and 0xF.
+                                             @note: It is only used for multiplexed NOR Flash memories. */
+
+  uint32_t FSMC_CLKDivision;            /*!&lt; Defines the period of CLK clock output signal, expressed in number of HCLK cycles.
+                                             This parameter can be a value between 1 and 0xF.
+                                             @note: This parameter is not used for asynchronous NOR Flash, SRAM or ROM accesses. */
+
+  uint32_t FSMC_DataLatency;            /*!&lt; Defines the number of memory clock cycles to issue
+                                             to the memory before getting the first data.
+                                             The value of this parameter depends on the memory type as shown below:
+                                              - It must be set to 0 in case of a CRAM
+                                              - It is don&#146;t care in asynchronous NOR, SRAM or ROM accesses
+                                              - It may assume a value between 0 and 0xF in NOR Flash memories
+                                                with synchronous burst mode enable */
+
+  uint32_t FSMC_AccessMode;             /*!&lt; Specifies the asynchronous access mode. 
+                                             This parameter can be a value of @ref FSMC_Access_Mode */
 }FSMC_NORSRAMTimingInitTypeDef;
 
-/* FSMC NOR/SRAM Init structure definition */
+/** 
+  * @brief  FSMC NOR/SRAM Init structure definition
+  */
+
 typedef struct
 {
-  u32 FSMC_Bank;
-  u32 FSMC_DataAddressMux;
-  u32 FSMC_MemoryType;
-  u32 FSMC_MemoryDataWidth;
-  u32 FSMC_BurstAccessMode;
-  u32 FSMC_WaitSignalPolarity;
-  u32 FSMC_WrapMode;
-  u32 FSMC_WaitSignalActive;
-  u32 FSMC_WriteOperation;
-  u32 FSMC_WaitSignal;
-  u32 FSMC_ExtendedMode;
-  u32 FSMC_WriteBurst;
-  /* Timing Parameters for write and read access if the  ExtendedMode is not used*/
-  FSMC_NORSRAMTimingInitTypeDef* FSMC_ReadWriteTimingStruct;
-  /* Timing Parameters for write access if the  ExtendedMode is used*/
-  FSMC_NORSRAMTimingInitTypeDef* FSMC_WriteTimingStruct;
+  uint32_t FSMC_Bank;                /*!&lt; Specifies the NOR/SRAM memory bank that will be used.
+                                          This parameter can be a value of @ref FSMC_NORSRAM_Bank */
+
+  uint32_t FSMC_DataAddressMux;      /*!&lt; Specifies whether the address and data values are
+                                          multiplexed on the databus or not. 
+                                          This parameter can be a value of @ref FSMC_Data_Address_Bus_Multiplexing */
+
+  uint32_t FSMC_MemoryType;          /*!&lt; Specifies the type of external memory attached to
+                                          the corresponding memory bank.
+                                          This parameter can be a value of @ref FSMC_Memory_Type */
+
+  uint32_t FSMC_MemoryDataWidth;     /*!&lt; Specifies the external memory device width.
+                                          This parameter can be a value of @ref FSMC_Data_Width */
+
+  uint32_t FSMC_BurstAccessMode;     /*!&lt; Enables or disables the burst access mode for Flash memory,
+                                          valid only with synchronous burst Flash memories.
+                                          This parameter can be a value of @ref FSMC_Burst_Access_Mode */
+
+  uint32_t FSMC_WaitSignalPolarity;  /*!&lt; Specifies the wait signal polarity, valid only when accessing
+                                          the Flash memory in burst mode.
+                                          This parameter can be a value of @ref FSMC_Wait_Signal_Polarity */
+
+  uint32_t FSMC_WrapMode;            /*!&lt; Enables or disables the Wrapped burst access mode for Flash
+                                          memory, valid only when accessing Flash memories in burst mode.
+                                          This parameter can be a value of @ref FSMC_Wrap_Mode */
+
+  uint32_t FSMC_WaitSignalActive;    /*!&lt; Specifies if the wait signal is asserted by the memory one
+                                          clock cycle before the wait state or during the wait state,
+                                          valid only when accessing memories in burst mode. 
+                                          This parameter can be a value of @ref FSMC_Wait_Timing */
+
+  uint32_t FSMC_WriteOperation;      /*!&lt; Enables or disables the write operation in the selected bank by the FSMC. 
+                                          This parameter can be a value of @ref FSMC_Write_Operation */
+
+  uint32_t FSMC_WaitSignal;          /*!&lt; Enables or disables the wait-state insertion via wait
+                                          signal, valid for Flash memory access in burst mode. 
+                                          This parameter can be a value of @ref FSMC_Wait_Signal */
+
+  uint32_t FSMC_ExtendedMode;        /*!&lt; Enables or disables the extended mode.
+                                          This parameter can be a value of @ref FSMC_Extended_Mode */
+
+  uint32_t FSMC_WriteBurst;          /*!&lt; Enables or disables the write burst operation.
+                                          This parameter can be a value of @ref FSMC_Write_Burst */ 
+
+  FSMC_NORSRAMTimingInitTypeDef* FSMC_ReadWriteTimingStruct; /*!&lt; Timing Parameters for write and read access if the  ExtendedMode is not used*/  
+
+  FSMC_NORSRAMTimingInitTypeDef* FSMC_WriteTimingStruct;     /*!&lt; Timing Parameters for write access if the  ExtendedMode is used*/      
 }FSMC_NORSRAMInitTypeDef;
 
-/* Timing parameters For FSMC NAND and PCCARD Banks */
+/** 
+  * @brief  Timing parameters For FSMC NAND and PCCARD Banks
+  */
+
 typedef struct
 {
-  u32 FSMC_SetupTime;
-  u32 FSMC_WaitSetupTime;
-  u32 FSMC_HoldSetupTime;
-  u32 FSMC_HiZSetupTime;
+  uint32_t FSMC_SetupTime;      /*!&lt; Defines the number of HCLK cycles to setup address before
+                                     the command assertion for NAND-Flash read or write access
+                                     to common/Attribute or I/O memory space (depending on
+                                     the memory space timing to be configured).
+                                     This parameter can be a value between 0 and 0xFF.*/
+
+  uint32_t FSMC_WaitSetupTime;  /*!&lt; Defines the minimum number of HCLK cycles to assert the
+                                     command for NAND-Flash read or write access to
+                                     common/Attribute or I/O memory space (depending on the
+                                     memory space timing to be configured). 
+                                     This parameter can be a number between 0x00 and 0xFF */
+
+  uint32_t FSMC_HoldSetupTime;  /*!&lt; Defines the number of HCLK clock cycles to hold address
+                                     (and data for write access) after the command deassertion
+                                     for NAND-Flash read or write access to common/Attribute
+                                     or I/O memory space (depending on the memory space timing
+                                     to be configured).
+                                     This parameter can be a number between 0x00 and 0xFF */
+
+  uint32_t FSMC_HiZSetupTime;   /*!&lt; Defines the number of HCLK clock cycles during which the
+                                     databus is kept in HiZ after the start of a NAND-Flash
+                                     write access to common/Attribute or I/O memory space (depending
+                                     on the memory space timing to be configured).
+                                     This parameter can be a number between 0x00 and 0xFF */
 }FSMC_NAND_PCCARDTimingInitTypeDef;
 
-/* FSMC NAND Init structure definition */
+/** 
+  * @brief  FSMC NAND Init structure definition
+  */
+
 typedef struct
 {
-  u32 FSMC_Bank;
-  u32 FSMC_Waitfeature;
-  u32 FSMC_MemoryDataWidth;
-  u32 FSMC_ECC;
-  u32 FSMC_ECCPageSize;
-  u32 FSMC_AddressLowMapping;
-  u32 FSMC_TCLRSetupTime;
-  u32 FSMC_TARSetupTime;
-  /* FSMC Common Space Timing */
-  FSMC_NAND_PCCARDTimingInitTypeDef*  FSMC_CommonSpaceTimingStruct;
-  /* FSMC Attribute Space Timing */
-  FSMC_NAND_PCCARDTimingInitTypeDef*  FSMC_AttributeSpaceTimingStruct;
+  uint32_t FSMC_Bank;              /*!&lt; Specifies the NAND memory bank that will be used.
+                                      This parameter can be a value of @ref FSMC_NAND_Bank */
+
+  uint32_t FSMC_Waitfeature;      /*!&lt; Enables or disables the Wait feature for the NAND Memory Bank.
+                                       This parameter can be any value of @ref FSMC_Wait_feature */
+
+  uint32_t FSMC_MemoryDataWidth;  /*!&lt; Specifies the external memory device width.
+                                       This parameter can be any value of @ref FSMC_Data_Width */
+
+  uint32_t FSMC_ECC;              /*!&lt; Enables or disables the ECC computation.
+                                       This parameter can be any value of @ref FSMC_ECC */
+
+  uint32_t FSMC_ECCPageSize;      /*!&lt; Defines the page size for the extended ECC.
+                                       This parameter can be any value of @ref FSMC_ECC_Page_Size */
+
+  uint32_t FSMC_TCLRSetupTime;    /*!&lt; Defines the number of HCLK cycles to configure the
+                                       delay between CLE low and RE low.
+                                       This parameter can be a value between 0 and 0xFF. */
+
+  uint32_t FSMC_TARSetupTime;     /*!&lt; Defines the number of HCLK cycles to configure the
+                                       delay between ALE low and RE low.
+                                       This parameter can be a number between 0x0 and 0xFF */ 
+
+  FSMC_NAND_PCCARDTimingInitTypeDef*  FSMC_CommonSpaceTimingStruct;   /*!&lt; FSMC Common Space Timing */ 
+
+  FSMC_NAND_PCCARDTimingInitTypeDef*  FSMC_AttributeSpaceTimingStruct; /*!&lt; FSMC Attribute Space Timing */
 }FSMC_NANDInitTypeDef;
 
-/* FSMC PCCARD Init structure definition */
+/** 
+  * @brief  FSMC PCCARD Init structure definition
+  */
+
 typedef struct
 {
-  u32 FSMC_Waitfeature;
-  u32 FSMC_AddressLowMapping;
-  u32 FSMC_TCLRSetupTime;
-  u32 FSMC_TARSetupTime;
-  /* FSMC Common Space Timing */
-  FSMC_NAND_PCCARDTimingInitTypeDef*  FSMC_CommonSpaceTimingStruct;
-  /* FSMC Attribute Space Timing */
-  FSMC_NAND_PCCARDTimingInitTypeDef*  FSMC_AttributeSpaceTimingStruct;
-  /* FSMC IO Space Timing */
-  FSMC_NAND_PCCARDTimingInitTypeDef*  FSMC_IOSpaceTimingStruct;
+  uint32_t FSMC_Waitfeature;    /*!&lt; Enables or disables the Wait feature for the Memory Bank.
+                                    This parameter can be any value of @ref FSMC_Wait_feature */
+
+  uint32_t FSMC_TCLRSetupTime;  /*!&lt; Defines the number of HCLK cycles to configure the
+                                     delay between CLE low and RE low.
+                                     This parameter can be a value between 0 and 0xFF. */
+
+  uint32_t FSMC_TARSetupTime;   /*!&lt; Defines the number of HCLK cycles to configure the
+                                     delay between ALE low and RE low.
+                                     This parameter can be a number between 0x0 and 0xFF */ 
+
+  
+  FSMC_NAND_PCCARDTimingInitTypeDef*  FSMC_CommonSpaceTimingStruct; /*!&lt; FSMC Common Space Timing */
+
+  FSMC_NAND_PCCARDTimingInitTypeDef*  FSMC_AttributeSpaceTimingStruct;  /*!&lt; FSMC Attribute Space Timing */ 
+  
+  FSMC_NAND_PCCARDTimingInitTypeDef*  FSMC_IOSpaceTimingStruct; /*!&lt; FSMC IO Space Timing */  
 }FSMC_PCCARDInitTypeDef;
 
-/* Exported constants --------------------------------------------------------*/
-/*-------------------------------FSMC Banks definitions ----------------------*/
-#define FSMC_Bank1_NORSRAM1                             ((u32)0x00000000)
-#define FSMC_Bank1_NORSRAM2                             ((u32)0x00000002)
-#define FSMC_Bank1_NORSRAM3                             ((u32)0x00000004)
-#define FSMC_Bank1_NORSRAM4                             ((u32)0x00000006)
-#define FSMC_Bank2_NAND                                 ((u32)0x00000010)
-#define FSMC_Bank3_NAND                                 ((u32)0x00000100)
-#define FSMC_Bank4_PCCARD                               ((u32)0x00001000)
+/**
+  * @}
+  */
 
+/** @defgroup FSMC_Exported_Constants
+  * @{
+  */
+
+/** @defgroup FSMC_NORSRAM_Bank 
+  * @{
+  */
+#define FSMC_Bank1_NORSRAM1                             ((uint32_t)0x00000000)
+#define FSMC_Bank1_NORSRAM2                             ((uint32_t)0x00000002)
+#define FSMC_Bank1_NORSRAM3                             ((uint32_t)0x00000004)
+#define FSMC_Bank1_NORSRAM4                             ((uint32_t)0x00000006)
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_NAND_Bank 
+  * @{
+  */  
+#define FSMC_Bank2_NAND                                 ((uint32_t)0x00000010)
+#define FSMC_Bank3_NAND                                 ((uint32_t)0x00000100)
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_PCCARD_Bank 
+  * @{
+  */    
+#define FSMC_Bank4_PCCARD                               ((uint32_t)0x00001000)
+/**
+  * @}
+  */
+
 #define IS_FSMC_NORSRAM_BANK(BANK) (((BANK) == FSMC_Bank1_NORSRAM1) || \
                                     ((BANK) == FSMC_Bank1_NORSRAM2) || \
                                     ((BANK) == FSMC_Bank1_NORSRAM3) || \
-                                    ((BANK) == FSMC_Bank1_NORSRAM4))                           
+                                    ((BANK) == FSMC_Bank1_NORSRAM4))
 
-
 #define IS_FSMC_NAND_BANK(BANK) (((BANK) == FSMC_Bank2_NAND) || \
                                  ((BANK) == FSMC_Bank3_NAND))
 
 #define IS_FSMC_GETFLAG_BANK(BANK) (((BANK) == FSMC_Bank2_NAND) || \
                                     ((BANK) == FSMC_Bank3_NAND) || \
                                     ((BANK) == FSMC_Bank4_PCCARD))
-                                    
+
 #define IS_FSMC_IT_BANK(BANK) (((BANK) == FSMC_Bank2_NAND) || \
                                ((BANK) == FSMC_Bank3_NAND) || \
-                               ((BANK) == FSMC_Bank4_PCCARD))                                    
+                               ((BANK) == FSMC_Bank4_PCCARD))
 
+/** @defgroup NOR_SRAM_Controller 
+  * @{
+  */
 
-/*------------------------------- NOR/SRAM Banks -----------------------------*/
-/* FSMC Data/Address Bus Multiplexing ----------------------------------------*/
-#define FSMC_DataAddressMux_Disable                       ((u32)0x00000000)
-#define FSMC_DataAddressMux_Enable                        ((u32)0x00000002)
+/** @defgroup FSMC_Data_Address_Bus_Multiplexing 
+  * @{
+  */
 
+#define FSMC_DataAddressMux_Disable                       ((uint32_t)0x00000000)
+#define FSMC_DataAddressMux_Enable                        ((uint32_t)0x00000002)
 #define IS_FSMC_MUX(MUX) (((MUX) == FSMC_DataAddressMux_Disable) || \
-                          ((MUX) == FSMC_DataAddressMux_Enable))                           
+                          ((MUX) == FSMC_DataAddressMux_Enable))
 
-/* FSMC Memory Type ----------------------------------------------------------*/
-#define FSMC_MemoryType_SRAM                            ((u32)0x00000000)
-#define FSMC_MemoryType_PSRAM                           ((u32)0x00000004)
-#define FSMC_MemoryType_NOR                             ((u32)0x00000008)
+/**
+  * @}
+  */
 
+/** @defgroup FSMC_Memory_Type 
+  * @{
+  */
+
+#define FSMC_MemoryType_SRAM                            ((uint32_t)0x00000000)
+#define FSMC_MemoryType_PSRAM                           ((uint32_t)0x00000004)
+#define FSMC_MemoryType_NOR                             ((uint32_t)0x00000008)
 #define IS_FSMC_MEMORY(MEMORY) (((MEMORY) == FSMC_MemoryType_SRAM) || \
                                 ((MEMORY) == FSMC_MemoryType_PSRAM)|| \
                                 ((MEMORY) == FSMC_MemoryType_NOR))
-                                     
-/* FSMC  Data Width ----------------------------------------------------------*/
-#define FSMC_MemoryDataWidth_8b                         ((u32)0x00000000)
-#define FSMC_MemoryDataWidth_16b                        ((u32)0x00000010)
 
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_Data_Width 
+  * @{
+  */
+
+#define FSMC_MemoryDataWidth_8b                         ((uint32_t)0x00000000)
+#define FSMC_MemoryDataWidth_16b                        ((uint32_t)0x00000010)
 #define IS_FSMC_MEMORY_WIDTH(WIDTH) (((WIDTH) == FSMC_MemoryDataWidth_8b) || \
                                      ((WIDTH) == FSMC_MemoryDataWidth_16b))
-                                      
-                               
-/* FSMC Burst Access Mode ----------------------------------------------------*/
-#define FSMC_BurstAccessMode_Disable                    ((u32)0x00000000) 
-#define FSMC_BurstAccessMode_Enable                     ((u32)0x00000100)
 
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_Burst_Access_Mode 
+  * @{
+  */
+
+#define FSMC_BurstAccessMode_Disable                    ((uint32_t)0x00000000) 
+#define FSMC_BurstAccessMode_Enable                     ((uint32_t)0x00000100)
 #define IS_FSMC_BURSTMODE(STATE) (((STATE) == FSMC_BurstAccessMode_Disable) || \
                                   ((STATE) == FSMC_BurstAccessMode_Enable))
+/**
+  * @}
+  */
 
-/* FSMC Wait Signal Polarity -------------------------------------------------*/                                  
-#define FSMC_WaitSignalPolarity_Low                     ((u32)0x00000000)
-#define FSMC_WaitSignalPolarity_High                    ((u32)0x00000200)
+/** @defgroup FSMC_Wait_Signal_Polarity 
+  * @{
+  */
 
+#define FSMC_WaitSignalPolarity_Low                     ((uint32_t)0x00000000)
+#define FSMC_WaitSignalPolarity_High                    ((uint32_t)0x00000200)
 #define IS_FSMC_WAIT_POLARITY(POLARITY) (((POLARITY) == FSMC_WaitSignalPolarity_Low) || \
                                          ((POLARITY) == FSMC_WaitSignalPolarity_High)) 
-                                        
-/* FSMC Wrap Mode ------------------------------------------------------------*/ 
-#define FSMC_WrapMode_Disable                           ((u32)0x00000000)
-#define FSMC_WrapMode_Enable                            ((u32)0x00000400) 
 
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_Wrap_Mode 
+  * @{
+  */
+
+#define FSMC_WrapMode_Disable                           ((uint32_t)0x00000000)
+#define FSMC_WrapMode_Enable                            ((uint32_t)0x00000400) 
 #define IS_FSMC_WRAP_MODE(MODE) (((MODE) == FSMC_WrapMode_Disable) || \
                                  ((MODE) == FSMC_WrapMode_Enable))
-                                 
-/* FSMC Wait Timing ----------------------------------------------------------*/                                 
-#define FSMC_WaitSignalActive_BeforeWaitState           ((u32)0x00000000)
-#define FSMC_WaitSignalActive_DuringWaitState           ((u32)0x00000800) 
 
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_Wait_Timing 
+  * @{
+  */
+
+#define FSMC_WaitSignalActive_BeforeWaitState           ((uint32_t)0x00000000)
+#define FSMC_WaitSignalActive_DuringWaitState           ((uint32_t)0x00000800) 
 #define IS_FSMC_WAIT_SIGNAL_ACTIVE(ACTIVE) (((ACTIVE) == FSMC_WaitSignalActive_BeforeWaitState) || \
                                             ((ACTIVE) == FSMC_WaitSignalActive_DuringWaitState))
-                                    
-/* FSMC Write Operation ------------------------------------------------------*/
-#define FSMC_WriteOperation_Disable                     ((u32)0x00000000)
-#define FSMC_WriteOperation_Enable                      ((u32)0x00001000)
 
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_Write_Operation 
+  * @{
+  */
+
+#define FSMC_WriteOperation_Disable                     ((uint32_t)0x00000000)
+#define FSMC_WriteOperation_Enable                      ((uint32_t)0x00001000)
 #define IS_FSMC_WRITE_OPERATION(OPERATION) (((OPERATION) == FSMC_WriteOperation_Disable) || \
                                             ((OPERATION) == FSMC_WriteOperation_Enable))
                               
-/* FSMC Wait Signal ----------------------------------------------------------*/
-#define FSMC_WaitSignal_Disable                         ((u32)0x00000000)
-#define FSMC_WaitSignal_Enable                          ((u32)0x00002000) 
+/**
+  * @}
+  */
 
+/** @defgroup FSMC_Wait_Signal 
+  * @{
+  */
+
+#define FSMC_WaitSignal_Disable                         ((uint32_t)0x00000000)
+#define FSMC_WaitSignal_Enable                          ((uint32_t)0x00002000) 
 #define IS_FSMC_WAITE_SIGNAL(SIGNAL) (((SIGNAL) == FSMC_WaitSignal_Disable) || \
                                       ((SIGNAL) == FSMC_WaitSignal_Enable))
+/**
+  * @}
+  */
 
-/* FSMC Extended Mode --------------------------------------------------------*/
-#define FSMC_ExtendedMode_Disable                       ((u32)0x00000000)
-#define FSMC_ExtendedMode_Enable                        ((u32)0x00004000)                                  
+/** @defgroup FSMC_Extended_Mode 
+  * @{
+  */
 
+#define FSMC_ExtendedMode_Disable                       ((uint32_t)0x00000000)
+#define FSMC_ExtendedMode_Enable                        ((uint32_t)0x00004000)
+
 #define IS_FSMC_EXTENDED_MODE(MODE) (((MODE) == FSMC_ExtendedMode_Disable) || \
                                      ((MODE) == FSMC_ExtendedMode_Enable)) 
-                                                                 
-/* FSMC Write Burst ----------------------------------------------------------*/                                  
-#define FSMC_WriteBurst_Disable                         ((u32)0x00000000)
-#define FSMC_WriteBurst_Enable                          ((u32)0x00080000) 
 
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_Write_Burst 
+  * @{
+  */
+
+#define FSMC_WriteBurst_Disable                         ((uint32_t)0x00000000)
+#define FSMC_WriteBurst_Enable                          ((uint32_t)0x00080000) 
 #define IS_FSMC_WRITE_BURST(BURST) (((BURST) == FSMC_WriteBurst_Disable) || \
                                     ((BURST) == FSMC_WriteBurst_Enable))
+/**
+  * @}
+  */
 
-/* FSMC Address Setup Time ---------------------------------------------------*/
+/** @defgroup FSMC_Address_Setup_Time 
+  * @{
+  */
+
 #define IS_FSMC_ADDRESS_SETUP_TIME(TIME) ((TIME) &lt;= 0xF)
 
-/* FSMC Address Hold Time ----------------------------------------------------*/
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_Address_Hold_Time 
+  * @{
+  */
+
 #define IS_FSMC_ADDRESS_HOLD_TIME(TIME) ((TIME) &lt;= 0xF)
 
-/* FSMC Data Setup Time ------------------------------------------------------*/
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_Data_Setup_Time 
+  * @{
+  */
+
 #define IS_FSMC_DATASETUP_TIME(TIME) (((TIME) &gt; 0) &amp;&amp; ((TIME) &lt;= 0xFF))
 
-/* FSMC Bus Turn around Duration ---------------------------------------------*/
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_Bus_Turn_around_Duration 
+  * @{
+  */
+
 #define IS_FSMC_TURNAROUND_TIME(TIME) ((TIME) &lt;= 0xF)
 
-/* FSMC CLK Division ---------------------------------------------------------*/
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_CLK_Division 
+  * @{
+  */
+
 #define IS_FSMC_CLK_DIV(DIV) ((DIV) &lt;= 0xF)
 
-/* FSMC Data Latency ---------------------------------------------------------*/
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_Data_Latency 
+  * @{
+  */
+
 #define IS_FSMC_DATA_LATENCY(LATENCY) ((LATENCY) &lt;= 0xF)
 
-/* FSMC Access Mode ----------------------------------------------------------*/
-#define FSMC_AccessMode_A                               ((u32)0x00000000)
-#define FSMC_AccessMode_B                               ((u32)0x10000000) 
-#define FSMC_AccessMode_C                               ((u32)0x20000000)
-#define FSMC_AccessMode_D                               ((u32)0x30000000)
+/**
+  * @}
+  */
 
+/** @defgroup FSMC_Access_Mode 
+  * @{
+  */
+
+#define FSMC_AccessMode_A                               ((uint32_t)0x00000000)
+#define FSMC_AccessMode_B                               ((uint32_t)0x10000000) 
+#define FSMC_AccessMode_C                               ((uint32_t)0x20000000)
+#define FSMC_AccessMode_D                               ((uint32_t)0x30000000)
 #define IS_FSMC_ACCESS_MODE(MODE) (((MODE) == FSMC_AccessMode_A) || \
                                    ((MODE) == FSMC_AccessMode_B) || \
                                    ((MODE) == FSMC_AccessMode_C) || \
                                    ((MODE) == FSMC_AccessMode_D)) 
-                                  
-/*----------------------------- NAND and PCCARD Banks ------------------------*/
-/* FSMC Wait feature ---------------------------------------------------------*/
-#define FSMC_Waitfeature_Disable                        ((u32)0x00000000)
-#define FSMC_Waitfeature_Enable                         ((u32)0x00000002)
 
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+  
+/** @defgroup NAND_PCCARD_Controller 
+  * @{
+  */
+
+/** @defgroup FSMC_Wait_feature 
+  * @{
+  */
+
+#define FSMC_Waitfeature_Disable                        ((uint32_t)0x00000000)
+#define FSMC_Waitfeature_Enable                         ((uint32_t)0x00000002)
 #define IS_FSMC_WAIT_FEATURE(FEATURE) (((FEATURE) == FSMC_Waitfeature_Disable) || \
                                        ((FEATURE) == FSMC_Waitfeature_Enable))
-                                    
-/* FSMC Memory Data Width ----------------------------------------------------*/
-#define FSMC_MemoryDataWidth_8b                         ((u32)0x00000000)
-#define FSMC_MemoryDataWidth_16b                        ((u32)0x00000010)
 
-#define IS_FSMC_DATA_WIDTH(WIDTH) (((WIDTH) == FSMC_MemoryDataWidth_8b) || \
-                                   ((WIDTH) == FSMC_MemoryDataWidth_16b))
-                                    
-/* FSMC ECC ------------------------------------------------------------------*/
-#define FSMC_ECC_Disable                                ((u32)0x00000000)
-#define FSMC_ECC_Enable                                 ((u32)0x00000040)
+/**
+  * @}
+  */
 
+
+/** @defgroup FSMC_ECC 
+  * @{
+  */
+
+#define FSMC_ECC_Disable                                ((uint32_t)0x00000000)
+#define FSMC_ECC_Enable                                 ((uint32_t)0x00000040)
 #define IS_FSMC_ECC_STATE(STATE) (((STATE) == FSMC_ECC_Disable) || \
                                   ((STATE) == FSMC_ECC_Enable))
-                                            
-/* FSMC ECC Page Size --------------------------------------------------------*/
-#define FSMC_ECCPageSize_256Bytes                       ((u32)0x00000000)
-#define FSMC_ECCPageSize_512Bytes                       ((u32)0x00020000)
-#define FSMC_ECCPageSize_1024Bytes                      ((u32)0x00040000)
-#define FSMC_ECCPageSize_2048Bytes                      ((u32)0x00060000)
-#define FSMC_ECCPageSize_4096Bytes                      ((u32)0x00080000)
-#define FSMC_ECCPageSize_8192Bytes                      ((u32)0x000A0000)
 
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_ECC_Page_Size 
+  * @{
+  */
+
+#define FSMC_ECCPageSize_256Bytes                       ((uint32_t)0x00000000)
+#define FSMC_ECCPageSize_512Bytes                       ((uint32_t)0x00020000)
+#define FSMC_ECCPageSize_1024Bytes                      ((uint32_t)0x00040000)
+#define FSMC_ECCPageSize_2048Bytes                      ((uint32_t)0x00060000)
+#define FSMC_ECCPageSize_4096Bytes                      ((uint32_t)0x00080000)
+#define FSMC_ECCPageSize_8192Bytes                      ((uint32_t)0x000A0000)
 #define IS_FSMC_ECCPAGE_SIZE(SIZE) (((SIZE) == FSMC_ECCPageSize_256Bytes) || \
                                     ((SIZE) == FSMC_ECCPageSize_512Bytes) || \
                                     ((SIZE) == FSMC_ECCPageSize_1024Bytes) || \
                                     ((SIZE) == FSMC_ECCPageSize_2048Bytes) || \
                                     ((SIZE) == FSMC_ECCPageSize_4096Bytes) || \
                                     ((SIZE) == FSMC_ECCPageSize_8192Bytes))
-                                                              
-/* FSMC Address Low Mapping --------------------------------------------------*/
-#define FSMC_AddressLowMapping_Direct                   ((u32)0x00000000)
-#define FSMC_AddressLowMapping_InDirect                 ((u32)0x00000100)
 
-#define IS_FSMC_ADDRESS_LOW_MAPPING(MAPPING) (((MAPPING) == FSMC_AddressLowMapping_Direct) || \
-                                              ((MAPPING) == FSMC_AddressLowMapping_InDirect))
-/* FSMC TCLR Setup Time ------------------------------------------------------*/
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_TCLR_Setup_Time 
+  * @{
+  */
+
 #define IS_FSMC_TCLR_TIME(TIME) ((TIME) &lt;= 0xFF)
 
-/* FSMC TAR Setup Time -------------------------------------------------------*/
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_TAR_Setup_Time 
+  * @{
+  */
+
 #define IS_FSMC_TAR_TIME(TIME) ((TIME) &lt;= 0xFF)
 
-/* FSMC Setup Time ----------------------------------------------------*/
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_Setup_Time 
+  * @{
+  */
+
 #define IS_FSMC_SETUP_TIME(TIME) ((TIME) &lt;= 0xFF)
 
-/* FSMC Wait Setup Time -----------------------------------------------*/
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_Wait_Setup_Time 
+  * @{
+  */
+
 #define IS_FSMC_WAIT_TIME(TIME) ((TIME) &lt;= 0xFF)
 
-/* FSMC Hold Setup Time -----------------------------------------------*/
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_Hold_Setup_Time 
+  * @{
+  */
+
 #define IS_FSMC_HOLD_TIME(TIME) ((TIME) &lt;= 0xFF)
 
-/* FSMC HiZ Setup Time ------------------------------------------------*/
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_HiZ_Setup_Time 
+  * @{
+  */
+
 #define IS_FSMC_HIZ_TIME(TIME) ((TIME) &lt;= 0xFF)
 
-/* FSMC Interrupt sources ----------------------------------------------------*/
-#define FSMC_IT_RisingEdge                              ((u32)0x00000008)
-#define FSMC_IT_Level                                   ((u32)0x00000010)
-#define FSMC_IT_FallingEdge                             ((u32)0x00000020)
+/**
+  * @}
+  */
 
-#define IS_FSMC_IT(IT) ((((IT) &amp; (u32)0xFFFFFFC7) == 0x00000000) &amp;&amp; ((IT) != 0x00000000))
+/** @defgroup FSMC_Interrupt_sources 
+  * @{
+  */
 
+#define FSMC_IT_RisingEdge                              ((uint32_t)0x00000008)
+#define FSMC_IT_Level                                   ((uint32_t)0x00000010)
+#define FSMC_IT_FallingEdge                             ((uint32_t)0x00000020)
+#define IS_FSMC_IT(IT) ((((IT) &amp; (uint32_t)0xFFFFFFC7) == 0x00000000) &amp;&amp; ((IT) != 0x00000000))
 #define IS_FSMC_GET_IT(IT) (((IT) == FSMC_IT_RisingEdge) || \
                             ((IT) == FSMC_IT_Level) || \
                             ((IT) == FSMC_IT_FallingEdge)) 
+/**
+  * @}
+  */
 
-/* FSMC Flags ----------------------------------------------------------------*/
-#define FSMC_FLAG_RisingEdge                            ((u32)0x00000001)
-#define FSMC_FLAG_Level                                 ((u32)0x00000002)
-#define FSMC_FLAG_FallingEdge                           ((u32)0x00000004)
-#define FSMC_FLAG_FEMPT                                 ((u32)0x00000040)
+/** @defgroup FSMC_Flags 
+  * @{
+  */
 
+#define FSMC_FLAG_RisingEdge                            ((uint32_t)0x00000001)
+#define FSMC_FLAG_Level                                 ((uint32_t)0x00000002)
+#define FSMC_FLAG_FallingEdge                           ((uint32_t)0x00000004)
+#define FSMC_FLAG_FEMPT                                 ((uint32_t)0x00000040)
 #define IS_FSMC_GET_FLAG(FLAG) (((FLAG) == FSMC_FLAG_RisingEdge) || \
                                 ((FLAG) == FSMC_FLAG_Level) || \
                                 ((FLAG) == FSMC_FLAG_FallingEdge) || \
                                 ((FLAG) == FSMC_FLAG_FEMPT))
 
-#define IS_FSMC_CLEAR_FLAG(FLAG) ((((FLAG) &amp; (u32)0xFFFFFFF8) == 0x00000000) &amp;&amp; ((FLAG) != 0x00000000))                                                                                                                                                                                                                                                                                                                                  
-/* Exported macro ------------------------------------------------------------*/
-/* Exported functions ------------------------------------------------------- */
-void FSMC_NORSRAMDeInit(u32 FSMC_Bank);
-void FSMC_NANDDeInit(u32 FSMC_Bank);
+#define IS_FSMC_CLEAR_FLAG(FLAG) ((((FLAG) &amp; (uint32_t)0xFFFFFFF8) == 0x00000000) &amp;&amp; ((FLAG) != 0x00000000))
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_Exported_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_Exported_Functions
+  * @{
+  */
+
+void FSMC_NORSRAMDeInit(uint32_t FSMC_Bank);
+void FSMC_NANDDeInit(uint32_t FSMC_Bank);
 void FSMC_PCCARDDeInit(void);
 void FSMC_NORSRAMInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct);
 void FSMC_NANDInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct);
@@ -329,17 +685,32 @@
 void FSMC_NORSRAMStructInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct);
 void FSMC_NANDStructInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct);
 void FSMC_PCCARDStructInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct);
-void FSMC_NORSRAMCmd(u32 FSMC_Bank, FunctionalState NewState);
-void FSMC_NANDCmd(u32 FSMC_Bank, FunctionalState NewState);
+void FSMC_NORSRAMCmd(uint32_t FSMC_Bank, FunctionalState NewState);
+void FSMC_NANDCmd(uint32_t FSMC_Bank, FunctionalState NewState);
 void FSMC_PCCARDCmd(FunctionalState NewState);
-void FSMC_NANDECCCmd(u32 FSMC_Bank, FunctionalState NewState);
-u32 FSMC_GetECC(u32 FSMC_Bank);
-void FSMC_ITConfig(u32 FSMC_Bank, u32 FSMC_IT, FunctionalState NewState);
-FlagStatus FSMC_GetFlagStatus(u32 FSMC_Bank, u32 FSMC_FLAG);
-void FSMC_ClearFlag(u32 FSMC_Bank, u32 FSMC_FLAG);
-ITStatus FSMC_GetITStatus(u32 FSMC_Bank, u32 FSMC_IT);
-void FSMC_ClearITPendingBit(u32 FSMC_Bank, u32 FSMC_IT);
+void FSMC_NANDECCCmd(uint32_t FSMC_Bank, FunctionalState NewState);
+uint32_t FSMC_GetECC(uint32_t FSMC_Bank);
+void FSMC_ITConfig(uint32_t FSMC_Bank, uint32_t FSMC_IT, FunctionalState NewState);
+FlagStatus FSMC_GetFlagStatus(uint32_t FSMC_Bank, uint32_t FSMC_FLAG);
+void FSMC_ClearFlag(uint32_t FSMC_Bank, uint32_t FSMC_FLAG);
+ITStatus FSMC_GetITStatus(uint32_t FSMC_Bank, uint32_t FSMC_IT);
+void FSMC_ClearITPendingBit(uint32_t FSMC_Bank, uint32_t FSMC_IT);
 
+#ifdef __cplusplus
+}
+#endif
+
 #endif /*__STM32F10x_FSMC_H */
+/**
+  * @}
+  */
 
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */ 
+
+/******************* (C) COPYRIGHT 2009 STMicroelectronics *****END OF FILE****/

Modified: trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_gpio.h
===================================================================
--- trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_gpio.h	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_gpio.h	2009-07-08 23:39:34 UTC (rev 354)
@@ -1,47 +1,72 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_gpio.h
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file contains all the functions prototypes for the
-*                      GPIO firmware library.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
+/**
+  ******************************************************************************
+  * @file    stm32f10x_gpio.h
+  * @author  MCD Application Team
+  * @version V3.1.0
+  * @date    06/19/2009
+  * @brief   This file contains all the functions prototypes for the GPIO 
+  *          firmware library.
+  ******************************************************************************
+  * @copy
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * &lt;h2&gt;&lt;center&gt;&copy; COPYRIGHT 2009 STMicroelectronics&lt;/center&gt;&lt;/h2&gt;
+  */ 
 
 /* Define to prevent recursive inclusion -------------------------------------*/
 #ifndef __STM32F10x_GPIO_H
 #define __STM32F10x_GPIO_H
 
+#ifdef __cplusplus
+ extern &quot;C&quot; {
+#endif
+
 /* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_map.h&quot;
+#include &quot;stm32f10x.h&quot;
 
-/* Exported types ------------------------------------------------------------*/
-#define IS_GPIO_ALL_PERIPH(PERIPH) (((*(u32*)&amp;(PERIPH)) == GPIOA_BASE) || \
-                                    ((*(u32*)&amp;(PERIPH)) == GPIOB_BASE) || \
-                                    ((*(u32*)&amp;(PERIPH)) == GPIOC_BASE) || \
-                                    ((*(u32*)&amp;(PERIPH)) == GPIOD_BASE) || \
-                                    ((*(u32*)&amp;(PERIPH)) == GPIOE_BASE) || \
-                                    ((*(u32*)&amp;(PERIPH)) == GPIOF_BASE) || \
-                                    ((*(u32*)&amp;(PERIPH)) == GPIOG_BASE))
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @addtogroup GPIO
+  * @{
+  */
+
+/** @defgroup GPIO_Exported_Types
+  * @{
+  */
+
+#define IS_GPIO_ALL_PERIPH(PERIPH) (((PERIPH) == GPIOA) || \
+                                    ((PERIPH) == GPIOB) || \
+                                    ((PERIPH) == GPIOC) || \
+                                    ((PERIPH) == GPIOD) || \
+                                    ((PERIPH) == GPIOE) || \
+                                    ((PERIPH) == GPIOF) || \
+                                    ((PERIPH) == GPIOG))
                                      
-/* Output Maximum frequency selection ----------------------------------------*/
+/** 
+  * @brief  Output Maximum frequency selection  
+  */
+
 typedef enum
 { 
   GPIO_Speed_10MHz = 1,
   GPIO_Speed_2MHz, 
   GPIO_Speed_50MHz
 }GPIOSpeed_TypeDef;
-
 #define IS_GPIO_SPEED(SPEED) (((SPEED) == GPIO_Speed_10MHz) || ((SPEED) == GPIO_Speed_2MHz) || \
                               ((SPEED) == GPIO_Speed_50MHz))
-                                         
-/* Configuration Mode enumeration --------------------------------------------*/
+
+/** 
+  * @brief  Configuration Mode enumeration  
+  */
+
 typedef enum
 { GPIO_Mode_AIN = 0x0,
   GPIO_Mode_IN_FLOATING = 0x04,
@@ -57,44 +82,67 @@
                             ((MODE) == GPIO_Mode_IPD) || ((MODE) == GPIO_Mode_IPU) || \
                             ((MODE) == GPIO_Mode_Out_OD) || ((MODE) == GPIO_Mode_Out_PP) || \
                             ((MODE) == GPIO_Mode_AF_OD) || ((MODE) == GPIO_Mode_AF_PP))
-                              
-/* GPIO Init structure definition */
+
+/** 
+  * @brief  GPIO Init structure definition  
+  */
+
 typedef struct
 {
-  u16 GPIO_Pin;
-  GPIOSpeed_TypeDef GPIO_Speed;
-  GPIOMode_TypeDef GPIO_Mode;
+  uint16_t GPIO_Pin;             /*!&lt; Specifies the GPIO pins to be configured.
+                                      This parameter can be any value of @ref GPIO_pins_define */
+
+  GPIOSpeed_TypeDef GPIO_Speed;  /*!&lt; Specifies the speed for the selected pins.
+                                      This parameter can be a value of @ref GPIOSpeed_TypeDef */
+
+  GPIOMode_TypeDef GPIO_Mode;    /*!&lt; Specifies the operating mode for the selected pins.
+                                      This parameter can be a value of @ref GPIOMode_TypeDef */
 }GPIO_InitTypeDef;
 
-/* Bit_SET and Bit_RESET enumeration -----------------------------------------*/
+
+/** 
+  * @brief  Bit_SET and Bit_RESET enumeration  
+  */
+
 typedef enum
 { Bit_RESET = 0,
   Bit_SET
 }BitAction;
+
 #define IS_GPIO_BIT_ACTION(ACTION) (((ACTION) == Bit_RESET) || ((ACTION) == Bit_SET))
 
-/* Exported constants --------------------------------------------------------*/
-/* GPIO pins define ----------------------------------------------------------*/
-#define GPIO_Pin_0                 ((u16)0x0001)  /* Pin 0 selected */
-#define GPIO_Pin_1                 ((u16)0x0002)  /* Pin 1 selected */
-#define GPIO_Pin_2                 ((u16)0x0004)  /* Pin 2 selected */
-#define GPIO_Pin_3                 ((u16)0x0008)  /* Pin 3 selected */
-#define GPIO_Pin_4                 ((u16)0x0010)  /* Pin 4 selected */
-#define GPIO_Pin_5                 ((u16)0x0020)  /* Pin 5 selected */
-#define GPIO_Pin_6                 ((u16)0x0040)  /* Pin 6 selected */
-#define GPIO_Pin_7                 ((u16)0x0080)  /* Pin 7 selected */
-#define GPIO_Pin_8                 ((u16)0x0100)  /* Pin 8 selected */
-#define GPIO_Pin_9                 ((u16)0x0200)  /* Pin 9 selected */
-#define GPIO_Pin_10                ((u16)0x0400)  /* Pin 10 selected */
-#define GPIO_Pin_11                ((u16)0x0800)  /* Pin 11 selected */
-#define GPIO_Pin_12                ((u16)0x1000)  /* Pin 12 selected */
-#define GPIO_Pin_13                ((u16)0x2000)  /* Pin 13 selected */
-#define GPIO_Pin_14                ((u16)0x4000)  /* Pin 14 selected */
-#define GPIO_Pin_15                ((u16)0x8000)  /* Pin 15 selected */
-#define GPIO_Pin_All               ((u16)0xFFFF)  /* All pins selected */
+/**
+  * @}
+  */
 
-#define IS_GPIO_PIN(PIN) ((((PIN) &amp; (u16)0x00) == 0x00) &amp;&amp; ((PIN) != (u16)0x00))
+/** @defgroup GPIO_Exported_Constants
+  * @{
+  */
 
+/** @defgroup GPIO_pins_define 
+  * @{
+  */
+
+#define GPIO_Pin_0                 ((uint16_t)0x0001)  /*!&lt; Pin 0 selected */
+#define GPIO_Pin_1                 ((uint16_t)0x0002)  /*!&lt; Pin 1 selected */
+#define GPIO_Pin_2                 ((uint16_t)0x0004)  /*!&lt; Pin 2 selected */
+#define GPIO_Pin_3                 ((uint16_t)0x0008)  /*!&lt; Pin 3 selected */
+#define GPIO_Pin_4                 ((uint16_t)0x0010)  /*!&lt; Pin 4 selected */
+#define GPIO_Pin_5                 ((uint16_t)0x0020)  /*!&lt; Pin 5 selected */
+#define GPIO_Pin_6                 ((uint16_t)0x0040)  /*!&lt; Pin 6 selected */
+#define GPIO_Pin_7                 ((uint16_t)0x0080)  /*!&lt; Pin 7 selected */
+#define GPIO_Pin_8                 ((uint16_t)0x0100)  /*!&lt; Pin 8 selected */
+#define GPIO_Pin_9                 ((uint16_t)0x0200)  /*!&lt; Pin 9 selected */
+#define GPIO_Pin_10                ((uint16_t)0x0400)  /*!&lt; Pin 10 selected */
+#define GPIO_Pin_11                ((uint16_t)0x0800)  /*!&lt; Pin 11 selected */
+#define GPIO_Pin_12                ((uint16_t)0x1000)  /*!&lt; Pin 12 selected */
+#define GPIO_Pin_13                ((uint16_t)0x2000)  /*!&lt; Pin 13 selected */
+#define GPIO_Pin_14                ((uint16_t)0x4000)  /*!&lt; Pin 14 selected */
+#define GPIO_Pin_15                ((uint16_t)0x8000)  /*!&lt; Pin 15 selected */
+#define GPIO_Pin_All               ((uint16_t)0xFFFF)  /*!&lt; All pins selected */
+
+#define IS_GPIO_PIN(PIN) ((((PIN) &amp; (uint16_t)0x00) == 0x00) &amp;&amp; ((PIN) != (uint16_t)0x00))
+
 #define IS_GET_GPIO_PIN(PIN) (((PIN) == GPIO_Pin_0) || \
                               ((PIN) == GPIO_Pin_1) || \
                               ((PIN) == GPIO_Pin_2) || \
@@ -111,35 +159,48 @@
                               ((PIN) == GPIO_Pin_13) || \
                               ((PIN) == GPIO_Pin_14) || \
                               ((PIN) == GPIO_Pin_15))
-                            
-/* GPIO Remap define ---------------------------------------------------------*/
-#define GPIO_Remap_SPI1            ((u32)0x00000001)  /* SPI1 Alternate Function mapping */
-#define GPIO_Remap_I2C1            ((u32)0x00000002)  /* I2C1 Alternate Function mapping */
-#define GPIO_Remap_USART1          ((u32)0x00000004)  /* USART1 Alternate Function mapping */
-#define GPIO_Remap_USART2          ((u32)0x00000008)  /* USART2 Alternate Function mapping */
-#define GPIO_PartialRemap_USART3   ((u32)0x00140010)  /* USART3 Partial Alternate Function mapping */
-#define GPIO_FullRemap_USART3      ((u32)0x00140030)  /* USART3 Full Alternate Function mapping */
-#define GPIO_PartialRemap_TIM1     ((u32)0x00160040)  /* TIM1 Partial Alternate Function mapping */
-#define GPIO_FullRemap_TIM1        ((u32)0x001600C0)  /* TIM1 Full Alternate Function mapping */
-#define GPIO_PartialRemap1_TIM2    ((u32)0x00180100)  /* TIM2 Partial1 Alternate Function mapping */
-#define GPIO_PartialRemap2_TIM2    ((u32)0x00180200)  /* TIM2 Partial2 Alternate Function mapping */
-#define GPIO_FullRemap_TIM2        ((u32)0x00180300)  /* TIM2 Full Alternate Function mapping */
-#define GPIO_PartialRemap_TIM3     ((u32)0x001A0800)  /* TIM3 Partial Alternate Function mapping */
-#define GPIO_FullRemap_TIM3        ((u32)0x001A0C00)  /* TIM3 Full Alternate Function mapping */
-#define GPIO_Remap_TIM4            ((u32)0x00001000)  /* TIM4 Alternate Function mapping */
-#define GPIO_Remap1_CAN            ((u32)0x001D4000)  /* CAN Alternate Function mapping */
-#define GPIO_Remap2_CAN            ((u32)0x001D6000)  /* CAN Alternate Function mapping */
-#define GPIO_Remap_PD01            ((u32)0x00008000)  /* PD01 Alternate Function mapping */
-#define GPIO_Remap_TIM5CH4_LSI     ((u32)0x00200001)  /* LSI connected to TIM5 Channel4 input capture for calibration */
-#define GPIO_Remap_ADC1_ETRGINJ    ((u32)0x00200002)  /* ADC1 External Trigger Injected Conversion remapping */
-#define GPIO_Remap_ADC1_ETRGREG    ((u32)0x00200004)  /* ADC1 External Trigger Regular Conversion remapping */
-#define GPIO_Remap_ADC2_ETRGINJ    ((u32)0x00200008)  /* ADC2 External Trigger Injected Conversion remapping */
-#define GPIO_Remap_ADC2_ETRGREG    ((u32)0x00200010)  /* ADC2 External Trigger Regular Conversion remapping */
-#define GPIO_Remap_SWJ_NoJTRST     ((u32)0x00300100)  /* Full SWJ Enabled (JTAG-DP + SW-DP) but without JTRST */
-#define GPIO_Remap_SWJ_JTAGDisable ((u32)0x00300200)  /* JTAG-DP Disabled and SW-DP Enabled */
-#define GPIO_Remap_SWJ_Disable     ((u32)0x00300400)  /* Full SWJ Disabled (JTAG-DP + SW-DP) */
 
+/**
+  * @}
+  */
 
+/** @defgroup GPIO_Remap_define 
+  * @{
+  */
+
+#define GPIO_Remap_SPI1             ((uint32_t)0x00000001)  /*!&lt; SPI1 Alternate Function mapping */
+#define GPIO_Remap_I2C1             ((uint32_t)0x00000002)  /*!&lt; I2C1 Alternate Function mapping */
+#define GPIO_Remap_USART1           ((uint32_t)0x00000004)  /*!&lt; USART1 Alternate Function mapping */
+#define GPIO_Remap_USART2           ((uint32_t)0x00000008)  /*!&lt; USART2 Alternate Function mapping */
+#define GPIO_PartialRemap_USART3    ((uint32_t)0x00140010)  /*!&lt; USART3 Partial Alternate Function mapping */
+#define GPIO_FullRemap_USART3       ((uint32_t)0x00140030)  /*!&lt; USART3 Full Alternate Function mapping */
+#define GPIO_PartialRemap_TIM1      ((uint32_t)0x00160040)  /*!&lt; TIM1 Partial Alternate Function mapping */
+#define GPIO_FullRemap_TIM1         ((uint32_t)0x001600C0)  /*!&lt; TIM1 Full Alternate Function mapping */
+#define GPIO_PartialRemap1_TIM2     ((uint32_t)0x00180100)  /*!&lt; TIM2 Partial1 Alternate Function mapping */
+#define GPIO_PartialRemap2_TIM2     ((uint32_t)0x00180200)  /*!&lt; TIM2 Partial2 Alternate Function mapping */
+#define GPIO_FullRemap_TIM2         ((uint32_t)0x00180300)  /*!&lt; TIM2 Full Alternate Function mapping */
+#define GPIO_PartialRemap_TIM3      ((uint32_t)0x001A0800)  /*!&lt; TIM3 Partial Alternate Function mapping */
+#define GPIO_FullRemap_TIM3         ((uint32_t)0x001A0C00)  /*!&lt; TIM3 Full Alternate Function mapping */
+#define GPIO_Remap_TIM4             ((uint32_t)0x00001000)  /*!&lt; TIM4 Alternate Function mapping */
+#define GPIO_Remap1_CAN1            ((uint32_t)0x001D4000)  /*!&lt; CAN1 Alternate Function mapping */
+#define GPIO_Remap2_CAN1            ((uint32_t)0x001D6000)  /*!&lt; CAN1 Alternate Function mapping */
+#define GPIO_Remap_PD01             ((uint32_t)0x00008000)  /*!&lt; PD01 Alternate Function mapping */
+#define GPIO_Remap_TIM5CH4_LSI      ((uint32_t)0x00200001)  /*!&lt; LSI connected to TIM5 Channel4 input capture for calibration */
+#define GPIO_Remap_ADC1_ETRGINJ     ((uint32_t)0x00200002)  /*!&lt; ADC1 External Trigger Injected Conversion remapping */
+#define GPIO_Remap_ADC1_ETRGREG     ((uint32_t)0x00200004)  /*!&lt; ADC1 External Trigger Regular Conversion remapping */
+#define GPIO_Remap_ADC2_ETRGINJ     ((uint32_t)0x00200008)  /*!&lt; ADC2 External Trigger Injected Conversion remapping */
+#define GPIO_Remap_ADC2_ETRGREG     ((uint32_t)0x00200010)  /*!&lt; ADC2 External Trigger Regular Conversion remapping */
+#define GPIO_Remap_ETH              ((uint32_t)0x00200020)  /*!&lt; Ethernet remapping (only for Connectivity line devices) */
+#define GPIO_Remap_CAN2             ((uint32_t)0x00200040)  /*!&lt; CAN2 remapping (only for Connectivity line devices) */
+#define GPIO_Remap_SWJ_NoJTRST      ((uint32_t)0x00300100)  /*!&lt; Full SWJ Enabled (JTAG-DP + SW-DP) but without JTRST */
+#define GPIO_Remap_SWJ_JTAGDisable  ((uint32_t)0x00300200)  /*!&lt; JTAG-DP Disabled and SW-DP Enabled */
+#define GPIO_Remap_SWJ_Disable      ((uint32_t)0x00300400)  /*!&lt; Full SWJ Disabled (JTAG-DP + SW-DP) */
+#define GPIO_Remap_SPI3             ((uint32_t)0x00201000)  /*!&lt; SPI3 Alternate Function mapping (only for Connectivity line devices) */
+#define GPIO_Remap_TIM2ITR1_PTP_SOF ((uint32_t)0x00202000)  /*!&lt; Ethernet PTP output or USB OTG SOF (Start of Frame) connected
+                                                                 to TIM2 Internal Trigger 1 for calibration
+                                                                 (only for Connectivity line devices) */
+#define GPIO_Remap_PTP_PPS          ((uint32_t)0x00204000)  /*!&lt; Ethernet MAC PPS_PTS output on PB05 (only for Connectivity line devices) */                                                       
+
 #define IS_GPIO_REMAP(REMAP) (((REMAP) == GPIO_Remap_SPI1) || ((REMAP) == GPIO_Remap_I2C1) || \
                               ((REMAP) == GPIO_Remap_USART1) || ((REMAP) == GPIO_Remap_USART2) || \
                               ((REMAP) == GPIO_PartialRemap_USART3) || ((REMAP) == GPIO_FullRemap_USART3) || \
@@ -147,28 +208,36 @@
                               ((REMAP) == GPIO_PartialRemap1_TIM2) || ((REMAP) == GPIO_PartialRemap2_TIM2) || \
                               ((REMAP) == GPIO_FullRemap_TIM2) || ((REMAP) == GPIO_PartialRemap_TIM3) || \
                               ((REMAP) == GPIO_FullRemap_TIM3) || ((REMAP) == GPIO_Remap_TIM4) || \
-                              ((REMAP) == GPIO_Remap1_CAN) || ((REMAP) == GPIO_Remap2_CAN) || \
+                              ((REMAP) == GPIO_Remap1_CAN1) || ((REMAP) == GPIO_Remap2_CAN1) || \
                               ((REMAP) == GPIO_Remap_PD01) || ((REMAP) == GPIO_Remap_TIM5CH4_LSI) || \
                               ((REMAP) == GPIO_Remap_ADC1_ETRGINJ) ||((REMAP) == GPIO_Remap_ADC1_ETRGREG) || \
                               ((REMAP) == GPIO_Remap_ADC2_ETRGINJ) ||((REMAP) == GPIO_Remap_ADC2_ETRGREG) || \
-                              ((REMAP) == GPIO_Remap_SWJ_NoJTRST) || ((REMAP) == GPIO_Remap_SWJ_JTAGDisable)|| \
-                              ((REMAP) == GPIO_Remap_SWJ_Disable))
+                              ((REMAP) == GPIO_Remap_ETH) ||((REMAP) == GPIO_Remap_CAN2) || \
+                              ((REMAP) == GPIO_Remap_SWJ_NoJTRST) || ((REMAP) == GPIO_Remap_SWJ_JTAGDisable) || \
+                              ((REMAP) == GPIO_Remap_SWJ_Disable)|| ((REMAP) == GPIO_Remap_SPI3) || \
+                              ((REMAP) == GPIO_Remap_TIM2ITR1_PTP_SOF) || ((REMAP) == GPIO_Remap_PTP_PPS))
                               
-/* GPIO Port Sources ---------------------------------------------------------*/
-#define GPIO_PortSourceGPIOA       ((u8)0x00)
-#define GPIO_PortSourceGPIOB       ((u8)0x01)
-#define GPIO_PortSourceGPIOC       ((u8)0x02)
-#define GPIO_PortSourceGPIOD       ((u8)0x03)
-#define GPIO_PortSourceGPIOE       ((u8)0x04)
-#define GPIO_PortSourceGPIOF       ((u8)0x05)
-#define GPIO_PortSourceGPIOG       ((u8)0x06)
+/**
+  * @}
+  */ 
 
+/** @defgroup GPIO_Port_Sources 
+  * @{
+  */
+
+#define GPIO_PortSourceGPIOA       ((uint8_t)0x00)
+#define GPIO_PortSourceGPIOB       ((uint8_t)0x01)
+#define GPIO_PortSourceGPIOC       ((uint8_t)0x02)
+#define GPIO_PortSourceGPIOD       ((uint8_t)0x03)
+#define GPIO_PortSourceGPIOE       ((uint8_t)0x04)
+#define GPIO_PortSourceGPIOF       ((uint8_t)0x05)
+#define GPIO_PortSourceGPIOG       ((uint8_t)0x06)
 #define IS_GPIO_EVENTOUT_PORT_SOURCE(PORTSOURCE) (((PORTSOURCE) == GPIO_PortSourceGPIOA) || \
                                                   ((PORTSOURCE) == GPIO_PortSourceGPIOB) || \
                                                   ((PORTSOURCE) == GPIO_PortSourceGPIOC) || \
                                                   ((PORTSOURCE) == GPIO_PortSourceGPIOD) || \
                                                   ((PORTSOURCE) == GPIO_PortSourceGPIOE))
-                                         
+
 #define IS_GPIO_EXTI_PORT_SOURCE(PORTSOURCE) (((PORTSOURCE) == GPIO_PortSourceGPIOA) || \
                                               ((PORTSOURCE) == GPIO_PortSourceGPIOB) || \
                                               ((PORTSOURCE) == GPIO_PortSourceGPIOC) || \
@@ -176,25 +245,32 @@
                                               ((PORTSOURCE) == GPIO_PortSourceGPIOE) || \
                                               ((PORTSOURCE) == GPIO_PortSourceGPIOF) || \
                                               ((PORTSOURCE) == GPIO_PortSourceGPIOG))
-                                       
-/* GPIO Pin sources ----------------------------------------------------------*/
-#define GPIO_PinSource0            ((u8)0x00)
-#define GPIO_PinSource1            ((u8)0x01)
-#define GPIO_PinSource2            ((u8)0x02)
-#define GPIO_PinSource3            ((u8)0x03)
-#define GPIO_PinSource4            ((u8)0x04)
-#define GPIO_PinSource5            ((u8)0x05)
-#define GPIO_PinSource6            ((u8)0x06)
-#define GPIO_PinSource7            ((u8)0x07)
-#define GPIO_PinSource8            ((u8)0x08)
-#define GPIO_PinSource9            ((u8)0x09)
-#define GPIO_PinSource10           ((u8)0x0A)
-#define GPIO_PinSource11           ((u8)0x0B)
-#define GPIO_PinSource12           ((u8)0x0C)
-#define GPIO_PinSource13           ((u8)0x0D)
-#define GPIO_PinSource14           ((u8)0x0E)
-#define GPIO_PinSource15           ((u8)0x0F)
 
+/**
+  * @}
+  */
+
+/** @defgroup GPIO_Pin_sources 
+  * @{
+  */
+
+#define GPIO_PinSource0            ((uint8_t)0x00)
+#define GPIO_PinSource1            ((uint8_t)0x01)
+#define GPIO_PinSource2            ((uint8_t)0x02)
+#define GPIO_PinSource3            ((uint8_t)0x03)
+#define GPIO_PinSource4            ((uint8_t)0x04)
+#define GPIO_PinSource5            ((uint8_t)0x05)
+#define GPIO_PinSource6            ((uint8_t)0x06)
+#define GPIO_PinSource7            ((uint8_t)0x07)
+#define GPIO_PinSource8            ((uint8_t)0x08)
+#define GPIO_PinSource9            ((uint8_t)0x09)
+#define GPIO_PinSource10           ((uint8_t)0x0A)
+#define GPIO_PinSource11           ((uint8_t)0x0B)
+#define GPIO_PinSource12           ((uint8_t)0x0C)
+#define GPIO_PinSource13           ((uint8_t)0x0D)
+#define GPIO_PinSource14           ((uint8_t)0x0E)
+#define GPIO_PinSource15           ((uint8_t)0x0F)
+
 #define IS_GPIO_PIN_SOURCE(PINSOURCE) (((PINSOURCE) == GPIO_PinSource0) || \
                                        ((PINSOURCE) == GPIO_PinSource1) || \
                                        ((PINSOURCE) == GPIO_PinSource2) || \
@@ -211,27 +287,73 @@
                                        ((PINSOURCE) == GPIO_PinSource13) || \
                                        ((PINSOURCE) == GPIO_PinSource14) || \
                                        ((PINSOURCE) == GPIO_PinSource15))
-                          
-/* Exported macro ------------------------------------------------------------*/
-/* Exported functions ------------------------------------------------------- */
+
+/**
+  * @}
+  */
+
+/** @defgroup Ethernet_Media_Interface 
+  * @{
+  */ 
+#define GPIO_ETH_MediaInterface_MII    ((u32)0x00000000) 
+#define GPIO_ETH_MediaInterface_RMII   ((u32)0x00000001)                                       
+
+#define IS_GPIO_ETH_MEDIA_INTERFACE(INTERFACE) (((INTERFACE) == GPIO_ETH_MediaInterface_MII) || \
+                                                ((INTERFACE) == GPIO_ETH_MediaInterface_RMII))
+
+/**
+  * @}
+  */                                                
+/**
+  * @}
+  */
+
+/** @defgroup GPIO_Exported_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup GPIO_Exported_Functions
+  * @{
+  */
+
 void GPIO_DeInit(GPIO_TypeDef* GPIOx);
 void GPIO_AFIODeInit(void);
 void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct);
 void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct);
-u8 GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, u16 GPIO_Pin);
-u16 GPIO_ReadInputData(GPIO_TypeDef* GPIOx);
-u8 GPIO_ReadOutputDataBit(GPIO_TypeDef* GPIOx, u16 GPIO_Pin);
-u16 GPIO_ReadOutputData(GPIO_TypeDef* GPIOx);
-void GPIO_SetBits(GPIO_TypeDef* GPIOx, u16 GPIO_Pin);
-void GPIO_ResetBits(GPIO_TypeDef* GPIOx, u16 GPIO_Pin);
-void GPIO_WriteBit(GPIO_TypeDef* GPIOx, u16 GPIO_Pin, BitAction BitVal);
-void GPIO_Write(GPIO_TypeDef* GPIOx, u16 PortVal);
-void GPIO_PinLockConfig(GPIO_TypeDef* GPIOx, u16 GPIO_Pin);
-void GPIO_EventOutputConfig(u8 GPIO_PortSource, u8 GPIO_PinSource);
+uint8_t GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
+uint16_t GPIO_ReadInputData(GPIO_TypeDef* GPIOx);
+uint8_t GPIO_ReadOutputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
+uint16_t GPIO_ReadOutputData(GPIO_TypeDef* GPIOx);
+void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
+void GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
+void GPIO_WriteBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, BitAction BitVal);
+void GPIO_Write(GPIO_TypeDef* GPIOx, uint16_t PortVal);
+void GPIO_PinLockConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
+void GPIO_EventOutputConfig(uint8_t GPIO_PortSource, uint8_t GPIO_PinSource);
 void GPIO_EventOutputCmd(FunctionalState NewState);
-void GPIO_PinRemapConfig(u32 GPIO_Remap, FunctionalState NewState);
-void GPIO_EXTILineConfig(u8 GPIO_PortSource, u8 GPIO_PinSource);
+void GPIO_PinRemapConfig(uint32_t GPIO_Remap, FunctionalState NewState);
+void GPIO_EXTILineConfig(uint8_t GPIO_PortSource, uint8_t GPIO_PinSource);
+void GPIO_ETH_MediaInterfaceConfig(uint32_t GPIO_ETH_MediaInterface);
 
+#ifdef __cplusplus
+}
+#endif
+
 #endif /* __STM32F10x_GPIO_H */
+/**
+  * @}
+  */
 
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2009 STMicroelectronics *****END OF FILE****/

Modified: trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_i2c.h
===================================================================
--- trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_i2c.h	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_i2c.h	2009-07-08 23:39:34 UTC (rev 354)
@@ -1,89 +1,158 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_i2c.h
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file contains all the functions prototypes for the
-*                      I2C firmware library.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
+/**
+  ******************************************************************************
+  * @file    stm32f10x_i2c.h
+  * @author  MCD Application Team
+  * @version V3.1.0
+  * @date    06/19/2009
+  * @brief   This file contains all the functions prototypes for the I2C firmware 
+  *          library.
+  ******************************************************************************
+  * @copy
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * &lt;h2&gt;&lt;center&gt;&copy; COPYRIGHT 2009 STMicroelectronics&lt;/center&gt;&lt;/h2&gt;
+  */ 
 
 /* Define to prevent recursive inclusion -------------------------------------*/
-#ifndef __STM32F10x_I2C_H    
+#ifndef __STM32F10x_I2C_H
 #define __STM32F10x_I2C_H
 
+#ifdef __cplusplus
+ extern &quot;C&quot; {
+#endif
+
 /* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_map.h&quot;
+#include &quot;stm32f10x.h&quot;
 
-/* Exported types ------------------------------------------------------------*/
-/* I2C Init structure definition */
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @addtogroup I2C
+  * @{
+  */
+
+/** @defgroup I2C_Exported_Types
+  * @{
+  */
+
+/** 
+  * @brief  I2C Init structure definition  
+  */
+
 typedef struct
 {
-  u16 I2C_Mode;
-  u16 I2C_DutyCycle;
-  u16 I2C_OwnAddress1;
-  u16 I2C_Ack;
-  u16 I2C_AcknowledgedAddress;
-  u32 I2C_ClockSpeed;
+  uint32_t I2C_ClockSpeed;          /*!&lt; Specifies the clock frequency.
+                                         This parameter must be set to a value lower than 400kHz */
+
+  uint16_t I2C_Mode;                /*!&lt; Specifies the I2C mode.
+                                         This parameter can be a value of @ref I2C_mode */
+
+  uint16_t I2C_DutyCycle;           /*!&lt; Specifies the I2C fast mode duty cycle.
+                                         This parameter can be a value of @ref I2C_duty_cycle_in_fast_mode */
+
+  uint16_t I2C_OwnAddress1;         /*!&lt; Specifies the first device own address.
+                                         This parameter can be a 7-bit or 10-bit address. */
+
+  uint16_t I2C_Ack;                 /*!&lt; Enables or disables the acknowledgement.
+                                         This parameter can be a value of @ref I2C_acknowledgement */
+
+  uint16_t I2C_AcknowledgedAddress; /*!&lt; Specifies if 7-bit or 10-bit address is acknowledged.
+                                         This parameter can be a value of @ref I2C_acknowledged_address */
 }I2C_InitTypeDef;
 
-/* Exported constants --------------------------------------------------------*/
-#define IS_I2C_ALL_PERIPH(PERIPH) (((*(u32*)&amp;(PERIPH)) == I2C1_BASE) || \
-                                   ((*(u32*)&amp;(PERIPH)) == I2C2_BASE))
+/**
+  * @}
+  */ 
 
-/* I2C modes */
-#define I2C_Mode_I2C                    ((u16)0x0000)
-#define I2C_Mode_SMBusDevice            ((u16)0x0002)
-#define I2C_Mode_SMBusHost              ((u16)0x000A)
 
+/** @defgroup I2C_Exported_Constants
+  * @{
+  */
+
+#define IS_I2C_ALL_PERIPH(PERIPH) (((PERIPH) == I2C1) || \
+                                   ((PERIPH) == I2C2))
+/** @defgroup I2C_mode 
+  * @{
+  */
+
+#define I2C_Mode_I2C                    ((uint16_t)0x0000)
+#define I2C_Mode_SMBusDevice            ((uint16_t)0x0002)  
+#define I2C_Mode_SMBusHost              ((uint16_t)0x000A)
 #define IS_I2C_MODE(MODE) (((MODE) == I2C_Mode_I2C) || \
                            ((MODE) == I2C_Mode_SMBusDevice) || \
                            ((MODE) == I2C_Mode_SMBusHost))
-/* I2C duty cycle in fast mode */
-#define I2C_DutyCycle_16_9              ((u16)0x4000)
-#define I2C_DutyCycle_2                 ((u16)0xBFFF)
+/**
+  * @}
+  */
 
+/** @defgroup I2C_duty_cycle_in_fast_mode 
+  * @{
+  */
+
+#define I2C_DutyCycle_16_9              ((uint16_t)0x4000) /*!&lt; I2C fast mode Tlow/Thigh = 16/9 */
+#define I2C_DutyCycle_2                 ((uint16_t)0xBFFF) /*!&lt; I2C fast mode Tlow/Thigh = 2 */
 #define IS_I2C_DUTY_CYCLE(CYCLE) (((CYCLE) == I2C_DutyCycle_16_9) || \
                                   ((CYCLE) == I2C_DutyCycle_2))
+/**
+  * @}
+  */ 
 
-/* I2C cknowledgementy */
-#define I2C_Ack_Enable                  ((u16)0x0400)
-#define I2C_Ack_Disable                 ((u16)0x0000)
+/** @defgroup I2C_acknowledgement
+  * @{
+  */
 
+#define I2C_Ack_Enable                  ((uint16_t)0x0400)
+#define I2C_Ack_Disable                 ((uint16_t)0x0000)
 #define IS_I2C_ACK_STATE(STATE) (((STATE) == I2C_Ack_Enable) || \
                                  ((STATE) == I2C_Ack_Disable))
+/**
+  * @}
+  */
 
-/* I2C transfer direction */
-#define  I2C_Direction_Transmitter      ((u8)0x00)
-#define  I2C_Direction_Receiver         ((u8)0x01)
+/** @defgroup I2C_transfer_direction 
+  * @{
+  */
 
+#define  I2C_Direction_Transmitter      ((uint8_t)0x00)
+#define  I2C_Direction_Receiver         ((uint8_t)0x01)
 #define IS_I2C_DIRECTION(DIRECTION) (((DIRECTION) == I2C_Direction_Transmitter) || \
                                      ((DIRECTION) == I2C_Direction_Receiver))
+/**
+  * @}
+  */
 
-/* I2C acknowledged address defines */
-#define I2C_AcknowledgedAddress_7bit    ((u16)0x4000)
-#define I2C_AcknowledgedAddress_10bit   ((u16)0xC000)
+/** @defgroup I2C_acknowledged_address 
+  * @{
+  */
 
+#define I2C_AcknowledgedAddress_7bit    ((uint16_t)0x4000)
+#define I2C_AcknowledgedAddress_10bit   ((uint16_t)0xC000)
 #define IS_I2C_ACKNOWLEDGE_ADDRESS(ADDRESS) (((ADDRESS) == I2C_AcknowledgedAddress_7bit) || \
                                              ((ADDRESS) == I2C_AcknowledgedAddress_10bit))
+/**
+  * @}
+  */ 
 
-/* I2C registers */
-#define I2C_Register_CR1                ((u8)0x00)
-#define I2C_Register_CR2                ((u8)0x04)
-#define I2C_Register_OAR1               ((u8)0x08)
-#define I2C_Register_OAR2               ((u8)0x0C)
-#define I2C_Register_DR                 ((u8)0x10)
-#define I2C_Register_SR1                ((u8)0x14)
-#define I2C_Register_SR2                ((u8)0x18)
-#define I2C_Register_CCR                ((u8)0x1C)
-#define I2C_Register_TRISE              ((u8)0x20)
+/** @defgroup I2C_registers 
+  * @{
+  */
 
+#define I2C_Register_CR1                ((uint8_t)0x00)
+#define I2C_Register_CR2                ((uint8_t)0x04)
+#define I2C_Register_OAR1               ((uint8_t)0x08)
+#define I2C_Register_OAR2               ((uint8_t)0x0C)
+#define I2C_Register_DR                 ((uint8_t)0x10)
+#define I2C_Register_SR1                ((uint8_t)0x14)
+#define I2C_Register_SR2                ((uint8_t)0x18)
+#define I2C_Register_CCR                ((uint8_t)0x1C)
+#define I2C_Register_TRISE              ((uint8_t)0x20)
 #define IS_I2C_REGISTER(REGISTER) (((REGISTER) == I2C_Register_CR1) || \
                                    ((REGISTER) == I2C_Register_CR2) || \
                                    ((REGISTER) == I2C_Register_OAR1) || \
@@ -93,46 +162,67 @@
                                    ((REGISTER) == I2C_Register_SR2) || \
                                    ((REGISTER) == I2C_Register_CCR) || \
                                    ((REGISTER) == I2C_Register_TRISE))
+/**
+  * @}
+  */
 
-/* I2C SMBus alert pin level */
-#define I2C_SMBusAlert_Low              ((u16)0x2000)
-#define I2C_SMBusAlert_High             ((u16)0xDFFF)
+/** @defgroup I2C_SMBus_alert_pin_level 
+  * @{
+  */
 
+#define I2C_SMBusAlert_Low              ((uint16_t)0x2000)
+#define I2C_SMBusAlert_High             ((uint16_t)0xDFFF)
 #define IS_I2C_SMBUS_ALERT(ALERT) (((ALERT) == I2C_SMBusAlert_Low) || \
                                    ((ALERT) == I2C_SMBusAlert_High))
+/**
+  * @}
+  */
 
-/* I2C PEC position */
-#define I2C_PECPosition_Next            ((u16)0x0800)
-#define I2C_PECPosition_Current         ((u16)0xF7FF)
+/** @defgroup I2C_PEC_position 
+  * @{
+  */
 
+#define I2C_PECPosition_Next            ((uint16_t)0x0800)
+#define I2C_PECPosition_Current         ((uint16_t)0xF7FF)
 #define IS_I2C_PEC_POSITION(POSITION) (((POSITION) == I2C_PECPosition_Next) || \
                                        ((POSITION) == I2C_PECPosition_Current))
+/**
+  * @}
+  */ 
 
-/* I2C interrupts definition */
-#define I2C_IT_BUF                      ((u16)0x0400)
-#define I2C_IT_EVT                      ((u16)0x0200)
-#define I2C_IT_ERR                      ((u16)0x0100)
+/** @defgroup I2C_interrupts_definition 
+  * @{
+  */
 
-#define IS_I2C_CONFIG_IT(IT) ((((IT) &amp; (u16)0xF8FF) == 0x00) &amp;&amp; ((IT) != 0x00))
+#define I2C_IT_BUF                      ((uint16_t)0x0400)
+#define I2C_IT_EVT                      ((uint16_t)0x0200)
+#define I2C_IT_ERR                      ((uint16_t)0x0100)
+#define IS_I2C_CONFIG_IT(IT) ((((IT) &amp; (uint16_t)0xF8FF) == 0x00) &amp;&amp; ((IT) != 0x00))
+/**
+  * @}
+  */ 
 
-/* I2C interrupts definition */
-#define I2C_IT_SMBALERT                 ((u32)0x01008000)
-#define I2C_IT_TIMEOUT                  ((u32)0x01004000)
-#define I2C_IT_PECERR                   ((u32)0x01001000)
-#define I2C_IT_OVR                      ((u32)0x01000800)
-#define I2C_IT_AF                       ((u32)0x01000400)
-#define I2C_IT_ARLO                     ((u32)0x01000200)
-#define I2C_IT_BERR                     ((u32)0x01000100)
-#define I2C_IT_TXE                      ((u32)0x06000080)
-#define I2C_IT_RXNE                     ((u32)0x06000040)
-#define I2C_IT_STOPF                    ((u32)0x02000010)
-#define I2C_IT_ADD10                    ((u32)0x02000008)
-#define I2C_IT_BTF                      ((u32)0x02000004)
-#define I2C_IT_ADDR                     ((u32)0x02000002)
-#define I2C_IT_SB                       ((u32)0x02000001)
+/** @defgroup I2C_interrupts_definition 
+  * @{
+  */
 
-#define IS_I2C_CLEAR_IT(IT) ((((IT) &amp; (u16)0x20FF) == 0x00) &amp;&amp; ((IT) != (u16)0x00))                             
+#define I2C_IT_SMBALERT                 ((uint32_t)0x01008000)
+#define I2C_IT_TIMEOUT                  ((uint32_t)0x01004000)
+#define I2C_IT_PECERR                   ((uint32_t)0x01001000)
+#define I2C_IT_OVR                      ((uint32_t)0x01000800)
+#define I2C_IT_AF                       ((uint32_t)0x01000400)
+#define I2C_IT_ARLO                     ((uint32_t)0x01000200)
+#define I2C_IT_BERR                     ((uint32_t)0x01000100)
+#define I2C_IT_TXE                      ((uint32_t)0x06000080)
+#define I2C_IT_RXNE                     ((uint32_t)0x06000040)
+#define I2C_IT_STOPF                    ((uint32_t)0x02000010)
+#define I2C_IT_ADD10                    ((uint32_t)0x02000008)
+#define I2C_IT_BTF                      ((uint32_t)0x02000004)
+#define I2C_IT_ADDR                     ((uint32_t)0x02000002)
+#define I2C_IT_SB                       ((uint32_t)0x02000001)
 
+#define IS_I2C_CLEAR_IT(IT) ((((IT) &amp; (uint16_t)0x20FF) == 0x00) &amp;&amp; ((IT) != (uint16_t)0x00))
+
 #define IS_I2C_GET_IT(IT) (((IT) == I2C_IT_SMBALERT) || ((IT) == I2C_IT_TIMEOUT) || \
                            ((IT) == I2C_IT_PECERR) || ((IT) == I2C_IT_OVR) || \
                            ((IT) == I2C_IT_AF) || ((IT) == I2C_IT_ARLO) || \
@@ -140,34 +230,47 @@
                            ((IT) == I2C_IT_RXNE) || ((IT) == I2C_IT_STOPF) || \
                            ((IT) == I2C_IT_ADD10) || ((IT) == I2C_IT_BTF) || \
                            ((IT) == I2C_IT_ADDR) || ((IT) == I2C_IT_SB))
+/**
+  * @}
+  */
 
-/* I2C flags definition */
-/* SR2 register flags */
-#define I2C_FLAG_DUALF                  ((u32)0x00800000)
-#define I2C_FLAG_SMBHOST                ((u32)0x00400000)
-#define I2C_FLAG_SMBDEFAULT             ((u32)0x00200000)
-#define I2C_FLAG_GENCALL                ((u32)0x00100000)
-#define I2C_FLAG_TRA                    ((u32)0x00040000)
-#define I2C_FLAG_BUSY                   ((u32)0x00020000)
-#define I2C_FLAG_MSL                    ((u32)0x00010000)
-/* SR1 register flags */
-#define I2C_FLAG_SMBALERT               ((u32)0x10008000)
-#define I2C_FLAG_TIMEOUT                ((u32)0x10004000)
-#define I2C_FLAG_PECERR                 ((u32)0x10001000)
-#define I2C_FLAG_OVR                    ((u32)0x10000800)
-#define I2C_FLAG_AF                     ((u32)0x10000400)
-#define I2C_FLAG_ARLO                   ((u32)0x10000200)
-#define I2C_FLAG_BERR                   ((u32)0x10000100)
-#define I2C_FLAG_TXE                    ((u32)0x10000080)
-#define I2C_FLAG_RXNE                   ((u32)0x10000040)
-#define I2C_FLAG_STOPF                  ((u32)0x10000010)
-#define I2C_FLAG_ADD10                  ((u32)0x10000008)
-#define I2C_FLAG_BTF                    ((u32)0x10000004)
-#define I2C_FLAG_ADDR                   ((u32)0x10000002)
-#define I2C_FLAG_SB                     ((u32)0x10000001)
-                               
-#define IS_I2C_CLEAR_FLAG(FLAG) ((((FLAG) &amp; (u16)0x20FF) == 0x00) &amp;&amp; ((FLAG) != (u16)0x00))                                  
+/** @defgroup I2C_flags_definition 
+  * @{
+  */
 
+/** 
+  * @brief  SR2 register flags  
+  */
+
+#define I2C_FLAG_DUALF                  ((uint32_t)0x00800000)
+#define I2C_FLAG_SMBHOST                ((uint32_t)0x00400000)
+#define I2C_FLAG_SMBDEFAULT             ((uint32_t)0x00200000)
+#define I2C_FLAG_GENCALL                ((uint32_t)0x00100000)
+#define I2C_FLAG_TRA                    ((uint32_t)0x00040000)
+#define I2C_FLAG_BUSY                   ((uint32_t)0x00020000)
+#define I2C_FLAG_MSL                    ((uint32_t)0x00010000)
+
+/** 
+  * @brief  SR1 register flags  
+  */
+
+#define I2C_FLAG_SMBALERT               ((uint32_t)0x10008000)
+#define I2C_FLAG_TIMEOUT                ((uint32_t)0x10004000)
+#define I2C_FLAG_PECERR                 ((uint32_t)0x10001000)
+#define I2C_FLAG_OVR                    ((uint32_t)0x10000800)
+#define I2C_FLAG_AF                     ((uint32_t)0x10000400)
+#define I2C_FLAG_ARLO                   ((uint32_t)0x10000200)
+#define I2C_FLAG_BERR                   ((uint32_t)0x10000100)
+#define I2C_FLAG_TXE                    ((uint32_t)0x10000080)
+#define I2C_FLAG_RXNE                   ((uint32_t)0x10000040)
+#define I2C_FLAG_STOPF                  ((uint32_t)0x10000010)
+#define I2C_FLAG_ADD10                  ((uint32_t)0x10000008)
+#define I2C_FLAG_BTF                    ((uint32_t)0x10000004)
+#define I2C_FLAG_ADDR                   ((uint32_t)0x10000002)
+#define I2C_FLAG_SB                     ((uint32_t)0x10000001)
+
+#define IS_I2C_CLEAR_FLAG(FLAG) ((((FLAG) &amp; (uint16_t)0x20FF) == 0x00) &amp;&amp; ((FLAG) != (uint16_t)0x00))
+
 #define IS_I2C_GET_FLAG(FLAG) (((FLAG) == I2C_FLAG_DUALF) || ((FLAG) == I2C_FLAG_SMBHOST) || \
                                ((FLAG) == I2C_FLAG_SMBDEFAULT) || ((FLAG) == I2C_FLAG_GENCALL) || \
                                ((FLAG) == I2C_FLAG_TRA) || ((FLAG) == I2C_FLAG_BUSY) || \
@@ -179,46 +282,85 @@
                                ((FLAG) == I2C_FLAG_STOPF) || ((FLAG) == I2C_FLAG_ADD10) || \
                                ((FLAG) == I2C_FLAG_BTF) || ((FLAG) == I2C_FLAG_ADDR) || \
                                ((FLAG) == I2C_FLAG_SB))
+/**
+  * @}
+  */
 
-/* I2C Events */
-/* EV1 */
-#define  I2C_EVENT_SLAVE_TRANSMITTER_ADDRESS_MATCHED       ((u32)0x00060082) /* TRA, BUSY, TXE and ADDR flags */
-#define  I2C_EVENT_SLAVE_RECEIVER_ADDRESS_MATCHED          ((u32)0x00020002) /* BUSY and ADDR flags */
-#define  I2C_EVENT_SLAVE_TRANSMITTER_SECONDADDRESS_MATCHED ((u32)0x00860080)  /* DUALF, TRA, BUSY and TXE flags */
-#define  I2C_EVENT_SLAVE_RECEIVER_SECONDADDRESS_MATCHED    ((u32)0x00820000)  /* DUALF and BUSY flags */
-#define  I2C_EVENT_SLAVE_GENERALCALLADDRESS_MATCHED        ((u32)0x00120000)  /* GENCALL and BUSY flags */
+/** @defgroup I2C_Events 
+  * @{
+  */
 
-/* EV2 */
-#define  I2C_EVENT_SLAVE_BYTE_RECEIVED                     ((u32)0x00020040)  /* BUSY and RXNE flags */
-     
-/* EV3 */
-#define  I2C_EVENT_SLAVE_BYTE_TRANSMITTED                  ((u32)0x00060084)  /* TRA, BUSY, TXE and BTF flags */
+/** 
+  * @brief  EV1
+  */
 
-/* EV4 */
-#define  I2C_EVENT_SLAVE_STOP_DETECTED                     ((u32)0x00000010)  /* STOPF flag */
+#define  I2C_EVENT_SLAVE_TRANSMITTER_ADDRESS_MATCHED       ((uint32_t)0x00060082) /* TRA, BUSY, TXE and ADDR flags */
+#define  I2C_EVENT_SLAVE_RECEIVER_ADDRESS_MATCHED          ((uint32_t)0x00020002) /* BUSY and ADDR flags */
+#define  I2C_EVENT_SLAVE_TRANSMITTER_SECONDADDRESS_MATCHED ((uint32_t)0x00860080)  /* DUALF, TRA, BUSY and TXE flags */
+#define  I2C_EVENT_SLAVE_RECEIVER_SECONDADDRESS_MATCHED    ((uint32_t)0x00820000)  /* DUALF and BUSY flags */
+#define  I2C_EVENT_SLAVE_GENERALCALLADDRESS_MATCHED        ((uint32_t)0x00120000)  /* GENCALL and BUSY flags */
 
-/* EV5 */
-#define  I2C_EVENT_MASTER_MODE_SELECT                      ((u32)0x00030001)  /* BUSY, MSL and SB flag */
+/** 
+  * @brief  EV2  
+  */
 
-/* EV6 */
-#define  I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED        ((u32)0x00070082)  /* BUSY, MSL, ADDR, TXE and TRA flags */
-#define  I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED           ((u32)0x00030002)  /* BUSY, MSL and ADDR flags */
+#define  I2C_EVENT_SLAVE_BYTE_RECEIVED                     ((uint32_t)0x00020040)  /* BUSY and RXNE flags */
 
-/* EV7 */
-#define  I2C_EVENT_MASTER_BYTE_RECEIVED                    ((u32)0x00030040)  /* BUSY, MSL and RXNE flags */
+/** 
+  * @brief  EV3  
+  */
 
-/* EV8 */
-#define I2C_EVENT_MASTER_BYTE_TRANSMITTING                 ((u32)0x00070080) /* TRA, BUSY, MSL, TXE flags */
+#define  I2C_EVENT_SLAVE_BYTE_TRANSMITTED                  ((uint32_t)0x00060084)  /* TRA, BUSY, TXE and BTF flags */
 
-/* EV8_2 */
-#define  I2C_EVENT_MASTER_BYTE_TRANSMITTED                 ((u32)0x00070084)  /* TRA, BUSY, MSL, TXE and BTF flags */
-      
-/* EV9 */
-#define  I2C_EVENT_MASTER_MODE_ADDRESS10                   ((u32)0x00030008)  /* BUSY, MSL and ADD10 flags */
-                                          
-/* EV3_2 */
-#define  I2C_EVENT_SLAVE_ACK_FAILURE                       ((u32)0x00000400)  /* AF flag */
+/** 
+  * @brief  EV4
+  */
 
+#define  I2C_EVENT_SLAVE_STOP_DETECTED                     ((uint32_t)0x00000010)  /* STOPF flag */
+
+/** 
+  * @brief  EV5
+  */
+
+#define  I2C_EVENT_MASTER_MODE_SELECT                      ((uint32_t)0x00030001)  /* BUSY, MSL and SB flag */
+
+/** 
+  * @brief  EV6
+  */
+
+#define  I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED        ((uint32_t)0x00070082)  /* BUSY, MSL, ADDR, TXE and TRA flags */
+#define  I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED           ((uint32_t)0x00030002)  /* BUSY, MSL and ADDR flags */
+
+/** 
+  * @brief  EV7
+  */
+
+#define  I2C_EVENT_MASTER_BYTE_RECEIVED                    ((uint32_t)0x00030040)  /* BUSY, MSL and RXNE flags */
+
+/** 
+  * @brief  EV8
+  */
+
+#define I2C_EVENT_MASTER_BYTE_TRANSMITTING                 ((uint32_t)0x00070080) /* TRA, BUSY, MSL, TXE flags */
+
+/** 
+  * @brief  EV8_2
+  */
+
+#define  I2C_EVENT_MASTER_BYTE_TRANSMITTED                 ((uint32_t)0x00070084)  /* TRA, BUSY, MSL, TXE and BTF flags */
+
+/** 
+  * @brief  EV9
+  */
+
+#define  I2C_EVENT_MASTER_MODE_ADDRESS10                   ((uint32_t)0x00030008)  /* BUSY, MSL and ADD10 flags */
+
+/** 
+  * @brief  EV3_2
+  */
+
+#define  I2C_EVENT_SLAVE_ACK_FAILURE                       ((uint32_t)0x00000400)  /* AF flag */
+
 #define IS_I2C_EVENT(EVENT) (((EVENT) == I2C_EVENT_SLAVE_TRANSMITTER_ADDRESS_MATCHED) || \
                              ((EVENT) == I2C_EVENT_SLAVE_RECEIVER_ADDRESS_MATCHED) || \
                              ((EVENT) == I2C_EVENT_SLAVE_TRANSMITTER_SECONDADDRESS_MATCHED) || \
@@ -236,16 +378,47 @@
                              ((EVENT) == I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED) || \
                              ((EVENT) == I2C_EVENT_MASTER_BYTE_RECEIVED) || \
                              ((EVENT) == I2C_EVENT_MASTER_BYTE_TRANSMITTED) || \
+                             ((EVENT) == I2C_EVENT_MASTER_BYTE_TRANSMITTING) || \
                              ((EVENT) == I2C_EVENT_MASTER_MODE_ADDRESS10) || \
                              ((EVENT) == I2C_EVENT_SLAVE_ACK_FAILURE))
+/**
+  * @}
+  */
 
-/* I2C own address1 -----------------------------------------------------------*/
+/** @defgroup I2C_own_address1 
+  * @{
+  */
+
 #define IS_I2C_OWN_ADDRESS1(ADDRESS1) ((ADDRESS1) &lt;= 0x3FF)
-/* I2C clock speed ------------------------------------------------------------*/
+/**
+  * @}
+  */
+
+/** @defgroup I2C_clock_speed 
+  * @{
+  */
+
 #define IS_I2C_CLOCK_SPEED(SPEED) (((SPEED) &gt;= 0x1) &amp;&amp; ((SPEED) &lt;= 400000))
+/**
+  * @}
+  */
 
-/* Exported macro ------------------------------------------------------------*/
-/* Exported functions ------------------------------------------------------- */
+/**
+  * @}
+  */
+
+/** @defgroup I2C_Exported_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup I2C_Exported_Functions
+  * @{
+  */
+
 void I2C_DeInit(I2C_TypeDef* I2Cx);
 void I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct);
 void I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct);
@@ -255,30 +428,45 @@
 void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState);
 void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState);
 void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState);
-void I2C_OwnAddress2Config(I2C_TypeDef* I2Cx, u8 Address);
+void I2C_OwnAddress2Config(I2C_TypeDef* I2Cx, uint8_t Address);
 void I2C_DualAddressCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
 void I2C_GeneralCallCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
-void I2C_ITConfig(I2C_TypeDef* I2Cx, u16 I2C_IT, FunctionalState NewState);
-void I2C_SendData(I2C_TypeDef* I2Cx, u8 Data);
-u8 I2C_ReceiveData(I2C_TypeDef* I2Cx);
-void I2C_Send7bitAddress(I2C_TypeDef* I2Cx, u8 Address, u8 I2C_Direction);
-u16 I2C_ReadRegister(I2C_TypeDef* I2Cx, u8 I2C_Register);
+void I2C_ITConfig(I2C_TypeDef* I2Cx, uint16_t I2C_IT, FunctionalState NewState);
+void I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data);
+uint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx);
+void I2C_Send7bitAddress(I2C_TypeDef* I2Cx, uint8_t Address, uint8_t I2C_Direction);
+uint16_t I2C_ReadRegister(I2C_TypeDef* I2Cx, uint8_t I2C_Register);
 void I2C_SoftwareResetCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
-void I2C_SMBusAlertConfig(I2C_TypeDef* I2Cx, u16 I2C_SMBusAlert);
+void I2C_SMBusAlertConfig(I2C_TypeDef* I2Cx, uint16_t I2C_SMBusAlert);
 void I2C_TransmitPEC(I2C_TypeDef* I2Cx, FunctionalState NewState);
-void I2C_PECPositionConfig(I2C_TypeDef* I2Cx, u16 I2C_PECPosition);
+void I2C_PECPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_PECPosition);
 void I2C_CalculatePEC(I2C_TypeDef* I2Cx, FunctionalState NewState);
-u8 I2C_GetPEC(I2C_TypeDef* I2Cx);
+uint8_t I2C_GetPEC(I2C_TypeDef* I2Cx);
 void I2C_ARPCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
 void I2C_StretchClockCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
-void I2C_FastModeDutyCycleConfig(I2C_TypeDef* I2Cx, u16 I2C_DutyCycle);
-u32 I2C_GetLastEvent(I2C_TypeDef* I2Cx);
-ErrorStatus I2C_CheckEvent(I2C_TypeDef* I2Cx, u32 I2C_EVENT);
-FlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, u32 I2C_FLAG);
-void I2C_ClearFlag(I2C_TypeDef* I2Cx, u32 I2C_FLAG);
-ITStatus I2C_GetITStatus(I2C_TypeDef* I2Cx, u32 I2C_IT);
-void I2C_ClearITPendingBit(I2C_TypeDef* I2Cx, u32 I2C_IT);
+void I2C_FastModeDutyCycleConfig(I2C_TypeDef* I2Cx, uint16_t I2C_DutyCycle);
+uint32_t I2C_GetLastEvent(I2C_TypeDef* I2Cx);
+ErrorStatus I2C_CheckEvent(I2C_TypeDef* I2Cx, uint32_t I2C_EVENT);
+FlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG);
+void I2C_ClearFlag(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG);
+ITStatus I2C_GetITStatus(I2C_TypeDef* I2Cx, uint32_t I2C_IT);
+void I2C_ClearITPendingBit(I2C_TypeDef* I2Cx, uint32_t I2C_IT);
 
+#ifdef __cplusplus
+}
+#endif
+
 #endif /*__STM32F10x_I2C_H */
+/**
+  * @}
+  */ 
 
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/******************* (C) COPYRIGHT 2009 STMicroelectronics *****END OF FILE****/

Modified: trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_iwdg.h
===================================================================
--- trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_iwdg.h	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_iwdg.h	2009-07-08 23:39:34 UTC (rev 354)
@@ -1,44 +1,78 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_iwdg.h
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file contains all the functions prototypes for the
-*                      IWDG firmware library.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
+/**
+  ******************************************************************************
+  * @file    stm32f10x_iwdg.h
+  * @author  MCD Application Team
+  * @version V3.1.0
+  * @date    06/19/2009
+  * @brief   This file contains all the functions prototypes for the IWDG 
+  *          firmware library.
+  ******************************************************************************
+  * @copy
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * &lt;h2&gt;&lt;center&gt;&copy; COPYRIGHT 2009 STMicroelectronics&lt;/center&gt;&lt;/h2&gt;
+  */ 
 
 /* Define to prevent recursive inclusion -------------------------------------*/
 #ifndef __STM32F10x_IWDG_H
 #define __STM32F10x_IWDG_H
 
+#ifdef __cplusplus
+ extern &quot;C&quot; {
+#endif
+
 /* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_map.h&quot;
+#include &quot;stm32f10x.h&quot;
 
-/* Exported types ------------------------------------------------------------*/
-/* Exported constants --------------------------------------------------------*/
-/* Write access to IWDG_PR and IWDG_RLR registers */
-#define IWDG_WriteAccess_Enable     ((u16)0x5555)
-#define IWDG_WriteAccess_Disable    ((u16)0x0000)
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
 
+/** @addtogroup IWDG
+  * @{
+  */
+
+/** @defgroup IWDG_Exported_Types
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup IWDG_Exported_Constants
+  * @{
+  */
+
+/** @defgroup IWDG_WriteAccess
+  * @{
+  */
+
+#define IWDG_WriteAccess_Enable     ((uint16_t)0x5555)
+#define IWDG_WriteAccess_Disable    ((uint16_t)0x0000)
 #define IS_IWDG_WRITE_ACCESS(ACCESS) (((ACCESS) == IWDG_WriteAccess_Enable) || \
                                       ((ACCESS) == IWDG_WriteAccess_Disable))
+/**
+  * @}
+  */
 
-/* IWDG prescaler */
-#define IWDG_Prescaler_4            ((u8)0x00)
-#define IWDG_Prescaler_8            ((u8)0x01)
-#define IWDG_Prescaler_16           ((u8)0x02)
-#define IWDG_Prescaler_32           ((u8)0x03)
-#define IWDG_Prescaler_64           ((u8)0x04)
-#define IWDG_Prescaler_128          ((u8)0x05)
-#define IWDG_Prescaler_256          ((u8)0x06)
+/** @defgroup IWDG_prescaler 
+  * @{
+  */
 
+#define IWDG_Prescaler_4            ((uint8_t)0x00)
+#define IWDG_Prescaler_8            ((uint8_t)0x01)
+#define IWDG_Prescaler_16           ((uint8_t)0x02)
+#define IWDG_Prescaler_32           ((uint8_t)0x03)
+#define IWDG_Prescaler_64           ((uint8_t)0x04)
+#define IWDG_Prescaler_128          ((uint8_t)0x05)
+#define IWDG_Prescaler_256          ((uint8_t)0x06)
 #define IS_IWDG_PRESCALER(PRESCALER) (((PRESCALER) == IWDG_Prescaler_4)  || \
                                       ((PRESCALER) == IWDG_Prescaler_8)  || \
                                       ((PRESCALER) == IWDG_Prescaler_16) || \
@@ -46,24 +80,60 @@
                                       ((PRESCALER) == IWDG_Prescaler_64) || \
                                       ((PRESCALER) == IWDG_Prescaler_128)|| \
                                       ((PRESCALER) == IWDG_Prescaler_256))
+/**
+  * @}
+  */
 
-/* IWDG Flag */
-#define IWDG_FLAG_PVU               ((u16)0x0001)
-#define IWDG_FLAG_RVU               ((u16)0x0002)
+/** @defgroup IWDG_Flag 
+  * @{
+  */
 
+#define IWDG_FLAG_PVU               ((uint16_t)0x0001)
+#define IWDG_FLAG_RVU               ((uint16_t)0x0002)
 #define IS_IWDG_FLAG(FLAG) (((FLAG) == IWDG_FLAG_PVU) || ((FLAG) == IWDG_FLAG_RVU))
-
 #define IS_IWDG_RELOAD(RELOAD) ((RELOAD) &lt;= 0xFFF)
+/**
+  * @}
+  */
 
-/* Exported macro ------------------------------------------------------------*/
-/* Exported functions ------------------------------------------------------- */
-void IWDG_WriteAccessCmd(u16 IWDG_WriteAccess);
-void IWDG_SetPrescaler(u8 IWDG_Prescaler);
-void IWDG_SetReload(u16 Reload);
+/**
+  * @}
+  */
+
+/** @defgroup IWDG_Exported_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup IWDG_Exported_Functions
+  * @{
+  */
+
+void IWDG_WriteAccessCmd(uint16_t IWDG_WriteAccess);
+void IWDG_SetPrescaler(uint8_t IWDG_Prescaler);
+void IWDG_SetReload(uint16_t Reload);
 void IWDG_ReloadCounter(void);
 void IWDG_Enable(void);
-FlagStatus IWDG_GetFlagStatus(u16 IWDG_FLAG);
+FlagStatus IWDG_GetFlagStatus(uint16_t IWDG_FLAG);
 
+#ifdef __cplusplus
+}
+#endif
+
 #endif /* __STM32F10x_IWDG_H */
+/**
+  * @}
+  */
 
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2009 STMicroelectronics *****END OF FILE****/

Deleted: trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_lib.h
===================================================================
--- trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_lib.h	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_lib.h	2009-07-08 23:39:34 UTC (rev 354)
@@ -1,124 +0,0 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_lib.h
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file includes the peripherals header files in the
-*                      user application.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
-
-/* Define to prevent recursive inclusion -------------------------------------*/
-#ifndef __STM32F10x_LIB_H
-#define __STM32F10x_LIB_H
-
-/* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_map.h&quot;
-
-#ifdef _ADC
-  #include &quot;stm32f10x_adc.h&quot;
-#endif /*_ADC */
-
-#ifdef _BKP
-  #include &quot;stm32f10x_bkp.h&quot;
-#endif /*_BKP */
-
-#ifdef _CAN
-  #include &quot;stm32f10x_can.h&quot;
-#endif /*_CAN */
-
-#ifdef _CRC
-  #include &quot;stm32f10x_crc.h&quot;
-#endif /*_CRC */
-
-#ifdef _DAC
-  #include &quot;stm32f10x_dac.h&quot;
-#endif /*_DAC */
-
-#ifdef _DBGMCU
-  #include &quot;stm32f10x_dbgmcu.h&quot;
-#endif /*_DBGMCU */
-
-#ifdef _DMA
-  #include &quot;stm32f10x_dma.h&quot;
-#endif /*_DMA */
-
-#ifdef _EXTI
-  #include &quot;stm32f10x_exti.h&quot;
-#endif /*_EXTI */
-
-#ifdef _FLASH
-  #include &quot;stm32f10x_flash.h&quot;
-#endif /*_FLASH */
-
-#ifdef _FSMC
-  #include &quot;stm32f10x_fsmc.h&quot;
-#endif /*_FSMC */
-
-#ifdef _GPIO
-  #include &quot;stm32f10x_gpio.h&quot;
-#endif /*_GPIO */
-
-#ifdef _I2C
-  #include &quot;stm32f10x_i2c.h&quot;
-#endif /*_I2C */
-
-#ifdef _IWDG
-  #include &quot;stm32f10x_iwdg.h&quot;
-#endif /*_IWDG */
-
-#ifdef _NVIC
-  #include &quot;stm32f10x_nvic.h&quot;
-#endif /*_NVIC */
-
-#ifdef _PWR
-  #include &quot;stm32f10x_pwr.h&quot;
-#endif /*_PWR */
-
-#ifdef _RCC
-  #include &quot;stm32f10x_rcc.h&quot;
-#endif /*_RCC */
-
-#ifdef _RTC
-  #include &quot;stm32f10x_rtc.h&quot;
-#endif /*_RTC */
-
-#ifdef _SDIO
-  #include &quot;stm32f10x_sdio.h&quot;
-#endif /*_SDIO */
-
-#ifdef _SPI
-  #include &quot;stm32f10x_spi.h&quot;
-#endif /*_SPI */
-
-#ifdef _SysTick
-  #include &quot;stm32f10x_systick.h&quot;
-#endif /*_SysTick */
-
-#ifdef _TIM
-  #include &quot;stm32f10x_tim.h&quot;
-#endif /*_TIM */
-
-#ifdef _USART
-  #include &quot;stm32f10x_usart.h&quot;
-#endif /*_USART */
-
-#ifdef _WWDG
-  #include &quot;stm32f10x_wwdg.h&quot;
-#endif /*_WWDG */
-
-/* Exported types ------------------------------------------------------------*/
-/* Exported constants --------------------------------------------------------*/
-/* Exported macro ------------------------------------------------------------*/
-/* Exported functions ------------------------------------------------------- */
-void debug(void);
-
-#endif /* __STM32F10x_LIB_H */
-
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/

Deleted: trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_map.h
===================================================================
--- trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_map.h	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_map.h	2009-07-08 23:39:34 UTC (rev 354)
@@ -1,7603 +0,0 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_map.h
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file contains all the peripheral register's definitions,
-*                      bits definitions and memory mapping.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
-
-/* Define to prevent recursive inclusion -------------------------------------*/
-#ifndef __STM32F10x_MAP_H
-#define __STM32F10x_MAP_H
-
-#ifndef EXT
-  #define EXT extern
-#endif /* EXT */
-
-/* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_conf.h&quot;
-#include &quot;stm32f10x_type.h&quot;
-#include &quot;cortexm3_macro.h&quot;
-
-/* Exported types ------------------------------------------------------------*/
-/******************************************************************************/
-/*                         Peripheral registers structures                    */
-/******************************************************************************/
-
-/*------------------------ Analog to Digital Converter -----------------------*/
-typedef struct
-{
-  vu32 SR;
-  vu32 CR1;
-  vu32 CR2;
-  vu32 SMPR1;
-  vu32 SMPR2;
-  vu32 JOFR1;
-  vu32 JOFR2;
-  vu32 JOFR3;
-  vu32 JOFR4;
-  vu32 HTR;
-  vu32 LTR;
-  vu32 SQR1;
-  vu32 SQR2;
-  vu32 SQR3;
-  vu32 JSQR;
-  vu32 JDR1;
-  vu32 JDR2;
-  vu32 JDR3;
-  vu32 JDR4;
-  vu32 DR;
-} ADC_TypeDef;
-
-/*------------------------ Backup Registers ----------------------------------*/
-typedef struct
-{
-  u32  RESERVED0;
-  vu16 DR1;
-  u16  RESERVED1;
-  vu16 DR2;
-  u16  RESERVED2;
-  vu16 DR3;
-  u16  RESERVED3;
-  vu16 DR4;
-  u16  RESERVED4;
-  vu16 DR5;
-  u16  RESERVED5;
-  vu16 DR6;
-  u16  RESERVED6;
-  vu16 DR7;
-  u16  RESERVED7;
-  vu16 DR8;
-  u16  RESERVED8;
-  vu16 DR9;
-  u16  RESERVED9;
-  vu16 DR10;
-  u16  RESERVED10; 
-  vu16 RTCCR;
-  u16  RESERVED11;
-  vu16 CR;
-  u16  RESERVED12;
-  vu16 CSR;
-  u16  RESERVED13[5];
-  vu16 DR11;
-  u16  RESERVED14;
-  vu16 DR12;
-  u16  RESERVED15;
-  vu16 DR13;
-  u16  RESERVED16;
-  vu16 DR14;
-  u16  RESERVED17;
-  vu16 DR15;
-  u16  RESERVED18;
-  vu16 DR16;
-  u16  RESERVED19;
-  vu16 DR17;
-  u16  RESERVED20;
-  vu16 DR18;
-  u16  RESERVED21;
-  vu16 DR19;
-  u16  RESERVED22;
-  vu16 DR20;
-  u16  RESERVED23;
-  vu16 DR21;
-  u16  RESERVED24;
-  vu16 DR22;
-  u16  RESERVED25;
-  vu16 DR23;
-  u16  RESERVED26;
-  vu16 DR24;
-  u16  RESERVED27;
-  vu16 DR25;
-  u16  RESERVED28;
-  vu16 DR26;
-  u16  RESERVED29;
-  vu16 DR27;
-  u16  RESERVED30;
-  vu16 DR28;
-  u16  RESERVED31;
-  vu16 DR29;
-  u16  RESERVED32;
-  vu16 DR30;
-  u16  RESERVED33; 
-  vu16 DR31;
-  u16  RESERVED34;
-  vu16 DR32;
-  u16  RESERVED35;
-  vu16 DR33;
-  u16  RESERVED36;
-  vu16 DR34;
-  u16  RESERVED37;
-  vu16 DR35;
-  u16  RESERVED38;
-  vu16 DR36;
-  u16  RESERVED39;
-  vu16 DR37;
-  u16  RESERVED40;
-  vu16 DR38;
-  u16  RESERVED41;
-  vu16 DR39;
-  u16  RESERVED42;
-  vu16 DR40;
-  u16  RESERVED43;
-  vu16 DR41;
-  u16  RESERVED44;
-  vu16 DR42;
-  u16  RESERVED45;    
-} BKP_TypeDef;
-
-/*------------------------ Controller Area Network ---------------------------*/
-typedef struct
-{
-  vu32 TIR;
-  vu32 TDTR;
-  vu32 TDLR;
-  vu32 TDHR;
-} CAN_TxMailBox_TypeDef;
-
-typedef struct
-{
-  vu32 RIR;
-  vu32 RDTR;
-  vu32 RDLR;
-  vu32 RDHR;
-} CAN_FIFOMailBox_TypeDef;
-
-typedef struct
-{
-  vu32 FR1;
-  vu32 FR2;
-} CAN_FilterRegister_TypeDef;
-
-typedef struct
-{
-  vu32 MCR;
-  vu32 MSR;
-  vu32 TSR;
-  vu32 RF0R;
-  vu32 RF1R;
-  vu32 IER;
-  vu32 ESR;
-  vu32 BTR;
-  u32  RESERVED0[88];
-  CAN_TxMailBox_TypeDef sTxMailBox[3];
-  CAN_FIFOMailBox_TypeDef sFIFOMailBox[2];
-  u32  RESERVED1[12];
-  vu32 FMR;
-  vu32 FM1R;
-  u32  RESERVED2;
-  vu32 FS1R;
-  u32  RESERVED3;
-  vu32 FFA1R;
-  u32  RESERVED4;
-  vu32 FA1R;
-  u32  RESERVED5[8];
-  CAN_FilterRegister_TypeDef sFilterRegister[14];
-} CAN_TypeDef;
-
-/*------------------------ CRC calculation unit ------------------------------*/
-typedef struct
-{
-  vu32 DR;
-  vu8  IDR;
-  u8   RESERVED0;
-  u16  RESERVED1;
-  vu32 CR;
-} CRC_TypeDef;
-
-
-/*------------------------ Digital to Analog Converter -----------------------*/
-typedef struct
-{
-  vu32 CR;
-  vu32 SWTRIGR;
-  vu32 DHR12R1;
-  vu32 DHR12L1;
-  vu32 DHR8R1;
-  vu32 DHR12R2;
-  vu32 DHR12L2;
-  vu32 DHR8R2;
-  vu32 DHR12RD;
-  vu32 DHR12LD;
-  vu32 DHR8RD;
-  vu32 DOR1;
-  vu32 DOR2;
-} DAC_TypeDef;
-
-/*------------------------ Debug MCU -----------------------------------------*/
-typedef struct
-{
-  vu32 IDCODE;
-  vu32 CR;	
-}DBGMCU_TypeDef;
-
-/*------------------------ DMA Controller ------------------------------------*/
-typedef struct
-{
-  vu32 CCR;
-  vu32 CNDTR;
-  vu32 CPAR;
-  vu32 CMAR;
-} DMA_Channel_TypeDef;
-
-typedef struct
-{
-  vu32 ISR;
-  vu32 IFCR;
-} DMA_TypeDef;
-
-/*------------------------ External Interrupt/Event Controller ---------------*/
-typedef struct
-{
-  vu32 IMR;
-  vu32 EMR;
-  vu32 RTSR;
-  vu32 FTSR;
-  vu32 SWIER;
-  vu32 PR;
-} EXTI_TypeDef;
-
-/*------------------------ FLASH and Option Bytes Registers ------------------*/
-typedef struct
-{
-  vu32 ACR;
-  vu32 KEYR;
-  vu32 OPTKEYR;
-  vu32 SR;
-  vu32 CR;
-  vu32 AR;
-  vu32 RESERVED;
-  vu32 OBR;
-  vu32 WRPR;
-} FLASH_TypeDef;
-
-typedef struct
-{
-  vu16 RDP;
-  vu16 USER;
-  vu16 Data0;
-  vu16 Data1;
-  vu16 WRP0;
-  vu16 WRP1;
-  vu16 WRP2;
-  vu16 WRP3;
-} OB_TypeDef;
-
-/*------------------------ Flexible Static Memory Controller -----------------*/
-typedef struct
-{
-  vu32 BTCR[8];   
-} FSMC_Bank1_TypeDef; 
-
-typedef struct
-{
-  vu32 BWTR[7];
-} FSMC_Bank1E_TypeDef;
-
-typedef struct
-{
-  vu32 PCR2;
-  vu32 SR2;
-  vu32 PMEM2;
-  vu32 PATT2;
-  u32  RESERVED0;   
-  vu32 ECCR2; 
-} FSMC_Bank2_TypeDef;  
-
-typedef struct
-{
-  vu32 PCR3;
-  vu32 SR3;
-  vu32 PMEM3;
-  vu32 PATT3;
-  u32  RESERVED0;   
-  vu32 ECCR3; 
-} FSMC_Bank3_TypeDef; 
-
-typedef struct
-{
-  vu32 PCR4;
-  vu32 SR4;
-  vu32 PMEM4;
-  vu32 PATT4;
-  vu32 PIO4; 
-} FSMC_Bank4_TypeDef; 
-
-/*------------------------ General Purpose and Alternate Function IO ---------*/
-typedef struct
-{
-  vu32 CRL;
-  vu32 CRH;
-  vu32 IDR;
-  vu32 ODR;
-  vu32 BSRR;
-  vu32 BRR;
-  vu32 LCKR;
-} GPIO_TypeDef;
-
-typedef struct
-{
-  vu32 EVCR;
-  vu32 MAPR;
-  vu32 EXTICR[4];
-} AFIO_TypeDef;
-
-/*------------------------ Inter-integrated Circuit Interface ----------------*/
-typedef struct
-{
-  vu16 CR1;
-  u16  RESERVED0;
-  vu16 CR2;
-  u16  RESERVED1;
-  vu16 OAR1;
-  u16  RESERVED2;
-  vu16 OAR2;
-  u16  RESERVED3;
-  vu16 DR;
-  u16  RESERVED4;
-  vu16 SR1;
-  u16  RESERVED5;
-  vu16 SR2;
-  u16  RESERVED6;
-  vu16 CCR;
-  u16  RESERVED7;
-  vu16 TRISE;
-  u16  RESERVED8;
-} I2C_TypeDef;
-
-/*------------------------ Independent WATCHDOG ------------------------------*/
-typedef struct
-{
-  vu32 KR;
-  vu32 PR;
-  vu32 RLR;
-  vu32 SR;
-} IWDG_TypeDef;
-
-/*------------------------ Nested Vectored Interrupt Controller --------------*/
-typedef struct
-{
-  vu32 ISER[2];
-  u32  RESERVED0[30];
-  vu32 ICER[2];
-  u32  RSERVED1[30];
-  vu32 ISPR[2];
-  u32  RESERVED2[30];
-  vu32 ICPR[2];
-  u32  RESERVED3[30];
-  vu32 IABR[2];
-  u32  RESERVED4[62];
-  vu32 IPR[15];
-} NVIC_TypeDef;
-
-typedef struct
-{
-  vuc32 CPUID;
-  vu32 ICSR;
-  vu32 VTOR;
-  vu32 AIRCR;
-  vu32 SCR;
-  vu32 CCR;
-  vu32 SHPR[3];
-  vu32 SHCSR;
-  vu32 CFSR;
-  vu32 HFSR;
-  vu32 DFSR;
-  vu32 MMFAR;
-  vu32 BFAR;
-  vu32 AFSR;
-} SCB_TypeDef;
-
-/*------------------------ Power Control -------------------------------------*/
-typedef struct
-{
-  vu32 CR;
-  vu32 CSR;
-} PWR_TypeDef;
-
-/*------------------------ Reset and Clock Control ---------------------------*/
-typedef struct
-{
-  vu32 CR;
-  vu32 CFGR;
-  vu32 CIR;
-  vu32 APB2RSTR;
-  vu32 APB1RSTR;
-  vu32 AHBENR;
-  vu32 APB2ENR;
-  vu32 APB1ENR;
-  vu32 BDCR;
-  vu32 CSR;
-} RCC_TypeDef;
-
-/*------------------------ Real-Time Clock -----------------------------------*/
-typedef struct
-{
-  vu16 CRH;
-  u16  RESERVED0;
-  vu16 CRL;
-  u16  RESERVED1;
-  vu16 PRLH;
-  u16  RESERVED2;
-  vu16 PRLL;
-  u16  RESERVED3;
-  vu16 DIVH;
-  u16  RESERVED4;
-  vu16 DIVL;
-  u16  RESERVED5;
-  vu16 CNTH;
-  u16  RESERVED6;
-  vu16 CNTL;
-  u16  RESERVED7;
-  vu16 ALRH;
-  u16  RESERVED8;
-  vu16 ALRL;
-  u16  RESERVED9;
-} RTC_TypeDef;
-
-/*------------------------ SD host Interface ---------------------------------*/
-typedef struct
-{
-  vu32 POWER;
-  vu32 CLKCR;
-  vu32 ARG;
-  vu32 CMD;
-  vuc32 RESPCMD;
-  vuc32 RESP1;
-  vuc32 RESP2;
-  vuc32 RESP3;
-  vuc32 RESP4;
-  vu32 DTIMER;
-  vu32 DLEN;
-  vu32 DCTRL;
-  vuc32 DCOUNT;
-  vuc32 STA;
-  vu32 ICR;
-  vu32 MASK;
-  u32  RESERVED0[2];
-  vuc32 FIFOCNT;
-  u32  RESERVED1[13];
-  vu32 FIFO;
-} SDIO_TypeDef;
-
-/*------------------------ Serial Peripheral Interface -----------------------*/
-typedef struct
-{
-  vu16 CR1;
-  u16  RESERVED0;
-  vu16 CR2;
-  u16  RESERVED1;
-  vu16 SR;
-  u16  RESERVED2;
-  vu16 DR;
-  u16  RESERVED3;
-  vu16 CRCPR;
-  u16  RESERVED4;
-  vu16 RXCRCR;
-  u16  RESERVED5;
-  vu16 TXCRCR;
-  u16  RESERVED6;
-  vu16 I2SCFGR;
-  u16  RESERVED7;
-  vu16 I2SPR;
-  u16  RESERVED8;  
-} SPI_TypeDef;
-
-/*------------------------ SystemTick ----------------------------------------*/
-typedef struct
-{
-  vu32 CTRL;
-  vu32 LOAD;
-  vu32 VAL;
-  vuc32 CALIB;
-} SysTick_TypeDef;
-
-/*------------------------ TIM -----------------------------------------------*/
-typedef struct
-{
-  vu16 CR1;
-  u16  RESERVED0;
-  vu16 CR2;
-  u16  RESERVED1;
-  vu16 SMCR;
-  u16  RESERVED2;
-  vu16 DIER;
-  u16  RESERVED3;
-  vu16 SR;
-  u16  RESERVED4;
-  vu16 EGR;
-  u16  RESERVED5;
-  vu16 CCMR1;
-  u16  RESERVED6;
-  vu16 CCMR2;
-  u16  RESERVED7;
-  vu16 CCER;
-  u16  RESERVED8;
-  vu16 CNT;
-  u16  RESERVED9;
-  vu16 PSC;
-  u16  RESERVED10;
-  vu16 ARR;
-  u16  RESERVED11;
-  vu16 RCR;
-  u16  RESERVED12;
-  vu16 CCR1;
-  u16  RESERVED13;
-  vu16 CCR2;
-  u16  RESERVED14;
-  vu16 CCR3;
-  u16  RESERVED15;
-  vu16 CCR4;
-  u16  RESERVED16;
-  vu16 BDTR;
-  u16  RESERVED17;
-  vu16 DCR;
-  u16  RESERVED18;
-  vu16 DMAR;
-  u16  RESERVED19;
-} TIM_TypeDef;
-
-/*----------------- Universal Synchronous Asynchronous Receiver Transmitter --*/
-typedef struct
-{
-  vu16 SR;
-  u16  RESERVED0;
-  vu16 DR;
-  u16  RESERVED1;
-  vu16 BRR;
-  u16  RESERVED2;
-  vu16 CR1;
-  u16  RESERVED3;
-  vu16 CR2;
-  u16  RESERVED4;
-  vu16 CR3;
-  u16  RESERVED5;
-  vu16 GTPR;
-  u16  RESERVED6;
-} USART_TypeDef;
-
-/*------------------------ Window WATCHDOG -----------------------------------*/
-typedef struct
-{
-  vu32 CR;
-  vu32 CFR;
-  vu32 SR;
-} WWDG_TypeDef;
-
-/******************************************************************************/
-/*                         Peripheral memory map                              */
-/******************************************************************************/
-/* Peripheral and SRAM base address in the alias region */
-#define PERIPH_BB_BASE        ((u32)0x42000000)
-#define SRAM_BB_BASE          ((u32)0x22000000)
-
-/* Peripheral and SRAM base address in the bit-band region */
-#define SRAM_BASE             ((u32)0x20000000)
-#define PERIPH_BASE           ((u32)0x40000000)
-
-/* FSMC registers base address */
-#define FSMC_R_BASE           ((u32)0xA0000000)
-
-/* Peripheral memory map */
-#define APB1PERIPH_BASE       PERIPH_BASE
-#define APB2PERIPH_BASE       (PERIPH_BASE + 0x10000)
-#define AHBPERIPH_BASE        (PERIPH_BASE + 0x20000)
-
-#define TIM2_BASE             (APB1PERIPH_BASE + 0x0000)
-#define TIM3_BASE             (APB1PERIPH_BASE + 0x0400)
-#define TIM4_BASE             (APB1PERIPH_BASE + 0x0800)
-#define TIM5_BASE             (APB1PERIPH_BASE + 0x0C00)
-#define TIM6_BASE             (APB1PERIPH_BASE + 0x1000)
-#define TIM7_BASE             (APB1PERIPH_BASE + 0x1400)
-#define RTC_BASE              (APB1PERIPH_BASE + 0x2800)
-#define WWDG_BASE             (APB1PERIPH_BASE + 0x2C00)
-#define IWDG_BASE             (APB1PERIPH_BASE + 0x3000)
-#define SPI2_BASE             (APB1PERIPH_BASE + 0x3800)
-#define SPI3_BASE             (APB1PERIPH_BASE + 0x3C00)
-#define USART2_BASE           (APB1PERIPH_BASE + 0x4400)
-#define USART3_BASE           (APB1PERIPH_BASE + 0x4800)
-#define UART4_BASE            (APB1PERIPH_BASE + 0x4C00)
-#define UART5_BASE            (APB1PERIPH_BASE + 0x5000)
-#define I2C1_BASE             (APB1PERIPH_BASE + 0x5400)
-#define I2C2_BASE             (APB1PERIPH_BASE + 0x5800)
-#define CAN_BASE              (APB1PERIPH_BASE + 0x6400)
-#define BKP_BASE              (APB1PERIPH_BASE + 0x6C00)
-#define PWR_BASE              (APB1PERIPH_BASE + 0x7000)
-#define DAC_BASE              (APB1PERIPH_BASE + 0x7400)
-
-#define AFIO_BASE             (APB2PERIPH_BASE + 0x0000)
-#define EXTI_BASE             (APB2PERIPH_BASE + 0x0400)
-#define GPIOA_BASE            (APB2PERIPH_BASE + 0x0800)
-#define GPIOB_BASE            (APB2PERIPH_BASE + 0x0C00)
-#define GPIOC_BASE            (APB2PERIPH_BASE + 0x1000)
-#define GPIOD_BASE            (APB2PERIPH_BASE + 0x1400)
-#define GPIOE_BASE            (APB2PERIPH_BASE + 0x1800)
-#define GPIOF_BASE            (APB2PERIPH_BASE + 0x1C00)
-#define GPIOG_BASE            (APB2PERIPH_BASE + 0x2000)
-#define ADC1_BASE             (APB2PERIPH_BASE + 0x2400)
-#define ADC2_BASE             (APB2PERIPH_BASE + 0x2800)
-#define TIM1_BASE             (APB2PERIPH_BASE + 0x2C00)
-#define SPI1_BASE             (APB2PERIPH_BASE + 0x3000)
-#define TIM8_BASE             (APB2PERIPH_BASE + 0x3400)
-#define USART1_BASE           (APB2PERIPH_BASE + 0x3800)
-#define ADC3_BASE             (APB2PERIPH_BASE + 0x3C00)
-
-#define SDIO_BASE             (PERIPH_BASE + 0x18000)
-
-#define DMA1_BASE             (AHBPERIPH_BASE + 0x0000)
-#define DMA1_Channel1_BASE    (AHBPERIPH_BASE + 0x0008)
-#define DMA1_Channel2_BASE    (AHBPERIPH_BASE + 0x001C)
-#define DMA1_Channel3_BASE    (AHBPERIPH_BASE + 0x0030)
-#define DMA1_Channel4_BASE    (AHBPERIPH_BASE + 0x0044)
-#define DMA1_Channel5_BASE    (AHBPERIPH_BASE + 0x0058)
-#define DMA1_Channel6_BASE    (AHBPERIPH_BASE + 0x006C)
-#define DMA1_Channel7_BASE    (AHBPERIPH_BASE + 0x0080)
-#define DMA2_BASE             (AHBPERIPH_BASE + 0x0400)
-#define DMA2_Channel1_BASE    (AHBPERIPH_BASE + 0x0408)
-#define DMA2_Channel2_BASE    (AHBPERIPH_BASE + 0x041C)
-#define DMA2_Channel3_BASE    (AHBPERIPH_BASE + 0x0430)
-#define DMA2_Channel4_BASE    (AHBPERIPH_BASE + 0x0444)
-#define DMA2_Channel5_BASE    (AHBPERIPH_BASE + 0x0458)
-#define RCC_BASE              (AHBPERIPH_BASE + 0x1000)
-#define CRC_BASE              (AHBPERIPH_BASE + 0x3000)
-
-/* Flash registers base address */
-#define FLASH_R_BASE          (AHBPERIPH_BASE + 0x2000)
-/* Flash Option Bytes base address */
-#define OB_BASE               ((u32)0x1FFFF800)
-
-/* FSMC Bankx registers base address */
-#define FSMC_Bank1_R_BASE     (FSMC_R_BASE + 0x0000)
-#define FSMC_Bank1E_R_BASE    (FSMC_R_BASE + 0x0104)
-#define FSMC_Bank2_R_BASE     (FSMC_R_BASE + 0x0060)
-#define FSMC_Bank3_R_BASE     (FSMC_R_BASE + 0x0080)
-#define FSMC_Bank4_R_BASE     (FSMC_R_BASE + 0x00A0)
-
-/* Debug MCU registers base address */
-#define DBGMCU_BASE          ((u32)0xE0042000)
-
-/* System Control Space memory map */
-#define SCS_BASE              ((u32)0xE000E000)
-
-#define SysTick_BASE          (SCS_BASE + 0x0010)
-#define NVIC_BASE             (SCS_BASE + 0x0100)
-#define SCB_BASE              (SCS_BASE + 0x0D00)
-
-/******************************************************************************/
-/*                         Peripheral declaration                             */
-/******************************************************************************/
-
-/*------------------------ Non Debug Mode ------------------------------------*/
-#ifndef DEBUG
-#ifdef _TIM2
-  #define TIM2                ((TIM_TypeDef *) TIM2_BASE)
-#endif /*_TIM2 */
-
-#ifdef _TIM3
-  #define TIM3                ((TIM_TypeDef *) TIM3_BASE)
-#endif /*_TIM3 */
-
-#ifdef _TIM4
-  #define TIM4                ((TIM_TypeDef *) TIM4_BASE)
-#endif /*_TIM4 */
-
-#ifdef _TIM5
-  #define TIM5                ((TIM_TypeDef *) TIM5_BASE)
-#endif /*_TIM5 */
-
-#ifdef _TIM6
-  #define TIM6                ((TIM_TypeDef *) TIM6_BASE)
-#endif /*_TIM6 */
-
-#ifdef _TIM7
-  #define TIM7                ((TIM_TypeDef *) TIM7_BASE)
-#endif /*_TIM7 */
-
-#ifdef _RTC
-  #define RTC                 ((RTC_TypeDef *) RTC_BASE)
-#endif /*_RTC */
-
-#ifdef _WWDG
-  #define WWDG                ((WWDG_TypeDef *) WWDG_BASE)
-#endif /*_WWDG */
-
-#ifdef _IWDG
-  #define IWDG                ((IWDG_TypeDef *) IWDG_BASE)
-#endif /*_IWDG */
-
-#ifdef _SPI2
-  #define SPI2                ((SPI_TypeDef *) SPI2_BASE)
-#endif /*_SPI2 */
-
-#ifdef _SPI3
-  #define SPI3                ((SPI_TypeDef *) SPI3_BASE)
-#endif /*_SPI3 */
-
-#ifdef _USART2
-  #define USART2              ((USART_TypeDef *) USART2_BASE)
-#endif /*_USART2 */
-
-#ifdef _USART3
-  #define USART3              ((USART_TypeDef *) USART3_BASE)
-#endif /*_USART3 */
-
-#ifdef _UART4
-  #define UART4              ((USART_TypeDef *) UART4_BASE)
-#endif /*_UART4 */
-
-#ifdef _UART5
-  #define UART5              ((USART_TypeDef *) UART5_BASE)
-#endif /*_USART5 */
-
-#ifdef _I2C1
-  #define I2C1                ((I2C_TypeDef *) I2C1_BASE)
-#endif /*_I2C1 */
-
-#ifdef _I2C2
-  #define I2C2                ((I2C_TypeDef *) I2C2_BASE)
-#endif /*_I2C2 */
-
-#ifdef _CAN
-  #define CAN                 ((CAN_TypeDef *) CAN_BASE)
-#endif /*_CAN */
-
-#ifdef _BKP
-  #define BKP                 ((BKP_TypeDef *) BKP_BASE)
-#endif /*_BKP */
-
-#ifdef _PWR
-  #define PWR                 ((PWR_TypeDef *) PWR_BASE)
-#endif /*_PWR */
-
-#ifdef _DAC
-  #define DAC                 ((DAC_TypeDef *) DAC_BASE)
-#endif /*_DAC */
-
-#ifdef _AFIO
-  #define AFIO                ((AFIO_TypeDef *) AFIO_BASE)
-#endif /*_AFIO */
-
-#ifdef _EXTI
-  #define EXTI                ((EXTI_TypeDef *) EXTI_BASE)
-#endif /*_EXTI */
-
-#ifdef _GPIOA
-  #define GPIOA               ((GPIO_TypeDef *) GPIOA_BASE)
-#endif /*_GPIOA */
-
-#ifdef _GPIOB
-  #define GPIOB               ((GPIO_TypeDef *) GPIOB_BASE)
-#endif /*_GPIOB */
-
-#ifdef _GPIOC
-  #define GPIOC               ((GPIO_TypeDef *) GPIOC_BASE)
-#endif /*_GPIOC */
-
-#ifdef _GPIOD
-  #define GPIOD               ((GPIO_TypeDef *) GPIOD_BASE)
-#endif /*_GPIOD */
-
-#ifdef _GPIOE
-  #define GPIOE               ((GPIO_TypeDef *) GPIOE_BASE)
-#endif /*_GPIOE */
-
-#ifdef _GPIOF
-  #define GPIOF               ((GPIO_TypeDef *) GPIOF_BASE)
-#endif /*_GPIOF */
-
-#ifdef _GPIOG
-  #define GPIOG               ((GPIO_TypeDef *) GPIOG_BASE)
-#endif /*_GPIOG */
-
-#ifdef _ADC1
-  #define ADC1                ((ADC_TypeDef *) ADC1_BASE)
-#endif /*_ADC1 */
-
-#ifdef _ADC2
-  #define ADC2                ((ADC_TypeDef *) ADC2_BASE)
-#endif /*_ADC2 */
-
-#ifdef _TIM1
-  #define TIM1                ((TIM_TypeDef *) TIM1_BASE)
-#endif /*_TIM1 */
-
-#ifdef _SPI1
-  #define SPI1                ((SPI_TypeDef *) SPI1_BASE)
-#endif /*_SPI1 */
-
-#ifdef _TIM8
-  #define TIM8                ((TIM_TypeDef *) TIM8_BASE)
-#endif /*_TIM8 */
-
-#ifdef _USART1
-  #define USART1              ((USART_TypeDef *) USART1_BASE)
-#endif /*_USART1 */
-
-#ifdef _ADC3
-  #define ADC3                ((ADC_TypeDef *) ADC3_BASE)
-#endif /*_ADC3 */
-
-#ifdef _SDIO
-  #define SDIO                ((SDIO_TypeDef *) SDIO_BASE)
-#endif /*_SDIO */
-
-#ifdef _DMA
-  #define DMA1                ((DMA_TypeDef *) DMA1_BASE)
-  #define DMA2                ((DMA_TypeDef *) DMA2_BASE)
-#endif /*_DMA */
-
-#ifdef _DMA1_Channel1
-  #define DMA1_Channel1       ((DMA_Channel_TypeDef *) DMA1_Channel1_BASE)
-#endif /*_DMA1_Channel1 */
-
-#ifdef _DMA1_Channel2
-  #define DMA1_Channel2       ((DMA_Channel_TypeDef *) DMA1_Channel2_BASE)
-#endif /*_DMA1_Channel2 */
-
-#ifdef _DMA1_Channel3
-  #define DMA1_Channel3       ((DMA_Channel_TypeDef *) DMA1_Channel3_BASE)
-#endif /*_DMA1_Channel3 */
-
-#ifdef _DMA1_Channel4
-  #define DMA1_Channel4       ((DMA_Channel_TypeDef *) DMA1_Channel4_BASE)
-#endif /*_DMA1_Channel4 */
-
-#ifdef _DMA1_Channel5
-  #define DMA1_Channel5       ((DMA_Channel_TypeDef *) DMA1_Channel5_BASE)
-#endif /*_DMA1_Channel5 */
-
-#ifdef _DMA1_Channel6
-  #define DMA1_Channel6       ((DMA_Channel_TypeDef *) DMA1_Channel6_BASE)
-#endif /*_DMA1_Channel6 */
-
-#ifdef _DMA1_Channel7
-  #define DMA1_Channel7       ((DMA_Channel_TypeDef *) DMA1_Channel7_BASE)
-#endif /*_DMA1_Channel7 */
-
-#ifdef _DMA2_Channel1
-  #define DMA2_Channel1       ((DMA_Channel_TypeDef *) DMA2_Channel1_BASE)
-#endif /*_DMA2_Channel1 */
-
-#ifdef _DMA2_Channel2
-  #define DMA2_Channel2       ((DMA_Channel_TypeDef *) DMA2_Channel2_BASE)
-#endif /*_DMA2_Channel2 */
-
-#ifdef _DMA2_Channel3
-  #define DMA2_Channel3       ((DMA_Channel_TypeDef *) DMA2_Channel3_BASE)
-#endif /*_DMA2_Channel3 */
-
-#ifdef _DMA2_Channel4
-  #define DMA2_Channel4       ((DMA_Channel_TypeDef *) DMA2_Channel4_BASE)
-#endif /*_DMA2_Channel4 */
-
-#ifdef _DMA2_Channel5
-  #define DMA2_Channel5       ((DMA_Channel_TypeDef *) DMA2_Channel5_BASE)
-#endif /*_DMA2_Channel5 */
-
-#ifdef _RCC
-  #define RCC                 ((RCC_TypeDef *) RCC_BASE)
-#endif /*_RCC */
-
-#ifdef _CRC
-  #define CRC                 ((CRC_TypeDef *) CRC_BASE)
-#endif /*_CRC */
-
-#ifdef _FLASH
-  #define FLASH               ((FLASH_TypeDef *) FLASH_R_BASE)
-  #define OB                  ((OB_TypeDef *) OB_BASE) 
-#endif /*_FLASH */
-
-#ifdef _FSMC
-  #define FSMC_Bank1          ((FSMC_Bank1_TypeDef *) FSMC_Bank1_R_BASE)
-  #define FSMC_Bank1E         ((FSMC_Bank1E_TypeDef *) FSMC_Bank1E_R_BASE)
-  #define FSMC_Bank2          ((FSMC_Bank2_TypeDef *) FSMC_Bank2_R_BASE)
-  #define FSMC_Bank3          ((FSMC_Bank3_TypeDef *) FSMC_Bank3_R_BASE)
-  #define FSMC_Bank4          ((FSMC_Bank4_TypeDef *) FSMC_Bank4_R_BASE)
-#endif /*_FSMC */
-
-#ifdef _DBGMCU
-  #define DBGMCU              ((DBGMCU_TypeDef *) DBGMCU_BASE)
-#endif /*_DBGMCU */
-
-#ifdef _SysTick
-  #define SysTick             ((SysTick_TypeDef *) SysTick_BASE)
-#endif /*_SysTick */
-
-#ifdef _NVIC
-  #define NVIC                ((NVIC_TypeDef *) NVIC_BASE)
-  #define SCB                 ((SCB_TypeDef *) SCB_BASE)  
-#endif /*_NVIC */
-
-/*------------------------ Debug Mode ----------------------------------------*/
-#else   /* DEBUG */
-#ifdef _TIM2
-  EXT TIM_TypeDef             *TIM2;
-#endif /*_TIM2 */
-
-#ifdef _TIM3
-  EXT TIM_TypeDef             *TIM3;
-#endif /*_TIM3 */
-
-#ifdef _TIM4
-  EXT TIM_TypeDef             *TIM4;
-#endif /*_TIM4 */
-
-#ifdef _TIM5
-  EXT TIM_TypeDef             *TIM5;
-#endif /*_TIM5 */
-
-#ifdef _TIM6
-  EXT TIM_TypeDef             *TIM6;
-#endif /*_TIM6 */
-
-#ifdef _TIM7
-  EXT TIM_TypeDef             *TIM7;
-#endif /*_TIM7 */
-
-#ifdef _RTC
-  EXT RTC_TypeDef             *RTC;
-#endif /*_RTC */
-
-#ifdef _WWDG
-  EXT WWDG_TypeDef            *WWDG;
-#endif /*_WWDG */
-
-#ifdef _IWDG
-  EXT IWDG_TypeDef            *IWDG;
-#endif /*_IWDG */
-
-#ifdef _SPI2
-  EXT SPI_TypeDef             *SPI2;
-#endif /*_SPI2 */
-
-#ifdef _SPI3
-  EXT SPI_TypeDef             *SPI3;
-#endif /*_SPI3 */
-
-#ifdef _USART2
-  EXT USART_TypeDef           *USART2;
-#endif /*_USART2 */
-
-#ifdef _USART3
-  EXT USART_TypeDef           *USART3;
-#endif /*_USART3 */
-
-#ifdef _UART4
-  EXT USART_TypeDef           *UART4;
-#endif /*_UART4 */
-
-#ifdef _UART5
-  EXT USART_TypeDef           *UART5;
-#endif /*_UART5 */
-
-#ifdef _I2C1
-  EXT I2C_TypeDef             *I2C1;
-#endif /*_I2C1 */
-
-#ifdef _I2C2
-  EXT I2C_TypeDef             *I2C2;
-#endif /*_I2C2 */
-
-#ifdef _CAN
-  EXT CAN_TypeDef             *CAN;
-#endif /*_CAN */
-
-#ifdef _BKP
-  EXT BKP_TypeDef             *BKP;
-#endif /*_BKP */
-
-#ifdef _PWR
-  EXT PWR_TypeDef             *PWR;
-#endif /*_PWR */
-
-#ifdef _DAC
-  EXT DAC_TypeDef             *DAC;
-#endif /*_DAC */
-
-#ifdef _AFIO
-  EXT AFIO_TypeDef            *AFIO;
-#endif /*_AFIO */
-
-#ifdef _EXTI
-  EXT EXTI_TypeDef            *EXTI;
-#endif /*_EXTI */
-
-#ifdef _GPIOA
-  EXT GPIO_TypeDef            *GPIOA;
-#endif /*_GPIOA */
-
-#ifdef _GPIOB
-  EXT GPIO_TypeDef            *GPIOB;
-#endif /*_GPIOB */
-
-#ifdef _GPIOC
-  EXT GPIO_TypeDef            *GPIOC;
-#endif /*_GPIOC */
-
-#ifdef _GPIOD
-  EXT GPIO_TypeDef            *GPIOD;
-#endif /*_GPIOD */
-
-#ifdef _GPIOE
-  EXT GPIO_TypeDef            *GPIOE;
-#endif /*_GPIOE */
-
-#ifdef _GPIOF
-  EXT GPIO_TypeDef            *GPIOF;
-#endif /*_GPIOF */
-
-#ifdef _GPIOG
-  EXT GPIO_TypeDef            *GPIOG;
-#endif /*_GPIOG */
-
-#ifdef _ADC1
-  EXT ADC_TypeDef             *ADC1;
-#endif /*_ADC1 */
-
-#ifdef _ADC2
-  EXT ADC_TypeDef             *ADC2;
-#endif /*_ADC2 */
-
-#ifdef _TIM1
-  EXT TIM_TypeDef             *TIM1;
-#endif /*_TIM1 */
-
-#ifdef _SPI1
-  EXT SPI_TypeDef             *SPI1;
-#endif /*_SPI1 */
-
-#ifdef _TIM8
-  EXT TIM_TypeDef             *TIM8;
-#endif /*_TIM8 */
-
-#ifdef _USART1
-  EXT USART_TypeDef           *USART1;
-#endif /*_USART1 */
-
-#ifdef _ADC3
-  EXT ADC_TypeDef             *ADC3;
-#endif /*_ADC3 */
-
-#ifdef _SDIO
-  EXT SDIO_TypeDef            *SDIO;
-#endif /*_SDIO */
-
-#ifdef _DMA
-  EXT DMA_TypeDef             *DMA1;
-  EXT DMA_TypeDef             *DMA2;
-#endif /*_DMA */
-
-#ifdef _DMA1_Channel1
-  EXT DMA_Channel_TypeDef     *DMA1_Channel1;
-#endif /*_DMA1_Channel1 */
-
-#ifdef _DMA1_Channel2
-  EXT DMA_Channel_TypeDef     *DMA1_Channel2;
-#endif /*_DMA1_Channel2 */
-
-#ifdef _DMA1_Channel3
-  EXT DMA_Channel_TypeDef     *DMA1_Channel3;
-#endif /*_DMA1_Channel3 */
-
-#ifdef _DMA1_Channel4
-  EXT DMA_Channel_TypeDef     *DMA1_Channel4;
-#endif /*_DMA1_Channel4 */
-
-#ifdef _DMA1_Channel5
-  EXT DMA_Channel_TypeDef     *DMA1_Channel5;
-#endif /*_DMA1_Channel5 */
-
-#ifdef _DMA1_Channel6
-  EXT DMA_Channel_TypeDef     *DMA1_Channel6;
-#endif /*_DMA1_Channel6 */
-
-#ifdef _DMA1_Channel7
-  EXT DMA_Channel_TypeDef     *DMA1_Channel7;
-#endif /*_DMA1_Channel7 */
-
-#ifdef _DMA2_Channel1
-  EXT DMA_Channel_TypeDef     *DMA2_Channel1;
-#endif /*_DMA2_Channel1 */
-
-#ifdef _DMA2_Channel2
-  EXT DMA_Channel_TypeDef     *DMA2_Channel2;
-#endif /*_DMA2_Channel2 */
-
-#ifdef _DMA2_Channel3
-  EXT DMA_Channel_TypeDef     *DMA2_Channel3;
-#endif /*_DMA2_Channel3 */
-
-#ifdef _DMA2_Channel4
-  EXT DMA_Channel_TypeDef     *DMA2_Channel4;
-#endif /*_DMA2_Channel4 */
-
-#ifdef _DMA2_Channel5
-  EXT DMA_Channel_TypeDef     *DMA2_Channel5;
-#endif /*_DMA2_Channel5 */
-
-#ifdef _RCC
-  EXT RCC_TypeDef             *RCC;
-#endif /*_RCC */
-
-#ifdef _CRC
-  EXT CRC_TypeDef             *CRC;
-#endif /*_CRC */
-
-#ifdef _FLASH
-  EXT FLASH_TypeDef            *FLASH;
-  EXT OB_TypeDef               *OB;  
-#endif /*_FLASH */
-
-#ifdef _FSMC
-  EXT FSMC_Bank1_TypeDef      *FSMC_Bank1;
-  EXT FSMC_Bank1E_TypeDef     *FSMC_Bank1E;
-  EXT FSMC_Bank2_TypeDef      *FSMC_Bank2;
-  EXT FSMC_Bank3_TypeDef      *FSMC_Bank3;
-  EXT FSMC_Bank4_TypeDef      *FSMC_Bank4;
-#endif /*_FSMC */
-
-#ifdef _DBGMCU
-  EXT DBGMCU_TypeDef          *DBGMCU;
-#endif /*_DBGMCU */
-
-#ifdef _SysTick
-  EXT SysTick_TypeDef         *SysTick;
-#endif /*_SysTick */
-
-#ifdef _NVIC
-  EXT NVIC_TypeDef            *NVIC;
-  EXT SCB_TypeDef             *SCB;
-#endif /*_NVIC */
-
-#endif  /* DEBUG */
-
-/* Exported constants --------------------------------------------------------*/
-/******************************************************************************/
-/*                                                                            */
-/*                          CRC calculation unit                              */
-/*                                                                            */
-/******************************************************************************/
-
-/*******************  Bit definition for CRC_DR register  *********************/
-#define  CRC_DR_DR                           ((u32)0xFFFFFFFF) /* Data register bits */
-
-
-/*******************  Bit definition for CRC_IDR register  ********************/
-#define  CRC_IDR_IDR                         ((u8)0xFF)        /* General-purpose 8-bit data register bits */
-
-
-/********************  Bit definition for CRC_CR register  ********************/
-#define  CRC_CR_RESET                        ((u8)0x01)        /* RESET bit */
-
-
-
-/******************************************************************************/
-/*                                                                            */
-/*                             Power Control                                  */
-/*                                                                            */
-/******************************************************************************/
-
-/********************  Bit definition for PWR_CR register  ********************/
-#define  PWR_CR_LPDS                         ((u16)0x0001)     /* Low-Power Deepsleep */
-#define  PWR_CR_PDDS                         ((u16)0x0002)     /* Power Down Deepsleep */
-#define  PWR_CR_CWUF                         ((u16)0x0004)     /* Clear Wakeup Flag */
-#define  PWR_CR_CSBF                         ((u16)0x0008)     /* Clear Standby Flag */
-#define  PWR_CR_PVDE                         ((u16)0x0010)     /* Power Voltage Detector Enable */
-
-#define  PWR_CR_PLS                          ((u16)0x00E0)     /* PLS[2:0] bits (PVD Level Selection) */
-#define  PWR_CR_PLS_0                        ((u16)0x0020)     /* Bit 0 */
-#define  PWR_CR_PLS_1                        ((u16)0x0040)     /* Bit 1 */
-#define  PWR_CR_PLS_2                        ((u16)0x0080)     /* Bit 2 */
-
-/* PVD level configuration */
-#define  PWR_CR_PLS_2V2                      ((u16)0x0000)     /* PVD level 2.2V */
-#define  PWR_CR_PLS_2V3                      ((u16)0x0020)     /* PVD level 2.3V */
-#define  PWR_CR_PLS_2V4                      ((u16)0x0040)     /* PVD level 2.4V */
-#define  PWR_CR_PLS_2V5                      ((u16)0x0060)     /* PVD level 2.5V */
-#define  PWR_CR_PLS_2V6                      ((u16)0x0080)     /* PVD level 2.6V */
-#define  PWR_CR_PLS_2V7                      ((u16)0x00A0)     /* PVD level 2.7V */
-#define  PWR_CR_PLS_2V8                      ((u16)0x00C0)     /* PVD level 2.8V */
-#define  PWR_CR_PLS_2V9                      ((u16)0x00E0)     /* PVD level 2.9V */
-
-#define  PWR_CR_DBP                          ((u16)0x0100)     /* Disable Backup Domain write protection */
-
-
-/*******************  Bit definition for PWR_CSR register  ********************/
-#define  PWR_CSR_WUF                         ((u16)0x0001)     /* Wakeup Flag */
-#define  PWR_CSR_SBF                         ((u16)0x0002)     /* Standby Flag */
-#define  PWR_CSR_PVDO                        ((u16)0x0004)     /* PVD Output */
-#define  PWR_CSR_EWUP                        ((u16)0x0100)     /* Enable WKUP pin */
-
-
-
-/******************************************************************************/
-/*                                                                            */
-/*                            Backup registers                                */
-/*                                                                            */
-/******************************************************************************/
-
-/*******************  Bit definition for BKP_DR1 register  ********************/
-#define  BKP_DR1_D                           ((u16)0xFFFF)     /* Backup data */
-
-
-/*******************  Bit definition for BKP_DR2 register  ********************/
-#define  BKP_DR2_D                           ((u16)0xFFFF)     /* Backup data */
-
-
-/*******************  Bit definition for BKP_DR3 register  ********************/
-#define  BKP_DR3_D                           ((u16)0xFFFF)     /* Backup data */
-
-
-/*******************  Bit definition for BKP_DR4 register  ********************/
-#define  BKP_DR4_D                           ((u16)0xFFFF)     /* Backup data */
-
-
-/*******************  Bit definition for BKP_DR5 register  ********************/
-#define  BKP_DR5_D                           ((u16)0xFFFF)     /* Backup data */
-
-
-/*******************  Bit definition for BKP_DR6 register  ********************/
-#define  BKP_DR6_D                           ((u16)0xFFFF)     /* Backup data */
-
-
-/*******************  Bit definition for BKP_DR7 register  ********************/
-#define  BKP_DR7_D                           ((u16)0xFFFF)     /* Backup data */
-
-
-/*******************  Bit definition for BKP_DR8 register  ********************/
-#define  BKP_DR8_D                           ((u16)0xFFFF)     /* Backup data */
-
-
-/*******************  Bit definition for BKP_DR9 register  ********************/
-#define  BKP_DR9_D                           ((u16)0xFFFF)     /* Backup data */
-
-
-/*******************  Bit definition for BKP_DR10 register  *******************/
-#define  BKP_DR10_D                          ((u16)0xFFFF)     /* Backup data */
-
-
-/*******************  Bit definition for BKP_DR11 register  *******************/
-#define  BKP_DR11_D                          ((u16)0xFFFF)     /* Backup data */
-
-
-/*******************  Bit definition for BKP_DR12 register  *******************/
-#define  BKP_DR12_D                          ((u16)0xFFFF)     /* Backup data */
-
-
-/*******************  Bit definition for BKP_DR13 register  *******************/
-#define  BKP_DR13_D                          ((u16)0xFFFF)     /* Backup data */
-
-
-/*******************  Bit definition for BKP_DR14 register  *******************/
-#define  BKP_DR14_D                          ((u16)0xFFFF)     /* Backup data */
-
-
-/*******************  Bit definition for BKP_DR15 register  *******************/
-#define  BKP_DR15_D                          ((u16)0xFFFF)     /* Backup data */
-
-
-/*******************  Bit definition for BKP_DR16 register  *******************/
-#define  BKP_DR16_D                          ((u16)0xFFFF)     /* Backup data */
-
-
-/*******************  Bit definition for BKP_DR17 register  *******************/
-#define  BKP_DR17_D                          ((u16)0xFFFF)     /* Backup data */
-
-
-/******************  Bit definition for BKP_DR18 register  ********************/
-#define  BKP_DR18_D                          ((u16)0xFFFF)     /* Backup data */
-
-
-/*******************  Bit definition for BKP_DR19 register  *******************/
-#define  BKP_DR19_D                          ((u16)0xFFFF)     /* Backup data */
-
-
-/*******************  Bit definition for BKP_DR20 register  *******************/
-#define  BKP_DR20_D                          ((u16)0xFFFF)     /* Backup data */
-
-
-/*******************  Bit definition for BKP_DR21 register  *******************/
-#define  BKP_DR21_D                          ((u16)0xFFFF)     /* Backup data */
-
-
-/*******************  Bit definition for BKP_DR22 register  *******************/
-#define  BKP_DR22_D                          ((u16)0xFFFF)     /* Backup data */
-
-
-/*******************  Bit definition for BKP_DR23 register  *******************/
-#define  BKP_DR23_D                          ((u16)0xFFFF)     /* Backup data */
-
-
-/*******************  Bit definition for BKP_DR24 register  *******************/
-#define  BKP_DR24_D                          ((u16)0xFFFF)     /* Backup data */
-
-
-/*******************  Bit definition for BKP_DR25 register  *******************/
-#define  BKP_DR25_D                          ((u16)0xFFFF)     /* Backup data */
-
-
-/*******************  Bit definition for BKP_DR26 register  *******************/
-#define  BKP_DR26_D                          ((u16)0xFFFF)     /* Backup data */
-
-
-/*******************  Bit definition for BKP_DR27 register  *******************/
-#define  BKP_DR27_D                          ((u16)0xFFFF)     /* Backup data */
-
-
-/*******************  Bit definition for BKP_DR28 register  *******************/
-#define  BKP_DR28_D                          ((u16)0xFFFF)     /* Backup data */
-
-
-/*******************  Bit definition for BKP_DR29 register  *******************/
-#define  BKP_DR29_D                          ((u16)0xFFFF)     /* Backup data */
-
-
-/*******************  Bit definition for BKP_DR30 register  *******************/
-#define  BKP_DR30_D                          ((u16)0xFFFF)     /* Backup data */
-
-
-/*******************  Bit definition for BKP_DR31 register  *******************/
-#define  BKP_DR31_D                          ((u16)0xFFFF)     /* Backup data */
-
-
-/*******************  Bit definition for BKP_DR32 register  *******************/
-#define  BKP_DR32_D                          ((u16)0xFFFF)     /* Backup data */
-
-
-/*******************  Bit definition for BKP_DR33 register  *******************/
-#define  BKP_DR33_D                          ((u16)0xFFFF)     /* Backup data */
-
-
-/*******************  Bit definition for BKP_DR34 register  *******************/
-#define  BKP_DR34_D                          ((u16)0xFFFF)     /* Backup data */
-
-
-/*******************  Bit definition for BKP_DR35 register  *******************/
-#define  BKP_DR35_D                          ((u16)0xFFFF)     /* Backup data */
-
-
-/*******************  Bit definition for BKP_DR36 register  *******************/
-#define  BKP_DR36_D                          ((u16)0xFFFF)     /* Backup data */
-
-
-/*******************  Bit definition for BKP_DR37 register  *******************/
-#define  BKP_DR37_D                          ((u16)0xFFFF)     /* Backup data */
-
-
-/*******************  Bit definition for BKP_DR38 register  *******************/
-#define  BKP_DR38_D                          ((u16)0xFFFF)     /* Backup data */
-
-
-/*******************  Bit definition for BKP_DR39 register  *******************/
-#define  BKP_DR39_D                          ((u16)0xFFFF)     /* Backup data */
-
-
-/*******************  Bit definition for BKP_DR40 register  *******************/
-#define  BKP_DR40_D                          ((u16)0xFFFF)     /* Backup data */
-
-
-/*******************  Bit definition for BKP_DR41 register  *******************/
-#define  BKP_DR41_D                          ((u16)0xFFFF)     /* Backup data */
-
-
-/*******************  Bit definition for BKP_DR42 register  *******************/
-#define  BKP_DR42_D                          ((u16)0xFFFF)     /* Backup data */
-
-
-/******************  Bit definition for BKP_RTCCR register  *******************/
-#define  BKP_RTCCR_CAL                       ((u16)0x007F)     /* Calibration value */
-#define  BKP_RTCCR_CCO                       ((u16)0x0080)     /* Calibration Clock Output */
-#define  BKP_RTCCR_ASOE                      ((u16)0x0100)     /* Alarm or Second Output Enable */
-#define  BKP_RTCCR_ASOS                      ((u16)0x0200)     /* Alarm or Second Output Selection */
-
-
-/********************  Bit definition for BKP_CR register  ********************/
-#define  BKP_CR_TPE                          ((u8)0x01)        /* TAMPER pin enable */
-#define  BKP_CR_TPAL                         ((u8)0x02)        /* TAMPER pin active level */
-
-
-/*******************  Bit definition for BKP_CSR register  ********************/
-#define  BKP_CSR_CTE                         ((u16)0x0001)     /* Clear Tamper event */
-#define  BKP_CSR_CTI                         ((u16)0x0002)     /* Clear Tamper Interrupt */
-#define  BKP_CSR_TPIE                        ((u16)0x0004)     /* TAMPER Pin interrupt enable */
-#define  BKP_CSR_TEF                         ((u16)0x0100)     /* Tamper Event Flag */
-#define  BKP_CSR_TIF                         ((u16)0x0200)     /* Tamper Interrupt Flag */
-
-
-
-/******************************************************************************/
-/*                                                                            */
-/*                         Reset and Clock Control                            */
-/*                                                                            */
-/******************************************************************************/
-
-
-/********************  Bit definition for RCC_CR register  ********************/
-#define  RCC_CR_HSION                        ((u32)0x00000001)        /* Internal High Speed clock enable */
-#define  RCC_CR_HSIRDY                       ((u32)0x00000002)        /* Internal High Speed clock ready flag */
-#define  RCC_CR_HSITRIM                      ((u32)0x000000F8)        /* Internal High Speed clock trimming */
-#define  RCC_CR_HSICAL                       ((u32)0x0000FF00)        /* Internal High Speed clock Calibration */
-#define  RCC_CR_HSEON                        ((u32)0x00010000)        /* External High Speed clock enable */
-#define  RCC_CR_HSERDY                       ((u32)0x00020000)        /* External High Speed clock ready flag */
-#define  RCC_CR_HSEBYP                       ((u32)0x00040000)        /* External High Speed clock Bypass */
-#define  RCC_CR_CSSON                        ((u32)0x00080000)        /* Clock Security System enable */
-#define  RCC_CR_PLLON                        ((u32)0x01000000)        /* PLL enable */
-#define  RCC_CR_PLLRDY                       ((u32)0x02000000)        /* PLL clock ready flag */
-
-
-/*******************  Bit definition for RCC_CFGR register  *******************/
-#define  RCC_CFGR_SW                         ((u32)0x00000003)        /* SW[1:0] bits (System clock Switch) */
-#define  RCC_CFGR_SW_0                       ((u32)0x00000001)        /* Bit 0 */
-#define  RCC_CFGR_SW_1                       ((u32)0x00000002)        /* Bit 1 */
-
-/* SW configuration */
-#define  RCC_CFGR_SW_HSI                     ((u32)0x00000000)        /* HSI selected as system clock */
-#define  RCC_CFGR_SW_HSE                     ((u32)0x00000001)        /* HSE selected as system clock */
-#define  RCC_CFGR_SW_PLL                     ((u32)0x00000002)        /* PLL selected as system clock */
-
-#define  RCC_CFGR_SWS                        ((u32)0x0000000C)        /* SWS[1:0] bits (System Clock Switch Status) */
-#define  RCC_CFGR_SWS_0                      ((u32)0x00000004)        /* Bit 0 */
-#define  RCC_CFGR_SWS_1                      ((u32)0x00000008)        /* Bit 1 */
-
-/* SWS configuration */
-#define  RCC_CFGR_SWS_HSI                    ((u32)0x00000000)        /* HSI oscillator used as system clock */
-#define  RCC_CFGR_SWS_HSE                    ((u32)0x00000004)        /* HSE oscillator used as system clock */
-#define  RCC_CFGR_SWS_PLL                    ((u32)0x00000008)        /* PLL used as system clock */
-
-#define  RCC_CFGR_HPRE                       ((u32)0x000000F0)        /* HPRE[3:0] bits (AHB prescaler) */
-#define  RCC_CFGR_HPRE_0                     ((u32)0x00000010)        /* Bit 0 */
-#define  RCC_CFGR_HPRE_1                     ((u32)0x00000020)        /* Bit 1 */
-#define  RCC_CFGR_HPRE_2                     ((u32)0x00000040)        /* Bit 2 */
-#define  RCC_CFGR_HPRE_3                     ((u32)0x00000080)        /* Bit 3 */
-
-/* HPRE configuration */
-#define  RCC_CFGR_HPRE_DIV1                  ((u32)0x00000000)        /* SYSCLK not divided */
-#define  RCC_CFGR_HPRE_DIV2                  ((u32)0x00000080)        /* SYSCLK divided by 2 */
-#define  RCC_CFGR_HPRE_DIV4                  ((u32)0x00000090)        /* SYSCLK divided by 4 */
-#define  RCC_CFGR_HPRE_DIV8                  ((u32)0x000000A0)        /* SYSCLK divided by 8 */
-#define  RCC_CFGR_HPRE_DIV16                 ((u32)0x000000B0)        /* SYSCLK divided by 16 */
-#define  RCC_CFGR_HPRE_DIV64                 ((u32)0x000000C0)        /* SYSCLK divided by 64 */
-#define  RCC_CFGR_HPRE_DIV128                ((u32)0x000000D0)        /* SYSCLK divided by 128 */
-#define  RCC_CFGR_HPRE_DIV256                ((u32)0x000000E0)        /* SYSCLK divided by 256 */
-#define  RCC_CFGR_HPRE_DIV512                ((u32)0x000000F0)        /* SYSCLK divided by 512 */
-
-#define  RCC_CFGR_PPRE1                      ((u32)0x00000700)        /* PRE1[2:0] bits (APB1 prescaler) */
-#define  RCC_CFGR_PPRE1_0                    ((u32)0x00000100)        /* Bit 0 */
-#define  RCC_CFGR_PPRE1_1                    ((u32)0x00000200)        /* Bit 1 */
-#define  RCC_CFGR_PPRE1_2                    ((u32)0x00000400)        /* Bit 2 */
-
-/* PPRE1 configuration */
-#define  RCC_CFGR_PPRE1_DIV1                 ((u32)0x00000000)        /* HCLK not divided */
-#define  RCC_CFGR_PPRE1_DIV2                 ((u32)0x00000400)        /* HCLK divided by 2 */
-#define  RCC_CFGR_PPRE1_DIV4                 ((u32)0x00000500)        /* HCLK divided by 4 */
-#define  RCC_CFGR_PPRE1_DIV8                 ((u32)0x00000600)        /* HCLK divided by 8 */
-#define  RCC_CFGR_PPRE1_DIV16                ((u32)0x00000700)        /* HCLK divided by 16 */
-
-#define  RCC_CFGR_PPRE2                      ((u32)0x00003800)        /* PRE2[2:0] bits (APB2 prescaler) */
-#define  RCC_CFGR_PPRE2_0                    ((u32)0x00000800)        /* Bit 0 */
-#define  RCC_CFGR_PPRE2_1                    ((u32)0x00001000)        /* Bit 1 */
-#define  RCC_CFGR_PPRE2_2                    ((u32)0x00002000)        /* Bit 2 */
-
-/* PPRE2 configuration */
-#define  RCC_CFGR_PPRE2_DIV1                 ((u32)0x00000000)        /* HCLK not divided */
-#define  RCC_CFGR_PPRE2_DIV2                 ((u32)0x00002000)        /* HCLK divided by 2 */
-#define  RCC_CFGR_PPRE2_DIV4                 ((u32)0x00002800)        /* HCLK divided by 4 */
-#define  RCC_CFGR_PPRE2_DIV8                 ((u32)0x00003000)        /* HCLK divided by 8 */
-#define  RCC_CFGR_PPRE2_DIV16                ((u32)0x00003800)        /* HCLK divided by 16 */
-
-#define  RCC_CFGR_ADCPRE                     ((u32)0x0000C000)        /* ADCPRE[1:0] bits (ADC prescaler) */
-#define  RCC_CFGR_ADCPRE_0                   ((u32)0x00004000)        /* Bit 0 */
-#define  RCC_CFGR_ADCPRE_1                   ((u32)0x00008000)        /* Bit 1 */
-
-/* ADCPPRE configuration */
-#define  RCC_CFGR_ADCPRE_DIV2                ((u32)0x00000000)        /* PCLK2 divided by 2 */
-#define  RCC_CFGR_ADCPRE_DIV4                ((u32)0x00004000)        /* PCLK2 divided by 4 */
-#define  RCC_CFGR_ADCPRE_DIV6                ((u32)0x00008000)        /* PCLK2 divided by 6 */
-#define  RCC_CFGR_ADCPRE_DIV8                ((u32)0x0000C000)        /* PCLK2 divided by 8 */
-
-#define  RCC_CFGR_PLLSRC                     ((u32)0x00010000)        /* PLL entry clock source */
-#define  RCC_CFGR_PLLXTPRE                   ((u32)0x00020000)        /* HSE divider for PLL entry */
-
-#define  RCC_CFGR_PLLMULL                    ((u32)0x003C0000)        /* PLLMUL[3:0] bits (PLL multiplication factor) */
-#define  RCC_CFGR_PLLMULL_0                  ((u32)0x00040000)        /* Bit 0 */
-#define  RCC_CFGR_PLLMULL_1                  ((u32)0x00080000)        /* Bit 1 */
-#define  RCC_CFGR_PLLMULL_2                  ((u32)0x00100000)        /* Bit 2 */
-#define  RCC_CFGR_PLLMULL_3                  ((u32)0x00200000)        /* Bit 3 */
-
-/* PLLMUL configuration */
-#define  RCC_CFGR_PLLMULL2                   ((u32)0x00000000)        /* PLL input clock*2 */
-#define  RCC_CFGR_PLLMULL3                   ((u32)0x00040000)        /* PLL input clock*3 */
-#define  RCC_CFGR_PLLMULL4                   ((u32)0x00080000)        /* PLL input clock*4 */
-#define  RCC_CFGR_PLLMULL5                   ((u32)0x000C0000)        /* PLL input clock*5 */
-#define  RCC_CFGR_PLLMULL6                   ((u32)0x00100000)        /* PLL input clock*6 */
-#define  RCC_CFGR_PLLMULL7                   ((u32)0x00140000)        /* PLL input clock*7 */
-#define  RCC_CFGR_PLLMULL8                   ((u32)0x00180000)        /* PLL input clock*8 */
-#define  RCC_CFGR_PLLMULL9                   ((u32)0x001C0000)        /* PLL input clock*9 */
-#define  RCC_CFGR_PLLMULL10                  ((u32)0x00200000)        /* PLL input clock10 */
-#define  RCC_CFGR_PLLMULL11                  ((u32)0x00240000)        /* PLL input clock*11 */
-#define  RCC_CFGR_PLLMULL12                  ((u32)0x00280000)        /* PLL input clock*12 */
-#define  RCC_CFGR_PLLMULL13                  ((u32)0x002C0000)        /* PLL input clock*13 */
-#define  RCC_CFGR_PLLMULL14                  ((u32)0x00300000)        /* PLL input clock*14 */
-#define  RCC_CFGR_PLLMULL15                  ((u32)0x00340000)        /* PLL input clock*15 */
-#define  RCC_CFGR_PLLMULL16                  ((u32)0x00380000)        /* PLL input clock*16 */
-
-#define  RCC_CFGR_USBPRE                     ((u32)0x00400000)        /* USB prescaler */
-
-#define  RCC_CFGR_MCO                        ((u32)0x07000000)        /* MCO[2:0] bits (Microcontroller Clock Output) */
-#define  RCC_CFGR_MCO_0                      ((u32)0x01000000)        /* Bit 0 */
-#define  RCC_CFGR_MCO_1                      ((u32)0x02000000)        /* Bit 1 */
-#define  RCC_CFGR_MCO_2                      ((u32)0x04000000)        /* Bit 2 */
-
-/* MCO configuration */
-#define  RCC_CFGR_MCO_NOCLOCK                ((u32)0x00000000)        /* No clock */
-#define  RCC_CFGR_MCO_SYSCLK                 ((u32)0x04000000)        /* System clock selected */
-#define  RCC_CFGR_MCO_HSI                    ((u32)0x05000000)        /* Internal 8 MHz RC oscillator clock selected */
-#define  RCC_CFGR_MCO_HSE                    ((u32)0x06000000)        /* External 1-25 MHz oscillator clock selected */
-#define  RCC_CFGR_MCO_PLL                    ((u32)0x07000000)        /* PLL clock divided by 2 selected*/
-
-
-/*******************  Bit definition for RCC_CIR register  ********************/
-#define  RCC_CIR_LSIRDYF                     ((u32)0x00000001)        /* LSI Ready Interrupt flag */
-#define  RCC_CIR_LSERDYF                     ((u32)0x00000002)        /* LSE Ready Interrupt flag */
-#define  RCC_CIR_HSIRDYF                     ((u32)0x00000004)        /* HSI Ready Interrupt flag */
-#define  RCC_CIR_HSERDYF                     ((u32)0x00000008)        /* HSE Ready Interrupt flag */
-#define  RCC_CIR_PLLRDYF                     ((u32)0x00000010)        /* PLL Ready Interrupt flag */
-#define  RCC_CIR_CSSF                        ((u32)0x00000080)        /* Clock Security System Interrupt flag */
-#define  RCC_CIR_LSIRDYIE                    ((u32)0x00000100)        /* LSI Ready Interrupt Enable */
-#define  RCC_CIR_LSERDYIE                    ((u32)0x00000200)        /* LSE Ready Interrupt Enable */
-#define  RCC_CIR_HSIRDYIE                    ((u32)0x00000400)        /* HSI Ready Interrupt Enable */
-#define  RCC_CIR_HSERDYIE                    ((u32)0x00000800)        /* HSE Ready Interrupt Enable */
-#define  RCC_CIR_PLLRDYIE                    ((u32)0x00001000)        /* PLL Ready Interrupt Enable */
-#define  RCC_CIR_LSIRDYC                     ((u32)0x00010000)        /* LSI Ready Interrupt Clear */
-#define  RCC_CIR_LSERDYC                     ((u32)0x00020000)        /* LSE Ready Interrupt Clear */
-#define  RCC_CIR_HSIRDYC                     ((u32)0x00040000)        /* HSI Ready Interrupt Clear */
-#define  RCC_CIR_HSERDYC                     ((u32)0x00080000)        /* HSE Ready Interrupt Clear */
-#define  RCC_CIR_PLLRDYC                     ((u32)0x00100000)        /* PLL Ready Interrupt Clear */
-#define  RCC_CIR_CSSC                        ((u32)0x00800000)        /* Clock Security System Interrupt Clear */
-
-
-/*****************  Bit definition for RCC_APB2RSTR register  *****************/
-#define  RCC_APB2RSTR_AFIORST                ((u16)0x0001)            /* Alternate Function I/O reset */
-#define  RCC_APB2RSTR_IOPARST                ((u16)0x0004)            /* I/O port A reset */
-#define  RCC_APB2RSTR_IOPBRST                ((u16)0x0008)            /* IO port B reset */
-#define  RCC_APB2RSTR_IOPCRST                ((u16)0x0010)            /* IO port C reset */
-#define  RCC_APB2RSTR_IOPDRST                ((u16)0x0020)            /* IO port D reset */
-#define  RCC_APB2RSTR_IOPERST                ((u16)0x0040)            /* IO port E reset */
-#define  RCC_APB2RSTR_IOPFRST                ((u16)0x0080)            /* IO port F reset */
-#define  RCC_APB2RSTR_IOPGRST                ((u16)0x0100)            /* IO port G reset */
-#define  RCC_APB2RSTR_ADC1RST                ((u16)0x0200)            /* ADC 1 interface reset */
-#define  RCC_APB2RSTR_ADC2RST                ((u16)0x0400)            /* ADC 2 interface reset */
-#define  RCC_APB2RSTR_TIM1RST                ((u16)0x0800)            /* TIM1 Timer reset */
-#define  RCC_APB2RSTR_SPI1RST                ((u16)0x1000)            /* SPI 1 reset */
-#define  RCC_APB2RSTR_TIM8RST                ((u16)0x2000)            /* TIM8 Timer reset */
-#define  RCC_APB2RSTR_USART1RST              ((u16)0x4000)            /* USART1 reset */
-#define  RCC_APB2RSTR_ADC3RST                ((u16)0x8000)            /* ADC3 interface reset */
-
-
-/*****************  Bit definition for RCC_APB1RSTR register  *****************/
-#define  RCC_APB1RSTR_TIM2RST                ((u32)0x00000001)        /* Timer 2 reset */
-#define  RCC_APB1RSTR_TIM3RST                ((u32)0x00000002)        /* Timer 3 reset */
-#define  RCC_APB1RSTR_TIM4RST                ((u32)0x00000004)        /* Timer 4 reset */
-#define  RCC_APB1RSTR_TIM5RST                ((u32)0x00000008)        /* Timer 5 reset */
-#define  RCC_APB1RSTR_TIM6RST                ((u32)0x00000010)        /* Timer 6 reset */
-#define  RCC_APB1RSTR_TIM7RST                ((u32)0x00000020)        /* Timer 7 reset */
-#define  RCC_APB1RSTR_WWDGRST                ((u32)0x00000800)        /* Window Watchdog reset */
-#define  RCC_APB1RSTR_SPI2RST                ((u32)0x00004000)        /* SPI 2 reset */
-#define  RCC_APB1RSTR_SPI3RST                ((u32)0x00008000)        /* SPI 3 reset */
-#define  RCC_APB1RSTR_USART2RST              ((u32)0x00020000)        /* USART 2 reset */
-#define  RCC_APB1RSTR_USART3RST              ((u32)0x00040000)        /* RUSART 3 reset */
-#define  RCC_APB1RSTR_UART4RST               ((u32)0x00080000)        /* USART 4 reset */
-#define  RCC_APB1RSTR_UART5RST               ((u32)0x00100000)        /* USART 5 reset */
-#define  RCC_APB1RSTR_I2C1RST                ((u32)0x00200000)        /* I2C 1 reset */
-#define  RCC_APB1RSTR_I2C2RST                ((u32)0x00400000)        /* I2C 2 reset */
-#define  RCC_APB1RSTR_USBRST                 ((u32)0x00800000)        /* USB reset */
-#define  RCC_APB1RSTR_CANRST                 ((u32)0x02000000)        /* CAN reset */
-#define  RCC_APB1RSTR_BKPRST                 ((u32)0x08000000)        /* Backup interface reset */
-#define  RCC_APB1RSTR_PWRRST                 ((u32)0x10000000)        /* Power interface reset */
-#define  RCC_APB1RSTR_DACRST                 ((u32)0x20000000)        /* DAC interface reset */
-
-
-/******************  Bit definition for RCC_AHBENR register  ******************/
-#define  RCC_AHBENR_DMA1EN                   ((u16)0x0001)            /* DMA1 clock enable */
-#define  RCC_AHBENR_DMA2EN                   ((u16)0x0002)            /* DMA2 clock enable */
-#define  RCC_AHBENR_SRAMEN                   ((u16)0x0004)            /* SRAM interface clock enable */
-#define  RCC_AHBENR_FLITFEN                  ((u16)0x0010)            /* FLITF clock enable */
-#define  RCC_AHBENR_CRCEN                    ((u16)0x0040)            /* CRC clock enable */
-#define  RCC_AHBENR_FSMCEN                   ((u16)0x0100)            /* FSMC clock enable */
-#define  RCC_AHBENR_SDIOEN                   ((u16)0x0400)            /* SDIO clock enable */
-
-
-/******************  Bit definition for RCC_APB2ENR register  *****************/
-#define  RCC_APB2ENR_AFIOEN                  ((u16)0x0001)            /* Alternate Function I/O clock enable */
-#define  RCC_APB2ENR_IOPAEN                  ((u16)0x0004)            /* I/O port A clock enable */
-#define  RCC_APB2ENR_IOPBEN                  ((u16)0x0008)            /* I/O port B clock enable */
-#define  RCC_APB2ENR_IOPCEN                  ((u16)0x0010)            /* I/O port C clock enable */
-#define  RCC_APB2ENR_IOPDEN                  ((u16)0x0020)            /* I/O port D clock enable */
-#define  RCC_APB2ENR_IOPEEN                  ((u16)0x0040)            /* I/O port E clock enable */
-#define  RCC_APB2ENR_IOPFEN                  ((u16)0x0080)            /* I/O port F clock enable */
-#define  RCC_APB2ENR_IOPGEN                  ((u16)0x0100)            /* I/O port G clock enable */
-#define  RCC_APB2ENR_ADC1EN                  ((u16)0x0200)            /* ADC 1 interface clock enable */
-#define  RCC_APB2ENR_ADC2EN                  ((u16)0x0400)            /* ADC 2 interface clock enable */
-#define  RCC_APB2ENR_TIM1EN                  ((u16)0x0800)            /* TIM1 Timer clock enable */
-#define  RCC_APB2ENR_SPI1EN                  ((u16)0x1000)            /* SPI 1 clock enable */
-#define  RCC_APB2ENR_TIM8EN                  ((u16)0x2000)            /* TIM8 Timer clock enable */
-#define  RCC_APB2ENR_USART1EN                ((u16)0x4000)            /* USART1 clock enable */
-#define  RCC_APB2ENR_ADC3EN                  ((u16)0x8000)            /* DMA1 clock enable */
-
-
-/*****************  Bit definition for RCC_APB1ENR register  ******************/
-#define  RCC_APB1ENR_TIM2EN                  ((u32)0x00000001)        /* Timer 2 clock enabled*/
-#define  RCC_APB1ENR_TIM3EN                  ((u32)0x00000002)        /* Timer 3 clock enable */
-#define  RCC_APB1ENR_TIM4EN                  ((u32)0x00000004)        /* Timer 4 clock enable */
-#define  RCC_APB1ENR_TIM5EN                  ((u32)0x00000008)        /* Timer 5 clock enable */
-#define  RCC_APB1ENR_TIM6EN                  ((u32)0x00000010)        /* Timer 6 clock enable */
-#define  RCC_APB1ENR_TIM7EN                  ((u32)0x00000020)        /* Timer 7 clock enable */
-#define  RCC_APB1ENR_WWDGEN                  ((u32)0x00000800)        /* Window Watchdog clock enable */
-#define  RCC_APB1ENR_SPI2EN                  ((u32)0x00004000)        /* SPI 2 clock enable */
-#define  RCC_APB1ENR_SPI3EN                  ((u32)0x00008000)        /* SPI 3 clock enable */
-#define  RCC_APB1ENR_USART2EN                ((u32)0x00020000)        /* USART 2 clock enable */
-#define  RCC_APB1ENR_USART3EN                ((u32)0x00040000)        /* USART 3 clock enable */
-#define  RCC_APB1ENR_UART4EN                 ((u32)0x00080000)        /* USART 4 clock enable */
-#define  RCC_APB1ENR_UART5EN                 ((u32)0x00100000)        /* USART 5 clock enable */
-#define  RCC_APB1ENR_I2C1EN                  ((u32)0x00200000)        /* I2C 1 clock enable */
-#define  RCC_APB1ENR_I2C2EN                  ((u32)0x00400000)        /* I2C 2 clock enable */
-#define  RCC_APB1ENR_USBEN                   ((u32)0x00800000)        /* USB clock enable */
-#define  RCC_APB1ENR_CANEN                   ((u32)0x02000000)        /* CAN clock enable */
-#define  RCC_APB1ENR_BKPEN                   ((u32)0x08000000)        /* Backup interface clock enable */
-#define  RCC_APB1ENR_PWREN                   ((u32)0x10000000)        /* Power interface clock enable */
-#define  RCC_APB1ENR_DACEN                   ((u32)0x20000000)        /* DAC interface clock enable */
-
-
-/*******************  Bit definition for RCC_BDCR register  *******************/
-#define  RCC_BDCR_LSEON                      ((u32)0x00000001)        /* External Low Speed oscillator enable */
-#define  RCC_BDCR_LSERDY                     ((u32)0x00000002)        /* External Low Speed oscillator Ready */
-#define  RCC_BDCR_LSEBYP                     ((u32)0x00000004)        /* External Low Speed oscillator Bypass */
-
-#define  RCC_BDCR_RTCSEL                     ((u32)0x00000300)        /* RTCSEL[1:0] bits (RTC clock source selection) */
-#define  RCC_BDCR_RTCSEL_0                   ((u32)0x00000100)        /* Bit 0 */
-#define  RCC_BDCR_RTCSEL_1                   ((u32)0x00000200)        /* Bit 1 */
-/* RTC congiguration */
-#define  RCC_BDCR_RTCSEL_NOCLOCK             ((u32)0x00000000)        /* No clock */
-#define  RCC_BDCR_RTCSEL_LSE                 ((u32)0x00000100)        /* LSE oscillator clock used as RTC clock */
-#define  RCC_BDCR_RTCSEL_LSI                 ((u32)0x00000200)        /* LSI oscillator clock used as RTC clock */
-#define  RCC_BDCR_RTCSEL_HSE                 ((u32)0x00000300)        /* HSE oscillator clock divided by 128 used as RTC clock */
-
-#define  RCC_BDCR_RTCEN                      ((u32)0x00008000)        /* RTC clock enable */
-#define  RCC_BDCR_BDRST                      ((u32)0x00010000)        /* Backup domain software reset  */
-
-
-/*******************  Bit definition for RCC_CSR register  ********************/  
-#define  RCC_CSR_LSION                       ((u32)0x00000001)        /* Internal Low Speed oscillator enable */
-#define  RCC_CSR_LSIRDY                      ((u32)0x00000002)        /* Internal Low Speed oscillator Ready */
-#define  RCC_CSR_RMVF                        ((u32)0x01000000)        /* Remove reset flag */
-#define  RCC_CSR_PINRSTF                     ((u32)0x04000000)        /* PIN reset flag */
-#define  RCC_CSR_PORRSTF                     ((u32)0x08000000)        /* POR/PDR reset flag */
-#define  RCC_CSR_SFTRSTF                     ((u32)0x10000000)        /* Software Reset flag */
-#define  RCC_CSR_IWDGRSTF                    ((u32)0x20000000)        /* Independent Watchdog reset flag */
-#define  RCC_CSR_WWDGRSTF                    ((u32)0x40000000)        /* Window watchdog reset flag */
-#define  RCC_CSR_LPWRRSTF                    ((u32)0x80000000)        /* Low-Power reset flag */
-
-
-
-/******************************************************************************/
-/*                                                                            */
-/*                General Purpose and Alternate Function IO                   */
-/*                                                                            */
-/******************************************************************************/
-
-/*******************  Bit definition for GPIO_CRL register  *******************/
-#define  GPIO_CRL_MODE                       ((u32)0x33333333)        /* Port x mode bits */
-
-#define  GPIO_CRL_MODE0                      ((u32)0x00000003)        /* MODE0[1:0] bits (Port x mode bits, pin 0) */
-#define  GPIO_CRL_MODE0_0                    ((u32)0x00000001)        /* Bit 0 */
-#define  GPIO_CRL_MODE0_1                    ((u32)0x00000002)        /* Bit 1 */
-
-#define  GPIO_CRL_MODE1                      ((u32)0x00000030)        /* MODE1[1:0] bits (Port x mode bits, pin 1) */
-#define  GPIO_CRL_MODE1_0                    ((u32)0x00000010)        /* Bit 0 */
-#define  GPIO_CRL_MODE1_1                    ((u32)0x00000020)        /* Bit 1 */
-
-#define  GPIO_CRL_MODE2                      ((u32)0x00000300)        /* MODE2[1:0] bits (Port x mode bits, pin 2) */
-#define  GPIO_CRL_MODE2_0                    ((u32)0x00000100)        /* Bit 0 */
-#define  GPIO_CRL_MODE2_1                    ((u32)0x00000200)        /* Bit 1 */
-
-#define  GPIO_CRL_MODE3                      ((u32)0x00003000)        /* MODE3[1:0] bits (Port x mode bits, pin 3) */
-#define  GPIO_CRL_MODE3_0                    ((u32)0x00001000)        /* Bit 0 */
-#define  GPIO_CRL_MODE3_1                    ((u32)0x00002000)        /* Bit 1 */
-
-#define  GPIO_CRL_MODE4                      ((u32)0x00030000)        /* MODE4[1:0] bits (Port x mode bits, pin 4) */
-#define  GPIO_CRL_MODE4_0                    ((u32)0x00010000)        /* Bit 0 */
-#define  GPIO_CRL_MODE4_1                    ((u32)0x00020000)        /* Bit 1 */
-
-#define  GPIO_CRL_MODE5                      ((u32)0x00300000)        /* MODE5[1:0] bits (Port x mode bits, pin 5) */
-#define  GPIO_CRL_MODE5_0                    ((u32)0x00100000)        /* Bit 0 */
-#define  GPIO_CRL_MODE5_1                    ((u32)0x00200000)        /* Bit 1 */
-
-#define  GPIO_CRL_MODE6                      ((u32)0x03000000)        /* MODE6[1:0] bits (Port x mode bits, pin 6) */
-#define  GPIO_CRL_MODE6_0                    ((u32)0x01000000)        /* Bit 0 */
-#define  GPIO_CRL_MODE6_1                    ((u32)0x02000000)        /* Bit 1 */
-
-#define  GPIO_CRL_MODE7                      ((u32)0x30000000)        /* MODE7[1:0] bits (Port x mode bits, pin 7) */
-#define  GPIO_CRL_MODE7_0                    ((u32)0x10000000)        /* Bit 0 */
-#define  GPIO_CRL_MODE7_1                    ((u32)0x20000000)        /* Bit 1 */
-
-
-#define  GPIO_CRL_CNF                        ((u32)0xCCCCCCCC)        /* Port x configuration bits */
-
-#define  GPIO_CRL_CNF0                       ((u32)0x0000000C)        /* CNF0[1:0] bits (Port x configuration bits, pin 0) */
-#define  GPIO_CRL_CNF0_0                     ((u32)0x00000004)        /* Bit 0 */
-#define  GPIO_CRL_CNF0_1                     ((u32)0x00000008)        /* Bit 1 */
-
-#define  GPIO_CRL_CNF1                       ((u32)0x000000C0)        /* CNF1[1:0] bits (Port x configuration bits, pin 1) */
-#define  GPIO_CRL_CNF1_0                     ((u32)0x00000040)        /* Bit 0 */
-#define  GPIO_CRL_CNF1_1                     ((u32)0x00000080)        /* Bit 1 */
-
-#define  GPIO_CRL_CNF2                       ((u32)0x00000C00)        /* CNF2[1:0] bits (Port x configuration bits, pin 2) */
-#define  GPIO_CRL_CNF2_0                     ((u32)0x00000400)        /* Bit 0 */
-#define  GPIO_CRL_CNF2_1                     ((u32)0x00000800)        /* Bit 1 */
-
-#define  GPIO_CRL_CNF3                       ((u32)0x0000C000)        /* CNF3[1:0] bits (Port x configuration bits, pin 3) */
-#define  GPIO_CRL_CNF3_0                     ((u32)0x00004000)        /* Bit 0 */
-#define  GPIO_CRL_CNF3_1                     ((u32)0x00008000)        /* Bit 1 */
-
-#define  GPIO_CRL_CNF4                       ((u32)0x000C0000)        /* CNF4[1:0] bits (Port x configuration bits, pin 4) */
-#define  GPIO_CRL_CNF4_0                     ((u32)0x00040000)        /* Bit 0 */
-#define  GPIO_CRL_CNF4_1                     ((u32)0x00080000)        /* Bit 1 */
-
-#define  GPIO_CRL_CNF5                       ((u32)0x00C00000)        /* CNF5[1:0] bits (Port x configuration bits, pin 5) */
-#define  GPIO_CRL_CNF5_0                     ((u32)0x00400000)        /* Bit 0 */
-#define  GPIO_CRL_CNF5_1                     ((u32)0x00800000)        /* Bit 1 */
-
-#define  GPIO_CRL_CNF6                       ((u32)0x0C000000)        /* CNF6[1:0] bits (Port x configuration bits, pin 6) */
-#define  GPIO_CRL_CNF6_0                     ((u32)0x04000000)        /* Bit 0 */
-#define  GPIO_CRL_CNF6_1                     ((u32)0x08000000)        /* Bit 1 */
-
-#define  GPIO_CRL_CNF7                       ((u32)0xC0000000)        /* CNF7[1:0] bits (Port x configuration bits, pin 7) */
-#define  GPIO_CRL_CNF7_0                     ((u32)0x40000000)        /* Bit 0 */
-#define  GPIO_CRL_CNF7_1                     ((u32)0x80000000)        /* Bit 1 */
-
-
-/*******************  Bit definition for GPIO_CRH register  *******************/
-#define  GPIO_CRH_MODE                       ((u32)0x33333333)        /* Port x mode bits */
-
-#define  GPIO_CRH_MODE8                      ((u32)0x00000003)        /* MODE8[1:0] bits (Port x mode bits, pin 8) */
-#define  GPIO_CRH_MODE8_0                    ((u32)0x00000001)        /* Bit 0 */
-#define  GPIO_CRH_MODE8_1                    ((u32)0x00000002)        /* Bit 1 */
-
-#define  GPIO_CRH_MODE9                      ((u32)0x00000030)        /* MODE9[1:0] bits (Port x mode bits, pin 9) */
-#define  GPIO_CRH_MODE9_0                    ((u32)0x00000010)        /* Bit 0 */
-#define  GPIO_CRH_MODE9_1                    ((u32)0x00000020)        /* Bit 1 */
-
-#define  GPIO_CRH_MODE10                     ((u32)0x00000300)        /* MODE10[1:0] bits (Port x mode bits, pin 10) */
-#define  GPIO_CRH_MODE10_0                   ((u32)0x00000100)        /* Bit 0 */
-#define  GPIO_CRH_MODE10_1                   ((u32)0x00000200)        /* Bit 1 */
-
-#define  GPIO_CRH_MODE11                     ((u32)0x00003000)        /* MODE11[1:0] bits (Port x mode bits, pin 11) */
-#define  GPIO_CRH_MODE11_0                   ((u32)0x00001000)        /* Bit 0 */
-#define  GPIO_CRH_MODE11_1                   ((u32)0x00002000)        /* Bit 1 */
-
-#define  GPIO_CRH_MODE12                     ((u32)0x00030000)        /* MODE12[1:0] bits (Port x mode bits, pin 12) */
-#define  GPIO_CRH_MODE12_0                   ((u32)0x00010000)        /* Bit 0 */
-#define  GPIO_CRH_MODE12_1                   ((u32)0x00020000)        /* Bit 1 */
-
-#define  GPIO_CRH_MODE13                     ((u32)0x00300000)        /* MODE13[1:0] bits (Port x mode bits, pin 13) */
-#define  GPIO_CRH_MODE13_0                   ((u32)0x00100000)        /* Bit 0 */
-#define  GPIO_CRH_MODE13_1                   ((u32)0x00200000)        /* Bit 1 */
-
-#define  GPIO_CRH_MODE14                     ((u32)0x03000000)        /* MODE14[1:0] bits (Port x mode bits, pin 14) */
-#define  GPIO_CRH_MODE14_0                   ((u32)0x01000000)        /* Bit 0 */
-#define  GPIO_CRH_MODE14_1                   ((u32)0x02000000)        /* Bit 1 */
-
-#define  GPIO_CRH_MODE15                     ((u32)0x30000000)        /* MODE15[1:0] bits (Port x mode bits, pin 15) */
-#define  GPIO_CRH_MODE15_0                   ((u32)0x10000000)        /* Bit 0 */
-#define  GPIO_CRH_MODE15_1                   ((u32)0x20000000)        /* Bit 1 */
-
-
-#define  GPIO_CRH_CNF                        ((u32)0xCCCCCCCC)        /* Port x configuration bits */
-
-#define  GPIO_CRH_CNF8                       ((u32)0x0000000C)        /* CNF8[1:0] bits (Port x configuration bits, pin 8) */
-#define  GPIO_CRH_CNF8_0                     ((u32)0x00000004)        /* Bit 0 */
-#define  GPIO_CRH_CNF8_1                     ((u32)0x00000008)        /* Bit 1 */
-
-#define  GPIO_CRH_CNF9                       ((u32)0x000000C0)        /* CNF9[1:0] bits (Port x configuration bits, pin 9) */
-#define  GPIO_CRH_CNF9_0                     ((u32)0x00000040)        /* Bit 0 */
-#define  GPIO_CRH_CNF9_1                     ((u32)0x00000080)        /* Bit 1 */
-
-#define  GPIO_CRH_CNF10                      ((u32)0x00000C00)        /* CNF10[1:0] bits (Port x configuration bits, pin 10) */
-#define  GPIO_CRH_CNF10_0                    ((u32)0x00000400)        /* Bit 0 */
-#define  GPIO_CRH_CNF10_1                    ((u32)0x00000800)        /* Bit 1 */
-
-#define  GPIO_CRH_CNF11                      ((u32)0x0000C000)        /* CNF11[1:0] bits (Port x configuration bits, pin 11) */
-#define  GPIO_CRH_CNF11_0                    ((u32)0x00004000)        /* Bit 0 */
-#define  GPIO_CRH_CNF11_1                    ((u32)0x00008000)        /* Bit 1 */
-
-#define  GPIO_CRH_CNF12                      ((u32)0x000C0000)        /* CNF12[1:0] bits (Port x configuration bits, pin 12) */
-#define  GPIO_CRH_CNF12_0                    ((u32)0x00040000)        /* Bit 0 */
-#define  GPIO_CRH_CNF12_1                    ((u32)0x00080000)        /* Bit 1 */
-
-#define  GPIO_CRH_CNF13                      ((u32)0x00C00000)        /* CNF13[1:0] bits (Port x configuration bits, pin 13) */
-#define  GPIO_CRH_CNF13_0                    ((u32)0x00400000)        /* Bit 0 */
-#define  GPIO_CRH_CNF13_1                    ((u32)0x00800000)        /* Bit 1 */
-
-#define  GPIO_CRH_CNF14                      ((u32)0x0C000000)        /* CNF14[1:0] bits (Port x configuration bits, pin 14) */
-#define  GPIO_CRH_CNF14_0                    ((u32)0x04000000)        /* Bit 0 */
-#define  GPIO_CRH_CNF14_1                    ((u32)0x08000000)        /* Bit 1 */
-
-#define  GPIO_CRH_CNF15                      ((u32)0xC0000000)        /* CNF15[1:0] bits (Port x configuration bits, pin 15) */
-#define  GPIO_CRH_CNF15_0                    ((u32)0x40000000)        /* Bit 0 */
-#define  GPIO_CRH_CNF15_1                    ((u32)0x80000000)        /* Bit 1 */
-
-
-/*******************  Bit definition for GPIO_IDR register  *******************/
-#define GPIO_IDR_IDR0                        ((u16)0x0001)            /* Port input data, bit 0 */
-#define GPIO_IDR_IDR1                        ((u16)0x0002)            /* Port input data, bit 1 */
-#define GPIO_IDR_IDR2                        ((u16)0x0004)            /* Port input data, bit 2 */
-#define GPIO_IDR_IDR3                        ((u16)0x0008)            /* Port input data, bit 3 */
-#define GPIO_IDR_IDR4                        ((u16)0x0010)            /* Port input data, bit 4 */
-#define GPIO_IDR_IDR5                        ((u16)0x0020)            /* Port input data, bit 5 */
-#define GPIO_IDR_IDR6                        ((u16)0x0040)            /* Port input data, bit 6 */
-#define GPIO_IDR_IDR7                        ((u16)0x0080)            /* Port input data, bit 7 */
-#define GPIO_IDR_IDR8                        ((u16)0x0100)            /* Port input data, bit 8 */
-#define GPIO_IDR_IDR9                        ((u16)0x0200)            /* Port input data, bit 9 */
-#define GPIO_IDR_IDR10                       ((u16)0x0400)            /* Port input data, bit 10 */
-#define GPIO_IDR_IDR11                       ((u16)0x0800)            /* Port input data, bit 11 */
-#define GPIO_IDR_IDR12                       ((u16)0x1000)            /* Port input data, bit 12 */
-#define GPIO_IDR_IDR13                       ((u16)0x2000)            /* Port input data, bit 13 */
-#define GPIO_IDR_IDR14                       ((u16)0x4000)            /* Port input data, bit 14 */
-#define GPIO_IDR_IDR15                       ((u16)0x8000)            /* Port input data, bit 15 */
-
-
-/*******************  Bit definition for GPIO_ODR register  *******************/
-#define GPIO_ODR_ODR0                        ((u16)0x0001)            /* Port output data, bit 0 */
-#define GPIO_ODR_ODR1                        ((u16)0x0002)            /* Port output data, bit 1 */
-#define GPIO_ODR_ODR2                        ((u16)0x0004)            /* Port output data, bit 2 */
-#define GPIO_ODR_ODR3                        ((u16)0x0008)            /* Port output data, bit 3 */
-#define GPIO_ODR_ODR4                        ((u16)0x0010)            /* Port output data, bit 4 */
-#define GPIO_ODR_ODR5                        ((u16)0x0020)            /* Port output data, bit 5 */
-#define GPIO_ODR_ODR6                        ((u16)0x0040)            /* Port output data, bit 6 */
-#define GPIO_ODR_ODR7                        ((u16)0x0080)            /* Port output data, bit 7 */
-#define GPIO_ODR_ODR8                        ((u16)0x0100)            /* Port output data, bit 8 */
-#define GPIO_ODR_ODR9                        ((u16)0x0200)            /* Port output data, bit 9 */
-#define GPIO_ODR_ODR10                       ((u16)0x0400)            /* Port output data, bit 10 */
-#define GPIO_ODR_ODR11                       ((u16)0x0800)            /* Port output data, bit 11 */
-#define GPIO_ODR_ODR12                       ((u16)0x1000)            /* Port output data, bit 12 */
-#define GPIO_ODR_ODR13                       ((u16)0x2000)            /* Port output data, bit 13 */
-#define GPIO_ODR_ODR14                       ((u16)0x4000)            /* Port output data, bit 14 */
-#define GPIO_ODR_ODR15                       ((u16)0x8000)            /* Port output data, bit 15 */
-
-
-/******************  Bit definition for GPIO_BSRR register  *******************/
-#define GPIO_BSRR_BS0                        ((u32)0x00000001)        /* Port x Set bit 0 */
-#define GPIO_BSRR_BS1                        ((u32)0x00000002)        /* Port x Set bit 1 */
-#define GPIO_BSRR_BS2                        ((u32)0x00000004)        /* Port x Set bit 2 */
-#define GPIO_BSRR_BS3                        ((u32)0x00000008)        /* Port x Set bit 3 */
-#define GPIO_BSRR_BS4                        ((u32)0x00000010)        /* Port x Set bit 4 */
-#define GPIO_BSRR_BS5                        ((u32)0x00000020)        /* Port x Set bit 5 */
-#define GPIO_BSRR_BS6                        ((u32)0x00000040)        /* Port x Set bit 6 */
-#define GPIO_BSRR_BS7                        ((u32)0x00000080)        /* Port x Set bit 7 */
-#define GPIO_BSRR_BS8                        ((u32)0x00000100)        /* Port x Set bit 8 */
-#define GPIO_BSRR_BS9                        ((u32)0x00000200)        /* Port x Set bit 9 */
-#define GPIO_BSRR_BS10                       ((u32)0x00000400)        /* Port x Set bit 10 */
-#define GPIO_BSRR_BS11                       ((u32)0x00000800)        /* Port x Set bit 11 */
-#define GPIO_BSRR_BS12                       ((u32)0x00001000)        /* Port x Set bit 12 */
-#define GPIO_BSRR_BS13                       ((u32)0x00002000)        /* Port x Set bit 13 */
-#define GPIO_BSRR_BS14                       ((u32)0x00004000)        /* Port x Set bit 14 */
-#define GPIO_BSRR_BS15                       ((u32)0x00008000)        /* Port x Set bit 15 */
-
-#define GPIO_BSRR_BR0                        ((u32)0x00010000)        /* Port x Reset bit 0 */
-#define GPIO_BSRR_BR1                        ((u32)0x00020000)        /* Port x Reset bit 1 */
-#define GPIO_BSRR_BR2                        ((u32)0x00040000)        /* Port x Reset bit 2 */
-#define GPIO_BSRR_BR3                        ((u32)0x00080000)        /* Port x Reset bit 3 */
-#define GPIO_BSRR_BR4                        ((u32)0x00100000)        /* Port x Reset bit 4 */
-#define GPIO_BSRR_BR5                        ((u32)0x00200000)        /* Port x Reset bit 5 */
-#define GPIO_BSRR_BR6                        ((u32)0x00400000)        /* Port x Reset bit 6 */
-#define GPIO_BSRR_BR7                        ((u32)0x00800000)        /* Port x Reset bit 7 */
-#define GPIO_BSRR_BR8                        ((u32)0x01000000)        /* Port x Reset bit 8 */
-#define GPIO_BSRR_BR9                        ((u32)0x02000000)        /* Port x Reset bit 9 */
-#define GPIO_BSRR_BR10                       ((u32)0x04000000)        /* Port x Reset bit 10 */
-#define GPIO_BSRR_BR11                       ((u32)0x08000000)        /* Port x Reset bit 11 */
-#define GPIO_BSRR_BR12                       ((u32)0x10000000)        /* Port x Reset bit 12 */
-#define GPIO_BSRR_BR13                       ((u32)0x20000000)        /* Port x Reset bit 13 */
-#define GPIO_BSRR_BR14                       ((u32)0x40000000)        /* Port x Reset bit 14 */
-#define GPIO_BSRR_BR15                       ((u32)0x80000000)        /* Port x Reset bit 15 */
-
-
-/*******************  Bit definition for GPIO_BRR register  *******************/
-#define GPIO_BRR_BR0                         ((u16)0x0001)            /* Port x Reset bit 0 */
-#define GPIO_BRR_BR1                         ((u16)0x0002)            /* Port x Reset bit 1 */
-#define GPIO_BRR_BR2                         ((u16)0x0004)            /* Port x Reset bit 2 */
-#define GPIO_BRR_BR3                         ((u16)0x0008)            /* Port x Reset bit 3 */
-#define GPIO_BRR_BR4                         ((u16)0x0010)            /* Port x Reset bit 4 */
-#define GPIO_BRR_BR5                         ((u16)0x0020)            /* Port x Reset bit 5 */
-#define GPIO_BRR_BR6                         ((u16)0x0040)            /* Port x Reset bit 6 */
-#define GPIO_BRR_BR7                         ((u16)0x0080)            /* Port x Reset bit 7 */
-#define GPIO_BRR_BR8                         ((u16)0x0100)            /* Port x Reset bit 8 */
-#define GPIO_BRR_BR9                         ((u16)0x0200)            /* Port x Reset bit 9 */
-#define GPIO_BRR_BR10                        ((u16)0x0400)            /* Port x Reset bit 10 */
-#define GPIO_BRR_BR11                        ((u16)0x0800)            /* Port x Reset bit 11 */
-#define GPIO_BRR_BR12                        ((u16)0x1000)            /* Port x Reset bit 12 */
-#define GPIO_BRR_BR13                        ((u16)0x2000)            /* Port x Reset bit 13 */
-#define GPIO_BRR_BR14                        ((u16)0x4000)            /* Port x Reset bit 14 */
-#define GPIO_BRR_BR15                        ((u16)0x8000)            /* Port x Reset bit 15 */
-
-
-/******************  Bit definition for GPIO_LCKR register  *******************/
-#define GPIO_LCKR_LCK0                       ((u32)0x00000001)        /* Port x Lock bit 0 */
-#define GPIO_LCKR_LCK1                       ((u32)0x00000002)        /* Port x Lock bit 1 */
-#define GPIO_LCKR_LCK2                       ((u32)0x00000004)        /* Port x Lock bit 2 */
-#define GPIO_LCKR_LCK3                       ((u32)0x00000008)        /* Port x Lock bit 3 */
-#define GPIO_LCKR_LCK4                       ((u32)0x00000010)        /* Port x Lock bit 4 */
-#define GPIO_LCKR_LCK5                       ((u32)0x00000020)        /* Port x Lock bit 5 */
-#define GPIO_LCKR_LCK6                       ((u32)0x00000040)        /* Port x Lock bit 6 */
-#define GPIO_LCKR_LCK7                       ((u32)0x00000080)        /* Port x Lock bit 7 */
-#define GPIO_LCKR_LCK8                       ((u32)0x00000100)        /* Port x Lock bit 8 */
-#define GPIO_LCKR_LCK9                       ((u32)0x00000200)        /* Port x Lock bit 9 */
-#define GPIO_LCKR_LCK10                      ((u32)0x00000400)        /* Port x Lock bit 10 */
-#define GPIO_LCKR_LCK11                      ((u32)0x00000800)        /* Port x Lock bit 11 */
-#define GPIO_LCKR_LCK12                      ((u32)0x00001000)        /* Port x Lock bit 12 */
-#define GPIO_LCKR_LCK13                      ((u32)0x00002000)        /* Port x Lock bit 13 */
-#define GPIO_LCKR_LCK14                      ((u32)0x00004000)        /* Port x Lock bit 14 */
-#define GPIO_LCKR_LCK15                      ((u32)0x00008000)        /* Port x Lock bit 15 */
-#define GPIO_LCKR_LCKK                       ((u32)0x00010000)        /* Lock key */
-
-
-/*----------------------------------------------------------------------------*/
-
-
-/******************  Bit definition for AFIO_EVCR register  *******************/
-#define AFIO_EVCR_PIN                        ((u8)0x0F)               /* PIN[3:0] bits (Pin selection) */
-#define AFIO_EVCR_PIN_0                      ((u8)0x01)               /* Bit 0 */
-#define AFIO_EVCR_PIN_1                      ((u8)0x02)               /* Bit 1 */
-#define AFIO_EVCR_PIN_2                      ((u8)0x04)               /* Bit 2 */
-#define AFIO_EVCR_PIN_3                      ((u8)0x08)               /* Bit 3 */
-
-/* PIN configuration */
-#define AFIO_EVCR_PIN_PX0                    ((u8)0x00)               /* Pin 0 selected */
-#define AFIO_EVCR_PIN_PX1                    ((u8)0x01)               /* Pin 1 selected */
-#define AFIO_EVCR_PIN_PX2                    ((u8)0x02)               /* Pin 2 selected */
-#define AFIO_EVCR_PIN_PX3                    ((u8)0x03)               /* Pin 3 selected */
-#define AFIO_EVCR_PIN_PX4                    ((u8)0x04)               /* Pin 4 selected */
-#define AFIO_EVCR_PIN_PX5                    ((u8)0x05)               /* Pin 5 selected */
-#define AFIO_EVCR_PIN_PX6                    ((u8)0x06)               /* Pin 6 selected */
-#define AFIO_EVCR_PIN_PX7                    ((u8)0x07)               /* Pin 7 selected */
-#define AFIO_EVCR_PIN_PX8                    ((u8)0x08)               /* Pin 8 selected */
-#define AFIO_EVCR_PIN_PX9                    ((u8)0x09)               /* Pin 9 selected */
-#define AFIO_EVCR_PIN_PX10                   ((u8)0x0A)               /* Pin 10 selected */
-#define AFIO_EVCR_PIN_PX11                   ((u8)0x0B)               /* Pin 11 selected */
-#define AFIO_EVCR_PIN_PX12                   ((u8)0x0C)               /* Pin 12 selected */
-#define AFIO_EVCR_PIN_PX13                   ((u8)0x0D)               /* Pin 13 selected */
-#define AFIO_EVCR_PIN_PX14                   ((u8)0x0E)               /* Pin 14 selected */
-#define AFIO_EVCR_PIN_PX15                   ((u8)0x0F)               /* Pin 15 selected */
-
-#define AFIO_EVCR_PORT                       ((u8)0x70)               /* PORT[2:0] bits (Port selection) */
-#define AFIO_EVCR_PORT_0                     ((u8)0x10)               /* Bit 0 */
-#define AFIO_EVCR_PORT_1                     ((u8)0x20)               /* Bit 1 */
-#define AFIO_EVCR_PORT_2                     ((u8)0x40)               /* Bit 2 */
-
-/* PORT configuration */
-#define AFIO_EVCR_PORT_PA                    ((u8)0x00)               /* Port A selected */
-#define AFIO_EVCR_PORT_PB                    ((u8)0x10)               /* Port B selected */
-#define AFIO_EVCR_PORT_PC                    ((u8)0x20)               /* Port C selected */
-#define AFIO_EVCR_PORT_PD                    ((u8)0x30)               /* Port D selected */
-#define AFIO_EVCR_PORT_PE                    ((u8)0x40)               /* Port E selected */
-
-#define AFIO_EVCR_EVOE                       ((u8)0x80)               /* Event Output Enable */
-
-
-/******************  Bit definition for AFIO_MAPR register  *******************/
-#define AFIO_MAPR_SPI1 _REMAP                ((u32)0x00000001)        /* SPI1 remapping */
-#define AFIO_MAPR_I2C1_REMAP                 ((u32)0x00000002)        /* I2C1 remapping */
-#define AFIO_MAPR_USART1_REMAP               ((u32)0x00000004)        /* USART1 remapping */
-#define AFIO_MAPR_USART2_REMAP               ((u32)0x00000008)        /* USART2 remapping */
-
-#define AFIO_MAPR_USART3_REMAP               ((u32)0x00000030)        /* USART3_REMAP[1:0] bits (USART3 remapping) */
-#define AFIO_MAPR_USART3_REMAP_0             ((u32)0x00000010)        /* Bit 0 */
-#define AFIO_MAPR_USART3_REMAP_1             ((u32)0x00000020)        /* Bit 1 */
-
-/* USART3_REMAP configuration */
-#define AFIO_MAPR_USART3_REMAP_NOREMAP       ((u32)0x00000000)        /* No remap (TX/PB10, RX/PB11, CK/PB12, CTS/PB13, RTS/PB14) */
-#define AFIO_MAPR_USART3_REMAP_PARTIALREMAP  ((u32)0x00000010)        /* Partial remap (TX/PC10, RX/PC11, CK/PC12, CTS/PB13, RTS/PB14) */
-#define AFIO_MAPR_USART3_REMAP_FULLREMAP     ((u32)0x00000030)        /* Full remap (TX/PD8, RX/PD9, CK/PD10, CTS/PD11, RTS/PD12) */
-
-#define AFIO_MAPR_TIM1_REMAP                 ((u32)0x000000C0)        /* TIM1_REMAP[1:0] bits (TIM1 remapping) */
-#define AFIO_MAPR_TIM1_REMAP_0               ((u32)0x00000040)        /* Bit 0 */
-#define AFIO_MAPR_TIM1_REMAP_1               ((u32)0x00000080)        /* Bit 1 */
-
-/* TIM1_REMAP configuration */
-#define AFIO_MAPR_TIM1_REMAP_NOREMAP         ((u32)0x00000000)        /* No remap (ETR/PA12, CH1/PA8, CH2/PA9, CH3/PA10, CH4/PA11, BKIN/PB12, CH1N/PB13, CH2N/PB14, CH3N/PB15) */
-#define AFIO_MAPR_TIM1_REMAP_PARTIALREMAP    ((u32)0x00000040)        /* Partial remap (ETR/PA12, CH1/PA8, CH2/PA9, CH3/PA10, CH4/PA11, BKIN/PA6, CH1N/PA7, CH2N/PB0, CH3N/PB1) */
-#define AFIO_MAPR_TIM1_REMAP_FULLREMAP       ((u32)0x000000C0)        /* Full remap (ETR/PE7, CH1/PE9, CH2/PE11, CH3/PE13, CH4/PE14, BKIN/PE15, CH1N/PE8, CH2N/PE10, CH3N/PE12) */
-
-#define AFIO_MAPR_TIM2_REMAP                 ((u32)0x00000300)        /* TIM2_REMAP[1:0] bits (TIM2 remapping) */
-#define AFIO_MAPR_TIM2_REMAP_0               ((u32)0x00000100)        /* Bit 0 */
-#define AFIO_MAPR_TIM2_REMAP_1               ((u32)0x00000200)        /* Bit 1 */
-
-/* TIM2_REMAP configuration */
-#define AFIO_MAPR_TIM2_REMAP_NOREMAP         ((u32)0x00000000)        /* No remap (CH1/ETR/PA0, CH2/PA1, CH3/PA2, CH4/PA3) */
-#define AFIO_MAPR_TIM2_REMAP_PARTIALREMAP1   ((u32)0x00000100)        /* Partial remap (CH1/ETR/PA15, CH2/PB3, CH3/PA2, CH4/PA3) */
-#define AFIO_MAPR_TIM2_REMAP_PARTIALREMAP2   ((u32)0x00000200)        /* Partial remap (CH1/ETR/PA0, CH2/PA1, CH3/PB10, CH4/PB11) */
-#define AFIO_MAPR_TIM2_REMAP_FULLREMAP       ((u32)0x00000300)        /* Full remap (CH1/ETR/PA15, CH2/PB3, CH3/PB10, CH4/PB11) */
-
-#define AFIO_MAPR_TIM3_REMAP                 ((u32)0x00000C00)        /* TIM3_REMAP[1:0] bits (TIM3 remapping) */
-#define AFIO_MAPR_TIM3_REMAP_0               ((u32)0x00000400)        /* Bit 0 */
-#define AFIO_MAPR_TIM3_REMAP_1               ((u32)0x00000800)        /* Bit 1 */
-
-/* TIM3_REMAP configuration */
-#define AFIO_MAPR_TIM3_REMAP_NOREMAP         ((u32)0x00000000)        /* No remap (CH1/PA6, CH2/PA7, CH3/PB0, CH4/PB1) */
-#define AFIO_MAPR_TIM3_REMAP_PARTIALREMAP    ((u32)0x00000800)        /* Partial remap (CH1/PB4, CH2/PB5, CH3/PB0, CH4/PB1) */
-#define AFIO_MAPR_TIM3_REMAP_FULLREMAP       ((u32)0x00000C00)        /* Full remap (CH1/PC6, CH2/PC7, CH3/PC8, CH4/PC9) */
-
-#define AFIO_MAPR_TIM4_REMAP                 ((u32)0x00001000)        /* Port D0/Port D1 mapping on OSC_IN/OSC_OUT */
-
-#define AFIO_MAPR_CAN_REMAP                  ((u32)0x00006000)        /* CAN_REMAP[1:0] bits (CAN Alternate function remapping) */
-#define AFIO_MAPR_CAN_REMAP_0                ((u32)0x00002000)        /* Bit 0 */
-#define AFIO_MAPR_CAN_REMAP_1                ((u32)0x00004000)        /* Bit 1 */
-
-/* CAN_REMAP configuration */
-#define AFIO_MAPR_CAN_REMAP_REMAP1           ((u32)0x00000000)        /* CANRX mapped to PA11, CANTX mapped to PA12 */
-#define AFIO_MAPR_CAN_REMAP_REMAP2           ((u32)0x00004000)        /* CANRX mapped to PB8, CANTX mapped to PB9 */
-#define AFIO_MAPR_CAN_REMAP_REMAP3           ((u32)0x00006000)        /* CANRX mapped to PD0, CANTX mapped to PD1 */
-
-#define AFIO_MAPR_PD01_REMAP                 ((u32)0x00008000)        /* Port D0/Port D1 mapping on OSC_IN/OSC_OUT */
-#define AFIO_MAPR_TIM5CH4_IREMAP             ((u32)0x00010000)        /* TIM5 Channel4 Internal Remap */
-#define AFIO_MAPR_ADC1_ETRGINJ_REMAP         ((u32)0x00020000)        /* ADC 1 External Trigger Injected Conversion remapping */
-#define AFIO_MAPR_ADC1_ETRGREG_REMAP         ((u32)0x00040000)        /* ADC 1 External Trigger Regular Conversion remapping */
-#define AFIO_MAPR_ADC2_ETRGINJ_REMAP         ((u32)0x00080000)        /* ADC 2 External Trigger Injected Conversion remapping */
-#define AFIO_MAPR_ADC2_ETRGREG_REMAP         ((u32)0x00100000)        /* ADC 2 External Trigger Regular Conversion remapping */
-
-#define AFIO_MAPR_SWJ_CFG                    ((u32)0x07000000)        /* SWJ_CFG[2:0] bits (Serial Wire JTAG configuration) */
-#define AFIO_MAPR_SWJ_CFG_0                  ((u32)0x01000000)        /* Bit 0 */
-#define AFIO_MAPR_SWJ_CFG_1                  ((u32)0x02000000)        /* Bit 1 */
-#define AFIO_MAPR_SWJ_CFG_2                  ((u32)0x04000000)        /* Bit 2 */
-
-/* SWJ_CFG configuration */
-#define AFIO_MAPR_SWJ_CFG_RESET              ((u32)0x00000000)        /* Full SWJ (JTAG-DP + SW-DP) : Reset State */
-#define AFIO_MAPR_SWJ_CFG_NOJNTRST           ((u32)0x01000000)        /* Full SWJ (JTAG-DP + SW-DP) but without JNTRST */
-#define AFIO_MAPR_SWJ_CFG_JTAGDISABLE        ((u32)0x02000000)        /* JTAG-DP Disabled and SW-DP Enabled */
-#define AFIO_MAPR_SWJ_CFG_DISABLE            ((u32)0x04000000)        /* JTAG-DP Disabled and SW-DP Disabled */
-
-
-/*****************  Bit definition for AFIO_EXTICR1 register  *****************/
-#define AFIO_EXTICR1_EXTI0                   ((u16)0x000F)            /* EXTI 0 configuration */
-#define AFIO_EXTICR1_EXTI1                   ((u16)0x00F0)            /* EXTI 1 configuration */
-#define AFIO_EXTICR1_EXTI2                   ((u16)0x0F00)            /* EXTI 2 configuration */
-#define AFIO_EXTICR1_EXTI3                   ((u16)0xF000)            /* EXTI 3 configuration */
-
-/* EXTI0 configuration */
-#define AFIO_EXTICR1_EXTI0_PA                ((u16)0x0000)            /* PA[0] pin */
-#define AFIO_EXTICR1_EXTI0_PB                ((u16)0x0001)            /* PB[0] pin */
-#define AFIO_EXTICR1_EXTI0_PC                ((u16)0x0002)            /* PC[0] pin */
-#define AFIO_EXTICR1_EXTI0_PD                ((u16)0x0003)            /* PD[0] pin */
-#define AFIO_EXTICR1_EXTI0_PE                ((u16)0x0004)            /* PE[0] pin */
-#define AFIO_EXTICR1_EXTI0_PF                ((u16)0x0005)            /* PF[0] pin */
-#define AFIO_EXTICR1_EXTI0_PG                ((u16)0x0006)            /* PG[0] pin */
-
-/* EXTI1 configuration */
-#define AFIO_EXTICR1_EXTI1_PA                ((u16)0x0000)            /* PA[1] pin */
-#define AFIO_EXTICR1_EXTI1_PB                ((u16)0x0010)            /* PB[1] pin */
-#define AFIO_EXTICR1_EXTI1_PC                ((u16)0x0020)            /* PC[1] pin */
-#define AFIO_EXTICR1_EXTI1_PD                ((u16)0x0030)            /* PD[1] pin */
-#define AFIO_EXTICR1_EXTI1_PE                ((u16)0x0040)            /* PE[1] pin */
-#define AFIO_EXTICR1_EXTI1_PF                ((u16)0x0050)            /* PF[1] pin */
-#define AFIO_EXTICR1_EXTI1_PG                ((u16)0x0060)            /* PG[1] pin */
-
-/* EXTI2 configuration */  
-#define AFIO_EXTICR1_EXTI2_PA                ((u16)0x0000)            /* PA[2] pin */
-#define AFIO_EXTICR1_EXTI2_PB                ((u16)0x0100)            /* PB[2] pin */
-#define AFIO_EXTICR1_EXTI2_PC                ((u16)0x0200)            /* PC[2] pin */
-#define AFIO_EXTICR1_EXTI2_PD                ((u16)0x0300)            /* PD[2] pin */
-#define AFIO_EXTICR1_EXTI2_PE                ((u16)0x0400)            /* PE[2] pin */
-#define AFIO_EXTICR1_EXTI2_PF                ((u16)0x0500)            /* PF[2] pin */
-#define AFIO_EXTICR1_EXTI2_PG                ((u16)0x0600)            /* PG[2] pin */
-
-/* EXTI3 configuration */
-#define AFIO_EXTICR1_EXTI3_PA                ((u16)0x0000)            /* PA[3] pin */
-#define AFIO_EXTICR1_EXTI3_PB                ((u16)0x1000)            /* PB[3] pin */
-#define AFIO_EXTICR1_EXTI3_PC                ((u16)0x2000)            /* PC[3] pin */
-#define AFIO_EXTICR1_EXTI3_PD                ((u16)0x3000)            /* PD[3] pin */
-#define AFIO_EXTICR1_EXTI3_PE                ((u16)0x4000)            /* PE[3] pin */
-#define AFIO_EXTICR1_EXTI3_PF                ((u16)0x5000)            /* PF[3] pin */
-#define AFIO_EXTICR1_EXTI3_PG                ((u16)0x6000)            /* PG[3] pin */
-
-
-/*****************  Bit definition for AFIO_EXTICR2 register  *****************/
-#define AFIO_EXTICR2_EXTI4                   ((u16)0x000F)            /* EXTI 4 configuration */
-#define AFIO_EXTICR2_EXTI5                   ((u16)0x00F0)            /* EXTI 5 configuration */
-#define AFIO_EXTICR2_EXTI6                   ((u16)0x0F00)            /* EXTI 6 configuration */
-#define AFIO_EXTICR2_EXTI7                   ((u16)0xF000)            /* EXTI 7 configuration */
-
-/* EXTI4 configuration */
-#define AFIO_EXTICR2_EXTI4_PA                ((u16)0x0000)            /* PA[4] pin */
-#define AFIO_EXTICR2_EXTI4_PB                ((u16)0x0001)            /* PB[4] pin */
-#define AFIO_EXTICR2_EXTI4_PC                ((u16)0x0002)            /* PC[4] pin */
-#define AFIO_EXTICR2_EXTI4_PD                ((u16)0x0003)            /* PD[4] pin */
-#define AFIO_EXTICR2_EXTI4_PE                ((u16)0x0004)            /* PE[4] pin */
-#define AFIO_EXTICR2_EXTI4_PF                ((u16)0x0005)            /* PF[4] pin */
-#define AFIO_EXTICR2_EXTI4_PG                ((u16)0x0006)            /* PG[4] pin */
-
-/* EXTI5 configuration */
-#define AFIO_EXTICR2_EXTI5_PA                ((u16)0x0000)            /* PA[5] pin */
-#define AFIO_EXTICR2_EXTI5_PB                ((u16)0x0010)            /* PB[5] pin */
-#define AFIO_EXTICR2_EXTI5_PC                ((u16)0x0020)            /* PC[5] pin */
-#define AFIO_EXTICR2_EXTI5_PD                ((u16)0x0030)            /* PD[5] pin */
-#define AFIO_EXTICR2_EXTI5_PE                ((u16)0x0040)            /* PE[5] pin */
-#define AFIO_EXTICR2_EXTI5_PF                ((u16)0x0050)            /* PF[5] pin */
-#define AFIO_EXTICR2_EXTI5_PG                ((u16)0x0060)            /* PG[5] pin */
-
-/* EXTI6 configuration */  
-#define AFIO_EXTICR2_EXTI6_PA                ((u16)0x0000)            /* PA[6] pin */
-#define AFIO_EXTICR2_EXTI6_PB                ((u16)0x0100)            /* PB[6] pin */
-#define AFIO_EXTICR2_EXTI6_PC                ((u16)0x0200)            /* PC[6] pin */
-#define AFIO_EXTICR2_EXTI6_PD                ((u16)0x0300)            /* PD[6] pin */
-#define AFIO_EXTICR2_EXTI6_PE                ((u16)0x0400)            /* PE[6] pin */
-#define AFIO_EXTICR2_EXTI6_PF                ((u16)0x0500)            /* PF[6] pin */
-#define AFIO_EXTICR2_EXTI6_PG                ((u16)0x0600)            /* PG[6] pin */
-
-/* EXTI7 configuration */
-#define AFIO_EXTICR2_EXTI7_PA                ((u16)0x0000)            /* PA[7] pin */
-#define AFIO_EXTICR2_EXTI7_PB                ((u16)0x1000)            /* PB[7] pin */
-#define AFIO_EXTICR2_EXTI7_PC                ((u16)0x2000)            /* PC[7] pin */
-#define AFIO_EXTICR2_EXTI7_PD                ((u16)0x3000)            /* PD[7] pin */
-#define AFIO_EXTICR2_EXTI7_PE                ((u16)0x4000)            /* PE[7] pin */
-#define AFIO_EXTICR2_EXTI7_PF                ((u16)0x5000)            /* PF[7] pin */
-#define AFIO_EXTICR2_EXTI7_PG                ((u16)0x6000)            /* PG[7] pin */
-
-
-/*****************  Bit definition for AFIO_EXTICR3 register  *****************/
-#define AFIO_EXTICR3_EXTI8                   ((u16)0x000F)            /* EXTI 8 configuration */
-#define AFIO_EXTICR3_EXTI9                   ((u16)0x00F0)            /* EXTI 9 configuration */
-#define AFIO_EXTICR3_EXTI10                  ((u16)0x0F00)            /* EXTI 10 configuration */
-#define AFIO_EXTICR3_EXTI11                  ((u16)0xF000)            /* EXTI 11 configuration */
-
-/* EXTI8 configuration */
-#define AFIO_EXTICR3_EXTI8_PA                ((u16)0x0000)            /* PA[8] pin */
-#define AFIO_EXTICR3_EXTI8_PB                ((u16)0x0001)            /* PB[8] pin */
-#define AFIO_EXTICR3_EXTI8_PC                ((u16)0x0002)            /* PC[8] pin */
-#define AFIO_EXTICR3_EXTI8_PD                ((u16)0x0003)            /* PD[8] pin */
-#define AFIO_EXTICR3_EXTI8_PE                ((u16)0x0004)            /* PE[8] pin */
-#define AFIO_EXTICR3_EXTI8_PF                ((u16)0x0005)            /* PF[8] pin */
-#define AFIO_EXTICR3_EXTI8_PG                ((u16)0x0006)            /* PG[8] pin */
-
-/* EXTI9 configuration */
-#define AFIO_EXTICR3_EXTI9_PA                ((u16)0x0000)            /* PA[9] pin */
-#define AFIO_EXTICR3_EXTI9_PB                ((u16)0x0010)            /* PB[9] pin */
-#define AFIO_EXTICR3_EXTI9_PC                ((u16)0x0020)            /* PC[9] pin */
-#define AFIO_EXTICR3_EXTI9_PD                ((u16)0x0030)            /* PD[9] pin */
-#define AFIO_EXTICR3_EXTI9_PE                ((u16)0x0040)            /* PE[9] pin */
-#define AFIO_EXTICR3_EXTI9_PF                ((u16)0x0050)            /* PF[9] pin */
-#define AFIO_EXTICR3_EXTI9_PG                ((u16)0x0060)            /* PG[9] pin */
-
-/* EXTI10 configuration */  
-#define AFIO_EXTICR3_EXTI10_PA               ((u16)0x0000)            /* PA[10] pin */
-#define AFIO_EXTICR3_EXTI10_PB               ((u16)0x0100)            /* PB[10] pin */
-#define AFIO_EXTICR3_EXTI10_PC               ((u16)0x0200)            /* PC[10] pin */
-#define AFIO_EXTICR3_EXTI10_PD               ((u16)0x0300)            /* PD[10] pin */
-#define AFIO_EXTICR3_EXTI10_PE               ((u16)0x0400)            /* PE[10] pin */
-#define AFIO_EXTICR3_EXTI10_PF               ((u16)0x0500)            /* PF[10] pin */
-#define AFIO_EXTICR3_EXTI10_PG               ((u16)0x0600)            /* PG[10] pin */
-
-/* EXTI11 configuration */
-#define AFIO_EXTICR3_EXTI11_PA               ((u16)0x0000)            /* PA[11] pin */
-#define AFIO_EXTICR3_EXTI11_PB               ((u16)0x1000)            /* PB[11] pin */
-#define AFIO_EXTICR3_EXTI11_PC               ((u16)0x2000)            /* PC[11] pin */
-#define AFIO_EXTICR3_EXTI11_PD               ((u16)0x3000)            /* PD[11] pin */
-#define AFIO_EXTICR3_EXTI11_PE               ((u16)0x4000)            /* PE[11] pin */
-#define AFIO_EXTICR3_EXTI11_PF               ((u16)0x5000)            /* PF[11] pin */
-#define AFIO_EXTICR3_EXTI11_PG               ((u16)0x6000)            /* PG[11] pin */
-
-
-/*****************  Bit definition for AFIO_EXTICR4 register  *****************/
-#define AFIO_EXTICR4_EXTI12                  ((u16)0x000F)            /* EXTI 12 configuration */
-#define AFIO_EXTICR4_EXTI13                  ((u16)0x00F0)            /* EXTI 13 configuration */
-#define AFIO_EXTICR4_EXTI14                  ((u16)0x0F00)            /* EXTI 14 configuration */
-#define AFIO_EXTICR4_EXTI15                  ((u16)0xF000)            /* EXTI 15 configuration */
-
-/* EXTI12 configuration */
-#define AFIO_EXTICR4_EXTI12_PA               ((u16)0x0000)            /* PA[12] pin */
-#define AFIO_EXTICR4_EXTI12_PB               ((u16)0x0001)            /* PB[12] pin */
-#define AFIO_EXTICR4_EXTI12_PC               ((u16)0x0002)            /* PC[12] pin */
-#define AFIO_EXTICR4_EXTI12_PD               ((u16)0x0003)            /* PD[12] pin */
-#define AFIO_EXTICR4_EXTI12_PE               ((u16)0x0004)            /* PE[12] pin */
-#define AFIO_EXTICR4_EXTI12_PF               ((u16)0x0005)            /* PF[12] pin */
-#define AFIO_EXTICR4_EXTI12_PG               ((u16)0x0006)            /* PG[12] pin */
-
-/* EXTI13 configuration */
-#define AFIO_EXTICR4_EXTI13_PA               ((u16)0x0000)            /* PA[13] pin */
-#define AFIO_EXTICR4_EXTI13_PB               ((u16)0x0010)            /* PB[13] pin */
-#define AFIO_EXTICR4_EXTI13_PC               ((u16)0x0020)            /* PC[13] pin */
-#define AFIO_EXTICR4_EXTI13_PD               ((u16)0x0030)            /* PD[13] pin */
-#define AFIO_EXTICR4_EXTI13_PE               ((u16)0x0040)            /* PE[13] pin */
-#define AFIO_EXTICR4_EXTI13_PF               ((u16)0x0050)            /* PF[13] pin */
-#define AFIO_EXTICR4_EXTI13_PG               ((u16)0x0060)            /* PG[13] pin */
-
-/* EXTI14 configuration */  
-#define AFIO_EXTICR4_EXTI14_PA               ((u16)0x0000)            /* PA[14] pin */
-#define AFIO_EXTICR4_EXTI14_PB               ((u16)0x0100)            /* PB[14] pin */
-#define AFIO_EXTICR4_EXTI14_PC               ((u16)0x0200)            /* PC[14] pin */
-#define AFIO_EXTICR4_EXTI14_PD               ((u16)0x0300)            /* PD[14] pin */
-#define AFIO_EXTICR4_EXTI14_PE               ((u16)0x0400)            /* PE[14] pin */
-#define AFIO_EXTICR4_EXTI14_PF               ((u16)0x0500)            /* PF[14] pin */
-#define AFIO_EXTICR4_EXTI14_PG               ((u16)0x0600)            /* PG[14] pin */
-
-/* EXTI15 configuration */
-#define AFIO_EXTICR4_EXTI15_PA               ((u16)0x0000)            /* PA[15] pin */
-#define AFIO_EXTICR4_EXTI15_PB               ((u16)0x1000)            /* PB[15] pin */
-#define AFIO_EXTICR4_EXTI15_PC               ((u16)0x2000)            /* PC[15] pin */
-#define AFIO_EXTICR4_EXTI15_PD               ((u16)0x3000)            /* PD[15] pin */
-#define AFIO_EXTICR4_EXTI15_PE               ((u16)0x4000)            /* PE[15] pin */
-#define AFIO_EXTICR4_EXTI15_PF               ((u16)0x5000)            /* PF[15] pin */
-#define AFIO_EXTICR4_EXTI15_PG               ((u16)0x6000)            /* PG[15] pin */
-
-
-
-/******************************************************************************/
-/*                                                                            */
-/*                               SystemTick                                   */
-/*                                                                            */
-/******************************************************************************/
-
-/*****************  Bit definition for SysTick_CTRL register  *****************/
-#define  SysTick_CTRL_ENABLE                 ((u32)0x00000001)        /* Counter enable */
-#define  SysTick_CTRL_TICKINT                ((u32)0x00000002)        /* Counting down to 0 pends the SysTick handler */
-#define  SysTick_CTRL_CLKSOURCE              ((u32)0x00000004)        /* Clock source */
-#define  SysTick_CTRL_COUNTFLAG              ((u32)0x00010000)        /* Count Flag */
-
-
-/*****************  Bit definition for SysTick_LOAD register  *****************/
-#define  SysTick_LOAD_RELOAD                 ((u32)0x00FFFFFF)        /* Value to load into the SysTick Current Value Register when the counter reaches 0 */
-
-
-/*****************  Bit definition for SysTick_VAL register  ******************/
-#define  SysTick_VAL_CURRENT                 ((u32)0x00FFFFFF)        /* Current value at the time the register is accessed */
-
-
-/*****************  Bit definition for SysTick_CALIB register  ****************/
-#define  SysTick_CALIB_TENMS                 ((u32)0x00FFFFFF)        /* Reload value to use for 10ms timing */
-#define  SysTick_CALIB_SKEW                  ((u32)0x40000000)        /* Calibration value is not exactly 10 ms */
-#define  SysTick_CALIB_NOREF                 ((u32)0x80000000)        /* The reference clock is not provided */
-
-
-
-/******************************************************************************/
-/*                                                                            */
-/*                  Nested Vectored Interrupt Controller                      */
-/*                                                                            */
-/******************************************************************************/
-
-/******************  Bit definition for NVIC_ISER register  *******************/
-#define  NVIC_ISER_SETENA                    ((u32)0xFFFFFFFF)        /* Interrupt set enable bits */
-#define  NVIC_ISER_SETENA_0                  ((u32)0x00000001)        /* bit 0 */
-#define  NVIC_ISER_SETENA_1                  ((u32)0x00000002)        /* bit 1 */
-#define  NVIC_ISER_SETENA_2                  ((u32)0x00000004)        /* bit 2 */
-#define  NVIC_ISER_SETENA_3                  ((u32)0x00000008)        /* bit 3 */
-#define  NVIC_ISER_SETENA_4                  ((u32)0x00000010)        /* bit 4 */
-#define  NVIC_ISER_SETENA_5                  ((u32)0x00000020)        /* bit 5 */
-#define  NVIC_ISER_SETENA_6                  ((u32)0x00000040)        /* bit 6 */
-#define  NVIC_ISER_SETENA_7                  ((u32)0x00000080)        /* bit 7 */
-#define  NVIC_ISER_SETENA_8                  ((u32)0x00000100)        /* bit 8 */
-#define  NVIC_ISER_SETENA_9                  ((u32)0x00000200)        /* bit 9 */
-#define  NVIC_ISER_SETENA_10                 ((u32)0x00000400)        /* bit 10 */
-#define  NVIC_ISER_SETENA_11                 ((u32)0x00000800)        /* bit 11 */
-#define  NVIC_ISER_SETENA_12                 ((u32)0x00001000)        /* bit 12 */
-#define  NVIC_ISER_SETENA_13                 ((u32)0x00002000)        /* bit 13 */
-#define  NVIC_ISER_SETENA_14                 ((u32)0x00004000)        /* bit 14 */
-#define  NVIC_ISER_SETENA_15                 ((u32)0x00008000)        /* bit 15 */
-#define  NVIC_ISER_SETENA_16                 ((u32)0x00010000)        /* bit 16 */
-#define  NVIC_ISER_SETENA_17                 ((u32)0x00020000)        /* bit 17 */
-#define  NVIC_ISER_SETENA_18                 ((u32)0x00040000)        /* bit 18 */
-#define  NVIC_ISER_SETENA_19                 ((u32)0x00080000)        /* bit 19 */
-#define  NVIC_ISER_SETENA_20                 ((u32)0x00100000)        /* bit 20 */
-#define  NVIC_ISER_SETENA_21                 ((u32)0x00200000)        /* bit 21 */
-#define  NVIC_ISER_SETENA_22                 ((u32)0x00400000)        /* bit 22 */
-#define  NVIC_ISER_SETENA_23                 ((u32)0x00800000)        /* bit 23 */
-#define  NVIC_ISER_SETENA_24                 ((u32)0x01000000)        /* bit 24 */
-#define  NVIC_ISER_SETENA_25                 ((u32)0x02000000)        /* bit 25 */
-#define  NVIC_ISER_SETENA_26                 ((u32)0x04000000)        /* bit 26 */
-#define  NVIC_ISER_SETENA_27                 ((u32)0x08000000)        /* bit 27 */
-#define  NVIC_ISER_SETENA_28                 ((u32)0x10000000)        /* bit 28 */
-#define  NVIC_ISER_SETENA_29                 ((u32)0x20000000)        /* bit 29 */
-#define  NVIC_ISER_SETENA_30                 ((u32)0x40000000)        /* bit 30 */
-#define  NVIC_ISER_SETENA_31                 ((u32)0x80000000)        /* bit 31 */
-
-
-
-/******************  Bit definition for NVIC_ICER register  *******************/
-#define  NVIC_ICER_CLRENA                   ((u32)0xFFFFFFFF)        /* Interrupt clear-enable bits */
-#define  NVIC_ICER_CLRENA_0                  ((u32)0x00000001)        /* bit 0 */
-#define  NVIC_ICER_CLRENA_1                  ((u32)0x00000002)        /* bit 1 */
-#define  NVIC_ICER_CLRENA_2                  ((u32)0x00000004)        /* bit 2 */
-#define  NVIC_ICER_CLRENA_3                  ((u32)0x00000008)        /* bit 3 */
-#define  NVIC_ICER_CLRENA_4                  ((u32)0x00000010)        /* bit 4 */
-#define  NVIC_ICER_CLRENA_5                  ((u32)0x00000020)        /* bit 5 */
-#define  NVIC_ICER_CLRENA_6                  ((u32)0x00000040)        /* bit 6 */
-#define  NVIC_ICER_CLRENA_7                  ((u32)0x00000080)        /* bit 7 */
-#define  NVIC_ICER_CLRENA_8                  ((u32)0x00000100)        /* bit 8 */
-#define  NVIC_ICER_CLRENA_9                  ((u32)0x00000200)        /* bit 9 */
-#define  NVIC_ICER_CLRENA_10                 ((u32)0x00000400)        /* bit 10 */
-#define  NVIC_ICER_CLRENA_11                 ((u32)0x00000800)        /* bit 11 */
-#define  NVIC_ICER_CLRENA_12                 ((u32)0x00001000)        /* bit 12 */
-#define  NVIC_ICER_CLRENA_13                 ((u32)0x00002000)        /* bit 13 */
-#define  NVIC_ICER_CLRENA_14                 ((u32)0x00004000)        /* bit 14 */
-#define  NVIC_ICER_CLRENA_15                 ((u32)0x00008000)        /* bit 15 */
-#define  NVIC_ICER_CLRENA_16                 ((u32)0x00010000)        /* bit 16 */
-#define  NVIC_ICER_CLRENA_17                 ((u32)0x00020000)        /* bit 17 */
-#define  NVIC_ICER_CLRENA_18                 ((u32)0x00040000)        /* bit 18 */
-#define  NVIC_ICER_CLRENA_19                 ((u32)0x00080000)        /* bit 19 */
-#define  NVIC_ICER_CLRENA_20                 ((u32)0x00100000)        /* bit 20 */
-#define  NVIC_ICER_CLRENA_21                 ((u32)0x00200000)        /* bit 21 */
-#define  NVIC_ICER_CLRENA_22                 ((u32)0x00400000)        /* bit 22 */
-#define  NVIC_ICER_CLRENA_23                 ((u32)0x00800000)        /* bit 23 */
-#define  NVIC_ICER_CLRENA_24                 ((u32)0x01000000)        /* bit 24 */
-#define  NVIC_ICER_CLRENA_25                 ((u32)0x02000000)        /* bit 25 */
-#define  NVIC_ICER_CLRENA_26                 ((u32)0x04000000)        /* bit 26 */
-#define  NVIC_ICER_CLRENA_27                 ((u32)0x08000000)        /* bit 27 */
-#define  NVIC_ICER_CLRENA_28                 ((u32)0x10000000)        /* bit 28 */
-#define  NVIC_ICER_CLRENA_29                 ((u32)0x20000000)        /* bit 29 */
-#define  NVIC_ICER_CLRENA_30                 ((u32)0x40000000)        /* bit 30 */
-#define  NVIC_ICER_CLRENA_31                 ((u32)0x80000000)        /* bit 31 */
-
-
-/******************  Bit definition for NVIC_ISPR register  *******************/
-#define  NVIC_ISPR_SETPEND                   ((u32)0xFFFFFFFF)        /* Interrupt set-pending bits */
-#define  NVIC_ISPR_SETPEND_0                 ((u32)0x00000001)        /* bit 0 */
-#define  NVIC_ISPR_SETPEND_1                 ((u32)0x00000002)        /* bit 1 */
-#define  NVIC_ISPR_SETPEND_2                 ((u32)0x00000004)        /* bit 2 */
-#define  NVIC_ISPR_SETPEND_3                 ((u32)0x00000008)        /* bit 3 */
-#define  NVIC_ISPR_SETPEND_4                 ((u32)0x00000010)        /* bit 4 */
-#define  NVIC_ISPR_SETPEND_5                 ((u32)0x00000020)        /* bit 5 */
-#define  NVIC_ISPR_SETPEND_6                 ((u32)0x00000040)        /* bit 6 */
-#define  NVIC_ISPR_SETPEND_7                 ((u32)0x00000080)        /* bit 7 */
-#define  NVIC_ISPR_SETPEND_8                 ((u32)0x00000100)        /* bit 8 */
-#define  NVIC_ISPR_SETPEND_9                 ((u32)0x00000200)        /* bit 9 */
-#define  NVIC_ISPR_SETPEND_10                ((u32)0x00000400)        /* bit 10 */
-#define  NVIC_ISPR_SETPEND_11                ((u32)0x00000800)        /* bit 11 */
-#define  NVIC_ISPR_SETPEND_12                ((u32)0x00001000)        /* bit 12 */
-#define  NVIC_ISPR_SETPEND_13                ((u32)0x00002000)        /* bit 13 */
-#define  NVIC_ISPR_SETPEND_14                ((u32)0x00004000)        /* bit 14 */
-#define  NVIC_ISPR_SETPEND_15                ((u32)0x00008000)        /* bit 15 */
-#define  NVIC_ISPR_SETPEND_16                ((u32)0x00010000)        /* bit 16 */
-#define  NVIC_ISPR_SETPEND_17                ((u32)0x00020000)        /* bit 17 */
-#define  NVIC_ISPR_SETPEND_18                ((u32)0x00040000)        /* bit 18 */
-#define  NVIC_ISPR_SETPEND_19                ((u32)0x00080000)        /* bit 19 */
-#define  NVIC_ISPR_SETPEND_20                ((u32)0x00100000)        /* bit 20 */
-#define  NVIC_ISPR_SETPEND_21                ((u32)0x00200000)        /* bit 21 */
-#define  NVIC_ISPR_SETPEND_22                ((u32)0x00400000)        /* bit 22 */
-#define  NVIC_ISPR_SETPEND_23                ((u32)0x00800000)        /* bit 23 */
-#define  NVIC_ISPR_SETPEND_24                ((u32)0x01000000)        /* bit 24 */
-#define  NVIC_ISPR_SETPEND_25                ((u32)0x02000000)        /* bit 25 */
-#define  NVIC_ISPR_SETPEND_26                ((u32)0x04000000)        /* bit 26 */
-#define  NVIC_ISPR_SETPEND_27                ((u32)0x08000000)        /* bit 27 */
-#define  NVIC_ISPR_SETPEND_28                ((u32)0x10000000)        /* bit 28 */
-#define  NVIC_ISPR_SETPEND_29                ((u32)0x20000000)        /* bit 29 */
-#define  NVIC_ISPR_SETPEND_30                ((u32)0x40000000)        /* bit 30 */
-#define  NVIC_ISPR_SETPEND_31                ((u32)0x80000000)        /* bit 31 */
-
-
-/******************  Bit definition for NVIC_ICPR register  *******************/
-#define  NVIC_ICPR_CLRPEND                   ((u32)0xFFFFFFFF)        /* Interrupt clear-pending bits */
-#define  NVIC_ICPR_CLRPEND_0                 ((u32)0x00000001)        /* bit 0 */
-#define  NVIC_ICPR_CLRPEND_1                 ((u32)0x00000002)        /* bit 1 */
-#define  NVIC_ICPR_CLRPEND_2                 ((u32)0x00000004)        /* bit 2 */
-#define  NVIC_ICPR_CLRPEND_3                 ((u32)0x00000008)        /* bit 3 */
-#define  NVIC_ICPR_CLRPEND_4                 ((u32)0x00000010)        /* bit 4 */
-#define  NVIC_ICPR_CLRPEND_5                 ((u32)0x00000020)        /* bit 5 */
-#define  NVIC_ICPR_CLRPEND_6                 ((u32)0x00000040)        /* bit 6 */
-#define  NVIC_ICPR_CLRPEND_7                 ((u32)0x00000080)        /* bit 7 */
-#define  NVIC_ICPR_CLRPEND_8                 ((u32)0x00000100)        /* bit 8 */
-#define  NVIC_ICPR_CLRPEND_9                 ((u32)0x00000200)        /* bit 9 */
-#define  NVIC_ICPR_CLRPEND_10                ((u32)0x00000400)        /* bit 10 */
-#define  NVIC_ICPR_CLRPEND_11                ((u32)0x00000800)        /* bit 11 */
-#define  NVIC_ICPR_CLRPEND_12                ((u32)0x00001000)        /* bit 12 */
-#define  NVIC_ICPR_CLRPEND_13                ((u32)0x00002000)        /* bit 13 */
-#define  NVIC_ICPR_CLRPEND_14                ((u32)0x00004000)        /* bit 14 */
-#define  NVIC_ICPR_CLRPEND_15                ((u32)0x00008000)        /* bit 15 */
-#define  NVIC_ICPR_CLRPEND_16                ((u32)0x00010000)        /* bit 16 */
-#define  NVIC_ICPR_CLRPEND_17                ((u32)0x00020000)        /* bit 17 */
-#define  NVIC_ICPR_CLRPEND_18                ((u32)0x00040000)        /* bit 18 */
-#define  NVIC_ICPR_CLRPEND_19                ((u32)0x00080000)        /* bit 19 */
-#define  NVIC_ICPR_CLRPEND_20                ((u32)0x00100000)        /* bit 20 */
-#define  NVIC_ICPR_CLRPEND_21                ((u32)0x00200000)        /* bit 21 */
-#define  NVIC_ICPR_CLRPEND_22                ((u32)0x00400000)        /* bit 22 */
-#define  NVIC_ICPR_CLRPEND_23                ((u32)0x00800000)        /* bit 23 */
-#define  NVIC_ICPR_CLRPEND_24                ((u32)0x01000000)        /* bit 24 */
-#define  NVIC_ICPR_CLRPEND_25                ((u32)0x02000000)        /* bit 25 */
-#define  NVIC_ICPR_CLRPEND_26                ((u32)0x04000000)        /* bit 26 */
-#define  NVIC_ICPR_CLRPEND_27                ((u32)0x08000000)        /* bit 27 */
-#define  NVIC_ICPR_CLRPEND_28                ((u32)0x10000000)        /* bit 28 */
-#define  NVIC_ICPR_CLRPEND_29                ((u32)0x20000000)        /* bit 29 */
-#define  NVIC_ICPR_CLRPEND_30                ((u32)0x40000000)        /* bit 30 */
-#define  NVIC_ICPR_CLRPEND_31                ((u32)0x80000000)        /* bit 31 */
-
-
-/******************  Bit definition for NVIC_IABR register  *******************/
-#define  NVIC_IABR_ACTIVE                    ((u32)0xFFFFFFFF)        /* Interrupt active flags */
-#define  NVIC_IABR_ACTIVE_0                  ((u32)0x00000001)        /* bit 0 */
-#define  NVIC_IABR_ACTIVE_1                  ((u32)0x00000002)        /* bit 1 */
-#define  NVIC_IABR_ACTIVE_2                  ((u32)0x00000004)        /* bit 2 */
-#define  NVIC_IABR_ACTIVE_3                  ((u32)0x00000008)        /* bit 3 */
-#define  NVIC_IABR_ACTIVE_4                  ((u32)0x00000010)        /* bit 4 */
-#define  NVIC_IABR_ACTIVE_5                  ((u32)0x00000020)        /* bit 5 */
-#define  NVIC_IABR_ACTIVE_6                  ((u32)0x00000040)        /* bit 6 */
-#define  NVIC_IABR_ACTIVE_7                  ((u32)0x00000080)        /* bit 7 */
-#define  NVIC_IABR_ACTIVE_8                  ((u32)0x00000100)        /* bit 8 */
-#define  NVIC_IABR_ACTIVE_9                  ((u32)0x00000200)        /* bit 9 */
-#define  NVIC_IABR_ACTIVE_10                 ((u32)0x00000400)        /* bit 10 */
-#define  NVIC_IABR_ACTIVE_11                 ((u32)0x00000800)        /* bit 11 */
-#define  NVIC_IABR_ACTIVE_12                 ((u32)0x00001000)        /* bit 12 */
-#define  NVIC_IABR_ACTIVE_13                 ((u32)0x00002000)        /* bit 13 */
-#define  NVIC_IABR_ACTIVE_14                 ((u32)0x00004000)        /* bit 14 */
-#define  NVIC_IABR_ACTIVE_15                 ((u32)0x00008000)        /* bit 15 */
-#define  NVIC_IABR_ACTIVE_16                 ((u32)0x00010000)        /* bit 16 */
-#define  NVIC_IABR_ACTIVE_17                 ((u32)0x00020000)        /* bit 17 */
-#define  NVIC_IABR_ACTIVE_18                 ((u32)0x00040000)        /* bit 18 */
-#define  NVIC_IABR_ACTIVE_19                 ((u32)0x00080000)        /* bit 19 */
-#define  NVIC_IABR_ACTIVE_20                 ((u32)0x00100000)        /* bit 20 */
-#define  NVIC_IABR_ACTIVE_21                 ((u32)0x00200000)        /* bit 21 */
-#define  NVIC_IABR_ACTIVE_22                 ((u32)0x00400000)        /* bit 22 */
-#define  NVIC_IABR_ACTIVE_23                 ((u32)0x00800000)        /* bit 23 */
-#define  NVIC_IABR_ACTIVE_24                 ((u32)0x01000000)        /* bit 24 */
-#define  NVIC_IABR_ACTIVE_25                 ((u32)0x02000000)        /* bit 25 */
-#define  NVIC_IABR_ACTIVE_26                 ((u32)0x04000000)        /* bit 26 */
-#define  NVIC_IABR_ACTIVE_27                 ((u32)0x08000000)        /* bit 27 */
-#define  NVIC_IABR_ACTIVE_28                 ((u32)0x10000000)        /* bit 28 */
-#define  NVIC_IABR_ACTIVE_29                 ((u32)0x20000000)        /* bit 29 */
-#define  NVIC_IABR_ACTIVE_30                 ((u32)0x40000000)        /* bit 30 */
-#define  NVIC_IABR_ACTIVE_31                 ((u32)0x80000000)        /* bit 31 */
-
-
-/******************  Bit definition for NVIC_PRI0 register  *******************/
-#define  NVIC_IPR0_PRI_0                     ((u32)0x000000FF)        /* Priority of interrupt 0 */
-#define  NVIC_IPR0_PRI_1                     ((u32)0x0000FF00)        /* Priority of interrupt 1 */
-#define  NVIC_IPR0_PRI_2                     ((u32)0x00FF0000)        /* Priority of interrupt 2 */
-#define  NVIC_IPR0_PRI_3                     ((u32)0xFF000000)        /* Priority of interrupt 3 */
-
-
-/******************  Bit definition for NVIC_PRI1 register  *******************/
-#define  NVIC_IPR1_PRI_4                     ((u32)0x000000FF)        /* Priority of interrupt 4 */
-#define  NVIC_IPR1_PRI_5                     ((u32)0x0000FF00)        /* Priority of interrupt 5 */
-#define  NVIC_IPR1_PRI_6                     ((u32)0x00FF0000)        /* Priority of interrupt 6 */
-#define  NVIC_IPR1_PRI_7                     ((u32)0xFF000000)        /* Priority of interrupt 7 */
-
-
-/******************  Bit definition for NVIC_PRI2 register  *******************/
-#define  NVIC_IPR2_PRI_8                     ((u32)0x000000FF)        /* Priority of interrupt 8 */
-#define  NVIC_IPR2_PRI_9                     ((u32)0x0000FF00)        /* Priority of interrupt 9 */
-#define  NVIC_IPR2_PRI_10                    ((u32)0x00FF0000)        /* Priority of interrupt 10 */
-#define  NVIC_IPR2_PRI_11                    ((u32)0xFF000000)        /* Priority of interrupt 11 */
-
-
-/******************  Bit definition for NVIC_PRI3 register  *******************/
-#define  NVIC_IPR3_PRI_12                    ((u32)0x000000FF)        /* Priority of interrupt 12 */
-#define  NVIC_IPR3_PRI_13                    ((u32)0x0000FF00)        /* Priority of interrupt 13 */
-#define  NVIC_IPR3_PRI_14                    ((u32)0x00FF0000)        /* Priority of interrupt 14 */
-#define  NVIC_IPR3_PRI_15                    ((u32)0xFF000000)        /* Priority of interrupt 15 */
-
-
-/******************  Bit definition for NVIC_PRI4 register  *******************/
-#define  NVIC_IPR4_PRI_16                    ((u32)0x000000FF)        /* Priority of interrupt 16 */
-#define  NVIC_IPR4_PRI_17                    ((u32)0x0000FF00)        /* Priority of interrupt 17 */
-#define  NVIC_IPR4_PRI_18                    ((u32)0x00FF0000)        /* Priority of interrupt 18 */
-#define  NVIC_IPR4_PRI_19                    ((u32)0xFF000000)        /* Priority of interrupt 19 */
-
-
-/******************  Bit definition for NVIC_PRI5 register  *******************/
-#define  NVIC_IPR5_PRI_20                    ((u32)0x000000FF)        /* Priority of interrupt 20 */
-#define  NVIC_IPR5_PRI_21                    ((u32)0x0000FF00)        /* Priority of interrupt 21 */
-#define  NVIC_IPR5_PRI_22                    ((u32)0x00FF0000)        /* Priority of interrupt 22 */
-#define  NVIC_IPR5_PRI_23                    ((u32)0xFF000000)        /* Priority of interrupt 23 */
-
-
-/******************  Bit definition for NVIC_PRI6 register  *******************/
-#define  NVIC_IPR6_PRI_24                    ((u32)0x000000FF)        /* Priority of interrupt 24 */
-#define  NVIC_IPR6_PRI_25                    ((u32)0x0000FF00)        /* Priority of interrupt 25 */
-#define  NVIC_IPR6_PRI_26                    ((u32)0x00FF0000)        /* Priority of interrupt 26 */
-#define  NVIC_IPR6_PRI_27                    ((u32)0xFF000000)        /* Priority of interrupt 27 */
-
-
-/******************  Bit definition for NVIC_PRI7 register  *******************/
-#define  NVIC_IPR7_PRI_28                    ((u32)0x000000FF)        /* Priority of interrupt 28 */
-#define  NVIC_IPR7_PRI_29                    ((u32)0x0000FF00)        /* Priority of interrupt 29 */
-#define  NVIC_IPR7_PRI_30                    ((u32)0x00FF0000)        /* Priority of interrupt 30 */
-#define  NVIC_IPR7_PRI_31                    ((u32)0xFF000000)        /* Priority of interrupt 31 */
-
-
-/******************  Bit definition for SCB_CPUID register  *******************/
-#define  SCB_CPUID_REVISION                  ((u32)0x0000000F)        /* Implementation defined revision number */
-#define  SCB_CPUID_PARTNO                    ((u32)0x0000FFF0)        /* Number of processor within family */
-#define  SCB_CPUID_Constant                  ((u32)0x000F0000)        /* Reads as 0x0F */
-#define  SCB_CPUID_VARIANT                   ((u32)0x00F00000)        /* Implementation defined variant number */
-#define  SCB_CPUID_IMPLEMENTER               ((u32)0xFF000000)        /* Implementer code. ARM is 0x41 */
-
-
-/*******************  Bit definition for SCB_ICSR register  *******************/
-#define  SCB_ICSR_VECTACTIVE                 ((u32)0x000001FF)        /* Active ISR number field */
-#define  SCB_ICSR_RETTOBASE                  ((u32)0x00000800)        /* All active exceptions minus the IPSR_current_exception yields the empty set */
-#define  SCB_ICSR_VECTPENDING                ((u32)0x003FF000)        /* Pending ISR number field */
-#define  SCB_ICSR_ISRPENDING                 ((u32)0x00400000)        /* Interrupt pending flag */
-#define  SCB_ICSR_ISRPREEMPT                 ((u32)0x00800000)        /* It indicates that a pending interrupt becomes active in the next running cycle */
-#define  SCB_ICSR_PENDSTCLR                  ((u32)0x02000000)        /* Clear pending SysTick bit */
-#define  SCB_ICSR_PENDSTSET                  ((u32)0x04000000)        /* Set pending SysTick bit */
-#define  SCB_ICSR_PENDSVCLR                  ((u32)0x08000000)        /* Clear pending pendSV bit */
-#define  SCB_ICSR_PENDSVSET                  ((u32)0x10000000)        /* Set pending pendSV bit */
-#define  SCB_ICSR_NMIPENDSET                 ((u32)0x80000000)        /* Set pending NMI bit */
-
-
-/*******************  Bit definition for SCB_VTOR register  *******************/
-#define  SCB_VTOR_TBLOFF                     ((u32)0x1FFFFF80)        /* Vector table base offset field */
-#define  SCB_VTOR_TBLBASE                    ((u32)0x20000000)        /* Table base in code(0) or RAM(1) */
-
-
-/******************  Bit definition for SCB_AIRCR register  *******************/
-#define  SCB_AIRCR_VECTRESET                 ((u32)0x00000001)        /* System Reset bit */
-#define  SCB_AIRCR_VECTCLRACTIVE             ((u32)0x00000002)        /* Clear active vector bit */
-#define  SCB_AIRCR_SYSRESETREQ               ((u32)0x00000004)        /* Requests chip control logic to generate a reset */
-
-#define  SCB_AIRCR_PRIGROUP                  ((u32)0x00000700)        /* PRIGROUP[2:0] bits (Priority group) */
-#define  SCB_AIRCR_PRIGROUP_0                ((u32)0x00000100)        /* Bit 0 */
-#define  SCB_AIRCR_PRIGROUP_1                ((u32)0x00000200)        /* Bit 1 */
-#define  SCB_AIRCR_PRIGROUP_2                ((u32)0x00000400)        /* Bit 2  */
-
-/* prority group configuration */
-#define  SCB_AIRCR_PRIGROUP0                 ((u32)0x00000000)        /* Priority group=0 (7 bits of pre-emption priority, 1 bit of subpriority) */
-#define  SCB_AIRCR_PRIGROUP1                 ((u32)0x00000100)        /* Priority group=1 (6 bits of pre-emption priority, 2 bits of subpriority) */
-#define  SCB_AIRCR_PRIGROUP2                 ((u32)0x00000200)        /* Priority group=2 (5 bits of pre-emption priority, 3 bits of subpriority) */
-#define  SCB_AIRCR_PRIGROUP3                 ((u32)0x00000300)        /* Priority group=3 (4 bits of pre-emption priority, 4 bits of subpriority) */
-#define  SCB_AIRCR_PRIGROUP4                 ((u32)0x00000400)        /* Priority group=4 (3 bits of pre-emption priority, 5 bits of subpriority) */
-#define  SCB_AIRCR_PRIGROUP5                 ((u32)0x00000500)        /* Priority group=5 (2 bits of pre-emption priority, 6 bits of subpriority) */
-#define  SCB_AIRCR_PRIGROUP6                 ((u32)0x00000600)        /* Priority group=6 (1 bit of pre-emption priority, 7 bits of subpriority) */
-#define  SCB_AIRCR_PRIGROUP7                 ((u32)0x00000700)        /* Priority group=7 (no pre-emption priority, 8 bits of subpriority) */
-
-#define  SCB_AIRCR_ENDIANESS                 ((u32)0x00008000)        /* Data endianness bit */
-#define  SCB_AIRCR_VECTKEY                   ((u32)0xFFFF0000)        /* Register key (VECTKEY) - Reads as 0xFA05 (VECTKEYSTAT) */
-
-
-/*******************  Bit definition for SCB_SCR register  ********************/
-#define  SCB_SCR_SLEEPONEXIT                 ((u8)0x02)               /* Sleep on exit bit */
-#define  SCB_SCR_SLEEPDEEP                   ((u8)0x04)               /* Sleep deep bit */
-#define  SCB_SCR_SEVONPEND                   ((u8)0x10)               /* Wake up from WFE */
-
-
-/********************  Bit definition for SCB_CCR register  *******************/
-#define  SCB_CCR_NONBASETHRDENA              ((u16)0x0001)            /* Thread mode can be entered from any level in Handler mode by controlled return value */
-#define  SCB_CCR_USERSETMPEND                ((u16)0x0002)            /* Enables user code to write the Software Trigger Interrupt register to trigger (pend) a Main exception */
-#define  SCB_CCR_UNALIGN_TRP                 ((u16)0x0008)            /* Trap for unaligned access */
-#define  SCB_CCR_DIV_0_TRP                   ((u16)0x0010)            /* Trap on Divide by 0 */
-#define  SCB_CCR_BFHFNMIGN                   ((u16)0x0100)            /* Handlers running at priority -1 and -2 */
-#define  SCB_CCR_STKALIGN                    ((u16)0x0200)            /* On exception entry, the SP used prior to the exception is adjusted to be 8-byte aligned */
-
-
-/*******************  Bit definition for SCB_SHPR register ********************/
-#define  SCB_SHPR_PRI_N                      ((u32)0x000000FF)        /* Priority of system handler 4,8, and 12. Mem Manage, reserved and Debug Monitor */
-#define  SCB_SHPR_PRI_N1                     ((u32)0x0000FF00)        /* Priority of system handler 5,9, and 13. Bus Fault, reserved and reserved */
-#define  SCB_SHPR_PRI_N2                     ((u32)0x00FF0000)        /* Priority of system handler 6,10, and 14. Usage Fault, reserved and PendSV */
-#define  SCB_SHPR_PRI_N3                     ((u32)0xFF000000)        /* Priority of system handler 7,11, and 15. Reserved, SVCall and SysTick */
-
-
-/******************  Bit definition for SCB_SHCSR register  *******************/
-#define  SCB_SHCSR_MEMFAULTACT               ((u32)0x00000001)        /* MemManage is active */
-#define  SCB_SHCSR_BUSFAULTACT               ((u32)0x00000002)        /* BusFault is active */
-#define  SCB_SHCSR_USGFAULTACT               ((u32)0x00000008)        /* UsageFault is active */
-#define  SCB_SHCSR_SVCALLACT                 ((u32)0x00000080)        /* SVCall is active */
-#define  SCB_SHCSR_MONITORACT                ((u32)0x00000100)        /* Monitor is active */
-#define  SCB_SHCSR_PENDSVACT                 ((u32)0x00000400)        /* PendSV is active */
-#define  SCB_SHCSR_SYSTICKACT                ((u32)0x00000800)        /* SysTick is active */
-#define  SCB_SHCSR_USGFAULTPENDED            ((u32)0x00001000)        /* Usage Fault is pended */
-#define  SCB_SHCSR_MEMFAULTPENDED            ((u32)0x00002000)        /* MemManage is pended */
-#define  SCB_SHCSR_BUSFAULTPENDED            ((u32)0x00004000)        /* Bus Fault is pended */
-#define  SCB_SHCSR_SVCALLPENDED              ((u32)0x00008000)        /* SVCall is pended */
-#define  SCB_SHCSR_MEMFAULTENA               ((u32)0x00010000)        /* MemManage enable */
-#define  SCB_SHCSR_BUSFAULTENA               ((u32)0x00020000)        /* Bus Fault enable */
-#define  SCB_SHCSR_USGFAULTENA               ((u32)0x00040000)        /* UsageFault enable */
-
-
-/*******************  Bit definition for SCB_CFSR register  *******************/
-/* MFSR */
-#define  SCB_CFSR_IACCVIOL                   ((u32)0x00000001)        /* Instruction access violation */
-#define  SCB_CFSR_DACCVIOL                   ((u32)0x00000002)        /* Data access violation */
-#define  SCB_CFSR_MUNSTKERR                  ((u32)0x00000008)        /* Unstacking error */
-#define  SCB_CFSR_MSTKERR                    ((u32)0x00000010)        /* Stacking error */
-#define  SCB_CFSR_MMARVALID                  ((u32)0x00000080)        /* Memory Manage Address Register address valid flag */
-/* BFSR */
-#define  SCB_CFSR_IBUSERR                    ((u32)0x00000100)        /* Instruction bus error flag */
-#define  SCB_CFSR_PRECISERR                  ((u32)0x00000200)        /* Precise data bus error */
-#define  SCB_CFSR_IMPRECISERR                ((u32)0x00000400)        /* Imprecise data bus error */
-#define  SCB_CFSR_UNSTKERR                   ((u32)0x00000800)        /* Unstacking error */
-#define  SCB_CFSR_STKERR                     ((u32)0x00001000)        /* Stacking error */
-#define  SCB_CFSR_BFARVALID                  ((u32)0x00008000)        /* Bus Fault Address Register address valid flag */
-/* UFSR */
-#define  SCB_CFSR_UNDEFINSTR                 ((u32)0x00010000)        /* The processor attempt to excecute an undefined instruction */
-#define  SCB_CFSR_INVSTATE                   ((u32)0x00020000)        /* Invalid combination of EPSR and instruction */
-#define  SCB_CFSR_INVPC                      ((u32)0x00040000)        /* Attempt to load EXC_RETURN into pc illegally */
-#define  SCB_CFSR_NOCP                       ((u32)0x00080000)        /* Attempt to use a coprocessor instruction */
-#define  SCB_CFSR_UNALIGNED                  ((u32)0x01000000)        /* Fault occurs when there is an attempt to make an unaligned memory access */
-#define  SCB_CFSR_DIVBYZERO                  ((u32)0x02000000)        /* Fault occurs when SDIV or DIV instruction is used with a divisor of 0 */
-
-
-/*******************  Bit definition for SCB_HFSR register  *******************/
-#define  SCB_HFSR_VECTTBL                    ((u32)0x00000002)        /* Fault occures because of vector table read on exception processing */
-#define  SCB_HFSR_FORCED                     ((u32)0x40000000)        /* Hard Fault activated when a configurable Fault was received and cannot activate */
-#define  SCB_HFSR_DEBUGEVT                   ((u32)0x80000000)        /* Fault related to debug */
-
-
-/*******************  Bit definition for SCB_DFSR register  *******************/
-#define  SCB_DFSR_HALTED                     ((u8)0x01)               /* Halt request flag */
-#define  SCB_DFSR_BKPT                       ((u8)0x02)               /* BKPT flag */
-#define  SCB_DFSR_DWTTRAP                    ((u8)0x04)               /* Data Watchpoint and Trace (DWT) flag */
-#define  SCB_DFSR_VCATCH                     ((u8)0x08)               /* Vector catch flag */
-#define  SCB_DFSR_EXTERNAL                   ((u8)0x10)               /* External debug request flag */
-
-
-/*******************  Bit definition for SCB_MMFAR register  ******************/
-#define  SCB_MMFAR_ADDRESS                   ((u32)0xFFFFFFFF)        /* Mem Manage fault address field */
-
-
-/*******************  Bit definition for SCB_BFAR register  *******************/
-#define  SCB_BFAR_ADDRESS                    ((u32)0xFFFFFFFF)        /* Bus fault address field */
-
-
-/*******************  Bit definition for SCB_afsr register  *******************/
-#define  SCB_AFSR_IMPDEF                     ((u32)0xFFFFFFFF)        /* Implementation defined */
-
-
-
-/******************************************************************************/
-/*                                                                            */
-/*                    External Interrupt/Event Controller                     */
-/*                                                                            */
-/******************************************************************************/
-
-/*******************  Bit definition for EXTI_IMR register  *******************/
-#define  EXTI_IMR_MR0                        ((u32)0x00000001)        /* Interrupt Mask on line 0 */
-#define  EXTI_IMR_MR1                        ((u32)0x00000002)        /* Interrupt Mask on line 1 */
-#define  EXTI_IMR_MR2                        ((u32)0x00000004)        /* Interrupt Mask on line 2 */
-#define  EXTI_IMR_MR3                        ((u32)0x00000008)        /* Interrupt Mask on line 3 */
-#define  EXTI_IMR_MR4                        ((u32)0x00000010)        /* Interrupt Mask on line 4 */
-#define  EXTI_IMR_MR5                        ((u32)0x00000020)        /* Interrupt Mask on line 5 */
-#define  EXTI_IMR_MR6                        ((u32)0x00000040)        /* Interrupt Mask on line 6 */
-#define  EXTI_IMR_MR7                        ((u32)0x00000080)        /* Interrupt Mask on line 7 */
-#define  EXTI_IMR_MR8                        ((u32)0x00000100)        /* Interrupt Mask on line 8 */
-#define  EXTI_IMR_MR9                        ((u32)0x00000200)        /* Interrupt Mask on line 9 */
-#define  EXTI_IMR_MR10                       ((u32)0x00000400)        /* Interrupt Mask on line 10 */
-#define  EXTI_IMR_MR11                       ((u32)0x00000800)        /* Interrupt Mask on line 11 */
-#define  EXTI_IMR_MR12                       ((u32)0x00001000)        /* Interrupt Mask on line 12 */
-#define  EXTI_IMR_MR13                       ((u32)0x00002000)        /* Interrupt Mask on line 13 */
-#define  EXTI_IMR_MR14                       ((u32)0x00004000)        /* Interrupt Mask on line 14 */
-#define  EXTI_IMR_MR15                       ((u32)0x00008000)        /* Interrupt Mask on line 15 */
-#define  EXTI_IMR_MR16                       ((u32)0x00010000)        /* Interrupt Mask on line 16 */
-#define  EXTI_IMR_MR17                       ((u32)0x00020000)        /* Interrupt Mask on line 17 */
-#define  EXTI_IMR_MR18                       ((u32)0x00040000)        /* Interrupt Mask on line 18 */
-
-
-/*******************  Bit definition for EXTI_EMR register  *******************/
-#define  EXTI_EMR_MR0                        ((u32)0x00000001)        /* Event Mask on line 0 */
-#define  EXTI_EMR_MR1                        ((u32)0x00000002)        /* Event Mask on line 1 */
-#define  EXTI_EMR_MR2                        ((u32)0x00000004)        /* Event Mask on line 2 */
-#define  EXTI_EMR_MR3                        ((u32)0x00000008)        /* Event Mask on line 3 */
-#define  EXTI_EMR_MR4                        ((u32)0x00000010)        /* Event Mask on line 4 */
-#define  EXTI_EMR_MR5                        ((u32)0x00000020)        /* Event Mask on line 5 */
-#define  EXTI_EMR_MR6                        ((u32)0x00000040)        /* Event Mask on line 6 */
-#define  EXTI_EMR_MR7                        ((u32)0x00000080)        /* Event Mask on line 7 */
-#define  EXTI_EMR_MR8                        ((u32)0x00000100)        /* Event Mask on line 8 */
-#define  EXTI_EMR_MR9                        ((u32)0x00000200)        /* Event Mask on line 9 */
-#define  EXTI_EMR_MR10                       ((u32)0x00000400)        /* Event Mask on line 10 */
-#define  EXTI_EMR_MR11                       ((u32)0x00000800)        /* Event Mask on line 11 */
-#define  EXTI_EMR_MR12                       ((u32)0x00001000)        /* Event Mask on line 12 */
-#define  EXTI_EMR_MR13                       ((u32)0x00002000)        /* Event Mask on line 13 */
-#define  EXTI_EMR_MR14                       ((u32)0x00004000)        /* Event Mask on line 14 */
-#define  EXTI_EMR_MR15                       ((u32)0x00008000)        /* Event Mask on line 15 */
-#define  EXTI_EMR_MR16                       ((u32)0x00010000)        /* Event Mask on line 16 */
-#define  EXTI_EMR_MR17                       ((u32)0x00020000)        /* Event Mask on line 17 */
-#define  EXTI_EMR_MR18                       ((u32)0x00040000)        /* Event Mask on line 18 */
-
-
-/******************  Bit definition for EXTI_RTSR register  *******************/
-#define  EXTI_RTSR_TR0                       ((u32)0x00000001)        /* Rising trigger event configuration bit of line 0 */
-#define  EXTI_RTSR_TR1                       ((u32)0x00000002)        /* Rising trigger event configuration bit of line 1 */
-#define  EXTI_RTSR_TR2                       ((u32)0x00000004)        /* Rising trigger event configuration bit of line 2 */
-#define  EXTI_RTSR_TR3                       ((u32)0x00000008)        /* Rising trigger event configuration bit of line 3 */
-#define  EXTI_RTSR_TR4                       ((u32)0x00000010)        /* Rising trigger event configuration bit of line 4 */
-#define  EXTI_RTSR_TR5                       ((u32)0x00000020)        /* Rising trigger event configuration bit of line 5 */
-#define  EXTI_RTSR_TR6                       ((u32)0x00000040)        /* Rising trigger event configuration bit of line 6 */
-#define  EXTI_RTSR_TR7                       ((u32)0x00000080)        /* Rising trigger event configuration bit of line 7 */
-#define  EXTI_RTSR_TR8                       ((u32)0x00000100)        /* Rising trigger event configuration bit of line 8 */
-#define  EXTI_RTSR_TR9                       ((u32)0x00000200)        /* Rising trigger event configuration bit of line 9 */
-#define  EXTI_RTSR_TR10                      ((u32)0x00000400)        /* Rising trigger event configuration bit of line 10 */
-#define  EXTI_RTSR_TR11                      ((u32)0x00000800)        /* Rising trigger event configuration bit of line 11 */
-#define  EXTI_RTSR_TR12                      ((u32)0x00001000)        /* Rising trigger event configuration bit of line 12 */
-#define  EXTI_RTSR_TR13                      ((u32)0x00002000)        /* Rising trigger event configuration bit of line 13 */
-#define  EXTI_RTSR_TR14                      ((u32)0x00004000)        /* Rising trigger event configuration bit of line 14 */
-#define  EXTI_RTSR_TR15                      ((u32)0x00008000)        /* Rising trigger event configuration bit of line 15 */
-#define  EXTI_RTSR_TR16                      ((u32)0x00010000)        /* Rising trigger event configuration bit of line 16 */
-#define  EXTI_RTSR_TR17                      ((u32)0x00020000)        /* Rising trigger event configuration bit of line 17 */
-#define  EXTI_RTSR_TR18                      ((u32)0x00040000)        /* Rising trigger event configuration bit of line 18 */
-
-
-/******************  Bit definition for EXTI_FTSR register  *******************/
-#define  EXTI_FTSR_TR0                       ((u32)0x00000001)        /* Falling trigger event configuration bit of line 0 */
-#define  EXTI_FTSR_TR1                       ((u32)0x00000002)        /* Falling trigger event configuration bit of line 1 */
-#define  EXTI_FTSR_TR2                       ((u32)0x00000004)        /* Falling trigger event configuration bit of line 2 */
-#define  EXTI_FTSR_TR3                       ((u32)0x00000008)        /* Falling trigger event configuration bit of line 3 */
-#define  EXTI_FTSR_TR4                       ((u32)0x00000010)        /* Falling trigger event configuration bit of line 4 */
-#define  EXTI_FTSR_TR5                       ((u32)0x00000020)        /* Falling trigger event configuration bit of line 5 */
-#define  EXTI_FTSR_TR6                       ((u32)0x00000040)        /* Falling trigger event configuration bit of line 6 */
-#define  EXTI_FTSR_TR7                       ((u32)0x00000080)        /* Falling trigger event configuration bit of line 7 */
-#define  EXTI_FTSR_TR8                       ((u32)0x00000100)        /* Falling trigger event configuration bit of line 8 */
-#define  EXTI_FTSR_TR9                       ((u32)0x00000200)        /* Falling trigger event configuration bit of line 9 */
-#define  EXTI_FTSR_TR10                      ((u32)0x00000400)        /* Falling trigger event configuration bit of line 10 */
-#define  EXTI_FTSR_TR11                      ((u32)0x00000800)        /* Falling trigger event configuration bit of line 11 */
-#define  EXTI_FTSR_TR12                      ((u32)0x00001000)        /* Falling trigger event configuration bit of line 12 */
-#define  EXTI_FTSR_TR13                      ((u32)0x00002000)        /* Falling trigger event configuration bit of line 13 */
-#define  EXTI_FTSR_TR14                      ((u32)0x00004000)        /* Falling trigger event configuration bit of line 14 */
-#define  EXTI_FTSR_TR15                      ((u32)0x00008000)        /* Falling trigger event configuration bit of line 15 */
-#define  EXTI_FTSR_TR16                      ((u32)0x00010000)        /* Falling trigger event configuration bit of line 16 */
-#define  EXTI_FTSR_TR17                      ((u32)0x00020000)        /* Falling trigger event configuration bit of line 17 */
-#define  EXTI_FTSR_TR18                      ((u32)0x00040000)        /* Falling trigger event configuration bit of line 18 */
-
-
-/******************  Bit definition for EXTI_SWIER register  ******************/
-#define  EXTI_SWIER_SWIER0                   ((u32)0x00000001)        /* Software Interrupt on line 0 */
-#define  EXTI_SWIER_SWIER1                   ((u32)0x00000002)        /* Software Interrupt on line 1 */
-#define  EXTI_SWIER_SWIER2                   ((u32)0x00000004)        /* Software Interrupt on line 2 */
-#define  EXTI_SWIER_SWIER3                   ((u32)0x00000008)        /* Software Interrupt on line 3 */
-#define  EXTI_SWIER_SWIER4                   ((u32)0x00000010)        /* Software Interrupt on line 4 */
-#define  EXTI_SWIER_SWIER5                   ((u32)0x00000020)        /* Software Interrupt on line 5 */
-#define  EXTI_SWIER_SWIER6                   ((u32)0x00000040)        /* Software Interrupt on line 6 */
-#define  EXTI_SWIER_SWIER7                   ((u32)0x00000080)        /* Software Interrupt on line 7 */
-#define  EXTI_SWIER_SWIER8                   ((u32)0x00000100)        /* Software Interrupt on line 8 */
-#define  EXTI_SWIER_SWIER9                   ((u32)0x00000200)        /* Software Interrupt on line 9 */
-#define  EXTI_SWIER_SWIER10                  ((u32)0x00000400)        /* Software Interrupt on line 10 */
-#define  EXTI_SWIER_SWIER11                  ((u32)0x00000800)        /* Software Interrupt on line 11 */
-#define  EXTI_SWIER_SWIER12                  ((u32)0x00001000)        /* Software Interrupt on line 12 */
-#define  EXTI_SWIER_SWIER13                  ((u32)0x00002000)        /* Software Interrupt on line 13 */
-#define  EXTI_SWIER_SWIER14                  ((u32)0x00004000)        /* Software Interrupt on line 14 */
-#define  EXTI_SWIER_SWIER15                  ((u32)0x00008000)        /* Software Interrupt on line 15 */
-#define  EXTI_SWIER_SWIER16                  ((u32)0x00010000)        /* Software Interrupt on line 16 */
-#define  EXTI_SWIER_SWIER17                  ((u32)0x00020000)        /* Software Interrupt on line 17 */
-#define  EXTI_SWIER_SWIER18                  ((u32)0x00040000)        /* Software Interrupt on line 18 */
-
-
-/*******************  Bit definition for EXTI_PR register  ********************/
-#define  EXTI_PR_PR0                         ((u32)0x00000001)        /* Pending bit 0 */
-#define  EXTI_PR_PR1                         ((u32)0x00000002)        /* Pending bit 1 */
-#define  EXTI_PR_PR2                         ((u32)0x00000004)        /* Pending bit 2 */
-#define  EXTI_PR_PR3                         ((u32)0x00000008)        /* Pending bit 3 */
-#define  EXTI_PR_PR4                         ((u32)0x00000010)        /* Pending bit 4 */
-#define  EXTI_PR_PR5                         ((u32)0x00000020)        /* Pending bit 5 */
-#define  EXTI_PR_PR6                         ((u32)0x00000040)        /* Pending bit 6 */
-#define  EXTI_PR_PR7                         ((u32)0x00000080)        /* Pending bit 7 */
-#define  EXTI_PR_PR8                         ((u32)0x00000100)        /* Pending bit 8 */
-#define  EXTI_PR_PR9                         ((u32)0x00000200)        /* Pending bit 9 */
-#define  EXTI_PR_PR10                        ((u32)0x00000400)        /* Pending bit 10 */
-#define  EXTI_PR_PR11                        ((u32)0x00000800)        /* Pending bit 11 */
-#define  EXTI_PR_PR12                        ((u32)0x00001000)        /* Pending bit 12 */
-#define  EXTI_PR_PR13                        ((u32)0x00002000)        /* Pending bit 13 */
-#define  EXTI_PR_PR14                        ((u32)0x00004000)        /* Pending bit 14 */
-#define  EXTI_PR_PR15                        ((u32)0x00008000)        /* Pending bit 15 */
-#define  EXTI_PR_PR16                        ((u32)0x00010000)        /* Pending bit 16 */
-#define  EXTI_PR_PR17                        ((u32)0x00020000)        /* Pending bit 17 */
-#define  EXTI_PR_PR18                        ((u32)0x00040000)        /* Trigger request occurred on the external interrupt line 18 */
-
-
-
-/******************************************************************************/
-/*                                                                            */
-/*                             DMA Controller                                 */
-/*                                                                            */
-/******************************************************************************/
-
-/*******************  Bit definition for DMA_ISR register  ********************/
-#define  DMA_ISR_GIF1                        ((u32)0x00000001)        /* Channel 1 Global interrupt flag */
-#define  DMA_ISR_TCIF1                       ((u32)0x00000002)        /* Channel 1 Transfer Complete flag */
-#define  DMA_ISR_HTIF1                       ((u32)0x00000004)        /* Channel 1 Half Transfer flag */
-#define  DMA_ISR_TEIF1                       ((u32)0x00000008)        /* Channel 1 Transfer Error flag */
-#define  DMA_ISR_GIF2                        ((u32)0x00000010)        /* Channel 2 Global interrupt flag */
-#define  DMA_ISR_TCIF2                       ((u32)0x00000020)        /* Channel 2 Transfer Complete flag */
-#define  DMA_ISR_HTIF2                       ((u32)0x00000040)        /* Channel 2 Half Transfer flag */
-#define  DMA_ISR_TEIF2                       ((u32)0x00000080)        /* Channel 2 Transfer Error flag */
-#define  DMA_ISR_GIF3                        ((u32)0x00000100)        /* Channel 3 Global interrupt flag */
-#define  DMA_ISR_TCIF3                       ((u32)0x00000200)        /* Channel 3 Transfer Complete flag */
-#define  DMA_ISR_HTIF3                       ((u32)0x00000400)        /* Channel 3 Half Transfer flag */
-#define  DMA_ISR_TEIF3                       ((u32)0x00000800)        /* Channel 3 Transfer Error flag */
-#define  DMA_ISR_GIF4                        ((u32)0x00001000)        /* Channel 4 Global interrupt flag */
-#define  DMA_ISR_TCIF4                       ((u32)0x00002000)        /* Channel 4 Transfer Complete flag */
-#define  DMA_ISR_HTIF4                       ((u32)0x00004000)        /* Channel 4 Half Transfer flag */
-#define  DMA_ISR_TEIF4                       ((u32)0x00008000)        /* Channel 4 Transfer Error flag */
-#define  DMA_ISR_GIF5                        ((u32)0x00010000)        /* Channel 5 Global interrupt flag */
-#define  DMA_ISR_TCIF5                       ((u32)0x00020000)        /* Channel 5 Transfer Complete flag */
-#define  DMA_ISR_HTIF5                       ((u32)0x00040000)        /* Channel 5 Half Transfer flag */
-#define  DMA_ISR_TEIF5                       ((u32)0x00080000)        /* Channel 5 Transfer Error flag */
-#define  DMA_ISR_GIF6                        ((u32)0x00100000)        /* Channel 6 Global interrupt flag */
-#define  DMA_ISR_TCIF6                       ((u32)0x00200000)        /* Channel 6 Transfer Complete flag */
-#define  DMA_ISR_HTIF6                       ((u32)0x00400000)        /* Channel 6 Half Transfer flag */
-#define  DMA_ISR_TEIF6                       ((u32)0x00800000)        /* Channel 6 Transfer Error flag */
-#define  DMA_ISR_GIF7                        ((u32)0x01000000)        /* Channel 7 Global interrupt flag */
-#define  DMA_ISR_TCIF7                       ((u32)0x02000000)        /* Channel 7 Transfer Complete flag */
-#define  DMA_ISR_HTIF7                       ((u32)0x04000000)        /* Channel 7 Half Transfer flag */
-#define  DMA_ISR_TEIF7                       ((u32)0x08000000)        /* Channel 7 Transfer Error flag */
-
-
-/*******************  Bit definition for DMA_IFCR register  *******************/
-#define  DMA_IFCR_CGIF1                      ((u32)0x00000001)        /* Channel 1 Global interrupt clearr */
-#define  DMA_IFCR_CTCIF1                     ((u32)0x00000002)        /* Channel 1 Transfer Complete clear */
-#define  DMA_IFCR_CHTIF1                     ((u32)0x00000004)        /* Channel 1 Half Transfer clear */
-#define  DMA_IFCR_CTEIF1                     ((u32)0x00000008)        /* Channel 1 Transfer Error clear */
-#define  DMA_IFCR_CGIF2                      ((u32)0x00000010)        /* Channel 2 Global interrupt clear */
-#define  DMA_IFCR_CTCIF2                     ((u32)0x00000020)        /* Channel 2 Transfer Complete clear */
-#define  DMA_IFCR_CHTIF2                     ((u32)0x00000040)        /* Channel 2 Half Transfer clear */
-#define  DMA_IFCR_CTEIF2                     ((u32)0x00000080)        /* Channel 2 Transfer Error clear */
-#define  DMA_IFCR_CGIF3                      ((u32)0x00000100)        /* Channel 3 Global interrupt clear */
-#define  DMA_IFCR_CTCIF3                     ((u32)0x00000200)        /* Channel 3 Transfer Complete clear */
-#define  DMA_IFCR_CHTIF3                     ((u32)0x00000400)        /* Channel 3 Half Transfer clear */
-#define  DMA_IFCR_CTEIF3                     ((u32)0x00000800)        /* Channel 3 Transfer Error clear */
-#define  DMA_IFCR_CGIF4                      ((u32)0x00001000)        /* Channel 4 Global interrupt clear */
-#define  DMA_IFCR_CTCIF4                     ((u32)0x00002000)        /* Channel 4 Transfer Complete clear */
-#define  DMA_IFCR_CHTIF4                     ((u32)0x00004000)        /* Channel 4 Half Transfer clear */
-#define  DMA_IFCR_CTEIF4                     ((u32)0x00008000)        /* Channel 4 Transfer Error clear */
-#define  DMA_IFCR_CGIF5                      ((u32)0x00010000)        /* Channel 5 Global interrupt clear */
-#define  DMA_IFCR_CTCIF5                     ((u32)0x00020000)        /* Channel 5 Transfer Complete clear */
-#define  DMA_IFCR_CHTIF5                     ((u32)0x00040000)        /* Channel 5 Half Transfer clear */
-#define  DMA_IFCR_CTEIF5                     ((u32)0x00080000)        /* Channel 5 Transfer Error clear */
-#define  DMA_IFCR_CGIF6                      ((u32)0x00100000)        /* Channel 6 Global interrupt clear */
-#define  DMA_IFCR_CTCIF6                     ((u32)0x00200000)        /* Channel 6 Transfer Complete clear */
-#define  DMA_IFCR_CHTIF6                     ((u32)0x00400000)        /* Channel 6 Half Transfer clear */
-#define  DMA_IFCR_CTEIF6                     ((u32)0x00800000)        /* Channel 6 Transfer Error clear */
-#define  DMA_IFCR_CGIF7                      ((u32)0x01000000)        /* Channel 7 Global interrupt clear */
-#define  DMA_IFCR_CTCIF7                     ((u32)0x02000000)        /* Channel 7 Transfer Complete clear */
-#define  DMA_IFCR_CHTIF7                     ((u32)0x04000000)        /* Channel 7 Half Transfer clear */
-#define  DMA_IFCR_CTEIF7                     ((u32)0x08000000)        /* Channel 7 Transfer Error clear */
-
-
-/*******************  Bit definition for DMA_CCR1 register  *******************/
-#define  DMA_CCR1_EN                         ((u16)0x0001)            /* Channel enable*/
-#define  DMA_CCR1_TCIE                       ((u16)0x0002)            /* Transfer complete interrupt enable */
-#define  DMA_CCR1_HTIE                       ((u16)0x0004)            /* Half Transfer interrupt enable */
-#define  DMA_CCR1_TEIE                       ((u16)0x0008)            /* Transfer error interrupt enable */
-#define  DMA_CCR1_DIR                        ((u16)0x0010)            /* Data transfer direction */
-#define  DMA_CCR1_CIRC                       ((u16)0x0020)            /* Circular mode */
-#define  DMA_CCR1_PINC                       ((u16)0x0040)            /* Peripheral increment mode */
-#define  DMA_CCR1_MINC                       ((u16)0x0080)            /* Memory increment mode */
-
-#define  DMA_CCR1_PSIZE                      ((u16)0x0300)            /* PSIZE[1:0] bits (Peripheral size) */
-#define  DMA_CCR1_PSIZE_0                    ((u16)0x0100)            /* Bit 0 */
-#define  DMA_CCR1_PSIZE_1                    ((u16)0x0200)            /* Bit 1 */
-
-#define  DMA_CCR1_MSIZE                      ((u16)0x0C00)            /* MSIZE[1:0] bits (Memory size) */
-#define  DMA_CCR1_MSIZE_0                    ((u16)0x0400)            /* Bit 0 */
-#define  DMA_CCR1_MSIZE_1                    ((u16)0x0800)            /* Bit 1 */
-
-#define  DMA_CCR1_PL                         ((u16)0x3000)            /* PL[1:0] bits(Channel Priority level) */
-#define  DMA_CCR1_PL_0                       ((u16)0x1000)            /* Bit 0 */
-#define  DMA_CCR1_PL_1                       ((u16)0x2000)            /* Bit 1 */
-
-#define  DMA_CCR1_MEM2MEM                    ((u16)0x4000)            /* Memory to memory mode */
-
-
-/*******************  Bit definition for DMA_CCR2 register  *******************/
-#define  DMA_CCR2_EN                         ((u16)0x0001)            /* Channel enable */
-#define  DMA_CCR2_TCIE                       ((u16)0x0002)            /* ransfer complete interrupt enable */
-#define  DMA_CCR2_HTIE                       ((u16)0x0004)            /* Half Transfer interrupt enable */
-#define  DMA_CCR2_TEIE                       ((u16)0x0008)            /* Transfer error interrupt enable */
-#define  DMA_CCR2_DIR                        ((u16)0x0010)            /* Data transfer direction */
-#define  DMA_CCR2_CIRC                       ((u16)0x0020)            /* Circular mode */
-#define  DMA_CCR2_PINC                       ((u16)0x0040)            /* Peripheral increment mode */
-#define  DMA_CCR2_MINC                       ((u16)0x0080)            /* Memory increment mode */
-
-#define  DMA_CCR2_PSIZE                      ((u16)0x0300)            /* PSIZE[1:0] bits (Peripheral size) */
-#define  DMA_CCR2_PSIZE_0                    ((u16)0x0100)            /* Bit 0 */
-#define  DMA_CCR2_PSIZE_1                    ((u16)0x0200)            /* Bit 1 */
-
-#define  DMA_CCR2_MSIZE                      ((u16)0x0C00)            /* MSIZE[1:0] bits (Memory size) */
-#define  DMA_CCR2_MSIZE_0                    ((u16)0x0400)            /* Bit 0 */
-#define  DMA_CCR2_MSIZE_1                    ((u16)0x0800)            /* Bit 1 */
-
-#define  DMA_CCR2_PL                         ((u16)0x3000)            /* PL[1:0] bits (Channel Priority level) */
-#define  DMA_CCR2_PL_0                       ((u16)0x1000)            /* Bit 0 */
-#define  DMA_CCR2_PL_1                       ((u16)0x2000)            /* Bit 1 */
-
-#define  DMA_CCR2_MEM2MEM                    ((u16)0x4000)            /* Memory to memory mode */
-
-
-/*******************  Bit definition for DMA_CCR3 register  *******************/
-#define  DMA_CCR3_EN                         ((u16)0x0001)            /* Channel enable */
-#define  DMA_CCR3_TCIE                       ((u16)0x0002)            /* Transfer complete interrupt enable */
-#define  DMA_CCR3_HTIE                       ((u16)0x0004)            /* Half Transfer interrupt enable */
-#define  DMA_CCR3_TEIE                       ((u16)0x0008)            /* Transfer error interrupt enable */
-#define  DMA_CCR3_DIR                        ((u16)0x0010)            /* Data transfer direction */
-#define  DMA_CCR3_CIRC                       ((u16)0x0020)            /* Circular mode */
-#define  DMA_CCR3_PINC                       ((u16)0x0040)            /* Peripheral increment mode */
-#define  DMA_CCR3_MINC                       ((u16)0x0080)            /* Memory increment mode */
-
-#define  DMA_CCR3_PSIZE                      ((u16)0x0300)            /* PSIZE[1:0] bits (Peripheral size) */
-#define  DMA_CCR3_PSIZE_0                    ((u16)0x0100)            /* Bit 0 */
-#define  DMA_CCR3_PSIZE_1                    ((u16)0x0200)            /* Bit 1 */
-
-#define  DMA_CCR3_MSIZE                      ((u16)0x0C00)            /* MSIZE[1:0] bits (Memory size) */
-#define  DMA_CCR3_MSIZE_0                    ((u16)0x0400)            /* Bit 0 */
-#define  DMA_CCR3_MSIZE_1                    ((u16)0x0800)            /* Bit 1 */
-
-#define  DMA_CCR3_PL                         ((u16)0x3000)            /* PL[1:0] bits (Channel Priority level) */
-#define  DMA_CCR3_PL_0                       ((u16)0x1000)            /* Bit 0 */
-#define  DMA_CCR3_PL_1                       ((u16)0x2000)            /* Bit 1 */
-
-#define  DMA_CCR3_MEM2MEM                    ((u16)0x4000)            /* Memory to memory mode */
-
-
-/*******************  Bit definition for DMA_CCR4 register  *******************/
-#define  DMA_CCR4_EN                         ((u16)0x0001)            /* Channel enable */
-#define  DMA_CCR4_TCIE                       ((u16)0x0002)            /* Transfer complete interrupt enable */
-#define  DMA_CCR4_HTIE                       ((u16)0x0004)            /* Half Transfer interrupt enable */
-#define  DMA_CCR4_TEIE                       ((u16)0x0008)            /* Transfer error interrupt enable */
-#define  DMA_CCR4_DIR                        ((u16)0x0010)            /* Data transfer direction */
-#define  DMA_CCR4_CIRC                       ((u16)0x0020)            /* Circular mode */
-#define  DMA_CCR4_PINC                       ((u16)0x0040)            /* Peripheral increment mode */
-#define  DMA_CCR4_MINC                       ((u16)0x0080)            /* Memory increment mode */
-
-#define  DMA_CCR4_PSIZE                      ((u16)0x0300)            /* PSIZE[1:0] bits (Peripheral size) */
-#define  DMA_CCR4_PSIZE_0                    ((u16)0x0100)            /* Bit 0 */
-#define  DMA_CCR4_PSIZE_1                    ((u16)0x0200)            /* Bit 1 */
-
-#define  DMA_CCR4_MSIZE                      ((u16)0x0C00)            /* MSIZE[1:0] bits (Memory size) */
-#define  DMA_CCR4_MSIZE_0                    ((u16)0x0400)            /* Bit 0 */
-#define  DMA_CCR4_MSIZE_1                    ((u16)0x0800)            /* Bit 1 */
-
-#define  DMA_CCR4_PL                         ((u16)0x3000)            /* PL[1:0] bits (Channel Priority level) */
-#define  DMA_CCR4_PL_0                       ((u16)0x1000)            /* Bit 0 */
-#define  DMA_CCR4_PL_1                       ((u16)0x2000)            /* Bit 1 */
-
-#define  DMA_CCR4_MEM2MEM                    ((u16)0x4000)            /* Memory to memory mode */
-
-
-/******************  Bit definition for DMA_CCR5 register  *******************/
-#define  DMA_CCR5_EN                         ((u16)0x0001)            /* Channel enable */
-#define  DMA_CCR5_TCIE                       ((u16)0x0002)            /* Transfer complete interrupt enable */
-#define  DMA_CCR5_HTIE                       ((u16)0x0004)            /* Half Transfer interrupt enable */
-#define  DMA_CCR5_TEIE                       ((u16)0x0008)            /* Transfer error interrupt enable */
-#define  DMA_CCR5_DIR                        ((u16)0x0010)            /* Data transfer direction */
-#define  DMA_CCR5_CIRC                       ((u16)0x0020)            /* Circular mode */
-#define  DMA_CCR5_PINC                       ((u16)0x0040)            /* Peripheral increment mode */
-#define  DMA_CCR5_MINC                       ((u16)0x0080)            /* Memory increment mode */
-
-#define  DMA_CCR5_PSIZE                      ((u16)0x0300)            /* PSIZE[1:0] bits (Peripheral size) */
-#define  DMA_CCR5_PSIZE_0                    ((u16)0x0100)            /* Bit 0 */
-#define  DMA_CCR5_PSIZE_1                    ((u16)0x0200)            /* Bit 1 */
-
-#define  DMA_CCR5_MSIZE                      ((u16)0x0C00)            /* MSIZE[1:0] bits (Memory size) */
-#define  DMA_CCR5_MSIZE_0                    ((u16)0x0400)            /* Bit 0 */
-#define  DMA_CCR5_MSIZE_1                    ((u16)0x0800)            /* Bit 1 */
-
-#define  DMA_CCR5_PL                         ((u16)0x3000)            /* PL[1:0] bits (Channel Priority level) */
-#define  DMA_CCR5_PL_0                       ((u16)0x1000)            /* Bit 0 */
-#define  DMA_CCR5_PL_1                       ((u16)0x2000)            /* Bit 1 */
-
-#define  DMA_CCR5_MEM2MEM                    ((u16)0x4000)            /* Memory to memory mode enable */
-
-
-/*******************  Bit definition for DMA_CCR6 register  *******************/
-#define  DMA_CCR6_EN                         ((u16)0x0001)            /* Channel enable */
-#define  DMA_CCR6_TCIE                       ((u16)0x0002)            /* Transfer complete interrupt enable */
-#define  DMA_CCR6_HTIE                       ((u16)0x0004)            /* Half Transfer interrupt enable */
-#define  DMA_CCR6_TEIE                       ((u16)0x0008)            /* Transfer error interrupt enable */
-#define  DMA_CCR6_DIR                        ((u16)0x0010)            /* Data transfer direction */
-#define  DMA_CCR6_CIRC                       ((u16)0x0020)            /* Circular mode */
-#define  DMA_CCR6_PINC                       ((u16)0x0040)            /* Peripheral increment mode */
-#define  DMA_CCR6_MINC                       ((u16)0x0080)            /* Memory increment mode */
-
-#define  DMA_CCR6_PSIZE                      ((u16)0x0300)            /* PSIZE[1:0] bits (Peripheral size) */
-#define  DMA_CCR6_PSIZE_0                    ((u16)0x0100)            /* Bit 0 */
-#define  DMA_CCR6_PSIZE_1                    ((u16)0x0200)            /* Bit 1 */
-
-#define  DMA_CCR6_MSIZE                      ((u16)0x0C00)            /* MSIZE[1:0] bits (Memory size) */
-#define  DMA_CCR6_MSIZE_0                    ((u16)0x0400)            /* Bit 0 */
-#define  DMA_CCR6_MSIZE_1                    ((u16)0x0800)            /* Bit 1 */
-
-#define  DMA_CCR6_PL                         ((u16)0x3000)            /* PL[1:0] bits (Channel Priority level) */
-#define  DMA_CCR6_PL_0                       ((u16)0x1000)            /* Bit 0 */
-#define  DMA_CCR6_PL_1                       ((u16)0x2000)            /* Bit 1 */
-
-#define  DMA_CCR6_MEM2MEM                    ((u16)0x4000)            /* Memory to memory mode */
-
-
-/*******************  Bit definition for DMA_CCR7 register  *******************/
-#define  DMA_CCR7_EN                         ((u16)0x0001)            /* Channel enable */
-#define  DMA_CCR7_TCIE                       ((u16)0x0002)            /* Transfer complete interrupt enable */
-#define  DMA_CCR7_HTIE                       ((u16)0x0004)            /* Half Transfer interrupt enable */
-#define  DMA_CCR7_TEIE                       ((u16)0x0008)            /* Transfer error interrupt enable */
-#define  DMA_CCR7_DIR                        ((u16)0x0010)            /* Data transfer direction */
-#define  DMA_CCR7_CIRC                       ((u16)0x0020)            /* Circular mode */
-#define  DMA_CCR7_PINC                       ((u16)0x0040)            /* Peripheral increment mode */
-#define  DMA_CCR7_MINC                       ((u16)0x0080)            /* Memory increment mode */
-
-#define  DMA_CCR7_PSIZE            ,         ((u16)0x0300)            /* PSIZE[1:0] bits (Peripheral size) */
-#define  DMA_CCR7_PSIZE_0                    ((u16)0x0100)            /* Bit 0 */
-#define  DMA_CCR7_PSIZE_1                    ((u16)0x0200)            /* Bit 1 */
-
-#define  DMA_CCR7_MSIZE                      ((u16)0x0C00)            /* MSIZE[1:0] bits (Memory size) */
-#define  DMA_CCR7_MSIZE_0                    ((u16)0x0400)            /* Bit 0 */
-#define  DMA_CCR7_MSIZE_1                    ((u16)0x0800)            /* Bit 1 */
-
-#define  DMA_CCR7_PL                         ((u16)0x3000)            /* PL[1:0] bits (Channel Priority level) */
-#define  DMA_CCR7_PL_0                       ((u16)0x1000)            /* Bit 0 */
-#define  DMA_CCR7_PL_1                       ((u16)0x2000)            /* Bit 1 */
-
-#define  DMA_CCR7_MEM2MEM                    ((u16)0x4000)            /* Memory to memory mode enable */
-
-
-/******************  Bit definition for DMA_CNDTR1 register  ******************/
-#define  DMA_CNDTR1_NDT                      ((u16)0xFFFF)            /* Number of data to Transfer */
-
-
-/******************  Bit definition for DMA_CNDTR2 register  ******************/
-#define  DMA_CNDTR2_NDT                      ((u16)0xFFFF)            /* Number of data to Transfer */
-
-
-/******************  Bit definition for DMA_CNDTR3 register  ******************/
-#define  DMA_CNDTR3_NDT                      ((u16)0xFFFF)            /* Number of data to Transfer */
-
-
-/******************  Bit definition for DMA_CNDTR4 register  ******************/
-#define  DMA_CNDTR4_NDT                      ((u16)0xFFFF)            /* Number of data to Transfer */
-
-
-/******************  Bit definition for DMA_CNDTR5 register  ******************/
-#define  DMA_CNDTR5_NDT                      ((u16)0xFFFF)            /* Number of data to Transfer */
-
-
-/******************  Bit definition for DMA_CNDTR6 register  ******************/
-#define  DMA_CNDTR6_NDT                      ((u16)0xFFFF)            /* Number of data to Transfer */
-
-
-/******************  Bit definition for DMA_CNDTR7 register  ******************/
-#define  DMA_CNDTR7_NDT                      ((u16)0xFFFF)            /* Number of data to Transfer */
-
-
-/******************  Bit definition for DMA_CPAR1 register  *******************/
-#define  DMA_CPAR1_PA                        ((u32)0xFFFFFFFF)        /* Peripheral Address */
-
-
-/******************  Bit definition for DMA_CPAR2 register  *******************/
-#define  DMA_CPAR2_PA                        ((u32)0xFFFFFFFF)        /* Peripheral Address */
-
-
-/******************  Bit definition for DMA_CPAR3 register  *******************/
-#define  DMA_CPAR3_PA                        ((u32)0xFFFFFFFF)        /* Peripheral Address */
-
-
-/******************  Bit definition for DMA_CPAR4 register  *******************/
-#define  DMA_CPAR4_PA                        ((u32)0xFFFFFFFF)        /* Peripheral Address */
-
-
-/******************  Bit definition for DMA_CPAR5 register  *******************/
-#define  DMA_CPAR5_PA                        ((u32)0xFFFFFFFF)        /* Peripheral Address */
-
-
-/******************  Bit definition for DMA_CPAR6 register  *******************/
-#define  DMA_CPAR6_PA                        ((u32)0xFFFFFFFF)        /* Peripheral Address */
-
-
-/******************  Bit definition for DMA_CPAR7 register  *******************/
-#define  DMA_CPAR7_PA                        ((u32)0xFFFFFFFF)        /* Peripheral Address */
-
-
-/******************  Bit definition for DMA_CMAR1 register  *******************/
-#define  DMA_CMAR1_MA                        ((u32)0xFFFFFFFF)        /* Memory Address */
-
-
-/******************  Bit definition for DMA_CMAR2 register  *******************/
-#define  DMA_CMAR2_MA                        ((u32)0xFFFFFFFF)        /* Memory Address */
-
-
-/******************  Bit definition for DMA_CMAR3 register  *******************/
-#define  DMA_CMAR3_MA                        ((u32)0xFFFFFFFF)        /* Memory Address */
-
-
-/******************  Bit definition for DMA_CMAR4 register  *******************/
-#define  DMA_CMAR4_MA                        ((u32)0xFFFFFFFF)        /* Memory Address */
-
-
-/******************  Bit definition for DMA_CMAR5 register  *******************/
-#define  DMA_CMAR5_MA                        ((u32)0xFFFFFFFF)        /* Memory Address */
-
-
-/******************  Bit definition for DMA_CMAR6 register  *******************/
-#define  DMA_CMAR6_MA                        ((u32)0xFFFFFFFF)        /* Memory Address */
-
-
-/******************  Bit definition for DMA_CMAR7 register  *******************/
-#define  DMA_CMAR7_MA                        ((u32)0xFFFFFFFF)        /* Memory Address */
-
-
-
-/******************************************************************************/
-/*                                                                            */
-/*                        Analog to Digital Converter                         */
-/*                                                                            */
-/******************************************************************************/
-
-/********************  Bit definition for ADC_SR register  ********************/
-#define  ADC_SR_AWD                          ((u8)0x01)               /* Analog watchdog flag */
-#define  ADC_SR_EOC                          ((u8)0x02)               /* End of conversion */
-#define  ADC_SR_JEOC                         ((u8)0x04)               /* Injected channel end of conversion */
-#define  ADC_SR_JSTRT                        ((u8)0x08)               /* Injected channel Start flag */
-#define  ADC_SR_STRT                         ((u8)0x10)               /* Regular channel Start flag */
-
-
-/*******************  Bit definition for ADC_CR1 register  ********************/
-#define  ADC_CR1_AWDCH                       ((u32)0x0000001F)        /* AWDCH[4:0] bits (Analog watchdog channel select bits) */
-#define  ADC_CR1_AWDCH_0                     ((u32)0x00000001)        /* Bit 0 */
-#define  ADC_CR1_AWDCH_1                     ((u32)0x00000002)        /* Bit 1 */
-#define  ADC_CR1_AWDCH_2                     ((u32)0x00000004)        /* Bit 2 */
-#define  ADC_CR1_AWDCH_3                     ((u32)0x00000008)        /* Bit 3 */
-#define  ADC_CR1_AWDCH_4                     ((u32)0x00000010)        /* Bit 4 */
-
-#define  ADC_CR1_EOCIE                       ((u32)0x00000020)        /* Interrupt enable for EOC */
-#define  ADC_CR1_AWDIE                       ((u32)0x00000040)        /* AAnalog Watchdog interrupt enable */
-#define  ADC_CR1_JEOCIE                      ((u32)0x00000080)        /* Interrupt enable for injected channels */
-#define  ADC_CR1_SCAN                        ((u32)0x00000100)        /* Scan mode */
-#define  ADC_CR1_AWDSGL                      ((u32)0x00000200)        /* Enable the watchdog on a single channel in scan mode */
-#define  ADC_CR1_JAUTO                       ((u32)0x00000400)        /* Automatic injected group conversion */
-#define  ADC_CR1_DISCEN                      ((u32)0x00000800)        /* Discontinuous mode on regular channels */
-#define  ADC_CR1_JDISCEN                     ((u32)0x00001000)        /* Discontinuous mode on injected channels */
-
-#define  ADC_CR1_DISCNUM                     ((u32)0x0000E000)        /* DISCNUM[2:0] bits (Discontinuous mode channel count) */
-#define  ADC_CR1_DISCNUM_0                   ((u32)0x00002000)        /* Bit 0 */
-#define  ADC_CR1_DISCNUM_1                   ((u32)0x00004000)        /* Bit 1 */
-#define  ADC_CR1_DISCNUM_2                   ((u32)0x00008000)        /* Bit 2 */
-
-#define  ADC_CR1_DUALMOD                     ((u32)0x000F0000)        /* DUALMOD[3:0] bits (Dual mode selection) */
-#define  ADC_CR1_DUALMOD_0                   ((u32)0x00010000)        /* Bit 0 */
-#define  ADC_CR1_DUALMOD_1                   ((u32)0x00020000)        /* Bit 1 */
-#define  ADC_CR1_DUALMOD_2                   ((u32)0x00040000)        /* Bit 2 */
-#define  ADC_CR1_DUALMOD_3                   ((u32)0x00080000)        /* Bit 3 */
-
-#define  ADC_CR1_JAWDEN                      ((u32)0x00400000)        /* Analog watchdog enable on injected channels */
-#define  ADC_CR1_AWDEN                       ((u32)0x00800000)        /* Analog watchdog enable on regular channels */
-
-  
-/*******************  Bit definition for ADC_CR2 register  ********************/
-#define  ADC_CR2_ADON                        ((u32)0x00000001)        /* A/D Converter ON / OFF */
-#define  ADC_CR2_CONT                        ((u32)0x00000002)        /* Continuous Conversion */
-#define  ADC_CR2_CAL                         ((u32)0x00000004)        /* A/D Calibration */
-#define  ADC_CR2_RSTCAL                      ((u32)0x00000008)        /* Reset Calibration */
-#define  ADC_CR2_DMA                         ((u32)0x00000100)        /* Direct Memory access mode */
-#define  ADC_CR2_ALIGN                       ((u32)0x00000800)        /* Data Alignment */
-
-#define  ADC_CR2_JEXTSEL                     ((u32)0x00007000)        /* JEXTSEL[2:0] bits (External event select for injected group) */
-#define  ADC_CR2_JEXTSEL_0                   ((u32)0x00001000)        /* Bit 0 */
-#define  ADC_CR2_JEXTSEL_1                   ((u32)0x00002000)        /* Bit 1 */
-#define  ADC_CR2_JEXTSEL_2                   ((u32)0x00004000)        /* Bit 2 */
-
-#define  ADC_CR2_JEXTTRIG                    ((u32)0x00008000)        /* External Trigger Conversion mode for injected channels */
-
-#define  ADC_CR2_EXTSEL                      ((u32)0x000E0000)        /* EXTSEL[2:0] bits (External Event Select for regular group) */
-#define  ADC_CR2_EXTSEL_0                    ((u32)0x00020000)        /* Bit 0 */
-#define  ADC_CR2_EXTSEL_1                    ((u32)0x00040000)        /* Bit 1 */
-#define  ADC_CR2_EXTSEL_2                    ((u32)0x00080000)        /* Bit 2 */
-
-#define  ADC_CR2_EXTTRIG                     ((u32)0x00100000)        /* External Trigger Conversion mode for regular channels */
-#define  ADC_CR2_JSWSTART                    ((u32)0x00200000)        /* Start Conversion of injected channels */
-#define  ADC_CR2_SWSTART                     ((u32)0x00400000)        /* Start Conversion of regular channels */
-#define  ADC_CR2_TSVREFE                     ((u32)0x00800000)        /* Temperature Sensor and VREFINT Enable */
-
-
-/******************  Bit definition for ADC_SMPR1 register  *******************/
-#define  ADC_SMPR1_SMP10                     ((u32)0x00000007)        /* SMP10[2:0] bits (Channel 10 Sample time selection) */
-#define  ADC_SMPR1_SMP10_0                   ((u32)0x00000001)        /* Bit 0 */
-#define  ADC_SMPR1_SMP10_1                   ((u32)0x00000002)        /* Bit 1 */
-#define  ADC_SMPR1_SMP10_2                   ((u32)0x00000004)        /* Bit 2 */
-
-#define  ADC_SMPR1_SMP11                     ((u32)0x00000038)        /* SMP11[2:0] bits (Channel 11 Sample time selection) */
-#define  ADC_SMPR1_SMP11_0                   ((u32)0x00000008)        /* Bit 0 */
-#define  ADC_SMPR1_SMP11_1                   ((u32)0x00000010)        /* Bit 1 */
-#define  ADC_SMPR1_SMP11_2                   ((u32)0x00000020)        /* Bit 2 */
-
-#define  ADC_SMPR1_SMP12                     ((u32)0x000001C0)        /* SMP12[2:0] bits (Channel 12 Sample time selection) */
-#define  ADC_SMPR1_SMP12_0                   ((u32)0x00000040)        /* Bit 0 */
-#define  ADC_SMPR1_SMP12_1                   ((u32)0x00000080)        /* Bit 1 */
-#define  ADC_SMPR1_SMP12_2                   ((u32)0x00000100)        /* Bit 2 */
-
-#define  ADC_SMPR1_SMP13                     ((u32)0x00000E00)        /* SMP13[2:0] bits (Channel 13 Sample time selection) */
-#define  ADC_SMPR1_SMP13_0                   ((u32)0x00000200)        /* Bit 0 */
-#define  ADC_SMPR1_SMP13_1                   ((u32)0x00000400)        /* Bit 1 */
-#define  ADC_SMPR1_SMP13_2                   ((u32)0x00000800)        /* Bit 2 */
-
-#define  ADC_SMPR1_SMP14                     ((u32)0x00007000)        /* SMP14[2:0] bits (Channel 14 Sample time selection) */
-#define  ADC_SMPR1_SMP14_0                   ((u32)0x00001000)        /* Bit 0 */
-#define  ADC_SMPR1_SMP14_1                   ((u32)0x00002000)        /* Bit 1 */
-#define  ADC_SMPR1_SMP14_2                   ((u32)0x00004000)        /* Bit 2 */
-
-#define  ADC_SMPR1_SMP15                     ((u32)0x00038000)        /* SMP15[2:0] bits (Channel 15 Sample time selection) */
-#define  ADC_SMPR1_SMP15_0                   ((u32)0x00008000)        /* Bit 0 */
-#define  ADC_SMPR1_SMP15_1                   ((u32)0x00010000)        /* Bit 1 */
-#define  ADC_SMPR1_SMP15_2                   ((u32)0x00020000)        /* Bit 2 */
-
-#define  ADC_SMPR1_SMP16                     ((u32)0x001C0000)        /* SMP16[2:0] bits (Channel 16 Sample time selection) */
-#define  ADC_SMPR1_SMP16_0                   ((u32)0x00040000)        /* Bit 0 */
-#define  ADC_SMPR1_SMP16_1                   ((u32)0x00080000)        /* Bit 1 */
-#define  ADC_SMPR1_SMP16_2                   ((u32)0x00100000)        /* Bit 2 */
-
-#define  ADC_SMPR1_SMP17                     ((u32)0x00E00000)        /* SMP17[2:0] bits (Channel 17 Sample time selection) */
-#define  ADC_SMPR1_SMP17_0                   ((u32)0x00200000)        /* Bit 0 */
-#define  ADC_SMPR1_SMP17_1                   ((u32)0x00400000)        /* Bit 1 */
-#define  ADC_SMPR1_SMP17_2                   ((u32)0x00800000)        /* Bit 2 */
-
-
-/******************  Bit definition for ADC_SMPR2 register  *******************/
-#define  ADC_SMPR2_SMP0                      ((u32)0x00000007)        /* SMP0[2:0] bits (Channel 0 Sample time selection) */
-#define  ADC_SMPR2_SMP0_0                    ((u32)0x00000001)        /* Bit 0 */
-#define  ADC_SMPR2_SMP0_1                    ((u32)0x00000002)        /* Bit 1 */
-#define  ADC_SMPR2_SMP0_2                    ((u32)0x00000004)        /* Bit 2 */
-
-#define  ADC_SMPR2_SMP1                      ((u32)0x00000038)        /* SMP1[2:0] bits (Channel 1 Sample time selection) */
-#define  ADC_SMPR2_SMP1_0                    ((u32)0x00000008)        /* Bit 0 */
-#define  ADC_SMPR2_SMP1_1                    ((u32)0x00000010)        /* Bit 1 */
-#define  ADC_SMPR2_SMP1_2                    ((u32)0x00000020)        /* Bit 2 */
-
-#define  ADC_SMPR2_SMP2                      ((u32)0x000001C0)        /* SMP2[2:0] bits (Channel 2 Sample time selection) */
-#define  ADC_SMPR2_SMP2_0                    ((u32)0x00000040)        /* Bit 0 */
-#define  ADC_SMPR2_SMP2_1                    ((u32)0x00000080)        /* Bit 1 */
-#define  ADC_SMPR2_SMP2_2                    ((u32)0x00000100)        /* Bit 2 */
-
-#define  ADC_SMPR2_SMP3                      ((u32)0x00000E00)        /* SMP3[2:0] bits (Channel 3 Sample time selection) */
-#define  ADC_SMPR2_SMP3_0                    ((u32)0x00000200)        /* Bit 0 */
-#define  ADC_SMPR2_SMP3_1                    ((u32)0x00000400)        /* Bit 1 */
-#define  ADC_SMPR2_SMP3_2                    ((u32)0x00000800)        /* Bit 2 */
-
-#define  ADC_SMPR2_SMP4                      ((u32)0x00007000)        /* SMP4[2:0] bits (Channel 4 Sample time selection) */
-#define  ADC_SMPR2_SMP4_0                    ((u32)0x00001000)        /* Bit 0 */
-#define  ADC_SMPR2_SMP4_1                    ((u32)0x00002000)        /* Bit 1 */
-#define  ADC_SMPR2_SMP4_2                    ((u32)0x00004000)        /* Bit 2 */
-
-#define  ADC_SMPR2_SMP5                      ((u32)0x00038000)        /* SMP5[2:0] bits (Channel 5 Sample time selection) */
-#define  ADC_SMPR2_SMP5_0                    ((u32)0x00008000)        /* Bit 0 */
-#define  ADC_SMPR2_SMP5_1                    ((u32)0x00010000)        /* Bit 1 */
-#define  ADC_SMPR2_SMP5_2                    ((u32)0x00020000)        /* Bit 2 */
-
-#define  ADC_SMPR2_SMP6                      ((u32)0x001C0000)        /* SMP6[2:0] bits (Channel 6 Sample time selection) */
-#define  ADC_SMPR2_SMP6_0                    ((u32)0x00040000)        /* Bit 0 */
-#define  ADC_SMPR2_SMP6_1                    ((u32)0x00080000)        /* Bit 1 */
-#define  ADC_SMPR2_SMP6_2                    ((u32)0x00100000)        /* Bit 2 */
-
-#define  ADC_SMPR2_SMP7                      ((u32)0x00E00000)        /* SMP7[2:0] bits (Channel 7 Sample time selection) */
-#define  ADC_SMPR2_SMP7_0                    ((u32)0x00200000)        /* Bit 0 */
-#define  ADC_SMPR2_SMP7_1                    ((u32)0x00400000)        /* Bit 1 */
-#define  ADC_SMPR2_SMP7_2                    ((u32)0x00800000)        /* Bit 2 */
-
-#define  ADC_SMPR2_SMP8                      ((u32)0x07000000)        /* SMP8[2:0] bits (Channel 8 Sample time selection) */
-#define  ADC_SMPR2_SMP8_0                    ((u32)0x01000000)        /* Bit 0 */
-#define  ADC_SMPR2_SMP8_1                    ((u32)0x02000000)        /* Bit 1 */
-#define  ADC_SMPR2_SMP8_2                    ((u32)0x04000000)        /* Bit 2 */
-
-#define  ADC_SMPR2_SMP9                      ((u32)0x38000000)        /* SMP9[2:0] bits (Channel 9 Sample time selection) */
-#define  ADC_SMPR2_SMP9_0                    ((u32)0x08000000)        /* Bit 0 */
-#define  ADC_SMPR2_SMP9_1                    ((u32)0x10000000)        /* Bit 1 */
-#define  ADC_SMPR2_SMP9_2                    ((u32)0x20000000)        /* Bit 2 */
-
-
-/******************  Bit definition for ADC_JOFR1 register  *******************/
-#define  ADC_JOFR1_JOFFSET1                  ((u16)0x0FFF)            /* Data offset for injected channel 1 */
-
-
-/******************  Bit definition for ADC_JOFR2 register  *******************/
-#define  ADC_JOFR2_JOFFSET2                  ((u16)0x0FFF)            /* Data offset for injected channel 2 */
-
-
-/******************  Bit definition for ADC_JOFR3 register  *******************/
-#define  ADC_JOFR3_JOFFSET3                  ((u16)0x0FFF)            /* Data offset for injected channel 3 */
-
-
-/******************  Bit definition for ADC_JOFR4 register  *******************/
-#define  ADC_JOFR4_JOFFSET4                  ((u16)0x0FFF)            /* Data offset for injected channel 4 */
-
-
-/*******************  Bit definition for ADC_HTR register  ********************/
-#define  ADC_HTR_HT                          ((u16)0x0FFF)            /* Analog watchdog high threshold */
-
-
-/*******************  Bit definition for ADC_LTR register  ********************/
-#define  ADC_LTR_LT                          ((u16)0x0FFF)            /* Analog watchdog low threshold */
-
-
-/*******************  Bit definition for ADC_SQR1 register  *******************/
-#define  ADC_SQR1_SQ13                       ((u32)0x0000001F)        /* SQ13[4:0] bits (13th conversion in regular sequence) */
-#define  ADC_SQR1_SQ13_0                     ((u32)0x00000001)        /* Bit 0 */
-#define  ADC_SQR1_SQ13_1                     ((u32)0x00000002)        /* Bit 1 */
-#define  ADC_SQR1_SQ13_2                     ((u32)0x00000004)        /* Bit 2 */
-#define  ADC_SQR1_SQ13_3                     ((u32)0x00000008)        /* Bit 3 */
-#define  ADC_SQR1_SQ13_4                     ((u32)0x00000010)        /* Bit 4 */
-
-#define  ADC_SQR1_SQ14                       ((u32)0x000003E0)        /* SQ14[4:0] bits (14th conversion in regular sequence) */
-#define  ADC_SQR1_SQ14_0                     ((u32)0x00000020)        /* Bit 0 */
-#define  ADC_SQR1_SQ14_1                     ((u32)0x00000040)        /* Bit 1 */
-#define  ADC_SQR1_SQ14_2                     ((u32)0x00000080)        /* Bit 2 */
-#define  ADC_SQR1_SQ14_3                     ((u32)0x00000100)        /* Bit 3 */
-#define  ADC_SQR1_SQ14_4                     ((u32)0x00000200)        /* Bit 4 */
-
-#define  ADC_SQR1_SQ15                       ((u32)0x00007C00)        /* SQ15[4:0] bits (15th conversion in regular sequence) */
-#define  ADC_SQR1_SQ15_0                     ((u32)0x00000400)        /* Bit 0 */
-#define  ADC_SQR1_SQ15_1                     ((u32)0x00000800)        /* Bit 1 */
-#define  ADC_SQR1_SQ15_2                     ((u32)0x00001000)        /* Bit 2 */
-#define  ADC_SQR1_SQ15_3                     ((u32)0x00002000)        /* Bit 3 */
-#define  ADC_SQR1_SQ15_4                     ((u32)0x00004000)        /* Bit 4 */
-
-#define  ADC_SQR1_SQ16                       ((u32)0x000F8000)        /* SQ16[4:0] bits (16th conversion in regular sequence) */
-#define  ADC_SQR1_SQ16_0                     ((u32)0x00008000)        /* Bit 0 */
-#define  ADC_SQR1_SQ16_1                     ((u32)0x00010000)        /* Bit 1 */
-#define  ADC_SQR1_SQ16_2                     ((u32)0x00020000)        /* Bit 2 */
-#define  ADC_SQR1_SQ16_3                     ((u32)0x00040000)        /* Bit 3 */
-#define  ADC_SQR1_SQ16_4                     ((u32)0x00080000)        /* Bit 4 */
-
-#define  ADC_SQR1_L                          ((u32)0x00F00000)        /* L[3:0] bits (Regular channel sequence length) */
-#define  ADC_SQR1_L_0                        ((u32)0x00100000)        /* Bit 0 */
-#define  ADC_SQR1_L_1                        ((u32)0x00200000)        /* Bit 1 */
-#define  ADC_SQR1_L_2                        ((u32)0x00400000)        /* Bit 2 */
-#define  ADC_SQR1_L_3                        ((u32)0x00800000)        /* Bit 3 */
-
-
-/*******************  Bit definition for ADC_SQR2 register  *******************/
-#define  ADC_SQR2_SQ7                        ((u32)0x0000001F)        /* SQ7[4:0] bits (7th conversion in regular sequence) */
-#define  ADC_SQR2_SQ7_0                      ((u32)0x00000001)        /* Bit 0 */
-#define  ADC_SQR2_SQ7_1                      ((u32)0x00000002)        /* Bit 1 */
-#define  ADC_SQR2_SQ7_2                      ((u32)0x00000004)        /* Bit 2 */
-#define  ADC_SQR2_SQ7_3                      ((u32)0x00000008)        /* Bit 3 */
-#define  ADC_SQR2_SQ7_4                      ((u32)0x00000010)        /* Bit 4 */
-
-#define  ADC_SQR2_SQ8                        ((u32)0x000003E0)        /* SQ8[4:0] bits (8th conversion in regular sequence) */
-#define  ADC_SQR2_SQ8_0                      ((u32)0x00000020)        /* Bit 0 */
-#define  ADC_SQR2_SQ8_1                      ((u32)0x00000040)        /* Bit 1 */
-#define  ADC_SQR2_SQ8_2                      ((u32)0x00000080)        /* Bit 2 */
-#define  ADC_SQR2_SQ8_3                      ((u32)0x00000100)        /* Bit 3 */
-#define  ADC_SQR2_SQ8_4                      ((u32)0x00000200)        /* Bit 4 */
-
-#define  ADC_SQR2_SQ9                        ((u32)0x00007C00)        /* SQ9[4:0] bits (9th conversion in regular sequence) */
-#define  ADC_SQR2_SQ9_0                      ((u32)0x00000400)        /* Bit 0 */
-#define  ADC_SQR2_SQ9_1                      ((u32)0x00000800)        /* Bit 1 */
-#define  ADC_SQR2_SQ9_2                      ((u32)0x00001000)        /* Bit 2 */
-#define  ADC_SQR2_SQ9_3                      ((u32)0x00002000)        /* Bit 3 */
-#define  ADC_SQR2_SQ9_4                      ((u32)0x00004000)        /* Bit 4 */
-
-#define  ADC_SQR2_SQ10                       ((u32)0x000F8000)        /* SQ10[4:0] bits (10th conversion in regular sequence) */
-#define  ADC_SQR2_SQ10_0                     ((u32)0x00008000)        /* Bit 0 */
-#define  ADC_SQR2_SQ10_1                     ((u32)0x00010000)        /* Bit 1 */
-#define  ADC_SQR2_SQ10_2                     ((u32)0x00020000)        /* Bit 2 */
-#define  ADC_SQR2_SQ10_3                     ((u32)0x00040000)        /* Bit 3 */
-#define  ADC_SQR2_SQ10_4                     ((u32)0x00080000)        /* Bit 4 */
-
-#define  ADC_SQR2_SQ11                       ((u32)0x01F00000)        /* SQ11[4:0] bits (11th conversion in regular sequence) */
-#define  ADC_SQR2_SQ11_0                     ((u32)0x00100000)        /* Bit 0 */
-#define  ADC_SQR2_SQ11_1                     ((u32)0x00200000)        /* Bit 1 */
-#define  ADC_SQR2_SQ11_2                     ((u32)0x00400000)        /* Bit 2 */
-#define  ADC_SQR2_SQ11_3                     ((u32)0x00800000)        /* Bit 3 */
-#define  ADC_SQR2_SQ11_4                     ((u32)0x01000000)        /* Bit 4 */
-
-#define  ADC_SQR2_SQ12                       ((u32)0x3E000000)        /* SQ12[4:0] bits (12th conversion in regular sequence) */
-#define  ADC_SQR2_SQ12_0                     ((u32)0x02000000)        /* Bit 0 */
-#define  ADC_SQR2_SQ12_1                     ((u32)0x04000000)        /* Bit 1 */
-#define  ADC_SQR2_SQ12_2                     ((u32)0x08000000)        /* Bit 2 */
-#define  ADC_SQR2_SQ12_3                     ((u32)0x10000000)        /* Bit 3 */
-#define  ADC_SQR2_SQ12_4                     ((u32)0x20000000)        /* Bit 4 */
-
-
-/*******************  Bit definition for ADC_SQR3 register  *******************/
-#define  ADC_SQR3_SQ1                        ((u32)0x0000001F)        /* SQ1[4:0] bits (1st conversion in regular sequence) */
-#define  ADC_SQR3_SQ1_0                      ((u32)0x00000001)        /* Bit 0 */
-#define  ADC_SQR3_SQ1_1                      ((u32)0x00000002)        /* Bit 1 */
-#define  ADC_SQR3_SQ1_2                      ((u32)0x00000004)        /* Bit 2 */
-#define  ADC_SQR3_SQ1_3                      ((u32)0x00000008)        /* Bit 3 */
-#define  ADC_SQR3_SQ1_4                      ((u32)0x00000010)        /* Bit 4 */
-
-#define  ADC_SQR3_SQ2                        ((u32)0x000003E0)        /* SQ2[4:0] bits (2nd conversion in regular sequence) */
-#define  ADC_SQR3_SQ2_0                      ((u32)0x00000020)        /* Bit 0 */
-#define  ADC_SQR3_SQ2_1                      ((u32)0x00000040)        /* Bit 1 */
-#define  ADC_SQR3_SQ2_2                      ((u32)0x00000080)        /* Bit 2 */
-#define  ADC_SQR3_SQ2_3                      ((u32)0x00000100)        /* Bit 3 */
-#define  ADC_SQR3_SQ2_4                      ((u32)0x00000200)        /* Bit 4 */
-
-#define  ADC_SQR3_SQ3                        ((u32)0x00007C00)        /* SQ3[4:0] bits (3rd conversion in regular sequence) */
-#define  ADC_SQR3_SQ3_0                      ((u32)0x00000400)        /* Bit 0 */
-#define  ADC_SQR3_SQ3_1                      ((u32)0x00000800)        /* Bit 1 */
-#define  ADC_SQR3_SQ3_2                      ((u32)0x00001000)        /* Bit 2 */
-#define  ADC_SQR3_SQ3_3                      ((u32)0x00002000)        /* Bit 3 */
-#define  ADC_SQR3_SQ3_4                      ((u32)0x00004000)        /* Bit 4 */
-
-#define  ADC_SQR3_SQ4                        ((u32)0x000F8000)        /* SQ4[4:0] bits (4th conversion in regular sequence) */
-#define  ADC_SQR3_SQ4_0                      ((u32)0x00008000)        /* Bit 0 */
-#define  ADC_SQR3_SQ4_1                      ((u32)0x00010000)        /* Bit 1 */
-#define  ADC_SQR3_SQ4_2                      ((u32)0x00020000)        /* Bit 2 */
-#define  ADC_SQR3_SQ4_3                      ((u32)0x00040000)        /* Bit 3 */
-#define  ADC_SQR3_SQ4_4                      ((u32)0x00080000)        /* Bit 4 */
-
-#define  ADC_SQR3_SQ5                        ((u32)0x01F00000)        /* SQ5[4:0] bits (5th conversion in regular sequence) */
-#define  ADC_SQR3_SQ5_0                      ((u32)0x00100000)        /* Bit 0 */
-#define  ADC_SQR3_SQ5_1                      ((u32)0x00200000)        /* Bit 1 */
-#define  ADC_SQR3_SQ5_2                      ((u32)0x00400000)        /* Bit 2 */
-#define  ADC_SQR3_SQ5_3                      ((u32)0x00800000)        /* Bit 3 */
-#define  ADC_SQR3_SQ5_4                      ((u32)0x01000000)        /* Bit 4 */
-
-#define  ADC_SQR3_SQ6                        ((u32)0x3E000000)        /* SQ6[4:0] bits (6th conversion in regular sequence) */
-#define  ADC_SQR3_SQ6_0                      ((u32)0x02000000)        /* Bit 0 */
-#define  ADC_SQR3_SQ6_1                      ((u32)0x04000000)        /* Bit 1 */
-#define  ADC_SQR3_SQ6_2                      ((u32)0x08000000)        /* Bit 2 */
-#define  ADC_SQR3_SQ6_3                      ((u32)0x10000000)        /* Bit 3 */
-#define  ADC_SQR3_SQ6_4                      ((u32)0x20000000)        /* Bit 4 */
-
-
-/*******************  Bit definition for ADC_JSQR register  *******************/
-#define  ADC_JSQR_JSQ1                       ((u32)0x0000001F)        /* JSQ1[4:0] bits (1st conversion in injected sequence) */  
-#define  ADC_JSQR_JSQ1_0                     ((u32)0x00000001)        /* Bit 0 */
-#define  ADC_JSQR_JSQ1_1                     ((u32)0x00000002)        /* Bit 1 */
-#define  ADC_JSQR_JSQ1_2                     ((u32)0x00000004)        /* Bit 2 */
-#define  ADC_JSQR_JSQ1_3                     ((u32)0x00000008)        /* Bit 3 */
-#define  ADC_JSQR_JSQ1_4                     ((u32)0x00000010)        /* Bit 4 */
-
-#define  ADC_JSQR_JSQ2                       ((u32)0x000003E0)        /* JSQ2[4:0] bits (2nd conversion in injected sequence) */
-#define  ADC_JSQR_JSQ2_0                     ((u32)0x00000020)        /* Bit 0 */
-#define  ADC_JSQR_JSQ2_1                     ((u32)0x00000040)        /* Bit 1 */
-#define  ADC_JSQR_JSQ2_2                     ((u32)0x00000080)        /* Bit 2 */
-#define  ADC_JSQR_JSQ2_3                     ((u32)0x00000100)        /* Bit 3 */
-#define  ADC_JSQR_JSQ2_4                     ((u32)0x00000200)        /* Bit 4 */
-
-#define  ADC_JSQR_JSQ3                       ((u32)0x00007C00)        /* JSQ3[4:0] bits (3rd conversion in injected sequence) */
-#define  ADC_JSQR_JSQ3_0                     ((u32)0x00000400)        /* Bit 0 */
-#define  ADC_JSQR_JSQ3_1                     ((u32)0x00000800)        /* Bit 1 */
-#define  ADC_JSQR_JSQ3_2                     ((u32)0x00001000)        /* Bit 2 */
-#define  ADC_JSQR_JSQ3_3                     ((u32)0x00002000)        /* Bit 3 */
-#define  ADC_JSQR_JSQ3_4                     ((u32)0x00004000)        /* Bit 4 */
-
-#define  ADC_JSQR_JSQ4                       ((u32)0x000F8000)        /* JSQ4[4:0] bits (4th conversion in injected sequence) */
-#define  ADC_JSQR_JSQ4_0                     ((u32)0x00008000)        /* Bit 0 */
-#define  ADC_JSQR_JSQ4_1                     ((u32)0x00010000)        /* Bit 1 */
-#define  ADC_JSQR_JSQ4_2                     ((u32)0x00020000)        /* Bit 2 */
-#define  ADC_JSQR_JSQ4_3                     ((u32)0x00040000)        /* Bit 3 */
-#define  ADC_JSQR_JSQ4_4                     ((u32)0x00080000)        /* Bit 4 */
-
-#define  ADC_JSQR_JL                         ((u32)0x00300000)        /* JL[1:0] bits (Injected Sequence length) */
-#define  ADC_JSQR_JL_0                       ((u32)0x00100000)        /* Bit 0 */
-#define  ADC_JSQR_JL_1                       ((u32)0x00200000)        /* Bit 1 */
-
-
-/*******************  Bit definition for ADC_JDR1 register  *******************/
-#define  ADC_JDR1_JDATA                      ((u16)0xFFFF)            /* Injected data */
-
-
-/*******************  Bit definition for ADC_JDR2 register  *******************/
-#define  ADC_JDR2_JDATA                      ((u16)0xFFFF)            /* Injected data */
-
-
-/*******************  Bit definition for ADC_JDR3 register  *******************/
-#define  ADC_JDR3_JDATA                      ((u16)0xFFFF)            /* Injected data */
-
-
-/*******************  Bit definition for ADC_JDR4 register  *******************/
-#define  ADC_JDR4_JDATA                      ((u16)0xFFFF)            /* Injected data */
-
-
-/********************  Bit definition for ADC_DR register  ********************/
-#define  ADC_DR_DATA                         ((u32)0x0000FFFF)        /* Regular data */
-#define  ADC_DR_ADC2DATA                     ((u32)0xFFFF0000)        /* ADC2 data */
-
-
-
-/******************************************************************************/
-/*                                                                            */
-/*                      Digital to Analog Converter                           */
-/*                                                                            */
-/******************************************************************************/
-
-/********************  Bit definition for DAC_CR register  ********************/
-#define  DAC_CR_EN1                          ((u32)0x00000001)        /* DAC channel1 enable */
-#define  DAC_CR_BOFF1                        ((u32)0x00000002)        /* DAC channel1 output buffer disable */
-#define  DAC_CR_TEN1                         ((u32)0x00000004)        /* DAC channel1 Trigger enable */
-
-#define  DAC_CR_TSEL1                        ((u32)0x00000038)        /* TSEL1[2:0] (DAC channel1 Trigger selection) */
-#define  DAC_CR_TSEL1_0                      ((u32)0x00000008)        /* Bit 0 */
-#define  DAC_CR_TSEL1_1                      ((u32)0x00000010)        /* Bit 1 */
-#define  DAC_CR_TSEL1_2                      ((u32)0x00000020)        /* Bit 2 */
-
-#define  DAC_CR_WAVE1                        ((u32)0x000000C0)        /* WAVE1[1:0] (DAC channel1 noise/triangle wave generation enable) */
-#define  DAC_CR_WAVE1_0                      ((u32)0x00000040)        /* Bit 0 */
-#define  DAC_CR_WAVE1_1                      ((u32)0x00000080)        /* Bit 1 */
-
-#define  DAC_CR_MAMP1                        ((u32)0x00000F00)        /* MAMP1[3:0] (DAC channel1 Mask/Amplitude selector) */
-#define  DAC_CR_MAMP1_0                      ((u32)0x00000100)        /* Bit 0 */
-#define  DAC_CR_MAMP1_1                      ((u32)0x00000200)        /* Bit 1 */
-#define  DAC_CR_MAMP1_2                      ((u32)0x00000400)        /* Bit 2 */
-#define  DAC_CR_MAMP1_3                      ((u32)0x00000800)        /* Bit 3 */
-
-#define  DAC_CR_DMAEN1                       ((u32)0x00001000)        /* DAC channel1 DMA enable */
-#define  DAC_CR_EN2                          ((u32)0x00010000)        /* DAC channel2 enable */
-#define  DAC_CR_BOFF2                        ((u32)0x00020000)        /* DAC channel2 output buffer disable */
-#define  DAC_CR_TEN2                         ((u32)0x00040000)        /* DAC channel2 Trigger enable */
-
-#define  DAC_CR_TSEL2                        ((u32)0x00380000)        /* TSEL2[2:0] (DAC channel2 Trigger selection) */
-#define  DAC_CR_TSEL2_0                      ((u32)0x00080000)        /* Bit 0 */
-#define  DAC_CR_TSEL2_1                      ((u32)0x00100000)        /* Bit 1 */
-#define  DAC_CR_TSEL2_2                      ((u32)0x00200000)        /* Bit 2 */
-
-#define  DAC_CR_WAVE2                        ((u32)0x00C00000)        /* WAVE2[1:0] (DAC channel2 noise/triangle wave generation enable) */
-#define  DAC_CR_WAVE2_0                      ((u32)0x00400000)        /* Bit 0 */
-#define  DAC_CR_WAVE2_1                      ((u32)0x00800000)        /* Bit 1 */
-
-#define  DAC_CR_MAMP2                        ((u32)0x0F000000)        /* MAMP2[3:0] (DAC channel2 Mask/Amplitude selector) */
-#define  DAC_CR_MAMP2_0                      ((u32)0x01000000)        /* Bit 0 */
-#define  DAC_CR_MAMP2_1                      ((u32)0x02000000)        /* Bit 1 */
-#define  DAC_CR_MAMP2_2                      ((u32)0x04000000)        /* Bit 2 */
-#define  DAC_CR_MAMP2_3                      ((u32)0x08000000)        /* Bit 3 */
-
-#define  DAC_CR_DMAEN2                       ((u32)0x10000000)        /* DAC channel2 DMA enabled */
-
-
-/*****************  Bit definition for DAC_SWTRIGR register  ******************/
-#define  DAC_SWTRIGR_SWTRIG1                 ((u8)0x01)               /* DAC channel1 software trigger */
-#define  DAC_SWTRIGR_SWTRIG2                 ((u8)0x02)               /* DAC channel2 software trigger */
-
-
-/*****************  Bit definition for DAC_DHR12R1 register  ******************/
-#define  DAC_DHR12R1_DACC1DHR                ((u16)0x0FFF)            /* DAC channel1 12-bit Right aligned data */
-
-
-/*****************  Bit definition for DAC_DHR12L1 register  ******************/
-#define  DAC_DHR12L1_DACC1DHR                ((u16)0xFFF0)            /* DAC channel1 12-bit Left aligned data */
-
-
-/******************  Bit definition for DAC_DHR8R1 register  ******************/
-#define  DAC_DHR8R1_DACC1DHR                 ((u8)0xFF)               /* DAC channel1 8-bit Right aligned data */
-
-
-/*****************  Bit definition for DAC_DHR12R2 register  ******************/
-#define  DAC_DHR12R2_DACC2DHR                ((u16)0x0FFF)            /* DAC channel2 12-bit Right aligned data */
-
-
-/*****************  Bit definition for DAC_DHR12L2 register  ******************/
-#define  DAC_DHR12L2_DACC2DHR                ((u16)0xFFF0)            /* DAC channel2 12-bit Left aligned data */
-
-
-/******************  Bit definition for DAC_DHR8R2 register  ******************/
-#define  DAC_DHR8R2_DACC2DHR                 ((u8)0xFF)               /* DAC channel2 8-bit Right aligned data */
-
-
-/*****************  Bit definition for DAC_DHR12RD register  ******************/
-#define  DAC_DHR12RD_DACC1DHR                ((u32)0x00000FFF)        /* DAC channel1 12-bit Right aligned data */
-#define  DAC_DHR12RD_DACC2DHR                ((u32)0x0FFF0000)        /* DAC channel2 12-bit Right aligned data */
-
-
-/*****************  Bit definition for DAC_DHR12LD register  ******************/
-#define  DAC_DHR12LD_DACC1DHR                ((u32)0x0000FFF0)        /* DAC channel1 12-bit Left aligned data */
-#define  DAC_DHR12LD_DACC2DHR                ((u32)0xFFF00000)        /* DAC channel2 12-bit Left aligned data */
-
-
-/******************  Bit definition for DAC_DHR8RD register  ******************/
-#define  DAC_DHR8RD_DACC1DHR                 ((u16)0x00FF)            /* DAC channel1 8-bit Right aligned data */
-#define  DAC_DHR8RD_DACC2DHR                 ((u16)0xFF00)            /* DAC channel2 8-bit Right aligned data */
-
-
-/*******************  Bit definition for DAC_DOR1 register  *******************/
-#define  DAC_DOR1_DACC1DOR                   ((u16)0x0FFF)            /* DAC channel1 data output */
-
-
-/*******************  Bit definition for DAC_DOR2 register  *******************/
-#define  DAC_DOR2_DACC2DOR                   ((u16)0x0FFF)            /* DAC channel2 data output */
-
-
-
-/******************************************************************************/
-/*                                                                            */
-/*                                    TIM                                     */
-/*                                                                            */
-/******************************************************************************/
-
-/*******************  Bit definition for TIM_CR1 register  ********************/
-#define  TIM_CR1_CEN                         ((u16)0x0001)            /* Counter enable */
-#define  TIM_CR1_UDIS                        ((u16)0x0002)            /* Update disable */
-#define  TIM_CR1_URS                         ((u16)0x0004)            /* Update request source */
-#define  TIM_CR1_OPM                         ((u16)0x0008)            /* One pulse mode */
-#define  TIM_CR1_DIR                         ((u16)0x0010)            /* Direction */
-
-#define  TIM_CR1_CMS                         ((u16)0x0060)            /* CMS[1:0] bits (Center-aligned mode selection) */
-#define  TIM_CR1_CMS_0                       ((u16)0x0020)            /* Bit 0 */
-#define  TIM_CR1_CMS_1                       ((u16)0x0040)            /* Bit 1 */
-
-#define  TIM_CR1_ARPE                        ((u16)0x0080)            /* Auto-reload preload enable */
-
-#define  TIM_CR1_CKD                         ((u16)0x0300)            /* CKD[1:0] bits (clock division) */
-#define  TIM_CR1_CKD_0                       ((u16)0x0100)            /* Bit 0 */
-#define  TIM_CR1_CKD_1                       ((u16)0x0200)            /* Bit 1 */
-
-
-/*******************  Bit definition for TIM_CR2 register  ********************/
-#define  TIM_CR2_CCPC                        ((u16)0x0001)            /* Capture/Compare Preloaded Control */
-#define  TIM_CR2_CCUS                        ((u16)0x0004)            /* Capture/Compare Control Update Selection */
-#define  TIM_CR2_CCDS                        ((u16)0x0008)            /* Capture/Compare DMA Selection */
-
-#define  TIM_CR2_MMS                         ((u16)0x0070)            /* MMS[2:0] bits (Master Mode Selection) */
-#define  TIM_CR2_MMS_0                       ((u16)0x0010)            /* Bit 0 */
-#define  TIM_CR2_MMS_1                       ((u16)0x0020)            /* Bit 1 */
-#define  TIM_CR2_MMS_2                       ((u16)0x0040)            /* Bit 2 */
-
-#define  TIM_CR2_TI1S                        ((u16)0x0080)            /* TI1 Selection */
-#define  TIM_CR2_OIS1                        ((u16)0x0100)            /* Output Idle state 1 (OC1 output) */
-#define  TIM_CR2_OIS1N                       ((u16)0x0200)            /* Output Idle state 1 (OC1N output) */
-#define  TIM_CR2_OIS2                        ((u16)0x0400)            /* Output Idle state 2 (OC2 output) */
-#define  TIM_CR2_OIS2N                       ((u16)0x0800)            /* Output Idle state 2 (OC2N output) */
-#define  TIM_CR2_OIS3                        ((u16)0x1000)            /* Output Idle state 3 (OC3 output) */
-#define  TIM_CR2_OIS3N                       ((u16)0x2000)            /* Output Idle state 3 (OC3N output) */
-#define  TIM_CR2_OIS4                        ((u16)0x4000)            /* Output Idle state 4 (OC4 output) */
-
-
-/*******************  Bit definition for TIM_SMCR register  *******************/
-#define  TIM_SMCR_SMS                        ((u16)0x0007)            /* SMS[2:0] bits (Slave mode selection) */
-#define  TIM_SMCR_SMS_0                      ((u16)0x0001)            /* Bit 0 */
-#define  TIM_SMCR_SMS_1                      ((u16)0x0002)            /* Bit 1 */
-#define  TIM_SMCR_SMS_2                      ((u16)0x0004)            /* Bit 2 */
-
-#define  TIM_SMCR_TS                         ((u16)0x0070)            /* TS[2:0] bits (Trigger selection) */
-#define  TIM_SMCR_TS_0                       ((u16)0x0010)            /* Bit 0 */
-#define  TIM_SMCR_TS_1                       ((u16)0x0020)            /* Bit 1 */
-#define  TIM_SMCR_TS_2                       ((u16)0x0040)            /* Bit 2 */
-
-#define  TIM_SMCR_MSM                        ((u16)0x0080)            /* Master/slave mode */
-
-#define  TIM_SMCR_ETF                        ((u16)0x0F00)            /* ETF[3:0] bits (External trigger filter) */
-#define  TIM_SMCR_ETF_0                      ((u16)0x0100)            /* Bit 0 */
-#define  TIM_SMCR_ETF_1                      ((u16)0x0200)            /* Bit 1 */
-#define  TIM_SMCR_ETF_2                      ((u16)0x0400)            /* Bit 2 */
-#define  TIM_SMCR_ETF_3                      ((u16)0x0800)            /* Bit 3 */
-
-#define  TIM_SMCR_ETPS                       ((u16)0x3000)            /* ETPS[1:0] bits (External trigger prescaler) */
-#define  TIM_SMCR_ETPS_0                     ((u16)0x1000)            /* Bit 0 */
-#define  TIM_SMCR_ETPS_1                     ((u16)0x2000)            /* Bit 1 */
-
-#define  TIM_SMCR_ECE                        ((u16)0x4000)            /* External clock enable */
-#define  TIM_SMCR_ETP                        ((u16)0x8000)            /* External trigger polarity */
-
-
-/*******************  Bit definition for TIM_DIER register  *******************/
-#define  TIM_DIER_UIE                        ((u16)0x0001)            /* Update interrupt enable */
-#define  TIM_DIER_CC1IE                      ((u16)0x0002)            /* Capture/Compare 1 interrupt enable */
-#define  TIM_DIER_CC2IE                      ((u16)0x0004)            /* Capture/Compare 2 interrupt enable */
-#define  TIM_DIER_CC3IE                      ((u16)0x0008)            /* Capture/Compare 3 interrupt enable */
-#define  TIM_DIER_CC4IE                      ((u16)0x0010)            /* Capture/Compare 4 interrupt enable */
-#define  TIM_DIER_COMIE                      ((u16)0x0020)            /* COM interrupt enable */
-#define  TIM_DIER_TIE                        ((u16)0x0040)            /* Trigger interrupt enable */
-#define  TIM_DIER_BIE                        ((u16)0x0080)            /* Break interrupt enable */
-#define  TIM_DIER_UDE                        ((u16)0x0100)            /* Update DMA request enable */
-#define  TIM_DIER_CC1DE                      ((u16)0x0200)            /* Capture/Compare 1 DMA request enable */
-#define  TIM_DIER_CC2DE                      ((u16)0x0400)            /* Capture/Compare 2 DMA request enable */
-#define  TIM_DIER_CC3DE                      ((u16)0x0800)            /* Capture/Compare 3 DMA request enable */
-#define  TIM_DIER_CC4DE                      ((u16)0x1000)            /* Capture/Compare 4 DMA request enable */
-#define  TIM_DIER_COMDE                      ((u16)0x2000)            /* COM DMA request enable */
-#define  TIM_DIER_TDE                        ((u16)0x4000)            /* Trigger DMA request enable */
-
-
-/********************  Bit definition for TIM_SR register  ********************/
-#define  TIM_SR_UIF                          ((u16)0x0001)            /* Update interrupt Flag */
-#define  TIM_SR_CC1IF                        ((u16)0x0002)            /* Capture/Compare 1 interrupt Flag */
-#define  TIM_SR_CC2IF                        ((u16)0x0004)            /* Capture/Compare 2 interrupt Flag */
-#define  TIM_SR_CC3IF                        ((u16)0x0008)            /* Capture/Compare 3 interrupt Flag */
-#define  TIM_SR_CC4IF                        ((u16)0x0010)            /* Capture/Compare 4 interrupt Flag */
-#define  TIM_SR_COMIF                        ((u16)0x0020)            /* COM interrupt Flag */
-#define  TIM_SR_TIF                          ((u16)0x0040)            /* Trigger interrupt Flag */
-#define  TIM_SR_BIF                          ((u16)0x0080)            /* Break interrupt Flag */
-#define  TIM_SR_CC1OF                        ((u16)0x0200)            /* Capture/Compare 1 Overcapture Flag */
-#define  TIM_SR_CC2OF                        ((u16)0x0400)            /* Capture/Compare 2 Overcapture Flag */
-#define  TIM_SR_CC3OF                        ((u16)0x0800)            /* Capture/Compare 3 Overcapture Flag */
-#define  TIM_SR_CC4OF                        ((u16)0x1000)            /* Capture/Compare 4 Overcapture Flag */
-
-
-/*******************  Bit definition for TIM_EGR register  ********************/
-#define  TIM_EGR_UG                          ((u8)0x01)               /* Update Generation */
-#define  TIM_EGR_CC1G                        ((u8)0x02)               /* Capture/Compare 1 Generation */
-#define  TIM_EGR_CC2G                        ((u8)0x04)               /* Capture/Compare 2 Generation */
-#define  TIM_EGR_CC3G                        ((u8)0x08)               /* Capture/Compare 3 Generation */
-#define  TIM_EGR_CC4G                        ((u8)0x10)               /* Capture/Compare 4 Generation */
-#define  TIM_EGR_COMG                        ((u8)0x20)               /* Capture/Compare Control Update Generation */
-#define  TIM_EGR_TG                          ((u8)0x40)               /* Trigger Generation */
-#define  TIM_EGR_BG                          ((u8)0x80)               /* Break Generation */
-
-
-/******************  Bit definition for TIM_CCMR1 register  *******************/
-#define  TIM_CCMR1_CC1S                      ((u16)0x0003)            /* CC1S[1:0] bits (Capture/Compare 1 Selection) */
-#define  TIM_CCMR1_CC1S_0                    ((u16)0x0001)            /* Bit 0 */
-#define  TIM_CCMR1_CC1S_1                    ((u16)0x0002)            /* Bit 1 */
-
-#define  TIM_CCMR1_OC1FE                     ((u16)0x0004)            /* Output Compare 1 Fast enable */
-#define  TIM_CCMR1_OC1PE                     ((u16)0x0008)            /* Output Compare 1 Preload enable */
-
-#define  TIM_CCMR1_OC1M                      ((u16)0x0070)            /* OC1M[2:0] bits (Output Compare 1 Mode) */
-#define  TIM_CCMR1_OC1M_0                    ((u16)0x0010)            /* Bit 0 */
-#define  TIM_CCMR1_OC1M_1                    ((u16)0x0020)            /* Bit 1 */
-#define  TIM_CCMR1_OC1M_2                    ((u16)0x0040)            /* Bit 2 */
-
-#define  TIM_CCMR1_OC1CE                     ((u16)0x0080)            /* Output Compare 1Clear Enable */
-
-#define  TIM_CCMR1_CC2S                      ((u16)0x0300)            /* CC2S[1:0] bits (Capture/Compare 2 Selection) */
-#define  TIM_CCMR1_CC2S_0                    ((u16)0x0100)            /* Bit 0 */
-#define  TIM_CCMR1_CC2S_1                    ((u16)0x0200)            /* Bit 1 */
-
-#define  TIM_CCMR1_OC2FE                     ((u16)0x0400)            /* Output Compare 2 Fast enable */
-#define  TIM_CCMR1_OC2PE                     ((u16)0x0800)            /* Output Compare 2 Preload enable */
-
-#define  TIM_CCMR1_OC2M                      ((u16)0x7000)            /* OC2M[2:0] bits (Output Compare 2 Mode) */
-#define  TIM_CCMR1_OC2M_0                    ((u16)0x1000)            /* Bit 0 */
-#define  TIM_CCMR1_OC2M_1                    ((u16)0x2000)            /* Bit 1 */
-#define  TIM_CCMR1_OC2M_2                    ((u16)0x4000)            /* Bit 2 */
-
-#define  TIM_CCMR1_OC2CE                     ((u16)0x8000)            /* Output Compare 2 Clear Enable */
-
-/*----------------------------------------------------------------------------*/
-
-#define  TIM_CCMR1_IC1PSC                    ((u16)0x000C)            /* IC1PSC[1:0] bits (Input Capture 1 Prescaler) */
-#define  TIM_CCMR1_IC1PSC_0                  ((u16)0x0004)            /* Bit 0 */
-#define  TIM_CCMR1_IC1PSC_1                  ((u16)0x0008)            /* Bit 1 */
-
-#define  TIM_CCMR1_IC1F                      ((u16)0x00F0)            /* IC1F[3:0] bits (Input Capture 1 Filter) */
-#define  TIM_CCMR1_IC1F_0                    ((u16)0x0010)            /* Bit 0 */
-#define  TIM_CCMR1_IC1F_1                    ((u16)0x0020)            /* Bit 1 */
-#define  TIM_CCMR1_IC1F_2                    ((u16)0x0040)            /* Bit 2 */
-#define  TIM_CCMR1_IC1F_3                    ((u16)0x0080)            /* Bit 3 */
-
-#define  TIM_CCMR1_IC2PSC                    ((u16)0x0C00)            /* IC2PSC[1:0] bits (Input Capture 2 Prescaler) */
-#define  TIM_CCMR1_IC2PSC_0                  ((u16)0x0400)            /* Bit 0 */
-#define  TIM_CCMR1_IC2PSC_1                  ((u16)0x0800)            /* Bit 1 */
-
-#define  TIM_CCMR1_IC2F                      ((u16)0xF000)            /* IC2F[3:0] bits (Input Capture 2 Filter) */
-#define  TIM_CCMR1_IC2F_0                    ((u16)0x1000)            /* Bit 0 */
-#define  TIM_CCMR1_IC2F_1                    ((u16)0x2000)            /* Bit 1 */
-#define  TIM_CCMR1_IC2F_2                    ((u16)0x4000)            /* Bit 2 */
-#define  TIM_CCMR1_IC2F_3                    ((u16)0x8000)            /* Bit 3 */
-
-
-/******************  Bit definition for TIM_CCMR2 register  *******************/
-#define  TIM_CCMR2_CC3S                      ((u16)0x0003)            /* CC3S[1:0] bits (Capture/Compare 3 Selection) */
-#define  TIM_CCMR2_CC3S_0                    ((u16)0x0001)            /* Bit 0 */
-#define  TIM_CCMR2_CC3S_1                    ((u16)0x0002)            /* Bit 1 */
-
-#define  TIM_CCMR2_OC3FE                     ((u16)0x0004)            /* Output Compare 3 Fast enable */
-#define  TIM_CCMR2_OC3PE                     ((u16)0x0008)            /* Output Compare 3 Preload enable */
-
-#define  TIM_CCMR2_OC3M                      ((u16)0x0070)            /* OC3M[2:0] bits (Output Compare 3 Mode) */
-#define  TIM_CCMR2_OC3M_0                    ((u16)0x0010)            /* Bit 0 */
-#define  TIM_CCMR2_OC3M_1                    ((u16)0x0020)            /* Bit 1 */
-#define  TIM_CCMR2_OC3M_2                    ((u16)0x0040)            /* Bit 2 */
-
-#define  TIM_CCMR2_OC3CE                     ((u16)0x0080)            /* Output Compare 3 Clear Enable */
-
-#define  TIM_CCMR2_CC4S                      ((u16)0x0300)            /* CC4S[1:0] bits (Capture/Compare 4 Selection) */
-#define  TIM_CCMR2_CC4S_0                    ((u16)0x0100)            /* Bit 0 */
-#define  TIM_CCMR2_CC4S_1                    ((u16)0x0200)            /* Bit 1 */
-
-#define  TIM_CCMR2_OC4FE                     ((u16)0x0400)            /* Output Compare 4 Fast enable */
-#define  TIM_CCMR2_OC4PE                     ((u16)0x0800)            /* Output Compare 4 Preload enable */
-
-#define  TIM_CCMR2_OC4M                      ((u16)0x7000)            /* OC4M[2:0] bits (Output Compare 4 Mode) */
-#define  TIM_CCMR2_OC4M_0                    ((u16)0x1000)            /* Bit 0 */
-#define  TIM_CCMR2_OC4M_1                    ((u16)0x2000)            /* Bit 1 */
-#define  TIM_CCMR2_OC4M_2                    ((u16)0x4000)            /* Bit 2 */
-
-#define  TIM_CCMR2_OC4CE                     ((u16)0x8000)            /* Output Compare 4 Clear Enable */
-
-/*----------------------------------------------------------------------------*/
-
-#define  TIM_CCMR2_IC3PSC                    ((u16)0x000C)            /* IC3PSC[1:0] bits (Input Capture 3 Prescaler) */
-#define  TIM_CCMR2_IC3PSC_0                  ((u16)0x0004)            /* Bit 0 */
-#define  TIM_CCMR2_IC3PSC_1                  ((u16)0x0008)            /* Bit 1 */
-
-#define  TIM_CCMR2_IC3F                      ((u16)0x00F0)            /* IC3F[3:0] bits (Input Capture 3 Filter) */
-#define  TIM_CCMR2_IC3F_0                    ((u16)0x0010)            /* Bit 0 */
-#define  TIM_CCMR2_IC3F_1                    ((u16)0x0020)            /* Bit 1 */
-#define  TIM_CCMR2_IC3F_2                    ((u16)0x0040)            /* Bit 2 */
-#define  TIM_CCMR2_IC3F_3                    ((u16)0x0080)            /* Bit 3 */
-
-#define  TIM_CCMR2_IC4PSC                    ((u16)0x0C00)            /* IC4PSC[1:0] bits (Input Capture 4 Prescaler) */
-#define  TIM_CCMR2_IC4PSC_0                  ((u16)0x0400)            /* Bit 0 */
-#define  TIM_CCMR2_IC4PSC_1                  ((u16)0x0800)            /* Bit 1 */
-
-#define  TIM_CCMR2_IC4F                      ((u16)0xF000)            /* IC4F[3:0] bits (Input Capture 4 Filter) */
-#define  TIM_CCMR2_IC4F_0                    ((u16)0x1000)            /* Bit 0 */
-#define  TIM_CCMR2_IC4F_1                    ((u16)0x2000)            /* Bit 1 */
-#define  TIM_CCMR2_IC4F_2                    ((u16)0x4000)            /* Bit 2 */
-#define  TIM_CCMR2_IC4F_3                    ((u16)0x8000)            /* Bit 3 */
-
-
-/*******************  Bit definition for TIM_CCER register  *******************/
-#define  TIM_CCER_CC1E                       ((u16)0x0001)            /* Capture/Compare 1 output enable */
-#define  TIM_CCER_CC1P                       ((u16)0x0002)            /* Capture/Compare 1 output Polarity */
-#define  TIM_CCER_CC1NE                      ((u16)0x0004)            /* Capture/Compare 1 Complementary output enable */
-#define  TIM_CCER_CC1NP                      ((u16)0x0008)            /* Capture/Compare 1 Complementary output Polarity */
-#define  TIM_CCER_CC2E                       ((u16)0x0010)            /* Capture/Compare 2 output enable */
-#define  TIM_CCER_CC2P                       ((u16)0x0020)            /* Capture/Compare 2 output Polarity */
-#define  TIM_CCER_CC2NE                      ((u16)0x0040)            /* Capture/Compare 2 Complementary output enable */
-#define  TIM_CCER_CC2NP                      ((u16)0x0080)            /* Capture/Compare 2 Complementary output Polarity */
-#define  TIM_CCER_CC3E                       ((u16)0x0100)            /* Capture/Compare 3 output enable */
-#define  TIM_CCER_CC3P                       ((u16)0x0200)            /* Capture/Compare 3 output Polarity */
-#define  TIM_CCER_CC3NE                      ((u16)0x0400)            /* Capture/Compare 3 Complementary output enable */
-#define  TIM_CCER_CC3NP                      ((u16)0x0800)            /* Capture/Compare 3 Complementary output Polarity */
-#define  TIM_CCER_CC4E                       ((u16)0x1000)            /* Capture/Compare 4 output enable */
-#define  TIM_CCER_CC4P                       ((u16)0x2000)            /* Capture/Compare 4 output Polarity */
-
-
-/*******************  Bit definition for TIM_CNT register  ********************/
-#define  TIM_CNT_CNT                         ((u16)0xFFFF)            /* Counter Value */
-
-
-/*******************  Bit definition for TIM_PSC register  ********************/
-#define  TIM_PSC_PSC                         ((u16)0xFFFF)            /* Prescaler Value */
-
-
-/*******************  Bit definition for TIM_ARR register  ********************/
-#define  TIM_ARR_ARR                         ((u16)0xFFFF)            /* actual auto-reload Value */
-
-
-/*******************  Bit definition for TIM_RCR register  ********************/
-#define  TIM_RCR_REP                         ((u8)0xFF)               /* Repetition Counter Value */
-
-
-/*******************  Bit definition for TIM_CCR1 register  *******************/
-#define  TIM_CCR1_CCR1                       ((u16)0xFFFF)            /* Capture/Compare 1 Value */
-
-
-/*******************  Bit definition for TIM_CCR2 register  *******************/
-#define  TIM_CCR2_CCR2                       ((u16)0xFFFF)            /* Capture/Compare 2 Value */
-
-
-/*******************  Bit definition for TIM_CCR3 register  *******************/
-#define  TIM_CCR3_CCR3                       ((u16)0xFFFF)            /* Capture/Compare 3 Value */
-
-
-/*******************  Bit definition for TIM_CCR4 register  *******************/
-#define  TIM_CCR4_CCR4                       ((u16)0xFFFF)            /* Capture/Compare 4 Value */
-
-
-/*******************  Bit definition for TIM_BDTR register  *******************/
-#define  TIM_BDTR_DTG                        ((u16)0x00FF)            /* DTG[0:7] bits (Dead-Time Generator set-up) */
-#define  TIM_BDTR_DTG_0                      ((u16)0x0001)            /* Bit 0 */
-#define  TIM_BDTR_DTG_1                      ((u16)0x0002)            /* Bit 1 */
-#define  TIM_BDTR_DTG_2                      ((u16)0x0004)            /* Bit 2 */
-#define  TIM_BDTR_DTG_3                      ((u16)0x0008)            /* Bit 3 */
-#define  TIM_BDTR_DTG_4                      ((u16)0x0010)            /* Bit 4 */
-#define  TIM_BDTR_DTG_5                      ((u16)0x0020)            /* Bit 5 */
-#define  TIM_BDTR_DTG_6                      ((u16)0x0040)            /* Bit 6 */
-#define  TIM_BDTR_DTG_7                      ((u16)0x0080)            /* Bit 7 */
-
-#define  TIM_BDTR_LOCK                       ((u16)0x0300)            /* LOCK[1:0] bits (Lock Configuration) */
-#define  TIM_BDTR_LOCK_0                     ((u16)0x0100)            /* Bit 0 */
-#define  TIM_BDTR_LOCK_1                     ((u16)0x0200)            /* Bit 1 */
-
-#define  TIM_BDTR_OSSI                       ((u16)0x0400)            /* Off-State Selection for Idle mode */
-#define  TIM_BDTR_OSSR                       ((u16)0x0800)            /* Off-State Selection for Run mode */
-#define  TIM_BDTR_BKE                        ((u16)0x1000)            /* Break enable */
-#define  TIM_BDTR_BKP                        ((u16)0x2000)            /* Break Polarity */
-#define  TIM_BDTR_AOE                        ((u16)0x4000)            /* Automatic Output enable */
-#define  TIM_BDTR_MOE                        ((u16)0x8000)            /* Main Output enable */
-
-
-/*******************  Bit definition for TIM_DCR register  ********************/
-#define  TIM_DCR_DBA                         ((u16)0x001F)            /* DBA[4:0] bits (DMA Base Address) */
-#define  TIM_DCR_DBA_0                       ((u16)0x0001)            /* Bit 0 */
-#define  TIM_DCR_DBA_1                       ((u16)0x0002)            /* Bit 1 */
-#define  TIM_DCR_DBA_2                       ((u16)0x0004)            /* Bit 2 */
-#define  TIM_DCR_DBA_3                       ((u16)0x0008)            /* Bit 3 */
-#define  TIM_DCR_DBA_4                       ((u16)0x0010)            /* Bit 4 */
-
-#define  TIM_DCR_DBL                         ((u16)0x1F00)            /* DBL[4:0] bits (DMA Burst Length) */
-#define  TIM_DCR_DBL_0                       ((u16)0x0100)            /* Bit 0 */
-#define  TIM_DCR_DBL_1                       ((u16)0x0200)            /* Bit 1 */
-#define  TIM_DCR_DBL_2                       ((u16)0x0400)            /* Bit 2 */
-#define  TIM_DCR_DBL_3                       ((u16)0x0800)            /* Bit 3 */
-#define  TIM_DCR_DBL_4                       ((u16)0x1000)            /* Bit 4 */
-
-
-/*******************  Bit definition for TIM_DMAR register  *******************/
-#define  TIM_DMAR_DMAB                       ((u16)0xFFFF)            /* DMA register for burst accesses */
-
-
-
-/******************************************************************************/
-/*                                                                            */
-/*                             Real-Time Clock                                */
-/*                                                                            */
-/******************************************************************************/
-
-/*******************  Bit definition for RTC_CRH register  ********************/
-#define  RTC_CRH_SECIE                       ((u8)0x01)               /* Second Interrupt Enable */
-#define  RTC_CRH_ALRIE                       ((u8)0x02)               /* Alarm Interrupt Enable */
-#define  RTC_CRH_OWIE                        ((u8)0x04)               /* OverfloW Interrupt Enable */
-
-
-/*******************  Bit definition for RTC_CRL register  ********************/
-#define  RTC_CRL_SECF                        ((u8)0x01)               /* Second Flag */
-#define  RTC_CRL_ALRF                        ((u8)0x02)               /* Alarm Flag */
-#define  RTC_CRL_OWF                         ((u8)0x04)               /* OverfloW Flag */
-#define  RTC_CRL_RSF                         ((u8)0x08)               /* Registers Synchronized Flag */
-#define  RTC_CRL_CNF                         ((u8)0x10)               /* Configuration Flag */
-#define  RTC_CRL_RTOFF                       ((u8)0x20)               /* RTC operation OFF */
-
-
-/*******************  Bit definition for RTC_PRLH register  *******************/
-#define  RTC_PRLH_PRL                        ((u16)0x000F)            /* RTC Prescaler Reload Value High */
-
-
-/*******************  Bit definition for RTC_PRLL register  *******************/
-#define  RTC_PRLL_PRL                        ((u16)0xFFFF)            /* RTC Prescaler Reload Value Low */
-
-
-/*******************  Bit definition for RTC_DIVH register  *******************/
-#define  RTC_DIVH_RTC_DIV                    ((u16)0x000F)            /* RTC Clock Divider High */
-
-
-/*******************  Bit definition for RTC_DIVL register  *******************/
-#define  RTC_DIVL_RTC_DIV                    ((u16)0xFFFF)            /* RTC Clock Divider Low */
-
-
-/*******************  Bit definition for RTC_CNTH register  *******************/
-#define  RTC_CNTH_RTC_CNT                    ((u16)0xFFFF)            /* RTC Counter High */
-
-
-/*******************  Bit definition for RTC_CNTL register  *******************/
-#define  RTC_CNTL_RTC_CNT                    ((u16)0xFFFF)            /* RTC Counter Low */
-
-
-/*******************  Bit definition for RTC_ALRH register  *******************/
-#define  RTC_ALRH_RTC_ALR                    ((u16)0xFFFF)            /* RTC Alarm High */
-
-
-/*******************  Bit definition for RTC_ALRL register  *******************/
-#define  RTC_ALRL_RTC_ALR                    ((u16)0xFFFF)            /* RTC Alarm Low */
-
-
-
-/******************************************************************************/
-/*                                                                            */
-/*                           Independent WATCHDOG                             */
-/*                                                                            */
-/******************************************************************************/
-
-/*******************  Bit definition for IWDG_KR register  ********************/
-#define  IWDG_KR_KEY                         ((u16)0xFFFF)            /* Key value (write only, read 0000h) */
-
-
-/*******************  Bit definition for IWDG_PR register  ********************/
-#define  IWDG_PR_PR                          ((u8)0x07)               /* PR[2:0] (Prescaler divider) */
-#define  IWDG_PR_PR_0                        ((u8)0x01)               /* Bit 0 */
-#define  IWDG_PR_PR_1                        ((u8)0x02)               /* Bit 1 */
-#define  IWDG_PR_PR_2                        ((u8)0x04)               /* Bit 2 */
-
-
-/*******************  Bit definition for IWDG_RLR register  *******************/
-#define  IWDG_RLR_RL                         ((u16)0x0FFF)            /* Watchdog counter reload value */
-
-
-/*******************  Bit definition for IWDG_SR register  ********************/
-#define  IWDG_SR_PVU                         ((u8)0x01)               /* Watchdog prescaler value update */
-#define  IWDG_SR_RVU                         ((u8)0x02)               /* Watchdog counter reload value update */
-
-
-
-/******************************************************************************/
-/*                                                                            */
-/*                            Window WATCHDOG                                 */
-/*                                                                            */
-/******************************************************************************/
-
-/*******************  Bit definition for WWDG_CR register  ********************/
-#define  WWDG_CR_T                           ((u8)0x7F)               /* T[6:0] bits (7-Bit counter (MSB to LSB)) */
-#define  WWDG_CR_T0                          ((u8)0x01)               /* Bit 0 */
-#define  WWDG_CR_T1                          ((u8)0x02)               /* Bit 1 */
-#define  WWDG_CR_T2                          ((u8)0x04)               /* Bit 2 */
-#define  WWDG_CR_T3                          ((u8)0x08)               /* Bit 3 */
-#define  WWDG_CR_T4                          ((u8)0x10)               /* Bit 4 */
-#define  WWDG_CR_T5                          ((u8)0x20)               /* Bit 5 */
-#define  WWDG_CR_T6                          ((u8)0x40)               /* Bit 6 */
-
-#define  WWDG_CR_WDGA                        ((u8)0x80)               /* Activation bit */
-
-
-/*******************  Bit definition for WWDG_CFR register  *******************/
-#define  WWDG_CFR_W                          ((u16)0x007F)            /* W[6:0] bits (7-bit window value) */
-#define  WWDG_CFR_W0                         ((u16)0x0001)            /* Bit 0 */
-#define  WWDG_CFR_W1                         ((u16)0x0002)            /* Bit 1 */
-#define  WWDG_CFR_W2                         ((u16)0x0004)            /* Bit 2 */
-#define  WWDG_CFR_W3                         ((u16)0x0008)            /* Bit 3 */
-#define  WWDG_CFR_W4                         ((u16)0x0010)            /* Bit 4 */
-#define  WWDG_CFR_W5                         ((u16)0x0020)            /* Bit 5 */
-#define  WWDG_CFR_W6                         ((u16)0x0040)            /* Bit 6 */
-
-#define  WWDG_CFR_WDGTB                      ((u16)0x0180)            /* WDGTB[1:0] bits (Timer Base) */
-#define  WWDG_CFR_WDGTB0                     ((u16)0x0080)            /* Bit 0 */
-#define  WWDG_CFR_WDGTB1                     ((u16)0x0100)            /* Bit 1 */
-
-#define  WWDG_CFR_EWI                        ((u16)0x0200)            /* Early Wakeup Interrupt */
-
-
-/*******************  Bit definition for WWDG_SR register  ********************/
-#define  WWDG_SR_EWIF                        ((u8)0x01)               /* Early Wakeup Interrupt Flag */
-
-
-
-/******************************************************************************/
-/*                                                                            */
-/*                       Flexible Static Memory Controller                    */
-/*                                                                            */
-/******************************************************************************/
-
-/******************  Bit definition for FSMC_BCR1 register  *******************/
-#define  FSMC_BCR1_MBKEN                     ((u32)0x00000001)        /* Memory bank enable bit */
-#define  FSMC_BCR1_MUXEN                     ((u32)0x00000002)        /* Address/data multiplexing enable bit */
-
-#define  FSMC_BCR1_MTYP                      ((u32)0x0000000C)        /* MTYP[1:0] bits (Memory type) */
-#define  FSMC_BCR1_MTYP_0                    ((u32)0x00000004)        /* Bit 0 */
-#define  FSMC_BCR1_MTYP_1                    ((u32)0x00000008)        /* Bit 1 */
-
-#define  FSMC_BCR1_MWID                      ((u32)0x00000030)        /* MWID[1:0] bits (Memory data bus width) */
-#define  FSMC_BCR1_MWID_0                    ((u32)0x00000010)        /* Bit 0 */
-#define  FSMC_BCR1_MWID_1                    ((u32)0x00000020)        /* Bit 1 */
-
-#define  FSMC_BCR1_FACCEN                    ((u32)0x00000040)        /* Flash access enable */
-#define  FSMC_BCR1_BURSTEN                   ((u32)0x00000100)        /* Burst enable bit */
-#define  FSMC_BCR1_WAITPOL                   ((u32)0x00000200)        /* Wait signal polarity bit */
-#define  FSMC_BCR1_WRAPMOD                   ((u32)0x00000400)        /* Wrapped burst mode support */
-#define  FSMC_BCR1_WAITCFG                   ((u32)0x00000800)        /* Wait timing configuration */
-#define  FSMC_BCR1_WREN                      ((u32)0x00001000)        /* Write enable bit */
-#define  FSMC_BCR1_WAITEN                    ((u32)0x00002000)        /* Wait enable bit */
-#define  FSMC_BCR1_EXTMOD                    ((u32)0x00004000)        /* Extended mode enable */
-#define  FSMC_BCR1_CBURSTRW                  ((u32)0x00080000)        /* Write burst enable */
-
-
-/******************  Bit definition for FSMC_BCR2 register  *******************/
-#define  FSMC_BCR2_MBKEN                     ((u32)0x00000001)        /* Memory bank enable bit */
-#define  FSMC_BCR2_MUXEN                     ((u32)0x00000002)        /* Address/data multiplexing enable bit */
-
-#define  FSMC_BCR2_MTYP                      ((u32)0x0000000C)        /* MTYP[1:0] bits (Memory type) */
-#define  FSMC_BCR2_MTYP_0                    ((u32)0x00000004)        /* Bit 0 */
-#define  FSMC_BCR2_MTYP_1                    ((u32)0x00000008)        /* Bit 1 */
-
-#define  FSMC_BCR2_MWID                      ((u32)0x00000030)        /* MWID[1:0] bits (Memory data bus width) */
-#define  FSMC_BCR2_MWID_0                    ((u32)0x00000010)        /* Bit 0 */
-#define  FSMC_BCR2_MWID_1                    ((u32)0x00000020)        /* Bit 1 */
-
-#define  FSMC_BCR2_FACCEN                    ((u32)0x00000040)        /* Flash access enable */
-#define  FSMC_BCR2_BURSTEN                   ((u32)0x00000100)        /* Burst enable bit */
-#define  FSMC_BCR2_WAITPOL                   ((u32)0x00000200)        /* Wait signal polarity bit */
-#define  FSMC_BCR2_WRAPMOD                   ((u32)0x00000400)        /* Wrapped burst mode support */
-#define  FSMC_BCR2_WAITCFG                   ((u32)0x00000800)        /* Wait timing configuration */
-#define  FSMC_BCR2_WREN                      ((u32)0x00001000)        /* Write enable bit */
-#define  FSMC_BCR2_WAITEN                    ((u32)0x00002000)        /* Wait enable bit */
-#define  FSMC_BCR2_EXTMOD                    ((u32)0x00004000)        /* Extended mode enable */
-#define  FSMC_BCR2_CBURSTRW                  ((u32)0x00080000)        /* Write burst enable */
-
-
-/******************  Bit definition for FSMC_BCR3 register  *******************/
-#define  FSMC_BCR3_MBKEN                     ((u32)0x00000001)        /* Memory bank enable bit */
-#define  FSMC_BCR3_MUXEN                     ((u32)0x00000002)        /* Address/data multiplexing enable bit */
-
-#define  FSMC_BCR3_MTYP                      ((u32)0x0000000C)        /* MTYP[1:0] bits (Memory type) */
-#define  FSMC_BCR3_MTYP_0                    ((u32)0x00000004)        /* Bit 0 */
-#define  FSMC_BCR3_MTYP_1                    ((u32)0x00000008)        /* Bit 1 */
-
-#define  FSMC_BCR3_MWID                      ((u32)0x00000030)        /* MWID[1:0] bits (Memory data bus width) */
-#define  FSMC_BCR3_MWID_0                    ((u32)0x00000010)        /* Bit 0 */
-#define  FSMC_BCR3_MWID_1                    ((u32)0x00000020)        /* Bit 1 */
-
-#define  FSMC_BCR3_FACCEN                    ((u32)0x00000040)        /* Flash access enable */
-#define  FSMC_BCR3_BURSTEN                   ((u32)0x00000100)        /* Burst enable bit */
-#define  FSMC_BCR3_WAITPOL                   ((u32)0x00000200)        /* Wait signal polarity bit. */
-#define  FSMC_BCR3_WRAPMOD                   ((u32)0x00000400)        /* Wrapped burst mode support */
-#define  FSMC_BCR3_WAITCFG                   ((u32)0x00000800)        /* Wait timing configuration */
-#define  FSMC_BCR3_WREN                      ((u32)0x00001000)        /* Write enable bit */
-#define  FSMC_BCR3_WAITEN                    ((u32)0x00002000)        /* Wait enable bit */
-#define  FSMC_BCR3_EXTMOD                    ((u32)0x00004000)        /* Extended mode enable */
-#define  FSMC_BCR3_CBURSTRW                  ((u32)0x00080000)        /* Write burst enable */
-
-
-/******************  Bit definition for FSMC_BCR4 register  *******************/
-#define  FSMC_BCR4_MBKEN                     ((u32)0x00000001)        /* Memory bank enable bit */
-#define  FSMC_BCR4_MUXEN                     ((u32)0x00000002)        /* Address/data multiplexing enable bit */
-
-#define  FSMC_BCR4_MTYP                      ((u32)0x0000000C)        /* MTYP[1:0] bits (Memory type) */
-#define  FSMC_BCR4_MTYP_0                    ((u32)0x00000004)        /* Bit 0 */
-#define  FSMC_BCR4_MTYP_1                    ((u32)0x00000008)        /* Bit 1 */
-
-#define  FSMC_BCR4_MWID                      ((u32)0x00000030)        /* MWID[1:0] bits (Memory data bus width) */
-#define  FSMC_BCR4_MWID_0                    ((u32)0x00000010)        /* Bit 0 */
-#define  FSMC_BCR4_MWID_1                    ((u32)0x00000020)        /* Bit 1 */
-
-#define  FSMC_BCR4_FACCEN                    ((u32)0x00000040)        /* Flash access enable */
-#define  FSMC_BCR4_BURSTEN                   ((u32)0x00000100)        /* Burst enable bit */
-#define  FSMC_BCR4_WAITPOL                   ((u32)0x00000200)        /* Wait signal polarity bit */
-#define  FSMC_BCR4_WRAPMOD                   ((u32)0x00000400)        /* Wrapped burst mode support */
-#define  FSMC_BCR4_WAITCFG                   ((u32)0x00000800)        /* Wait timing configuration */
-#define  FSMC_BCR4_WREN                      ((u32)0x00001000)        /* Write enable bit */
-#define  FSMC_BCR4_WAITEN                    ((u32)0x00002000)        /* Wait enable bit */
-#define  FSMC_BCR4_EXTMOD                    ((u32)0x00004000)        /* Extended mode enable */
-#define  FSMC_BCR4_CBURSTRW                  ((u32)0x00080000)        /* Write burst enable */
-
-
-/******************  Bit definition for FSMC_BTR1 register  ******************/
-#define  FSMC_BTR1_ADDSET                    ((u32)0x0000000F)        /* ADDSET[3:0] bits (Address setup phase duration) */
-#define  FSMC_BTR1_ADDSET_0                  ((u32)0x00000001)        /* Bit 0 */
-#define  FSMC_BTR1_ADDSET_1                  ((u32)0x00000002)        /* Bit 1 */
-#define  FSMC_BTR1_ADDSET_2                  ((u32)0x00000004)        /* Bit 2 */
-#define  FSMC_BTR1_ADDSET_3                  ((u32)0x00000008)        /* Bit 3 */
-
-#define  FSMC_BTR1_ADDHLD                    ((u32)0x000000F0)        /* ADDHLD[3:0] bits (Address-hold phase duration) */
-#define  FSMC_BTR1_ADDHLD_0                  ((u32)0x00000010)        /* Bit 0 */
-#define  FSMC_BTR1_ADDHLD_1                  ((u32)0x00000020)        /* Bit 1 */
-#define  FSMC_BTR1_ADDHLD_2                  ((u32)0x00000040)        /* Bit 2 */
-#define  FSMC_BTR1_ADDHLD_3                  ((u32)0x00000080)        /* Bit 3 */
-
-#define  FSMC_BTR1_DATAST                    ((u32)0x0000FF00)        /* DATAST [3:0] bits (Data-phase duration) */
-#define  FSMC_BTR1_DATAST_0                  ((u32)0x00000100)        /* Bit 0 */
-#define  FSMC_BTR1_DATAST_1                  ((u32)0x00000200)        /* Bit 1 */
-#define  FSMC_BTR1_DATAST_2                  ((u32)0x00000400)        /* Bit 2 */
-#define  FSMC_BTR1_DATAST_3                  ((u32)0x00000800)        /* Bit 3 */
-
-#define  FSMC_BTR1_BUSTURN                   ((u32)0x000F0000)        /* BUSTURN[3:0] bits (Bus turnaround phase duration) */
-#define  FSMC_BTR1_BUSTURN_0                 ((u32)0x00010000)        /* Bit 0 */
-#define  FSMC_BTR1_BUSTURN_1                 ((u32)0x00020000)        /* Bit 1 */
-#define  FSMC_BTR1_BUSTURN_2                 ((u32)0x00040000)        /* Bit 2 */
-#define  FSMC_BTR1_BUSTURN_3                 ((u32)0x00080000)        /* Bit 3 */
-
-#define  FSMC_BTR1_CLKDIV                    ((u32)0x00F00000)        /* CLKDIV[3:0] bits (Clock divide ratio) */
-#define  FSMC_BTR1_CLKDIV_0                  ((u32)0x00100000)        /* Bit 0 */
-#define  FSMC_BTR1_CLKDIV_1                  ((u32)0x00200000)        /* Bit 1 */
-#define  FSMC_BTR1_CLKDIV_2                  ((u32)0x00400000)        /* Bit 2 */
-#define  FSMC_BTR1_CLKDIV_3                  ((u32)0x00800000)        /* Bit 3 */
-
-#define  FSMC_BTR1_DATLAT                    ((u32)0x0F000000)        /* DATLA[3:0] bits (Data latency) */
-#define  FSMC_BTR1_DATLAT_0                  ((u32)0x01000000)        /* Bit 0 */
-#define  FSMC_BTR1_DATLAT_1                  ((u32)0x02000000)        /* Bit 1 */
-#define  FSMC_BTR1_DATLAT_2                  ((u32)0x04000000)        /* Bit 2 */
-#define  FSMC_BTR1_DATLAT_3                  ((u32)0x08000000)        /* Bit 3 */
-
-#define  FSMC_BTR1_ACCMOD                    ((u32)0x30000000)        /* ACCMOD[1:0] bits (Access mode) */
-#define  FSMC_BTR1_ACCMOD_0                  ((u32)0x10000000)        /* Bit 0 */
-#define  FSMC_BTR1_ACCMOD_1                  ((u32)0x20000000)        /* Bit 1 */
-
-
-/******************  Bit definition for FSMC_BTR2 register  *******************/
-#define  FSMC_BTR2_ADDSET                    ((u32)0x0000000F)        /* ADDSET[3:0] bits (Address setup phase duration) */
-#define  FSMC_BTR2_ADDSET_0                  ((u32)0x00000001)        /* Bit 0 */
-#define  FSMC_BTR2_ADDSET_1                  ((u32)0x00000002)        /* Bit 1 */
-#define  FSMC_BTR2_ADDSET_2                  ((u32)0x00000004)        /* Bit 2 */
-#define  FSMC_BTR2_ADDSET_3                  ((u32)0x00000008)        /* Bit 3 */
-
-#define  FSMC_BTR2_ADDHLD                    ((u32)0x000000F0)        /* ADDHLD[3:0] bits (Address-hold phase duration) */
-#define  FSMC_BTR2_ADDHLD_0                  ((u32)0x00000010)        /* Bit 0 */
-#define  FSMC_BTR2_ADDHLD_1                  ((u32)0x00000020)        /* Bit 1 */
-#define  FSMC_BTR2_ADDHLD_2                  ((u32)0x00000040)        /* Bit 2 */
-#define  FSMC_BTR2_ADDHLD_3                  ((u32)0x00000080)        /* Bit 3 */
-
-#define  FSMC_BTR2_DATAST                    ((u32)0x0000FF00)        /* DATAST [3:0] bits (Data-phase duration) */
-#define  FSMC_BTR2_DATAST_0                  ((u32)0x00000100)        /* Bit 0 */
-#define  FSMC_BTR2_DATAST_1                  ((u32)0x00000200)        /* Bit 1 */
-#define  FSMC_BTR2_DATAST_2                  ((u32)0x00000400)        /* Bit 2 */
-#define  FSMC_BTR2_DATAST_3                  ((u32)0x00000800)        /* Bit 3 */
-
-#define  FSMC_BTR2_BUSTURN                   ((u32)0x000F0000)        /* BUSTURN[3:0] bits (Bus turnaround phase duration) */
-#define  FSMC_BTR2_BUSTURN_0                 ((u32)0x00010000)        /* Bit 0 */
-#define  FSMC_BTR2_BUSTURN_1                 ((u32)0x00020000)        /* Bit 1 */
-#define  FSMC_BTR2_BUSTURN_2                 ((u32)0x00040000)        /* Bit 2 */
-#define  FSMC_BTR2_BUSTURN_3                 ((u32)0x00080000)        /* Bit 3 */
-
-#define  FSMC_BTR2_CLKDIV                    ((u32)0x00F00000)        /* CLKDIV[3:0] bits (Clock divide ratio) */
-#define  FSMC_BTR2_CLKDIV_0                  ((u32)0x00100000)        /* Bit 0 */
-#define  FSMC_BTR2_CLKDIV_1                  ((u32)0x00200000)        /* Bit 1 */
-#define  FSMC_BTR2_CLKDIV_2                  ((u32)0x00400000)        /* Bit 2 */
-#define  FSMC_BTR2_CLKDIV_3                  ((u32)0x00800000)        /* Bit 3 */
-
-#define  FSMC_BTR2_DATLAT                    ((u32)0x0F000000)        /* DATLA[3:0] bits (Data latency) */
-#define  FSMC_BTR2_DATLAT_0                  ((u32)0x01000000)        /* Bit 0 */
-#define  FSMC_BTR2_DATLAT_1                  ((u32)0x02000000)        /* Bit 1 */
-#define  FSMC_BTR2_DATLAT_2                  ((u32)0x04000000)        /* Bit 2 */
-#define  FSMC_BTR2_DATLAT_3                  ((u32)0x08000000)        /* Bit 3 */
-
-#define  FSMC_BTR2_ACCMOD                    ((u32)0x30000000)        /* ACCMOD[1:0] bits (Access mode) */
-#define  FSMC_BTR2_ACCMOD_0                  ((u32)0x10000000)        /* Bit 0 */
-#define  FSMC_BTR2_ACCMOD_1                  ((u32)0x20000000)        /* Bit 1 */
-
-
-/*******************  Bit definition for FSMC_BTR3 register  *******************/
-#define  FSMC_BTR3_ADDSET                    ((u32)0x0000000F)        /* ADDSET[3:0] bits (Address setup phase duration) */
-#define  FSMC_BTR3_ADDSET_0                  ((u32)0x00000001)        /* Bit 0 */
-#define  FSMC_BTR3_ADDSET_1                  ((u32)0x00000002)        /* Bit 1 */
-#define  FSMC_BTR3_ADDSET_2                  ((u32)0x00000004)        /* Bit 2 */
-#define  FSMC_BTR3_ADDSET_3                  ((u32)0x00000008)        /* Bit 3 */
-
-#define  FSMC_BTR3_ADDHLD                    ((u32)0x000000F0)        /* ADDHLD[3:0] bits (Address-hold phase duration) */
-#define  FSMC_BTR3_ADDHLD_0                  ((u32)0x00000010)        /* Bit 0 */
-#define  FSMC_BTR3_ADDHLD_1                  ((u32)0x00000020)        /* Bit 1 */
-#define  FSMC_BTR3_ADDHLD_2                  ((u32)0x00000040)        /* Bit 2 */
-#define  FSMC_BTR3_ADDHLD_3                  ((u32)0x00000080)        /* Bit 3 */
-
-#define  FSMC_BTR3_DATAST                    ((u32)0x0000FF00)        /* DATAST [3:0] bits (Data-phase duration) */
-#define  FSMC_BTR3_DATAST_0                  ((u32)0x00000100)        /* Bit 0 */
-#define  FSMC_BTR3_DATAST_1                  ((u32)0x00000200)        /* Bit 1 */
-#define  FSMC_BTR3_DATAST_2                  ((u32)0x00000400)        /* Bit 2 */
-#define  FSMC_BTR3_DATAST_3                  ((u32)0x00000800)        /* Bit 3 */
-
-#define  FSMC_BTR3_BUSTURN                   ((u32)0x000F0000)        /* BUSTURN[3:0] bits (Bus turnaround phase duration) */
-#define  FSMC_BTR3_BUSTURN_0                 ((u32)0x00010000)        /* Bit 0 */
-#define  FSMC_BTR3_BUSTURN_1                 ((u32)0x00020000)        /* Bit 1 */
-#define  FSMC_BTR3_BUSTURN_2                 ((u32)0x00040000)        /* Bit 2 */
-#define  FSMC_BTR3_BUSTURN_3                 ((u32)0x00080000)        /* Bit 3 */
-
-#define  FSMC_BTR3_CLKDIV                    ((u32)0x00F00000)        /* CLKDIV[3:0] bits (Clock divide ratio) */
-#define  FSMC_BTR3_CLKDIV_0                  ((u32)0x00100000)        /* Bit 0 */
-#define  FSMC_BTR3_CLKDIV_1                  ((u32)0x00200000)        /* Bit 1 */
-#define  FSMC_BTR3_CLKDIV_2                  ((u32)0x00400000)        /* Bit 2 */
-#define  FSMC_BTR3_CLKDIV_3                  ((u32)0x00800000)        /* Bit 3 */
-
-#define  FSMC_BTR3_DATLAT                    ((u32)0x0F000000)        /* DATLA[3:0] bits (Data latency) */
-#define  FSMC_BTR3_DATLAT_0                  ((u32)0x01000000)        /* Bit 0 */
-#define  FSMC_BTR3_DATLAT_1                  ((u32)0x02000000)        /* Bit 1 */
-#define  FSMC_BTR3_DATLAT_2                  ((u32)0x04000000)        /* Bit 2 */
-#define  FSMC_BTR3_DATLAT_3                  ((u32)0x08000000)        /* Bit 3 */
-
-#define  FSMC_BTR3_ACCMOD                    ((u32)0x30000000)        /* ACCMOD[1:0] bits (Access mode) */
-#define  FSMC_BTR3_ACCMOD_0                  ((u32)0x10000000)        /* Bit 0 */
-#define  FSMC_BTR3_ACCMOD_1                  ((u32)0x20000000)        /* Bit 1 */
-
-
-/******************  Bit definition for FSMC_BTR4 register  *******************/
-#define  FSMC_BTR4_ADDSET                    ((u32)0x0000000F)        /* ADDSET[3:0] bits (Address setup phase duration) */
-#define  FSMC_BTR4_ADDSET_0                  ((u32)0x00000001)        /* Bit 0 */
-#define  FSMC_BTR4_ADDSET_1                  ((u32)0x00000002)        /* Bit 1 */
-#define  FSMC_BTR4_ADDSET_2                  ((u32)0x00000004)        /* Bit 2 */
-#define  FSMC_BTR4_ADDSET_3                  ((u32)0x00000008)        /* Bit 3 */
-
-#define  FSMC_BTR4_ADDHLD                    ((u32)0x000000F0)        /* ADDHLD[3:0] bits (Address-hold phase duration) */
-#define  FSMC_BTR4_ADDHLD_0                  ((u32)0x00000010)        /* Bit 0 */
-#define  FSMC_BTR4_ADDHLD_1                  ((u32)0x00000020)        /* Bit 1 */
-#define  FSMC_BTR4_ADDHLD_2                  ((u32)0x00000040)        /* Bit 2 */
-#define  FSMC_BTR4_ADDHLD_3                  ((u32)0x00000080)        /* Bit 3 */
-
-#define  FSMC_BTR4_DATAST                    ((u32)0x0000FF00)        /* DATAST [3:0] bits (Data-phase duration) */
-#define  FSMC_BTR4_DATAST_0                  ((u32)0x00000100)        /* Bit 0 */
-#define  FSMC_BTR4_DATAST_1                  ((u32)0x00000200)        /* Bit 1 */
-#define  FSMC_BTR4_DATAST_2                  ((u32)0x00000400)        /* Bit 2 */
-#define  FSMC_BTR4_DATAST_3                  ((u32)0x00000800)        /* Bit 3 */
-
-#define  FSMC_BTR4_BUSTURN                   ((u32)0x000F0000)        /* BUSTURN[3:0] bits (Bus turnaround phase duration) */
-#define  FSMC_BTR4_BUSTURN_0                 ((u32)0x00010000)        /* Bit 0 */
-#define  FSMC_BTR4_BUSTURN_1                 ((u32)0x00020000)        /* Bit 1 */
-#define  FSMC_BTR4_BUSTURN_2                 ((u32)0x00040000)        /* Bit 2 */
-#define  FSMC_BTR4_BUSTURN_3                 ((u32)0x00080000)        /* Bit 3 */
-
-#define  FSMC_BTR4_CLKDIV                    ((u32)0x00F00000)        /* CLKDIV[3:0] bits (Clock divide ratio) */
-#define  FSMC_BTR4_CLKDIV_0                  ((u32)0x00100000)        /* Bit 0 */
-#define  FSMC_BTR4_CLKDIV_1                  ((u32)0x00200000)        /* Bit 1 */
-#define  FSMC_BTR4_CLKDIV_2                  ((u32)0x00400000)        /* Bit 2 */
-#define  FSMC_BTR4_CLKDIV_3                  ((u32)0x00800000)        /* Bit 3 */
-
-#define  FSMC_BTR4_DATLAT                    ((u32)0x0F000000)        /* DATLA[3:0] bits (Data latency) */
-#define  FSMC_BTR4_DATLAT_0                  ((u32)0x01000000)        /* Bit 0 */
-#define  FSMC_BTR4_DATLAT_1                  ((u32)0x02000000)        /* Bit 1 */
-#define  FSMC_BTR4_DATLAT_2                  ((u32)0x04000000)        /* Bit 2 */
-#define  FSMC_BTR4_DATLAT_3                  ((u32)0x08000000)        /* Bit 3 */
-
-#define  FSMC_BTR4_ACCMOD                    ((u32)0x30000000)        /* ACCMOD[1:0] bits (Access mode) */
-#define  FSMC_BTR4_ACCMOD_0                  ((u32)0x10000000)        /* Bit 0 */
-#define  FSMC_BTR4_ACCMOD_1                  ((u32)0x20000000)        /* Bit 1 */
-
-
-/******************  Bit definition for FSMC_BWTR1 register  ******************/
-#define  FSMC_BWTR1_ADDSET                   ((u32)0x0000000F)        /* ADDSET[3:0] bits (Address setup phase duration) */
-#define  FSMC_BWTR1_ADDSET_0                 ((u32)0x00000001)        /* Bit 0 */
-#define  FSMC_BWTR1_ADDSET_1                 ((u32)0x00000002)        /* Bit 1 */
-#define  FSMC_BWTR1_ADDSET_2                 ((u32)0x00000004)        /* Bit 2 */
-#define  FSMC_BWTR1_ADDSET_3                 ((u32)0x00000008)        /* Bit 3 */
-
-#define  FSMC_BWTR1_ADDHLD                   ((u32)0x000000F0)        /* ADDHLD[3:0] bits (Address-hold phase duration) */
-#define  FSMC_BWTR1_ADDHLD_0                 ((u32)0x00000010)        /* Bit 0 */
-#define  FSMC_BWTR1_ADDHLD_1                 ((u32)0x00000020)        /* Bit 1 */
-#define  FSMC_BWTR1_ADDHLD_2                 ((u32)0x00000040)        /* Bit 2 */
-#define  FSMC_BWTR1_ADDHLD_3                 ((u32)0x00000080)        /* Bit 3 */
-
-#define  FSMC_BWTR1_DATAST                   ((u32)0x0000FF00)        /* DATAST [3:0] bits (Data-phase duration) */
-#define  FSMC_BWTR1_DATAST_0                 ((u32)0x00000100)        /* Bit 0 */
-#define  FSMC_BWTR1_DATAST_1                 ((u32)0x00000200)        /* Bit 1 */
-#define  FSMC_BWTR1_DATAST_2                 ((u32)0x00000400)        /* Bit 2 */
-#define  FSMC_BWTR1_DATAST_3                 ((u32)0x00000800)        /* Bit 3 */
-
-#define  FSMC_BWTR1_BUSTURN                  ((u32)0x000F0000)        /* BUSTURN[3:0] bits (Bus turnaround phase duration) */
-#define  FSMC_BWTR1_BUSTURN_0                ((u32)0x00010000)        /* Bit 0 */
-#define  FSMC_BWTR1_BUSTURN_1                ((u32)0x00020000)        /* Bit 1 */
-#define  FSMC_BWTR1_BUSTURN_2                ((u32)0x00040000)        /* Bit 2 */
-#define  FSMC_BWTR1_BUSTURN_3                ((u32)0x00080000)        /* Bit 3 */
-
-#define  FSMC_BWTR1_CLKDIV                   ((u32)0x00F00000)        /* CLKDIV[3:0] bits (Clock divide ratio) */
-#define  FSMC_BWTR1_CLKDIV_0                 ((u32)0x00100000)        /* Bit 0 */
-#define  FSMC_BWTR1_CLKDIV_1                 ((u32)0x00200000)        /* Bit 1 */
-#define  FSMC_BWTR1_CLKDIV_2                 ((u32)0x00400000)        /* Bit 2 */
-#define  FSMC_BWTR1_CLKDIV_3                 ((u32)0x00800000)        /* Bit 3 */
-
-#define  FSMC_BWTR1_DATLAT                   ((u32)0x0F000000)        /* DATLA[3:0] bits (Data latency) */
-#define  FSMC_BWTR1_DATLAT_0                 ((u32)0x01000000)        /* Bit 0 */
-#define  FSMC_BWTR1_DATLAT_1                 ((u32)0x02000000)        /* Bit 1 */
-#define  FSMC_BWTR1_DATLAT_2                 ((u32)0x04000000)        /* Bit 2 */
-#define  FSMC_BWTR1_DATLAT_3                 ((u32)0x08000000)        /* Bit 3 */
-
-#define  FSMC_BWTR1_ACCMOD                   ((u32)0x30000000)        /* ACCMOD[1:0] bits (Access mode) */
-#define  FSMC_BWTR1_ACCMOD_0                 ((u32)0x10000000)        /* Bit 0 */
-#define  FSMC_BWTR1_ACCMOD_1                 ((u32)0x20000000)        /* Bit 1 */
-
-
-/******************  Bit definition for FSMC_BWTR2 register  ******************/
-#define  FSMC_BWTR2_ADDSET                   ((u32)0x0000000F)        /* ADDSET[3:0] bits (Address setup phase duration) */
-#define  FSMC_BWTR2_ADDSET_0                 ((u32)0x00000001)        /* Bit 0 */
-#define  FSMC_BWTR2_ADDSET_1                 ((u32)0x00000002)        /* Bit 1 */
-#define  FSMC_BWTR2_ADDSET_2                 ((u32)0x00000004)        /* Bit 2 */
-#define  FSMC_BWTR2_ADDSET_3                 ((u32)0x00000008)        /* Bit 3 */
-
-#define  FSMC_BWTR2_ADDHLD                   ((u32)0x000000F0)        /* ADDHLD[3:0] bits (Address-hold phase duration) */
-#define  FSMC_BWTR2_ADDHLD_0                 ((u32)0x00000010)        /* Bit 0 */
-#define  FSMC_BWTR2_ADDHLD_1                 ((u32)0x00000020)        /* Bit 1 */
-#define  FSMC_BWTR2_ADDHLD_2                 ((u32)0x00000040)        /* Bit 2 */
-#define  FSMC_BWTR2_ADDHLD_3                 ((u32)0x00000080)        /* Bit 3 */
-
-#define  FSMC_BWTR2_DATAST                   ((u32)0x0000FF00)        /* DATAST [3:0] bits (Data-phase duration) */
-#define  FSMC_BWTR2_DATAST_0                 ((u32)0x00000100)        /* Bit 0 */
-#define  FSMC_BWTR2_DATAST_1                 ((u32)0x00000200)        /* Bit 1 */
-#define  FSMC_BWTR2_DATAST_2                 ((u32)0x00000400)        /* Bit 2 */
-#define  FSMC_BWTR2_DATAST_3                 ((u32)0x00000800)        /* Bit 3 */
-
-#define  FSMC_BWTR2_BUSTURN                  ((u32)0x000F0000)        /* BUSTURN[3:0] bits (Bus turnaround phase duration) */
-#define  FSMC_BWTR2_BUSTURN_0                ((u32)0x00010000)        /* Bit 0 */
-#define  FSMC_BWTR2_BUSTURN_1                ((u32)0x00020000)        /* Bit 1 */
-#define  FSMC_BWTR2_BUSTURN_2                ((u32)0x00040000)        /* Bit 2 */
-#define  FSMC_BWTR2_BUSTURN_3                ((u32)0x00080000)        /* Bit 3 */
-
-#define  FSMC_BWTR2_CLKDIV                   ((u32)0x00F00000)        /* CLKDIV[3:0] bits (Clock divide ratio) */
-#define  FSMC_BWTR2_CLKDIV_0                 ((u32)0x00100000)        /* Bit 0 */
-#define  FSMC_BWTR2_CLKDIV_1                 ((u32)0x00200000)        /* Bit 1*/
-#define  FSMC_BWTR2_CLKDIV_2                 ((u32)0x00400000)        /* Bit 2 */
-#define  FSMC_BWTR2_CLKDIV_3                 ((u32)0x00800000)        /* Bit 3 */
-
-#define  FSMC_BWTR2_DATLAT                   ((u32)0x0F000000)        /* DATLA[3:0] bits (Data latency) */
-#define  FSMC_BWTR2_DATLAT_0                 ((u32)0x01000000)        /* Bit 0 */
-#define  FSMC_BWTR2_DATLAT_1                 ((u32)0x02000000)        /* Bit 1 */
-#define  FSMC_BWTR2_DATLAT_2                 ((u32)0x04000000)        /* Bit 2 */
-#define  FSMC_BWTR2_DATLAT_3                 ((u32)0x08000000)        /* Bit 3 */
-
-#define  FSMC_BWTR2_ACCMOD                   ((u32)0x30000000)        /* ACCMOD[1:0] bits (Access mode) */
-#define  FSMC_BWTR2_ACCMOD_0                 ((u32)0x10000000)        /* Bit 0 */
-#define  FSMC_BWTR2_ACCMOD_1                 ((u32)0x20000000)        /* Bit 1 */
-
-
-/******************  Bit definition for FSMC_BWTR3 register  ******************/
-#define  FSMC_BWTR3_ADDSET                   ((u32)0x0000000F)        /* ADDSET[3:0] bits (Address setup phase duration) */
-#define  FSMC_BWTR3_ADDSET_0                 ((u32)0x00000001)        /* Bit 0 */
-#define  FSMC_BWTR3_ADDSET_1                 ((u32)0x00000002)        /* Bit 1 */
-#define  FSMC_BWTR3_ADDSET_2                 ((u32)0x00000004)        /* Bit 2 */
-#define  FSMC_BWTR3_ADDSET_3                 ((u32)0x00000008)        /* Bit 3 */
-
-#define  FSMC_BWTR3_ADDHLD                   ((u32)0x000000F0)        /* ADDHLD[3:0] bits (Address-hold phase duration) */
-#define  FSMC_BWTR3_ADDHLD_0                 ((u32)0x00000010)        /* Bit 0 */
-#define  FSMC_BWTR3_ADDHLD_1                 ((u32)0x00000020)        /* Bit 1 */
-#define  FSMC_BWTR3_ADDHLD_2                 ((u32)0x00000040)        /* Bit 2 */
-#define  FSMC_BWTR3_ADDHLD_3                 ((u32)0x00000080)        /* Bit 3 */
-
-#define  FSMC_BWTR3_DATAST                   ((u32)0x0000FF00)        /* DATAST [3:0] bits (Data-phase duration) */
-#define  FSMC_BWTR3_DATAST_0                 ((u32)0x00000100)        /* Bit 0 */
-#define  FSMC_BWTR3_DATAST_1                 ((u32)0x00000200)        /* Bit 1 */
-#define  FSMC_BWTR3_DATAST_2                 ((u32)0x00000400)        /* Bit 2 */
-#define  FSMC_BWTR3_DATAST_3                 ((u32)0x00000800)        /* Bit 3 */
-
-#define  FSMC_BWTR3_BUSTURN                  ((u32)0x000F0000)        /* BUSTURN[3:0] bits (Bus turnaround phase duration) */
-#define  FSMC_BWTR3_BUSTURN_0                ((u32)0x00010000)        /* Bit 0 */
-#define  FSMC_BWTR3_BUSTURN_1                ((u32)0x00020000)        /* Bit 1 */
-#define  FSMC_BWTR3_BUSTURN_2                ((u32)0x00040000)        /* Bit 2 */
-#define  FSMC_BWTR3_BUSTURN_3                ((u32)0x00080000)        /* Bit 3 */
-
-#define  FSMC_BWTR3_CLKDIV                   ((u32)0x00F00000)        /* CLKDIV[3:0] bits (Clock divide ratio) */
-#define  FSMC_BWTR3_CLKDIV_0                 ((u32)0x00100000)        /* Bit 0 */
-#define  FSMC_BWTR3_CLKDIV_1                 ((u32)0x00200000)        /* Bit 1 */
-#define  FSMC_BWTR3_CLKDIV_2                 ((u32)0x00400000)        /* Bit 2 */
-#define  FSMC_BWTR3_CLKDIV_3                 ((u32)0x00800000)        /* Bit 3 */
-
-#define  FSMC_BWTR3_DATLAT                   ((u32)0x0F000000)        /* DATLA[3:0] bits (Data latency) */
-#define  FSMC_BWTR3_DATLAT_0                 ((u32)0x01000000)        /* Bit 0 */
-#define  FSMC_BWTR3_DATLAT_1                 ((u32)0x02000000)        /* Bit 1 */
-#define  FSMC_BWTR3_DATLAT_2                 ((u32)0x04000000)        /* Bit 2 */
-#define  FSMC_BWTR3_DATLAT_3                 ((u32)0x08000000)        /* Bit 3 */
-
-#define  FSMC_BWTR3_ACCMOD                   ((u32)0x30000000)        /* ACCMOD[1:0] bits (Access mode) */
-#define  FSMC_BWTR3_ACCMOD_0                 ((u32)0x10000000)        /* Bit 0 */
-#define  FSMC_BWTR3_ACCMOD_1                 ((u32)0x20000000)        /* Bit 1 */
-
-
-/******************  Bit definition for FSMC_BWTR4 register  ******************/
-#define  FSMC_BWTR4_ADDSET                   ((u32)0x0000000F)        /* ADDSET[3:0] bits (Address setup phase duration) */
-#define  FSMC_BWTR4_ADDSET_0                 ((u32)0x00000001)        /* Bit 0 */
-#define  FSMC_BWTR4_ADDSET_1                 ((u32)0x00000002)        /* Bit 1 */
-#define  FSMC_BWTR4_ADDSET_2                 ((u32)0x00000004)        /* Bit 2 */
-#define  FSMC_BWTR4_ADDSET_3                 ((u32)0x00000008)        /* Bit 3 */
-
-#define  FSMC_BWTR4_ADDHLD                   ((u32)0x000000F0)        /* ADDHLD[3:0] bits (Address-hold phase duration) */
-#define  FSMC_BWTR4_ADDHLD_0                 ((u32)0x00000010)        /* Bit 0 */
-#define  FSMC_BWTR4_ADDHLD_1                 ((u32)0x00000020)        /* Bit 1 */
-#define  FSMC_BWTR4_ADDHLD_2                 ((u32)0x00000040)        /* Bit 2 */
-#define  FSMC_BWTR4_ADDHLD_3                 ((u32)0x00000080)        /* Bit 3 */
-
-#define  FSMC_BWTR4_DATAST                   ((u32)0x0000FF00)        /* DATAST [3:0] bits (Data-phase duration) */
-#define  FSMC_BWTR4_DATAST_0                 ((u32)0x00000100)        /* Bit 0 */
-#define  FSMC_BWTR4_DATAST_1                 ((u32)0x00000200)        /* Bit 1 */
-#define  FSMC_BWTR4_DATAST_2                 ((u32)0x00000400)        /* Bit 2 */
-#define  FSMC_BWTR4_DATAST_3                 ((u32)0x00000800)        /* Bit 3 */
-
-#define  FSMC_BWTR4_BUSTURN                  ((u32)0x000F0000)        /* BUSTURN[3:0] bits (Bus turnaround phase duration) */
-#define  FSMC_BWTR4_BUSTURN_0                ((u32)0x00010000)        /* Bit 0 */
-#define  FSMC_BWTR4_BUSTURN_1                ((u32)0x00020000)        /* Bit 1 */
-#define  FSMC_BWTR4_BUSTURN_2                ((u32)0x00040000)        /* Bit 2 */
-#define  FSMC_BWTR4_BUSTURN_3                ((u32)0x00080000)        /* Bit 3 */
-
-#define  FSMC_BWTR4_CLKDIV                   ((u32)0x00F00000)        /* CLKDIV[3:0] bits (Clock divide ratio) */
-#define  FSMC_BWTR4_CLKDIV_0                 ((u32)0x00100000)        /* Bit 0 */
-#define  FSMC_BWTR4_CLKDIV_1                 ((u32)0x00200000)        /* Bit 1 */
-#define  FSMC_BWTR4_CLKDIV_2                 ((u32)0x00400000)        /* Bit 2 */
-#define  FSMC_BWTR4_CLKDIV_3                 ((u32)0x00800000)        /* Bit 3 */
-
-#define  FSMC_BWTR4_DATLAT                   ((u32)0x0F000000)        /* DATLA[3:0] bits (Data latency) */
-#define  FSMC_BWTR4_DATLAT_0                 ((u32)0x01000000)        /* Bit 0 */
-#define  FSMC_BWTR4_DATLAT_1                 ((u32)0x02000000)        /* Bit 1 */
-#define  FSMC_BWTR4_DATLAT_2                 ((u32)0x04000000)        /* Bit 2 */
-#define  FSMC_BWTR4_DATLAT_3                 ((u32)0x08000000)        /* Bit 3 */
-
-#define  FSMC_BWTR4_ACCMOD                   ((u32)0x30000000)        /* ACCMOD[1:0] bits (Access mode) */
-#define  FSMC_BWTR4_ACCMOD_0                 ((u32)0x10000000)        /* Bit 0 */
-#define  FSMC_BWTR4_ACCMOD_1                 ((u32)0x20000000)        /* Bit 1 */
-
-
-/******************  Bit definition for FSMC_PCR2 register  *******************/
-#define  FSMC_PCR2_PWAITEN                   ((u32)0x00000002)        /* Wait feature enable bit */
-#define  FSMC_PCR2_PBKEN                     ((u32)0x00000004)        /* PC Card/NAND Flash memory bank enable bit */
-#define  FSMC_PCR2_PTYP                      ((u32)0x00000008)        /* Memory type */
-
-#define  FSMC_PCR2_PWID                      ((u32)0x00000030)        /* PWID[1:0] bits (NAND Flash databus width) */
-#define  FSMC_PCR2_PWID_0                    ((u32)0x00000010)        /* Bit 0 */
-#define  FSMC_PCR2_PWID_1                    ((u32)0x00000020)        /* Bit 1 */
-
-#define  FSMC_PCR2_ECCEN                     ((u32)0x00000040)        /* ECC computation logic enable bit */
-#define  FSMC_PCR2_ADLOW                     ((u32)0x00000100)        /* Address low bit delivery */
-
-#define  FSMC_PCR2_TCLR                      ((u32)0x00001E00)        /* TCLR[3:0] bits (CLE to RE delay) */
-#define  FSMC_PCR2_TCLR_0                    ((u32)0x00000200)        /* Bit 0 */
-#define  FSMC_PCR2_TCLR_1                    ((u32)0x00000400)        /* Bit 1 */
-#define  FSMC_PCR2_TCLR_2                    ((u32)0x00000800)        /* Bit 2 */
-#define  FSMC_PCR2_TCLR_3                    ((u32)0x00001000)        /* Bit 3 */
-
-#define  FSMC_PCR2_TAR                       ((u32)0x0001E000)        /* TAR[3:0] bits (ALE to RE delay) */
-#define  FSMC_PCR2_TAR_0                     ((u32)0x00002000)        /* Bit 0 */
-#define  FSMC_PCR2_TAR_1                     ((u32)0x00004000)        /* Bit 1 */
-#define  FSMC_PCR2_TAR_2                     ((u32)0x00008000)        /* Bit 2 */
-#define  FSMC_PCR2_TAR_3                     ((u32)0x00010000)        /* Bit 3 */
-
-#define  FSMC_PCR2_ECCPS                     ((u32)0x000E0000)        /* ECCPS[1:0] bits (ECC page size) */
-#define  FSMC_PCR2_ECCPS_0                   ((u32)0x00020000)        /* Bit 0 */
-#define  FSMC_PCR2_ECCPS_1                   ((u32)0x00040000)        /* Bit 1 */
-#define  FSMC_PCR2_ECCPS_2                   ((u32)0x00080000)        /* Bit 2 */
-
-
-/******************  Bit definition for FSMC_PCR3 register  *******************/
-#define  FSMC_PCR3_PWAITEN                   ((u32)0x00000002)        /* Wait feature enable bit */
-#define  FSMC_PCR3_PBKEN                     ((u32)0x00000004)        /* PC Card/NAND Flash memory bank enable bit */
-#define  FSMC_PCR3_PTYP                      ((u32)0x00000008)        /* Memory type */
-
-#define  FSMC_PCR3_PWID                      ((u32)0x00000030)        /* PWID[1:0] bits (NAND Flash databus width) */
-#define  FSMC_PCR3_PWID_0                    ((u32)0x00000010)        /* Bit 0 */
-#define  FSMC_PCR3_PWID_1                    ((u32)0x00000020)        /* Bit 1 */
-
-#define  FSMC_PCR3_ECCEN                     ((u32)0x00000040)        /* ECC computation logic enable bit */
-#define  FSMC_PCR3_ADLOW                     ((u32)0x00000100)        /* Address low bit delivery */
-
-#define  FSMC_PCR3_TCLR                      ((u32)0x00001E00)        /* TCLR[3:0] bits (CLE to RE delay) */
-#define  FSMC_PCR3_TCLR_0                    ((u32)0x00000200)        /* Bit 0 */
-#define  FSMC_PCR3_TCLR_1                    ((u32)0x00000400)        /* Bit 1 */
-#define  FSMC_PCR3_TCLR_2                    ((u32)0x00000800)        /* Bit 2 */
-#define  FSMC_PCR3_TCLR_3                    ((u32)0x00001000)        /* Bit 3 */
-
-#define  FSMC_PCR3_TAR                       ((u32)0x0001E000)        /* TAR[3:0] bits (ALE to RE delay) */
-#define  FSMC_PCR3_TAR_0                     ((u32)0x00002000)        /* Bit 0 */
-#define  FSMC_PCR3_TAR_1                     ((u32)0x00004000)        /* Bit 1 */
-#define  FSMC_PCR3_TAR_2                     ((u32)0x00008000)        /* Bit 2 */
-#define  FSMC_PCR3_TAR_3                     ((u32)0x00010000)        /* Bit 3 */
-
-#define  FSMC_PCR3_ECCPS                     ((u32)0x000E0000)        /* ECCPS[2:0] bits (ECC page size) */
-#define  FSMC_PCR3_ECCPS_0                   ((u32)0x00020000)        /* Bit 0 */
-#define  FSMC_PCR3_ECCPS_1                   ((u32)0x00040000)        /* Bit 1 */
-#define  FSMC_PCR3_ECCPS_2                   ((u32)0x00080000)        /* Bit 2 */
-
-
-/******************  Bit definition for FSMC_PCR4 register  *******************/
-#define  FSMC_PCR4_PWAITEN                   ((u32)0x00000002)        /* Wait feature enable bit */
-#define  FSMC_PCR4_PBKEN                     ((u32)0x00000004)        /* PC Card/NAND Flash memory bank enable bit */
-#define  FSMC_PCR4_PTYP                      ((u32)0x00000008)        /* Memory type */
-
-#define  FSMC_PCR4_PWID                      ((u32)0x00000030)        /* PWID[1:0] bits (NAND Flash databus width) */
-#define  FSMC_PCR4_PWID_0                    ((u32)0x00000010)        /* Bit 0 */
-#define  FSMC_PCR4_PWID_1                    ((u32)0x00000020)        /* Bit 1 */
-
-#define  FSMC_PCR4_ECCEN                     ((u32)0x00000040)        /* ECC computation logic enable bit */
-#define  FSMC_PCR4_ADLOW                     ((u32)0x00000100)        /* Address low bit delivery */
-
-#define  FSMC_PCR4_TCLR                      ((u32)0x00001E00)        /* TCLR[3:0] bits (CLE to RE delay) */
-#define  FSMC_PCR4_TCLR_0                    ((u32)0x00000200)        /* Bit 0 */
-#define  FSMC_PCR4_TCLR_1                    ((u32)0x00000400)        /* Bit 1 */
-#define  FSMC_PCR4_TCLR_2                    ((u32)0x00000800)        /* Bit 2 */
-#define  FSMC_PCR4_TCLR_3                    ((u32)0x00001000)        /* Bit 3 */
-
-#define  FSMC_PCR4_TAR                       ((u32)0x0001E000)        /* TAR[3:0] bits (ALE to RE delay) */
-#define  FSMC_PCR4_TAR_0                     ((u32)0x00002000)        /* Bit 0 */
-#define  FSMC_PCR4_TAR_1                     ((u32)0x00004000)        /* Bit 1 */
-#define  FSMC_PCR4_TAR_2                     ((u32)0x00008000)        /* Bit 2 */
-#define  FSMC_PCR4_TAR_3                     ((u32)0x00010000)        /* Bit 3 */
-
-#define  FSMC_PCR4_ECCPS                     ((u32)0x000E0000)        /* ECCPS[2:0] bits (ECC page size) */
-#define  FSMC_PCR4_ECCPS_0                   ((u32)0x00020000)        /* Bit 0 */
-#define  FSMC_PCR4_ECCPS_1                   ((u32)0x00040000)        /* Bit 1 */
-#define  FSMC_PCR4_ECCPS_2                   ((u32)0x00080000)        /* Bit 2 */
-
-
-/*******************  Bit definition for FSMC_SR2 register  *******************/
-#define  FSMC_SR2_IRS                        ((u8)0x01)               /* Interrupt Rising Edge status */
-#define  FSMC_SR2_ILS                        ((u8)0x02)               /* Interrupt Level status */
-#define  FSMC_SR2_IFS                        ((u8)0x04)               /* Interrupt Falling Edge status */
-#define  FSMC_SR2_IREN                       ((u8)0x08)               /* Interrupt Rising Edge detection Enable bit */
-#define  FSMC_SR2_ILEN                       ((u8)0x10)               /* Interrupt Level detection Enable bit */
-#define  FSMC_SR2_IFEN                       ((u8)0x20)               /* Interrupt Falling Edge detection Enable bit */
-#define  FSMC_SR2_FEMPT                      ((u8)0x40)               /* FIFO empty */
-
-
-/*******************  Bit definition for FSMC_SR3 register  *******************/
-#define  FSMC_SR3_IRS                        ((u8)0x01)               /* Interrupt Rising Edge status */
-#define  FSMC_SR3_ILS                        ((u8)0x02)               /* Interrupt Level status */
-#define  FSMC_SR3_IFS                        ((u8)0x04)               /* Interrupt Falling Edge status */
-#define  FSMC_SR3_IREN                       ((u8)0x08)               /* Interrupt Rising Edge detection Enable bit */
-#define  FSMC_SR3_ILEN                       ((u8)0x10)               /* Interrupt Level detection Enable bit */
-#define  FSMC_SR3_IFEN                       ((u8)0x20)               /* Interrupt Falling Edge detection Enable bit */
-#define  FSMC_SR3_FEMPT                      ((u8)0x40)               /* FIFO empty */
-
-
-/*******************  Bit definition for FSMC_SR4 register  *******************/
-#define  FSMC_SR4_IRS                        ((u8)0x01)               /* Interrupt Rising Edge status */
-#define  FSMC_SR4_ILS                        ((u8)0x02)               /* Interrupt Level status */
-#define  FSMC_SR4_IFS                        ((u8)0x04)               /* Interrupt Falling Edge status */
-#define  FSMC_SR4_IREN                       ((u8)0x08)               /* Interrupt Rising Edge detection Enable bit */
-#define  FSMC_SR4_ILEN                       ((u8)0x10)               /* Interrupt Level detection Enable bit */
-#define  FSMC_SR4_IFEN                       ((u8)0x20)               /* Interrupt Falling Edge detection Enable bit */
-#define  FSMC_SR4_FEMPT                      ((u8)0x40)               /* FIFO empty */
-
-
-/******************  Bit definition for FSMC_PMEM2 register  ******************/
-#define  FSMC_PMEM2_MEMSET2                  ((u32)0x000000FF)        /* MEMSET2[7:0] bits (Common memory 2 setup time) */
-#define  FSMC_PMEM2_MEMSET2_0                ((u32)0x00000001)        /* Bit 0 */
-#define  FSMC_PMEM2_MEMSET2_1                ((u32)0x00000002)        /* Bit 1 */
-#define  FSMC_PMEM2_MEMSET2_2                ((u32)0x00000004)        /* Bit 2 */
-#define  FSMC_PMEM2_MEMSET2_3                ((u32)0x00000008)        /* Bit 3 */
-#define  FSMC_PMEM2_MEMSET2_4                ((u32)0x00000010)        /* Bit 4 */
-#define  FSMC_PMEM2_MEMSET2_5                ((u32)0x00000020)        /* Bit 5 */
-#define  FSMC_PMEM2_MEMSET2_6                ((u32)0x00000040)        /* Bit 6 */
-#define  FSMC_PMEM2_MEMSET2_7                ((u32)0x00000080)        /* Bit 7 */
-
-#define  FSMC_PMEM2_MEMWAIT2                 ((u32)0x0000FF00)        /* MEMWAIT2[7:0] bits (Common memory 2 wait time) */
-#define  FSMC_PMEM2_MEMWAIT2_0               ((u32)0x00000100)        /* Bit 0 */
-#define  FSMC_PMEM2_MEMWAIT2_1               ((u32)0x00000200)        /* Bit 1 */
-#define  FSMC_PMEM2_MEMWAIT2_2               ((u32)0x00000400)        /* Bit 2 */
-#define  FSMC_PMEM2_MEMWAIT2_3               ((u32)0x00000800)        /* Bit 3 */
-#define  FSMC_PMEM2_MEMWAIT2_4               ((u32)0x00001000)        /* Bit 4 */
-#define  FSMC_PMEM2_MEMWAIT2_5               ((u32)0x00002000)        /* Bit 5 */
-#define  FSMC_PMEM2_MEMWAIT2_6               ((u32)0x00004000)        /* Bit 6 */
-#define  FSMC_PMEM2_MEMWAIT2_7               ((u32)0x00008000)        /* Bit 7 */
-
-#define  FSMC_PMEM2_MEMHOLD2                 ((u32)0x00FF0000)        /* MEMHOLD2[7:0] bits (Common memory 2 hold time) */
-#define  FSMC_PMEM2_MEMHOLD2_0               ((u32)0x00010000)        /* Bit 0 */
-#define  FSMC_PMEM2_MEMHOLD2_1               ((u32)0x00020000)        /* Bit 1 */
-#define  FSMC_PMEM2_MEMHOLD2_2               ((u32)0x00040000)        /* Bit 2 */
-#define  FSMC_PMEM2_MEMHOLD2_3               ((u32)0x00080000)        /* Bit 3 */
-#define  FSMC_PMEM2_MEMHOLD2_4               ((u32)0x00100000)        /* Bit 4 */
-#define  FSMC_PMEM2_MEMHOLD2_5               ((u32)0x00200000)        /* Bit 5 */
-#define  FSMC_PMEM2_MEMHOLD2_6               ((u32)0x00400000)        /* Bit 6 */
-#define  FSMC_PMEM2_MEMHOLD2_7               ((u32)0x00800000)        /* Bit 7 */
-
-#define  FSMC_PMEM2_MEMHIZ2                  ((u32)0xFF000000)        /* MEMHIZ2[7:0] bits (Common memory 2 databus HiZ time) */
-#define  FSMC_PMEM2_MEMHIZ2_0                ((u32)0x01000000)        /* Bit 0 */
-#define  FSMC_PMEM2_MEMHIZ2_1                ((u32)0x02000000)        /* Bit 1 */
-#define  FSMC_PMEM2_MEMHIZ2_2                ((u32)0x04000000)        /* Bit 2 */
-#define  FSMC_PMEM2_MEMHIZ2_3                ((u32)0x08000000)        /* Bit 3 */
-#define  FSMC_PMEM2_MEMHIZ2_4                ((u32)0x10000000)        /* Bit 4 */
-#define  FSMC_PMEM2_MEMHIZ2_5                ((u32)0x20000000)        /* Bit 5 */
-#define  FSMC_PMEM2_MEMHIZ2_6                ((u32)0x40000000)        /* Bit 6 */
-#define  FSMC_PMEM2_MEMHIZ2_7                ((u32)0x80000000)        /* Bit 7 */
-
-
-/******************  Bit definition for FSMC_PMEM3 register  ******************/
-#define  FSMC_PMEM3_MEMSET3                  ((u32)0x000000FF)        /* MEMSET3[7:0] bits (Common memory 3 setup time) */
-#define  FSMC_PMEM3_MEMSET3_0                ((u32)0x00000001)        /* Bit 0 */
-#define  FSMC_PMEM3_MEMSET3_1                ((u32)0x00000002)        /* Bit 1 */
-#define  FSMC_PMEM3_MEMSET3_2                ((u32)0x00000004)        /* Bit 2 */
-#define  FSMC_PMEM3_MEMSET3_3                ((u32)0x00000008)        /* Bit 3 */
-#define  FSMC_PMEM3_MEMSET3_4                ((u32)0x00000010)        /* Bit 4 */
-#define  FSMC_PMEM3_MEMSET3_5                ((u32)0x00000020)        /* Bit 5 */
-#define  FSMC_PMEM3_MEMSET3_6                ((u32)0x00000040)        /* Bit 6 */
-#define  FSMC_PMEM3_MEMSET3_7                ((u32)0x00000080)        /* Bit 7 */
-
-#define  FSMC_PMEM3_MEMWAIT3                 ((u32)0x0000FF00)        /* MEMWAIT3[7:0] bits (Common memory 3 wait time) */
-#define  FSMC_PMEM3_MEMWAIT3_0               ((u32)0x00000100)        /* Bit 0 */
-#define  FSMC_PMEM3_MEMWAIT3_1               ((u32)0x00000200)        /* Bit 1 */
-#define  FSMC_PMEM3_MEMWAIT3_2               ((u32)0x00000400)        /* Bit 2 */
-#define  FSMC_PMEM3_MEMWAIT3_3               ((u32)0x00000800)        /* Bit 3 */
-#define  FSMC_PMEM3_MEMWAIT3_4               ((u32)0x00001000)        /* Bit 4 */
-#define  FSMC_PMEM3_MEMWAIT3_5               ((u32)0x00002000)        /* Bit 5 */
-#define  FSMC_PMEM3_MEMWAIT3_6               ((u32)0x00004000)        /* Bit 6 */
-#define  FSMC_PMEM3_MEMWAIT3_7               ((u32)0x00008000)        /* Bit 7 */
-
-#define  FSMC_PMEM3_MEMHOLD3                 ((u32)0x00FF0000)        /* MEMHOLD3[7:0] bits (Common memory 3 hold time) */
-#define  FSMC_PMEM3_MEMHOLD3_0               ((u32)0x00010000)        /* Bit 0 */
-#define  FSMC_PMEM3_MEMHOLD3_1               ((u32)0x00020000)        /* Bit 1 */
-#define  FSMC_PMEM3_MEMHOLD3_2               ((u32)0x00040000)        /* Bit 2 */
-#define  FSMC_PMEM3_MEMHOLD3_3               ((u32)0x00080000)        /* Bit 3 */
-#define  FSMC_PMEM3_MEMHOLD3_4               ((u32)0x00100000)        /* Bit 4 */
-#define  FSMC_PMEM3_MEMHOLD3_5               ((u32)0x00200000)        /* Bit 5 */
-#define  FSMC_PMEM3_MEMHOLD3_6               ((u32)0x00400000)        /* Bit 6 */
-#define  FSMC_PMEM3_MEMHOLD3_7               ((u32)0x00800000)        /* Bit 7 */
-
-#define  FSMC_PMEM3_MEMHIZ3                  ((u32)0xFF000000)        /* MEMHIZ3[7:0] bits (Common memory 3 databus HiZ time) */
-#define  FSMC_PMEM3_MEMHIZ3_0                ((u32)0x01000000)        /* Bit 0 */
-#define  FSMC_PMEM3_MEMHIZ3_1                ((u32)0x02000000)        /* Bit 1 */
-#define  FSMC_PMEM3_MEMHIZ3_2                ((u32)0x04000000)        /* Bit 2 */
-#define  FSMC_PMEM3_MEMHIZ3_3                ((u32)0x08000000)        /* Bit 3 */
-#define  FSMC_PMEM3_MEMHIZ3_4                ((u32)0x10000000)        /* Bit 4 */
-#define  FSMC_PMEM3_MEMHIZ3_5                ((u32)0x20000000)        /* Bit 5 */
-#define  FSMC_PMEM3_MEMHIZ3_6                ((u32)0x40000000)        /* Bit 6 */
-#define  FSMC_PMEM3_MEMHIZ3_7                ((u32)0x80000000)        /* Bit 7 */
-
-
-/******************  Bit definition for FSMC_PMEM4 register  ******************/
-#define  FSMC_PMEM4_MEMSET4                  ((u32)0x000000FF)        /* MEMSET4[7:0] bits (Common memory 4 setup time) */
-#define  FSMC_PMEM4_MEMSET4_0                ((u32)0x00000001)        /* Bit 0 */
-#define  FSMC_PMEM4_MEMSET4_1                ((u32)0x00000002)        /* Bit 1 */
-#define  FSMC_PMEM4_MEMSET4_2                ((u32)0x00000004)        /* Bit 2 */
-#define  FSMC_PMEM4_MEMSET4_3                ((u32)0x00000008)        /* Bit 3 */
-#define  FSMC_PMEM4_MEMSET4_4                ((u32)0x00000010)        /* Bit 4 */
-#define  FSMC_PMEM4_MEMSET4_5                ((u32)0x00000020)        /* Bit 5 */
-#define  FSMC_PMEM4_MEMSET4_6                ((u32)0x00000040)        /* Bit 6 */
-#define  FSMC_PMEM4_MEMSET4_7                ((u32)0x00000080)        /* Bit 7 */
-
-#define  FSMC_PMEM4_MEMWAIT4                 ((u32)0x0000FF00)        /* MEMWAIT4[7:0] bits (Common memory 4 wait time) */
-#define  FSMC_PMEM4_MEMWAIT4_0               ((u32)0x00000100)        /* Bit 0 */
-#define  FSMC_PMEM4_MEMWAIT4_1               ((u32)0x00000200)        /* Bit 1 */
-#define  FSMC_PMEM4_MEMWAIT4_2               ((u32)0x00000400)        /* Bit 2 */
-#define  FSMC_PMEM4_MEMWAIT4_3               ((u32)0x00000800)        /* Bit 3 */
-#define  FSMC_PMEM4_MEMWAIT4_4               ((u32)0x00001000)        /* Bit 4 */
-#define  FSMC_PMEM4_MEMWAIT4_5               ((u32)0x00002000)        /* Bit 5 */
-#define  FSMC_PMEM4_MEMWAIT4_6               ((u32)0x00004000)        /* Bit 6 */
-#define  FSMC_PMEM4_MEMWAIT4_7               ((u32)0x00008000)        /* Bit 7 */
-
-#define  FSMC_PMEM4_MEMHOLD4                 ((u32)0x00FF0000)        /* MEMHOLD4[7:0] bits (Common memory 4 hold time) */
-#define  FSMC_PMEM4_MEMHOLD4_0               ((u32)0x00010000)        /* Bit 0 */
-#define  FSMC_PMEM4_MEMHOLD4_1               ((u32)0x00020000)        /* Bit 1 */
-#define  FSMC_PMEM4_MEMHOLD4_2               ((u32)0x00040000)        /* Bit 2 */
-#define  FSMC_PMEM4_MEMHOLD4_3               ((u32)0x00080000)        /* Bit 3 */
-#define  FSMC_PMEM4_MEMHOLD4_4               ((u32)0x00100000)        /* Bit 4 */
-#define  FSMC_PMEM4_MEMHOLD4_5               ((u32)0x00200000)        /* Bit 5 */
-#define  FSMC_PMEM4_MEMHOLD4_6               ((u32)0x00400000)        /* Bit 6 */
-#define  FSMC_PMEM4_MEMHOLD4_7               ((u32)0x00800000)        /* Bit 7 */
-
-#define  FSMC_PMEM4_MEMHIZ4                  ((u32)0xFF000000)        /* MEMHIZ4[7:0] bits (Common memory 4 databus HiZ time) */
-#define  FSMC_PMEM4_MEMHIZ4_0                ((u32)0x01000000)        /* Bit 0 */
-#define  FSMC_PMEM4_MEMHIZ4_1                ((u32)0x02000000)        /* Bit 1 */
-#define  FSMC_PMEM4_MEMHIZ4_2                ((u32)0x04000000)        /* Bit 2 */
-#define  FSMC_PMEM4_MEMHIZ4_3                ((u32)0x08000000)        /* Bit 3 */
-#define  FSMC_PMEM4_MEMHIZ4_4                ((u32)0x10000000)        /* Bit 4 */
-#define  FSMC_PMEM4_MEMHIZ4_5                ((u32)0x20000000)        /* Bit 5 */
-#define  FSMC_PMEM4_MEMHIZ4_6                ((u32)0x40000000)        /* Bit 6 */
-#define  FSMC_PMEM4_MEMHIZ4_7                ((u32)0x80000000)        /* Bit 7 */
-
-
-/******************  Bit definition for FSMC_PATT2 register  ******************/
-#define  FSMC_PATT2_ATTSET2                  ((u32)0x000000FF)        /* ATTSET2[7:0] bits (Attribute memory 2 setup time) */
-#define  FSMC_PATT2_ATTSET2_0                ((u32)0x00000001)        /* Bit 0 */
-#define  FSMC_PATT2_ATTSET2_1                ((u32)0x00000002)        /* Bit 1 */
-#define  FSMC_PATT2_ATTSET2_2                ((u32)0x00000004)        /* Bit 2 */
-#define  FSMC_PATT2_ATTSET2_3                ((u32)0x00000008)        /* Bit 3 */
-#define  FSMC_PATT2_ATTSET2_4                ((u32)0x00000010)        /* Bit 4 */
-#define  FSMC_PATT2_ATTSET2_5                ((u32)0x00000020)        /* Bit 5 */
-#define  FSMC_PATT2_ATTSET2_6                ((u32)0x00000040)        /* Bit 6 */
-#define  FSMC_PATT2_ATTSET2_7                ((u32)0x00000080)        /* Bit 7 */
-
-#define  FSMC_PATT2_ATTWAIT2                 ((u32)0x0000FF00)        /* ATTWAIT2[7:0] bits (Attribute memory 2 wait time) */
-#define  FSMC_PATT2_ATTWAIT2_0               ((u32)0x00000100)        /* Bit 0 */
-#define  FSMC_PATT2_ATTWAIT2_1               ((u32)0x00000200)        /* Bit 1 */
-#define  FSMC_PATT2_ATTWAIT2_2               ((u32)0x00000400)        /* Bit 2 */
-#define  FSMC_PATT2_ATTWAIT2_3               ((u32)0x00000800)        /* Bit 3 */
-#define  FSMC_PATT2_ATTWAIT2_4               ((u32)0x00001000)        /* Bit 4 */
-#define  FSMC_PATT2_ATTWAIT2_5               ((u32)0x00002000)        /* Bit 5 */
-#define  FSMC_PATT2_ATTWAIT2_6               ((u32)0x00004000)        /* Bit 6 */
-#define  FSMC_PATT2_ATTWAIT2_7               ((u32)0x00008000)        /* Bit 7 */
-
-#define  FSMC_PATT2_ATTHOLD2                 ((u32)0x00FF0000)        /* ATTHOLD2[7:0] bits (Attribute memory 2 hold time) */
-#define  FSMC_PATT2_ATTHOLD2_0               ((u32)0x00010000)        /* Bit 0 */
-#define  FSMC_PATT2_ATTHOLD2_1               ((u32)0x00020000)        /* Bit 1 */
-#define  FSMC_PATT2_ATTHOLD2_2               ((u32)0x00040000)        /* Bit 2 */
-#define  FSMC_PATT2_ATTHOLD2_3               ((u32)0x00080000)        /* Bit 3 */
-#define  FSMC_PATT2_ATTHOLD2_4               ((u32)0x00100000)        /* Bit 4 */
-#define  FSMC_PATT2_ATTHOLD2_5               ((u32)0x00200000)        /* Bit 5 */
-#define  FSMC_PATT2_ATTHOLD2_6               ((u32)0x00400000)        /* Bit 6 */
-#define  FSMC_PATT2_ATTHOLD2_7               ((u32)0x00800000)        /* Bit 7 */
-
-#define  FSMC_PATT2_ATTHIZ2                  ((u32)0xFF000000)        /* ATTHIZ2[7:0] bits (Attribute memory 2 databus HiZ time) */
-#define  FSMC_PATT2_ATTHIZ2_0                ((u32)0x01000000)        /* Bit 0 */
-#define  FSMC_PATT2_ATTHIZ2_1                ((u32)0x02000000)        /* Bit 1 */
-#define  FSMC_PATT2_ATTHIZ2_2                ((u32)0x04000000)        /* Bit 2 */
-#define  FSMC_PATT2_ATTHIZ2_3                ((u32)0x08000000)        /* Bit 3 */
-#define  FSMC_PATT2_ATTHIZ2_4                ((u32)0x10000000)        /* Bit 4 */
-#define  FSMC_PATT2_ATTHIZ2_5                ((u32)0x20000000)        /* Bit 5 */
-#define  FSMC_PATT2_ATTHIZ2_6                ((u32)0x40000000)        /* Bit 6 */
-#define  FSMC_PATT2_ATTHIZ2_7                ((u32)0x80000000)        /* Bit 7 */
-
-
-/******************  Bit definition for FSMC_PATT3 register  ******************/
-#define  FSMC_PATT3_ATTSET3                  ((u32)0x000000FF)        /* ATTSET3[7:0] bits (Attribute memory 3 setup time) */
-#define  FSMC_PATT3_ATTSET3_0                ((u32)0x00000001)        /* Bit 0 */
-#define  FSMC_PATT3_ATTSET3_1                ((u32)0x00000002)        /* Bit 1 */
-#define  FSMC_PATT3_ATTSET3_2                ((u32)0x00000004)        /* Bit 2 */
-#define  FSMC_PATT3_ATTSET3_3                ((u32)0x00000008)        /* Bit 3 */
-#define  FSMC_PATT3_ATTSET3_4                ((u32)0x00000010)        /* Bit 4 */
-#define  FSMC_PATT3_ATTSET3_5                ((u32)0x00000020)        /* Bit 5 */
-#define  FSMC_PATT3_ATTSET3_6                ((u32)0x00000040)        /* Bit 6 */
-#define  FSMC_PATT3_ATTSET3_7                ((u32)0x00000080)        /* Bit 7 */
-
-#define  FSMC_PATT3_ATTWAIT3                 ((u32)0x0000FF00)        /* ATTWAIT3[7:0] bits (Attribute memory 3 wait time) */
-#define  FSMC_PATT3_ATTWAIT3_0               ((u32)0x00000100)        /* Bit 0 */
-#define  FSMC_PATT3_ATTWAIT3_1               ((u32)0x00000200)        /* Bit 1 */
-#define  FSMC_PATT3_ATTWAIT3_2               ((u32)0x00000400)        /* Bit 2 */
-#define  FSMC_PATT3_ATTWAIT3_3               ((u32)0x00000800)        /* Bit 3 */
-#define  FSMC_PATT3_ATTWAIT3_4               ((u32)0x00001000)        /* Bit 4 */
-#define  FSMC_PATT3_ATTWAIT3_5               ((u32)0x00002000)        /* Bit 5 */
-#define  FSMC_PATT3_ATTWAIT3_6               ((u32)0x00004000)        /* Bit 6 */
-#define  FSMC_PATT3_ATTWAIT3_7               ((u32)0x00008000)        /* Bit 7 */
-
-#define  FSMC_PATT3_ATTHOLD3                 ((u32)0x00FF0000)        /* ATTHOLD3[7:0] bits (Attribute memory 3 hold time) */
-#define  FSMC_PATT3_ATTHOLD3_0               ((u32)0x00010000)        /* Bit 0 */
-#define  FSMC_PATT3_ATTHOLD3_1               ((u32)0x00020000)        /* Bit 1 */
-#define  FSMC_PATT3_ATTHOLD3_2               ((u32)0x00040000)        /* Bit 2 */
-#define  FSMC_PATT3_ATTHOLD3_3               ((u32)0x00080000)        /* Bit 3 */
-#define  FSMC_PATT3_ATTHOLD3_4               ((u32)0x00100000)        /* Bit 4 */
-#define  FSMC_PATT3_ATTHOLD3_5               ((u32)0x00200000)        /* Bit 5 */
-#define  FSMC_PATT3_ATTHOLD3_6               ((u32)0x00400000)        /* Bit 6 */
-#define  FSMC_PATT3_ATTHOLD3_7               ((u32)0x00800000)        /* Bit 7 */
-
-#define  FSMC_PATT3_ATTHIZ3                  ((u32)0xFF000000)        /* ATTHIZ3[7:0] bits (Attribute memory 3 databus HiZ time) */
-#define  FSMC_PATT3_ATTHIZ3_0                ((u32)0x01000000)        /* Bit 0 */
-#define  FSMC_PATT3_ATTHIZ3_1                ((u32)0x02000000)        /* Bit 1 */
-#define  FSMC_PATT3_ATTHIZ3_2                ((u32)0x04000000)        /* Bit 2 */
-#define  FSMC_PATT3_ATTHIZ3_3                ((u32)0x08000000)        /* Bit 3 */
-#define  FSMC_PATT3_ATTHIZ3_4                ((u32)0x10000000)        /* Bit 4 */
-#define  FSMC_PATT3_ATTHIZ3_5                ((u32)0x20000000)        /* Bit 5 */
-#define  FSMC_PATT3_ATTHIZ3_6                ((u32)0x40000000)        /* Bit 6 */
-#define  FSMC_PATT3_ATTHIZ3_7                ((u32)0x80000000)        /* Bit 7 */
-
-
-/******************  Bit definition for FSMC_PATT4 register  ******************/
-#define  FSMC_PATT4_ATTSET4                  ((u32)0x000000FF)        /* ATTSET4[7:0] bits (Attribute memory 4 setup time) */
-#define  FSMC_PATT4_ATTSET4_0                ((u32)0x00000001)        /* Bit 0 */
-#define  FSMC_PATT4_ATTSET4_1                ((u32)0x00000002)        /* Bit 1 */
-#define  FSMC_PATT4_ATTSET4_2                ((u32)0x00000004)        /* Bit 2 */
-#define  FSMC_PATT4_ATTSET4_3                ((u32)0x00000008)        /* Bit 3 */
-#define  FSMC_PATT4_ATTSET4_4                ((u32)0x00000010)        /* Bit 4 */
-#define  FSMC_PATT4_ATTSET4_5                ((u32)0x00000020)        /* Bit 5 */
-#define  FSMC_PATT4_ATTSET4_6                ((u32)0x00000040)        /* Bit 6 */
-#define  FSMC_PATT4_ATTSET4_7                ((u32)0x00000080)        /* Bit 7 */
-
-#define  FSMC_PATT4_ATTWAIT4                 ((u32)0x0000FF00)        /* ATTWAIT4[7:0] bits (Attribute memory 4 wait time) */
-#define  FSMC_PATT4_ATTWAIT4_0               ((u32)0x00000100)        /* Bit 0 */
-#define  FSMC_PATT4_ATTWAIT4_1               ((u32)0x00000200)        /* Bit 1 */
-#define  FSMC_PATT4_ATTWAIT4_2               ((u32)0x00000400)        /* Bit 2 */
-#define  FSMC_PATT4_ATTWAIT4_3               ((u32)0x00000800)        /* Bit 3 */
-#define  FSMC_PATT4_ATTWAIT4_4               ((u32)0x00001000)        /* Bit 4 */
-#define  FSMC_PATT4_ATTWAIT4_5               ((u32)0x00002000)        /* Bit 5 */
-#define  FSMC_PATT4_ATTWAIT4_6               ((u32)0x00004000)        /* Bit 6 */
-#define  FSMC_PATT4_ATTWAIT4_7               ((u32)0x00008000)        /* Bit 7 */
-
-#define  FSMC_PATT4_ATTHOLD4                 ((u32)0x00FF0000)        /* ATTHOLD4[7:0] bits (Attribute memory 4 hold time) */
-#define  FSMC_PATT4_ATTHOLD4_0               ((u32)0x00010000)        /* Bit 0 */
-#define  FSMC_PATT4_ATTHOLD4_1               ((u32)0x00020000)        /* Bit 1 */
-#define  FSMC_PATT4_ATTHOLD4_2               ((u32)0x00040000)        /* Bit 2 */
-#define  FSMC_PATT4_ATTHOLD4_3               ((u32)0x00080000)        /* Bit 3 */
-#define  FSMC_PATT4_ATTHOLD4_4               ((u32)0x00100000)        /* Bit 4 */
-#define  FSMC_PATT4_ATTHOLD4_5               ((u32)0x00200000)        /* Bit 5 */
-#define  FSMC_PATT4_ATTHOLD4_6               ((u32)0x00400000)        /* Bit 6 */
-#define  FSMC_PATT4_ATTHOLD4_7               ((u32)0x00800000)        /* Bit 7 */
-
-#define  FSMC_PATT4_ATTHIZ4                  ((u32)0xFF000000)        /* ATTHIZ4[7:0] bits (Attribute memory 4 databus HiZ time) */
-#define  FSMC_PATT4_ATTHIZ4_0                ((u32)0x01000000)        /* Bit 0 */
-#define  FSMC_PATT4_ATTHIZ4_1                ((u32)0x02000000)        /* Bit 1 */
-#define  FSMC_PATT4_ATTHIZ4_2                ((u32)0x04000000)        /* Bit 2 */
-#define  FSMC_PATT4_ATTHIZ4_3                ((u32)0x08000000)        /* Bit 3 */
-#define  FSMC_PATT4_ATTHIZ4_4                ((u32)0x10000000)        /* Bit 4 */
-#define  FSMC_PATT4_ATTHIZ4_5                ((u32)0x20000000)        /* Bit 5 */
-#define  FSMC_PATT4_ATTHIZ4_6                ((u32)0x40000000)        /* Bit 6 */
-#define  FSMC_PATT4_ATTHIZ4_7                ((u32)0x80000000)        /* Bit 7 */
-
-
-/******************  Bit definition for FSMC_PIO4 register  *******************/
-#define  FSMC_PIO4_IOSET4                    ((u32)0x000000FF)        /* IOSET4[7:0] bits (I/O 4 setup time) */
-#define  FSMC_PIO4_IOSET4_0                  ((u32)0x00000001)        /* Bit 0 */
-#define  FSMC_PIO4_IOSET4_1                  ((u32)0x00000002)        /* Bit 1 */
-#define  FSMC_PIO4_IOSET4_2                  ((u32)0x00000004)        /* Bit 2 */
-#define  FSMC_PIO4_IOSET4_3                  ((u32)0x00000008)        /* Bit 3 */
-#define  FSMC_PIO4_IOSET4_4                  ((u32)0x00000010)        /* Bit 4 */
-#define  FSMC_PIO4_IOSET4_5                  ((u32)0x00000020)        /* Bit 5 */
-#define  FSMC_PIO4_IOSET4_6                  ((u32)0x00000040)        /* Bit 6 */
-#define  FSMC_PIO4_IOSET4_7                  ((u32)0x00000080)        /* Bit 7 */
-
-#define  FSMC_PIO4_IOWAIT4                   ((u32)0x0000FF00)        /* IOWAIT4[7:0] bits (I/O 4 wait time) */
-#define  FSMC_PIO4_IOWAIT4_0                 ((u32)0x00000100)        /* Bit 0 */
-#define  FSMC_PIO4_IOWAIT4_1                 ((u32)0x00000200)        /* Bit 1 */
-#define  FSMC_PIO4_IOWAIT4_2                 ((u32)0x00000400)        /* Bit 2 */
-#define  FSMC_PIO4_IOWAIT4_3                 ((u32)0x00000800)        /* Bit 3 */
-#define  FSMC_PIO4_IOWAIT4_4                 ((u32)0x00001000)        /* Bit 4 */
-#define  FSMC_PIO4_IOWAIT4_5                 ((u32)0x00002000)        /* Bit 5 */
-#define  FSMC_PIO4_IOWAIT4_6                 ((u32)0x00004000)        /* Bit 6 */
-#define  FSMC_PIO4_IOWAIT4_7                 ((u32)0x00008000)        /* Bit 7 */
-
-#define  FSMC_PIO4_IOHOLD4                   ((u32)0x00FF0000)        /* IOHOLD4[7:0] bits (I/O 4 hold time) */
-#define  FSMC_PIO4_IOHOLD4_0                 ((u32)0x00010000)        /* Bit 0 */
-#define  FSMC_PIO4_IOHOLD4_1                 ((u32)0x00020000)        /* Bit 1 */
-#define  FSMC_PIO4_IOHOLD4_2                 ((u32)0x00040000)        /* Bit 2 */
-#define  FSMC_PIO4_IOHOLD4_3                 ((u32)0x00080000)        /* Bit 3 */
-#define  FSMC_PIO4_IOHOLD4_4                 ((u32)0x00100000)        /* Bit 4 */
-#define  FSMC_PIO4_IOHOLD4_5                 ((u32)0x00200000)        /* Bit 5 */
-#define  FSMC_PIO4_IOHOLD4_6                 ((u32)0x00400000)        /* Bit 6 */
-#define  FSMC_PIO4_IOHOLD4_7                 ((u32)0x00800000)        /* Bit 7 */
-
-#define  FSMC_PIO4_IOHIZ4                    ((u32)0xFF000000)        /* IOHIZ4[7:0] bits (I/O 4 databus HiZ time) */
-#define  FSMC_PIO4_IOHIZ4_0                  ((u32)0x01000000)        /* Bit 0 */
-#define  FSMC_PIO4_IOHIZ4_1                  ((u32)0x02000000)        /* Bit 1 */
-#define  FSMC_PIO4_IOHIZ4_2                  ((u32)0x04000000)        /* Bit 2 */
-#define  FSMC_PIO4_IOHIZ4_3                  ((u32)0x08000000)        /* Bit 3 */
-#define  FSMC_PIO4_IOHIZ4_4                  ((u32)0x10000000)        /* Bit 4 */
-#define  FSMC_PIO4_IOHIZ4_5                  ((u32)0x20000000)        /* Bit 5 */
-#define  FSMC_PIO4_IOHIZ4_6                  ((u32)0x40000000)        /* Bit 6 */
-#define  FSMC_PIO4_IOHIZ4_7                  ((u32)0x80000000)        /* Bit 7 */
-
-
-/******************  Bit definition for FSMC_ECCR2 register  ******************/
-#define  FSMC_ECCR2_ECC2                     ((u32)0xFFFFFFFF)        /* ECC result */
-
-/******************  Bit definition for FSMC_ECCR3 register  ******************/
-#define  FSMC_ECCR3_ECC3                     ((u32)0xFFFFFFFF)        /* ECC result */
-
-
-
-/******************************************************************************/
-/*                                                                            */
-/*                           SD host Interface                                */
-/*                                                                            */
-/******************************************************************************/
-
-/******************  Bit definition for SDIO_POWER register  ******************/
-#define  SDIO_POWER_PWRCTRL                  ((u8)0x03)               /* PWRCTRL[1:0] bits (Power supply control bits) */
-#define  SDIO_POWER_PWRCTRL_0                ((u8)0x01)               /* Bit 0 */
-#define  SDIO_POWER_PWRCTRL_1                ((u8)0x02)               /* Bit 1 */
-
-
-/******************  Bit definition for SDIO_CLKCR register  ******************/
-#define  SDIO_CLKCR_CLKDIV                   ((u16)0x00FF)            /* Clock divide factor */
-#define  SDIO_CLKCR_CLKEN                    ((u16)0x0100)            /* Clock enable bit */
-#define  SDIO_CLKCR_PWRSAV                   ((u16)0x0200)            /* Power saving configuration bit */
-#define  SDIO_CLKCR_BYPASS                   ((u16)0x0400)            /* Clock divider bypass enable bit */
-
-#define  SDIO_CLKCR_WIDBUS                   ((u16)0x1800)            /* WIDBUS[1:0] bits (Wide bus mode enable bit) */
-#define  SDIO_CLKCR_WIDBUS_0                 ((u16)0x0800)            /* Bit 0 */
-#define  SDIO_CLKCR_WIDBUS_1                 ((u16)0x1000)            /* Bit 1 */
-
-#define  SDIO_CLKCR_NEGEDGE                  ((u16)0x2000)            /* SDIO_CK dephasing selection bit */
-#define  SDIO_CLKCR_HWFC_EN                  ((u16)0x4000)            /* HW Flow Control enable */
-
-
-/*******************  Bit definition for SDIO_ARG register  *******************/
-#define  SDIO_ARG_CMDARG                     ((u32)0xFFFFFFFF)            /* Command argument */
-
-
-/*******************  Bit definition for SDIO_CMD register  *******************/
-#define  SDIO_CMD_CMDINDEX                   ((u16)0x003F)            /* Command Index */
-
-#define  SDIO_CMD_WAITRESP                   ((u16)0x00C0)            /* WAITRESP[1:0] bits (Wait for response bits) */
-#define  SDIO_CMD_WAITRESP_0                 ((u16)0x0040)            /*  Bit 0 */
-#define  SDIO_CMD_WAITRESP_1                 ((u16)0x0080)            /*  Bit 1 */
-
-#define  SDIO_CMD_WAITINT                    ((u16)0x0100)            /* CPSM Waits for Interrupt Request */
-#define  SDIO_CMD_WAITPEND                   ((u16)0x0200)            /* CPSM Waits for ends of data transfer (CmdPend internal signal) */
-#define  SDIO_CMD_CPSMEN                     ((u16)0x0400)            /* Command path state machine (CPSM) Enable bit */
-#define  SDIO_CMD_SDIOSUSPEND                ((u16)0x0800)            /* SD I/O suspend command */
-#define  SDIO_CMD_ENCMDCOMPL                 ((u16)0x1000)            /* Enable CMD completion */
-#define  SDIO_CMD_NIEN                       ((u16)0x2000)            /* Not Interrupt Enable */
-#define  SDIO_CMD_CEATACMD                   ((u16)0x4000)            /* CE-ATA command */
-
-
-/*****************  Bit definition for SDIO_RESPCMD register  *****************/
-#define  SDIO_RESPCMD_RESPCMD                ((u8)0x3F)               /* Response command index */
-
-
-/******************  Bit definition for SDIO_RESP0 register  ******************/
-#define  SDIO_RESP0_CARDSTATUS0              ((u32)0xFFFFFFFF)        /* Card Status */
-
-
-/******************  Bit definition for SDIO_RESP1 register  ******************/
-#define  SDIO_RESP1_CARDSTATUS1              ((u32)0xFFFFFFFF)        /* Card Status */
-
-
-/******************  Bit definition for SDIO_RESP2 register  ******************/
-#define  SDIO_RESP2_CARDSTATUS2              ((u32)0xFFFFFFFF)        /* Card Status */
-
-
-/******************  Bit definition for SDIO_RESP3 register  ******************/
-#define  SDIO_RESP3_CARDSTATUS3              ((u32)0xFFFFFFFF)        /* Card Status */
-
-
-/******************  Bit definition for SDIO_RESP4 register  ******************/
-#define  SDIO_RESP4_CARDSTATUS4              ((u32)0xFFFFFFFF)        /* Card Status */
-
-
-/******************  Bit definition for SDIO_DTIMER register  *****************/
-#define  SDIO_DTIMER_DATATIME                ((u32)0xFFFFFFFF)        /* Data timeout period. */
-
-
-/******************  Bit definition for SDIO_DLEN register  *******************/
-#define  SDIO_DLEN_DATALENGTH                ((u32)0x01FFFFFF)        /* Data length value */
-
-
-/******************  Bit definition for SDIO_DCTRL register  ******************/
-#define  SDIO_DCTRL_DTEN                     ((u16)0x0001)            /* Data transfer enabled bit */
-#define  SDIO_DCTRL_DTDIR                    ((u16)0x0002)            /* Data transfer direction selection */
-#define  SDIO_DCTRL_DTMODE                   ((u16)0x0004)            /* Data transfer mode selection */
-#define  SDIO_DCTRL_DMAEN                    ((u16)0x0008)            /* DMA enabled bit */
-
-#define  SDIO_DCTRL_DBLOCKSIZE               ((u16)0x00F0)            /* DBLOCKSIZE[3:0] bits (Data block size) */
-#define  SDIO_DCTRL_DBLOCKSIZE_0             ((u16)0x0010)            /* Bit 0 */
-#define  SDIO_DCTRL_DBLOCKSIZE_1             ((u16)0x0020)            /* Bit 1 */
-#define  SDIO_DCTRL_DBLOCKSIZE_2             ((u16)0x0040)            /* Bit 2 */
-#define  SDIO_DCTRL_DBLOCKSIZE_3             ((u16)0x0080)            /* Bit 3 */
-
-#define  SDIO_DCTRL_RWSTART                  ((u16)0x0100)            /* Read wait start */
-#define  SDIO_DCTRL_RWSTOP                   ((u16)0x0200)            /* Read wait stop */
-#define  SDIO_DCTRL_RWMOD                    ((u16)0x0400)            /* Read wait mode */
-#define  SDIO_DCTRL_SDIOEN                   ((u16)0x0800)            /* SD I/O enable functions */
-
-
-/******************  Bit definition for SDIO_DCOUNT register  *****************/
-#define  SDIO_DCOUNT_DATACOUNT               ((u32)0x01FFFFFF)        /* Data count value */
-
-
-/******************  Bit definition for SDIO_STA register  ********************/
-#define  SDIO_STA_CCRCFAIL                   ((u32)0x00000001)        /* Command response received (CRC check failed) */
-#define  SDIO_STA_DCRCFAIL                   ((u32)0x00000002)        /* Data block sent/received (CRC check failed) */
-#define  SDIO_STA_CTIMEOUT                   ((u32)0x00000004)        /* Command response timeout */
-#define  SDIO_STA_DTIMEOUT                   ((u32)0x00000008)        /* Data timeout */
-#define  SDIO_STA_TXUNDERR                   ((u32)0x00000010)        /* Transmit FIFO underrun error */
-#define  SDIO_STA_RXOVERR                    ((u32)0x00000020)        /* Received FIFO overrun error */
-#define  SDIO_STA_CMDREND                    ((u32)0x00000040)        /* Command response received (CRC check passed) */
-#define  SDIO_STA_CMDSENT                    ((u32)0x00000080)        /* Command sent (no response required) */
-#define  SDIO_STA_DATAEND                    ((u32)0x00000100)        /* Data end (data counter, SDIDCOUNT, is zero) */
-#define  SDIO_STA_STBITERR                   ((u32)0x00000200)        /* Start bit not detected on all data signals in wide bus mode */
-#define  SDIO_STA_DBCKEND                    ((u32)0x00000400)        /* Data block sent/received (CRC check passed) */
-#define  SDIO_STA_CMDACT                     ((u32)0x00000800)        /* Command transfer in progress */
-#define  SDIO_STA_TXACT                      ((u32)0x00001000)        /* Data transmit in progress */
-#define  SDIO_STA_RXACT                      ((u32)0x00002000)        /* Data receive in progress */
-#define  SDIO_STA_TXFIFOHE                   ((u32)0x00004000)        /* Transmit FIFO Half Empty: at least 8 words can be written into the FIFO */
-#define  SDIO_STA_RXFIFOHF                   ((u32)0x00008000)        /* Receive FIFO Half Full: there are at least 8 words in the FIFO */
-#define  SDIO_STA_TXFIFOF                    ((u32)0x00010000)        /* Transmit FIFO full */
-#define  SDIO_STA_RXFIFOF                    ((u32)0x00020000)        /* Receive FIFO full */
-#define  SDIO_STA_TXFIFOE                    ((u32)0x00040000)        /* Transmit FIFO empty */
-#define  SDIO_STA_RXFIFOE                    ((u32)0x00080000)        /* Receive FIFO empty */
-#define  SDIO_STA_TXDAVL                     ((u32)0x00100000)        /* Data available in transmit FIFO */
-#define  SDIO_STA_RXDAVL                     ((u32)0x00200000)        /* Data available in receive FIFO */
-#define  SDIO_STA_SDIOIT                     ((u32)0x00400000)        /* SDIO interrupt received */
-#define  SDIO_STA_CEATAEND                   ((u32)0x00800000)        /* CE-ATA command completion signal received for CMD61 */
-
-
-/*******************  Bit definition for SDIO_ICR register  *******************/
-#define  SDIO_ICR_CCRCFAILC                  ((u32)0x00000001)        /* CCRCFAIL flag clear bit */
-#define  SDIO_ICR_DCRCFAILC                  ((u32)0x00000002)        /* DCRCFAIL flag clear bit */
-#define  SDIO_ICR_CTIMEOUTC                  ((u32)0x00000004)        /* CTIMEOUT flag clear bit */
-#define  SDIO_ICR_DTIMEOUTC                  ((u32)0x00000008)        /* DTIMEOUT flag clear bit */
-#define  SDIO_ICR_TXUNDERRC                  ((u32)0x00000010)        /* TXUNDERR flag clear bit */
-#define  SDIO_ICR_RXOVERRC                   ((u32)0x00000020)        /* RXOVERR flag clear bit */
-#define  SDIO_ICR_CMDRENDC                   ((u32)0x00000040)        /* CMDREND flag clear bit */
-#define  SDIO_ICR_CMDSENTC                   ((u32)0x00000080)        /* CMDSENT flag clear bit */
-#define  SDIO_ICR_DATAENDC                   ((u32)0x00000100)        /* DATAEND flag clear bit */
-#define  SDIO_ICR_STBITERRC                  ((u32)0x00000200)        /* STBITERR flag clear bit */
-#define  SDIO_ICR_DBCKENDC                   ((u32)0x00000400)        /* DBCKEND flag clear bit */
-#define  SDIO_ICR_SDIOITC                    ((u32)0x00400000)        /* SDIOIT flag clear bit */
-#define  SDIO_ICR_CEATAENDC                  ((u32)0x00800000)        /* CEATAEND flag clear bit */
-
-
-/******************  Bit definition for SDIO_MASK register  *******************/
-#define  SDIO_MASK_CCRCFAILIE                ((u32)0x00000001)        /* Command CRC Fail Interrupt Enable */
-#define  SDIO_MASK_DCRCFAILIE                ((u32)0x00000002)        /* Data CRC Fail Interrupt Enable */
-#define  SDIO_MASK_CTIMEOUTIE                ((u32)0x00000004)        /* Command TimeOut Interrupt Enable */
-#define  SDIO_MASK_DTIMEOUTIE                ((u32)0x00000008)        /* Data TimeOut Interrupt Enable */
-#define  SDIO_MASK_TXUNDERRIE                ((u32)0x00000010)        /* Tx FIFO UnderRun Error Interrupt Enable */
-#define  SDIO_MASK_RXOVERRIE                 ((u32)0x00000020)        /* Rx FIFO OverRun Error Interrupt Enable */
-#define  SDIO_MASK_CMDRENDIE                 ((u32)0x00000040)        /* Command Response Received Interrupt Enable */
-#define  SDIO_MASK_CMDSENTIE                 ((u32)0x00000080)        /* Command Sent Interrupt Enable */
-#define  SDIO_MASK_DATAENDIE                 ((u32)0x00000100)        /* Data End Interrupt Enable */
-#define  SDIO_MASK_STBITERRIE                ((u32)0x00000200)        /* Start Bit Error Interrupt Enable */
-#define  SDIO_MASK_DBCKENDIE                 ((u32)0x00000400)        /* Data Block End Interrupt Enable */
-#define  SDIO_MASK_CMDACTIE                  ((u32)0x00000800)        /* CCommand Acting Interrupt Enable */
-#define  SDIO_MASK_TXACTIE                   ((u32)0x00001000)        /* Data Transmit Acting Interrupt Enable */
-#define  SDIO_MASK_RXACTIE                   ((u32)0x00002000)        /* Data receive acting interrupt enabled */
-#define  SDIO_MASK_TXFIFOHEIE                ((u32)0x00004000)        /* Tx FIFO Half Empty interrupt Enable */
-#define  SDIO_MASK_RXFIFOHFIE                ((u32)0x00008000)        /* Rx FIFO Half Full interrupt Enable */
-#define  SDIO_MASK_TXFIFOFIE                 ((u32)0x00010000)        /* Tx FIFO Full interrupt Enable */
-#define  SDIO_MASK_RXFIFOFIE                 ((u32)0x00020000)        /* Rx FIFO Full interrupt Enable */
-#define  SDIO_MASK_TXFIFOEIE                 ((u32)0x00040000)        /* Tx FIFO Empty interrupt Enable */
-#define  SDIO_MASK_RXFIFOEIE                 ((u32)0x00080000)        /* Rx FIFO Empty interrupt Enable */
-#define  SDIO_MASK_TXDAVLIE                  ((u32)0x00100000)        /* Data available in Tx FIFO interrupt Enable */
-#define  SDIO_MASK_RXDAVLIE                  ((u32)0x00200000)        /* Data available in Rx FIFO interrupt Enable */
-#define  SDIO_MASK_SDIOITIE                  ((u32)0x00400000)        /* SDIO Mode Interrupt Received interrupt Enable */
-#define  SDIO_MASK_CEATAENDIE                ((u32)0x00800000)        /* CE-ATA command completion signal received Interrupt Enable */
-
-
-/*****************  Bit definition for SDIO_FIFOCNT register  *****************/
-#define  SDIO_FIFOCNT_FIFOCOUNT              ((u32)0x00FFFFFF)        /* Remaining number of words to be written to or read from the FIFO */
-
-
-/******************  Bit definition for SDIO_FIFO register  *******************/
-#define  SDIO_FIFO_FIFODATA                  ((u32)0xFFFFFFFF)        /* Receive and transmit FIFO data */
-
-
-
-/******************************************************************************/
-/*                                                                            */
-/*                                   USB                                      */
-/*                                                                            */
-/******************************************************************************/
-
-/* Endpoint-specific registers */
-/*******************  Bit definition for USB_EP0R register  *******************/
-#define  USB_EP0R_EA                         ((u16)0x000F)            /* Endpoint Address */
-
-#define  USB_EP0R_STAT_TX                    ((u16)0x0030)            /* STAT_TX[1:0] bits (Status bits, for transmission transfers) */
-#define  USB_EP0R_STAT_TX_0                  ((u16)0x0010)            /* Bit 0 */
-#define  USB_EP0R_STAT_TX_1                  ((u16)0x0020)            /* Bit 1 */
-
-#define  USB_EP0R_DTOG_TX                    ((u16)0x0040)            /* Data Toggle, for transmission transfers */
-#define  USB_EP0R_CTR_TX                     ((u16)0x0080)            /* Correct Transfer for transmission */
-#define  USB_EP0R_EP_KIND                    ((u16)0x0100)            /* Endpoint Kind */
-
-#define  USB_EP0R_EP_TYPE                    ((u16)0x0600)            /* EP_TYPE[1:0] bits (Endpoint type) */
-#define  USB_EP0R_EP_TYPE_0                  ((u16)0x0200)            /* Bit 0 */
-#define  USB_EP0R_EP_TYPE_1                  ((u16)0x0400)            /* Bit 1 */
-
-#define  USB_EP0R_SETUP                      ((u16)0x0800)            /* Setup transaction completed */
-
-#define  USB_EP0R_STAT_RX                    ((u16)0x3000)            /* STAT_RX[1:0] bits (Status bits, for reception transfers) */
-#define  USB_EP0R_STAT_RX_0                  ((u16)0x1000)            /* Bit 0 */
-#define  USB_EP0R_STAT_RX_1                  ((u16)0x2000)            /* Bit 1 */
-
-#define  USB_EP0R_DTOG_RX                    ((u16)0x4000)            /* Data Toggle, for reception transfers */
-#define  USB_EP0R_CTR_RX                     ((u16)0x8000)            /* Correct Transfer for reception */
-
-
-/*******************  Bit definition for USB_EP1R register  *******************/
-#define  USB_EP1R_EA                         ((u16)0x000F)            /* Endpoint Address */
-
-#define  USB_EP1R_STAT_TX                    ((u16)0x0030)            /* STAT_TX[1:0] bits (Status bits, for transmission transfers) */
-#define  USB_EP1R_STAT_TX_0                  ((u16)0x0010)            /* Bit 0 */
-#define  USB_EP1R_STAT_TX_1                  ((u16)0x0020)            /* Bit 1 */
-
-#define  USB_EP1R_DTOG_TX                    ((u16)0x0040)            /* Data Toggle, for transmission transfers */
-#define  USB_EP1R_CTR_TX                     ((u16)0x0080)            /* Correct Transfer for transmission */
-#define  USB_EP1R_EP_KIND                    ((u16)0x0100)            /* Endpoint Kind */
-
-#define  USB_EP1R_EP_TYPE                    ((u16)0x0600)            /* EP_TYPE[1:0] bits (Endpoint type) */
-#define  USB_EP1R_EP_TYPE_0                  ((u16)0x0200)            /* Bit 0 */
-#define  USB_EP1R_EP_TYPE_1                  ((u16)0x0400)            /* Bit 1 */
-
-#define  USB_EP1R_SETUP                      ((u16)0x0800)            /* Setup transaction completed */
-
-#define  USB_EP1R_STAT_RX                    ((u16)0x3000)            /* STAT_RX[1:0] bits (Status bits, for reception transfers) */
-#define  USB_EP1R_STAT_RX_0                  ((u16)0x1000)            /* Bit 0 */
-#define  USB_EP1R_STAT_RX_1                  ((u16)0x2000)            /* Bit 1 */
-
-#define  USB_EP1R_DTOG_RX                    ((u16)0x4000)            /* Data Toggle, for reception transfers */
-#define  USB_EP1R_CTR_RX                     ((u16)0x8000)            /* Correct Transfer for reception */
-
-
-/*******************  Bit definition for USB_EP2R register  *******************/
-#define  USB_EP2R_EA                         ((u16)0x000F)            /* Endpoint Address */
-
-#define  USB_EP2R_STAT_TX                    ((u16)0x0030)            /* STAT_TX[1:0] bits (Status bits, for transmission transfers) */
-#define  USB_EP2R_STAT_TX_0                  ((u16)0x0010)            /* Bit 0 */
-#define  USB_EP2R_STAT_TX_1                  ((u16)0x0020)            /* Bit 1 */
-
-#define  USB_EP2R_DTOG_TX                    ((u16)0x0040)            /* Data Toggle, for transmission transfers */
-#define  USB_EP2R_CTR_TX                     ((u16)0x0080)            /* Correct Transfer for transmission */
-#define  USB_EP2R_EP_KIND                    ((u16)0x0100)            /* Endpoint Kind */
-
-#define  USB_EP2R_EP_TYPE                    ((u16)0x0600)            /* EP_TYPE[1:0] bits (Endpoint type) */
-#define  USB_EP2R_EP_TYPE_0                  ((u16)0x0200)            /* Bit 0 */
-#define  USB_EP2R_EP_TYPE_1                  ((u16)0x0400)            /* Bit 1 */
-
-#define  USB_EP2R_SETUP                      ((u16)0x0800)            /* Setup transaction completed */
-
-#define  USB_EP2R_STAT_RX                    ((u16)0x3000)            /* STAT_RX[1:0] bits (Status bits, for reception transfers) */
-#define  USB_EP2R_STAT_RX_0                  ((u16)0x1000)            /* Bit 0 */
-#define  USB_EP2R_STAT_RX_1                  ((u16)0x2000)            /* Bit 1 */
-
-#define  USB_EP2R_DTOG_RX                    ((u16)0x4000)            /* Data Toggle, for reception transfers */
-#define  USB_EP2R_CTR_RX                     ((u16)0x8000)            /* Correct Transfer for reception */
-
-
-/*******************  Bit definition for USB_EP3R register  *******************/
-#define  USB_EP3R_EA                         ((u16)0x000F)            /* Endpoint Address */
-
-#define  USB_EP3R_STAT_TX                    ((u16)0x0030)            /* STAT_TX[1:0] bits (Status bits, for transmission transfers) */
-#define  USB_EP3R_STAT_TX_0                  ((u16)0x0010)            /* Bit 0 */
-#define  USB_EP3R_STAT_TX_1                  ((u16)0x0020)            /* Bit 1 */
-
-#define  USB_EP3R_DTOG_TX                    ((u16)0x0040)            /* Data Toggle, for transmission transfers */
-#define  USB_EP3R_CTR_TX                     ((u16)0x0080)            /* Correct Transfer for transmission */
-#define  USB_EP3R_EP_KIND                    ((u16)0x0100)            /* Endpoint Kind */
-
-#define  USB_EP3R_EP_TYPE                    ((u16)0x0600)            /* EP_TYPE[1:0] bits (Endpoint type) */
-#define  USB_EP3R_EP_TYPE_0                  ((u16)0x0200)            /* Bit 0 */
-#define  USB_EP3R_EP_TYPE_1                  ((u16)0x0400)            /* Bit 1 */
-
-#define  USB_EP3R_SETUP                      ((u16)0x0800)            /* Setup transaction completed */
-
-#define  USB_EP3R_STAT_RX                    ((u16)0x3000)            /* STAT_RX[1:0] bits (Status bits, for reception transfers) */
-#define  USB_EP3R_STAT_RX_0                  ((u16)0x1000)            /* Bit 0 */
-#define  USB_EP3R_STAT_RX_1                  ((u16)0x2000)            /* Bit 1 */
-
-#define  USB_EP3R_DTOG_RX                    ((u16)0x4000)            /* Data Toggle, for reception transfers */
-#define  USB_EP3R_CTR_RX                     ((u16)0x8000)            /* Correct Transfer for reception */
-
-
-/*******************  Bit definition for USB_EP4R register  *******************/
-#define  USB_EP4R_EA                         ((u16)0x000F)            /* Endpoint Address */
-
-#define  USB_EP4R_STAT_TX                    ((u16)0x0030)            /* STAT_TX[1:0] bits (Status bits, for transmission transfers) */
-#define  USB_EP4R_STAT_TX_0                  ((u16)0x0010)            /* Bit 0 */
-#define  USB_EP4R_STAT_TX_1                  ((u16)0x0020)            /* Bit 1 */
-
-#define  USB_EP4R_DTOG_TX                    ((u16)0x0040)            /* Data Toggle, for transmission transfers */
-#define  USB_EP4R_CTR_TX                     ((u16)0x0080)            /* Correct Transfer for transmission */
-#define  USB_EP4R_EP_KIND                    ((u16)0x0100)            /* Endpoint Kind */
-
-#define  USB_EP4R_EP_TYPE                    ((u16)0x0600)            /* EP_TYPE[1:0] bits (Endpoint type) */
-#define  USB_EP4R_EP_TYPE_0                  ((u16)0x0200)            /* Bit 0 */
-#define  USB_EP4R_EP_TYPE_1                  ((u16)0x0400)            /* Bit 1 */
-
-#define  USB_EP4R_SETUP                      ((u16)0x0800)            /* Setup transaction completed */
-
-#define  USB_EP4R_STAT_RX                    ((u16)0x3000)            /* STAT_RX[1:0] bits (Status bits, for reception transfers) */
-#define  USB_EP4R_STAT_RX_0                  ((u16)0x1000)            /* Bit 0 */
-#define  USB_EP4R_STAT_RX_1                  ((u16)0x2000)            /* Bit 1 */
-
-#define  USB_EP4R_DTOG_RX                    ((u16)0x4000)            /* Data Toggle, for reception transfers */
-#define  USB_EP4R_CTR_RX                     ((u16)0x8000)            /* Correct Transfer for reception */
-
-
-/*******************  Bit definition for USB_EP5R register  *******************/
-#define  USB_EP5R_EA                         ((u16)0x000F)            /* Endpoint Address */
-
-#define  USB_EP5R_STAT_TX                    ((u16)0x0030)            /* STAT_TX[1:0] bits (Status bits, for transmission transfers) */
-#define  USB_EP5R_STAT_TX_0                  ((u16)0x0010)            /* Bit 0 */
-#define  USB_EP5R_STAT_TX_1                  ((u16)0x0020)            /* Bit 1 */
-
-#define  USB_EP5R_DTOG_TX                    ((u16)0x0040)            /* Data Toggle, for transmission transfers */
-#define  USB_EP5R_CTR_TX                     ((u16)0x0080)            /* Correct Transfer for transmission */
-#define  USB_EP5R_EP_KIND                    ((u16)0x0100)            /* Endpoint Kind */
-
-#define  USB_EP5R_EP_TYPE                    ((u16)0x0600)            /* EP_TYPE[1:0] bits (Endpoint type) */
-#define  USB_EP5R_EP_TYPE_0                  ((u16)0x0200)            /* Bit 0 */
-#define  USB_EP5R_EP_TYPE_1                  ((u16)0x0400)            /* Bit 1 */
-
-#define  USB_EP5R_SETUP                      ((u16)0x0800)            /* Setup transaction completed */
-
-#define  USB_EP5R_STAT_RX                    ((u16)0x3000)            /* STAT_RX[1:0] bits (Status bits, for reception transfers) */
-#define  USB_EP5R_STAT_RX_0                  ((u16)0x1000)            /* Bit 0 */
-#define  USB_EP5R_STAT_RX_1                  ((u16)0x2000)            /* Bit 1 */
-
-#define  USB_EP5R_DTOG_RX                    ((u16)0x4000)            /* Data Toggle, for reception transfers */
-#define  USB_EP5R_CTR_RX                     ((u16)0x8000)            /* Correct Transfer for reception */
-
-
-/*******************  Bit definition for USB_EP6R register  *******************/
-#define  USB_EP6R_EA                         ((u16)0x000F)            /* Endpoint Address */
-
-#define  USB_EP6R_STAT_TX                    ((u16)0x0030)            /* STAT_TX[1:0] bits (Status bits, for transmission transfers) */
-#define  USB_EP6R_STAT_TX_0                  ((u16)0x0010)            /* Bit 0 */
-#define  USB_EP6R_STAT_TX_1                  ((u16)0x0020)            /* Bit 1 */
-
-#define  USB_EP6R_DTOG_TX                    ((u16)0x0040)            /* Data Toggle, for transmission transfers */
-#define  USB_EP6R_CTR_TX                     ((u16)0x0080)            /* Correct Transfer for transmission */
-#define  USB_EP6R_EP_KIND                    ((u16)0x0100)            /* Endpoint Kind */
-
-#define  USB_EP6R_EP_TYPE                    ((u16)0x0600)            /* EP_TYPE[1:0] bits (Endpoint type) */
-#define  USB_EP6R_EP_TYPE_0                  ((u16)0x0200)            /* Bit 0 */
-#define  USB_EP6R_EP_TYPE_1                  ((u16)0x0400)            /* Bit 1 */
-
-#define  USB_EP6R_SETUP                      ((u16)0x0800)            /* Setup transaction completed */
-
-#define  USB_EP6R_STAT_RX                    ((u16)0x3000)            /* STAT_RX[1:0] bits (Status bits, for reception transfers) */
-#define  USB_EP6R_STAT_RX_0                  ((u16)0x1000)            /* Bit 0 */
-#define  USB_EP6R_STAT_RX_1                  ((u16)0x2000)            /* Bit 1 */
-
-#define  USB_EP6R_DTOG_RX                    ((u16)0x4000)            /* Data Toggle, for reception transfers */
-#define  USB_EP6R_CTR_RX                     ((u16)0x8000)            /* Correct Transfer for reception */
-
-
-/*******************  Bit definition for USB_EP7R register  *******************/
-#define  USB_EP7R_EA                         ((u16)0x000F)            /* Endpoint Address */
-
-#define  USB_EP7R_STAT_TX                    ((u16)0x0030)            /* STAT_TX[1:0] bits (Status bits, for transmission transfers) */
-#define  USB_EP7R_STAT_TX_0                  ((u16)0x0010)            /* Bit 0 */
-#define  USB_EP7R_STAT_TX_1                  ((u16)0x0020)            /* Bit 1 */
-
-#define  USB_EP7R_DTOG_TX                    ((u16)0x0040)            /* Data Toggle, for transmission transfers */
-#define  USB_EP7R_CTR_TX                     ((u16)0x0080)            /* Correct Transfer for transmission */
-#define  USB_EP7R_EP_KIND                    ((u16)0x0100)            /* Endpoint Kind */
-
-#define  USB_EP7R_EP_TYPE                    ((u16)0x0600)            /* EP_TYPE[1:0] bits (Endpoint type) */
-#define  USB_EP7R_EP_TYPE_0                  ((u16)0x0200)            /* Bit 0 */
-#define  USB_EP7R_EP_TYPE_1                  ((u16)0x0400)            /* Bit 1 */
-
-#define  USB_EP7R_SETUP                      ((u16)0x0800)            /* Setup transaction completed */
-
-#define  USB_EP7R_STAT_RX                    ((u16)0x3000)            /* STAT_RX[1:0] bits (Status bits, for reception transfers) */
-#define  USB_EP7R_STAT_RX_0                  ((u16)0x1000)            /* Bit 0 */
-#define  USB_EP7R_STAT_RX_1                  ((u16)0x2000)            /* Bit 1 */
-
-#define  USB_EP7R_DTOG_RX                    ((u16)0x4000)            /* Data Toggle, for reception transfers */
-#define  USB_EP7R_CTR_RX                     ((u16)0x8000)            /* Correct Transfer for reception */
-
-
-/* Common registers */
-/*******************  Bit definition for USB_CNTR register  *******************/
-#define  USB_CNTR_FRES                       ((u16)0x0001)            /* Force USB Reset */
-#define  USB_CNTR_PDWN                       ((u16)0x0002)            /* Power down */
-#define  USB_CNTR_LP_MODE                    ((u16)0x0004)            /* Low-power mode */
-#define  USB_CNTR_FSUSP                      ((u16)0x0008)            /* Force suspend */
-#define  USB_CNTR_RESUME                     ((u16)0x0010)            /* Resume request */
-#define  USB_CNTR_ESOFM                      ((u16)0x0100)            /* Expected Start Of Frame Interrupt Mask */
-#define  USB_CNTR_SOFM                       ((u16)0x0200)            /* Start Of Frame Interrupt Mask */
-#define  USB_CNTR_RESETM                     ((u16)0x0400)            /* RESET Interrupt Mask */
-#define  USB_CNTR_SUSPM                      ((u16)0x0800)            /* Suspend mode Interrupt Mask */
-#define  USB_CNTR_WKUPM                      ((u16)0x1000)            /* Wakeup Interrupt Mask */
-#define  USB_CNTR_ERRM                       ((u16)0x2000)            /* Error Interrupt Mask */
-#define  USB_CNTR_PMAOVRM                    ((u16)0x4000)            /* Packet Memory Area Over / Underrun Interrupt Mask */
-#define  USB_CNTR_CTRM                       ((u16)0x8000)            /* Correct Transfer Interrupt Mask */
-
-
-/*******************  Bit definition for USB_ISTR register  *******************/
-#define  USB_ISTR_EP_ID                      ((u16)0x000F)            /* Endpoint Identifier */
-#define  USB_ISTR_DIR                        ((u16)0x0010)            /* Direction of transaction */
-#define  USB_ISTR_ESOF                       ((u16)0x0100)            /* Expected Start Of Frame */
-#define  USB_ISTR_SOF                        ((u16)0x0200)            /* Start Of Frame */
-#define  USB_ISTR_RESET                      ((u16)0x0400)            /* USB RESET request */
-#define  USB_ISTR_SUSP                       ((u16)0x0800)            /* Suspend mode request */
-#define  USB_ISTR_WKUP                       ((u16)0x1000)            /* Wake up */
-#define  USB_ISTR_ERR                        ((u16)0x2000)            /* Error */
-#define  USB_ISTR_PMAOVR                     ((u16)0x4000)            /* Packet Memory Area Over / Underrun */
-#define  USB_ISTR_CTR                        ((u16)0x8000)            /* Correct Transfer */
-
-
-/*******************  Bit definition for USB_FNR register  ********************/
-#define  USB_FNR_FN                          ((u16)0x07FF)            /* Frame Number */
-#define  USB_FNR_LSOF                        ((u16)0x1800)            /* Lost SOF */
-#define  USB_FNR_LCK                         ((u16)0x2000)            /* Locked */
-#define  USB_FNR_RXDM                        ((u16)0x4000)            /* Receive Data - Line Status */
-#define  USB_FNR_RXDP                        ((u16)0x8000)            /* Receive Data + Line Status */
-
-
-/******************  Bit definition for USB_DADDR register  *******************/
-#define  USB_DADDR_ADD                       ((u8)0x7F)               /* ADD[6:0] bits (Device Address) */
-#define  USB_DADDR_ADD0                      ((u8)0x01)               /* Bit 0 */
-#define  USB_DADDR_ADD1                      ((u8)0x02)               /* Bit 1 */
-#define  USB_DADDR_ADD2                      ((u8)0x04)               /* Bit 2 */
-#define  USB_DADDR_ADD3                      ((u8)0x08)               /* Bit 3 */
-#define  USB_DADDR_ADD4                      ((u8)0x10)               /* Bit 4 */
-#define  USB_DADDR_ADD5                      ((u8)0x20)               /* Bit 5 */
-#define  USB_DADDR_ADD6                      ((u8)0x40)               /* Bit 6 */
-
-#define  USB_DADDR_EF                        ((u8)0x80)               /* Enable Function */
-
-
-/******************  Bit definition for USB_BTABLE register  ******************/    
-#define  USB_BTABLE_BTABLE                   ((u16)0xFFF8)            /* Buffer Table */
-
-
-/* Buffer descriptor table */
-/*****************  Bit definition for USB_ADDR0_TX register  *****************/
-#define  USB_ADDR0_TX_ADDR0_TX               ((u16)0xFFFE)            /* Transmission Buffer Address 0 */
-
-
-/*****************  Bit definition for USB_ADDR1_TX register  *****************/
-#define  USB_ADDR1_TX_ADDR1_TX               ((u16)0xFFFE)            /* Transmission Buffer Address 1 */
-
-
-/*****************  Bit definition for USB_ADDR2_TX register  *****************/
-#define  USB_ADDR2_TX_ADDR2_TX               ((u16)0xFFFE)            /* Transmission Buffer Address 2 */
-
-
-/*****************  Bit definition for USB_ADDR3_TX register  *****************/
-#define  USB_ADDR3_TX_ADDR3_TX               ((u16)0xFFFE)            /* Transmission Buffer Address 3 */
-
-
-/*****************  Bit definition for USB_ADDR4_TX register  *****************/
-#define  USB_ADDR4_TX_ADDR4_TX               ((u16)0xFFFE)            /* Transmission Buffer Address 4 */
-
-
-/*****************  Bit definition for USB_ADDR5_TX register  *****************/
-#define  USB_ADDR5_TX_ADDR5_TX               ((u16)0xFFFE)            /* Transmission Buffer Address 5 */
-
-
-/*****************  Bit definition for USB_ADDR6_TX register  *****************/
-#define  USB_ADDR6_TX_ADDR6_TX               ((u16)0xFFFE)            /* Transmission Buffer Address 6 */
-
-
-/*****************  Bit definition for USB_ADDR7_TX register  *****************/
-#define  USB_ADDR7_TX_ADDR7_TX               ((u16)0xFFFE)            /* Transmission Buffer Address 7 */
-
-
-/*----------------------------------------------------------------------------*/
-
-
-/*****************  Bit definition for USB_COUNT0_TX register  ****************/
-#define  USB_COUNT0_TX_COUNT0_TX             ((u16)0x03FF)            /* Transmission Byte Count 0 */
-
-
-/*****************  Bit definition for USB_COUNT1_TX register  ****************/
-#define  USB_COUNT1_TX_COUNT1_TX             ((u16)0x03FF)            /* Transmission Byte Count 1 */
-
-
-/*****************  Bit definition for USB_COUNT2_TX register  ****************/
-#define  USB_COUNT2_TX_COUNT2_TX             ((u16)0x03FF)            /* Transmission Byte Count 2 */
-
-
-/*****************  Bit definition for USB_COUNT3_TX register  ****************/
-#define  USB_COUNT3_TX_COUNT3_TX             ((u16)0x03FF)            /* Transmission Byte Count 3 */
-
-
-/*****************  Bit definition for USB_COUNT4_TX register  ****************/
-#define  USB_COUNT4_TX_COUNT4_TX             ((u16)0x03FF)            /* Transmission Byte Count 4 */
-
-/*****************  Bit definition for USB_COUNT5_TX register  ****************/
-#define  USB_COUNT5_TX_COUNT5_TX             ((u16)0x03FF)            /* Transmission Byte Count 5 */
-
-
-/*****************  Bit definition for USB_COUNT6_TX register  ****************/
-#define  USB_COUNT6_TX_COUNT6_TX             ((u16)0x03FF)            /* Transmission Byte Count 6 */
-
-
-/*****************  Bit definition for USB_COUNT7_TX register  ****************/
-#define  USB_COUNT7_TX_COUNT7_TX             ((u16)0x03FF)            /* Transmission Byte Count 7 */
-
-
-/*----------------------------------------------------------------------------*/
-
-
-/****************  Bit definition for USB_COUNT0_TX_0 register  ***************/
-#define  USB_COUNT0_TX_0_COUNT0_TX_0         ((u32)0x000003FF)        /* Transmission Byte Count 0 (low) */
-
-/****************  Bit definition for USB_COUNT0_TX_1 register  ***************/
-#define  USB_COUNT0_TX_1_COUNT0_TX_1         ((u32)0x03FF0000)        /* Transmission Byte Count 0 (high) */
-
-
-
-/****************  Bit definition for USB_COUNT1_TX_0 register  ***************/
-#define  USB_COUNT1_TX_0_COUNT1_TX_0          ((u32)0x000003FF)        /* Transmission Byte Count 1 (low) */
-
-/****************  Bit definition for USB_COUNT1_TX_1 register  ***************/
-#define  USB_COUNT1_TX_1_COUNT1_TX_1          ((u32)0x03FF0000)        /* Transmission Byte Count 1 (high) */
-
-
-
-/****************  Bit definition for USB_COUNT2_TX_0 register  ***************/
-#define  USB_COUNT2_TX_0_COUNT2_TX_0         ((u32)0x000003FF)        /* Transmission Byte Count 2 (low) */
-
-/****************  Bit definition for USB_COUNT2_TX_1 register  ***************/
-#define  USB_COUNT2_TX_1_COUNT2_TX_1         ((u32)0x03FF0000)        /* Transmission Byte Count 2 (high) */
-
-
-
-/****************  Bit definition for USB_COUNT3_TX_0 register  ***************/
-#define  USB_COUNT3_TX_0_COUNT3_TX_0         ((u16)0x000003FF)        /* Transmission Byte Count 3 (low) */
-
-/****************  Bit definition for USB_COUNT3_TX_1 register  ***************/
-#define  USB_COUNT3_TX_1_COUNT3_TX_1         ((u16)0x03FF0000)        /* Transmission Byte Count 3 (high) */
-
-
-
-/****************  Bit definition for USB_COUNT4_TX_0 register  ***************/
-#define  USB_COUNT4_TX_0_COUNT4_TX_0         ((u32)0x000003FF)        /* Transmission Byte Count 4 (low) */
-
-/****************  Bit definition for USB_COUNT4_TX_1 register  ***************/
-#define  USB_COUNT4_TX_1_COUNT4_TX_1         ((u32)0x03FF0000)        /* Transmission Byte Count 4 (high) */
-
-
-
-/****************  Bit definition for USB_COUNT5_TX_0 register  ***************/
-#define  USB_COUNT5_TX_0_COUNT5_TX_0         ((u32)0x000003FF)        /* Transmission Byte Count 5 (low) */
-
-/****************  Bit definition for USB_COUNT5_TX_1 register  ***************/
-#define  USB_COUNT5_TX_1_COUNT5_TX_1         ((u32)0x03FF0000)        /* Transmission Byte Count 5 (high) */
-
-
-
-/****************  Bit definition for USB_COUNT6_TX_0 register  ***************/
-#define  USB_COUNT6_TX_0_COUNT6_TX_0         ((u32)0x000003FF)        /* Transmission Byte Count 6 (low) */
-
-/****************  Bit definition for USB_COUNT6_TX_1 register  ***************/
-#define  USB_COUNT6_TX_1_COUNT6_TX_1         ((u32)0x03FF0000)        /* Transmission Byte Count 6 (high) */
-
-
-
-/****************  Bit definition for USB_COUNT7_TX_0 register  ***************/
-#define  USB_COUNT7_TX_0_COUNT7_TX_0         ((u32)0x000003FF)        /* Transmission Byte Count 7 (low) */
-
-/****************  Bit definition for USB_COUNT7_TX_1 register  ***************/
-#define  USB_COUNT7_TX_1_COUNT7_TX_1         ((u32)0x03FF0000)        /* Transmission Byte Count 7 (high) */
-
-
-/*----------------------------------------------------------------------------*/
-
-
-/*****************  Bit definition for USB_ADDR0_RX register  *****************/
-#define  USB_ADDR0_RX_ADDR0_RX               ((u16)0xFFFE)            /* Reception Buffer Address 0 */
-
-
-/*****************  Bit definition for USB_ADDR1_RX register  *****************/
-#define  USB_ADDR1_RX_ADDR1_RX               ((u16)0xFFFE)            /* Reception Buffer Address 1 */
-
-
-/*****************  Bit definition for USB_ADDR2_RX register  *****************/
-#define  USB_ADDR2_RX_ADDR2_RX               ((u16)0xFFFE)            /* Reception Buffer Address 2 */
-
-
-/*****************  Bit definition for USB_ADDR3_RX register  *****************/
-#define  USB_ADDR3_RX_ADDR3_RX               ((u16)0xFFFE)            /* Reception Buffer Address 3 */
-
-
-/*****************  Bit definition for USB_ADDR4_RX register  *****************/
-#define  USB_ADDR4_RX_ADDR4_RX               ((u16)0xFFFE)            /* Reception Buffer Address 4 */
-
-
-/*****************  Bit definition for USB_ADDR5_RX register  *****************/
-#define  USB_ADDR5_RX_ADDR5_RX               ((u16)0xFFFE)            /* Reception Buffer Address 5 */
-
-
-/*****************  Bit definition for USB_ADDR6_RX register  *****************/
-#define  USB_ADDR6_RX_ADDR6_RX               ((u16)0xFFFE)            /* Reception Buffer Address 6 */
-
-
-/*****************  Bit definition for USB_ADDR7_RX register  *****************/
-#define  USB_ADDR7_RX_ADDR7_RX               ((u16)0xFFFE)            /* Reception Buffer Address 7 */
-
-
-/*----------------------------------------------------------------------------*/
-
-
-/*****************  Bit definition for USB_COUNT0_RX register  ****************/
-#define  USB_COUNT0_RX_COUNT0_RX             ((u16)0x03FF)            /* Reception Byte Count */
-
-#define  USB_COUNT0_RX_NUM_BLOCK             ((u16)0x7C00)            /* NUM_BLOCK[4:0] bits (Number of blocks) */
-#define  USB_COUNT0_RX_NUM_BLOCK_0           ((u16)0x0400)            /* Bit 0 */
-#define  USB_COUNT0_RX_NUM_BLOCK_1           ((u16)0x0800)            /* Bit 1 */
-#define  USB_COUNT0_RX_NUM_BLOCK_2           ((u16)0x1000)            /* Bit 2 */
-#define  USB_COUNT0_RX_NUM_BLOCK_3           ((u16)0x2000)            /* Bit 3 */
-#define  USB_COUNT0_RX_NUM_BLOCK_4           ((u16)0x4000)            /* Bit 4 */
-
-#define  USB_COUNT0_RX_BLSIZE                ((u16)0x8000)            /* BLock SIZE */
-
-
-/*****************  Bit definition for USB_COUNT1_RX register  ****************/
-#define  USB_COUNT1_RX_COUNT1_RX             ((u16)0x03FF)            /* Reception Byte Count */
-
-#define  USB_COUNT1_RX_NUM_BLOCK             ((u16)0x7C00)            /* NUM_BLOCK[4:0] bits (Number of blocks) */
-#define  USB_COUNT1_RX_NUM_BLOCK_0           ((u16)0x0400)            /* Bit 0 */
-#define  USB_COUNT1_RX_NUM_BLOCK_1           ((u16)0x0800)            /* Bit 1 */
-#define  USB_COUNT1_RX_NUM_BLOCK_2           ((u16)0x1000)            /* Bit 2 */
-#define  USB_COUNT1_RX_NUM_BLOCK_3           ((u16)0x2000)            /* Bit 3 */
-#define  USB_COUNT1_RX_NUM_BLOCK_4           ((u16)0x4000)            /* Bit 4 */
-
-#define  USB_COUNT1_RX_BLSIZE                ((u16)0x8000)            /* BLock SIZE */
-
-
-/*****************  Bit definition for USB_COUNT2_RX register  ****************/
-#define  USB_COUNT2_RX_COUNT2_RX             ((u16)0x03FF)            /* Reception Byte Count */
-
-#define  USB_COUNT2_RX_NUM_BLOCK             ((u16)0x7C00)            /* NUM_BLOCK[4:0] bits (Number of blocks) */
-#define  USB_COUNT2_RX_NUM_BLOCK_0           ((u16)0x0400)            /* Bit 0 */
-#define  USB_COUNT2_RX_NUM_BLOCK_1           ((u16)0x0800)            /* Bit 1 */
-#define  USB_COUNT2_RX_NUM_BLOCK_2           ((u16)0x1000)            /* Bit 2 */
-#define  USB_COUNT2_RX_NUM_BLOCK_3           ((u16)0x2000)            /* Bit 3 */
-#define  USB_COUNT2_RX_NUM_BLOCK_4           ((u16)0x4000)            /* Bit 4 */
-
-#define  USB_COUNT2_RX_BLSIZE                ((u16)0x8000)            /* BLock SIZE */
-
-
-/*****************  Bit definition for USB_COUNT3_RX register  ****************/
-#define  USB_COUNT3_RX_COUNT3_RX             ((u16)0x03FF)            /* Reception Byte Count */
-
-#define  USB_COUNT3_RX_NUM_BLOCK             ((u16)0x7C00)            /* NUM_BLOCK[4:0] bits (Number of blocks) */
-#define  USB_COUNT3_RX_NUM_BLOCK_0           ((u16)0x0400)            /* Bit 0 */
-#define  USB_COUNT3_RX_NUM_BLOCK_1           ((u16)0x0800)            /* Bit 1 */
-#define  USB_COUNT3_RX_NUM_BLOCK_2           ((u16)0x1000)            /* Bit 2 */
-#define  USB_COUNT3_RX_NUM_BLOCK_3           ((u16)0x2000)            /* Bit 3 */
-#define  USB_COUNT3_RX_NUM_BLOCK_4           ((u16)0x4000)            /* Bit 4 */
-
-#define  USB_COUNT3_RX_BLSIZE                ((u16)0x8000)            /* BLock SIZE */
-
-
-/*****************  Bit definition for USB_COUNT4_RX register  ****************/
-#define  USB_COUNT4_RX_COUNT4_RX             ((u16)0x03FF)            /* Reception Byte Count */
-
-#define  USB_COUNT4_RX_NUM_BLOCK             ((u16)0x7C00)            /* NUM_BLOCK[4:0] bits (Number of blocks) */
-#define  USB_COUNT4_RX_NUM_BLOCK_0           ((u16)0x0400)            /* Bit 0 */
-#define  USB_COUNT4_RX_NUM_BLOCK_1           ((u16)0x0800)            /* Bit 1 */
-#define  USB_COUNT4_RX_NUM_BLOCK_2           ((u16)0x1000)            /* Bit 2 */
-#define  USB_COUNT4_RX_NUM_BLOCK_3           ((u16)0x2000)            /* Bit 3 */
-#define  USB_COUNT4_RX_NUM_BLOCK_4           ((u16)0x4000)            /* Bit 4 */
-
-#define  USB_COUNT4_RX_BLSIZE                ((u16)0x8000)            /* BLock SIZE */
-
-
-/*****************  Bit definition for USB_COUNT5_RX register  ****************/
-#define  USB_COUNT5_RX_COUNT5_RX             ((u16)0x03FF)            /* Reception Byte Count */
-
-#define  USB_COUNT5_RX_NUM_BLOCK             ((u16)0x7C00)            /* NUM_BLOCK[4:0] bits (Number of blocks) */
-#define  USB_COUNT5_RX_NUM_BLOCK_0           ((u16)0x0400)            /* Bit 0 */
-#define  USB_COUNT5_RX_NUM_BLOCK_1           ((u16)0x0800)            /* Bit 1 */
-#define  USB_COUNT5_RX_NUM_BLOCK_2           ((u16)0x1000)            /* Bit 2 */
-#define  USB_COUNT5_RX_NUM_BLOCK_3           ((u16)0x2000)            /* Bit 3 */
-#define  USB_COUNT5_RX_NUM_BLOCK_4           ((u16)0x4000)            /* Bit 4 */
-
-#define  USB_COUNT5_RX_BLSIZE                ((u16)0x8000)            /* BLock SIZE */
-
-/*****************  Bit definition for USB_COUNT6_RX register  ****************/
-#define  USB_COUNT6_RX_COUNT6_RX             ((u16)0x03FF)            /* Reception Byte Count */
-
-#define  USB_COUNT6_RX_NUM_BLOCK             ((u16)0x7C00)            /* NUM_BLOCK[4:0] bits (Number of blocks) */
-#define  USB_COUNT6_RX_NUM_BLOCK_0           ((u16)0x0400)            /* Bit 0 */
-#define  USB_COUNT6_RX_NUM_BLOCK_1           ((u16)0x0800)            /* Bit 1 */
-#define  USB_COUNT6_RX_NUM_BLOCK_2           ((u16)0x1000)            /* Bit 2 */
-#define  USB_COUNT6_RX_NUM_BLOCK_3           ((u16)0x2000)            /* Bit 3 */
-#define  USB_COUNT6_RX_NUM_BLOCK_4           ((u16)0x4000)            /* Bit 4 */
-
-#define  USB_COUNT6_RX_BLSIZE                ((u16)0x8000)            /* BLock SIZE */
-
-
-/*****************  Bit definition for USB_COUNT7_RX register  ****************/
-#define  USB_COUNT7_RX_COUNT7_RX             ((u16)0x03FF)            /* Reception Byte Count */
-
-#define  USB_COUNT7_RX_NUM_BLOCK             ((u16)0x7C00)            /* NUM_BLOCK[4:0] bits (Number of blocks) */
-#define  USB_COUNT7_RX_NUM_BLOCK_0           ((u16)0x0400)            /* Bit 0 */
-#define  USB_COUNT7_RX_NUM_BLOCK_1           ((u16)0x0800)            /* Bit 1 */
-#define  USB_COUNT7_RX_NUM_BLOCK_2           ((u16)0x1000)            /* Bit 2 */
-#define  USB_COUNT7_RX_NUM_BLOCK_3           ((u16)0x2000)            /* Bit 3 */
-#define  USB_COUNT7_RX_NUM_BLOCK_4           ((u16)0x4000)            /* Bit 4 */
-
-#define  USB_COUNT7_RX_BLSIZE                ((u16)0x8000)            /* BLock SIZE */
-
-
-/*----------------------------------------------------------------------------*/
-
-
-/****************  Bit definition for USB_COUNT0_RX_0 register  ***************/
-#define  USB_COUNT0_RX_0_COUNT0_RX_0         ((u32)0x000003FF)        /* Reception Byte Count (low) */
-
-#define  USB_COUNT0_RX_0_NUM_BLOCK_0         ((u32)0x00007C00)        /* NUM_BLOCK_0[4:0] bits (Number of blocks) (low) */
-#define  USB_COUNT0_RX_0_NUM_BLOCK_0_0       ((u32)0x00000400)        /* Bit 0 */
-#define  USB_COUNT0_RX_0_NUM_BLOCK_0_1       ((u32)0x00000800)        /* Bit 1 */
-#define  USB_COUNT0_RX_0_NUM_BLOCK_0_2       ((u32)0x00001000)        /* Bit 2 */
-#define  USB_COUNT0_RX_0_NUM_BLOCK_0_3       ((u32)0x00002000)        /* Bit 3 */
-#define  USB_COUNT0_RX_0_NUM_BLOCK_0_4       ((u32)0x00004000)        /* Bit 4 */
-
-#define  USB_COUNT0_RX_0_BLSIZE_0            ((u32)0x00008000)        /* BLock SIZE (low) */
-
-/****************  Bit definition for USB_COUNT0_RX_1 register  ***************/
-#define  USB_COUNT0_RX_1_COUNT0_RX_1         ((u32)0x03FF0000)        /* Reception Byte Count (high) */
-
-#define  USB_COUNT0_RX_1_NUM_BLOCK_1         ((u32)0x7C000000)        /* NUM_BLOCK_1[4:0] bits (Number of blocks) (high) */
-#define  USB_COUNT0_RX_1_NUM_BLOCK_1_0       ((u32)0x04000000)        /* Bit 1 */
-#define  USB_COUNT0_RX_1_NUM_BLOCK_1_1       ((u32)0x08000000)        /* Bit 1 */
-#define  USB_COUNT0_RX_1_NUM_BLOCK_1_2       ((u32)0x10000000)        /* Bit 2 */
-#define  USB_COUNT0_RX_1_NUM_BLOCK_1_3       ((u32)0x20000000)        /* Bit 3 */
-#define  USB_COUNT0_RX_1_NUM_BLOCK_1_4       ((u32)0x40000000)        /* Bit 4 */
-
-#define  USB_COUNT0_RX_1_BLSIZE_1            ((u32)0x80000000)        /* BLock SIZE (high) */
-
-
-
-/****************  Bit definition for USB_COUNT1_RX_0 register  ***************/
-#define  USB_COUNT1_RX_0_COUNT1_RX_0         ((u32)0x000003FF)        /* Reception Byte Count (low) */
-
-#define  USB_COUNT1_RX_0_NUM_BLOCK_0         ((u32)0x00007C00)        /* NUM_BLOCK_0[4:0] bits (Number of blocks) (low) */
-#define  USB_COUNT1_RX_0_NUM_BLOCK_0_0       ((u32)0x00000400)        /* Bit 0 */
-#define  USB_COUNT1_RX_0_NUM_BLOCK_0_1       ((u32)0x00000800)        /* Bit 1 */
-#define  USB_COUNT1_RX_0_NUM_BLOCK_0_2       ((u32)0x00001000)        /* Bit 2 */
-#define  USB_COUNT1_RX_0_NUM_BLOCK_0_3       ((u32)0x00002000)        /* Bit 3 */
-#define  USB_COUNT1_RX_0_NUM_BLOCK_0_4       ((u32)0x00004000)        /* Bit 4 */
-
-#define  USB_COUNT1_RX_0_BLSIZE_0            ((u32)0x00008000)        /* BLock SIZE (low) */
-
-/****************  Bit definition for USB_COUNT1_RX_1 register  ***************/
-#define  USB_COUNT1_RX_1_COUNT1_RX_1         ((u32)0x03FF0000)        /* Reception Byte Count (high) */
-
-#define  USB_COUNT1_RX_1_NUM_BLOCK_1         ((u32)0x7C000000)        /* NUM_BLOCK_1[4:0] bits (Number of blocks) (high) */
-#define  USB_COUNT1_RX_1_NUM_BLOCK_1_0       ((u32)0x04000000)        /* Bit 0 */
-#define  USB_COUNT1_RX_1_NUM_BLOCK_1_1       ((u32)0x08000000)        /* Bit 1 */
-#define  USB_COUNT1_RX_1_NUM_BLOCK_1_2       ((u32)0x10000000)        /* Bit 2 */
-#define  USB_COUNT1_RX_1_NUM_BLOCK_1_3       ((u32)0x20000000)        /* Bit 3 */
-#define  USB_COUNT1_RX_1_NUM_BLOCK_1_4       ((u32)0x40000000)        /* Bit 4 */
-
-#define  USB_COUNT1_RX_1_BLSIZE_1            ((u32)0x80000000)        /* BLock SIZE (high) */
-
-
-
-/****************  Bit definition for USB_COUNT2_RX_0 register  ***************/
-#define  USB_COUNT2_RX_0_COUNT2_RX_0         ((u32)0x000003FF)        /* Reception Byte Count (low) */
-
-#define  USB_COUNT2_RX_0_NUM_BLOCK_0         ((u32)0x00007C00)        /* NUM_BLOCK_0[4:0] bits (Number of blocks) (low) */
-#define  USB_COUNT2_RX_0_NUM_BLOCK_0_0       ((u32)0x00000400)        /* Bit 0 */
-#define  USB_COUNT2_RX_0_NUM_BLOCK_0_1       ((u32)0x00000800)        /* Bit 1 */
-#define  USB_COUNT2_RX_0_NUM_BLOCK_0_2       ((u32)0x00001000)        /* Bit 2 */
-#define  USB_COUNT2_RX_0_NUM_BLOCK_0_3       ((u32)0x00002000)        /* Bit 3 */
-#define  USB_COUNT2_RX_0_NUM_BLOCK_0_4       ((u32)0x00004000)        /* Bit 4 */
-
-#define  USB_COUNT2_RX_0_BLSIZE_0            ((u32)0x00008000)        /* BLock SIZE (low) */
-
-/****************  Bit definition for USB_COUNT2_RX_1 register  ***************/
-#define  USB_COUNT2_RX_1_COUNT2_RX_1         ((u32)0x03FF0000)        /* Reception Byte Count (high) */
-
-#define  USB_COUNT2_RX_1_NUM_BLOCK_1         ((u32)0x7C000000)        /* NUM_BLOCK_1[4:0] bits (Number of blocks) (high) */
-#define  USB_COUNT2_RX_1_NUM_BLOCK_1_0       ((u32)0x04000000)        /* Bit 0 */
-#define  USB_COUNT2_RX_1_NUM_BLOCK_1_1       ((u32)0x08000000)        /* Bit 1 */
-#define  USB_COUNT2_RX_1_NUM_BLOCK_1_2       ((u32)0x10000000)        /* Bit 2 */
-#define  USB_COUNT2_RX_1_NUM_BLOCK_1_3       ((u32)0x20000000)        /* Bit 3 */
-#define  USB_COUNT2_RX_1_NUM_BLOCK_1_4       ((u32)0x40000000)        /* Bit 4 */
-
-#define  USB_COUNT2_RX_1_BLSIZE_1            ((u32)0x80000000)        /* BLock SIZE (high) */
-
-
-
-/****************  Bit definition for USB_COUNT3_RX_0 register  ***************/
-#define  USB_COUNT3_RX_0_COUNT3_RX_0         ((u32)0x000003FF)        /* Reception Byte Count (low) */
-
-#define  USB_COUNT3_RX_0_NUM_BLOCK_0         ((u32)0x00007C00)        /* NUM_BLOCK_0[4:0] bits (Number of blocks) (low) */
-#define  USB_COUNT3_RX_0_NUM_BLOCK_0_0       ((u32)0x00000400)        /* Bit 0 */
-#define  USB_COUNT3_RX_0_NUM_BLOCK_0_1       ((u32)0x00000800)        /* Bit 1 */
-#define  USB_COUNT3_RX_0_NUM_BLOCK_0_2       ((u32)0x00001000)        /* Bit 2 */
-#define  USB_COUNT3_RX_0_NUM_BLOCK_0_3       ((u32)0x00002000)        /* Bit 3 */
-#define  USB_COUNT3_RX_0_NUM_BLOCK_0_4       ((u32)0x00004000)        /* Bit 4 */
-
-#define  USB_COUNT3_RX_0_BLSIZE_0            ((u32)0x00008000)        /* BLock SIZE (low) */
-
-/****************  Bit definition for USB_COUNT3_RX_1 register  ***************/
-#define  USB_COUNT3_RX_1_COUNT3_RX_1         ((u32)0x03FF0000)        /* Reception Byte Count (high) */
-
-#define  USB_COUNT3_RX_1_NUM_BLOCK_1         ((u32)0x7C000000)        /* NUM_BLOCK_1[4:0] bits (Number of blocks) (high) */
-#define  USB_COUNT3_RX_1_NUM_BLOCK_1_0       ((u32)0x04000000)        /* Bit 0 */
-#define  USB_COUNT3_RX_1_NUM_BLOCK_1_1       ((u32)0x08000000)        /* Bit 1 */
-#define  USB_COUNT3_RX_1_NUM_BLOCK_1_2       ((u32)0x10000000)        /* Bit 2 */
-#define  USB_COUNT3_RX_1_NUM_BLOCK_1_3       ((u32)0x20000000)        /* Bit 3 */
-#define  USB_COUNT3_RX_1_NUM_BLOCK_1_4       ((u32)0x40000000)        /* Bit 4 */
-
-#define  USB_COUNT3_RX_1_BLSIZE_1            ((u32)0x80000000)        /* BLock SIZE (high) */
-
-
-
-/****************  Bit definition for USB_COUNT4_RX_0 register  ***************/
-#define  USB_COUNT4_RX_0_COUNT4_RX_0         ((u32)0x000003FF)        /* Reception Byte Count (low) */
-
-#define  USB_COUNT4_RX_0_NUM_BLOCK_0         ((u32)0x00007C00)        /* NUM_BLOCK_0[4:0] bits (Number of blocks) (low) */
-#define  USB_COUNT4_RX_0_NUM_BLOCK_0_0      ((u32)0x00000400)        /* Bit 0 */
-#define  USB_COUNT4_RX_0_NUM_BLOCK_0_1      ((u32)0x00000800)        /* Bit 1 */
-#define  USB_COUNT4_RX_0_NUM_BLOCK_0_2      ((u32)0x00001000)        /* Bit 2 */
-#define  USB_COUNT4_RX_0_NUM_BLOCK_0_3      ((u32)0x00002000)        /* Bit 3 */
-#define  USB_COUNT4_RX_0_NUM_BLOCK_0_4      ((u32)0x00004000)        /* Bit 4 */
-
-#define  USB_COUNT4_RX_0_BLSIZE_0            ((u32)0x00008000)        /* BLock SIZE (low) */
-
-/****************  Bit definition for USB_COUNT4_RX_1 register  ***************/
-#define  USB_COUNT4_RX_1_COUNT4_RX_1         ((u32)0x03FF0000)        /* Reception Byte Count (high) */
-
-#define  USB_COUNT4_RX_1_NUM_BLOCK_1         ((u32)0x7C000000)        /* NUM_BLOCK_1[4:0] bits (Number of blocks) (high) */
-#define  USB_COUNT4_RX_1_NUM_BLOCK_1_0       ((u32)0x04000000)        /* Bit 0 */
-#define  USB_COUNT4_RX_1_NUM_BLOCK_1_1       ((u32)0x08000000)        /* Bit 1 */
-#define  USB_COUNT4_RX_1_NUM_BLOCK_1_2       ((u32)0x10000000)        /* Bit 2 */
-#define  USB_COUNT4_RX_1_NUM_BLOCK_1_3       ((u32)0x20000000)        /* Bit 3 */
-#define  USB_COUNT4_RX_1_NUM_BLOCK_1_4       ((u32)0x40000000)        /* Bit 4 */
-
-#define  USB_COUNT4_RX_1_BLSIZE_1            ((u32)0x80000000)        /* BLock SIZE (high) */
-
-
-
-/****************  Bit definition for USB_COUNT5_RX_0 register  ***************/
-#define  USB_COUNT5_RX_0_COUNT5_RX_0         ((u32)0x000003FF)        /* Reception Byte Count (low) */
-
-#define  USB_COUNT5_RX_0_NUM_BLOCK_0         ((u32)0x00007C00)        /* NUM_BLOCK_0[4:0] bits (Number of blocks) (low) */
-#define  USB_COUNT5_RX_0_NUM_BLOCK_0_0       ((u32)0x00000400)        /* Bit 0 */
-#define  USB_COUNT5_RX_0_NUM_BLOCK_0_1       ((u32)0x00000800)        /* Bit 1 */
-#define  USB_COUNT5_RX_0_NUM_BLOCK_0_2       ((u32)0x00001000)        /* Bit 2 */
-#define  USB_COUNT5_RX_0_NUM_BLOCK_0_3       ((u32)0x00002000)        /* Bit 3 */
-#define  USB_COUNT5_RX_0_NUM_BLOCK_0_4       ((u32)0x00004000)        /* Bit 4 */
-
-#define  USB_COUNT5_RX_0_BLSIZE_0            ((u32)0x00008000)        /* BLock SIZE (low) */
-
-/****************  Bit definition for USB_COUNT5_RX_1 register  ***************/
-#define  USB_COUNT5_RX_1_COUNT5_RX_1         ((u32)0x03FF0000)        /* Reception Byte Count (high) */
-
-#define  USB_COUNT5_RX_1_NUM_BLOCK_1         ((u32)0x7C000000)        /* NUM_BLOCK_1[4:0] bits (Number of blocks) (high) */
-#define  USB_COUNT5_RX_1_NUM_BLOCK_1_0       ((u32)0x04000000)        /* Bit 0 */
-#define  USB_COUNT5_RX_1_NUM_BLOCK_1_1       ((u32)0x08000000)        /* Bit 1 */
-#define  USB_COUNT5_RX_1_NUM_BLOCK_1_2       ((u32)0x10000000)        /* Bit 2 */
-#define  USB_COUNT5_RX_1_NUM_BLOCK_1_3       ((u32)0x20000000)        /* Bit 3 */
-#define  USB_COUNT5_RX_1_NUM_BLOCK_1_4       ((u32)0x40000000)        /* Bit 4 */
-
-#define  USB_COUNT5_RX_1_BLSIZE_1            ((u32)0x80000000)        /* BLock SIZE (high) */
-
-
-
-/***************  Bit definition for USB_COUNT6_RX_0  register  ***************/
-#define  USB_COUNT6_RX_0_COUNT6_RX_0         ((u32)0x000003FF)        /* Reception Byte Count (low) */
-
-#define  USB_COUNT6_RX_0_NUM_BLOCK_0         ((u32)0x00007C00)        /* NUM_BLOCK_0[4:0] bits (Number of blocks) (low) */
-#define  USB_COUNT6_RX_0_NUM_BLOCK_0_0       ((u32)0x00000400)        /* Bit 0 */
-#define  USB_COUNT6_RX_0_NUM_BLOCK_0_1       ((u32)0x00000800)        /* Bit 1 */
-#define  USB_COUNT6_RX_0_NUM_BLOCK_0_2       ((u32)0x00001000)        /* Bit 2 */
-#define  USB_COUNT6_RX_0_NUM_BLOCK_0_3       ((u32)0x00002000)        /* Bit 3 */
-#define  USB_COUNT6_RX_0_NUM_BLOCK_0_4       ((u32)0x00004000)        /* Bit 4 */
-
-#define  USB_COUNT6_RX_0_BLSIZE_0            ((u32)0x00008000)        /* BLock SIZE (low) */
-
-/****************  Bit definition for USB_COUNT6_RX_1 register  ***************/
-#define  USB_COUNT6_RX_1_COUNT6_RX_1         ((u32)0x03FF0000)        /* Reception Byte Count (high) */
-
-#define  USB_COUNT6_RX_1_NUM_BLOCK_1         ((u32)0x7C000000)        /* NUM_BLOCK_1[4:0] bits (Number of blocks) (high) */
-#define  USB_COUNT6_RX_1_NUM_BLOCK_1_0       ((u32)0x04000000)        /* Bit 0 */
-#define  USB_COUNT6_RX_1_NUM_BLOCK_1_1       ((u32)0x08000000)        /* Bit 1 */
-#define  USB_COUNT6_RX_1_NUM_BLOCK_1_2       ((u32)0x10000000)        /* Bit 2 */
-#define  USB_COUNT6_RX_1_NUM_BLOCK_1_3       ((u32)0x20000000)        /* Bit 3 */
-#define  USB_COUNT6_RX_1_NUM_BLOCK_1_4       ((u32)0x40000000)        /* Bit 4 */
-
-#define  USB_COUNT6_RX_1_BLSIZE_1            ((u32)0x80000000)        /* BLock SIZE (high) */
-
-
-
-/***************  Bit definition for USB_COUNT7_RX_0 register  ****************/
-#define  USB_COUNT7_RX_0_COUNT7_RX_0         ((u32)0x000003FF)        /* Reception Byte Count (low) */
-
-#define  USB_COUNT7_RX_0_NUM_BLOCK_0         ((u32)0x00007C00)        /* NUM_BLOCK_0[4:0] bits (Number of blocks) (low) */
-#define  USB_COUNT7_RX_0_NUM_BLOCK_0_0       ((u32)0x00000400)        /* Bit 0 */
-#define  USB_COUNT7_RX_0_NUM_BLOCK_0_1       ((u32)0x00000800)        /* Bit 1 */
-#define  USB_COUNT7_RX_0_NUM_BLOCK_0_2       ((u32)0x00001000)        /* Bit 2 */
-#define  USB_COUNT7_RX_0_NUM_BLOCK_0_3       ((u32)0x00002000)        /* Bit 3 */
-#define  USB_COUNT7_RX_0_NUM_BLOCK_0_4       ((u32)0x00004000)        /* Bit 4 */
-
-#define  USB_COUNT7_RX_0_BLSIZE_0            ((u32)0x00008000)        /* BLock SIZE (low) */
-
-/***************  Bit definition for USB_COUNT7_RX_1 register  ****************/
-#define  USB_COUNT7_RX_1_COUNT7_RX_1         ((u32)0x03FF0000)        /* Reception Byte Count (high) */
-
-#define  USB_COUNT7_RX_1_NUM_BLOCK_1         ((u32)0x7C000000)        /* NUM_BLOCK_1[4:0] bits (Number of blocks) (high) */
-#define  USB_COUNT7_RX_1_NUM_BLOCK_1_0       ((u32)0x04000000)        /* Bit 0 */
-#define  USB_COUNT7_RX_1_NUM_BLOCK_1_1       ((u32)0x08000000)        /* Bit 1 */
-#define  USB_COUNT7_RX_1_NUM_BLOCK_1_2       ((u32)0x10000000)        /* Bit 2 */
-#define  USB_COUNT7_RX_1_NUM_BLOCK_1_3       ((u32)0x20000000)        /* Bit 3 */
-#define  USB_COUNT7_RX_1_NUM_BLOCK_1_4       ((u32)0x40000000)        /* Bit 4 */
-
-#define  USB_COUNT7_RX_1_BLSIZE_1            ((u32)0x80000000)        /* BLock SIZE (high) */
-
-
-
-/******************************************************************************/
-/*                                                                            */
-/*                          Controller Area Network                           */
-/*                                                                            */
-/******************************************************************************/
-
-/* CAN control and status registers */
-/*******************  Bit definition for CAN_MCR register  ********************/
-#define  CAN_MCR_INRQ                        ((u16)0x0001)            /* Initialization Request */
-#define  CAN_MCR_SLEEP                       ((u16)0x0002)            /* Sleep Mode Request */
-#define  CAN_MCR_TXFP                        ((u16)0x0004)            /* Transmit FIFO Priority */
-#define  CAN_MCR_RFLM                        ((u16)0x0008)            /* Receive FIFO Locked Mode */
-#define  CAN_MCR_NART                        ((u16)0x0010)            /* No Automatic Retransmission */
-#define  CAN_MCR_AWUM                        ((u16)0x0020)            /* Automatic Wakeup Mode */
-#define  CAN_MCR_ABOM                        ((u16)0x0040)            /* Automatic Bus-Off Management */
-#define  CAN_MCR_TTCM                        ((u16)0x0080)            /* Time Triggered Communication Mode */
-#define  CAN_MCR_RESET                       ((u16)0x8000)            /* bxCAN software master reset */
-
-
-/*******************  Bit definition for CAN_MSR register  ********************/
-#define  CAN_MSR_INAK                        ((u16)0x0001)            /* Initialization Acknowledge */
-#define  CAN_MSR_SLAK                        ((u16)0x0002)            /* Sleep Acknowledge */
-#define  CAN_MSR_ERRI                        ((u16)0x0004)            /* Error Interrupt */
-#define  CAN_MSR_WKUI                        ((u16)0x0008)            /* Wakeup Interrupt */
-#define  CAN_MSR_SLAKI                       ((u16)0x0010)            /* Sleep Acknowledge Interrupt */
-#define  CAN_MSR_TXM                         ((u16)0x0100)            /* Transmit Mode */
-#define  CAN_MSR_RXM                         ((u16)0x0200)            /* Receive Mode */
-#define  CAN_MSR_SAMP                        ((u16)0x0400)            /* Last Sample Point */
-#define  CAN_MSR_RX                          ((u16)0x0800)            /* CAN Rx Signal */
-
-
-/*******************  Bit definition for CAN_TSR register  ********************/
-#define  CAN_TSR_RQCP0                       ((u32)0x00000001)        /* Request Completed Mailbox0 */
-#define  CAN_TSR_TXOK0                       ((u32)0x00000002)        /* Transmission OK of Mailbox0 */
-#define  CAN_TSR_ALST0                       ((u32)0x00000004)        /* Arbitration Lost for Mailbox0 */
-#define  CAN_TSR_TERR0                       ((u32)0x00000008)        /* Transmission Error of Mailbox0 */
-#define  CAN_TSR_ABRQ0                       ((u32)0x00000080)        /* Abort Request for Mailbox0 */
-#define  CAN_TSR_RQCP1                       ((u32)0x00000100)        /* Request Completed Mailbox1 */
-#define  CAN_TSR_TXOK1                       ((u32)0x00000200)        /* Transmission OK of Mailbox1 */
-#define  CAN_TSR_ALST1                       ((u32)0x00000400)        /* Arbitration Lost for Mailbox1 */
-#define  CAN_TSR_TERR1                       ((u32)0x00000800)        /* Transmission Error of Mailbox1 */
-#define  CAN_TSR_ABRQ1                       ((u32)0x00008000)        /* Abort Request for Mailbox 1 */
-#define  CAN_TSR_RQCP2                       ((u32)0x00010000)        /* Request Completed Mailbox2 */
-#define  CAN_TSR_TXOK2                       ((u32)0x00020000)        /* Transmission OK of Mailbox 2 */
-#define  CAN_TSR_ALST2                       ((u32)0x00040000)        /* Arbitration Lost for mailbox 2 */
-#define  CAN_TSR_TERR2                       ((u32)0x00080000)        /* Transmission Error of Mailbox 2 */
-#define  CAN_TSR_ABRQ2                       ((u32)0x00800000)        /* Abort Request for Mailbox 2 */
-#define  CAN_TSR_CODE                        ((u32)0x03000000)        /* Mailbox Code */
-
-#define  CAN_TSR_TME                         ((u32)0x1C000000)        /* TME[2:0] bits */
-#define  CAN_TSR_TME0                        ((u32)0x04000000)        /* Transmit Mailbox 0 Empty */
-#define  CAN_TSR_TME1                        ((u32)0x08000000)        /* Transmit Mailbox 1 Empty */
-#define  CAN_TSR_TME2                        ((u32)0x10000000)        /* Transmit Mailbox 2 Empty */
-
-#define  CAN_TSR_LOW                         ((u32)0xE0000000)        /* LOW[2:0] bits */
-#define  CAN_TSR_LOW0                        ((u32)0x20000000)        /* Lowest Priority Flag for Mailbox 0 */
-#define  CAN_TSR_LOW1                        ((u32)0x40000000)        /* Lowest Priority Flag for Mailbox 1 */
-#define  CAN_TSR_LOW2                        ((u32)0x80000000)        /* Lowest Priority Flag for Mailbox 2 */
-
-
-/*******************  Bit definition for CAN_RF0R register  *******************/
-#define  CAN_RF0R_FMP0                       ((u8)0x03)               /* FIFO 0 Message Pending */
-#define  CAN_RF0R_FULL0                      ((u8)0x08)               /* FIFO 0 Full */
-#define  CAN_RF0R_FOVR0                      ((u8)0x10)               /* FIFO 0 Overrun */
-#define  CAN_RF0R_RFOM0                      ((u8)0x20)               /* Release FIFO 0 Output Mailbox */
-
-
-/*******************  Bit definition for CAN_RF1R register  *******************/
-#define  CAN_RF1R_FMP1                       ((u8)0x03)               /* FIFO 1 Message Pending */
-#define  CAN_RF1R_FULL1                      ((u8)0x08)               /* FIFO 1 Full */
-#define  CAN_RF1R_FOVR1                      ((u8)0x10)               /* FIFO 1 Overrun */
-#define  CAN_RF1R_RFOM1                      ((u8)0x20)               /* Release FIFO 1 Output Mailbox */
-
-
-/********************  Bit definition for CAN_IER register  *******************/
-#define  CAN_IER_TMEIE                       ((u32)0x00000001)        /* Transmit Mailbox Empty Interrupt Enable */
-#define  CAN_IER_FMPIE0                      ((u32)0x00000002)        /* FIFO Message Pending Interrupt Enable */
-#define  CAN_IER_FFIE0                       ((u32)0x00000004)        /* FIFO Full Interrupt Enable */
-#define  CAN_IER_FOVIE0                      ((u32)0x00000008)        /* FIFO Overrun Interrupt Enable */
-#define  CAN_IER_FMPIE1                      ((u32)0x00000010)        /* FIFO Message Pending Interrupt Enable */
-#define  CAN_IER_FFIE1                       ((u32)0x00000020)        /* FIFO Full Interrupt Enable */
-#define  CAN_IER_FOVIE1                      ((u32)0x00000040)        /* FIFO Overrun Interrupt Enable */
-#define  CAN_IER_EWGIE                       ((u32)0x00000100)        /* Error Warning Interrupt Enable */
-#define  CAN_IER_EPVIE                       ((u32)0x00000200)        /* Error Passive Interrupt Enable */
-#define  CAN_IER_BOFIE                       ((u32)0x00000400)        /* Bus-Off Interrupt Enable */
-#define  CAN_IER_LECIE                       ((u32)0x00000800)        /* Last Error Code Interrupt Enable */
-#define  CAN_IER_ERRIE                       ((u32)0x00008000)        /* Error Interrupt Enable */
-#define  CAN_IER_WKUIE                       ((u32)0x00010000)        /* Wakeup Interrupt Enable */
-#define  CAN_IER_SLKIE                       ((u32)0x00020000)        /* Sleep Interrupt Enable */
-
-
-/********************  Bit definition for CAN_ESR register  *******************/
-#define  CAN_ESR_EWGF                        ((u32)0x00000001)        /* Error Warning Flag */
-#define  CAN_ESR_EPVF                        ((u32)0x00000002)        /* Error Passive Flag */
-#define  CAN_ESR_BOFF                        ((u32)0x00000004)        /* Bus-Off Flag */
-
-#define  CAN_ESR_LEC                         ((u32)0x00000070)        /* LEC[2:0] bits (Last Error Code) */
-#define  CAN_ESR_LEC_0                       ((u32)0x00000010)        /* Bit 0 */
-#define  CAN_ESR_LEC_1                       ((u32)0x00000020)        /* Bit 1 */
-#define  CAN_ESR_LEC_2                       ((u32)0x00000040)        /* Bit 2 */
-
-#define  CAN_ESR_TEC                         ((u32)0x00FF0000)        /* Least significant byte of the 9-bit Transmit Error Counter */
-#define  CAN_ESR_REC                         ((u32)0xFF000000)        /* Receive Error Counter */
-
-
-/*******************  Bit definition for CAN_BTR register  ********************/
-#define  CAN_BTR_BRP                         ((u32)0x000003FF)        /* Baud Rate Prescaler */
-#define  CAN_BTR_TS1                         ((u32)0x000F0000)        /* Time Segment 1 */
-#define  CAN_BTR_TS2                         ((u32)0x00700000)        /* Time Segment 2 */
-#define  CAN_BTR_SJW                         ((u32)0x03000000)        /* Resynchronization Jump Width */
-#define  CAN_BTR_LBKM                        ((u32)0x40000000)        /* Loop Back Mode (Debug) */
-#define  CAN_BTR_SILM                        ((u32)0x80000000)        /* Silent Mode */
-
-
-/* Mailbox registers */
-/******************  Bit definition for CAN_TI0R register  ********************/
-#define  CAN_TI0R_TXRQ                       ((u32)0x00000001)        /* Transmit Mailbox Request */
-#define  CAN_TI0R_RTR                        ((u32)0x00000002)        /* Remote Transmission Request */
-#define  CAN_TI0R_IDE                        ((u32)0x00000004)        /* Identifier Extension */
-#define  CAN_TI0R_EXID                       ((u32)0x001FFFF8)        /* Extended Identifier */
-#define  CAN_TI0R_STID                       ((u32)0xFFE00000)        /* Standard Identifier or Extended Identifier */
-
-
-/******************  Bit definition for CAN_TDT0R register  *******************/
-#define  CAN_TDT0R_DLC                       ((u32)0x0000000F)        /* Data Length Code */
-#define  CAN_TDT0R_TGT                       ((u32)0x00000100)        /* Transmit Global Time */
-#define  CAN_TDT0R_TIME                      ((u32)0xFFFF0000)        /* Message Time Stamp */
-
-
-/******************  Bit definition for CAN_TDL0R register  *******************/
-#define  CAN_TDL0R_DATA0                     ((u32)0x000000FF)        /* Data byte 0 */
-#define  CAN_TDL0R_DATA1                     ((u32)0x0000FF00)        /* Data byte 1 */
-#define  CAN_TDL0R_DATA2                     ((u32)0x00FF0000)        /* Data byte 2 */
-#define  CAN_TDL0R_DATA3                     ((u32)0xFF000000)        /* Data byte 3 */
-
-
-/******************  Bit definition for CAN_TDH0R register  *******************/
-#define  CAN_TDH0R_DATA4                     ((u32)0x000000FF)        /* Data byte 4 */
-#define  CAN_TDH0R_DATA5                     ((u32)0x0000FF00)        /* Data byte 5 */
-#define  CAN_TDH0R_DATA6                     ((u32)0x00FF0000)        /* Data byte 6 */
-#define  CAN_TDH0R_DATA7                     ((u32)0xFF000000)        /* Data byte 7 */
-
-
-/*******************  Bit definition for CAN_TI1R register  *******************/
-#define  CAN_TI1R_TXRQ                       ((u32)0x00000001)        /* Transmit Mailbox Request */
-#define  CAN_TI1R_RTR                        ((u32)0x00000002)        /* Remote Transmission Request */
-#define  CAN_TI1R_IDE                        ((u32)0x00000004)        /* Identifier Extension */
-#define  CAN_TI1R_EXID                       ((u32)0x001FFFF8)        /* Extended Identifier */
-#define  CAN_TI1R_STID                       ((u32)0xFFE00000)        /* Standard Identifier or Extended Identifier */
-
-
-/*******************  Bit definition for CAN_TDT1R register  ******************/
-#define  CAN_TDT1R_DLC                       ((u32)0x0000000F)        /* Data Length Code */
-#define  CAN_TDT1R_TGT                       ((u32)0x00000100)        /* Transmit Global Time */
-#define  CAN_TDT1R_TIME                      ((u32)0xFFFF0000)        /* Message Time Stamp */
-
-
-/*******************  Bit definition for CAN_TDL1R register  ******************/
-#define  CAN_TDL1R_DATA0                     ((u32)0x000000FF)        /* Data byte 0 */
-#define  CAN_TDL1R_DATA1                     ((u32)0x0000FF00)        /* Data byte 1 */
-#define  CAN_TDL1R_DATA2                     ((u32)0x00FF0000)        /* Data byte 2 */
-#define  CAN_TDL1R_DATA3                     ((u32)0xFF000000)        /* Data byte 3 */
-
-
-/*******************  Bit definition for CAN_TDH1R register  ******************/
-#define  CAN_TDH1R_DATA4                     ((u32)0x000000FF)        /* Data byte 4 */
-#define  CAN_TDH1R_DATA5                     ((u32)0x0000FF00)        /* Data byte 5 */
-#define  CAN_TDH1R_DATA6                     ((u32)0x00FF0000)        /* Data byte 6 */
-#define  CAN_TDH1R_DATA7                     ((u32)0xFF000000)        /* Data byte 7 */
-
-
-/*******************  Bit definition for CAN_TI2R register  *******************/
-#define  CAN_TI2R_TXRQ                       ((u32)0x00000001)        /* Transmit Mailbox Request */
-#define  CAN_TI2R_RTR                        ((u32)0x00000002)        /* Remote Transmission Request */
-#define  CAN_TI2R_IDE                        ((u32)0x00000004)        /* Identifier Extension */
-#define  CAN_TI2R_EXID                       ((u32)0x001FFFF8)        /* Extended identifier */
-#define  CAN_TI2R_STID                       ((u32)0xFFE00000)        /* Standard Identifier or Extended Identifier */
-
-
-/*******************  Bit definition for CAN_TDT2R register  ******************/  
-#define  CAN_TDT2R_DLC                       ((u32)0x0000000F)        /* Data Length Code */
-#define  CAN_TDT2R_TGT                       ((u32)0x00000100)        /* Transmit Global Time */
-#define  CAN_TDT2R_TIME                      ((u32)0xFFFF0000)        /* Message Time Stamp */
-
-
-/*******************  Bit definition for CAN_TDL2R register  ******************/
-#define  CAN_TDL2R_DATA0                     ((u32)0x000000FF)        /* Data byte 0 */
-#define  CAN_TDL2R_DATA1                     ((u32)0x0000FF00)        /* Data byte 1 */
-#define  CAN_TDL2R_DATA2                     ((u32)0x00FF0000)        /* Data byte 2 */
-#define  CAN_TDL2R_DATA3                     ((u32)0xFF000000)        /* Data byte 3 */
-
-
-/*******************  Bit definition for CAN_TDH2R register  ******************/
-#define  CAN_TDH2R_DATA4                     ((u32)0x000000FF)        /* Data byte 4 */
-#define  CAN_TDH2R_DATA5                     ((u32)0x0000FF00)        /* Data byte 5 */
-#define  CAN_TDH2R_DATA6                     ((u32)0x00FF0000)        /* Data byte 6 */
-#define  CAN_TDH2R_DATA7                     ((u32)0xFF000000)        /* Data byte 7 */
-
-
-/*******************  Bit definition for CAN_RI0R register  *******************/
-#define  CAN_RI0R_RTR                        ((u32)0x00000002)        /* Remote Transmission Request */
-#define  CAN_RI0R_IDE                        ((u32)0x00000004)        /* Identifier Extension */
-#define  CAN_RI0R_EXID                       ((u32)0x001FFFF8)        /* Extended Identifier */
-#define  CAN_RI0R_STID                       ((u32)0xFFE00000)        /* Standard Identifier or Extended Identifier */
-
-
-/*******************  Bit definition for CAN_RDT0R register  ******************/
-#define  CAN_RDT0R_DLC                       ((u32)0x0000000F)        /* Data Length Code */
-#define  CAN_RDT0R_FMI                       ((u32)0x0000FF00)        /* Filter Match Index */
-#define  CAN_RDT0R_TIME                      ((u32)0xFFFF0000)        /* Message Time Stamp */
-
-
-/*******************  Bit definition for CAN_RDL0R register  ******************/
-#define  CAN_RDL0R_DATA0                     ((u32)0x000000FF)        /* Data byte 0 */
-#define  CAN_RDL0R_DATA1                     ((u32)0x0000FF00)        /* Data byte 1 */
-#define  CAN_RDL0R_DATA2                     ((u32)0x00FF0000)        /* Data byte 2 */
-#define  CAN_RDL0R_DATA3                     ((u32)0xFF000000)        /* Data byte 3 */
-
-
-/*******************  Bit definition for CAN_RDH0R register  ******************/
-#define  CAN_RDH0R_DATA4                     ((u32)0x000000FF)        /* Data byte 4 */
-#define  CAN_RDH0R_DATA5                     ((u32)0x0000FF00)        /* Data byte 5 */
-#define  CAN_RDH0R_DATA6                     ((u32)0x00FF0000)        /* Data byte 6 */
-#define  CAN_RDH0R_DATA7                     ((u32)0xFF000000)        /* Data byte 7 */
-
-
-/*******************  Bit definition for CAN_RI1R register  *******************/
-#define  CAN_RI1R_RTR                        ((u32)0x00000002)        /* Remote Transmission Request */
-#define  CAN_RI1R_IDE                        ((u32)0x00000004)        /* Identifier Extension */
-#define  CAN_RI1R_EXID                       ((u32)0x001FFFF8)        /* Extended identifier */
-#define  CAN_RI1R_STID                       ((u32)0xFFE00000)        /* Standard Identifier or Extended Identifier */
-
-
-/*******************  Bit definition for CAN_RDT1R register  ******************/
-#define  CAN_RDT1R_DLC                       ((u32)0x0000000F)        /* Data Length Code */
-#define  CAN_RDT1R_FMI                       ((u32)0x0000FF00)        /* Filter Match Index */
-#define  CAN_RDT1R_TIME                      ((u32)0xFFFF0000)        /* Message Time Stamp */
-
-
-/*******************  Bit definition for CAN_RDL1R register  ******************/
-#define  CAN_RDL1R_DATA0                     ((u32)0x000000FF)        /* Data byte 0 */
-#define  CAN_RDL1R_DATA1                     ((u32)0x0000FF00)        /* Data byte 1 */
-#define  CAN_RDL1R_DATA2                     ((u32)0x00FF0000)        /* Data byte 2 */
-#define  CAN_RDL1R_DATA3                     ((u32)0xFF000000)        /* Data byte 3 */
-
-
-/*******************  Bit definition for CAN_RDH1R register  ******************/
-#define  CAN_RDH1R_DATA4                     ((u32)0x000000FF)        /* Data byte 4 */
-#define  CAN_RDH1R_DATA5                     ((u32)0x0000FF00)        /* Data byte 5 */
-#define  CAN_RDH1R_DATA6                     ((u32)0x00FF0000)        /* Data byte 6 */
-#define  CAN_RDH1R_DATA7                     ((u32)0xFF000000)        /* Data byte 7 */
-
-/* CAN filter registers */
-/*******************  Bit definition for CAN_FMR register  ********************/
-#define  CAN_FMR_FINIT                       ((u8)0x01)               /* Filter Init Mode */
-
-
-/*******************  Bit definition for CAN_FM1R register  *******************/
-#define  CAN_FM1R_FBM                        ((u16)0x3FFF)            /* Filter Mode */
-#define  CAN_FM1R_FBM0                       ((u16)0x0001)            /* Filter Init Mode bit 0 */
-#define  CAN_FM1R_FBM1                       ((u16)0x0002)            /* Filter Init Mode bit 1 */
-#define  CAN_FM1R_FBM2                       ((u16)0x0004)            /* Filter Init Mode bit 2 */
-#define  CAN_FM1R_FBM3                       ((u16)0x0008)            /* Filter Init Mode bit 3 */
-#define  CAN_FM1R_FBM4                       ((u16)0x0010)            /* Filter Init Mode bit 4 */
-#define  CAN_FM1R_FBM5                       ((u16)0x0020)            /* Filter Init Mode bit 5 */
-#define  CAN_FM1R_FBM6                       ((u16)0x0040)            /* Filter Init Mode bit 6 */
-#define  CAN_FM1R_FBM7                       ((u16)0x0080)            /* Filter Init Mode bit 7 */
-#define  CAN_FM1R_FBM8                       ((u16)0x0100)            /* Filter Init Mode bit 8 */
-#define  CAN_FM1R_FBM9                       ((u16)0x0200)            /* Filter Init Mode bit 9 */
-#define  CAN_FM1R_FBM10                      ((u16)0x0400)            /* Filter Init Mode bit 10 */
-#define  CAN_FM1R_FBM11                      ((u16)0x0800)            /* Filter Init Mode bit 11 */
-#define  CAN_FM1R_FBM12                      ((u16)0x1000)            /* Filter Init Mode bit 12 */
-#define  CAN_FM1R_FBM13                      ((u16)0x2000)            /* Filter Init Mode bit 13 */
-
-
-/*******************  Bit definition for CAN_FS1R register  *******************/
-#define  CAN_FS1R_FSC                        ((u16)0x3FFF)            /* Filter Scale Configuration */
-#define  CAN_FS1R_FSC0                       ((u16)0x0001)            /* Filter Scale Configuration bit 0 */
-#define  CAN_FS1R_FSC1                       ((u16)0x0002)            /* Filter Scale Configuration bit 1 */
-#define  CAN_FS1R_FSC2                       ((u16)0x0004)            /* Filter Scale Configuration bit 2 */
-#define  CAN_FS1R_FSC3                       ((u16)0x0008)            /* Filter Scale Configuration bit 3 */
-#define  CAN_FS1R_FSC4                       ((u16)0x0010)            /* Filter Scale Configuration bit 4 */
-#define  CAN_FS1R_FSC5                       ((u16)0x0020)            /* Filter Scale Configuration bit 5 */
-#define  CAN_FS1R_FSC6                       ((u16)0x0040)            /* Filter Scale Configuration bit 6 */
-#define  CAN_FS1R_FSC7                       ((u16)0x0080)            /* Filter Scale Configuration bit 7 */
-#define  CAN_FS1R_FSC8                       ((u16)0x0100)            /* Filter Scale Configuration bit 8 */
-#define  CAN_FS1R_FSC9                       ((u16)0x0200)            /* Filter Scale Configuration bit 9 */
-#define  CAN_FS1R_FSC10                      ((u16)0x0400)            /* Filter Scale Configuration bit 10 */
-#define  CAN_FS1R_FSC11                      ((u16)0x0800)            /* Filter Scale Configuration bit 11 */
-#define  CAN_FS1R_FSC12                      ((u16)0x1000)            /* Filter Scale Configuration bit 12 */
-#define  CAN_FS1R_FSC13                      ((u16)0x2000)            /* Filter Scale Configuration bit 13 */
-
-
-/******************  Bit definition for CAN_FFA1R register  *******************/
-#define  CAN_FFA1R_FFA                       ((u16)0x3FFF)            /* Filter FIFO Assignment */
-#define  CAN_FFA1R_FFA0                      ((u16)0x0001)            /* Filter FIFO Assignment for Filter 0 */
-#define  CAN_FFA1R_FFA1                      ((u16)0x0002)            /* Filter FIFO Assignment for Filter 1 */
-#define  CAN_FFA1R_FFA2                      ((u16)0x0004)            /* Filter FIFO Assignment for Filter 2 */
-#define  CAN_FFA1R_FFA3                      ((u16)0x0008)            /* Filter FIFO Assignment for Filter 3 */
-#define  CAN_FFA1R_FFA4                      ((u16)0x0010)            /* Filter FIFO Assignment for Filter 4 */
-#define  CAN_FFA1R_FFA5                      ((u16)0x0020)            /* Filter FIFO Assignment for Filter 5 */
-#define  CAN_FFA1R_FFA6                      ((u16)0x0040)            /* Filter FIFO Assignment for Filter 6 */
-#define  CAN_FFA1R_FFA7                      ((u16)0x0080)            /* Filter FIFO Assignment for Filter 7 */
-#define  CAN_FFA1R_FFA8                      ((u16)0x0100)            /* Filter FIFO Assignment for Filter 8 */
-#define  CAN_FFA1R_FFA9                      ((u16)0x0200)            /* Filter FIFO Assignment for Filter 9 */
-#define  CAN_FFA1R_FFA10                     ((u16)0x0400)            /* Filter FIFO Assignment for Filter 10 */
-#define  CAN_FFA1R_FFA11                     ((u16)0x0800)            /* Filter FIFO Assignment for Filter 11 */
-#define  CAN_FFA1R_FFA12                     ((u16)0x1000)            /* Filter FIFO Assignment for Filter 12 */
-#define  CAN_FFA1R_FFA13                     ((u16)0x2000)            /* Filter FIFO Assignment for Filter 13 */
-
-
-/*******************  Bit definition for CAN_FA1R register  *******************/
-#define  CAN_FA1R_FACT                       ((u16)0x3FFF)            /* Filter Active */
-#define  CAN_FA1R_FACT0                      ((u16)0x0001)            /* Filter 0 Active */
-#define  CAN_FA1R_FACT1                      ((u16)0x0002)            /* Filter 1 Active */
-#define  CAN_FA1R_FACT2                      ((u16)0x0004)            /* Filter 2 Active */
-#define  CAN_FA1R_FACT3                      ((u16)0x0008)            /* Filter 3 Active */
-#define  CAN_FA1R_FACT4                      ((u16)0x0010)            /* Filter 4 Active */
-#define  CAN_FA1R_FACT5                      ((u16)0x0020)            /* Filter 5 Active */
-#define  CAN_FA1R_FACT6                      ((u16)0x0040)            /* Filter 6 Active */
-#define  CAN_FA1R_FACT7                      ((u16)0x0080)            /* Filter 7 Active */
-#define  CAN_FA1R_FACT8                      ((u16)0x0100)            /* Filter 8 Active */
-#define  CAN_FA1R_FACT9                      ((u16)0x0200)            /* Filter 9 Active */
-#define  CAN_FA1R_FACT10                     ((u16)0x0400)            /* Filter 10 Active */
-#define  CAN_FA1R_FACT11                     ((u16)0x0800)            /* Filter 11 Active */
-#define  CAN_FA1R_FACT12                     ((u16)0x1000)            /* Filter 12 Active */
-#define  CAN_FA1R_FACT13                     ((u16)0x2000)            /* Filter 13 Active */
-
-
-/*******************  Bit definition for CAN_F0R1 register  *******************/
-#define  CAN_F0R1_FB0                        ((u32)0x00000001)        /* Filter bit 0 */
-#define  CAN_F0R1_FB1                        ((u32)0x00000002)        /* Filter bit 1 */
-#define  CAN_F0R1_FB2                        ((u32)0x00000004)        /* Filter bit 2 */
-#define  CAN_F0R1_FB3                        ((u32)0x00000008)        /* Filter bit 3 */
-#define  CAN_F0R1_FB4                        ((u32)0x00000010)        /* Filter bit 4 */
-#define  CAN_F0R1_FB5                        ((u32)0x00000020)        /* Filter bit 5 */
-#define  CAN_F0R1_FB6                        ((u32)0x00000040)        /* Filter bit 6 */
-#define  CAN_F0R1_FB7                        ((u32)0x00000080)        /* Filter bit 7 */
-#define  CAN_F0R1_FB8                        ((u32)0x00000100)        /* Filter bit 8 */
-#define  CAN_F0R1_FB9                        ((u32)0x00000200)        /* Filter bit 9 */
-#define  CAN_F0R1_FB10                       ((u32)0x00000400)        /* Filter bit 10 */
-#define  CAN_F0R1_FB11                       ((u32)0x00000800)        /* Filter bit 11 */
-#define  CAN_F0R1_FB12                       ((u32)0x00001000)        /* Filter bit 12 */
-#define  CAN_F0R1_FB13                       ((u32)0x00002000)        /* Filter bit 13 */
-#define  CAN_F0R1_FB14                       ((u32)0x00004000)        /* Filter bit 14 */
-#define  CAN_F0R1_FB15                       ((u32)0x00008000)        /* Filter bit 15 */
-#define  CAN_F0R1_FB16                       ((u32)0x00010000)        /* Filter bit 16 */
-#define  CAN_F0R1_FB17                       ((u32)0x00020000)        /* Filter bit 17 */
-#define  CAN_F0R1_FB18                       ((u32)0x00040000)        /* Filter bit 18 */
-#define  CAN_F0R1_FB19                       ((u32)0x00080000)        /* Filter bit 19 */
-#define  CAN_F0R1_FB20                       ((u32)0x00100000)        /* Filter bit 20 */
-#define  CAN_F0R1_FB21                       ((u32)0x00200000)        /* Filter bit 21 */
-#define  CAN_F0R1_FB22                       ((u32)0x00400000)        /* Filter bit 22 */
-#define  CAN_F0R1_FB23                       ((u32)0x00800000)        /* Filter bit 23 */
-#define  CAN_F0R1_FB24                       ((u32)0x01000000)        /* Filter bit 24 */
-#define  CAN_F0R1_FB25                       ((u32)0x02000000)        /* Filter bit 25 */
-#define  CAN_F0R1_FB26                       ((u32)0x04000000)        /* Filter bit 26 */
-#define  CAN_F0R1_FB27                       ((u32)0x08000000)        /* Filter bit 27 */
-#define  CAN_F0R1_FB28                       ((u32)0x10000000)        /* Filter bit 28 */
-#define  CAN_F0R1_FB29                       ((u32)0x20000000)        /* Filter bit 29 */
-#define  CAN_F0R1_FB30                       ((u32)0x40000000)        /* Filter bit 30 */
-#define  CAN_F0R1_FB31                       ((u32)0x80000000)        /* Filter bit 31 */
-
-
-/*******************  Bit definition for CAN_F1R1 register  *******************/
-#define  CAN_F1R1_FB0                        ((u32)0x00000001)        /* Filter bit 0 */
-#define  CAN_F1R1_FB1                        ((u32)0x00000002)        /* Filter bit 1 */
-#define  CAN_F1R1_FB2                        ((u32)0x00000004)        /* Filter bit 2 */
-#define  CAN_F1R1_FB3                        ((u32)0x00000008)        /* Filter bit 3 */
-#define  CAN_F1R1_FB4                        ((u32)0x00000010)        /* Filter bit 4 */
-#define  CAN_F1R1_FB5                        ((u32)0x00000020)        /* Filter bit 5 */
-#define  CAN_F1R1_FB6                        ((u32)0x00000040)        /* Filter bit 6 */
-#define  CAN_F1R1_FB7                        ((u32)0x00000080)        /* Filter bit 7 */
-#define  CAN_F1R1_FB8                        ((u32)0x00000100)        /* Filter bit 8 */
-#define  CAN_F1R1_FB9                        ((u32)0x00000200)        /* Filter bit 9 */
-#define  CAN_F1R1_FB10                       ((u32)0x00000400)        /* Filter bit 10 */
-#define  CAN_F1R1_FB11                       ((u32)0x00000800)        /* Filter bit 11 */
-#define  CAN_F1R1_FB12                       ((u32)0x00001000)        /* Filter bit 12 */
-#define  CAN_F1R1_FB13                       ((u32)0x00002000)        /* Filter bit 13 */
-#define  CAN_F1R1_FB14                       ((u32)0x00004000)        /* Filter bit 14 */
-#define  CAN_F1R1_FB15                       ((u32)0x00008000)        /* Filter bit 15 */
-#define  CAN_F1R1_FB16                       ((u32)0x00010000)        /* Filter bit 16 */
-#define  CAN_F1R1_FB17                       ((u32)0x00020000)        /* Filter bit 17 */
-#define  CAN_F1R1_FB18                       ((u32)0x00040000)        /* Filter bit 18 */
-#define  CAN_F1R1_FB19                       ((u32)0x00080000)        /* Filter bit 19 */
-#define  CAN_F1R1_FB20                       ((u32)0x00100000)        /* Filter bit 20 */
-#define  CAN_F1R1_FB21                       ((u32)0x00200000)        /* Filter bit 21 */
-#define  CAN_F1R1_FB22                       ((u32)0x00400000)        /* Filter bit 22 */
-#define  CAN_F1R1_FB23                       ((u32)0x00800000)        /* Filter bit 23 */
-#define  CAN_F1R1_FB24                       ((u32)0x01000000)        /* Filter bit 24 */
-#define  CAN_F1R1_FB25                       ((u32)0x02000000)        /* Filter bit 25 */
-#define  CAN_F1R1_FB26                       ((u32)0x04000000)        /* Filter bit 26 */
-#define  CAN_F1R1_FB27                       ((u32)0x08000000)        /* Filter bit 27 */
-#define  CAN_F1R1_FB28                       ((u32)0x10000000)        /* Filter bit 28 */
-#define  CAN_F1R1_FB29                       ((u32)0x20000000)        /* Filter bit 29 */
-#define  CAN_F1R1_FB30                       ((u32)0x40000000)        /* Filter bit 30 */
-#define  CAN_F1R1_FB31                       ((u32)0x80000000)        /* Filter bit 31 */
-
-
-/*******************  Bit definition for CAN_F2R1 register  *******************/
-#define  CAN_F2R1_FB0                        ((u32)0x00000001)        /* Filter bit 0 */
-#define  CAN_F2R1_FB1                        ((u32)0x00000002)        /* Filter bit 1 */
-#define  CAN_F2R1_FB2                        ((u32)0x00000004)        /* Filter bit 2 */
-#define  CAN_F2R1_FB3                        ((u32)0x00000008)        /* Filter bit 3 */
-#define  CAN_F2R1_FB4                        ((u32)0x00000010)        /* Filter bit 4 */
-#define  CAN_F2R1_FB5                        ((u32)0x00000020)        /* Filter bit 5 */
-#define  CAN_F2R1_FB6                        ((u32)0x00000040)        /* Filter bit 6 */
-#define  CAN_F2R1_FB7                        ((u32)0x00000080)        /* Filter bit 7 */
-#define  CAN_F2R1_FB8                        ((u32)0x00000100)        /* Filter bit 8 */
-#define  CAN_F2R1_FB9                        ((u32)0x00000200)        /* Filter bit 9 */
-#define  CAN_F2R1_FB10                       ((u32)0x00000400)        /* Filter bit 10 */
-#define  CAN_F2R1_FB11                       ((u32)0x00000800)        /* Filter bit 11 */
-#define  CAN_F2R1_FB12                       ((u32)0x00001000)        /* Filter bit 12 */
-#define  CAN_F2R1_FB13                       ((u32)0x00002000)        /* Filter bit 13 */
-#define  CAN_F2R1_FB14                       ((u32)0x00004000)        /* Filter bit 14 */
-#define  CAN_F2R1_FB15                       ((u32)0x00008000)        /* Filter bit 15 */
-#define  CAN_F2R1_FB16                       ((u32)0x00010000)        /* Filter bit 16 */
-#define  CAN_F2R1_FB17                       ((u32)0x00020000)        /* Filter bit 17 */
-#define  CAN_F2R1_FB18                       ((u32)0x00040000)        /* Filter bit 18 */
-#define  CAN_F2R1_FB19                       ((u32)0x00080000)        /* Filter bit 19 */
-#define  CAN_F2R1_FB20                       ((u32)0x00100000)        /* Filter bit 20 */
-#define  CAN_F2R1_FB21                       ((u32)0x00200000)        /* Filter bit 21 */
-#define  CAN_F2R1_FB22                       ((u32)0x00400000)        /* Filter bit 22 */
-#define  CAN_F2R1_FB23                       ((u32)0x00800000)        /* Filter bit 23 */
-#define  CAN_F2R1_FB24                       ((u32)0x01000000)        /* Filter bit 24 */
-#define  CAN_F2R1_FB25                       ((u32)0x02000000)        /* Filter bit 25 */
-#define  CAN_F2R1_FB26                       ((u32)0x04000000)        /* Filter bit 26 */
-#define  CAN_F2R1_FB27                       ((u32)0x08000000)        /* Filter bit 27 */
-#define  CAN_F2R1_FB28                       ((u32)0x10000000)        /* Filter bit 28 */
-#define  CAN_F2R1_FB29                       ((u32)0x20000000)        /* Filter bit 29 */
-#define  CAN_F2R1_FB30                       ((u32)0x40000000)        /* Filter bit 30 */
-#define  CAN_F2R1_FB31                       ((u32)0x80000000)        /* Filter bit 31 */
-
-
-/*******************  Bit definition for CAN_F3R1 register  *******************/
-#define  CAN_F3R1_FB0                        ((u32)0x00000001)        /* Filter bit 0 */
-#define  CAN_F3R1_FB1                        ((u32)0x00000002)        /* Filter bit 1 */
-#define  CAN_F3R1_FB2                        ((u32)0x00000004)        /* Filter bit 2 */
-#define  CAN_F3R1_FB3                        ((u32)0x00000008)        /* Filter bit 3 */
-#define  CAN_F3R1_FB4                        ((u32)0x00000010)        /* Filter bit 4 */
-#define  CAN_F3R1_FB5                        ((u32)0x00000020)        /* Filter bit 5 */
-#define  CAN_F3R1_FB6                        ((u32)0x00000040)        /* Filter bit 6 */
-#define  CAN_F3R1_FB7                        ((u32)0x00000080)        /* Filter bit 7 */
-#define  CAN_F3R1_FB8                        ((u32)0x00000100)        /* Filter bit 8 */
-#define  CAN_F3R1_FB9                        ((u32)0x00000200)        /* Filter bit 9 */
-#define  CAN_F3R1_FB10                       ((u32)0x00000400)        /* Filter bit 10 */
-#define  CAN_F3R1_FB11                       ((u32)0x00000800)        /* Filter bit 11 */
-#define  CAN_F3R1_FB12                       ((u32)0x00001000)        /* Filter bit 12 */
-#define  CAN_F3R1_FB13                       ((u32)0x00002000)        /* Filter bit 13 */
-#define  CAN_F3R1_FB14                       ((u32)0x00004000)        /* Filter bit 14 */
-#define  CAN_F3R1_FB15                       ((u32)0x00008000)        /* Filter bit 15 */
-#define  CAN_F3R1_FB16                       ((u32)0x00010000)        /* Filter bit 16 */
-#define  CAN_F3R1_FB17                       ((u32)0x00020000)        /* Filter bit 17 */
-#define  CAN_F3R1_FB18                       ((u32)0x00040000)        /* Filter bit 18 */
-#define  CAN_F3R1_FB19                       ((u32)0x00080000)        /* Filter bit 19 */
-#define  CAN_F3R1_FB20                       ((u32)0x00100000)        /* Filter bit 20 */
-#define  CAN_F3R1_FB21                       ((u32)0x00200000)        /* Filter bit 21 */
-#define  CAN_F3R1_FB22                       ((u32)0x00400000)        /* Filter bit 22 */
-#define  CAN_F3R1_FB23                       ((u32)0x00800000)        /* Filter bit 23 */
-#define  CAN_F3R1_FB24                       ((u32)0x01000000)        /* Filter bit 24 */
-#define  CAN_F3R1_FB25                       ((u32)0x02000000)        /* Filter bit 25 */
-#define  CAN_F3R1_FB26                       ((u32)0x04000000)        /* Filter bit 26 */
-#define  CAN_F3R1_FB27                       ((u32)0x08000000)        /* Filter bit 27 */
-#define  CAN_F3R1_FB28                       ((u32)0x10000000)        /* Filter bit 28 */
-#define  CAN_F3R1_FB29                       ((u32)0x20000000)        /* Filter bit 29 */
-#define  CAN_F3R1_FB30                       ((u32)0x40000000)        /* Filter bit 30 */
-#define  CAN_F3R1_FB31                       ((u32)0x80000000)        /* Filter bit 31 */
-
-
-/*******************  Bit definition for CAN_F4R1 register  *******************/
-#define  CAN_F4R1_FB0                        ((u32)0x00000001)        /* Filter bit 0 */
-#define  CAN_F4R1_FB1                        ((u32)0x00000002)        /* Filter bit 1 */
-#define  CAN_F4R1_FB2                        ((u32)0x00000004)        /* Filter bit 2 */
-#define  CAN_F4R1_FB3                        ((u32)0x00000008)        /* Filter bit 3 */
-#define  CAN_F4R1_FB4                        ((u32)0x00000010)        /* Filter bit 4 */
-#define  CAN_F4R1_FB5                        ((u32)0x00000020)        /* Filter bit 5 */
-#define  CAN_F4R1_FB6                        ((u32)0x00000040)        /* Filter bit 6 */
-#define  CAN_F4R1_FB7                        ((u32)0x00000080)        /* Filter bit 7 */
-#define  CAN_F4R1_FB8                        ((u32)0x00000100)        /* Filter bit 8 */
-#define  CAN_F4R1_FB9                        ((u32)0x00000200)        /* Filter bit 9 */
-#define  CAN_F4R1_FB10                       ((u32)0x00000400)        /* Filter bit 10 */
-#define  CAN_F4R1_FB11                       ((u32)0x00000800)        /* Filter bit 11 */
-#define  CAN_F4R1_FB12                       ((u32)0x00001000)        /* Filter bit 12 */
-#define  CAN_F4R1_FB13                       ((u32)0x00002000)        /* Filter bit 13 */
-#define  CAN_F4R1_FB14                       ((u32)0x00004000)        /* Filter bit 14 */
-#define  CAN_F4R1_FB15                       ((u32)0x00008000)        /* Filter bit 15 */
-#define  CAN_F4R1_FB16                       ((u32)0x00010000)        /* Filter bit 16 */
-#define  CAN_F4R1_FB17                       ((u32)0x00020000)        /* Filter bit 17 */
-#define  CAN_F4R1_FB18                       ((u32)0x00040000)        /* Filter bit 18 */
-#define  CAN_F4R1_FB19                       ((u32)0x00080000)        /* Filter bit 19 */
-#define  CAN_F4R1_FB20                       ((u32)0x00100000)        /* Filter bit 20 */
-#define  CAN_F4R1_FB21                       ((u32)0x00200000)        /* Filter bit 21 */
-#define  CAN_F4R1_FB22                       ((u32)0x00400000)        /* Filter bit 22 */
-#define  CAN_F4R1_FB23                       ((u32)0x00800000)        /* Filter bit 23 */
-#define  CAN_F4R1_FB24                       ((u32)0x01000000)        /* Filter bit 24 */
-#define  CAN_F4R1_FB25                       ((u32)0x02000000)        /* Filter bit 25 */
-#define  CAN_F4R1_FB26                       ((u32)0x04000000)        /* Filter bit 26 */
-#define  CAN_F4R1_FB27                       ((u32)0x08000000)        /* Filter bit 27 */
-#define  CAN_F4R1_FB28                       ((u32)0x10000000)        /* Filter bit 28 */
-#define  CAN_F4R1_FB29                       ((u32)0x20000000)        /* Filter bit 29 */
-#define  CAN_F4R1_FB30                       ((u32)0x40000000)        /* Filter bit 30 */
-#define  CAN_F4R1_FB31                       ((u32)0x80000000)        /* Filter bit 31 */
-
-
-/*******************  Bit definition for CAN_F5R1 register  *******************/
-#define  CAN_F5R1_FB0                        ((u32)0x00000001)        /* Filter bit 0 */
-#define  CAN_F5R1_FB1                        ((u32)0x00000002)        /* Filter bit 1 */
-#define  CAN_F5R1_FB2                        ((u32)0x00000004)        /* Filter bit 2 */
-#define  CAN_F5R1_FB3                        ((u32)0x00000008)        /* Filter bit 3 */
-#define  CAN_F5R1_FB4                        ((u32)0x00000010)        /* Filter bit 4 */
-#define  CAN_F5R1_FB5                        ((u32)0x00000020)        /* Filter bit 5 */
-#define  CAN_F5R1_FB6                        ((u32)0x00000040)        /* Filter bit 6 */
-#define  CAN_F5R1_FB7                        ((u32)0x00000080)        /* Filter bit 7 */
-#define  CAN_F5R1_FB8                        ((u32)0x00000100)        /* Filter bit 8 */
-#define  CAN_F5R1_FB9                        ((u32)0x00000200)        /* Filter bit 9 */
-#define  CAN_F5R1_FB10                       ((u32)0x00000400)        /* Filter bit 10 */
-#define  CAN_F5R1_FB11                       ((u32)0x00000800)        /* Filter bit 11 */
-#define  CAN_F5R1_FB12                       ((u32)0x00001000)        /* Filter bit 12 */
-#define  CAN_F5R1_FB13                       ((u32)0x00002000)        /* Filter bit 13 */
-#define  CAN_F5R1_FB14                       ((u32)0x00004000)        /* Filter bit 14 */
-#define  CAN_F5R1_FB15                       ((u32)0x00008000)        /* Filter bit 15 */
-#define  CAN_F5R1_FB16                       ((u32)0x00010000)        /* Filter bit 16 */
-#define  CAN_F5R1_FB17                       ((u32)0x00020000)        /* Filter bit 17 */
-#define  CAN_F5R1_FB18                       ((u32)0x00040000)        /* Filter bit 18 */
-#define  CAN_F5R1_FB19                       ((u32)0x00080000)        /* Filter bit 19 */
-#define  CAN_F5R1_FB20                       ((u32)0x00100000)        /* Filter bit 20 */
-#define  CAN_F5R1_FB21                       ((u32)0x00200000)        /* Filter bit 21 */
-#define  CAN_F5R1_FB22                       ((u32)0x00400000)        /* Filter bit 22 */
-#define  CAN_F5R1_FB23                       ((u32)0x00800000)        /* Filter bit 23 */
-#define  CAN_F5R1_FB24                       ((u32)0x01000000)        /* Filter bit 24 */
-#define  CAN_F5R1_FB25                       ((u32)0x02000000)        /* Filter bit 25 */
-#define  CAN_F5R1_FB26                       ((u32)0x04000000)        /* Filter bit 26 */
-#define  CAN_F5R1_FB27                       ((u32)0x08000000)        /* Filter bit 27 */
-#define  CAN_F5R1_FB28                       ((u32)0x10000000)        /* Filter bit 28 */
-#define  CAN_F5R1_FB29                       ((u32)0x20000000)        /* Filter bit 29 */
-#define  CAN_F5R1_FB30                       ((u32)0x40000000)        /* Filter bit 30 */
-#define  CAN_F5R1_FB31                       ((u32)0x80000000)        /* Filter bit 31 */
-
-
-/*******************  Bit definition for CAN_F6R1 register  *******************/
-#define  CAN_F6R1_FB0                        ((u32)0x00000001)        /* Filter bit 0 */
-#define  CAN_F6R1_FB1                        ((u32)0x00000002)        /* Filter bit 1 */
-#define  CAN_F6R1_FB2                        ((u32)0x00000004)        /* Filter bit 2 */
-#define  CAN_F6R1_FB3                        ((u32)0x00000008)        /* Filter bit 3 */
-#define  CAN_F6R1_FB4                        ((u32)0x00000010)        /* Filter bit 4 */
-#define  CAN_F6R1_FB5                        ((u32)0x00000020)        /* Filter bit 5 */
-#define  CAN_F6R1_FB6                        ((u32)0x00000040)        /* Filter bit 6 */
-#define  CAN_F6R1_FB7                        ((u32)0x00000080)        /* Filter bit 7 */
-#define  CAN_F6R1_FB8                        ((u32)0x00000100)        /* Filter bit 8 */
-#define  CAN_F6R1_FB9                        ((u32)0x00000200)        /* Filter bit 9 */
-#define  CAN_F6R1_FB10                       ((u32)0x00000400)        /* Filter bit 10 */
-#define  CAN_F6R1_FB11                       ((u32)0x00000800)        /* Filter bit 11 */
-#define  CAN_F6R1_FB12                       ((u32)0x00001000)        /* Filter bit 12 */
-#define  CAN_F6R1_FB13                       ((u32)0x00002000)        /* Filter bit 13 */
-#define  CAN_F6R1_FB14                       ((u32)0x00004000)        /* Filter bit 14 */
-#define  CAN_F6R1_FB15                       ((u32)0x00008000)        /* Filter bit 15 */
-#define  CAN_F6R1_FB16                       ((u32)0x00010000)        /* Filter bit 16 */
-#define  CAN_F6R1_FB17                       ((u32)0x00020000)        /* Filter bit 17 */
-#define  CAN_F6R1_FB18                       ((u32)0x00040000)        /* Filter bit 18 */
-#define  CAN_F6R1_FB19                       ((u32)0x00080000)        /* Filter bit 19 */
-#define  CAN_F6R1_FB20                       ((u32)0x00100000)        /* Filter bit 20 */
-#define  CAN_F6R1_FB21                       ((u32)0x00200000)        /* Filter bit 21 */
-#define  CAN_F6R1_FB22                       ((u32)0x00400000)        /* Filter bit 22 */
-#define  CAN_F6R1_FB23                       ((u32)0x00800000)        /* Filter bit 23 */
-#define  CAN_F6R1_FB24                       ((u32)0x01000000)        /* Filter bit 24 */
-#define  CAN_F6R1_FB25                       ((u32)0x02000000)        /* Filter bit 25 */
-#define  CAN_F6R1_FB26                       ((u32)0x04000000)        /* Filter bit 26 */
-#define  CAN_F6R1_FB27                       ((u32)0x08000000)        /* Filter bit 27 */
-#define  CAN_F6R1_FB28                       ((u32)0x10000000)        /* Filter bit 28 */
-#define  CAN_F6R1_FB29                       ((u32)0x20000000)        /* Filter bit 29 */
-#define  CAN_F6R1_FB30                       ((u32)0x40000000)        /* Filter bit 30 */
-#define  CAN_F6R1_FB31                       ((u32)0x80000000)        /* Filter bit 31 */
-
-
-/*******************  Bit definition for CAN_F7R1 register  *******************/
-#define  CAN_F7R1_FB0                        ((u32)0x00000001)        /* Filter bit 0 */
-#define  CAN_F7R1_FB1                        ((u32)0x00000002)        /* Filter bit 1 */
-#define  CAN_F7R1_FB2                        ((u32)0x00000004)        /* Filter bit 2 */
-#define  CAN_F7R1_FB3                        ((u32)0x00000008)        /* Filter bit 3 */
-#define  CAN_F7R1_FB4                        ((u32)0x00000010)        /* Filter bit 4 */
-#define  CAN_F7R1_FB5                        ((u32)0x00000020)        /* Filter bit 5 */
-#define  CAN_F7R1_FB6                        ((u32)0x00000040)        /* Filter bit 6 */
-#define  CAN_F7R1_FB7                        ((u32)0x00000080)        /* Filter bit 7 */
-#define  CAN_F7R1_FB8                        ((u32)0x00000100)        /* Filter bit 8 */
-#define  CAN_F7R1_FB9                        ((u32)0x00000200)        /* Filter bit 9 */
-#define  CAN_F7R1_FB10                       ((u32)0x00000400)        /* Filter bit 10 */
-#define  CAN_F7R1_FB11                       ((u32)0x00000800)        /* Filter bit 11 */
-#define  CAN_F7R1_FB12                       ((u32)0x00001000)        /* Filter bit 12 */
-#define  CAN_F7R1_FB13                       ((u32)0x00002000)        /* Filter bit 13 */
-#define  CAN_F7R1_FB14                       ((u32)0x00004000)        /* Filter bit 14 */
-#define  CAN_F7R1_FB15                       ((u32)0x00008000)        /* Filter bit 15 */
-#define  CAN_F7R1_FB16                       ((u32)0x00010000)        /* Filter bit 16 */
-#define  CAN_F7R1_FB17                       ((u32)0x00020000)        /* Filter bit 17 */
-#define  CAN_F7R1_FB18                       ((u32)0x00040000)        /* Filter bit 18 */
-#define  CAN_F7R1_FB19                       ((u32)0x00080000)        /* Filter bit 19 */
-#define  CAN_F7R1_FB20                       ((u32)0x00100000)        /* Filter bit 20 */
-#define  CAN_F7R1_FB21                       ((u32)0x00200000)        /* Filter bit 21 */
-#define  CAN_F7R1_FB22                       ((u32)0x00400000)        /* Filter bit 22 */
-#define  CAN_F7R1_FB23                       ((u32)0x00800000)        /* Filter bit 23 */
-#define  CAN_F7R1_FB24                       ((u32)0x01000000)        /* Filter bit 24 */
-#define  CAN_F7R1_FB25                       ((u32)0x02000000)        /* Filter bit 25 */
-#define  CAN_F7R1_FB26                       ((u32)0x04000000)        /* Filter bit 26 */
-#define  CAN_F7R1_FB27                       ((u32)0x08000000)        /* Filter bit 27 */
-#define  CAN_F7R1_FB28                       ((u32)0x10000000)        /* Filter bit 28 */
-#define  CAN_F7R1_FB29                       ((u32)0x20000000)        /* Filter bit 29 */
-#define  CAN_F7R1_FB30                       ((u32)0x40000000)        /* Filter bit 30 */
-#define  CAN_F7R1_FB31                       ((u32)0x80000000)        /* Filter bit 31 */
-
-
-/*******************  Bit definition for CAN_F8R1 register  *******************/
-#define  CAN_F8R1_FB0                        ((u32)0x00000001)        /* Filter bit 0 */
-#define  CAN_F8R1_FB1                        ((u32)0x00000002)        /* Filter bit 1 */
-#define  CAN_F8R1_FB2                        ((u32)0x00000004)        /* Filter bit 2 */
-#define  CAN_F8R1_FB3                        ((u32)0x00000008)        /* Filter bit 3 */
-#define  CAN_F8R1_FB4                        ((u32)0x00000010)        /* Filter bit 4 */
-#define  CAN_F8R1_FB5                        ((u32)0x00000020)        /* Filter bit 5 */
-#define  CAN_F8R1_FB6                        ((u32)0x00000040)        /* Filter bit 6 */
-#define  CAN_F8R1_FB7                        ((u32)0x00000080)        /* Filter bit 7 */
-#define  CAN_F8R1_FB8                        ((u32)0x00000100)        /* Filter bit 8 */
-#define  CAN_F8R1_FB9                        ((u32)0x00000200)        /* Filter bit 9 */
-#define  CAN_F8R1_FB10                       ((u32)0x00000400)        /* Filter bit 10 */
-#define  CAN_F8R1_FB11                       ((u32)0x00000800)        /* Filter bit 11 */
-#define  CAN_F8R1_FB12                       ((u32)0x00001000)        /* Filter bit 12 */
-#define  CAN_F8R1_FB13                       ((u32)0x00002000)        /* Filter bit 13 */
-#define  CAN_F8R1_FB14                       ((u32)0x00004000)        /* Filter bit 14 */
-#define  CAN_F8R1_FB15                       ((u32)0x00008000)        /* Filter bit 15 */
-#define  CAN_F8R1_FB16                       ((u32)0x00010000)        /* Filter bit 16 */
-#define  CAN_F8R1_FB17                       ((u32)0x00020000)        /* Filter bit 17 */
-#define  CAN_F8R1_FB18                       ((u32)0x00040000)        /* Filter bit 18 */
-#define  CAN_F8R1_FB19                       ((u32)0x00080000)        /* Filter bit 19 */
-#define  CAN_F8R1_FB20                       ((u32)0x00100000)        /* Filter bit 20 */
-#define  CAN_F8R1_FB21                       ((u32)0x00200000)        /* Filter bit 21 */
-#define  CAN_F8R1_FB22                       ((u32)0x00400000)        /* Filter bit 22 */
-#define  CAN_F8R1_FB23                       ((u32)0x00800000)        /* Filter bit 23 */
-#define  CAN_F8R1_FB24                       ((u32)0x01000000)        /* Filter bit 24 */
-#define  CAN_F8R1_FB25                       ((u32)0x02000000)        /* Filter bit 25 */
-#define  CAN_F8R1_FB26                       ((u32)0x04000000)        /* Filter bit 26 */
-#define  CAN_F8R1_FB27                       ((u32)0x08000000)        /* Filter bit 27 */
-#define  CAN_F8R1_FB28                       ((u32)0x10000000)        /* Filter bit 28 */
-#define  CAN_F8R1_FB29                       ((u32)0x20000000)        /* Filter bit 29 */
-#define  CAN_F8R1_FB30                       ((u32)0x40000000)        /* Filter bit 30 */
-#define  CAN_F8R1_FB31                       ((u32)0x80000000)        /* Filter bit 31 */
-
-
-/*******************  Bit definition for CAN_F9R1 register  *******************/
-#define  CAN_F9R1_FB0                        ((u32)0x00000001)        /* Filter bit 0 */
-#define  CAN_F9R1_FB1                        ((u32)0x00000002)        /* Filter bit 1 */
-#define  CAN_F9R1_FB2                        ((u32)0x00000004)        /* Filter bit 2 */
-#define  CAN_F9R1_FB3                        ((u32)0x00000008)        /* Filter bit 3 */
-#define  CAN_F9R1_FB4                        ((u32)0x00000010)        /* Filter bit 4 */
-#define  CAN_F9R1_FB5                        ((u32)0x00000020)        /* Filter bit 5 */
-#define  CAN_F9R1_FB6                        ((u32)0x00000040)        /* Filter bit 6 */
-#define  CAN_F9R1_FB7                        ((u32)0x00000080)        /* Filter bit 7 */
-#define  CAN_F9R1_FB8                        ((u32)0x00000100)        /* Filter bit 8 */
-#define  CAN_F9R1_FB9                        ((u32)0x00000200)        /* Filter bit 9 */
-#define  CAN_F9R1_FB10                       ((u32)0x00000400)        /* Filter bit 10 */
-#define  CAN_F9R1_FB11                       ((u32)0x00000800)        /* Filter bit 11 */
-#define  CAN_F9R1_FB12                       ((u32)0x00001000)        /* Filter bit 12 */
-#define  CAN_F9R1_FB13                       ((u32)0x00002000)        /* Filter bit 13 */
-#define  CAN_F9R1_FB14                       ((u32)0x00004000)        /* Filter bit 14 */
-#define  CAN_F9R1_FB15                       ((u32)0x00008000)        /* Filter bit 15 */
-#define  CAN_F9R1_FB16                       ((u32)0x00010000)        /* Filter bit 16 */
-#define  CAN_F9R1_FB17                       ((u32)0x00020000)        /* Filter bit 17 */
-#define  CAN_F9R1_FB18                       ((u32)0x00040000)        /* Filter bit 18 */
-#define  CAN_F9R1_FB19                       ((u32)0x00080000)        /* Filter bit 19 */
-#define  CAN_F9R1_FB20                       ((u32)0x00100000)        /* Filter bit 20 */
-#define  CAN_F9R1_FB21                       ((u32)0x00200000)        /* Filter bit 21 */
-#define  CAN_F9R1_FB22                       ((u32)0x00400000)        /* Filter bit 22 */
-#define  CAN_F9R1_FB23                       ((u32)0x00800000)        /* Filter bit 23 */
-#define  CAN_F9R1_FB24                       ((u32)0x01000000)        /* Filter bit 24 */
-#define  CAN_F9R1_FB25                       ((u32)0x02000000)        /* Filter bit 25 */
-#define  CAN_F9R1_FB26                       ((u32)0x04000000)        /* Filter bit 26 */
-#define  CAN_F9R1_FB27                       ((u32)0x08000000)        /* Filter bit 27 */
-#define  CAN_F9R1_FB28                       ((u32)0x10000000)        /* Filter bit 28 */
-#define  CAN_F9R1_FB29                       ((u32)0x20000000)        /* Filter bit 29 */
-#define  CAN_F9R1_FB30                       ((u32)0x40000000)        /* Filter bit 30 */
-#define  CAN_F9R1_FB31                       ((u32)0x80000000)        /* Filter bit 31 */
-
-
-/*******************  Bit definition for CAN_F10R1 register  ******************/
-#define  CAN_F10R1_FB0                       ((u32)0x00000001)        /* Filter bit 0 */
-#define  CAN_F10R1_FB1                       ((u32)0x00000002)        /* Filter bit 1 */
-#define  CAN_F10R1_FB2                       ((u32)0x00000004)        /* Filter bit 2 */
-#define  CAN_F10R1_FB3                       ((u32)0x00000008)        /* Filter bit 3 */
-#define  CAN_F10R1_FB4                       ((u32)0x00000010)        /* Filter bit 4 */
-#define  CAN_F10R1_FB5                       ((u32)0x00000020)        /* Filter bit 5 */
-#define  CAN_F10R1_FB6                       ((u32)0x00000040)        /* Filter bit 6 */
-#define  CAN_F10R1_FB7                       ((u32)0x00000080)        /* Filter bit 7 */
-#define  CAN_F10R1_FB8                       ((u32)0x00000100)        /* Filter bit 8 */
-#define  CAN_F10R1_FB9                       ((u32)0x00000200)        /* Filter bit 9 */
-#define  CAN_F10R1_FB10                      ((u32)0x00000400)        /* Filter bit 10 */
-#define  CAN_F10R1_FB11                      ((u32)0x00000800)        /* Filter bit 11 */
-#define  CAN_F10R1_FB12                      ((u32)0x00001000)        /* Filter bit 12 */
-#define  CAN_F10R1_FB13                      ((u32)0x00002000)        /* Filter bit 13 */
-#define  CAN_F10R1_FB14                      ((u32)0x00004000)        /* Filter bit 14 */
-#define  CAN_F10R1_FB15                      ((u32)0x00008000)        /* Filter bit 15 */
-#define  CAN_F10R1_FB16                      ((u32)0x00010000)        /* Filter bit 16 */
-#define  CAN_F10R1_FB17                      ((u32)0x00020000)        /* Filter bit 17 */
-#define  CAN_F10R1_FB18                      ((u32)0x00040000)        /* Filter bit 18 */
-#define  CAN_F10R1_FB19                      ((u32)0x00080000)        /* Filter bit 19 */
-#define  CAN_F10R1_FB20                      ((u32)0x00100000)        /* Filter bit 20 */
-#define  CAN_F10R1_FB21                      ((u32)0x00200000)        /* Filter bit 21 */
-#define  CAN_F10R1_FB22                      ((u32)0x00400000)        /* Filter bit 22 */
-#define  CAN_F10R1_FB23                      ((u32)0x00800000)        /* Filter bit 23 */
-#define  CAN_F10R1_FB24                      ((u32)0x01000000)        /* Filter bit 24 */
-#define  CAN_F10R1_FB25                      ((u32)0x02000000)        /* Filter bit 25 */
-#define  CAN_F10R1_FB26                      ((u32)0x04000000)        /* Filter bit 26 */
-#define  CAN_F10R1_FB27                      ((u32)0x08000000)        /* Filter bit 27 */
-#define  CAN_F10R1_FB28                      ((u32)0x10000000)        /* Filter bit 28 */
-#define  CAN_F10R1_FB29                      ((u32)0x20000000)        /* Filter bit 29 */
-#define  CAN_F10R1_FB30                      ((u32)0x40000000)        /* Filter bit 30 */
-#define  CAN_F10R1_FB31                      ((u32)0x80000000)        /* Filter bit 31 */
-
-
-/*******************  Bit definition for CAN_F11R1 register  ******************/
-#define  CAN_F11R1_FB0                       ((u32)0x00000001)        /* Filter bit 0 */
-#define  CAN_F11R1_FB1                       ((u32)0x00000002)        /* Filter bit 1 */
-#define  CAN_F11R1_FB2                       ((u32)0x00000004)        /* Filter bit 2 */
-#define  CAN_F11R1_FB3                       ((u32)0x00000008)        /* Filter bit 3 */
-#define  CAN_F11R1_FB4                       ((u32)0x00000010)        /* Filter bit 4 */
-#define  CAN_F11R1_FB5                       ((u32)0x00000020)        /* Filter bit 5 */
-#define  CAN_F11R1_FB6                       ((u32)0x00000040)        /* Filter bit 6 */
-#define  CAN_F11R1_FB7                       ((u32)0x00000080)        /* Filter bit 7 */
-#define  CAN_F11R1_FB8                       ((u32)0x00000100)        /* Filter bit 8 */
-#define  CAN_F11R1_FB9                       ((u32)0x00000200)        /* Filter bit 9 */
-#define  CAN_F11R1_FB10                      ((u32)0x00000400)        /* Filter bit 10 */
-#define  CAN_F11R1_FB11                      ((u32)0x00000800)        /* Filter bit 11 */
-#define  CAN_F11R1_FB12                      ((u32)0x00001000)        /* Filter bit 12 */
-#define  CAN_F11R1_FB13                      ((u32)0x00002000)        /* Filter bit 13 */
-#define  CAN_F11R1_FB14                      ((u32)0x00004000)        /* Filter bit 14 */
-#define  CAN_F11R1_FB15                      ((u32)0x00008000)        /* Filter bit 15 */
-#define  CAN_F11R1_FB16                      ((u32)0x00010000)        /* Filter bit 16 */
-#define  CAN_F11R1_FB17                      ((u32)0x00020000)        /* Filter bit 17 */
-#define  CAN_F11R1_FB18                      ((u32)0x00040000)        /* Filter bit 18 */
-#define  CAN_F11R1_FB19                      ((u32)0x00080000)        /* Filter bit 19 */
-#define  CAN_F11R1_FB20                      ((u32)0x00100000)        /* Filter bit 20 */
-#define  CAN_F11R1_FB21                      ((u32)0x00200000)        /* Filter bit 21 */
-#define  CAN_F11R1_FB22                      ((u32)0x00400000)        /* Filter bit 22 */
-#define  CAN_F11R1_FB23                      ((u32)0x00800000)        /* Filter bit 23 */
-#define  CAN_F11R1_FB24                      ((u32)0x01000000)        /* Filter bit 24 */
-#define  CAN_F11R1_FB25                      ((u32)0x02000000)        /* Filter bit 25 */
-#define  CAN_F11R1_FB26                      ((u32)0x04000000)        /* Filter bit 26 */
-#define  CAN_F11R1_FB27                      ((u32)0x08000000)        /* Filter bit 27 */
-#define  CAN_F11R1_FB28                      ((u32)0x10000000)        /* Filter bit 28 */
-#define  CAN_F11R1_FB29                      ((u32)0x20000000)        /* Filter bit 29 */
-#define  CAN_F11R1_FB30                      ((u32)0x40000000)        /* Filter bit 30 */
-#define  CAN_F11R1_FB31                      ((u32)0x80000000)        /* Filter bit 31 */
-
-
-/*******************  Bit definition for CAN_F12R1 register  ******************/
-#define  CAN_F12R1_FB0                       ((u32)0x00000001)        /* Filter bit 0 */
-#define  CAN_F12R1_FB1                       ((u32)0x00000002)        /* Filter bit 1 */
-#define  CAN_F12R1_FB2                       ((u32)0x00000004)        /* Filter bit 2 */
-#define  CAN_F12R1_FB3                       ((u32)0x00000008)        /* Filter bit 3 */
-#define  CAN_F12R1_FB4                       ((u32)0x00000010)        /* Filter bit 4 */
-#define  CAN_F12R1_FB5                       ((u32)0x00000020)        /* Filter bit 5 */
-#define  CAN_F12R1_FB6                       ((u32)0x00000040)        /* Filter bit 6 */
-#define  CAN_F12R1_FB7                       ((u32)0x00000080)        /* Filter bit 7 */
-#define  CAN_F12R1_FB8                       ((u32)0x00000100)        /* Filter bit 8 */
-#define  CAN_F12R1_FB9                       ((u32)0x00000200)        /* Filter bit 9 */
-#define  CAN_F12R1_FB10                      ((u32)0x00000400)        /* Filter bit 10 */
-#define  CAN_F12R1_FB11                      ((u32)0x00000800)        /* Filter bit 11 */
-#define  CAN_F12R1_FB12                      ((u32)0x00001000)        /* Filter bit 12 */
-#define  CAN_F12R1_FB13                      ((u32)0x00002000)        /* Filter bit 13 */
-#define  CAN_F12R1_FB14                      ((u32)0x00004000)        /* Filter bit 14 */
-#define  CAN_F12R1_FB15                      ((u32)0x00008000)        /* Filter bit 15 */
-#define  CAN_F12R1_FB16                      ((u32)0x00010000)        /* Filter bit 16 */
-#define  CAN_F12R1_FB17                      ((u32)0x00020000)        /* Filter bit 17 */
-#define  CAN_F12R1_FB18                      ((u32)0x00040000)        /* Filter bit 18 */
-#define  CAN_F12R1_FB19                      ((u32)0x00080000)        /* Filter bit 19 */
-#define  CAN_F12R1_FB20                      ((u32)0x00100000)        /* Filter bit 20 */
-#define  CAN_F12R1_FB21                      ((u32)0x00200000)        /* Filter bit 21 */
-#define  CAN_F12R1_FB22                      ((u32)0x00400000)        /* Filter bit 22 */
-#define  CAN_F12R1_FB23                      ((u32)0x00800000)        /* Filter bit 23 */
-#define  CAN_F12R1_FB24                      ((u32)0x01000000)        /* Filter bit 24 */
-#define  CAN_F12R1_FB25                      ((u32)0x02000000)        /* Filter bit 25 */
-#define  CAN_F12R1_FB26                      ((u32)0x04000000)        /* Filter bit 26 */
-#define  CAN_F12R1_FB27                      ((u32)0x08000000)        /* Filter bit 27 */
-#define  CAN_F12R1_FB28                      ((u32)0x10000000)        /* Filter bit 28 */
-#define  CAN_F12R1_FB29                      ((u32)0x20000000)        /* Filter bit 29 */
-#define  CAN_F12R1_FB30                      ((u32)0x40000000)        /* Filter bit 30 */
-#define  CAN_F12R1_FB31                      ((u32)0x80000000)        /* Filter bit 31 */
-
-
-/*******************  Bit definition for CAN_F13R1 register  ******************/
-#define  CAN_F13R1_FB0                       ((u32)0x00000001)        /* Filter bit 0 */
-#define  CAN_F13R1_FB1                       ((u32)0x00000002)        /* Filter bit 1 */
-#define  CAN_F13R1_FB2                       ((u32)0x00000004)        /* Filter bit 2 */
-#define  CAN_F13R1_FB3                       ((u32)0x00000008)        /* Filter bit 3 */
-#define  CAN_F13R1_FB4                       ((u32)0x00000010)        /* Filter bit 4 */
-#define  CAN_F13R1_FB5                       ((u32)0x00000020)        /* Filter bit 5 */
-#define  CAN_F13R1_FB6                       ((u32)0x00000040)        /* Filter bit 6 */
-#define  CAN_F13R1_FB7                       ((u32)0x00000080)        /* Filter bit 7 */
-#define  CAN_F13R1_FB8                       ((u32)0x00000100)        /* Filter bit 8 */
-#define  CAN_F13R1_FB9                       ((u32)0x00000200)        /* Filter bit 9 */
-#define  CAN_F13R1_FB10                      ((u32)0x00000400)        /* Filter bit 10 */
-#define  CAN_F13R1_FB11                      ((u32)0x00000800)        /* Filter bit 11 */
-#define  CAN_F13R1_FB12                      ((u32)0x00001000)        /* Filter bit 12 */
-#define  CAN_F13R1_FB13                      ((u32)0x00002000)        /* Filter bit 13 */
-#define  CAN_F13R1_FB14                      ((u32)0x00004000)        /* Filter bit 14 */
-#define  CAN_F13R1_FB15                      ((u32)0x00008000)        /* Filter bit 15 */
-#define  CAN_F13R1_FB16                      ((u32)0x00010000)        /* Filter bit 16 */
-#define  CAN_F13R1_FB17                      ((u32)0x00020000)        /* Filter bit 17 */
-#define  CAN_F13R1_FB18                      ((u32)0x00040000)        /* Filter bit 18 */
-#define  CAN_F13R1_FB19                      ((u32)0x00080000)        /* Filter bit 19 */
-#define  CAN_F13R1_FB20                      ((u32)0x00100000)        /* Filter bit 20 */
-#define  CAN_F13R1_FB21                      ((u32)0x00200000)        /* Filter bit 21 */
-#define  CAN_F13R1_FB22                      ((u32)0x00400000)        /* Filter bit 22 */
-#define  CAN_F13R1_FB23                      ((u32)0x00800000)        /* Filter bit 23 */
-#define  CAN_F13R1_FB24                      ((u32)0x01000000)        /* Filter bit 24 */
-#define  CAN_F13R1_FB25                      ((u32)0x02000000)        /* Filter bit 25 */
-#define  CAN_F13R1_FB26                      ((u32)0x04000000)        /* Filter bit 26 */
-#define  CAN_F13R1_FB27                      ((u32)0x08000000)        /* Filter bit 27 */
-#define  CAN_F13R1_FB28                      ((u32)0x10000000)        /* Filter bit 28 */
-#define  CAN_F13R1_FB29                      ((u32)0x20000000)        /* Filter bit 29 */
-#define  CAN_F13R1_FB30                      ((u32)0x40000000)        /* Filter bit 30 */
-#define  CAN_F13R1_FB31                      ((u32)0x80000000)        /* Filter bit 31 */
-
-
-/*******************  Bit definition for CAN_F0R2 register  *******************/
-#define  CAN_F0R2_FB0                        ((u32)0x00000001)        /* Filter bit 0 */
-#define  CAN_F0R2_FB1                        ((u32)0x00000002)        /* Filter bit 1 */
-#define  CAN_F0R2_FB2                        ((u32)0x00000004)        /* Filter bit 2 */
-#define  CAN_F0R2_FB3                        ((u32)0x00000008)        /* Filter bit 3 */
-#define  CAN_F0R2_FB4                        ((u32)0x00000010)        /* Filter bit 4 */
-#define  CAN_F0R2_FB5                        ((u32)0x00000020)        /* Filter bit 5 */
-#define  CAN_F0R2_FB6                        ((u32)0x00000040)        /* Filter bit 6 */
-#define  CAN_F0R2_FB7                        ((u32)0x00000080)        /* Filter bit 7 */
-#define  CAN_F0R2_FB8                        ((u32)0x00000100)        /* Filter bit 8 */
-#define  CAN_F0R2_FB9                        ((u32)0x00000200)        /* Filter bit 9 */
-#define  CAN_F0R2_FB10                       ((u32)0x00000400)        /* Filter bit 10 */
-#define  CAN_F0R2_FB11                       ((u32)0x00000800)        /* Filter bit 11 */
-#define  CAN_F0R2_FB12                       ((u32)0x00001000)        /* Filter bit 12 */
-#define  CAN_F0R2_FB13                       ((u32)0x00002000)        /* Filter bit 13 */
-#define  CAN_F0R2_FB14                       ((u32)0x00004000)        /* Filter bit 14 */
-#define  CAN_F0R2_FB15                       ((u32)0x00008000)        /* Filter bit 15 */
-#define  CAN_F0R2_FB16                       ((u32)0x00010000)        /* Filter bit 16 */
-#define  CAN_F0R2_FB17                       ((u32)0x00020000)        /* Filter bit 17 */
-#define  CAN_F0R2_FB18                       ((u32)0x00040000)        /* Filter bit 18 */
-#define  CAN_F0R2_FB19                       ((u32)0x00080000)        /* Filter bit 19 */
-#define  CAN_F0R2_FB20                       ((u32)0x00100000)        /* Filter bit 20 */
-#define  CAN_F0R2_FB21                       ((u32)0x00200000)        /* Filter bit 21 */
-#define  CAN_F0R2_FB22                       ((u32)0x00400000)        /* Filter bit 22 */
-#define  CAN_F0R2_FB23                       ((u32)0x00800000)        /* Filter bit 23 */
-#define  CAN_F0R2_FB24                       ((u32)0x01000000)        /* Filter bit 24 */
-#define  CAN_F0R2_FB25                       ((u32)0x02000000)        /* Filter bit 25 */
-#define  CAN_F0R2_FB26                       ((u32)0x04000000)        /* Filter bit 26 */
-#define  CAN_F0R2_FB27                       ((u32)0x08000000)        /* Filter bit 27 */
-#define  CAN_F0R2_FB28                       ((u32)0x10000000)        /* Filter bit 28 */
-#define  CAN_F0R2_FB29                       ((u32)0x20000000)        /* Filter bit 29 */
-#define  CAN_F0R2_FB30                       ((u32)0x40000000)        /* Filter bit 30 */
-#define  CAN_F0R2_FB31                       ((u32)0x80000000)        /* Filter bit 31 */
-
-
-/*******************  Bit definition for CAN_F1R2 register  *******************/
-#define  CAN_F1R2_FB0                        ((u32)0x00000001)        /* Filter bit 0 */
-#define  CAN_F1R2_FB1                        ((u32)0x00000002)        /* Filter bit 1 */
-#define  CAN_F1R2_FB2                        ((u32)0x00000004)        /* Filter bit 2 */
-#define  CAN_F1R2_FB3                        ((u32)0x00000008)        /* Filter bit 3 */
-#define  CAN_F1R2_FB4                        ((u32)0x00000010)        /* Filter bit 4 */
-#define  CAN_F1R2_FB5                        ((u32)0x00000020)        /* Filter bit 5 */
-#define  CAN_F1R2_FB6                        ((u32)0x00000040)        /* Filter bit 6 */
-#define  CAN_F1R2_FB7                        ((u32)0x00000080)        /* Filter bit 7 */
-#define  CAN_F1R2_FB8                        ((u32)0x00000100)        /* Filter bit 8 */
-#define  CAN_F1R2_FB9                        ((u32)0x00000200)        /* Filter bit 9 */
-#define  CAN_F1R2_FB10                       ((u32)0x00000400)        /* Filter bit 10 */
-#define  CAN_F1R2_FB11                       ((u32)0x00000800)        /* Filter bit 11 */
-#define  CAN_F1R2_FB12                       ((u32)0x00001000)        /* Filter bit 12 */
-#define  CAN_F1R2_FB13                       ((u32)0x00002000)        /* Filter bit 13 */
-#define  CAN_F1R2_FB14                       ((u32)0x00004000)        /* Filter bit 14 */
-#define  CAN_F1R2_FB15                       ((u32)0x00008000)        /* Filter bit 15 */
-#define  CAN_F1R2_FB16                       ((u32)0x00010000)        /* Filter bit 16 */
-#define  CAN_F1R2_FB17                       ((u32)0x00020000)        /* Filter bit 17 */
-#define  CAN_F1R2_FB18                       ((u32)0x00040000)        /* Filter bit 18 */
-#define  CAN_F1R2_FB19                       ((u32)0x00080000)        /* Filter bit 19 */
-#define  CAN_F1R2_FB20                       ((u32)0x00100000)        /* Filter bit 20 */
-#define  CAN_F1R2_FB21                       ((u32)0x00200000)        /* Filter bit 21 */
-#define  CAN_F1R2_FB22                       ((u32)0x00400000)        /* Filter bit 22 */
-#define  CAN_F1R2_FB23                       ((u32)0x00800000)        /* Filter bit 23 */
-#define  CAN_F1R2_FB24                       ((u32)0x01000000)        /* Filter bit 24 */
-#define  CAN_F1R2_FB25                       ((u32)0x02000000)        /* Filter bit 25 */
-#define  CAN_F1R2_FB26                       ((u32)0x04000000)        /* Filter bit 26 */
-#define  CAN_F1R2_FB27                       ((u32)0x08000000)        /* Filter bit 27 */
-#define  CAN_F1R2_FB28                       ((u32)0x10000000)        /* Filter bit 28 */
-#define  CAN_F1R2_FB29                       ((u32)0x20000000)        /* Filter bit 29 */
-#define  CAN_F1R2_FB30                       ((u32)0x40000000)        /* Filter bit 30 */
-#define  CAN_F1R2_FB31                       ((u32)0x80000000)        /* Filter bit 31 */
-
-
-/*******************  Bit definition for CAN_F2R2 register  *******************/
-#define  CAN_F2R2_FB0                        ((u32)0x00000001)        /* Filter bit 0 */
-#define  CAN_F2R2_FB1                        ((u32)0x00000002)        /* Filter bit 1 */
-#define  CAN_F2R2_FB2                        ((u32)0x00000004)        /* Filter bit 2 */
-#define  CAN_F2R2_FB3                        ((u32)0x00000008)        /* Filter bit 3 */
-#define  CAN_F2R2_FB4                        ((u32)0x00000010)        /* Filter bit 4 */
-#define  CAN_F2R2_FB5                        ((u32)0x00000020)        /* Filter bit 5 */
-#define  CAN_F2R2_FB6                        ((u32)0x00000040)        /* Filter bit 6 */
-#define  CAN_F2R2_FB7                        ((u32)0x00000080)        /* Filter bit 7 */
-#define  CAN_F2R2_FB8                        ((u32)0x00000100)        /* Filter bit 8 */
-#define  CAN_F2R2_FB9                        ((u32)0x00000200)        /* Filter bit 9 */
-#define  CAN_F2R2_FB10                       ((u32)0x00000400)        /* Filter bit 10 */
-#define  CAN_F2R2_FB11                       ((u32)0x00000800)        /* Filter bit 11 */
-#define  CAN_F2R2_FB12                       ((u32)0x00001000)        /* Filter bit 12 */
-#define  CAN_F2R2_FB13                       ((u32)0x00002000)        /* Filter bit 13 */
-#define  CAN_F2R2_FB14                       ((u32)0x00004000)        /* Filter bit 14 */
-#define  CAN_F2R2_FB15                       ((u32)0x00008000)        /* Filter bit 15 */
-#define  CAN_F2R2_FB16                       ((u32)0x00010000)        /* Filter bit 16 */
-#define  CAN_F2R2_FB17                       ((u32)0x00020000)        /* Filter bit 17 */
-#define  CAN_F2R2_FB18                       ((u32)0x00040000)        /* Filter bit 18 */
-#define  CAN_F2R2_FB19                       ((u32)0x00080000)        /* Filter bit 19 */
-#define  CAN_F2R2_FB20                       ((u32)0x00100000)        /* Filter bit 20 */
-#define  CAN_F2R2_FB21                       ((u32)0x00200000)        /* Filter bit 21 */
-#define  CAN_F2R2_FB22                       ((u32)0x00400000)        /* Filter bit 22 */
-#define  CAN_F2R2_FB23                       ((u32)0x00800000)        /* Filter bit 23 */
-#define  CAN_F2R2_FB24                       ((u32)0x01000000)        /* Filter bit 24 */
-#define  CAN_F2R2_FB25                       ((u32)0x02000000)        /* Filter bit 25 */
-#define  CAN_F2R2_FB26                       ((u32)0x04000000)        /* Filter bit 26 */
-#define  CAN_F2R2_FB27                       ((u32)0x08000000)        /* Filter bit 27 */
-#define  CAN_F2R2_FB28                       ((u32)0x10000000)        /* Filter bit 28 */
-#define  CAN_F2R2_FB29                       ((u32)0x20000000)        /* Filter bit 29 */
-#define  CAN_F2R2_FB30                       ((u32)0x40000000)        /* Filter bit 30 */
-#define  CAN_F2R2_FB31                       ((u32)0x80000000)        /* Filter bit 31 */
-
-
-/*******************  Bit definition for CAN_F3R2 register  *******************/
-#define  CAN_F3R2_FB0                        ((u32)0x00000001)        /* Filter bit 0 */
-#define  CAN_F3R2_FB1                        ((u32)0x00000002)        /* Filter bit 1 */
-#define  CAN_F3R2_FB2                        ((u32)0x00000004)        /* Filter bit 2 */
-#define  CAN_F3R2_FB3                        ((u32)0x00000008)        /* Filter bit 3 */
-#define  CAN_F3R2_FB4                        ((u32)0x00000010)        /* Filter bit 4 */
-#define  CAN_F3R2_FB5                        ((u32)0x00000020)        /* Filter bit 5 */
-#define  CAN_F3R2_FB6                        ((u32)0x00000040)        /* Filter bit 6 */
-#define  CAN_F3R2_FB7                        ((u32)0x00000080)        /* Filter bit 7 */
-#define  CAN_F3R2_FB8                        ((u32)0x00000100)        /* Filter bit 8 */
-#define  CAN_F3R2_FB9                        ((u32)0x00000200)        /* Filter bit 9 */
-#define  CAN_F3R2_FB10                       ((u32)0x00000400)        /* Filter bit 10 */
-#define  CAN_F3R2_FB11                       ((u32)0x00000800)        /* Filter bit 11 */
-#define  CAN_F3R2_FB12                       ((u32)0x00001000)        /* Filter bit 12 */
-#define  CAN_F3R2_FB13                       ((u32)0x00002000)        /* Filter bit 13 */
-#define  CAN_F3R2_FB14                       ((u32)0x00004000)        /* Filter bit 14 */
-#define  CAN_F3R2_FB15                       ((u32)0x00008000)        /* Filter bit 15 */
-#define  CAN_F3R2_FB16                       ((u32)0x00010000)        /* Filter bit 16 */
-#define  CAN_F3R2_FB17                       ((u32)0x00020000)        /* Filter bit 17 */
-#define  CAN_F3R2_FB18                       ((u32)0x00040000)        /* Filter bit 18 */
-#define  CAN_F3R2_FB19                       ((u32)0x00080000)        /* Filter bit 19 */
-#define  CAN_F3R2_FB20                       ((u32)0x00100000)        /* Filter bit 20 */
-#define  CAN_F3R2_FB21                       ((u32)0x00200000)        /* Filter bit 21 */
-#define  CAN_F3R2_FB22                       ((u32)0x00400000)        /* Filter bit 22 */
-#define  CAN_F3R2_FB23                       ((u32)0x00800000)        /* Filter bit 23 */
-#define  CAN_F3R2_FB24                       ((u32)0x01000000)        /* Filter bit 24 */
-#define  CAN_F3R2_FB25                       ((u32)0x02000000)        /* Filter bit 25 */
-#define  CAN_F3R2_FB26                       ((u32)0x04000000)        /* Filter bit 26 */
-#define  CAN_F3R2_FB27                       ((u32)0x08000000)        /* Filter bit 27 */
-#define  CAN_F3R2_FB28                       ((u32)0x10000000)        /* Filter bit 28 */
-#define  CAN_F3R2_FB29                       ((u32)0x20000000)        /* Filter bit 29 */
-#define  CAN_F3R2_FB30                       ((u32)0x40000000)        /* Filter bit 30 */
-#define  CAN_F3R2_FB31                       ((u32)0x80000000)        /* Filter bit 31 */
-
-
-/*******************  Bit definition for CAN_F4R2 register  *******************/
-#define  CAN_F4R2_FB0                        ((u32)0x00000001)        /* Filter bit 0 */
-#define  CAN_F4R2_FB1                        ((u32)0x00000002)        /* Filter bit 1 */
-#define  CAN_F4R2_FB2                        ((u32)0x00000004)        /* Filter bit 2 */
-#define  CAN_F4R2_FB3                        ((u32)0x00000008)        /* Filter bit 3 */
-#define  CAN_F4R2_FB4                        ((u32)0x00000010)        /* Filter bit 4 */
-#define  CAN_F4R2_FB5                        ((u32)0x00000020)        /* Filter bit 5 */
-#define  CAN_F4R2_FB6                        ((u32)0x00000040)        /* Filter bit 6 */
-#define  CAN_F4R2_FB7                        ((u32)0x00000080)        /* Filter bit 7 */
-#define  CAN_F4R2_FB8                        ((u32)0x00000100)        /* Filter bit 8 */
-#define  CAN_F4R2_FB9                        ((u32)0x00000200)        /* Filter bit 9 */
-#define  CAN_F4R2_FB10                       ((u32)0x00000400)        /* Filter bit 10 */
-#define  CAN_F4R2_FB11                       ((u32)0x00000800)        /* Filter bit 11 */
-#define  CAN_F4R2_FB12                       ((u32)0x00001000)        /* Filter bit 12 */
-#define  CAN_F4R2_FB13                       ((u32)0x00002000)        /* Filter bit 13 */
-#define  CAN_F4R2_FB14                       ((u32)0x00004000)        /* Filter bit 14 */
-#define  CAN_F4R2_FB15                       ((u32)0x00008000)        /* Filter bit 15 */
-#define  CAN_F4R2_FB16                       ((u32)0x00010000)        /* Filter bit 16 */
-#define  CAN_F4R2_FB17                       ((u32)0x00020000)        /* Filter bit 17 */
-#define  CAN_F4R2_FB18                       ((u32)0x00040000)        /* Filter bit 18 */
-#define  CAN_F4R2_FB19                       ((u32)0x00080000)        /* Filter bit 19 */
-#define  CAN_F4R2_FB20                       ((u32)0x00100000)        /* Filter bit 20 */
-#define  CAN_F4R2_FB21                       ((u32)0x00200000)        /* Filter bit 21 */
-#define  CAN_F4R2_FB22                       ((u32)0x00400000)        /* Filter bit 22 */
-#define  CAN_F4R2_FB23                       ((u32)0x00800000)        /* Filter bit 23 */
-#define  CAN_F4R2_FB24                       ((u32)0x01000000)        /* Filter bit 24 */
-#define  CAN_F4R2_FB25                       ((u32)0x02000000)        /* Filter bit 25 */
-#define  CAN_F4R2_FB26                       ((u32)0x04000000)        /* Filter bit 26 */
-#define  CAN_F4R2_FB27                       ((u32)0x08000000)        /* Filter bit 27 */
-#define  CAN_F4R2_FB28                       ((u32)0x10000000)        /* Filter bit 28 */
-#define  CAN_F4R2_FB29                       ((u32)0x20000000)        /* Filter bit 29 */
-#define  CAN_F4R2_FB30                       ((u32)0x40000000)        /* Filter bit 30 */
-#define  CAN_F4R2_FB31                       ((u32)0x80000000)        /* Filter bit 31 */
-
-
-/*******************  Bit definition for CAN_F5R2 register  *******************/
-#define  CAN_F5R2_FB0                        ((u32)0x00000001)        /* Filter bit 0 */
-#define  CAN_F5R2_FB1                        ((u32)0x00000002)        /* Filter bit 1 */
-#define  CAN_F5R2_FB2                        ((u32)0x00000004)        /* Filter bit 2 */
-#define  CAN_F5R2_FB3                        ((u32)0x00000008)        /* Filter bit 3 */
-#define  CAN_F5R2_FB4                        ((u32)0x00000010)        /* Filter bit 4 */
-#define  CAN_F5R2_FB5                        ((u32)0x00000020)        /* Filter bit 5 */
-#define  CAN_F5R2_FB6                        ((u32)0x00000040)        /* Filter bit 6 */
-#define  CAN_F5R2_FB7                        ((u32)0x00000080)        /* Filter bit 7 */
-#define  CAN_F5R2_FB8                        ((u32)0x00000100)        /* Filter bit 8 */
-#define  CAN_F5R2_FB9                        ((u32)0x00000200)        /* Filter bit 9 */
-#define  CAN_F5R2_FB10                       ((u32)0x00000400)        /* Filter bit 10 */
-#define  CAN_F5R2_FB11                       ((u32)0x00000800)        /* Filter bit 11 */
-#define  CAN_F5R2_FB12                       ((u32)0x00001000)        /* Filter bit 12 */
-#define  CAN_F5R2_FB13                       ((u32)0x00002000)        /* Filter bit 13 */
-#define  CAN_F5R2_FB14                       ((u32)0x00004000)        /* Filter bit 14 */
-#define  CAN_F5R2_FB15                       ((u32)0x00008000)        /* Filter bit 15 */
-#define  CAN_F5R2_FB16                       ((u32)0x00010000)        /* Filter bit 16 */
-#define  CAN_F5R2_FB17                       ((u32)0x00020000)        /* Filter bit 17 */
-#define  CAN_F5R2_FB18                       ((u32)0x00040000)        /* Filter bit 18 */
-#define  CAN_F5R2_FB19                       ((u32)0x00080000)        /* Filter bit 19 */
-#define  CAN_F5R2_FB20                       ((u32)0x00100000)        /* Filter bit 20 */
-#define  CAN_F5R2_FB21                       ((u32)0x00200000)        /* Filter bit 21 */
-#define  CAN_F5R2_FB22                       ((u32)0x00400000)        /* Filter bit 22 */
-#define  CAN_F5R2_FB23                       ((u32)0x00800000)        /* Filter bit 23 */
-#define  CAN_F5R2_FB24                       ((u32)0x01000000)        /* Filter bit 24 */
-#define  CAN_F5R2_FB25                       ((u32)0x02000000)        /* Filter bit 25 */
-#define  CAN_F5R2_FB26                       ((u32)0x04000000)        /* Filter bit 26 */
-#define  CAN_F5R2_FB27                       ((u32)0x08000000)        /* Filter bit 27 */
-#define  CAN_F5R2_FB28                       ((u32)0x10000000)        /* Filter bit 28 */
-#define  CAN_F5R2_FB29                       ((u32)0x20000000)        /* Filter bit 29 */
-#define  CAN_F5R2_FB30                       ((u32)0x40000000)        /* Filter bit 30 */
-#define  CAN_F5R2_FB31                       ((u32)0x80000000)        /* Filter bit 31 */
-
-
-/*******************  Bit definition for CAN_F6R2 register  *******************/
-#define  CAN_F6R2_FB0                        ((u32)0x00000001)        /* Filter bit 0 */
-#define  CAN_F6R2_FB1                        ((u32)0x00000002)        /* Filter bit 1 */
-#define  CAN_F6R2_FB2                        ((u32)0x00000004)        /* Filter bit 2 */
-#define  CAN_F6R2_FB3                        ((u32)0x00000008)        /* Filter bit 3 */
-#define  CAN_F6R2_FB4                        ((u32)0x00000010)        /* Filter bit 4 */
-#define  CAN_F6R2_FB5                        ((u32)0x00000020)        /* Filter bit 5 */
-#define  CAN_F6R2_FB6                        ((u32)0x00000040)        /* Filter bit 6 */
-#define  CAN_F6R2_FB7                        ((u32)0x00000080)        /* Filter bit 7 */
-#define  CAN_F6R2_FB8                        ((u32)0x00000100)        /* Filter bit 8 */
-#define  CAN_F6R2_FB9                        ((u32)0x00000200)        /* Filter bit 9 */
-#define  CAN_F6R2_FB10                       ((u32)0x00000400)        /* Filter bit 10 */
-#define  CAN_F6R2_FB11                       ((u32)0x00000800)        /* Filter bit 11 */
-#define  CAN_F6R2_FB12                       ((u32)0x00001000)        /* Filter bit 12 */
-#define  CAN_F6R2_FB13                       ((u32)0x00002000)        /* Filter bit 13 */
-#define  CAN_F6R2_FB14                       ((u32)0x00004000)        /* Filter bit 14 */
-#define  CAN_F6R2_FB15                       ((u32)0x00008000)        /* Filter bit 15 */
-#define  CAN_F6R2_FB16                       ((u32)0x00010000)        /* Filter bit 16 */
-#define  CAN_F6R2_FB17                       ((u32)0x00020000)        /* Filter bit 17 */
-#define  CAN_F6R2_FB18                       ((u32)0x00040000)        /* Filter bit 18 */
-#define  CAN_F6R2_FB19                       ((u32)0x00080000)        /* Filter bit 19 */
-#define  CAN_F6R2_FB20                       ((u32)0x00100000)        /* Filter bit 20 */
-#define  CAN_F6R2_FB21                       ((u32)0x00200000)        /* Filter bit 21 */
-#define  CAN_F6R2_FB22                       ((u32)0x00400000)        /* Filter bit 22 */
-#define  CAN_F6R2_FB23                       ((u32)0x00800000)        /* Filter bit 23 */
-#define  CAN_F6R2_FB24                       ((u32)0x01000000)        /* Filter bit 24 */
-#define  CAN_F6R2_FB25                       ((u32)0x02000000)        /* Filter bit 25 */
-#define  CAN_F6R2_FB26                       ((u32)0x04000000)        /* Filter bit 26 */
-#define  CAN_F6R2_FB27                       ((u32)0x08000000)        /* Filter bit 27 */
-#define  CAN_F6R2_FB28                       ((u32)0x10000000)        /* Filter bit 28 */
-#define  CAN_F6R2_FB29                       ((u32)0x20000000)        /* Filter bit 29 */
-#define  CAN_F6R2_FB30                       ((u32)0x40000000)        /* Filter bit 30 */
-#define  CAN_F6R2_FB31                       ((u32)0x80000000)        /* Filter bit 31 */
-
-
-/*******************  Bit definition for CAN_F7R2 register  *******************/
-#define  CAN_F7R2_FB0                        ((u32)0x00000001)        /* Filter bit 0 */
-#define  CAN_F7R2_FB1                        ((u32)0x00000002)        /* Filter bit 1 */
-#define  CAN_F7R2_FB2                        ((u32)0x00000004)        /* Filter bit 2 */
-#define  CAN_F7R2_FB3                        ((u32)0x00000008)        /* Filter bit 3 */
-#define  CAN_F7R2_FB4                        ((u32)0x00000010)        /* Filter bit 4 */
-#define  CAN_F7R2_FB5                        ((u32)0x00000020)        /* Filter bit 5 */
-#define  CAN_F7R2_FB6                        ((u32)0x00000040)        /* Filter bit 6 */
-#define  CAN_F7R2_FB7                        ((u32)0x00000080)        /* Filter bit 7 */
-#define  CAN_F7R2_FB8                        ((u32)0x00000100)        /* Filter bit 8 */
-#define  CAN_F7R2_FB9                        ((u32)0x00000200)        /* Filter bit 9 */
-#define  CAN_F7R2_FB10                       ((u32)0x00000400)        /* Filter bit 10 */
-#define  CAN_F7R2_FB11                       ((u32)0x00000800)        /* Filter bit 11 */
-#define  CAN_F7R2_FB12                       ((u32)0x00001000)        /* Filter bit 12 */
-#define  CAN_F7R2_FB13                       ((u32)0x00002000)        /* Filter bit 13 */
-#define  CAN_F7R2_FB14                       ((u32)0x00004000)        /* Filter bit 14 */
-#define  CAN_F7R2_FB15                       ((u32)0x00008000)        /* Filter bit 15 */
-#define  CAN_F7R2_FB16                       ((u32)0x00010000)        /* Filter bit 16 */
-#define  CAN_F7R2_FB17                       ((u32)0x00020000)        /* Filter bit 17 */
-#define  CAN_F7R2_FB18                       ((u32)0x00040000)        /* Filter bit 18 */
-#define  CAN_F7R2_FB19                       ((u32)0x00080000)        /* Filter bit 19 */
-#define  CAN_F7R2_FB20                       ((u32)0x00100000)        /* Filter bit 20 */
-#define  CAN_F7R2_FB21                       ((u32)0x00200000)        /* Filter bit 21 */
-#define  CAN_F7R2_FB22                       ((u32)0x00400000)        /* Filter bit 22 */
-#define  CAN_F7R2_FB23                       ((u32)0x00800000)        /* Filter bit 23 */
-#define  CAN_F7R2_FB24                       ((u32)0x01000000)        /* Filter bit 24 */
-#define  CAN_F7R2_FB25                       ((u32)0x02000000)        /* Filter bit 25 */
-#define  CAN_F7R2_FB26                       ((u32)0x04000000)        /* Filter bit 26 */
-#define  CAN_F7R2_FB27                       ((u32)0x08000000)        /* Filter bit 27 */
-#define  CAN_F7R2_FB28                       ((u32)0x10000000)        /* Filter bit 28 */
-#define  CAN_F7R2_FB29                       ((u32)0x20000000)        /* Filter bit 29 */
-#define  CAN_F7R2_FB30                       ((u32)0x40000000)        /* Filter bit 30 */
-#define  CAN_F7R2_FB31                       ((u32)0x80000000)        /* Filter bit 31 */
-
-
-/*******************  Bit definition for CAN_F8R2 register  *******************/
-#define  CAN_F8R2_FB0                        ((u32)0x00000001)        /* Filter bit 0 */
-#define  CAN_F8R2_FB1                        ((u32)0x00000002)        /* Filter bit 1 */
-#define  CAN_F8R2_FB2                        ((u32)0x00000004)        /* Filter bit 2 */
-#define  CAN_F8R2_FB3                        ((u32)0x00000008)        /* Filter bit 3 */
-#define  CAN_F8R2_FB4                        ((u32)0x00000010)        /* Filter bit 4 */
-#define  CAN_F8R2_FB5                        ((u32)0x00000020)        /* Filter bit 5 */
-#define  CAN_F8R2_FB6                        ((u32)0x00000040)        /* Filter bit 6 */
-#define  CAN_F8R2_FB7                        ((u32)0x00000080)        /* Filter bit 7 */
-#define  CAN_F8R2_FB8                        ((u32)0x00000100)        /* Filter bit 8 */
-#define  CAN_F8R2_FB9                        ((u32)0x00000200)        /* Filter bit 9 */
-#define  CAN_F8R2_FB10                       ((u32)0x00000400)        /* Filter bit 10 */
-#define  CAN_F8R2_FB11                       ((u32)0x00000800)        /* Filter bit 11 */
-#define  CAN_F8R2_FB12                       ((u32)0x00001000)        /* Filter bit 12 */
-#define  CAN_F8R2_FB13                       ((u32)0x00002000)        /* Filter bit 13 */
-#define  CAN_F8R2_FB14                       ((u32)0x00004000)        /* Filter bit 14 */
-#define  CAN_F8R2_FB15                       ((u32)0x00008000)        /* Filter bit 15 */
-#define  CAN_F8R2_FB16                       ((u32)0x00010000)        /* Filter bit 16 */
-#define  CAN_F8R2_FB17                       ((u32)0x00020000)        /* Filter bit 17 */
-#define  CAN_F8R2_FB18                       ((u32)0x00040000)        /* Filter bit 18 */
-#define  CAN_F8R2_FB19                       ((u32)0x00080000)        /* Filter bit 19 */
-#define  CAN_F8R2_FB20                       ((u32)0x00100000)        /* Filter bit 20 */
-#define  CAN_F8R2_FB21                       ((u32)0x00200000)        /* Filter bit 21 */
-#define  CAN_F8R2_FB22                       ((u32)0x00400000)        /* Filter bit 22 */
-#define  CAN_F8R2_FB23                       ((u32)0x00800000)        /* Filter bit 23 */
-#define  CAN_F8R2_FB24                       ((u32)0x01000000)        /* Filter bit 24 */
-#define  CAN_F8R2_FB25                       ((u32)0x02000000)        /* Filter bit 25 */
-#define  CAN_F8R2_FB26                       ((u32)0x04000000)        /* Filter bit 26 */
-#define  CAN_F8R2_FB27                       ((u32)0x08000000)        /* Filter bit 27 */
-#define  CAN_F8R2_FB28                       ((u32)0x10000000)        /* Filter bit 28 */
-#define  CAN_F8R2_FB29                       ((u32)0x20000000)        /* Filter bit 29 */
-#define  CAN_F8R2_FB30                       ((u32)0x40000000)        /* Filter bit 30 */
-#define  CAN_F8R2_FB31                       ((u32)0x80000000)        /* Filter bit 31 */
-
-
-/*******************  Bit definition for CAN_F9R2 register  *******************/
-#define  CAN_F9R2_FB0                        ((u32)0x00000001)        /* Filter bit 0 */
-#define  CAN_F9R2_FB1                        ((u32)0x00000002)        /* Filter bit 1 */
-#define  CAN_F9R2_FB2                        ((u32)0x00000004)        /* Filter bit 2 */
-#define  CAN_F9R2_FB3                        ((u32)0x00000008)        /* Filter bit 3 */
-#define  CAN_F9R2_FB4                        ((u32)0x00000010)        /* Filter bit 4 */
-#define  CAN_F9R2_FB5                        ((u32)0x00000020)        /* Filter bit 5 */
-#define  CAN_F9R2_FB6                        ((u32)0x00000040)        /* Filter bit 6 */
-#define  CAN_F9R2_FB7                        ((u32)0x00000080)        /* Filter bit 7 */
-#define  CAN_F9R2_FB8                        ((u32)0x00000100)        /* Filter bit 8 */
-#define  CAN_F9R2_FB9                        ((u32)0x00000200)        /* Filter bit 9 */
-#define  CAN_F9R2_FB10                       ((u32)0x00000400)        /* Filter bit 10 */
-#define  CAN_F9R2_FB11                       ((u32)0x00000800)        /* Filter bit 11 */
-#define  CAN_F9R2_FB12                       ((u32)0x00001000)        /* Filter bit 12 */
-#define  CAN_F9R2_FB13                       ((u32)0x00002000)        /* Filter bit 13 */
-#define  CAN_F9R2_FB14                       ((u32)0x00004000)        /* Filter bit 14 */
-#define  CAN_F9R2_FB15                       ((u32)0x00008000)        /* Filter bit 15 */
-#define  CAN_F9R2_FB16                       ((u32)0x00010000)        /* Filter bit 16 */
-#define  CAN_F9R2_FB17                       ((u32)0x00020000)        /* Filter bit 17 */
-#define  CAN_F9R2_FB18                       ((u32)0x00040000)        /* Filter bit 18 */
-#define  CAN_F9R2_FB19                       ((u32)0x00080000)        /* Filter bit 19 */
-#define  CAN_F9R2_FB20                       ((u32)0x00100000)        /* Filter bit 20 */
-#define  CAN_F9R2_FB21                       ((u32)0x00200000)        /* Filter bit 21 */
-#define  CAN_F9R2_FB22                       ((u32)0x00400000)        /* Filter bit 22 */
-#define  CAN_F9R2_FB23                       ((u32)0x00800000)        /* Filter bit 23 */
-#define  CAN_F9R2_FB24                       ((u32)0x01000000)        /* Filter bit 24 */
-#define  CAN_F9R2_FB25                       ((u32)0x02000000)        /* Filter bit 25 */
-#define  CAN_F9R2_FB26                       ((u32)0x04000000)        /* Filter bit 26 */
-#define  CAN_F9R2_FB27                       ((u32)0x08000000)        /* Filter bit 27 */
-#define  CAN_F9R2_FB28                       ((u32)0x10000000)        /* Filter bit 28 */
-#define  CAN_F9R2_FB29                       ((u32)0x20000000)        /* Filter bit 29 */
-#define  CAN_F9R2_FB30                       ((u32)0x40000000)        /* Filter bit 30 */
-#define  CAN_F9R2_FB31                       ((u32)0x80000000)        /* Filter bit 31 */
-
-
-/*******************  Bit definition for CAN_F10R2 register  ******************/
-#define  CAN_F10R2_FB0                       ((u32)0x00000001)        /* Filter bit 0 */
-#define  CAN_F10R2_FB1                       ((u32)0x00000002)        /* Filter bit 1 */
-#define  CAN_F10R2_FB2                       ((u32)0x00000004)        /* Filter bit 2 */
-#define  CAN_F10R2_FB3                       ((u32)0x00000008)        /* Filter bit 3 */
-#define  CAN_F10R2_FB4                       ((u32)0x00000010)        /* Filter bit 4 */
-#define  CAN_F10R2_FB5                       ((u32)0x00000020)        /* Filter bit 5 */
-#define  CAN_F10R2_FB6                       ((u32)0x00000040)        /* Filter bit 6 */
-#define  CAN_F10R2_FB7                       ((u32)0x00000080)        /* Filter bit 7 */
-#define  CAN_F10R2_FB8                       ((u32)0x00000100)        /* Filter bit 8 */
-#define  CAN_F10R2_FB9                       ((u32)0x00000200)        /* Filter bit 9 */
-#define  CAN_F10R2_FB10                      ((u32)0x00000400)        /* Filter bit 10 */
-#define  CAN_F10R2_FB11                      ((u32)0x00000800)        /* Filter bit 11 */
-#define  CAN_F10R2_FB12                      ((u32)0x00001000)        /* Filter bit 12 */
-#define  CAN_F10R2_FB13                      ((u32)0x00002000)        /* Filter bit 13 */
-#define  CAN_F10R2_FB14                      ((u32)0x00004000)        /* Filter bit 14 */
-#define  CAN_F10R2_FB15                      ((u32)0x00008000)        /* Filter bit 15 */
-#define  CAN_F10R2_FB16                      ((u32)0x00010000)        /* Filter bit 16 */
-#define  CAN_F10R2_FB17                      ((u32)0x00020000)        /* Filter bit 17 */
-#define  CAN_F10R2_FB18                      ((u32)0x00040000)        /* Filter bit 18 */
-#define  CAN_F10R2_FB19                      ((u32)0x00080000)        /* Filter bit 19 */
-#define  CAN_F10R2_FB20                      ((u32)0x00100000)        /* Filter bit 20 */
-#define  CAN_F10R2_FB21                      ((u32)0x00200000)        /* Filter bit 21 */
-#define  CAN_F10R2_FB22                      ((u32)0x00400000)        /* Filter bit 22 */
-#define  CAN_F10R2_FB23                      ((u32)0x00800000)        /* Filter bit 23 */
-#define  CAN_F10R2_FB24                      ((u32)0x01000000)        /* Filter bit 24 */
-#define  CAN_F10R2_FB25                      ((u32)0x02000000)        /* Filter bit 25 */
-#define  CAN_F10R2_FB26                      ((u32)0x04000000)        /* Filter bit 26 */
-#define  CAN_F10R2_FB27                      ((u32)0x08000000)        /* Filter bit 27 */
-#define  CAN_F10R2_FB28                      ((u32)0x10000000)        /* Filter bit 28 */
-#define  CAN_F10R2_FB29                      ((u32)0x20000000)        /* Filter bit 29 */
-#define  CAN_F10R2_FB30                      ((u32)0x40000000)        /* Filter bit 30 */
-#define  CAN_F10R2_FB31                      ((u32)0x80000000)        /* Filter bit 31 */
-
-
-/*******************  Bit definition for CAN_F11R2 register  ******************/
-#define  CAN_F11R2_FB0                       ((u32)0x00000001)        /* Filter bit 0 */
-#define  CAN_F11R2_FB1                       ((u32)0x00000002)        /* Filter bit 1 */
-#define  CAN_F11R2_FB2                       ((u32)0x00000004)        /* Filter bit 2 */
-#define  CAN_F11R2_FB3                       ((u32)0x00000008)        /* Filter bit 3 */
-#define  CAN_F11R2_FB4                       ((u32)0x00000010)        /* Filter bit 4 */
-#define  CAN_F11R2_FB5                       ((u32)0x00000020)        /* Filter bit 5 */
-#define  CAN_F11R2_FB6                       ((u32)0x00000040)        /* Filter bit 6 */
-#define  CAN_F11R2_FB7                       ((u32)0x00000080)        /* Filter bit 7 */
-#define  CAN_F11R2_FB8                       ((u32)0x00000100)        /* Filter bit 8 */
-#define  CAN_F11R2_FB9                       ((u32)0x00000200)        /* Filter bit 9 */
-#define  CAN_F11R2_FB10                      ((u32)0x00000400)        /* Filter bit 10 */
-#define  CAN_F11R2_FB11                      ((u32)0x00000800)        /* Filter bit 11 */
-#define  CAN_F11R2_FB12                      ((u32)0x00001000)        /* Filter bit 12 */
-#define  CAN_F11R2_FB13                      ((u32)0x00002000)        /* Filter bit 13 */
-#define  CAN_F11R2_FB14                      ((u32)0x00004000)        /* Filter bit 14 */
-#define  CAN_F11R2_FB15                      ((u32)0x00008000)        /* Filter bit 15 */
-#define  CAN_F11R2_FB16                      ((u32)0x00010000)        /* Filter bit 16 */
-#define  CAN_F11R2_FB17                      ((u32)0x00020000)        /* Filter bit 17 */
-#define  CAN_F11R2_FB18                      ((u32)0x00040000)        /* Filter bit 18 */
-#define  CAN_F11R2_FB19                      ((u32)0x00080000)        /* Filter bit 19 */
-#define  CAN_F11R2_FB20                      ((u32)0x00100000)        /* Filter bit 20 */
-#define  CAN_F11R2_FB21                      ((u32)0x00200000)        /* Filter bit 21 */
-#define  CAN_F11R2_FB22                      ((u32)0x00400000)        /* Filter bit 22 */
-#define  CAN_F11R2_FB23                      ((u32)0x00800000)        /* Filter bit 23 */
-#define  CAN_F11R2_FB24                      ((u32)0x01000000)        /* Filter bit 24 */
-#define  CAN_F11R2_FB25                      ((u32)0x02000000)        /* Filter bit 25 */
-#define  CAN_F11R2_FB26                      ((u32)0x04000000)        /* Filter bit 26 */
-#define  CAN_F11R2_FB27                      ((u32)0x08000000)        /* Filter bit 27 */
-#define  CAN_F11R2_FB28                      ((u32)0x10000000)        /* Filter bit 28 */
-#define  CAN_F11R2_FB29                      ((u32)0x20000000)        /* Filter bit 29 */
-#define  CAN_F11R2_FB30                      ((u32)0x40000000)        /* Filter bit 30 */
-#define  CAN_F11R2_FB31                      ((u32)0x80000000)        /* Filter bit 31 */
-
-
-/*******************  Bit definition for CAN_F12R2 register  ******************/
-#define  CAN_F12R2_FB0                       ((u32)0x00000001)        /* Filter bit 0 */
-#define  CAN_F12R2_FB1                       ((u32)0x00000002)        /* Filter bit 1 */
-#define  CAN_F12R2_FB2                       ((u32)0x00000004)        /* Filter bit 2 */
-#define  CAN_F12R2_FB3                       ((u32)0x00000008)        /* Filter bit 3 */
-#define  CAN_F12R2_FB4                       ((u32)0x00000010)        /* Filter bit 4 */
-#define  CAN_F12R2_FB5                       ((u32)0x00000020)        /* Filter bit 5 */
-#define  CAN_F12R2_FB6                       ((u32)0x00000040)        /* Filter bit 6 */
-#define  CAN_F12R2_FB7                       ((u32)0x00000080)        /* Filter bit 7 */
-#define  CAN_F12R2_FB8                       ((u32)0x00000100)        /* Filter bit 8 */
-#define  CAN_F12R2_FB9                       ((u32)0x00000200)        /* Filter bit 9 */
-#define  CAN_F12R2_FB10                      ((u32)0x00000400)        /* Filter bit 10 */
-#define  CAN_F12R2_FB11                      ((u32)0x00000800)        /* Filter bit 11 */
-#define  CAN_F12R2_FB12                      ((u32)0x00001000)        /* Filter bit 12 */
-#define  CAN_F12R2_FB13                      ((u32)0x00002000)        /* Filter bit 13 */
-#define  CAN_F12R2_FB14                      ((u32)0x00004000)        /* Filter bit 14 */
-#define  CAN_F12R2_FB15                      ((u32)0x00008000)        /* Filter bit 15 */
-#define  CAN_F12R2_FB16                      ((u32)0x00010000)        /* Filter bit 16 */
-#define  CAN_F12R2_FB17                      ((u32)0x00020000)        /* Filter bit 17 */
-#define  CAN_F12R2_FB18                      ((u32)0x00040000)        /* Filter bit 18 */
-#define  CAN_F12R2_FB19                      ((u32)0x00080000)        /* Filter bit 19 */
-#define  CAN_F12R2_FB20                      ((u32)0x00100000)        /* Filter bit 20 */
-#define  CAN_F12R2_FB21                      ((u32)0x00200000)        /* Filter bit 21 */
-#define  CAN_F12R2_FB22                      ((u32)0x00400000)        /* Filter bit 22 */
-#define  CAN_F12R2_FB23                      ((u32)0x00800000)        /* Filter bit 23 */
-#define  CAN_F12R2_FB24                      ((u32)0x01000000)        /* Filter bit 24 */
-#define  CAN_F12R2_FB25                      ((u32)0x02000000)        /* Filter bit 25 */
-#define  CAN_F12R2_FB26                      ((u32)0x04000000)        /* Filter bit 26 */
-#define  CAN_F12R2_FB27                      ((u32)0x08000000)        /* Filter bit 27 */
-#define  CAN_F12R2_FB28                      ((u32)0x10000000)        /* Filter bit 28 */
-#define  CAN_F12R2_FB29                      ((u32)0x20000000)        /* Filter bit 29 */
-#define  CAN_F12R2_FB30                      ((u32)0x40000000)        /* Filter bit 30 */
-#define  CAN_F12R2_FB31                      ((u32)0x80000000)        /* Filter bit 31 */
-
-
-/*******************  Bit definition for CAN_F13R2 register  ******************/
-#define  CAN_F13R2_FB0                       ((u32)0x00000001)        /* Filter bit 0 */
-#define  CAN_F13R2_FB1                       ((u32)0x00000002)        /* Filter bit 1 */
-#define  CAN_F13R2_FB2                       ((u32)0x00000004)        /* Filter bit 2 */
-#define  CAN_F13R2_FB3                       ((u32)0x00000008)        /* Filter bit 3 */
-#define  CAN_F13R2_FB4                       ((u32)0x00000010)        /* Filter bit 4 */
-#define  CAN_F13R2_FB5                       ((u32)0x00000020)        /* Filter bit 5 */
-#define  CAN_F13R2_FB6                       ((u32)0x00000040)        /* Filter bit 6 */
-#define  CAN_F13R2_FB7                       ((u32)0x00000080)        /* Filter bit 7 */
-#define  CAN_F13R2_FB8                       ((u32)0x00000100)        /* Filter bit 8 */
-#define  CAN_F13R2_FB9                       ((u32)0x00000200)        /* Filter bit 9 */
-#define  CAN_F13R2_FB10                      ((u32)0x00000400)        /* Filter bit 10 */
-#define  CAN_F13R2_FB11                      ((u32)0x00000800)        /* Filter bit 11 */
-#define  CAN_F13R2_FB12                      ((u32)0x00001000)        /* Filter bit 12 */
-#define  CAN_F13R2_FB13                      ((u32)0x00002000)        /* Filter bit 13 */
-#define  CAN_F13R2_FB14                      ((u32)0x00004000)        /* Filter bit 14 */
-#define  CAN_F13R2_FB15                      ((u32)0x00008000)        /* Filter bit 15 */
-#define  CAN_F13R2_FB16                      ((u32)0x00010000)        /* Filter bit 16 */
-#define  CAN_F13R2_FB17                      ((u32)0x00020000)        /* Filter bit 17 */
-#define  CAN_F13R2_FB18                      ((u32)0x00040000)        /* Filter bit 18 */
-#define  CAN_F13R2_FB19                      ((u32)0x00080000)        /* Filter bit 19 */
-#define  CAN_F13R2_FB20                      ((u32)0x00100000)        /* Filter bit 20 */
-#define  CAN_F13R2_FB21                      ((u32)0x00200000)        /* Filter bit 21 */
-#define  CAN_F13R2_FB22                      ((u32)0x00400000)        /* Filter bit 22 */
-#define  CAN_F13R2_FB23                      ((u32)0x00800000)        /* Filter bit 23 */
-#define  CAN_F13R2_FB24                      ((u32)0x01000000)        /* Filter bit 24 */
-#define  CAN_F13R2_FB25                      ((u32)0x02000000)        /* Filter bit 25 */
-#define  CAN_F13R2_FB26                      ((u32)0x04000000)        /* Filter bit 26 */
-#define  CAN_F13R2_FB27                      ((u32)0x08000000)        /* Filter bit 27 */
-#define  CAN_F13R2_FB28                      ((u32)0x10000000)        /* Filter bit 28 */
-#define  CAN_F13R2_FB29                      ((u32)0x20000000)        /* Filter bit 29 */
-#define  CAN_F13R2_FB30                      ((u32)0x40000000)        /* Filter bit 30 */
-#define  CAN_F13R2_FB31                      ((u32)0x80000000)        /* Filter bit 31 */
-
-
-
-/******************************************************************************/
-/*                                                                            */
-/*                        Serial Peripheral Interface                         */
-/*                                                                            */
-/******************************************************************************/
-
-/*******************  Bit definition for SPI_CR1 register  ********************/
-#define  SPI_CR1_CPHA                        ((u16)0x0001)            /* Clock Phase */
-#define  SPI_CR1_CPOL                        ((u16)0x0002)            /* Clock Polarity */
-#define  SPI_CR1_MSTR                        ((u16)0x0004)            /* Master Selection */
-
-#define  SPI_CR1_BR                          ((u16)0x0038)            /* BR[2:0] bits (Baud Rate Control) */
-#define  SPI_CR1_BR_0                        ((u16)0x0008)            /* Bit 0 */
-#define  SPI_CR1_BR_1                        ((u16)0x0010)            /* Bit 1 */
-#define  SPI_CR1_BR_2                        ((u16)0x0020)            /* Bit 2 */
-
-#define  SPI_CR1_SPE                         ((u16)0x0040)            /* SPI Enable */
-#define  SPI_CR1_LSBFIRST                    ((u16)0x0080)            /* Frame Format */
-#define  SPI_CR1_SSI                         ((u16)0x0100)            /* Internal slave select */
-#define  SPI_CR1_SSM                         ((u16)0x0200)            /* Software slave management */
-#define  SPI_CR1_RXONLY                      ((u16)0x0400)            /* Receive only */
-#define  SPI_CR1_DFF                         ((u16)0x0800)            /* Data Frame Format */
-#define  SPI_CR1_CRCNEXT                     ((u16)0x1000)            /* Transmit CRC next */
-#define  SPI_CR1_CRCEN                       ((u16)0x2000)            /* Hardware CRC calculation enable */
-#define  SPI_CR1_BIDIOE                      ((u16)0x4000)            /* Output enable in bidirectional mode */
-#define  SPI_CR1_BIDIMODE                    ((u16)0x8000)            /* Bidirectional data mode enable */
-
-
-/*******************  Bit definition for SPI_CR2 register  ********************/
-#define  SPI_CR2_RXDMAEN                     ((u8)0x01)               /* Rx Buffer DMA Enable */
-#define  SPI_CR2_TXDMAEN                     ((u8)0x02)               /* Tx Buffer DMA Enable */
-#define  SPI_CR2_SSOE                        ((u8)0x04)               /* SS Output Enable */
-#define  SPI_CR2_ERRIE                       ((u8)0x20)               /* Error Interrupt Enable */
-#define  SPI_CR2_RXNEIE                      ((u8)0x40)               /* RX buffer Not Empty Interrupt Enable */
-#define  SPI_CR2_TXEIE                       ((u8)0x80)               /* Tx buffer Empty Interrupt Enable */
-
-
-/********************  Bit definition for SPI_SR register  ********************/
-#define  SPI_SR_RXNE                         ((u8)0x01)               /* Receive buffer Not Empty */
-#define  SPI_SR_TXE                          ((u8)0x02)               /* Transmit buffer Empty */
-#define  SPI_SR_CHSIDE                       ((u8)0x04)               /* Channel side */
-#define  SPI_SR_UDR                          ((u8)0x08)               /* Underrun flag */
-#define  SPI_SR_CRCERR                       ((u8)0x10)               /* CRC Error flag */
-#define  SPI_SR_MODF                         ((u8)0x20)               /* Mode fault */
-#define  SPI_SR_OVR                          ((u8)0x40)               /* Overrun flag */
-#define  SPI_SR_BSY                          ((u8)0x80)               /* Busy flag */
-
-
-/********************  Bit definition for SPI_DR register  ********************/
-#define  SPI_DR_DR                           ((u16)0xFFFF)            /* Data Register */
-
-
-/*******************  Bit definition for SPI_CRCPR register  ******************/
-#define  SPI_CRCPR_CRCPOLY                   ((u16)0xFFFF)            /* CRC polynomial register */
-
-
-/******************  Bit definition for SPI_RXCRCR register  ******************/
-#define  SPI_RXCRCR_RXCRC                    ((u16)0xFFFF)            /* Rx CRC Register */
-
-
-/******************  Bit definition for SPI_TXCRCR register  ******************/
-#define  SPI_TXCRCR_TXCRC                    ((u16)0xFFFF)            /* Tx CRC Register */
-
-
-/******************  Bit definition for SPI_I2SCFGR register  *****************/
-#define  SPI_I2SCFGR_CHLEN                   ((u16)0x0001)            /* Channel length (number of bits per audio channel) */
-
-#define  SPI_I2SCFGR_DATLEN                  ((u16)0x0006)            /* DATLEN[1:0] bits (Data length to be transferred) */
-#define  SPI_I2SCFGR_DATLEN_0                ((u16)0x0002)            /* Bit 0 */
-#define  SPI_I2SCFGR_DATLEN_1                ((u16)0x0004)            /* Bit 1 */
-
-#define  SPI_I2SCFGR_CKPOL                   ((u16)0x0008)            /* steady state clock polarity */
-
-#define  SPI_I2SCFGR_I2SSTD                  ((u16)0x0030)            /* I2SSTD[1:0] bits (I2S standard selection) */
-#define  SPI_I2SCFGR_I2SSTD_0                ((u16)0x0010)            /* Bit 0 */
-#define  SPI_I2SCFGR_I2SSTD_1                ((u16)0x0020)            /* Bit 1 */
-
-#define  SPI_I2SCFGR_PCMSYNC                 ((u16)0x0080)            /* PCM frame synchronization */
-
-#define  SPI_I2SCFGR_I2SCFG                  ((u16)0x0300)            /* I2SCFG[1:0] bits (I2S configuration mode) */
-#define  SPI_I2SCFGR_I2SCFG_0                ((u16)0x0100)            /* Bit 0 */
-#define  SPI_I2SCFGR_I2SCFG_1                ((u16)0x0200)            /* Bit 1 */
-
-#define  SPI_I2SCFGR_I2SE                    ((u16)0x0400)            /* I2S Enable */
-#define  SPI_I2SCFGR_I2SMOD                  ((u16)0x0800)            /* I2S mode selection */
-
-
-/******************  Bit definition for SPI_I2SPR register  *******************/
-#define  SPI_I2SPR_I2SDIV                    ((u16)0x00FF)            /* I2S Linear prescaler */
-#define  SPI_I2SPR_ODD                       ((u16)0x0100)            /* Odd factor for the prescaler */
-#define  SPI_I2SPR_MCKOE                     ((u16)0x0200)            /* Master Clock Output Enable */
-
-
-
-/******************************************************************************/
-/*                                                                            */
-/*                      Inter-integrated Circuit Interface                    */
-/*                                                                            */
-/******************************************************************************/
-
-/*******************  Bit definition for I2C_CR1 register  ********************/
-#define  I2C_CR1_PE                          ((u16)0x0001)            /* Peripheral Enable */
-#define  I2C_CR1_SMBUS                       ((u16)0x0002)            /* SMBus Mode */
-#define  I2C_CR1_SMBTYPE                     ((u16)0x0008)            /* SMBus Type */
-#define  I2C_CR1_ENARP                       ((u16)0x0010)            /* ARP Enable */
-#define  I2C_CR1_ENPEC                       ((u16)0x0020)            /* PEC Enable */
-#define  I2C_CR1_ENGC                        ((u16)0x0040)            /* General Call Enable */
-#define  I2C_CR1_NOSTRETCH                   ((u16)0x0080)            /* Clock Stretching Disable (Slave mode) */
-#define  I2C_CR1_START                       ((u16)0x0100)            /* Start Generation */
-#define  I2C_CR1_STOP                        ((u16)0x0200)            /* Stop Generation */
-#define  I2C_CR1_ACK                         ((u16)0x0400)            /* Acknowledge Enable */
-#define  I2C_CR1_POS                         ((u16)0x0800)            /* Acknowledge/PEC Position (for data reception) */
-#define  I2C_CR1_PEC                         ((u16)0x1000)            /* Packet Error Checking */
-#define  I2C_CR1_ALERT                       ((u16)0x2000)            /* SMBus Alert */
-#define  I2C_CR1_SWRST                       ((u16)0x8000)            /* Software Reset */
-
-
-/*******************  Bit definition for I2C_CR2 register  ********************/
-#define  I2C_CR2_FREQ                        ((u16)0x003F)            /* FREQ[5:0] bits (Peripheral Clock Frequency) */
-#define  I2C_CR2_FREQ_0                      ((u16)0x0001)            /* Bit 0 */
-#define  I2C_CR2_FREQ_1                      ((u16)0x0002)            /* Bit 1 */
-#define  I2C_CR2_FREQ_2                      ((u16)0x0004)            /* Bit 2 */
-#define  I2C_CR2_FREQ_3                      ((u16)0x0008)            /* Bit 3 */
-#define  I2C_CR2_FREQ_4                      ((u16)0x0010)            /* Bit 4 */
-#define  I2C_CR2_FREQ_5                      ((u16)0x0020)            /* Bit 5 */
-
-#define  I2C_CR2_ITERREN                     ((u16)0x0100)            /* Error Interrupt Enable */
-#define  I2C_CR2_ITEVTEN                     ((u16)0x0200)            /* Event Interrupt Enable */
-#define  I2C_CR2_ITBUFEN                     ((u16)0x0400)            /* Buffer Interrupt Enable */
-#define  I2C_CR2_DMAEN                       ((u16)0x0800)            /* DMA Requests Enable */
-#define  I2C_CR2_LAST                        ((u16)0x1000)            /* DMA Last Transfer */
-
-
-/*******************  Bit definition for I2C_OAR1 register  *******************/
-#define  I2C_OAR1_ADD1_7                     ((u16)0x00FE)            /* Interface Address */
-#define  I2C_OAR1_ADD8_9                     ((u16)0x0300)            /* Interface Address */
-
-#define  I2C_OAR1_ADD0                       ((u16)0x0001)            /* Bit 0 */
-#define  I2C_OAR1_ADD1                       ((u16)0x0002)            /* Bit 1 */
-#define  I2C_OAR1_ADD2                       ((u16)0x0004)            /* Bit 2 */
-#define  I2C_OAR1_ADD3                       ((u16)0x0008)            /* Bit 3 */
-#define  I2C_OAR1_ADD4                       ((u16)0x0010)            /* Bit 4 */
-#define  I2C_OAR1_ADD5                       ((u16)0x0020)            /* Bit 5 */
-#define  I2C_OAR1_ADD6                       ((u16)0x0040)            /* Bit 6 */
-#define  I2C_OAR1_ADD7                       ((u16)0x0080)            /* Bit 7 */
-#define  I2C_OAR1_ADD8                       ((u16)0x0100)            /* Bit 8 */
-#define  I2C_OAR1_ADD9                       ((u16)0x0200)            /* Bit 9 */
-
-#define  I2C_OAR1_ADDMODE                    ((u16)0x8000)            /* Addressing Mode (Slave mode) */
-
-
-/*******************  Bit definition for I2C_OAR2 register  *******************/
-#define  I2C_OAR2_ENDUAL                     ((u8)0x01)               /* Dual addressing mode enable */
-#define  I2C_OAR2_ADD2                       ((u8)0xFE)               /* Interface address */
-
-
-/********************  Bit definition for I2C_DR register  ********************/
-#define  I2C_DR_DR                           ((u8)0xFF)               /* 8-bit Data Register */
-
-
-/*******************  Bit definition for I2C_SR1 register  ********************/
-#define  I2C_SR1_SB                          ((u16)0x0001)            /* Start Bit (Master mode) */
-#define  I2C_SR1_ADDR                        ((u16)0x0002)            /* Address sent (master mode)/matched (slave mode) */
-#define  I2C_SR1_BTF                         ((u16)0x0004)            /* Byte Transfer Finished */
-#define  I2C_SR1_ADD10                       ((u16)0x0008)            /* 10-bit header sent (Master mode) */
-#define  I2C_SR1_STOPF                       ((u16)0x0010)            /* Stop detection (Slave mode) */
-#define  I2C_SR1_RXNE                        ((u16)0x0040)            /* Data Register not Empty (receivers) */
-#define  I2C_SR1_TXE                         ((u16)0x0080)            /* Data Register Empty (transmitters) */
-#define  I2C_SR1_BERR                        ((u16)0x0100)            /* Bus Error */
-#define  I2C_SR1_ARLO                        ((u16)0x0200)            /* Arbitration Lost (master mode) */
-#define  I2C_SR1_AF                          ((u16)0x0400)            /* Acknowledge Failure */
-#define  I2C_SR1_OVR                         ((u16)0x0800)            /* Overrun/Underrun */
-#define  I2C_SR1_PECERR                      ((u16)0x1000)            /* PEC Error in reception */
-#define  I2C_SR1_TIMEOUT                     ((u16)0x4000)            /* Timeout or Tlow Error */
-#define  I2C_SR1_SMBALERT                    ((u16)0x8000)            /* SMBus Alert */
-
-
-/*******************  Bit definition for I2C_SR2 register  ********************/
-#define  I2C_SR2_MSL                         ((u16)0x0001)            /* Master/Slave */
-#define  I2C_SR2_BUSY                        ((u16)0x0002)            /* Bus Busy */
-#define  I2C_SR2_TRA                         ((u16)0x0004)            /* Transmitter/Receiver */
-#define  I2C_SR2_GENCALL                     ((u16)0x0010)            /* General Call Address (Slave mode) */
-#define  I2C_SR2_SMBDEFAULT                  ((u16)0x0020)            /* SMBus Device Default Address (Slave mode) */
-#define  I2C_SR2_SMBHOST                     ((u16)0x0040)            /* SMBus Host Header (Slave mode) */
-#define  I2C_SR2_DUALF                       ((u16)0x0080)            /* Dual Flag (Slave mode) */
-#define  I2C_SR2_PEC                         ((u16)0xFF00)            /* Packet Error Checking Register */
-
-
-/*******************  Bit definition for I2C_CCR register  ********************/
-#define  I2C_CCR_CCR                         ((u16)0x0FFF)            /* Clock Control Register in Fast/Standard mode (Master mode) */
-#define  I2C_CCR_DUTY                        ((u16)0x4000)            /* Fast Mode Duty Cycle */
-#define  I2C_CCR_FS                          ((u16)0x8000)            /* I2C Master Mode Selection */
-
-
-/******************  Bit definition for I2C_TRISE register  *******************/
-#define  I2C_TRISE_TRISE                     ((u8)0x3F)               /* Maximum Rise Time in Fast/Standard mode (Master mode) */
-
-
-
-/******************************************************************************/
-/*                                                                            */
-/*          Universal Synchronous Asynchronous Receiver Transmitter           */
-/*                                                                            */
-/******************************************************************************/
-
-/*******************  Bit definition for USART_SR register  *******************/
-#define  USART_SR_PE                         ((u16)0x0001)            /* Parity Error */
-#define  USART_SR_FE                         ((u16)0x0002)            /* Framing Error */
-#define  USART_SR_NE                         ((u16)0x0004)            /* Noise Error Flag */
-#define  USART_SR_ORE                        ((u16)0x0008)            /* OverRun Error */
-#define  USART_SR_IDLE                       ((u16)0x0010)            /* IDLE line detected */
-#define  USART_SR_RXNE                       ((u16)0x0020)            /* Read Data Register Not Empty */
-#define  USART_SR_TC                         ((u16)0x0040)            /* Transmission Complete */
-#define  USART_SR_TXE                        ((u16)0x0080)            /* Transmit Data Register Empty */
-#define  USART_SR_LBD                        ((u16)0x0100)            /* LIN Break Detection Flag */
-#define  USART_SR_CTS                        ((u16)0x0200)            /* CTS Flag */
-
-
-/*******************  Bit definition for USART_DR register  *******************/
-#define  USART_DR_DR                         ((u16)0x01FF)            /* Data value */
-
-
-/******************  Bit definition for USART_BRR register  *******************/
-#define  USART_BRR_DIV_Fraction              ((u16)0x000F)            /* Fraction of USARTDIV */
-#define  USART_BRR_DIV_Mantissa              ((u16)0xFFF0)            /* Mantissa of USARTDIV */
-
-
-/******************  Bit definition for USART_CR1 register  *******************/
-#define  USART_CR1_SBK                       ((u16)0x0001)            /* Send Break */
-#define  USART_CR1_RWU                       ((u16)0x0002)            /* Receiver wakeup */
-#define  USART_CR1_RE                        ((u16)0x0004)            /* Receiver Enable */
-#define  USART_CR1_TE                        ((u16)0x0008)            /* Transmitter Enable */
-#define  USART_CR1_IDLEIE                    ((u16)0x0010)            /* IDLE Interrupt Enable */
-#define  USART_CR1_RXNEIE                    ((u16)0x0020)            /* RXNE Interrupt Enable */
-#define  USART_CR1_TCIE                      ((u16)0x0040)            /* Transmission Complete Interrupt Enable */
-#define  USART_CR1_TXEIE                     ((u16)0x0080)            /* PE Interrupt Enable */
-#define  USART_CR1_PEIE                      ((u16)0x0100)            /* PE Interrupt Enable */
-#define  USART_CR1_PS                        ((u16)0x0200)            /* Parity Selection */
-#define  USART_CR1_PCE                       ((u16)0x0400)            /* Parity Control Enable */
-#define  USART_CR1_WAKE                      ((u16)0x0800)            /* Wakeup method */
-#define  USART_CR1_M                         ((u16)0x1000)            /* Word length */
-#define  USART_CR1_UE                        ((u16)0x2000)            /* USART Enable */
-
-
-/******************  Bit definition for USART_CR2 register  *******************/
-#define  USART_CR2_ADD                       ((u16)0x000F)            /* Address of the USART node */
-#define  USART_CR2_LBDL                      ((u16)0x0020)            /* LIN Break Detection Length */
-#define  USART_CR2_LBDIE                     ((u16)0x0040)            /* LIN Break Detection Interrupt Enable */
-#define  USART_CR2_LBCL                      ((u16)0x0100)            /* Last Bit Clock pulse */
-#define  USART_CR2_CPHA                      ((u16)0x0200)            /* Clock Phase */
-#define  USART_CR2_CPOL                      ((u16)0x0400)            /* Clock Polarity */
-#define  USART_CR2_CLKEN                     ((u16)0x0800)            /* Clock Enable */
-
-#define  USART_CR2_STOP                      ((u16)0x3000)            /* STOP[1:0] bits (STOP bits) */
-#define  USART_CR2_STOP_0                    ((u16)0x1000)            /* Bit 0 */
-#define  USART_CR2_STOP_1                    ((u16)0x2000)            /* Bit 1 */
-
-#define  USART_CR2_LINEN                     ((u16)0x4000)            /* LIN mode enable */
-
-
-/******************  Bit definition for USART_CR3 register  *******************/
-#define  USART_CR3_EIE                       ((u16)0x0001)            /* Error Interrupt Enable */
-#define  USART_CR3_IREN                      ((u16)0x0002)            /* IrDA mode Enable */
-#define  USART_CR3_IRLP                      ((u16)0x0004)            /* IrDA Low-Power */
-#define  USART_CR3_HDSEL                     ((u16)0x0008)            /* Half-Duplex Selection */
-#define  USART_CR3_NACK                      ((u16)0x0010)            /* Smartcard NACK enable */
-#define  USART_CR3_SCEN                      ((u16)0x0020)            /* Smartcard mode enable */
-#define  USART_CR3_DMAR                      ((u16)0x0040)            /* DMA Enable Receiver */
-#define  USART_CR3_DMAT                      ((u16)0x0080)            /* DMA Enable Transmitter */
-#define  USART_CR3_RTSE                      ((u16)0x0100)            /* RTS Enable */
-#define  USART_CR3_CTSE                      ((u16)0x0200)            /* CTS Enable */
-#define  USART_CR3_CTSIE                     ((u16)0x0400)            /* CTS Interrupt Enable */
-
-
-/******************  Bit definition for USART_GTPR register  ******************/
-#define  USART_GTPR_PSC                      ((u16)0x00FF)            /* PSC[7:0] bits (Prescaler value) */
-#define  USART_GTPR_PSC_0                    ((u16)0x0001)            /* Bit 0 */
-#define  USART_GTPR_PSC_1                    ((u16)0x0002)            /* Bit 1 */
-#define  USART_GTPR_PSC_2                    ((u16)0x0004)            /* Bit 2 */
-#define  USART_GTPR_PSC_3                    ((u16)0x0008)            /* Bit 3 */
-#define  USART_GTPR_PSC_4                    ((u16)0x0010)            /* Bit 4 */
-#define  USART_GTPR_PSC_5                    ((u16)0x0020)            /* Bit 5 */
-#define  USART_GTPR_PSC_6                    ((u16)0x0040)            /* Bit 6 */
-#define  USART_GTPR_PSC_7                    ((u16)0x0080)            /* Bit 7 */
-
-#define  USART_GTPR_GT                       ((u16)0xFF00)            /* Guard time value */
-
-
-
-/******************************************************************************/
-/*                                                                            */
-/*                                 Debug MCU                                  */
-/*                                                                            */
-/******************************************************************************/
-
-/****************  Bit definition for DBGMCU_IDCODE register  *****************/
-#define  DBGMCU_IDCODE_DEV_ID                ((u32)0x00000FFF)        /* Device Identifier */
-
-#define  DBGMCU_IDCODE_REV_ID                ((u32)0xFFFF0000)        /* REV_ID[15:0] bits (Revision Identifier) */
-#define  DBGMCU_IDCODE_REV_ID_0              ((u32)0x00010000)        /* Bit 0 */
-#define  DBGMCU_IDCODE_REV_ID_1              ((u32)0x00020000)        /* Bit 1 */
-#define  DBGMCU_IDCODE_REV_ID_2              ((u32)0x00040000)        /* Bit 2 */
-#define  DBGMCU_IDCODE_REV_ID_3              ((u32)0x00080000)        /* Bit 3 */
-#define  DBGMCU_IDCODE_REV_ID_4              ((u32)0x00100000)        /* Bit 4 */
-#define  DBGMCU_IDCODE_REV_ID_5              ((u32)0x00200000)        /* Bit 5 */
-#define  DBGMCU_IDCODE_REV_ID_6              ((u32)0x00400000)        /* Bit 6 */
-#define  DBGMCU_IDCODE_REV_ID_7              ((u32)0x00800000)        /* Bit 7 */
-#define  DBGMCU_IDCODE_REV_ID_8              ((u32)0x01000000)        /* Bit 8 */
-#define  DBGMCU_IDCODE_REV_ID_9              ((u32)0x02000000)        /* Bit 9 */
-#define  DBGMCU_IDCODE_REV_ID_10             ((u32)0x04000000)        /* Bit 10 */
-#define  DBGMCU_IDCODE_REV_ID_11             ((u32)0x08000000)        /* Bit 11 */
-#define  DBGMCU_IDCODE_REV_ID_12             ((u32)0x10000000)        /* Bit 12 */
-#define  DBGMCU_IDCODE_REV_ID_13             ((u32)0x20000000)        /* Bit 13 */
-#define  DBGMCU_IDCODE_REV_ID_14             ((u32)0x40000000)        /* Bit 14 */
-#define  DBGMCU_IDCODE_REV_ID_15             ((u32)0x80000000)        /* Bit 15 */
-
-
-/******************  Bit definition for DBGMCU_CR register  *******************/
-#define  DBGMCU_CR_DBG_SLEEP                 ((u32)0x00000001)        /* Debug Sleep Mode */
-#define  DBGMCU_CR_DBG_STOP                  ((u32)0x00000002)        /* Debug Stop Mode */
-#define  DBGMCU_CR_DBG_STANDBY               ((u32)0x00000004)        /* Debug Standby mode */
-#define  DBGMCU_CR_TRACE_IOEN                ((u32)0x00000020)        /* Trace Pin Assignment Control */
-
-#define  DBGMCU_CR_TRACE_MODE                ((u32)0x000000C0)        /* TRACE_MODE[1:0] bits (Trace Pin Assignment Control) */
-#define  DBGMCU_CR_TRACE_MODE_0              ((u32)0x00000040)        /* Bit 0 */
-#define  DBGMCU_CR_TRACE_MODE_1              ((u32)0x00000080)        /* Bit 1 */
-
-#define  DBGMCU_CR_DBG_IWDG_STOP             ((u32)0x00000100)        /* Debug Independent Watchdog stopped when Core is halted */
-#define  DBGMCU_CR_DBG_WWDG_STOP             ((u32)0x00000200)        /* Debug Window Watchdog stopped when Core is halted */
-#define  DBGMCU_CR_DBG_TIM1_STOP             ((u32)0x00000400)        /* TIM1 counter stopped when core is halted */
-#define  DBGMCU_CR_DBG_TIM2_STOP             ((u32)0x00000800)        /* TIM2 counter stopped when core is halted */
-#define  DBGMCU_CR_DBG_TIM3_STOP             ((u32)0x00001000)        /* TIM3 counter stopped when core is halted */
-#define  DBGMCU_CR_DBG_TIM4_STOP             ((u32)0x00002000)        /* TIM4 counter stopped when core is halted */
-#define  DBGMCU_CR_DBG_CAN_STOP              ((u32)0x00004000)        /* Debug CAN stopped when Core is halted */
-#define  DBGMCU_CR_DBG_I2C1_SMBUS_TIMEOUT    ((u32)0x00008000)        /* SMBUS timeout mode stopped when Core is halted */
-#define  DBGMCU_CR_DBG_I2C2_SMBUS_TIMEOUT    ((u32)0x00010000)        /* SMBUS timeout mode stopped when Core is halted */
-#define  DBGMCU_CR_DBG_TIM5_STOP             ((u32)0x00020000)        /* TIM5 counter stopped when core is halted */
-#define  DBGMCU_CR_DBG_TIM6_STOP             ((u32)0x00040000)        /* TIM6 counter stopped when core is halted */
-#define  DBGMCU_CR_DBG_TIM7_STOP             ((u32)0x00080000)        /* TIM7 counter stopped when core is halted */
-#define  DBGMCU_CR_DBG_TIM8_STOP             ((u32)0x00100000)        /* TIM8 counter stopped when core is halted */
-
-
-
-/******************************************************************************/
-/*                                                                            */
-/*                      FLASH and Option Bytes Registers                      */
-/*                                                                            */
-/******************************************************************************/
-
-/*******************  Bit definition for FLASH_ACR register  ******************/
-#define  FLASH_ACR_LATENCY                   ((u8)0x07)               /* LATENCY[2:0] bits (Latency) */
-#define  FLASH_ACR_LATENCY_0                 ((u8)0x01)               /* Bit 0 */
-#define  FLASH_ACR_LATENCY_1                 ((u8)0x02)               /* Bit 1 */
-#define  FLASH_ACR_LATENCY_2                 ((u8)0x04)               /* Bit 2 */
-  
-#define  FLASH_ACR_HLFCYA                    ((u8)0x08)               /* Flash Half Cycle Access Enable */
-#define  FLASH_ACR_PRFTBE                    ((u8)0x10)               /* Prefetch Buffer Enable */
-#define  FLASH_ACR_PRFTBS                    ((u8)0x20)               /* Prefetch Buffer Status */
-
-
-/******************  Bit definition for FLASH_KEYR register  ******************/
-#define  FLASH_KEYR_FKEYR                    ((u32)0xFFFFFFFF)        /* FPEC Key */
-
-
-/*****************  Bit definition for FLASH_OPTKEYR register  ****************/
-#define  FLASH_OPTKEYR_OPTKEYR               ((u32)0xFFFFFFFF)        /* Option Byte Key */
-
-
-/******************  Bit definition for FLASH_SR register  *******************/
-#define  FLASH_SR_BSY                        ((u8)0x01)               /* Busy */
-#define  FLASH_SR_PGERR                      ((u8)0x04)               /* Programming Error */
-#define  FLASH_SR_WRPRTERR                   ((u8)0x10)               /* Write Protection Error */
-#define  FLASH_SR_EOP                        ((u8)0x20)               /* End of operation */
-
-
-/*******************  Bit definition for FLASH_CR register  *******************/
-#define  FLASH_CR_PG                         ((u16)0x0001)            /* Programming */
-#define  FLASH_CR_PER                        ((u16)0x0002)            /* Page Erase */
-#define  FLASH_CR_MER                        ((u16)0x0004)            /* Mass Erase */
-#define  FLASH_CR_OPTPG                      ((u16)0x0010)            /* Option Byte Programming */
-#define  FLASH_CR_OPTER                      ((u16)0x0020)            /* Option Byte Erase */
-#define  FLASH_CR_STRT                       ((u16)0x0040)            /* Start */
-#define  FLASH_CR_LOCK                       ((u16)0x0080)            /* Lock */
-#define  FLASH_CR_OPTWRE                     ((u16)0x0200)            /* Option Bytes Write Enable */
-#define  FLASH_CR_ERRIE                      ((u16)0x0400)            /* Error Interrupt Enable */
-#define  FLASH_CR_EOPIE                      ((u16)0x1000)            /* End of operation interrupt enable */
-
-
-/*******************  Bit definition for FLASH_AR register  *******************/
-#define  FLASH_AR_FAR                        ((u32)0xFFFFFFFF)        /* Flash Address */
-
-
-/******************  Bit definition for FLASH_OBR register  *******************/
-#define  FLASH_OBR_OPTERR                    ((u16)0x0001)            /* Option Byte Error */
-#define  FLASH_OBR_RDPRT                     ((u16)0x0002)            /* Read protection */
-
-#define  FLASH_OBR_USER                      ((u16)0x03FC)            /* User Option Bytes */
-#define  FLASH_OBR_WDG_SW                    ((u16)0x0004)            /* WDG_SW */
-#define  FLASH_OBR_nRST_STOP                 ((u16)0x0008)            /* nRST_STOP */
-#define  FLASH_OBR_nRST_STDBY                ((u16)0x0010)            /* nRST_STDBY */
-#define  FLASH_OBR_Notused                   ((u16)0x03E0)            /* Not used */
-
-
-/******************  Bit definition for FLASH_WRPR register  ******************/
-#define  FLASH_WRPR_WRP                        ((u32)0xFFFFFFFF)        /* Write Protect */
-
-
-/*----------------------------------------------------------------------------*/
-
-
-/******************  Bit definition for FLASH_RDP register  *******************/
-#define  FLASH_RDP_RDP                       ((u32)0x000000FF)        /* Read protection option byte */
-#define  FLASH_RDP_nRDP                      ((u32)0x0000FF00)        /* Read protection complemented option byte */
-
-
-/******************  Bit definition for FLASH_USER register  ******************/
-#define  FLASH_USER_USER                     ((u32)0x00FF0000)        /* User option byte */
-#define  FLASH_USER_nUSER                    ((u32)0xFF000000)        /* User complemented option byte */
-
-
-/******************  Bit definition for FLASH_Data0 register  *****************/
-#define  FLASH_Data0_Data0                   ((u32)0x000000FF)        /* User data storage option byte */
-#define  FLASH_Data0_nData0                  ((u32)0x0000FF00)        /* User data storage complemented option byte */
-
-
-/******************  Bit definition for FLASH_Data1 register  *****************/
-#define  FLASH_Data1_Data1                   ((u32)0x00FF0000)        /* User data storage option byte */
-#define  FLASH_Data1_nData1                  ((u32)0xFF000000)        /* User data storage complemented option byte */
-
-
-/******************  Bit definition for FLASH_WRP0 register  ******************/
-#define  FLASH_WRP0_WRP0                     ((u32)0x000000FF)        /* Flash memory write protection option bytes */
-#define  FLASH_WRP0_nWRP0                    ((u32)0x0000FF00)        /* Flash memory write protection complemented option bytes */
-
-
-/******************  Bit definition for FLASH_WRP1 register  ******************/
-#define  FLASH_WRP1_WRP1                     ((u32)0x00FF0000)        /* Flash memory write protection option bytes */
-#define  FLASH_WRP1_nWRP1                    ((u32)0xFF000000)        /* Flash memory write protection complemented option bytes */
-
-
-/******************  Bit definition for FLASH_WRP2 register  ******************/
-#define  FLASH_WRP2_WRP2                     ((u32)0x000000FF)        /* Flash memory write protection option bytes */
-#define  FLASH_WRP2_nWRP2                    ((u32)0x0000FF00)        /* Flash memory write protection complemented option bytes */
-
-
-/******************  Bit definition for FLASH_WRP3 register  ******************/
-#define  FLASH_WRP3_WRP3                     ((u32)0x00FF0000)        /* Flash memory write protection option bytes */
-#define  FLASH_WRP3_nWRP3                    ((u32)0xFF000000)        /* Flash memory write protection complemented option bytes */
-
-
-/* Exported macro ------------------------------------------------------------*/
-#define SET_BIT(REG, BIT)     ((REG) |= (BIT))
-
-#define CLEAR_BIT(REG, BIT)   ((REG) &amp;= ~(BIT))
-
-#define READ_BIT(REG, BIT)    ((REG) &amp; (BIT))
-
-#define CLEAR_REG(REG)        ((REG) = 0x0)
-
-#define WRITE_REG(REG, VAL)   ((REG) = VAL)
-
-#define READ_REG(REG)         ((REG))
-
-#define MODIFY_REG(REG, CLEARMASK, SETMASK)  WRITE_REG((REG), (((READ_REG(REG)) &amp; (~CLEARMASK)) | (SETMASK)))
-
-/* Exported functions ------------------------------------------------------- */
-
-#endif /* __STM32F10x_MAP_H */
-
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/

Deleted: trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_nvic.h
===================================================================
--- trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_nvic.h	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_nvic.h	2009-07-08 23:39:34 UTC (rev 354)
@@ -1,287 +0,0 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_nvic.h
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file contains all the functions prototypes for the
-*                      NVIC firmware library.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
-
-/* Define to prevent recursive inclusion -------------------------------------*/
-#ifndef __STM32F10x_NVIC_H
-#define __STM32F10x_NVIC_H
-
-/* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_map.h&quot;
-
-/* Exported types ------------------------------------------------------------*/
-/* NVIC Init Structure definition */
-typedef struct
-{
-  u8 NVIC_IRQChannel;
-  u8 NVIC_IRQChannelPreemptionPriority;
-  u8 NVIC_IRQChannelSubPriority;
-  FunctionalState NVIC_IRQChannelCmd;
-} NVIC_InitTypeDef;
-
-/* Exported constants --------------------------------------------------------*/
-/* IRQ Channels --------------------------------------------------------------*/
-#define WWDG_IRQChannel              ((u8)0x00)  /* Window WatchDog Interrupt */
-#define PVD_IRQChannel               ((u8)0x01)  /* PVD through EXTI Line detection Interrupt */
-#define TAMPER_IRQChannel            ((u8)0x02)  /* Tamper Interrupt */
-#define RTC_IRQChannel               ((u8)0x03)  /* RTC global Interrupt */
-#define FLASH_IRQChannel             ((u8)0x04)  /* FLASH global Interrupt */
-#define RCC_IRQChannel               ((u8)0x05)  /* RCC global Interrupt */
-#define EXTI0_IRQChannel             ((u8)0x06)  /* EXTI Line0 Interrupt */
-#define EXTI1_IRQChannel             ((u8)0x07)  /* EXTI Line1 Interrupt */
-#define EXTI2_IRQChannel             ((u8)0x08)  /* EXTI Line2 Interrupt */
-#define EXTI3_IRQChannel             ((u8)0x09)  /* EXTI Line3 Interrupt */
-#define EXTI4_IRQChannel             ((u8)0x0A)  /* EXTI Line4 Interrupt */
-#define DMA1_Channel1_IRQChannel     ((u8)0x0B)  /* DMA1 Channel 1 global Interrupt */
-#define DMA1_Channel2_IRQChannel     ((u8)0x0C)  /* DMA1 Channel 2 global Interrupt */
-#define DMA1_Channel3_IRQChannel     ((u8)0x0D)  /* DMA1 Channel 3 global Interrupt */
-#define DMA1_Channel4_IRQChannel     ((u8)0x0E)  /* DMA1 Channel 4 global Interrupt */
-#define DMA1_Channel5_IRQChannel     ((u8)0x0F)  /* DMA1 Channel 5 global Interrupt */
-#define DMA1_Channel6_IRQChannel     ((u8)0x10)  /* DMA1 Channel 6 global Interrupt */
-#define DMA1_Channel7_IRQChannel     ((u8)0x11)  /* DMA1 Channel 7 global Interrupt */
-#define ADC1_2_IRQChannel            ((u8)0x12)  /* ADC1 et ADC2 global Interrupt */
-#define USB_HP_CAN_TX_IRQChannel     ((u8)0x13)  /* USB High Priority or CAN TX Interrupts */
-#define USB_LP_CAN_RX0_IRQChannel    ((u8)0x14)  /* USB Low Priority or CAN RX0 Interrupts */
-#define CAN_RX1_IRQChannel           ((u8)0x15)  /* CAN RX1 Interrupt */
-#define CAN_SCE_IRQChannel           ((u8)0x16)  /* CAN SCE Interrupt */
-#define EXTI9_5_IRQChannel           ((u8)0x17)  /* External Line[9:5] Interrupts */
-#define TIM1_BRK_IRQChannel          ((u8)0x18)  /* TIM1 Break Interrupt */
-#define TIM1_UP_IRQChannel           ((u8)0x19)  /* TIM1 Update Interrupt */
-#define TIM1_TRG_COM_IRQChannel      ((u8)0x1A)  /* TIM1 Trigger and Commutation Interrupt */
-#define TIM1_CC_IRQChannel           ((u8)0x1B)  /* TIM1 Capture Compare Interrupt */
-#define TIM2_IRQChannel              ((u8)0x1C)  /* TIM2 global Interrupt */
-#define TIM3_IRQChannel              ((u8)0x1D)  /* TIM3 global Interrupt */
-#define TIM4_IRQChannel              ((u8)0x1E)  /* TIM4 global Interrupt */
-#define I2C1_EV_IRQChannel           ((u8)0x1F)  /* I2C1 Event Interrupt */
-#define I2C1_ER_IRQChannel           ((u8)0x20)  /* I2C1 Error Interrupt */
-#define I2C2_EV_IRQChannel           ((u8)0x21)  /* I2C2 Event Interrupt */
-#define I2C2_ER_IRQChannel           ((u8)0x22)  /* I2C2 Error Interrupt */
-#define SPI1_IRQChannel              ((u8)0x23)  /* SPI1 global Interrupt */
-#define SPI2_IRQChannel              ((u8)0x24)  /* SPI2 global Interrupt */
-#define USART1_IRQChannel            ((u8)0x25)  /* USART1 global Interrupt */
-#define USART2_IRQChannel            ((u8)0x26)  /* USART2 global Interrupt */
-#define USART3_IRQChannel            ((u8)0x27)  /* USART3 global Interrupt */
-#define EXTI15_10_IRQChannel         ((u8)0x28)  /* External Line[15:10] Interrupts */
-#define RTCAlarm_IRQChannel          ((u8)0x29)  /* RTC Alarm through EXTI Line Interrupt */
-#define USBWakeUp_IRQChannel         ((u8)0x2A)  /* USB WakeUp from suspend through EXTI Line Interrupt */
-#define TIM8_BRK_IRQChannel          ((u8)0x2B)  /* TIM8 Break Interrupt */
-#define TIM8_UP_IRQChannel           ((u8)0x2C)  /* TIM8 Update Interrupt */
-#define TIM8_TRG_COM_IRQChannel      ((u8)0x2D)  /* TIM8 Trigger and Commutation Interrupt */
-#define TIM8_CC_IRQChannel           ((u8)0x2E)  /* TIM8 Capture Compare Interrupt */
-#define ADC3_IRQChannel              ((u8)0x2F)  /* ADC3 global Interrupt */
-#define FSMC_IRQChannel              ((u8)0x30)  /* FSMC global Interrupt */
-#define SDIO_IRQChannel              ((u8)0x31)  /* SDIO global Interrupt */
-#define TIM5_IRQChannel              ((u8)0x32)  /* TIM5 global Interrupt */
-#define SPI3_IRQChannel              ((u8)0x33)  /* SPI3 global Interrupt */
-#define UART4_IRQChannel             ((u8)0x34)  /* UART4 global Interrupt */
-#define UART5_IRQChannel             ((u8)0x35)  /* UART5 global Interrupt */
-#define TIM6_IRQChannel              ((u8)0x36)  /* TIM6 global Interrupt */
-#define TIM7_IRQChannel              ((u8)0x37)  /* TIM7 global Interrupt */
-#define DMA2_Channel1_IRQChannel     ((u8)0x38)  /* DMA2 Channel 1 global Interrupt */
-#define DMA2_Channel2_IRQChannel     ((u8)0x39)  /* DMA2 Channel 2 global Interrupt */
-#define DMA2_Channel3_IRQChannel     ((u8)0x3A)  /* DMA2 Channel 3 global Interrupt */
-#define DMA2_Channel4_5_IRQChannel   ((u8)0x3B)  /* DMA2 Channel 4 and DMA2 Channel 5 global Interrupt */
-
-
-#define IS_NVIC_IRQ_CHANNEL(CHANNEL) (((CHANNEL) == WWDG_IRQChannel) || \
-                                      ((CHANNEL) == PVD_IRQChannel) || \
-                                      ((CHANNEL) == TAMPER_IRQChannel) || \
-                                      ((CHANNEL) == RTC_IRQChannel) || \
-                                      ((CHANNEL) == FLASH_IRQChannel) || \
-                                      ((CHANNEL) == RCC_IRQChannel) || \
-                                      ((CHANNEL) == EXTI0_IRQChannel) || \
-                                      ((CHANNEL) == EXTI1_IRQChannel) || \
-                                      ((CHANNEL) == EXTI2_IRQChannel) || \
-                                      ((CHANNEL) == EXTI3_IRQChannel) || \
-                                      ((CHANNEL) == EXTI4_IRQChannel) || \
-                                      ((CHANNEL) == DMA1_Channel1_IRQChannel) || \
-                                      ((CHANNEL) == DMA1_Channel2_IRQChannel) || \
-                                      ((CHANNEL) == DMA1_Channel3_IRQChannel) || \
-                                      ((CHANNEL) == DMA1_Channel4_IRQChannel) || \
-                                      ((CHANNEL) == DMA1_Channel5_IRQChannel) || \
-                                      ((CHANNEL) == DMA1_Channel6_IRQChannel) || \
-                                      ((CHANNEL) == DMA1_Channel7_IRQChannel) || \
-                                      ((CHANNEL) == ADC1_2_IRQChannel) || \
-                                      ((CHANNEL) == USB_HP_CAN_TX_IRQChannel) || \
-                                      ((CHANNEL) == USB_LP_CAN_RX0_IRQChannel) || \
-                                      ((CHANNEL) == CAN_RX1_IRQChannel) || \
-                                      ((CHANNEL) == CAN_SCE_IRQChannel) || \
-                                      ((CHANNEL) == EXTI9_5_IRQChannel) || \
-                                      ((CHANNEL) == TIM1_BRK_IRQChannel) || \
-                                      ((CHANNEL) == TIM1_UP_IRQChannel) || \
-                                      ((CHANNEL) == TIM1_TRG_COM_IRQChannel) || \
-                                      ((CHANNEL) == TIM1_CC_IRQChannel) || \
-                                      ((CHANNEL) == TIM2_IRQChannel) || \
-                                      ((CHANNEL) == TIM3_IRQChannel) || \
-                                      ((CHANNEL) == TIM4_IRQChannel) || \
-                                      ((CHANNEL) == I2C1_EV_IRQChannel) || \
-                                      ((CHANNEL) == I2C1_ER_IRQChannel) || \
-                                      ((CHANNEL) == I2C2_EV_IRQChannel) || \
-                                      ((CHANNEL) == I2C2_ER_IRQChannel) || \
-                                      ((CHANNEL) == SPI1_IRQChannel) || \
-                                      ((CHANNEL) == SPI2_IRQChannel) || \
-                                      ((CHANNEL) == USART1_IRQChannel) || \
-                                      ((CHANNEL) == USART2_IRQChannel) || \
-                                      ((CHANNEL) == USART3_IRQChannel) || \
-                                      ((CHANNEL) == EXTI15_10_IRQChannel) || \
-                                      ((CHANNEL) == RTCAlarm_IRQChannel) || \
-                                      ((CHANNEL) == USBWakeUp_IRQChannel) || \
-                                      ((CHANNEL) == TIM8_BRK_IRQChannel) || \
-                                      ((CHANNEL) == TIM8_UP_IRQChannel) || \
-                                      ((CHANNEL) == TIM8_TRG_COM_IRQChannel) || \
-                                      ((CHANNEL) == TIM8_CC_IRQChannel) || \
-                                      ((CHANNEL) == ADC3_IRQChannel) || \
-                                      ((CHANNEL) == FSMC_IRQChannel) || \
-                                      ((CHANNEL) == SDIO_IRQChannel) || \
-                                      ((CHANNEL) == TIM5_IRQChannel) || \
-                                      ((CHANNEL) == SPI3_IRQChannel) || \
-                                      ((CHANNEL) == UART4_IRQChannel) || \
-                                      ((CHANNEL) == UART5_IRQChannel) || \
-                                      ((CHANNEL) == TIM6_IRQChannel) || \
-                                      ((CHANNEL) == TIM7_IRQChannel) || \
-                                      ((CHANNEL) == DMA2_Channel1_IRQChannel) || \
-                                      ((CHANNEL) == DMA2_Channel2_IRQChannel) || \
-                                      ((CHANNEL) == DMA2_Channel3_IRQChannel) || \
-                                      ((CHANNEL) == DMA2_Channel4_5_IRQChannel))
-
-
-/* System Handlers -----------------------------------------------------------*/
-#define SystemHandler_NMI            ((u32)0x00001F) /* NMI Handler */
-#define SystemHandler_HardFault      ((u32)0x000000) /* Hard Fault Handler */
-#define SystemHandler_MemoryManage   ((u32)0x043430) /* Memory Manage Handler */
-#define SystemHandler_BusFault       ((u32)0x547931) /* Bus Fault Handler */
-#define SystemHandler_UsageFault     ((u32)0x24C232) /* Usage Fault Handler */
-#define SystemHandler_SVCall         ((u32)0x01FF40) /* SVCall Handler */
-#define SystemHandler_DebugMonitor   ((u32)0x0A0080) /* Debug Monitor Handler */
-#define SystemHandler_PSV            ((u32)0x02829C) /* PSV Handler */
-#define SystemHandler_SysTick        ((u32)0x02C39A) /* SysTick Handler */
-
-#define IS_CONFIG_SYSTEM_HANDLER(HANDLER) (((HANDLER) == SystemHandler_MemoryManage) || \
-                                           ((HANDLER) == SystemHandler_BusFault) || \
-                                           ((HANDLER) == SystemHandler_UsageFault))
-
-#define IS_PRIORITY_SYSTEM_HANDLER(HANDLER) (((HANDLER) == SystemHandler_MemoryManage) || \
-                                             ((HANDLER) == SystemHandler_BusFault) || \
-                                             ((HANDLER) == SystemHandler_UsageFault) || \
-                                             ((HANDLER) == SystemHandler_SVCall) || \
-                                             ((HANDLER) == SystemHandler_DebugMonitor) || \
-                                             ((HANDLER) == SystemHandler_PSV) || \
-                                             ((HANDLER) == SystemHandler_SysTick))
-
-#define IS_GET_PENDING_SYSTEM_HANDLER(HANDLER) (((HANDLER) == SystemHandler_MemoryManage) || \
-                                                ((HANDLER) == SystemHandler_BusFault) || \
-                                                ((HANDLER) == SystemHandler_SVCall))
-
-#define IS_SET_PENDING_SYSTEM_HANDLER(HANDLER) (((HANDLER) == SystemHandler_NMI) || \
-                                                ((HANDLER) == SystemHandler_PSV) || \
-                                                ((HANDLER) == SystemHandler_SysTick))
-
-#define IS_CLEAR_SYSTEM_HANDLER(HANDLER) (((HANDLER) == SystemHandler_PSV) || \
-                                          ((HANDLER) == SystemHandler_SysTick))
-
-#define IS_GET_ACTIVE_SYSTEM_HANDLER(HANDLER) (((HANDLER) == SystemHandler_MemoryManage) || \
-                                               ((HANDLER) == SystemHandler_BusFault) || \
-                                               ((HANDLER) == SystemHandler_UsageFault) || \
-                                               ((HANDLER) == SystemHandler_SVCall) || \
-                                               ((HANDLER) == SystemHandler_DebugMonitor) || \
-                                               ((HANDLER) == SystemHandler_PSV) || \
-                                               ((HANDLER) == SystemHandler_SysTick))
-
-#define IS_FAULT_SOURCE_SYSTEM_HANDLER(HANDLER) (((HANDLER) == SystemHandler_HardFault) || \
-                                                 ((HANDLER) == SystemHandler_MemoryManage) || \
-                                                 ((HANDLER) == SystemHandler_BusFault) || \
-                                                 ((HANDLER) == SystemHandler_UsageFault) || \
-                                                 ((HANDLER) == SystemHandler_DebugMonitor)) 
-
-#define IS_FAULT_ADDRESS_SYSTEM_HANDLER(HANDLER) (((HANDLER) == SystemHandler_MemoryManage) || \
-                                                  ((HANDLER) == SystemHandler_BusFault))
-
-
-/* Vector Table Base ---------------------------------------------------------*/
-#define NVIC_VectTab_RAM             ((u32)0x20000000)
-#define NVIC_VectTab_FLASH           ((u32)0x08000000)
-
-#define IS_NVIC_VECTTAB(VECTTAB) (((VECTTAB) == NVIC_VectTab_RAM) || \
-                                  ((VECTTAB) == NVIC_VectTab_FLASH))
-
-/* System Low Power ----------------------------------------------------------*/
-#define NVIC_LP_SEVONPEND            ((u8)0x10)
-#define NVIC_LP_SLEEPDEEP            ((u8)0x04)
-#define NVIC_LP_SLEEPONEXIT          ((u8)0x02)
-
-#define IS_NVIC_LP(LP) (((LP) == NVIC_LP_SEVONPEND) || \
-                        ((LP) == NVIC_LP_SLEEPDEEP) || \
-                        ((LP) == NVIC_LP_SLEEPONEXIT))
-
-/* Preemption Priority Group -------------------------------------------------*/
-#define NVIC_PriorityGroup_0         ((u32)0x700) /* 0 bits for pre-emption priority
-                                                     4 bits for subpriority */
-#define NVIC_PriorityGroup_1         ((u32)0x600) /* 1 bits for pre-emption priority
-                                                     3 bits for subpriority */
-#define NVIC_PriorityGroup_2         ((u32)0x500) /* 2 bits for pre-emption priority
-                                                     2 bits for subpriority */
-#define NVIC_PriorityGroup_3         ((u32)0x400) /* 3 bits for pre-emption priority
-                                                     1 bits for subpriority */
-#define NVIC_PriorityGroup_4         ((u32)0x300) /* 4 bits for pre-emption priority
-                                                     0 bits for subpriority */
-
-#define IS_NVIC_PRIORITY_GROUP(GROUP) (((GROUP) == NVIC_PriorityGroup_0) || \
-                                       ((GROUP) == NVIC_PriorityGroup_1) || \
-                                       ((GROUP) == NVIC_PriorityGroup_2) || \
-                                       ((GROUP) == NVIC_PriorityGroup_3) || \
-                                       ((GROUP) == NVIC_PriorityGroup_4))
-
-#define IS_NVIC_PREEMPTION_PRIORITY(PRIORITY)  ((PRIORITY) &lt; 0x10)
-#define IS_NVIC_SUB_PRIORITY(PRIORITY)  ((PRIORITY) &lt; 0x10)
-#define IS_NVIC_OFFSET(OFFSET)  ((OFFSET) &lt; 0x0007FFFF)
-#define IS_NVIC_BASE_PRI(PRI)   ((PRI) &lt; 0x10)
-
-/* Exported macro ------------------------------------------------------------*/
-/* Exported functions ------------------------------------------------------- */
-void NVIC_DeInit(void);
-void NVIC_SCBDeInit(void);
-void NVIC_PriorityGroupConfig(u32 NVIC_PriorityGroup);
-void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct);
-void NVIC_StructInit(NVIC_InitTypeDef* NVIC_InitStruct);
-void NVIC_SETPRIMASK(void);
-void NVIC_RESETPRIMASK(void);
-void NVIC_SETFAULTMASK(void);
-void NVIC_RESETFAULTMASK(void);
-void NVIC_BASEPRICONFIG(u32 NewPriority);
-u32 NVIC_GetBASEPRI(void);
-u16 NVIC_GetCurrentPendingIRQChannel(void);
-ITStatus NVIC_GetIRQChannelPendingBitStatus(u8 NVIC_IRQChannel);
-void NVIC_SetIRQChannelPendingBit(u8 NVIC_IRQChannel);
-void NVIC_ClearIRQChannelPendingBit(u8 NVIC_IRQChannel);
-u16 NVIC_GetCurrentActiveHandler(void);
-ITStatus NVIC_GetIRQChannelActiveBitStatus(u8 NVIC_IRQChannel);
-u32 NVIC_GetCPUID(void);
-void NVIC_SetVectorTable(u32 NVIC_VectTab, u32 Offset);
-void NVIC_GenerateSystemReset(void);
-void NVIC_GenerateCoreReset(void);
-void NVIC_SystemLPConfig(u8 LowPowerMode, FunctionalState NewState);
-void NVIC_SystemHandlerConfig(u32 SystemHandler, FunctionalState NewState);
-void NVIC_SystemHandlerPriorityConfig(u32 SystemHandler, u8 SystemHandlerPreemptionPriority,
-                                      u8 SystemHandlerSubPriority);
-ITStatus NVIC_GetSystemHandlerPendingBitStatus(u32 SystemHandler);
-void NVIC_SetSystemHandlerPendingBit(u32 SystemHandler);
-void NVIC_ClearSystemHandlerPendingBit(u32 SystemHandler);
-ITStatus NVIC_GetSystemHandlerActiveBitStatus(u32 SystemHandler);
-u32 NVIC_GetFaultHandlerSources(u32 SystemHandler);
-u32 NVIC_GetFaultAddress(u32 SystemHandler);
-
-#endif /* __STM32F10x_NVIC_H */
-
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/

Modified: trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_pwr.h
===================================================================
--- trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_pwr.h	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_pwr.h	2009-07-08 23:39:34 UTC (rev 354)
@@ -1,77 +1,155 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_pwr.h
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file contains all the functions prototypes for the
-*                      PWR firmware library.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
+/**
+  ******************************************************************************
+  * @file    stm32f10x_pwr.h
+  * @author  MCD Application Team
+  * @version V3.1.0
+  * @date    06/19/2009
+  * @brief   This file contains all the functions prototypes for the PWR firmware 
+  *          library.
+  ******************************************************************************
+  * @copy
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * &lt;h2&gt;&lt;center&gt;&copy; COPYRIGHT 2009 STMicroelectronics&lt;/center&gt;&lt;/h2&gt;
+  */ 
 
 /* Define to prevent recursive inclusion -------------------------------------*/
 #ifndef __STM32F10x_PWR_H
 #define __STM32F10x_PWR_H
 
+#ifdef __cplusplus
+ extern &quot;C&quot; {
+#endif
+
 /* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_map.h&quot;
+#include &quot;stm32f10x.h&quot;
 
-/* Exported types ------------------------------------------------------------*/
-/* Exported constants --------------------------------------------------------*/
-/* PVD detection level */
-#define PWR_PVDLevel_2V2          ((u32)0x00000000)
-#define PWR_PVDLevel_2V3          ((u32)0x00000020)
-#define PWR_PVDLevel_2V4          ((u32)0x00000040)
-#define PWR_PVDLevel_2V5          ((u32)0x00000060)
-#define PWR_PVDLevel_2V6          ((u32)0x00000080)
-#define PWR_PVDLevel_2V7          ((u32)0x000000A0)
-#define PWR_PVDLevel_2V8          ((u32)0x000000C0)
-#define PWR_PVDLevel_2V9          ((u32)0x000000E0)
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
 
+/** @addtogroup PWR
+  * @{
+  */ 
+
+/** @defgroup PWR_Exported_Types
+  * @{
+  */ 
+
+/**
+  * @}
+  */ 
+
+/** @defgroup PWR_Exported_Constants
+  * @{
+  */ 
+
+/** @defgroup PVD_detection_level 
+  * @{
+  */ 
+
+#define PWR_PVDLevel_2V2          ((uint32_t)0x00000000)
+#define PWR_PVDLevel_2V3          ((uint32_t)0x00000020)
+#define PWR_PVDLevel_2V4          ((uint32_t)0x00000040)
+#define PWR_PVDLevel_2V5          ((uint32_t)0x00000060)
+#define PWR_PVDLevel_2V6          ((uint32_t)0x00000080)
+#define PWR_PVDLevel_2V7          ((uint32_t)0x000000A0)
+#define PWR_PVDLevel_2V8          ((uint32_t)0x000000C0)
+#define PWR_PVDLevel_2V9          ((uint32_t)0x000000E0)
 #define IS_PWR_PVD_LEVEL(LEVEL) (((LEVEL) == PWR_PVDLevel_2V2) || ((LEVEL) == PWR_PVDLevel_2V3)|| \
                                  ((LEVEL) == PWR_PVDLevel_2V4) || ((LEVEL) == PWR_PVDLevel_2V5)|| \
                                  ((LEVEL) == PWR_PVDLevel_2V6) || ((LEVEL) == PWR_PVDLevel_2V7)|| \
                                  ((LEVEL) == PWR_PVDLevel_2V8) || ((LEVEL) == PWR_PVDLevel_2V9))
+/**
+  * @}
+  */
 
-/* Regulator state is STOP mode */
-#define PWR_Regulator_ON          ((u32)0x00000000)
-#define PWR_Regulator_LowPower    ((u32)0x00000001)
+/** @defgroup Regulator_state_is_STOP_mode 
+  * @{
+  */
 
+#define PWR_Regulator_ON          ((uint32_t)0x00000000)
+#define PWR_Regulator_LowPower    ((uint32_t)0x00000001)
 #define IS_PWR_REGULATOR(REGULATOR) (((REGULATOR) == PWR_Regulator_ON) || \
                                      ((REGULATOR) == PWR_Regulator_LowPower))
+/**
+  * @}
+  */
 
-/* STOP mode entry */
-#define PWR_STOPEntry_WFI         ((u8)0x01)
-#define PWR_STOPEntry_WFE         ((u8)0x02)
+/** @defgroup STOP_mode_entry 
+  * @{
+  */
 
+#define PWR_STOPEntry_WFI         ((uint8_t)0x01)
+#define PWR_STOPEntry_WFE         ((uint8_t)0x02)
 #define IS_PWR_STOP_ENTRY(ENTRY) (((ENTRY) == PWR_STOPEntry_WFI) || ((ENTRY) == PWR_STOPEntry_WFE))
  
-/* PWR Flag */
-#define PWR_FLAG_WU               ((u32)0x00000001)
-#define PWR_FLAG_SB               ((u32)0x00000002)
-#define PWR_FLAG_PVDO             ((u32)0x00000004)
+/**
+  * @}
+  */
 
+/** @defgroup PWR_Flag 
+  * @{
+  */
+
+#define PWR_FLAG_WU               ((uint32_t)0x00000001)
+#define PWR_FLAG_SB               ((uint32_t)0x00000002)
+#define PWR_FLAG_PVDO             ((uint32_t)0x00000004)
 #define IS_PWR_GET_FLAG(FLAG) (((FLAG) == PWR_FLAG_WU) || ((FLAG) == PWR_FLAG_SB) || \
                                ((FLAG) == PWR_FLAG_PVDO))
+
 #define IS_PWR_CLEAR_FLAG(FLAG) (((FLAG) == PWR_FLAG_WU) || ((FLAG) == PWR_FLAG_SB))
+/**
+  * @}
+  */
 
-/* Exported macro ------------------------------------------------------------*/
-/* Exported functions ------------------------------------------------------- */
+/**
+  * @}
+  */
+
+/** @defgroup PWR_Exported_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup PWR_Exported_Functions
+  * @{
+  */
+
 void PWR_DeInit(void);
 void PWR_BackupAccessCmd(FunctionalState NewState);
 void PWR_PVDCmd(FunctionalState NewState);
-void PWR_PVDLevelConfig(u32 PWR_PVDLevel);
+void PWR_PVDLevelConfig(uint32_t PWR_PVDLevel);
 void PWR_WakeUpPinCmd(FunctionalState NewState);
-void PWR_EnterSTOPMode(u32 PWR_Regulator, u8 PWR_STOPEntry);
+void PWR_EnterSTOPMode(uint32_t PWR_Regulator, uint8_t PWR_STOPEntry);
 void PWR_EnterSTANDBYMode(void);
-FlagStatus PWR_GetFlagStatus(u32 PWR_FLAG);
-void PWR_ClearFlag(u32 PWR_FLAG);
+FlagStatus PWR_GetFlagStatus(uint32_t PWR_FLAG);
+void PWR_ClearFlag(uint32_t PWR_FLAG);
 
+#ifdef __cplusplus
+}
+#endif
+
 #endif /* __STM32F10x_PWR_H */
+/**
+  * @}
+  */
 
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2009 STMicroelectronics *****END OF FILE****/

Modified: trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_rcc.h
===================================================================
--- trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_rcc.h	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_rcc.h	2009-07-08 23:39:34 UTC (rev 354)
@@ -1,288 +1,700 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_rcc.h
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file contains all the functions prototypes for the
-*                      RCC firmware library.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
+/**
+  ******************************************************************************
+  * @file    stm32f10x_rcc.h
+  * @author  MCD Application Team
+  * @version V3.1.0
+  * @date    06/19/2009
+  * @brief   This file contains all the functions prototypes for the RCC firmware 
+  *          library.
+  ******************************************************************************
+  * @copy
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * &lt;h2&gt;&lt;center&gt;&copy; COPYRIGHT 2009 STMicroelectronics&lt;/center&gt;&lt;/h2&gt;
+  */ 
 
 /* Define to prevent recursive inclusion -------------------------------------*/
 #ifndef __STM32F10x_RCC_H
 #define __STM32F10x_RCC_H
 
+#ifdef __cplusplus
+ extern &quot;C&quot; {
+#endif
+
 /* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_map.h&quot;
+#include &quot;stm32f10x.h&quot;
 
-/* Exported types ------------------------------------------------------------*/
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @addtogroup RCC
+  * @{
+  */
+
+/** @defgroup RCC_Exported_Types
+  * @{
+  */
+
 typedef struct
 {
-  u32 SYSCLK_Frequency;
-  u32 HCLK_Frequency;
-  u32 PCLK1_Frequency;
-  u32 PCLK2_Frequency;
-  u32 ADCCLK_Frequency;
+  uint32_t SYSCLK_Frequency;  /*!&lt; returns SYSCLK clock frequency expressed in Hz */
+  uint32_t HCLK_Frequency;    /*!&lt; returns HCLK clock frequency expressed in Hz */
+  uint32_t PCLK1_Frequency;   /*!&lt; returns PCLK1 clock frequency expressed in Hz */
+  uint32_t PCLK2_Frequency;   /*!&lt; returns PCLK2 clock frequency expressed in Hz */
+  uint32_t ADCCLK_Frequency;  /*!&lt; returns ADCCLK clock frequency expressed in Hz */
 }RCC_ClocksTypeDef;
 
-/* Exported constants --------------------------------------------------------*/
-/* HSE configuration */
-#define RCC_HSE_OFF                      ((u32)0x00000000)
-#define RCC_HSE_ON                       ((u32)0x00010000)
-#define RCC_HSE_Bypass                   ((u32)0x00040000)
+/**
+  * @}
+  */
 
+/** @defgroup RCC_Exported_Constants
+  * @{
+  */
+
+/** @defgroup HSE_configuration 
+  * @{
+  */
+
+#define RCC_HSE_OFF                      ((uint32_t)0x00000000)
+#define RCC_HSE_ON                       ((uint32_t)0x00010000)
+#define RCC_HSE_Bypass                   ((uint32_t)0x00040000)
 #define IS_RCC_HSE(HSE) (((HSE) == RCC_HSE_OFF) || ((HSE) == RCC_HSE_ON) || \
                          ((HSE) == RCC_HSE_Bypass))
 
-/* PLL entry clock source */
-#define RCC_PLLSource_HSI_Div2           ((u32)0x00000000)
-#define RCC_PLLSource_HSE_Div1           ((u32)0x00010000)
-#define RCC_PLLSource_HSE_Div2           ((u32)0x00030000)
+/**
+  * @}
+  */ 
 
-#define IS_RCC_PLL_SOURCE(SOURCE) (((SOURCE) == RCC_PLLSource_HSI_Div2) || \
+/** @defgroup PLL_entry_clock_source 
+  * @{
+  */
+
+#define RCC_PLLSource_HSI_Div2           ((uint32_t)0x00000000)
+
+#ifndef STM32F10X_CL
+ #define RCC_PLLSource_HSE_Div1           ((uint32_t)0x00010000)
+ #define RCC_PLLSource_HSE_Div2           ((uint32_t)0x00030000)
+ #define IS_RCC_PLL_SOURCE(SOURCE) (((SOURCE) == RCC_PLLSource_HSI_Div2) || \
                                    ((SOURCE) == RCC_PLLSource_HSE_Div1) || \
                                    ((SOURCE) == RCC_PLLSource_HSE_Div2))
+#else
+ #define RCC_PLLSource_PREDIV1            ((uint32_t)0x00010000)
+#define IS_RCC_PLL_SOURCE(SOURCE) (((SOURCE) == RCC_PLLSource_HSI_Div2) || \
+                                   ((SOURCE) == RCC_PLLSource_PREDIV1))
+#endif /* STM32F10X_CL */ 
 
-/* PLL multiplication factor */
-#define RCC_PLLMul_2                     ((u32)0x00000000)
-#define RCC_PLLMul_3                     ((u32)0x00040000)
-#define RCC_PLLMul_4                     ((u32)0x00080000)
-#define RCC_PLLMul_5                     ((u32)0x000C0000)
-#define RCC_PLLMul_6                     ((u32)0x00100000)
-#define RCC_PLLMul_7                     ((u32)0x00140000)
-#define RCC_PLLMul_8                     ((u32)0x00180000)
-#define RCC_PLLMul_9                     ((u32)0x001C0000)
-#define RCC_PLLMul_10                    ((u32)0x00200000)
-#define RCC_PLLMul_11                    ((u32)0x00240000)
-#define RCC_PLLMul_12                    ((u32)0x00280000)
-#define RCC_PLLMul_13                    ((u32)0x002C0000)
-#define RCC_PLLMul_14                    ((u32)0x00300000)
-#define RCC_PLLMul_15                    ((u32)0x00340000)
-#define RCC_PLLMul_16                    ((u32)0x00380000)
+/**
+  * @}
+  */ 
 
-#define IS_RCC_PLL_MUL(MUL) (((MUL) == RCC_PLLMul_2) || ((MUL) == RCC_PLLMul_3)   || \
-                             ((MUL) == RCC_PLLMul_4) || ((MUL) == RCC_PLLMul_5)   || \
-                             ((MUL) == RCC_PLLMul_6) || ((MUL) == RCC_PLLMul_7)   || \
-                             ((MUL) == RCC_PLLMul_8) || ((MUL) == RCC_PLLMul_9)   || \
-                             ((MUL) == RCC_PLLMul_10) || ((MUL) == RCC_PLLMul_11) || \
-                             ((MUL) == RCC_PLLMul_12) || ((MUL) == RCC_PLLMul_13) || \
-                             ((MUL) == RCC_PLLMul_14) || ((MUL) == RCC_PLLMul_15) || \
-                             ((MUL) == RCC_PLLMul_16))
+/** @defgroup PLL_multiplication_factor 
+  * @{
+  */
+#ifndef STM32F10X_CL
+ #define RCC_PLLMul_2                    ((uint32_t)0x00000000)
+ #define RCC_PLLMul_3                    ((uint32_t)0x00040000)
+ #define RCC_PLLMul_4                    ((uint32_t)0x00080000)
+ #define RCC_PLLMul_5                    ((uint32_t)0x000C0000)
+ #define RCC_PLLMul_6                    ((uint32_t)0x00100000)
+ #define RCC_PLLMul_7                    ((uint32_t)0x00140000)
+ #define RCC_PLLMul_8                    ((uint32_t)0x00180000)
+ #define RCC_PLLMul_9                    ((uint32_t)0x001C0000)
+ #define RCC_PLLMul_10                   ((uint32_t)0x00200000)
+ #define RCC_PLLMul_11                   ((uint32_t)0x00240000)
+ #define RCC_PLLMul_12                   ((uint32_t)0x00280000)
+ #define RCC_PLLMul_13                   ((uint32_t)0x002C0000)
+ #define RCC_PLLMul_14                   ((uint32_t)0x00300000)
+ #define RCC_PLLMul_15                   ((uint32_t)0x00340000)
+ #define RCC_PLLMul_16                   ((uint32_t)0x00380000)
+ #define IS_RCC_PLL_MUL(MUL) (((MUL) == RCC_PLLMul_2) || ((MUL) == RCC_PLLMul_3)   || \
+                              ((MUL) == RCC_PLLMul_4) || ((MUL) == RCC_PLLMul_5)   || \
+                              ((MUL) == RCC_PLLMul_6) || ((MUL) == RCC_PLLMul_7)   || \
+                              ((MUL) == RCC_PLLMul_8) || ((MUL) == RCC_PLLMul_9)   || \
+                              ((MUL) == RCC_PLLMul_10) || ((MUL) == RCC_PLLMul_11) || \
+                              ((MUL) == RCC_PLLMul_12) || ((MUL) == RCC_PLLMul_13) || \
+                              ((MUL) == RCC_PLLMul_14) || ((MUL) == RCC_PLLMul_15) || \
+                              ((MUL) == RCC_PLLMul_16))
 
-/* System clock source */
-#define RCC_SYSCLKSource_HSI             ((u32)0x00000000)
-#define RCC_SYSCLKSource_HSE             ((u32)0x00000001)
-#define RCC_SYSCLKSource_PLLCLK          ((u32)0x00000002)
+#else
+ #define RCC_PLLMul_4                    ((uint32_t)0x00080000)
+ #define RCC_PLLMul_5                    ((uint32_t)0x000C0000)
+ #define RCC_PLLMul_6                    ((uint32_t)0x00100000)
+ #define RCC_PLLMul_7                    ((uint32_t)0x00140000)
+ #define RCC_PLLMul_8                    ((uint32_t)0x00180000)
+ #define RCC_PLLMul_9                    ((uint32_t)0x001C0000)
+ #define RCC_PLLMul_6_5                  ((uint32_t)0x00340000)
 
+ #define IS_RCC_PLL_MUL(MUL) (((MUL) == RCC_PLLMul_4) || ((MUL) == RCC_PLLMul_5) || \
+                              ((MUL) == RCC_PLLMul_6) || ((MUL) == RCC_PLLMul_7) || \
+                              ((MUL) == RCC_PLLMul_8) || ((MUL) == RCC_PLLMul_9) || \
+                              ((MUL) == RCC_PLLMul_6_5))
+#endif /* STM32F10X_CL */                              
+/**
+  * @}
+  */
+
+#ifdef STM32F10X_CL
+/** @defgroup PREDIV1_division_factor
+  * @{
+  */
+ #define  RCC_PREDIV1_Div1               ((uint32_t)0x00000000)
+ #define  RCC_PREDIV1_Div2               ((uint32_t)0x00000001)
+ #define  RCC_PREDIV1_Div3               ((uint32_t)0x00000002)
+ #define  RCC_PREDIV1_Div4               ((uint32_t)0x00000003)
+ #define  RCC_PREDIV1_Div5               ((uint32_t)0x00000004)
+ #define  RCC_PREDIV1_Div6               ((uint32_t)0x00000005)
+ #define  RCC_PREDIV1_Div7               ((uint32_t)0x00000006)
+ #define  RCC_PREDIV1_Div8               ((uint32_t)0x00000007)
+ #define  RCC_PREDIV1_Div9               ((uint32_t)0x00000008)
+ #define  RCC_PREDIV1_Div10              ((uint32_t)0x00000009)
+ #define  RCC_PREDIV1_Div11              ((uint32_t)0x0000000A)
+ #define  RCC_PREDIV1_Div12              ((uint32_t)0x0000000B)
+ #define  RCC_PREDIV1_Div13              ((uint32_t)0x0000000C)
+ #define  RCC_PREDIV1_Div14              ((uint32_t)0x0000000D)
+ #define  RCC_PREDIV1_Div15              ((uint32_t)0x0000000E)
+ #define  RCC_PREDIV1_Div16              ((uint32_t)0x0000000F)
+
+ #define IS_RCC_PREDIV1(PREDIV1) (((PREDIV1) == RCC_PREDIV1_Div1) || ((PREDIV1) == RCC_PREDIV1_Div2) || \
+                                  ((PREDIV1) == RCC_PREDIV1_Div3) || ((PREDIV1) == RCC_PREDIV1_Div4) || \
+                                  ((PREDIV1) == RCC_PREDIV1_Div5) || ((PREDIV1) == RCC_PREDIV1_Div6) || \
+                                  ((PREDIV1) == RCC_PREDIV1_Div7) || ((PREDIV1) == RCC_PREDIV1_Div8) || \
+                                  ((PREDIV1) == RCC_PREDIV1_Div9) || ((PREDIV1) == RCC_PREDIV1_Div10) || \
+                                  ((PREDIV1) == RCC_PREDIV1_Div11) || ((PREDIV1) == RCC_PREDIV1_Div12) || \
+                                  ((PREDIV1) == RCC_PREDIV1_Div13) || ((PREDIV1) == RCC_PREDIV1_Div14) || \
+                                  ((PREDIV1) == RCC_PREDIV1_Div15) || ((PREDIV1) == RCC_PREDIV1_Div16))
+/**
+  * @}
+  */
+
+
+/** @defgroup PREDIV1_clock_source
+  * @{
+  */
+/* PREDIV1 clock source (only for STM32 connectivity line devices) */
+ #define  RCC_PREDIV1_Source_HSE         ((uint32_t)0x00000000) 
+ #define  RCC_PREDIV1_Source_PLL2        ((uint32_t)0x00010000) 
+
+ #define IS_RCC_PREDIV1_SOURCE(SOURCE) (((SOURCE) == RCC_PREDIV1_Source_HSE) || \
+                                        ((SOURCE) == RCC_PREDIV1_Source_PLL2)) 
+/**
+  * @}
+  */
+
+
+/** @defgroup PREDIV2_division_factor
+  * @{
+  */
+  
+ #define  RCC_PREDIV2_Div1               ((uint32_t)0x00000000)
+ #define  RCC_PREDIV2_Div2               ((uint32_t)0x00000010)
+ #define  RCC_PREDIV2_Div3               ((uint32_t)0x00000020)
+ #define  RCC_PREDIV2_Div4               ((uint32_t)0x00000030)
+ #define  RCC_PREDIV2_Div5               ((uint32_t)0x00000040)
+ #define  RCC_PREDIV2_Div6               ((uint32_t)0x00000050)
+ #define  RCC_PREDIV2_Div7               ((uint32_t)0x00000060)
+ #define  RCC_PREDIV2_Div8               ((uint32_t)0x00000070)
+ #define  RCC_PREDIV2_Div9               ((uint32_t)0x00000080)
+ #define  RCC_PREDIV2_Div10              ((uint32_t)0x00000090)
+ #define  RCC_PREDIV2_Div11              ((uint32_t)0x000000A0)
+ #define  RCC_PREDIV2_Div12              ((uint32_t)0x000000B0)
+ #define  RCC_PREDIV2_Div13              ((uint32_t)0x000000C0)
+ #define  RCC_PREDIV2_Div14              ((uint32_t)0x000000D0)
+ #define  RCC_PREDIV2_Div15              ((uint32_t)0x000000E0)
+ #define  RCC_PREDIV2_Div16              ((uint32_t)0x000000F0)
+
+ #define IS_RCC_PREDIV2(PREDIV2) (((PREDIV2) == RCC_PREDIV2_Div1) || ((PREDIV2) == RCC_PREDIV2_Div2) || \
+                                  ((PREDIV2) == RCC_PREDIV2_Div3) || ((PREDIV2) == RCC_PREDIV2_Div4) || \
+                                  ((PREDIV2) == RCC_PREDIV2_Div5) || ((PREDIV2) == RCC_PREDIV2_Div6) || \
+                                  ((PREDIV2) == RCC_PREDIV2_Div7) || ((PREDIV2) == RCC_PREDIV2_Div8) || \
+                                  ((PREDIV2) == RCC_PREDIV2_Div9) || ((PREDIV2) == RCC_PREDIV2_Div10) || \
+                                  ((PREDIV2) == RCC_PREDIV2_Div11) || ((PREDIV2) == RCC_PREDIV2_Div12) || \
+                                  ((PREDIV2) == RCC_PREDIV2_Div13) || ((PREDIV2) == RCC_PREDIV2_Div14) || \
+                                  ((PREDIV2) == RCC_PREDIV2_Div15) || ((PREDIV2) == RCC_PREDIV2_Div16))
+/**
+  * @}
+  */
+
+
+/** @defgroup PLL2_multiplication_factor
+  * @{
+  */
+  
+ #define  RCC_PLL2Mul_8                  ((uint32_t)0x00000600)
+ #define  RCC_PLL2Mul_9                  ((uint32_t)0x00000700)
+ #define  RCC_PLL2Mul_10                 ((uint32_t)0x00000800)
+ #define  RCC_PLL2Mul_11                 ((uint32_t)0x00000900)
+ #define  RCC_PLL2Mul_12                 ((uint32_t)0x00000A00)
+ #define  RCC_PLL2Mul_13                 ((uint32_t)0x00000B00)
+ #define  RCC_PLL2Mul_14                 ((uint32_t)0x00000C00)
+ #define  RCC_PLL2Mul_16                 ((uint32_t)0x00000E00)
+ #define  RCC_PLL2Mul_20                 ((uint32_t)0x00000F00)
+
+ #define IS_RCC_PLL2_MUL(MUL) (((MUL) == RCC_PLL2Mul_8) || ((MUL) == RCC_PLL2Mul_9)  || \
+                               ((MUL) == RCC_PLL2Mul_10) || ((MUL) == RCC_PLL2Mul_11) || \
+                               ((MUL) == RCC_PLL2Mul_12) || ((MUL) == RCC_PLL2Mul_13) || \
+                               ((MUL) == RCC_PLL2Mul_14) || ((MUL) == RCC_PLL2Mul_16) || \
+                               ((MUL) == RCC_PLL2Mul_20))
+/**
+  * @}
+  */
+
+
+/** @defgroup PLL3_multiplication_factor
+  * @{
+  */
+
+ #define  RCC_PLL3Mul_8                  ((uint32_t)0x00006000)
+ #define  RCC_PLL3Mul_9                  ((uint32_t)0x00007000)
+ #define  RCC_PLL3Mul_10                 ((uint32_t)0x00008000)
+ #define  RCC_PLL3Mul_11                 ((uint32_t)0x00009000)
+ #define  RCC_PLL3Mul_12                 ((uint32_t)0x0000A000)
+ #define  RCC_PLL3Mul_13                 ((uint32_t)0x0000B000)
+ #define  RCC_PLL3Mul_14                 ((uint32_t)0x0000C000)
+ #define  RCC_PLL3Mul_16                 ((uint32_t)0x0000E000)
+ #define  RCC_PLL3Mul_20                 ((uint32_t)0x0000F000)
+
+ #define IS_RCC_PLL3_MUL(MUL) (((MUL) == RCC_PLL3Mul_8) || ((MUL) == RCC_PLL3Mul_9)  || \
+                               ((MUL) == RCC_PLL3Mul_10) || ((MUL) == RCC_PLL3Mul_11) || \
+                               ((MUL) == RCC_PLL3Mul_12) || ((MUL) == RCC_PLL3Mul_13) || \
+                               ((MUL) == RCC_PLL3Mul_14) || ((MUL) == RCC_PLL3Mul_16) || \
+                               ((MUL) == RCC_PLL3Mul_20))
+/**
+  * @}
+  */
+
+#endif /* STM32F10X_CL */
+
+
+/** @defgroup System_clock_source 
+  * @{
+  */
+
+#define RCC_SYSCLKSource_HSI             ((uint32_t)0x00000000)
+#define RCC_SYSCLKSource_HSE             ((uint32_t)0x00000001)
+#define RCC_SYSCLKSource_PLLCLK          ((uint32_t)0x00000002)
 #define IS_RCC_SYSCLK_SOURCE(SOURCE) (((SOURCE) == RCC_SYSCLKSource_HSI) || \
                                       ((SOURCE) == RCC_SYSCLKSource_HSE) || \
                                       ((SOURCE) == RCC_SYSCLKSource_PLLCLK))
+/**
+  * @}
+  */
 
-/* AHB clock source */
-#define RCC_SYSCLK_Div1                  ((u32)0x00000000)
-#define RCC_SYSCLK_Div2                  ((u32)0x00000080)
-#define RCC_SYSCLK_Div4                  ((u32)0x00000090)
-#define RCC_SYSCLK_Div8                  ((u32)0x000000A0)
-#define RCC_SYSCLK_Div16                 ((u32)0x000000B0)
-#define RCC_SYSCLK_Div64                 ((u32)0x000000C0)
-#define RCC_SYSCLK_Div128                ((u32)0x000000D0)
-#define RCC_SYSCLK_Div256                ((u32)0x000000E0)
-#define RCC_SYSCLK_Div512                ((u32)0x000000F0)
+/** @defgroup AHB_clock_source 
+  * @{
+  */
 
+#define RCC_SYSCLK_Div1                  ((uint32_t)0x00000000)
+#define RCC_SYSCLK_Div2                  ((uint32_t)0x00000080)
+#define RCC_SYSCLK_Div4                  ((uint32_t)0x00000090)
+#define RCC_SYSCLK_Div8                  ((uint32_t)0x000000A0)
+#define RCC_SYSCLK_Div16                 ((uint32_t)0x000000B0)
+#define RCC_SYSCLK_Div64                 ((uint32_t)0x000000C0)
+#define RCC_SYSCLK_Div128                ((uint32_t)0x000000D0)
+#define RCC_SYSCLK_Div256                ((uint32_t)0x000000E0)
+#define RCC_SYSCLK_Div512                ((uint32_t)0x000000F0)
 #define IS_RCC_HCLK(HCLK) (((HCLK) == RCC_SYSCLK_Div1) || ((HCLK) == RCC_SYSCLK_Div2) || \
                            ((HCLK) == RCC_SYSCLK_Div4) || ((HCLK) == RCC_SYSCLK_Div8) || \
                            ((HCLK) == RCC_SYSCLK_Div16) || ((HCLK) == RCC_SYSCLK_Div64) || \
                            ((HCLK) == RCC_SYSCLK_Div128) || ((HCLK) == RCC_SYSCLK_Div256) || \
                            ((HCLK) == RCC_SYSCLK_Div512))
+/**
+  * @}
+  */ 
 
-/* APB1/APB2 clock source */
-#define RCC_HCLK_Div1                    ((u32)0x00000000)
-#define RCC_HCLK_Div2                    ((u32)0x00000400)
-#define RCC_HCLK_Div4                    ((u32)0x00000500)
-#define RCC_HCLK_Div8                    ((u32)0x00000600)
-#define RCC_HCLK_Div16                   ((u32)0x00000700)
+/** @defgroup APB1_APB2_clock_source 
+  * @{
+  */
 
+#define RCC_HCLK_Div1                    ((uint32_t)0x00000000)
+#define RCC_HCLK_Div2                    ((uint32_t)0x00000400)
+#define RCC_HCLK_Div4                    ((uint32_t)0x00000500)
+#define RCC_HCLK_Div8                    ((uint32_t)0x00000600)
+#define RCC_HCLK_Div16                   ((uint32_t)0x00000700)
 #define IS_RCC_PCLK(PCLK) (((PCLK) == RCC_HCLK_Div1) || ((PCLK) == RCC_HCLK_Div2) || \
                            ((PCLK) == RCC_HCLK_Div4) || ((PCLK) == RCC_HCLK_Div8) || \
                            ((PCLK) == RCC_HCLK_Div16))
+/**
+  * @}
+  */
 
-/* RCC Interrupt source */
-#define RCC_IT_LSIRDY                    ((u8)0x01)
-#define RCC_IT_LSERDY                    ((u8)0x02)
-#define RCC_IT_HSIRDY                    ((u8)0x04)
-#define RCC_IT_HSERDY                    ((u8)0x08)
-#define RCC_IT_PLLRDY                    ((u8)0x10)
-#define RCC_IT_CSS                       ((u8)0x80)
+/** @defgroup RCC_Interrupt_source 
+  * @{
+  */
 
-#define IS_RCC_IT(IT) ((((IT) &amp; (u8)0xE0) == 0x00) &amp;&amp; ((IT) != 0x00))
-#define IS_RCC_GET_IT(IT) (((IT) == RCC_IT_LSIRDY) || ((IT) == RCC_IT_LSERDY) || \
-                           ((IT) == RCC_IT_HSIRDY) || ((IT) == RCC_IT_HSERDY) || \
-                           ((IT) == RCC_IT_PLLRDY) || ((IT) == RCC_IT_CSS))
-#define IS_RCC_CLEAR_IT(IT) ((((IT) &amp; (u8)0x60) == 0x00) &amp;&amp; ((IT) != 0x00))
+#define RCC_IT_LSIRDY                    ((uint8_t)0x01)
+#define RCC_IT_LSERDY                    ((uint8_t)0x02)
+#define RCC_IT_HSIRDY                    ((uint8_t)0x04)
+#define RCC_IT_HSERDY                    ((uint8_t)0x08)
+#define RCC_IT_PLLRDY                    ((uint8_t)0x10)
+#define RCC_IT_CSS                       ((uint8_t)0x80)
 
-/* USB clock source */
-#define RCC_USBCLKSource_PLLCLK_1Div5    ((u8)0x00)
-#define RCC_USBCLKSource_PLLCLK_Div1     ((u8)0x01)
+#ifndef STM32F10X_CL
+ #define IS_RCC_IT(IT) ((((IT) &amp; (uint8_t)0xE0) == 0x00) &amp;&amp; ((IT) != 0x00))
+ #define IS_RCC_GET_IT(IT) (((IT) == RCC_IT_LSIRDY) || ((IT) == RCC_IT_LSERDY) || \
+                            ((IT) == RCC_IT_HSIRDY) || ((IT) == RCC_IT_HSERDY) || \
+                            ((IT) == RCC_IT_PLLRDY) || ((IT) == RCC_IT_CSS))
+ #define IS_RCC_CLEAR_IT(IT) ((((IT) &amp; (uint8_t)0x60) == 0x00) &amp;&amp; ((IT) != 0x00))
+#else
+ #define RCC_IT_PLL2RDY                  ((uint8_t)0x20)
+ #define RCC_IT_PLL3RDY                  ((uint8_t)0x40)
+ #define IS_RCC_IT(IT) ((((IT) &amp; (uint8_t)0x80) == 0x00) &amp;&amp; ((IT) != 0x00))
+ #define IS_RCC_GET_IT(IT) (((IT) == RCC_IT_LSIRDY) || ((IT) == RCC_IT_LSERDY) || \
+                            ((IT) == RCC_IT_HSIRDY) || ((IT) == RCC_IT_HSERDY) || \
+                            ((IT) == RCC_IT_PLLRDY) || ((IT) == RCC_IT_CSS) || \
+                            ((IT) == RCC_IT_PLL2RDY) || ((IT) == RCC_IT_PLL3RDY))
+ #define IS_RCC_CLEAR_IT(IT) ((IT) != 0x00)
+#endif /* STM32F10X_CL */ 
 
-#define IS_RCC_USBCLK_SOURCE(SOURCE) (((SOURCE) == RCC_USBCLKSource_PLLCLK_1Div5) || \
+
+/**
+  * @}
+  */
+
+#ifndef STM32F10X_CL
+/** @defgroup USB_Device_clock_source 
+  * @{
+  */
+
+ #define RCC_USBCLKSource_PLLCLK_1Div5   ((uint8_t)0x00)
+ #define RCC_USBCLKSource_PLLCLK_Div1    ((uint8_t)0x01)
+
+ #define IS_RCC_USBCLK_SOURCE(SOURCE) (((SOURCE) == RCC_USBCLKSource_PLLCLK_1Div5) || \
                                       ((SOURCE) == RCC_USBCLKSource_PLLCLK_Div1))
+#else
+/** @defgroup USB_OTG_FS_clock_source 
+  * @{
+  */
+ #define RCC_OTGFSCLKSource_PLLVCO_Div3    ((uint8_t)0x00)
+ #define RCC_OTGFSCLKSource_PLLVCO_Div2    ((uint8_t)0x01)
 
-/* ADC clock source */
-#define RCC_PCLK2_Div2                   ((u32)0x00000000)
-#define RCC_PCLK2_Div4                   ((u32)0x00004000)
-#define RCC_PCLK2_Div6                   ((u32)0x00008000)
-#define RCC_PCLK2_Div8                   ((u32)0x0000C000)
+ #define IS_RCC_OTGFSCLK_SOURCE(SOURCE) (((SOURCE) == RCC_OTGFSCLKSource_PLLVCO_Div3) || \
+                                         ((SOURCE) == RCC_OTGFSCLKSource_PLLVCO_Div2))
+#endif /* STM32F10X_CL */ 
+/**
+  * @}
+  */
 
+#ifdef STM32F10X_CL
+/** @defgroup I2S2_clock_source 
+  * @{
+  */
+ #define RCC_I2S2CLKSource_SYSCLK        ((uint8_t)0x00)
+ #define RCC_I2S2CLKSource_PLL3_VCO      ((uint8_t)0x01)
+
+ #define IS_RCC_I2S2CLK_SOURCE(SOURCE) (((SOURCE) == RCC_I2S2CLKSource_SYSCLK) || \
+                                        ((SOURCE) == RCC_I2S2CLKSource_PLL3_VCO))
+/**
+  * @}
+  */
+
+/** @defgroup I2S3_clock_source 
+  * @{
+  */
+ #define RCC_I2S3CLKSource_SYSCLK        ((uint8_t)0x00)
+ #define RCC_I2S3CLKSource_PLL3_VCO      ((uint8_t)0x01)
+
+ #define IS_RCC_I2S3CLK_SOURCE(SOURCE) (((SOURCE) == RCC_I2S3CLKSource_SYSCLK) || \
+                                        ((SOURCE) == RCC_I2S3CLKSource_PLL3_VCO))    
+/**
+  * @}
+  */
+#endif /* STM32F10X_CL */  
+  
+
+/** @defgroup ADC_clock_source 
+  * @{
+  */
+
+#define RCC_PCLK2_Div2                   ((uint32_t)0x00000000)
+#define RCC_PCLK2_Div4                   ((uint32_t)0x00004000)
+#define RCC_PCLK2_Div6                   ((uint32_t)0x00008000)
+#define RCC_PCLK2_Div8                   ((uint32_t)0x0000C000)
 #define IS_RCC_ADCCLK(ADCCLK) (((ADCCLK) == RCC_PCLK2_Div2) || ((ADCCLK) == RCC_PCLK2_Div4) || \
                                ((ADCCLK) == RCC_PCLK2_Div6) || ((ADCCLK) == RCC_PCLK2_Div8))
+/**
+  * @}
+  */
 
-/* LSE configuration */
-#define RCC_LSE_OFF                      ((u8)0x00)
-#define RCC_LSE_ON                       ((u8)0x01)
-#define RCC_LSE_Bypass                   ((u8)0x04)
+/** @defgroup LSE_configuration 
+  * @{
+  */
 
+#define RCC_LSE_OFF                      ((uint8_t)0x00)
+#define RCC_LSE_ON                       ((uint8_t)0x01)
+#define RCC_LSE_Bypass                   ((uint8_t)0x04)
 #define IS_RCC_LSE(LSE) (((LSE) == RCC_LSE_OFF) || ((LSE) == RCC_LSE_ON) || \
                          ((LSE) == RCC_LSE_Bypass))
+/**
+  * @}
+  */
 
-/* RTC clock source */
-#define RCC_RTCCLKSource_LSE             ((u32)0x00000100)
-#define RCC_RTCCLKSource_LSI             ((u32)0x00000200)
-#define RCC_RTCCLKSource_HSE_Div128      ((u32)0x00000300)
+/** @defgroup RTC_clock_source 
+  * @{
+  */
 
+#define RCC_RTCCLKSource_LSE             ((uint32_t)0x00000100)
+#define RCC_RTCCLKSource_LSI             ((uint32_t)0x00000200)
+#define RCC_RTCCLKSource_HSE_Div128      ((uint32_t)0x00000300)
 #define IS_RCC_RTCCLK_SOURCE(SOURCE) (((SOURCE) == RCC_RTCCLKSource_LSE) || \
                                       ((SOURCE) == RCC_RTCCLKSource_LSI) || \
                                       ((SOURCE) == RCC_RTCCLKSource_HSE_Div128))
+/**
+  * @}
+  */
 
-/* AHB peripheral */
-#define RCC_AHBPeriph_DMA1               ((u32)0x00000001)
-#define RCC_AHBPeriph_DMA2               ((u32)0x00000002)
-#define RCC_AHBPeriph_SRAM               ((u32)0x00000004)
-#define RCC_AHBPeriph_FLITF              ((u32)0x00000010)
-#define RCC_AHBPeriph_CRC                ((u32)0x00000040)
-#define RCC_AHBPeriph_FSMC               ((u32)0x00000100)
-#define RCC_AHBPeriph_SDIO               ((u32)0x00000400)
+/** @defgroup AHB_peripheral 
+  * @{
+  */
 
-#define IS_RCC_AHB_PERIPH(PERIPH) ((((PERIPH) &amp; 0xFFFFFAA8) == 0x00) &amp;&amp; ((PERIPH) != 0x00))
+#define RCC_AHBPeriph_DMA1               ((uint32_t)0x00000001)
+#define RCC_AHBPeriph_DMA2               ((uint32_t)0x00000002)
+#define RCC_AHBPeriph_SRAM               ((uint32_t)0x00000004)
+#define RCC_AHBPeriph_FLITF              ((uint32_t)0x00000010)
+#define RCC_AHBPeriph_CRC                ((uint32_t)0x00000040)
 
-/* APB2 peripheral */
-#define RCC_APB2Periph_AFIO              ((u32)0x00000001)
-#define RCC_APB2Periph_GPIOA             ((u32)0x00000004)
-#define RCC_APB2Periph_GPIOB             ((u32)0x00000008)
-#define RCC_APB2Periph_GPIOC             ((u32)0x00000010)
-#define RCC_APB2Periph_GPIOD             ((u32)0x00000020)
-#define RCC_APB2Periph_GPIOE             ((u32)0x00000040)
-#define RCC_APB2Periph_GPIOF             ((u32)0x00000080)
-#define RCC_APB2Periph_GPIOG             ((u32)0x00000100)
-#define RCC_APB2Periph_ADC1              ((u32)0x00000200)
-#define RCC_APB2Periph_ADC2              ((u32)0x00000400)
-#define RCC_APB2Periph_TIM1              ((u32)0x00000800)
-#define RCC_APB2Periph_SPI1              ((u32)0x00001000)
-#define RCC_APB2Periph_TIM8              ((u32)0x00002000)
-#define RCC_APB2Periph_USART1            ((u32)0x00004000)
-#define RCC_APB2Periph_ADC3              ((u32)0x00008000)
-#define RCC_APB2Periph_ALL               ((u32)0x0000FFFD)
+#ifndef STM32F10X_CL
+ #define RCC_AHBPeriph_FSMC              ((uint32_t)0x00000100)
+ #define RCC_AHBPeriph_SDIO              ((uint32_t)0x00000400)
+ #define IS_RCC_AHB_PERIPH(PERIPH) ((((PERIPH) &amp; 0xFFFFFAA8) == 0x00) &amp;&amp; ((PERIPH) != 0x00))
+#else
+ #define RCC_AHBPeriph_OTG_FS            ((uint32_t)0x00001000)
+ #define RCC_AHBPeriph_ETH_MAC           ((uint32_t)0x00004000)
+ #define RCC_AHBPeriph_ETH_MAC_Tx        ((uint32_t)0x00008000)
+ #define RCC_AHBPeriph_ETH_MAC_Rx        ((uint32_t)0x00010000)
 
+ #define IS_RCC_AHB_PERIPH(PERIPH) ((((PERIPH) &amp; 0xFFFE2FA8) == 0x00) &amp;&amp; ((PERIPH) != 0x00))
+ #define IS_RCC_AHB_PERIPH_RESET(PERIPH) ((((PERIPH) &amp; 0xFFFFAFFF) == 0x00) &amp;&amp; ((PERIPH) != 0x00))
+#endif /* STM32F10X_CL */
+/**
+  * @}
+  */
+
+/** @defgroup APB2_peripheral 
+  * @{
+  */
+
+#define RCC_APB2Periph_AFIO              ((uint32_t)0x00000001)
+#define RCC_APB2Periph_GPIOA             ((uint32_t)0x00000004)
+#define RCC_APB2Periph_GPIOB             ((uint32_t)0x00000008)
+#define RCC_APB2Periph_GPIOC             ((uint32_t)0x00000010)
+#define RCC_APB2Periph_GPIOD             ((uint32_t)0x00000020)
+#define RCC_APB2Periph_GPIOE             ((uint32_t)0x00000040)
+#define RCC_APB2Periph_GPIOF             ((uint32_t)0x00000080)
+#define RCC_APB2Periph_GPIOG             ((uint32_t)0x00000100)
+#define RCC_APB2Periph_ADC1              ((uint32_t)0x00000200)
+#define RCC_APB2Periph_ADC2              ((uint32_t)0x00000400)
+#define RCC_APB2Periph_TIM1              ((uint32_t)0x00000800)
+#define RCC_APB2Periph_SPI1              ((uint32_t)0x00001000)
+#define RCC_APB2Periph_TIM8              ((uint32_t)0x00002000)
+#define RCC_APB2Periph_USART1            ((uint32_t)0x00004000)
+#define RCC_APB2Periph_ADC3              ((uint32_t)0x00008000)
+
 #define IS_RCC_APB2_PERIPH(PERIPH) ((((PERIPH) &amp; 0xFFFF0002) == 0x00) &amp;&amp; ((PERIPH) != 0x00))
+/**
+  * @}
+  */ 
 
-/* APB1 peripheral */
-#define RCC_APB1Periph_TIM2              ((u32)0x00000001)
-#define RCC_APB1Periph_TIM3              ((u32)0x00000002)
-#define RCC_APB1Periph_TIM4              ((u32)0x00000004)
-#define RCC_APB1Periph_TIM5              ((u32)0x00000008)
-#define RCC_APB1Periph_TIM6              ((u32)0x00000010)
-#define RCC_APB1Periph_TIM7              ((u32)0x00000020)
-#define RCC_APB1Periph_WWDG              ((u32)0x00000800)
-#define RCC_APB1Periph_SPI2              ((u32)0x00004000)
-#define RCC_APB1Periph_SPI3              ((u32)0x00008000)
-#define RCC_APB1Periph_USART2            ((u32)0x00020000)
-#define RCC_APB1Periph_USART3            ((u32)0x00040000)
-#define RCC_APB1Periph_UART4             ((u32)0x00080000)
-#define RCC_APB1Periph_UART5             ((u32)0x00100000)
-#define RCC_APB1Periph_I2C1              ((u32)0x00200000)
-#define RCC_APB1Periph_I2C2              ((u32)0x00400000)
-#define RCC_APB1Periph_USB               ((u32)0x00800000)
-#define RCC_APB1Periph_CAN               ((u32)0x02000000)
-#define RCC_APB1Periph_BKP               ((u32)0x08000000)
-#define RCC_APB1Periph_PWR               ((u32)0x10000000)
-#define RCC_APB1Periph_DAC               ((u32)0x20000000)
-#define RCC_APB1Periph_ALL               ((u32)0x3AFEC83F)
+/** @defgroup APB1_peripheral 
+  * @{
+  */
 
-#define IS_RCC_APB1_PERIPH(PERIPH) ((((PERIPH) &amp; 0xC50137C0) == 0x00) &amp;&amp; ((PERIPH) != 0x00))
+#define RCC_APB1Periph_TIM2              ((uint32_t)0x00000001)
+#define RCC_APB1Periph_TIM3              ((uint32_t)0x00000002)
+#define RCC_APB1Periph_TIM4              ((uint32_t)0x00000004)
+#define RCC_APB1Periph_TIM5              ((uint32_t)0x00000008)
+#define RCC_APB1Periph_TIM6              ((uint32_t)0x00000010)
+#define RCC_APB1Periph_TIM7              ((uint32_t)0x00000020)
+#define RCC_APB1Periph_WWDG              ((uint32_t)0x00000800)
+#define RCC_APB1Periph_SPI2              ((uint32_t)0x00004000)
+#define RCC_APB1Periph_SPI3              ((uint32_t)0x00008000)
+#define RCC_APB1Periph_USART2            ((uint32_t)0x00020000)
+#define RCC_APB1Periph_USART3            ((uint32_t)0x00040000)
+#define RCC_APB1Periph_UART4             ((uint32_t)0x00080000)
+#define RCC_APB1Periph_UART5             ((uint32_t)0x00100000)
+#define RCC_APB1Periph_I2C1              ((uint32_t)0x00200000)
+#define RCC_APB1Periph_I2C2              ((uint32_t)0x00400000)
+#define RCC_APB1Periph_USB               ((uint32_t)0x00800000)
+#define RCC_APB1Periph_CAN1              ((uint32_t)0x02000000)
+#define RCC_APB1Periph_BKP               ((uint32_t)0x08000000)
+#define RCC_APB1Periph_PWR               ((uint32_t)0x10000000)
+#define RCC_APB1Periph_DAC               ((uint32_t)0x20000000)
+#define RCC_APB1Periph_CAN2             ((uint32_t)0x04000000) 
+#define IS_RCC_APB1_PERIPH(PERIPH) ((((PERIPH) &amp; 0xC10137C0) == 0x00) &amp;&amp; ((PERIPH) != 0x00))
 
-/* Clock source to output on MCO pin */
-#define RCC_MCO_NoClock                  ((u8)0x00)
-#define RCC_MCO_SYSCLK                   ((u8)0x04)
-#define RCC_MCO_HSI                      ((u8)0x05)
-#define RCC_MCO_HSE                      ((u8)0x06)
-#define RCC_MCO_PLLCLK_Div2              ((u8)0x07)
+/**
+  * @}
+  */
 
-#define IS_RCC_MCO(MCO) (((MCO) == RCC_MCO_NoClock) || ((MCO) == RCC_MCO_HSI) || \
-                         ((MCO) == RCC_MCO_SYSCLK)  || ((MCO) == RCC_MCO_HSE) || \
-                         ((MCO) == RCC_MCO_PLLCLK_Div2))
+/** @defgroup Clock_source_to_output_on_MCO_pin 
+  * @{
+  */
 
-/* RCC Flag */
-#define RCC_FLAG_HSIRDY                  ((u8)0x21)
-#define RCC_FLAG_HSERDY                  ((u8)0x31)
-#define RCC_FLAG_PLLRDY                  ((u8)0x39)
-#define RCC_FLAG_LSERDY                  ((u8)0x41)
-#define RCC_FLAG_LSIRDY                  ((u8)0x61)
-#define RCC_FLAG_PINRST                  ((u8)0x7A)
-#define RCC_FLAG_PORRST                  ((u8)0x7B)
-#define RCC_FLAG_SFTRST                  ((u8)0x7C)
-#define RCC_FLAG_IWDGRST                 ((u8)0x7D)
-#define RCC_FLAG_WWDGRST                 ((u8)0x7E)
-#define RCC_FLAG_LPWRRST                 ((u8)0x7F)
+#define RCC_MCO_NoClock                  ((uint8_t)0x00)
+#define RCC_MCO_SYSCLK                   ((uint8_t)0x04)
+#define RCC_MCO_HSI                      ((uint8_t)0x05)
+#define RCC_MCO_HSE                      ((uint8_t)0x06)
+#define RCC_MCO_PLLCLK_Div2              ((uint8_t)0x07)
 
-#define IS_RCC_FLAG(FLAG) (((FLAG) == RCC_FLAG_HSIRDY) || ((FLAG) == RCC_FLAG_HSERDY) || \
-                           ((FLAG) == RCC_FLAG_PLLRDY) || ((FLAG) == RCC_FLAG_LSERDY) || \
-                           ((FLAG) == RCC_FLAG_LSIRDY) || ((FLAG) == RCC_FLAG_PINRST) || \
-                           ((FLAG) == RCC_FLAG_PORRST) || ((FLAG) == RCC_FLAG_SFTRST) || \
-                           ((FLAG) == RCC_FLAG_IWDGRST)|| ((FLAG) == RCC_FLAG_WWDGRST)|| \
-                           ((FLAG) == RCC_FLAG_LPWRRST))
+#ifndef STM32F10X_CL
+ #define IS_RCC_MCO(MCO) (((MCO) == RCC_MCO_NoClock) || ((MCO) == RCC_MCO_HSI) || \
+                          ((MCO) == RCC_MCO_SYSCLK)  || ((MCO) == RCC_MCO_HSE) || \
+                          ((MCO) == RCC_MCO_PLLCLK_Div2))
+#else
+ #define RCC_MCO_PLL2CLK                 ((uint8_t)0x08)
+ #define RCC_MCO_PLL3CLK_Div2            ((uint8_t)0x09)
+ #define RCC_MCO_XT1                     ((uint8_t)0x0A)
+ #define RCC_MCO_PLL3CLK                 ((uint8_t)0x0B)
 
+ #define IS_RCC_MCO(MCO) (((MCO) == RCC_MCO_NoClock) || ((MCO) == RCC_MCO_HSI) || \
+                          ((MCO) == RCC_MCO_SYSCLK)  || ((MCO) == RCC_MCO_HSE) || \
+                          ((MCO) == RCC_MCO_PLLCLK_Div2) || ((MCO) == RCC_MCO_PLL2CLK) || \
+                          ((MCO) == RCC_MCO_PLL3CLK_Div2) || ((MCO) == RCC_MCO_XT1) || \
+                          ((MCO) == RCC_MCO_PLL3CLK))
+#endif /* STM32F10X_CL */ 
+
+/**
+  * @}
+  */
+
+/** @defgroup RCC_Flag 
+  * @{
+  */
+
+#define RCC_FLAG_HSIRDY                  ((uint8_t)0x21)
+#define RCC_FLAG_HSERDY                  ((uint8_t)0x31)
+#define RCC_FLAG_PLLRDY                  ((uint8_t)0x39)
+#define RCC_FLAG_LSERDY                  ((uint8_t)0x41)
+#define RCC_FLAG_LSIRDY                  ((uint8_t)0x61)
+#define RCC_FLAG_PINRST                  ((uint8_t)0x7A)
+#define RCC_FLAG_PORRST                  ((uint8_t)0x7B)
+#define RCC_FLAG_SFTRST                  ((uint8_t)0x7C)
+#define RCC_FLAG_IWDGRST                 ((uint8_t)0x7D)
+#define RCC_FLAG_WWDGRST                 ((uint8_t)0x7E)
+#define RCC_FLAG_LPWRRST                 ((uint8_t)0x7F)
+
+#ifndef STM32F10X_CL
+ #define IS_RCC_FLAG(FLAG) (((FLAG) == RCC_FLAG_HSIRDY) || ((FLAG) == RCC_FLAG_HSERDY) || \
+                            ((FLAG) == RCC_FLAG_PLLRDY) || ((FLAG) == RCC_FLAG_LSERDY) || \
+                            ((FLAG) == RCC_FLAG_LSIRDY) || ((FLAG) == RCC_FLAG_PINRST) || \
+                            ((FLAG) == RCC_FLAG_PORRST) || ((FLAG) == RCC_FLAG_SFTRST) || \
+                            ((FLAG) == RCC_FLAG_IWDGRST)|| ((FLAG) == RCC_FLAG_WWDGRST)|| \
+                            ((FLAG) == RCC_FLAG_LPWRRST))
+#else
+ #define RCC_FLAG_PLL2RDY                ((uint8_t)0x3B) 
+ #define RCC_FLAG_PLL3RDY                ((uint8_t)0x3D) 
+ #define IS_RCC_FLAG(FLAG) (((FLAG) == RCC_FLAG_HSIRDY) || ((FLAG) == RCC_FLAG_HSERDY) || \
+                            ((FLAG) == RCC_FLAG_PLLRDY) || ((FLAG) == RCC_FLAG_LSERDY) || \
+                            ((FLAG) == RCC_FLAG_PLL2RDY) || ((FLAG) == RCC_FLAG_PLL3RDY) || \
+                            ((FLAG) == RCC_FLAG_LSIRDY) || ((FLAG) == RCC_FLAG_PINRST) || \
+                            ((FLAG) == RCC_FLAG_PORRST) || ((FLAG) == RCC_FLAG_SFTRST) || \
+                            ((FLAG) == RCC_FLAG_IWDGRST)|| ((FLAG) == RCC_FLAG_WWDGRST)|| \
+                            ((FLAG) == RCC_FLAG_LPWRRST))
+#endif /* STM32F10X_CL */ 
+
 #define IS_RCC_CALIBRATION_VALUE(VALUE) ((VALUE) &lt;= 0x1F)
+/**
+  * @}
+  */
 
-/* Exported macro ------------------------------------------------------------*/
-/* Exported functions ------------------------------------------------------- */
+/**
+  * @}
+  */
+
+/** @defgroup RCC_Exported_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup RCC_Exported_Functions
+  * @{
+  */
+
 void RCC_DeInit(void);
-void RCC_HSEConfig(u32 RCC_HSE);
+void RCC_HSEConfig(uint32_t RCC_HSE);
 ErrorStatus RCC_WaitForHSEStartUp(void);
-void RCC_AdjustHSICalibrationValue(u8 HSICalibrationValue);
+void RCC_AdjustHSICalibrationValue(uint8_t HSICalibrationValue);
 void RCC_HSICmd(FunctionalState NewState);
-void RCC_PLLConfig(u32 RCC_PLLSource, u32 RCC_PLLMul);
+void RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t RCC_PLLMul);
 void RCC_PLLCmd(FunctionalState NewState);
-void RCC_SYSCLKConfig(u32 RCC_SYSCLKSource);
-u8 RCC_GetSYSCLKSource(void);
-void RCC_HCLKConfig(u32 RCC_SYSCLK);
-void RCC_PCLK1Config(u32 RCC_HCLK);
-void RCC_PCLK2Config(u32 RCC_HCLK);
-void RCC_ITConfig(u8 RCC_IT, FunctionalState NewState);
-void RCC_USBCLKConfig(u32 RCC_USBCLKSource);
-void RCC_ADCCLKConfig(u32 RCC_PCLK2);
-void RCC_LSEConfig(u8 RCC_LSE);
+
+#ifdef STM32F10X_CL
+ void RCC_PREDIV1Config(uint32_t RCC_PREDIV1_Source, uint32_t RCC_PREDIV1_Div);
+ void RCC_PREDIV2Config(uint32_t RCC_PREDIV2_Div);
+ void RCC_PLL2Config(uint32_t RCC_PLL2Mul);
+ void RCC_PLL2Cmd(FunctionalState NewState);
+ void RCC_PLL3Config(uint32_t RCC_PLL3Mul);
+ void RCC_PLL3Cmd(FunctionalState NewState);
+#endif /* STM32F10X_CL */ 
+
+void RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource);
+uint8_t RCC_GetSYSCLKSource(void);
+void RCC_HCLKConfig(uint32_t RCC_SYSCLK);
+void RCC_PCLK1Config(uint32_t RCC_HCLK);
+void RCC_PCLK2Config(uint32_t RCC_HCLK);
+void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState);
+
+#ifndef STM32F10X_CL
+ void RCC_USBCLKConfig(uint32_t RCC_USBCLKSource);
+#else
+ void RCC_OTGFSCLKConfig(uint32_t RCC_OTGFSCLKSource);
+#endif /* STM32F10X_CL */ 
+
+void RCC_ADCCLKConfig(uint32_t RCC_PCLK2);
+
+#ifdef STM32F10X_CL
+ void RCC_I2S2CLKConfig(uint32_t RCC_I2S2CLKSource);                                  
+ void RCC_I2S3CLKConfig(uint32_t RCC_I2S3CLKSource);
+#endif /* STM32F10X_CL */ 
+
+void RCC_LSEConfig(uint8_t RCC_LSE);
 void RCC_LSICmd(FunctionalState NewState);
-void RCC_RTCCLKConfig(u32 RCC_RTCCLKSource);
+void RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource);
 void RCC_RTCCLKCmd(FunctionalState NewState);
 void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks);
-void RCC_AHBPeriphClockCmd(u32 RCC_AHBPeriph, FunctionalState NewState);
-void RCC_APB2PeriphClockCmd(u32 RCC_APB2Periph, FunctionalState NewState);
-void RCC_APB1PeriphClockCmd(u32 RCC_APB1Periph, FunctionalState NewState);
-void RCC_APB2PeriphResetCmd(u32 RCC_APB2Periph, FunctionalState NewState);
-void RCC_APB1PeriphResetCmd(u32 RCC_APB1Periph, FunctionalState NewState);
+void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState);
+void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState);
+void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState);
+
+#ifdef STM32F10X_CL
+void RCC_AHBPeriphResetCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState);
+#endif /* STM32F10X_CL */ 
+
+void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState);
+void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState);
 void RCC_BackupResetCmd(FunctionalState NewState);
 void RCC_ClockSecuritySystemCmd(FunctionalState NewState);
-void RCC_MCOConfig(u8 RCC_MCO);
-FlagStatus RCC_GetFlagStatus(u8 RCC_FLAG);
+void RCC_MCOConfig(uint8_t RCC_MCO);
+FlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG);
 void RCC_ClearFlag(void);
-ITStatus RCC_GetITStatus(u8 RCC_IT);
-void RCC_ClearITPendingBit(u8 RCC_IT);
+ITStatus RCC_GetITStatus(uint8_t RCC_IT);
+void RCC_ClearITPendingBit(uint8_t RCC_IT);
 
+#ifdef __cplusplus
+}
+#endif
+
 #endif /* __STM32F10x_RCC_H */
+/**
+  * @}
+  */
 
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */ 
+
+/******************* (C) COPYRIGHT 2009 STMicroelectronics *****END OF FILE****/

Modified: trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_rtc.h
===================================================================
--- trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_rtc.h	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_rtc.h	2009-07-08 23:39:34 UTC (rev 354)
@@ -1,70 +1,134 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_rtc.h
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file contains all the functions prototypes for the
-*                      RTC firmware library.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
+/**
+  ******************************************************************************
+  * @file    stm32f10x_rtc.h
+  * @author  MCD Application Team
+  * @version V3.1.0
+  * @date    06/19/2009
+  * @brief   This file contains all the functions prototypes for the RTC firmware 
+  *          library.
+  ******************************************************************************
+  * @copy
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * &lt;h2&gt;&lt;center&gt;&copy; COPYRIGHT 2009 STMicroelectronics&lt;/center&gt;&lt;/h2&gt;
+  */ 
 
 /* Define to prevent recursive inclusion -------------------------------------*/
 #ifndef __STM32F10x_RTC_H
 #define __STM32F10x_RTC_H
 
+#ifdef __cplusplus
+ extern &quot;C&quot; {
+#endif
+
 /* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_map.h&quot;
+#include &quot;stm32f10x.h&quot;
 
-/* Exported types ------------------------------------------------------------*/
-/* Exported constants --------------------------------------------------------*/
-/* RTC interrupts define -----------------------------------------------------*/
-#define RTC_IT_OW            ((u16)0x0004)  /* Overflow interrupt */
-#define RTC_IT_ALR           ((u16)0x0002)  /* Alarm interrupt */
-#define RTC_IT_SEC           ((u16)0x0001)  /* Second interrupt */
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
 
-#define IS_RTC_IT(IT) ((((IT) &amp; (u16)0xFFF8) == 0x00) &amp;&amp; ((IT) != 0x00))
+/** @addtogroup RTC
+  * @{
+  */ 
 
+/** @defgroup RTC_Exported_Types
+  * @{
+  */ 
+
+/**
+  * @}
+  */ 
+
+/** @defgroup RTC_Exported_Constants
+  * @{
+  */
+
+/** @defgroup RTC_interrupts_define 
+  * @{
+  */
+
+#define RTC_IT_OW            ((uint16_t)0x0004)  /*!&lt; Overflow interrupt */
+#define RTC_IT_ALR           ((uint16_t)0x0002)  /*!&lt; Alarm interrupt */
+#define RTC_IT_SEC           ((uint16_t)0x0001)  /*!&lt; Second interrupt */
+#define IS_RTC_IT(IT) ((((IT) &amp; (uint16_t)0xFFF8) == 0x00) &amp;&amp; ((IT) != 0x00))
 #define IS_RTC_GET_IT(IT) (((IT) == RTC_IT_OW) || ((IT) == RTC_IT_ALR) || \
                            ((IT) == RTC_IT_SEC))
-                                                                     
-/* RTC interrupts flags ------------------------------------------------------*/
-#define RTC_FLAG_RTOFF       ((u16)0x0020)  /* RTC Operation OFF flag */
-#define RTC_FLAG_RSF         ((u16)0x0008)  /* Registers Synchronized flag */
-#define RTC_FLAG_OW          ((u16)0x0004)  /* Overflow flag */
-#define RTC_FLAG_ALR         ((u16)0x0002)  /* Alarm flag */
-#define RTC_FLAG_SEC         ((u16)0x0001)  /* Second flag */
+/**
+  * @}
+  */ 
 
-#define IS_RTC_CLEAR_FLAG(FLAG) ((((FLAG) &amp; (u16)0xFFF0) == 0x00) &amp;&amp; ((FLAG) != 0x00))
+/** @defgroup RTC_interrupts_flags 
+  * @{
+  */
 
+#define RTC_FLAG_RTOFF       ((uint16_t)0x0020)  /*!&lt; RTC Operation OFF flag */
+#define RTC_FLAG_RSF         ((uint16_t)0x0008)  /*!&lt; Registers Synchronized flag */
+#define RTC_FLAG_OW          ((uint16_t)0x0004)  /*!&lt; Overflow flag */
+#define RTC_FLAG_ALR         ((uint16_t)0x0002)  /*!&lt; Alarm flag */
+#define RTC_FLAG_SEC         ((uint16_t)0x0001)  /*!&lt; Second flag */
+#define IS_RTC_CLEAR_FLAG(FLAG) ((((FLAG) &amp; (uint16_t)0xFFF0) == 0x00) &amp;&amp; ((FLAG) != 0x00))
 #define IS_RTC_GET_FLAG(FLAG) (((FLAG) == RTC_FLAG_RTOFF) || ((FLAG) == RTC_FLAG_RSF) || \
                                ((FLAG) == RTC_FLAG_OW) || ((FLAG) == RTC_FLAG_ALR) || \
                                ((FLAG) == RTC_FLAG_SEC))
+#define IS_RTC_PRESCALER(PRESCALER) ((PRESCALER) &lt;= 0xFFFFF)
 
-#define IS_RTC_PRESCALER(PRESCALER) ((PRESCALER) &lt;= 0xFFFFF)
-                           
-/* Exported macro ------------------------------------------------------------*/
-/* Exported functions ------------------------------------------------------- */
-void RTC_ITConfig(u16 RTC_IT, FunctionalState NewState);
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup RTC_Exported_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup RTC_Exported_Functions
+  * @{
+  */
+
+void RTC_ITConfig(uint16_t RTC_IT, FunctionalState NewState);
 void RTC_EnterConfigMode(void);
 void RTC_ExitConfigMode(void);
-u32  RTC_GetCounter(void);
-void RTC_SetCounter(u32 CounterValue);
-void RTC_SetPrescaler(u32 PrescalerValue);
-void RTC_SetAlarm(u32 AlarmValue);
-u32  RTC_GetDivider(void);
+uint32_t  RTC_GetCounter(void);
+void RTC_SetCounter(uint32_t CounterValue);
+void RTC_SetPrescaler(uint32_t PrescalerValue);
+void RTC_SetAlarm(uint32_t AlarmValue);
+uint32_t  RTC_GetDivider(void);
 void RTC_WaitForLastTask(void);
 void RTC_WaitForSynchro(void);
-FlagStatus RTC_GetFlagStatus(u16 RTC_FLAG);
-void RTC_ClearFlag(u16 RTC_FLAG);
-ITStatus RTC_GetITStatus(u16 RTC_IT);
-void RTC_ClearITPendingBit(u16 RTC_IT);
+FlagStatus RTC_GetFlagStatus(uint16_t RTC_FLAG);
+void RTC_ClearFlag(uint16_t RTC_FLAG);
+ITStatus RTC_GetITStatus(uint16_t RTC_IT);
+void RTC_ClearITPendingBit(uint16_t RTC_IT);
 
+#ifdef __cplusplus
+}
+#endif
+
 #endif /* __STM32F10x_RTC_H */
+/**
+  * @}
+  */
 
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2009 STMicroelectronics *****END OF FILE****/

Modified: trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_sdio.h
===================================================================
--- trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_sdio.h	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_sdio.h	2009-07-08 23:39:34 UTC (rev 354)
@@ -1,181 +1,316 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_sdio.h
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file contains all the functions prototypes for the
-*                      SDIO firmware library.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
+/**
+  ******************************************************************************
+  * @file    stm32f10x_sdio.h
+  * @author  MCD Application Team
+  * @version V3.1.0
+  * @date    06/19/2009
+  * @brief   This file contains all the functions prototypes for the SDIO firmware
+  *          library.
+  ******************************************************************************
+  * @copy
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * &lt;h2&gt;&lt;center&gt;&copy; COPYRIGHT 2009 STMicroelectronics&lt;/center&gt;&lt;/h2&gt;
+  */ 
 
 /* Define to prevent recursive inclusion -------------------------------------*/
 #ifndef __STM32F10x_SDIO_H
 #define __STM32F10x_SDIO_H
 
+#ifdef __cplusplus
+ extern &quot;C&quot; {
+#endif
+
 /* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_map.h&quot;
+#include &quot;stm32f10x.h&quot;
 
-/* Exported types ------------------------------------------------------------*/
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @addtogroup SDIO
+  * @{
+  */
+
+/** @defgroup SDIO_Exported_Types
+  * @{
+  */
+
 typedef struct
 {
-  u8 SDIO_ClockDiv;
-  u32 SDIO_ClockEdge;
-  u32 SDIO_ClockBypass;
-  u32 SDIO_ClockPowerSave;
-  u32 SDIO_BusWide;
-  u32 SDIO_HardwareFlowControl;
+  uint32_t SDIO_ClockEdge;            /*!&lt; Specifies the clock transition on which the bit capture is made.
+                                           This parameter can be a value of @ref SDIO_Clock_Edge */
+
+  uint32_t SDIO_ClockBypass;          /*!&lt; Specifies whether the SDIO Clock divider bypass is
+                                           enabled or disabled.
+                                           This parameter can be a value of @ref SDIO_Clock_Bypass */
+
+  uint32_t SDIO_ClockPowerSave;       /*!&lt; Specifies whether SDIO Clock output is enabled or
+                                           disabled when the bus is idle.
+                                           This parameter can be a value of @ref SDIO_Clock_Power_Save */
+
+  uint32_t SDIO_BusWide;              /*!&lt; Specifies the SDIO bus width.
+                                           This parameter can be a value of @ref SDIO_Bus_Wide */
+
+  uint32_t SDIO_HardwareFlowControl;  /*!&lt; Specifies whether the SDIO hardware flow control is enabled or disabled.
+                                           This parameter can be a value of @ref SDIO_Hardware_Flow_Control */
+
+  uint8_t SDIO_ClockDiv;              /*!&lt; Specifies the clock frequency of the SDIO controller.
+                                           This parameter can be a value between 0x00 and 0xFF. */
+                                           
 } SDIO_InitTypeDef;
 
 typedef struct
 {
-  u32 SDIO_Argument;
-  u32 SDIO_CmdIndex;
-  u32 SDIO_Response;
-  u32 SDIO_Wait;
-  u32 SDIO_CPSM;
+  uint32_t SDIO_Argument;  /*!&lt; Specifies the SDIO command argument which is sent
+                                to a card as part of a command message. If a command
+                                contains an argument, it must be loaded into this register
+                                before writing the command to the command register */
+
+  uint32_t SDIO_CmdIndex;  /*!&lt; Specifies the SDIO command index. It must be lower than 0x40. */
+
+  uint32_t SDIO_Response;  /*!&lt; Specifies the SDIO response type.
+                                This parameter can be a value of @ref SDIO_Response_Type */
+
+  uint32_t SDIO_Wait;      /*!&lt; Specifies whether SDIO wait-for-interrupt request is enabled or disabled.
+                                This parameter can be a value of @ref SDIO_Wait_Interrupt_State */
+
+  uint32_t SDIO_CPSM;      /*!&lt; Specifies whether SDIO Command path state machine (CPSM)
+                                is enabled or disabled.
+                                This parameter can be a value of @ref SDIO_CPSM_State */
 } SDIO_CmdInitTypeDef;
 
 typedef struct
 {
-  u32 SDIO_DataTimeOut;
-  u32 SDIO_DataLength;
-  u32 SDIO_DataBlockSize;
-  u32 SDIO_TransferDir;
-  u32 SDIO_TransferMode;
-  u32 SDIO_DPSM;
+  uint32_t SDIO_DataTimeOut;    /*!&lt; Specifies the data timeout period in card bus clock periods. */
+
+  uint32_t SDIO_DataLength;     /*!&lt; Specifies the number of data bytes to be transferred. */
+ 
+  uint32_t SDIO_DataBlockSize;  /*!&lt; Specifies the data block size for block transfer.
+                                     This parameter can be a value of @ref SDIO_Data_Block_Size */
+ 
+  uint32_t SDIO_TransferDir;    /*!&lt; Specifies the data transfer direction, whether the transfer
+                                     is a read or write.
+                                     This parameter can be a value of @ref SDIO_Transfer_Direction */
+ 
+  uint32_t SDIO_TransferMode;   /*!&lt; Specifies whether data transfer is in stream or block mode.
+                                     This parameter can be a value of @ref SDIO_Transfer_Type */
+ 
+  uint32_t SDIO_DPSM;           /*!&lt; Specifies whether SDIO Data path state machine (DPSM)
+                                     is enabled or disabled.
+                                     This parameter can be a value of @ref SDIO_DPSM_State */
 } SDIO_DataInitTypeDef;
 
-/* Exported constants --------------------------------------------------------*/
-/* SDIO Clock Edge -----------------------------------------------------------*/
-#define SDIO_ClockEdge_Rising               ((u32)0x00000000)
-#define SDIO_ClockEdge_Falling              ((u32)0x00002000)
+/**
+  * @}
+  */ 
 
+/** @defgroup SDIO_Exported_Constants
+  * @{
+  */
+
+/** @defgroup SDIO_Clock_Edge 
+  * @{
+  */
+
+#define SDIO_ClockEdge_Rising               ((uint32_t)0x00000000)
+#define SDIO_ClockEdge_Falling              ((uint32_t)0x00002000)
 #define IS_SDIO_CLOCK_EDGE(EDGE) (((EDGE) == SDIO_ClockEdge_Rising) || \
                                   ((EDGE) == SDIO_ClockEdge_Falling))
-/* SDIO Clock Bypass ----------------------------------------------------------*/                                  
-#define SDIO_ClockBypass_Disable             ((u32)0x00000000)
-#define SDIO_ClockBypass_Enable              ((u32)0x00000400)    
+/**
+  * @}
+  */
 
+/** @defgroup SDIO_Clock_Bypass 
+  * @{
+  */
+
+#define SDIO_ClockBypass_Disable             ((uint32_t)0x00000000)
+#define SDIO_ClockBypass_Enable              ((uint32_t)0x00000400)    
 #define IS_SDIO_CLOCK_BYPASS(BYPASS) (((BYPASS) == SDIO_ClockBypass_Disable) || \
-                                     ((BYPASS) == SDIO_ClockBypass_Enable))                             
+                                     ((BYPASS) == SDIO_ClockBypass_Enable))
+/**
+  * @}
+  */ 
 
-/* SDIO Clock Power Save  ----------------------------------------------------*/ 
-#define SDIO_ClockPowerSave_Disable         ((u32)0x00000000)
-#define SDIO_ClockPowerSave_Enable          ((u32)0x00000200) 
+/** @defgroup SDIO_Clock_Power_Save 
+  * @{
+  */
 
+#define SDIO_ClockPowerSave_Disable         ((uint32_t)0x00000000)
+#define SDIO_ClockPowerSave_Enable          ((uint32_t)0x00000200) 
 #define IS_SDIO_CLOCK_POWER_SAVE(SAVE) (((SAVE) == SDIO_ClockPowerSave_Disable) || \
                                         ((SAVE) == SDIO_ClockPowerSave_Enable))
+/**
+  * @}
+  */
 
-/* SDIO Bus Wide -------------------------------------------------------------*/
-#define SDIO_BusWide_1b                     ((u32)0x00000000)
-#define SDIO_BusWide_4b                     ((u32)0x00000800)
-#define SDIO_BusWide_8b                     ((u32)0x00001000)
+/** @defgroup SDIO_Bus_Wide 
+  * @{
+  */
 
+#define SDIO_BusWide_1b                     ((uint32_t)0x00000000)
+#define SDIO_BusWide_4b                     ((uint32_t)0x00000800)
+#define SDIO_BusWide_8b                     ((uint32_t)0x00001000)
 #define IS_SDIO_BUS_WIDE(WIDE) (((WIDE) == SDIO_BusWide_1b) || ((WIDE) == SDIO_BusWide_4b) || \
                                 ((WIDE) == SDIO_BusWide_8b))
-                                
-/* SDIO Hardware Flow Control  -----------------------------------------------*/ 
-#define SDIO_HardwareFlowControl_Disable    ((u32)0x00000000)
-#define SDIO_HardwareFlowControl_Enable     ((u32)0x00004000)
 
+/**
+  * @}
+  */
+
+/** @defgroup SDIO_Hardware_Flow_Control 
+  * @{
+  */
+
+#define SDIO_HardwareFlowControl_Disable    ((uint32_t)0x00000000)
+#define SDIO_HardwareFlowControl_Enable     ((uint32_t)0x00004000)
 #define IS_SDIO_HARDWARE_FLOW_CONTROL(CONTROL) (((CONTROL) == SDIO_HardwareFlowControl_Disable) || \
                                                 ((CONTROL) == SDIO_HardwareFlowControl_Enable))
-                                  
-/* SDIO Power State ----------------------------------------------------------*/
-#define SDIO_PowerState_OFF                 ((u32)0x00000000)
-#define SDIO_PowerState_ON                  ((u32)0x00000003)
+/**
+  * @}
+  */
 
+/** @defgroup SDIO_Power_State 
+  * @{
+  */
+
+#define SDIO_PowerState_OFF                 ((uint32_t)0x00000000)
+#define SDIO_PowerState_ON                  ((uint32_t)0x00000003)
 #define IS_SDIO_POWER_STATE(STATE) (((STATE) == SDIO_PowerState_OFF) || ((STATE) == SDIO_PowerState_ON)) 
+/**
+  * @}
+  */ 
 
-/* SDIO Interrupt soucres ----------------------------------------------------*/
-#define SDIO_IT_CCRCFAIL                    ((u32)0x00000001)
-#define SDIO_IT_DCRCFAIL                    ((u32)0x00000002)
-#define SDIO_IT_CTIMEOUT                    ((u32)0x00000004)
-#define SDIO_IT_DTIMEOUT                    ((u32)0x00000008)
-#define SDIO_IT_TXUNDERR                    ((u32)0x00000010)
-#define SDIO_IT_RXOVERR                     ((u32)0x00000020)
-#define SDIO_IT_CMDREND                     ((u32)0x00000040)
-#define SDIO_IT_CMDSENT                     ((u32)0x00000080)
-#define SDIO_IT_DATAEND                     ((u32)0x00000100)
-#define SDIO_IT_STBITERR                    ((u32)0x00000200)
-#define SDIO_IT_DBCKEND                     ((u32)0x00000400)
-#define SDIO_IT_CMDACT                      ((u32)0x00000800)
-#define SDIO_IT_TXACT                       ((u32)0x00001000)
-#define SDIO_IT_RXACT                       ((u32)0x00002000)
-#define SDIO_IT_TXFIFOHE                    ((u32)0x00004000)
-#define SDIO_IT_RXFIFOHF                    ((u32)0x00008000)
-#define SDIO_IT_TXFIFOF                     ((u32)0x00010000)
-#define SDIO_IT_RXFIFOF                     ((u32)0x00020000)
-#define SDIO_IT_TXFIFOE                     ((u32)0x00040000)
-#define SDIO_IT_RXFIFOE                     ((u32)0x00080000)
-#define SDIO_IT_TXDAVL                      ((u32)0x00100000)
-#define SDIO_IT_RXDAVL                      ((u32)0x00200000)
-#define SDIO_IT_SDIOIT                      ((u32)0x00400000)
-#define SDIO_IT_CEATAEND                    ((u32)0x00800000)
 
-#define IS_SDIO_IT(IT) ((((IT) &amp; (u32)0xFF000000) == 0x00) &amp;&amp; ((IT) != (u32)0x00))
+/** @defgroup SDIO_Interrupt_soucres 
+  * @{
+  */
 
-/* SDIO Command Index  -------------------------------------------------------*/
+#define SDIO_IT_CCRCFAIL                    ((uint32_t)0x00000001)
+#define SDIO_IT_DCRCFAIL                    ((uint32_t)0x00000002)
+#define SDIO_IT_CTIMEOUT                    ((uint32_t)0x00000004)
+#define SDIO_IT_DTIMEOUT                    ((uint32_t)0x00000008)
+#define SDIO_IT_TXUNDERR                    ((uint32_t)0x00000010)
+#define SDIO_IT_RXOVERR                     ((uint32_t)0x00000020)
+#define SDIO_IT_CMDREND                     ((uint32_t)0x00000040)
+#define SDIO_IT_CMDSENT                     ((uint32_t)0x00000080)
+#define SDIO_IT_DATAEND                     ((uint32_t)0x00000100)
+#define SDIO_IT_STBITERR                    ((uint32_t)0x00000200)
+#define SDIO_IT_DBCKEND                     ((uint32_t)0x00000400)
+#define SDIO_IT_CMDACT                      ((uint32_t)0x00000800)
+#define SDIO_IT_TXACT                       ((uint32_t)0x00001000)
+#define SDIO_IT_RXACT                       ((uint32_t)0x00002000)
+#define SDIO_IT_TXFIFOHE                    ((uint32_t)0x00004000)
+#define SDIO_IT_RXFIFOHF                    ((uint32_t)0x00008000)
+#define SDIO_IT_TXFIFOF                     ((uint32_t)0x00010000)
+#define SDIO_IT_RXFIFOF                     ((uint32_t)0x00020000)
+#define SDIO_IT_TXFIFOE                     ((uint32_t)0x00040000)
+#define SDIO_IT_RXFIFOE                     ((uint32_t)0x00080000)
+#define SDIO_IT_TXDAVL                      ((uint32_t)0x00100000)
+#define SDIO_IT_RXDAVL                      ((uint32_t)0x00200000)
+#define SDIO_IT_SDIOIT                      ((uint32_t)0x00400000)
+#define SDIO_IT_CEATAEND                    ((uint32_t)0x00800000)
+#define IS_SDIO_IT(IT) ((((IT) &amp; (uint32_t)0xFF000000) == 0x00) &amp;&amp; ((IT) != (uint32_t)0x00))
+/**
+  * @}
+  */ 
+
+/** @defgroup SDIO_Command_Index
+  * @{
+  */
+
 #define IS_SDIO_CMD_INDEX(INDEX)            ((INDEX) &lt; 0x40)
+/**
+  * @}
+  */
 
-/* SDIO Response Type --------------------------------------------------------*/
-#define SDIO_Response_No                    ((u32)0x00000000)
-#define SDIO_Response_Short                 ((u32)0x00000040)
-#define SDIO_Response_Long                  ((u32)0x000000C0)
+/** @defgroup SDIO_Response_Type 
+  * @{
+  */
 
+#define SDIO_Response_No                    ((uint32_t)0x00000000)
+#define SDIO_Response_Short                 ((uint32_t)0x00000040)
+#define SDIO_Response_Long                  ((uint32_t)0x000000C0)
 #define IS_SDIO_RESPONSE(RESPONSE) (((RESPONSE) == SDIO_Response_No) || \
                                     ((RESPONSE) == SDIO_Response_Short) || \
                                     ((RESPONSE) == SDIO_Response_Long))
+/**
+  * @}
+  */
 
-/* SDIO Wait Interrupt State -------------------------------------------------*/
-#define SDIO_Wait_No                        ((u32)0x00000000) /* SDIO No Wait, TimeOut is enabled */
-#define SDIO_Wait_IT                        ((u32)0x00000100) /* SDIO Wait Interrupt Request */
-#define SDIO_Wait_Pend                      ((u32)0x00000200) /* SDIO Wait End of transfer */
+/** @defgroup SDIO_Wait_Interrupt_State 
+  * @{
+  */
 
+#define SDIO_Wait_No                        ((uint32_t)0x00000000) /*!&lt; SDIO No Wait, TimeOut is enabled */
+#define SDIO_Wait_IT                        ((uint32_t)0x00000100) /*!&lt; SDIO Wait Interrupt Request */
+#define SDIO_Wait_Pend                      ((uint32_t)0x00000200) /*!&lt; SDIO Wait End of transfer */
 #define IS_SDIO_WAIT(WAIT) (((WAIT) == SDIO_Wait_No) || ((WAIT) == SDIO_Wait_IT) || \
                             ((WAIT) == SDIO_Wait_Pend))
+/**
+  * @}
+  */
 
-/* SDIO CPSM State -----------------------------------------------------------*/
-#define SDIO_CPSM_Disable                    ((u32)0x00000000)
-#define SDIO_CPSM_Enable                     ((u32)0x00000400)
+/** @defgroup SDIO_CPSM_State 
+  * @{
+  */
 
+#define SDIO_CPSM_Disable                    ((uint32_t)0x00000000)
+#define SDIO_CPSM_Enable                     ((uint32_t)0x00000400)
 #define IS_SDIO_CPSM(CPSM) (((CPSM) == SDIO_CPSM_Enable) || ((CPSM) == SDIO_CPSM_Disable))
+/**
+  * @}
+  */ 
 
-/* SDIO Response Registers ---------------------------------------------------*/
-#define SDIO_RESP1                          ((u32)0x00000000)
-#define SDIO_RESP2                          ((u32)0x00000004)
-#define SDIO_RESP3                          ((u32)0x00000008)
-#define SDIO_RESP4                          ((u32)0x0000000C)
+/** @defgroup SDIO_Response_Registers 
+  * @{
+  */
 
+#define SDIO_RESP1                          ((uint32_t)0x00000000)
+#define SDIO_RESP2                          ((uint32_t)0x00000004)
+#define SDIO_RESP3                          ((uint32_t)0x00000008)
+#define SDIO_RESP4                          ((uint32_t)0x0000000C)
 #define IS_SDIO_RESP(RESP) (((RESP) == SDIO_RESP1) || ((RESP) == SDIO_RESP2) || \
                             ((RESP) == SDIO_RESP3) || ((RESP) == SDIO_RESP4))
+/**
+  * @}
+  */
 
-/* SDIO Data Length ----------------------------------------------------------*/
+/** @defgroup SDIO_Data_Length 
+  * @{
+  */
+
 #define IS_SDIO_DATA_LENGTH(LENGTH) ((LENGTH) &lt;= 0x01FFFFFF)
+/**
+  * @}
+  */
 
-/* SDIO Data Block Size ------------------------------------------------------*/
-#define SDIO_DataBlockSize_1b               ((u32)0x00000000)
-#define SDIO_DataBlockSize_2b               ((u32)0x00000010)
-#define SDIO_DataBlockSize_4b               ((u32)0x00000020)
-#define SDIO_DataBlockSize_8b               ((u32)0x00000030)
-#define SDIO_DataBlockSize_16b              ((u32)0x00000040)
-#define SDIO_DataBlockSize_32b              ((u32)0x00000050)
-#define SDIO_DataBlockSize_64b              ((u32)0x00000060)
-#define SDIO_DataBlockSize_128b             ((u32)0x00000070)
-#define SDIO_DataBlockSize_256b             ((u32)0x00000080)
-#define SDIO_DataBlockSize_512b             ((u32)0x00000090)
-#define SDIO_DataBlockSize_1024b            ((u32)0x000000A0)
-#define SDIO_DataBlockSize_2048b            ((u32)0x000000B0)
-#define SDIO_DataBlockSize_4096b            ((u32)0x000000C0)
-#define SDIO_DataBlockSize_8192b            ((u32)0x000000D0)
-#define SDIO_DataBlockSize_16384b           ((u32)0x000000E0)
+/** @defgroup SDIO_Data_Block_Size 
+  * @{
+  */
 
+#define SDIO_DataBlockSize_1b               ((uint32_t)0x00000000)
+#define SDIO_DataBlockSize_2b               ((uint32_t)0x00000010)
+#define SDIO_DataBlockSize_4b               ((uint32_t)0x00000020)
+#define SDIO_DataBlockSize_8b               ((uint32_t)0x00000030)
+#define SDIO_DataBlockSize_16b              ((uint32_t)0x00000040)
+#define SDIO_DataBlockSize_32b              ((uint32_t)0x00000050)
+#define SDIO_DataBlockSize_64b              ((uint32_t)0x00000060)
+#define SDIO_DataBlockSize_128b             ((uint32_t)0x00000070)
+#define SDIO_DataBlockSize_256b             ((uint32_t)0x00000080)
+#define SDIO_DataBlockSize_512b             ((uint32_t)0x00000090)
+#define SDIO_DataBlockSize_1024b            ((uint32_t)0x000000A0)
+#define SDIO_DataBlockSize_2048b            ((uint32_t)0x000000B0)
+#define SDIO_DataBlockSize_4096b            ((uint32_t)0x000000C0)
+#define SDIO_DataBlockSize_8192b            ((uint32_t)0x000000D0)
+#define SDIO_DataBlockSize_16384b           ((uint32_t)0x000000E0)
 #define IS_SDIO_BLOCK_SIZE(SIZE) (((SIZE) == SDIO_DataBlockSize_1b) || \
                                   ((SIZE) == SDIO_DataBlockSize_2b) || \
                                   ((SIZE) == SDIO_DataBlockSize_4b) || \
@@ -191,53 +326,73 @@
                                   ((SIZE) == SDIO_DataBlockSize_4096b) || \
                                   ((SIZE) == SDIO_DataBlockSize_8192b) || \
                                   ((SIZE) == SDIO_DataBlockSize_16384b)) 
+/**
+  * @}
+  */
 
-/* SDIO Transfer Direction ---------------------------------------------------*/
-#define SDIO_TransferDir_ToCard             ((u32)0x00000000)
-#define SDIO_TransferDir_ToSDIO             ((u32)0x00000002)
+/** @defgroup SDIO_Transfer_Direction 
+  * @{
+  */
 
+#define SDIO_TransferDir_ToCard             ((uint32_t)0x00000000)
+#define SDIO_TransferDir_ToSDIO             ((uint32_t)0x00000002)
 #define IS_SDIO_TRANSFER_DIR(DIR) (((DIR) == SDIO_TransferDir_ToCard) || \
-                                   ((DIR) == SDIO_TransferDir_ToSDIO))  
+                                   ((DIR) == SDIO_TransferDir_ToSDIO))
+/**
+  * @}
+  */
 
-/* SDIO Transfer Type --------------------------------------------------------*/
-#define SDIO_TransferMode_Block             ((u32)0x00000000)
-#define SDIO_TransferMode_Stream            ((u32)0x00000004)
+/** @defgroup SDIO_Transfer_Type 
+  * @{
+  */
 
+#define SDIO_TransferMode_Block             ((uint32_t)0x00000000)
+#define SDIO_TransferMode_Stream            ((uint32_t)0x00000004)
 #define IS_SDIO_TRANSFER_MODE(MODE) (((MODE) == SDIO_TransferMode_Stream) || \
-                                     ((MODE) == SDIO_TransferMode_Block))                                
+                                     ((MODE) == SDIO_TransferMode_Block))
+/**
+  * @}
+  */
 
-/* SDIO DPSM State -----------------------------------------------------------*/
-#define SDIO_DPSM_Disable                    ((u32)0x00000000)
-#define SDIO_DPSM_Enable                     ((u32)0x00000001)
+/** @defgroup SDIO_DPSM_State 
+  * @{
+  */
 
+#define SDIO_DPSM_Disable                    ((uint32_t)0x00000000)
+#define SDIO_DPSM_Enable                     ((uint32_t)0x00000001)
 #define IS_SDIO_DPSM(DPSM) (((DPSM) == SDIO_DPSM_Enable) || ((DPSM) == SDIO_DPSM_Disable))
+/**
+  * @}
+  */
 
-/* SDIO Flags ----------------------------------------------------------------*/
-#define SDIO_FLAG_CCRCFAIL                  ((u32)0x00000001)
-#define SDIO_FLAG_DCRCFAIL                  ((u32)0x00000002)
-#define SDIO_FLAG_CTIMEOUT                  ((u32)0x00000004)
-#define SDIO_FLAG_DTIMEOUT                  ((u32)0x00000008)
-#define SDIO_FLAG_TXUNDERR                  ((u32)0x00000010)
-#define SDIO_FLAG_RXOVERR                   ((u32)0x00000020)
-#define SDIO_FLAG_CMDREND                   ((u32)0x00000040)
-#define SDIO_FLAG_CMDSENT                   ((u32)0x00000080)
-#define SDIO_FLAG_DATAEND                   ((u32)0x00000100)
-#define SDIO_FLAG_STBITERR                  ((u32)0x00000200)
-#define SDIO_FLAG_DBCKEND                   ((u32)0x00000400)
-#define SDIO_FLAG_CMDACT                    ((u32)0x00000800)
-#define SDIO_FLAG_TXACT                     ((u32)0x00001000)
-#define SDIO_FLAG_RXACT                     ((u32)0x00002000)
-#define SDIO_FLAG_TXFIFOHE                  ((u32)0x00004000)
-#define SDIO_FLAG_RXFIFOHF                  ((u32)0x00008000)
-#define SDIO_FLAG_TXFIFOF                   ((u32)0x00010000)
-#define SDIO_FLAG_RXFIFOF                   ((u32)0x00020000)
-#define SDIO_FLAG_TXFIFOE                   ((u32)0x00040000)
-#define SDIO_FLAG_RXFIFOE                   ((u32)0x00080000)
-#define SDIO_FLAG_TXDAVL                    ((u32)0x00100000)
-#define SDIO_FLAG_RXDAVL                    ((u32)0x00200000)
-#define SDIO_FLAG_SDIOIT                    ((u32)0x00400000)
-#define SDIO_FLAG_CEATAEND                  ((u32)0x00800000)
+/** @defgroup SDIO_Flags 
+  * @{
+  */
 
+#define SDIO_FLAG_CCRCFAIL                  ((uint32_t)0x00000001)
+#define SDIO_FLAG_DCRCFAIL                  ((uint32_t)0x00000002)
+#define SDIO_FLAG_CTIMEOUT                  ((uint32_t)0x00000004)
+#define SDIO_FLAG_DTIMEOUT                  ((uint32_t)0x00000008)
+#define SDIO_FLAG_TXUNDERR                  ((uint32_t)0x00000010)
+#define SDIO_FLAG_RXOVERR                   ((uint32_t)0x00000020)
+#define SDIO_FLAG_CMDREND                   ((uint32_t)0x00000040)
+#define SDIO_FLAG_CMDSENT                   ((uint32_t)0x00000080)
+#define SDIO_FLAG_DATAEND                   ((uint32_t)0x00000100)
+#define SDIO_FLAG_STBITERR                  ((uint32_t)0x00000200)
+#define SDIO_FLAG_DBCKEND                   ((uint32_t)0x00000400)
+#define SDIO_FLAG_CMDACT                    ((uint32_t)0x00000800)
+#define SDIO_FLAG_TXACT                     ((uint32_t)0x00001000)
+#define SDIO_FLAG_RXACT                     ((uint32_t)0x00002000)
+#define SDIO_FLAG_TXFIFOHE                  ((uint32_t)0x00004000)
+#define SDIO_FLAG_RXFIFOHF                  ((uint32_t)0x00008000)
+#define SDIO_FLAG_TXFIFOF                   ((uint32_t)0x00010000)
+#define SDIO_FLAG_RXFIFOF                   ((uint32_t)0x00020000)
+#define SDIO_FLAG_TXFIFOE                   ((uint32_t)0x00040000)
+#define SDIO_FLAG_RXFIFOE                   ((uint32_t)0x00080000)
+#define SDIO_FLAG_TXDAVL                    ((uint32_t)0x00100000)
+#define SDIO_FLAG_RXDAVL                    ((uint32_t)0x00200000)
+#define SDIO_FLAG_SDIOIT                    ((uint32_t)0x00400000)
+#define SDIO_FLAG_CEATAEND                  ((uint32_t)0x00800000)
 #define IS_SDIO_FLAG(FLAG) (((FLAG)  == SDIO_FLAG_CCRCFAIL) || \
                             ((FLAG)  == SDIO_FLAG_DCRCFAIL) || \
                             ((FLAG)  == SDIO_FLAG_CTIMEOUT) || \
@@ -263,7 +418,7 @@
                             ((FLAG)  == SDIO_FLAG_SDIOIT) || \
                             ((FLAG)  == SDIO_FLAG_CEATAEND))
 
-#define IS_SDIO_CLEAR_FLAG(FLAG) ((((FLAG) &amp; (u32)0xFF3FF800) == 0x00) &amp;&amp; ((FLAG) != (u32)0x00))
+#define IS_SDIO_CLEAR_FLAG(FLAG) ((((FLAG) &amp; (uint32_t)0xFF3FF800) == 0x00) &amp;&amp; ((FLAG) != (uint32_t)0x00))
 
 #define IS_SDIO_GET_IT(IT) (((IT)  == SDIO_IT_CCRCFAIL) || \
                             ((IT)  == SDIO_IT_DCRCFAIL) || \
@@ -290,48 +445,86 @@
                             ((IT)  == SDIO_IT_SDIOIT) || \
                             ((IT)  == SDIO_IT_CEATAEND))
 
-#define IS_SDIO_CLEAR_IT(IT) ((((IT) &amp; (u32)0xFF3FF800) == 0x00) &amp;&amp; ((IT) != (u32)0x00))
-                                                        
-/* SDIO Read Wait Mode -------------------------------------------------------*/
-#define SDIO_ReadWaitMode_CLK               ((u32)0x00000000)
-#define SDIO_ReadWaitMode_DATA2             ((u32)0x00000001)
+#define IS_SDIO_CLEAR_IT(IT) ((((IT) &amp; (uint32_t)0xFF3FF800) == 0x00) &amp;&amp; ((IT) != (uint32_t)0x00))
 
+/**
+  * @}
+  */
+
+/** @defgroup SDIO_Read_Wait_Mode 
+  * @{
+  */
+
+#define SDIO_ReadWaitMode_CLK               ((uint32_t)0x00000000)
+#define SDIO_ReadWaitMode_DATA2             ((uint32_t)0x00000001)
 #define IS_SDIO_READWAIT_MODE(MODE) (((MODE) == SDIO_ReadWaitMode_CLK) || \
-                                     ((MODE) == SDIO_ReadWaitMode_DATA2))  
+                                     ((MODE) == SDIO_ReadWaitMode_DATA2))
+/**
+  * @}
+  */
 
-/* Exported macro ------------------------------------------------------------*/
-/* Exported functions ------------------------------------------------------- */
+/**
+  * @}
+  */
+
+/** @defgroup SDIO_Exported_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup SDIO_Exported_Functions
+  * @{
+  */
+
 void SDIO_DeInit(void);
 void SDIO_Init(SDIO_InitTypeDef* SDIO_InitStruct);
 void SDIO_StructInit(SDIO_InitTypeDef* SDIO_InitStruct);
 void SDIO_ClockCmd(FunctionalState NewState);
-void SDIO_SetPowerState(u32 SDIO_PowerState);
-u32 SDIO_GetPowerState(void);
-void SDIO_ITConfig(u32 SDIO_IT, FunctionalState NewState);
+void SDIO_SetPowerState(uint32_t SDIO_PowerState);
+uint32_t SDIO_GetPowerState(void);
+void SDIO_ITConfig(uint32_t SDIO_IT, FunctionalState NewState);
 void SDIO_DMACmd(FunctionalState NewState);
 void SDIO_SendCommand(SDIO_CmdInitTypeDef *SDIO_CmdInitStruct);
 void SDIO_CmdStructInit(SDIO_CmdInitTypeDef* SDIO_CmdInitStruct);
-u8 SDIO_GetCommandResponse(void);
-u32 SDIO_GetResponse(u32 SDIO_RESP);
+uint8_t SDIO_GetCommandResponse(void);
+uint32_t SDIO_GetResponse(uint32_t SDIO_RESP);
 void SDIO_DataConfig(SDIO_DataInitTypeDef* SDIO_DataInitStruct);
 void SDIO_DataStructInit(SDIO_DataInitTypeDef* SDIO_DataInitStruct);
-u32 SDIO_GetDataCounter(void);
-u32 SDIO_ReadData(void);
-void SDIO_WriteData(u32 Data);
-u32 SDIO_GetFIFOCount(void);
+uint32_t SDIO_GetDataCounter(void);
+uint32_t SDIO_ReadData(void);
+void SDIO_WriteData(uint32_t Data);
+uint32_t SDIO_GetFIFOCount(void);
 void SDIO_StartSDIOReadWait(FunctionalState NewState);
 void SDIO_StopSDIOReadWait(FunctionalState NewState);
-void SDIO_SetSDIOReadWaitMode(u32 SDIO_ReadWaitMode);
+void SDIO_SetSDIOReadWaitMode(uint32_t SDIO_ReadWaitMode);
 void SDIO_SetSDIOOperation(FunctionalState NewState);
 void SDIO_SendSDIOSuspendCmd(FunctionalState NewState);
 void SDIO_CommandCompletionCmd(FunctionalState NewState);
 void SDIO_CEATAITCmd(FunctionalState NewState);
 void SDIO_SendCEATACmd(FunctionalState NewState);
-FlagStatus SDIO_GetFlagStatus(u32 SDIO_FLAG);
-void SDIO_ClearFlag(u32 SDIO_FLAG);
-ITStatus SDIO_GetITStatus(u32 SDIO_IT);
-void SDIO_ClearITPendingBit(u32 SDIO_IT);
+FlagStatus SDIO_GetFlagStatus(uint32_t SDIO_FLAG);
+void SDIO_ClearFlag(uint32_t SDIO_FLAG);
+ITStatus SDIO_GetITStatus(uint32_t SDIO_IT);
+void SDIO_ClearITPendingBit(uint32_t SDIO_IT);
 
+#ifdef __cplusplus
+}
+#endif
+
 #endif /* __STM32F10x_SDIO_H */
+/**
+  * @}
+  */
 
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2009 STMicroelectronics *****END OF FILE****/

Modified: trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_spi.h
===================================================================
--- trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_spi.h	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_spi.h	2009-07-08 23:39:34 UTC (rev 354)
@@ -1,117 +1,213 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_spi.h
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file contains all the functions prototypes for the
-*                      SPI firmware library.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
+/**
+  ******************************************************************************
+  * @file    stm32f10x_spi.h
+  * @author  MCD Application Team
+  * @version V3.1.0
+  * @date    06/19/2009
+  * @brief   This file contains all the functions prototypes for the SPI firmware 
+  *          library.
+  ******************************************************************************
+  * @copy
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * &lt;h2&gt;&lt;center&gt;&copy; COPYRIGHT 2009 STMicroelectronics&lt;/center&gt;&lt;/h2&gt;
+  */ 
 
 /* Define to prevent recursive inclusion -------------------------------------*/
 #ifndef __STM32F10x_SPI_H
 #define __STM32F10x_SPI_H
 
+#ifdef __cplusplus
+ extern &quot;C&quot; {
+#endif
+
 /* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_map.h&quot;
+#include &quot;stm32f10x.h&quot;
 
-/* Exported types ------------------------------------------------------------*/
-/* SPI Init structure definition */
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @addtogroup SPI
+  * @{
+  */ 
+
+/** @defgroup SPI_Exported_Types
+  * @{
+  */
+
+/** 
+  * @brief  SPI Init structure definition  
+  */
+
 typedef struct
 {
-  u16 SPI_Direction;
-  u16 SPI_Mode;
-  u16 SPI_DataSize;
-  u16 SPI_CPOL;
-  u16 SPI_CPHA;
-  u16 SPI_NSS;
-  u16 SPI_BaudRatePrescaler;
-  u16 SPI_FirstBit;
-  u16 SPI_CRCPolynomial;
+  uint16_t SPI_Direction;           /*!&lt; Specifies the SPI unidirectional or bidirectional data mode.
+                                         This parameter can be any combination of @ref SPI_data_direction */
+
+  uint16_t SPI_Mode;                /*!&lt; Specifies the SPI operating mode.
+                                         This parameter can be any combination of @ref SPI_mode */
+
+  uint16_t SPI_DataSize;            /*!&lt; Specifies the SPI data size.
+                                         This parameter can be any combination of @ref SPI_data_size */
+
+  uint16_t SPI_CPOL;                /*!&lt; Specifies the serial clock steady state.
+                                         This parameter can be any combination of @ref SPI_Clock_Polarity */
+
+  uint16_t SPI_CPHA;                /*!&lt; Specifies the clock active edge for the bit capture.
+                                         This parameter can be any combination of @ref SPI_Clock_Phase */
+
+  uint16_t SPI_NSS;                 /*!&lt; Specifies whether the NSS signal is managed by
+                                         hardware (NSS pin) or by software using the SSI bit.
+                                         This parameter can be any combination of @ref SPI_Slave_Select_management */
+ 
+  uint16_t SPI_BaudRatePrescaler;   /*!&lt; Specifies the Baud Rate prescaler value which will be
+                                         used to configure the transmit and receive SCK clock.
+                                         This parameter can be any combination of @ref SPI_BaudRate_Prescaler.
+                                         @note The communication clock is derived from the master
+                                               clock. The slave clock does not need to be set. */
+
+  uint16_t SPI_FirstBit;            /*!&lt; Specifies whether data transfers start from MSB or LSB bit.
+                                         This parameter can be any combination of @ref SPI_MSB_LSB_transmission */
+
+  uint16_t SPI_CRCPolynomial;       /*!&lt; Specifies the polynomial used for the CRC calculation. */
 }SPI_InitTypeDef;
 
-/* I2S Init structure definition */
+/** 
+  * @brief  I2S Init structure definition  
+  */
+
 typedef struct
 {
-  u16 I2S_Mode;
-  u16 I2S_Standard;
-  u16 I2S_DataFormat;
-  u16 I2S_MCLKOutput;
-  u16 I2S_AudioFreq;
-  u16 I2S_CPOL;
+
+  uint16_t I2S_Mode;         /*!&lt; Specifies the I2S operating mode.
+                                  This parameter can be any combination of @ref I2S_Mode */
+
+  uint16_t I2S_Standard;     /*!&lt; Specifies the standard used for the I2S communication.
+                                  This parameter can be any combination of @ref I2S_Standard */
+
+  uint16_t I2S_DataFormat;   /*!&lt; Specifies the data format for the I2S communication.
+                                  This parameter can be any combination of @ref I2S_Data_Format */
+
+  uint16_t I2S_MCLKOutput;   /*!&lt; Specifies whether the I2S MCLK output is enabled or not.
+                                  This parameter can be any combination of @ref I2S_MCLK_Output */
+
+  uint16_t I2S_AudioFreq;    /*!&lt; Specifies the frequency selected for the I2S communication.
+                                  This parameter can be any combination of @ref I2S_Audio_Frequency */
+
+  uint16_t I2S_CPOL;         /*!&lt; Specifies the idle state of the I2S clock.
+                                  This parameter can be any combination of @ref I2S_Clock_Polarity */
 }I2S_InitTypeDef;
 
-/* Exported constants --------------------------------------------------------*/
+/**
+  * @}
+  */
 
-#define IS_SPI_ALL_PERIPH(PERIPH) (((*(u32*)&amp;(PERIPH)) == SPI1_BASE) || \
-                                   ((*(u32*)&amp;(PERIPH)) == SPI2_BASE) || \
-                                   ((*(u32*)&amp;(PERIPH)) == SPI3_BASE))
+/** @defgroup SPI_Exported_Constants
+  * @{
+  */
 
-#define IS_SPI_23_PERIPH(PERIPH) (((*(u32*)&amp;(PERIPH)) == SPI2_BASE) || \
-                                  ((*(u32*)&amp;(PERIPH)) == SPI3_BASE))
+#define IS_SPI_ALL_PERIPH(PERIPH) (((PERIPH) == SPI1) || \
+                                   ((PERIPH) == SPI2) || \
+                                   ((PERIPH) == SPI3))
 
-/* SPI data direction mode */
-#define SPI_Direction_2Lines_FullDuplex ((u16)0x0000)
-#define SPI_Direction_2Lines_RxOnly     ((u16)0x0400)
-#define SPI_Direction_1Line_Rx          ((u16)0x8000)
-#define SPI_Direction_1Line_Tx          ((u16)0xC000)
+#define IS_SPI_23_PERIPH(PERIPH) (((PERIPH) == SPI2) || \
+                                  ((PERIPH) == SPI3))
 
+/** @defgroup SPI_data_direction 
+  * @{
+  */
+  
+#define SPI_Direction_2Lines_FullDuplex ((uint16_t)0x0000)
+#define SPI_Direction_2Lines_RxOnly     ((uint16_t)0x0400)
+#define SPI_Direction_1Line_Rx          ((uint16_t)0x8000)
+#define SPI_Direction_1Line_Tx          ((uint16_t)0xC000)
 #define IS_SPI_DIRECTION_MODE(MODE) (((MODE) == SPI_Direction_2Lines_FullDuplex) || \
                                      ((MODE) == SPI_Direction_2Lines_RxOnly) || \
                                      ((MODE) == SPI_Direction_1Line_Rx) || \
                                      ((MODE) == SPI_Direction_1Line_Tx))
+/**
+  * @}
+  */
 
-/* SPI master/slave mode */
-#define SPI_Mode_Master                 ((u16)0x0104)
-#define SPI_Mode_Slave                  ((u16)0x0000)
+/** @defgroup SPI_mode 
+  * @{
+  */
 
+#define SPI_Mode_Master                 ((uint16_t)0x0104)
+#define SPI_Mode_Slave                  ((uint16_t)0x0000)
 #define IS_SPI_MODE(MODE) (((MODE) == SPI_Mode_Master) || \
                            ((MODE) == SPI_Mode_Slave))
+/**
+  * @}
+  */
 
-/* SPI data size */
-#define SPI_DataSize_16b                ((u16)0x0800)
-#define SPI_DataSize_8b                 ((u16)0x0000)
+/** @defgroup SPI_data_size 
+  * @{
+  */
 
+#define SPI_DataSize_16b                ((uint16_t)0x0800)
+#define SPI_DataSize_8b                 ((uint16_t)0x0000)
 #define IS_SPI_DATASIZE(DATASIZE) (((DATASIZE) == SPI_DataSize_16b) || \
                                    ((DATASIZE) == SPI_DataSize_8b))
+/**
+  * @}
+  */ 
 
-/* SPI Clock Polarity */
-#define SPI_CPOL_Low                    ((u16)0x0000)
-#define SPI_CPOL_High                   ((u16)0x0002)
+/** @defgroup SPI_Clock_Polarity 
+  * @{
+  */
 
+#define SPI_CPOL_Low                    ((uint16_t)0x0000)
+#define SPI_CPOL_High                   ((uint16_t)0x0002)
 #define IS_SPI_CPOL(CPOL) (((CPOL) == SPI_CPOL_Low) || \
                            ((CPOL) == SPI_CPOL_High))
+/**
+  * @}
+  */
 
-/* SPI Clock Phase */
-#define SPI_CPHA_1Edge                  ((u16)0x0000)
-#define SPI_CPHA_2Edge                  ((u16)0x0001)
+/** @defgroup SPI_Clock_Phase 
+  * @{
+  */
 
+#define SPI_CPHA_1Edge                  ((uint16_t)0x0000)
+#define SPI_CPHA_2Edge                  ((uint16_t)0x0001)
 #define IS_SPI_CPHA(CPHA) (((CPHA) == SPI_CPHA_1Edge) || \
                            ((CPHA) == SPI_CPHA_2Edge))
+/**
+  * @}
+  */
 
-/* SPI Slave Select management */
-#define SPI_NSS_Soft                    ((u16)0x0200)
-#define SPI_NSS_Hard                    ((u16)0x0000)
+/** @defgroup SPI_Slave_Select_management 
+  * @{
+  */
 
+#define SPI_NSS_Soft                    ((uint16_t)0x0200)
+#define SPI_NSS_Hard                    ((uint16_t)0x0000)
 #define IS_SPI_NSS(NSS) (((NSS) == SPI_NSS_Soft) || \
-                         ((NSS) == SPI_NSS_Hard))                         
+                         ((NSS) == SPI_NSS_Hard))
+/**
+  * @}
+  */ 
 
-/* SPI BaudRate Prescaler  */
-#define SPI_BaudRatePrescaler_2         ((u16)0x0000)
-#define SPI_BaudRatePrescaler_4         ((u16)0x0008)
-#define SPI_BaudRatePrescaler_8         ((u16)0x0010)
-#define SPI_BaudRatePrescaler_16        ((u16)0x0018)
-#define SPI_BaudRatePrescaler_32        ((u16)0x0020)
-#define SPI_BaudRatePrescaler_64        ((u16)0x0028)
-#define SPI_BaudRatePrescaler_128       ((u16)0x0030)
-#define SPI_BaudRatePrescaler_256       ((u16)0x0038)
+/** @defgroup SPI_BaudRate_Prescaler 
+  * @{
+  */
 
+#define SPI_BaudRatePrescaler_2         ((uint16_t)0x0000)
+#define SPI_BaudRatePrescaler_4         ((uint16_t)0x0008)
+#define SPI_BaudRatePrescaler_8         ((uint16_t)0x0010)
+#define SPI_BaudRatePrescaler_16        ((uint16_t)0x0018)
+#define SPI_BaudRatePrescaler_32        ((uint16_t)0x0020)
+#define SPI_BaudRatePrescaler_64        ((uint16_t)0x0028)
+#define SPI_BaudRatePrescaler_128       ((uint16_t)0x0030)
+#define SPI_BaudRatePrescaler_256       ((uint16_t)0x0038)
 #define IS_SPI_BAUDRATE_PRESCALER(PRESCALER) (((PRESCALER) == SPI_BaudRatePrescaler_2) || \
                                               ((PRESCALER) == SPI_BaudRatePrescaler_4) || \
                                               ((PRESCALER) == SPI_BaudRatePrescaler_8) || \
@@ -120,146 +216,236 @@
                                               ((PRESCALER) == SPI_BaudRatePrescaler_64) || \
                                               ((PRESCALER) == SPI_BaudRatePrescaler_128) || \
                                               ((PRESCALER) == SPI_BaudRatePrescaler_256))
+/**
+  * @}
+  */ 
 
-/* SPI MSB/LSB transmission */
-#define SPI_FirstBit_MSB                ((u16)0x0000)
-#define SPI_FirstBit_LSB                ((u16)0x0080)
+/** @defgroup SPI_MSB_LSB_transmission 
+  * @{
+  */
 
+#define SPI_FirstBit_MSB                ((uint16_t)0x0000)
+#define SPI_FirstBit_LSB                ((uint16_t)0x0080)
 #define IS_SPI_FIRST_BIT(BIT) (((BIT) == SPI_FirstBit_MSB) || \
                                ((BIT) == SPI_FirstBit_LSB))
+/**
+  * @}
+  */
 
-/* I2S Mode */
-#define I2S_Mode_SlaveTx                ((u16)0x0000)
-#define I2S_Mode_SlaveRx                ((u16)0x0100)
-#define I2S_Mode_MasterTx               ((u16)0x0200)
-#define I2S_Mode_MasterRx               ((u16)0x0300)
+/** @defgroup I2S_Mode 
+  * @{
+  */
 
+#define I2S_Mode_SlaveTx                ((uint16_t)0x0000)
+#define I2S_Mode_SlaveRx                ((uint16_t)0x0100)
+#define I2S_Mode_MasterTx               ((uint16_t)0x0200)
+#define I2S_Mode_MasterRx               ((uint16_t)0x0300)
 #define IS_I2S_MODE(MODE) (((MODE) == I2S_Mode_SlaveTx) || \
                            ((MODE) == I2S_Mode_SlaveRx) || \
                            ((MODE) == I2S_Mode_MasterTx) || \
                            ((MODE) == I2S_Mode_MasterRx) )
+/**
+  * @}
+  */
 
-/* I2S Standard */
-#define I2S_Standard_Phillips           ((u16)0x0000)
-#define I2S_Standard_MSB                ((u16)0x0010)
-#define I2S_Standard_LSB                ((u16)0x0020)
-#define I2S_Standard_PCMShort           ((u16)0x0030)
-#define I2S_Standard_PCMLong            ((u16)0x00B0)
+/** @defgroup I2S_Standard 
+  * @{
+  */
 
+#define I2S_Standard_Phillips           ((uint16_t)0x0000)
+#define I2S_Standard_MSB                ((uint16_t)0x0010)
+#define I2S_Standard_LSB                ((uint16_t)0x0020)
+#define I2S_Standard_PCMShort           ((uint16_t)0x0030)
+#define I2S_Standard_PCMLong            ((uint16_t)0x00B0)
 #define IS_I2S_STANDARD(STANDARD) (((STANDARD) == I2S_Standard_Phillips) || \
                                    ((STANDARD) == I2S_Standard_MSB) || \
                                    ((STANDARD) == I2S_Standard_LSB) || \
                                    ((STANDARD) == I2S_Standard_PCMShort) || \
                                    ((STANDARD) == I2S_Standard_PCMLong))
+/**
+  * @}
+  */
 
-/* I2S Data Format */
-#define I2S_DataFormat_16b              ((u16)0x0000)
-#define I2S_DataFormat_16bextended      ((u16)0x0001)
-#define I2S_DataFormat_24b              ((u16)0x0003)
-#define I2S_DataFormat_32b              ((u16)0x0005)
+/** @defgroup I2S_Data_Format 
+  * @{
+  */
 
+#define I2S_DataFormat_16b              ((uint16_t)0x0000)
+#define I2S_DataFormat_16bextended      ((uint16_t)0x0001)
+#define I2S_DataFormat_24b              ((uint16_t)0x0003)
+#define I2S_DataFormat_32b              ((uint16_t)0x0005)
 #define IS_I2S_DATA_FORMAT(FORMAT) (((FORMAT) == I2S_DataFormat_16b) || \
                                     ((FORMAT) == I2S_DataFormat_16bextended) || \
                                     ((FORMAT) == I2S_DataFormat_24b) || \
                                     ((FORMAT) == I2S_DataFormat_32b))
+/**
+  * @}
+  */ 
 
-/* I2S MCLK Output */ 
-#define I2S_MCLKOutput_Enable           ((u16)0x0200)
-#define I2S_MCLKOutput_Disable          ((u16)0x0000)
+/** @defgroup I2S_MCLK_Output 
+  * @{
+  */
 
+#define I2S_MCLKOutput_Enable           ((uint16_t)0x0200)
+#define I2S_MCLKOutput_Disable          ((uint16_t)0x0000)
 #define IS_I2S_MCLK_OUTPUT(OUTPUT) (((OUTPUT) == I2S_MCLKOutput_Enable) || \
                                     ((OUTPUT) == I2S_MCLKOutput_Disable))
+/**
+  * @}
+  */
 
-/* I2S Audio Frequency */
-#define I2S_AudioFreq_48k                ((u16)48000)
-#define I2S_AudioFreq_44k                ((u16)44100)
-#define I2S_AudioFreq_22k                ((u16)22050)
-#define I2S_AudioFreq_16k                ((u16)16000)
-#define I2S_AudioFreq_8k                 ((u16)8000)
-#define I2S_AudioFreq_Default            ((u16)2)
+/** @defgroup I2S_Audio_Frequency 
+  * @{
+  */
 
-#define IS_I2S_AUDIO_FREQ(FREQ) (((FREQ) == I2S_AudioFreq_48k) || \
+#define I2S_AudioFreq_96k                ((uint16_t)96000)
+#define I2S_AudioFreq_48k                ((uint16_t)48000)
+#define I2S_AudioFreq_44k                ((uint16_t)44100)
+#define I2S_AudioFreq_32k                ((uint16_t)32000)
+#define I2S_AudioFreq_22k                ((uint16_t)22050)
+#define I2S_AudioFreq_16k                ((uint16_t)16000)
+#define I2S_AudioFreq_11k                 ((uint16_t)11025)
+#define I2S_AudioFreq_8k                 ((uint16_t)8000)
+#define I2S_AudioFreq_Default            ((uint16_t)2)
+#define IS_I2S_AUDIO_FREQ(FREQ) (((FREQ) == I2S_AudioFreq_96k) || \
+                                 ((FREQ) == I2S_AudioFreq_48k) || \
                                  ((FREQ) == I2S_AudioFreq_44k) || \
+                                 ((FREQ) == I2S_AudioFreq_32k) || \
                                  ((FREQ) == I2S_AudioFreq_22k) || \
                                  ((FREQ) == I2S_AudioFreq_16k) || \
+                                 ((FREQ) == I2S_AudioFreq_11k) || \
                                  ((FREQ) == I2S_AudioFreq_8k)  || \
                                  ((FREQ) == I2S_AudioFreq_Default))
+/**
+  * @}
+  */ 
 
-/* I2S Clock Polarity */
-#define I2S_CPOL_Low                    ((u16)0x0000)
-#define I2S_CPOL_High                   ((u16)0x0008)
+/** @defgroup I2S_Clock_Polarity 
+  * @{
+  */
 
+#define I2S_CPOL_Low                    ((uint16_t)0x0000)
+#define I2S_CPOL_High                   ((uint16_t)0x0008)
 #define IS_I2S_CPOL(CPOL) (((CPOL) == I2S_CPOL_Low) || \
                            ((CPOL) == I2S_CPOL_High))
+/**
+  * @}
+  */
 
-/* SPI_I2S DMA transfer requests */
-#define SPI_I2S_DMAReq_Tx               ((u16)0x0002)
-#define SPI_I2S_DMAReq_Rx               ((u16)0x0001)
+/** @defgroup SPI_I2S_DMA_transfer_requests 
+  * @{
+  */
 
-#define IS_SPI_I2S_DMAREQ(DMAREQ) ((((DMAREQ) &amp; (u16)0xFFFC) == 0x00) &amp;&amp; ((DMAREQ) != 0x00))
+#define SPI_I2S_DMAReq_Tx               ((uint16_t)0x0002)
+#define SPI_I2S_DMAReq_Rx               ((uint16_t)0x0001)
+#define IS_SPI_I2S_DMAREQ(DMAREQ) ((((DMAREQ) &amp; (uint16_t)0xFFFC) == 0x00) &amp;&amp; ((DMAREQ) != 0x00))
+/**
+  * @}
+  */
 
-/* SPI NSS internal software mangement */
-#define SPI_NSSInternalSoft_Set         ((u16)0x0100)
-#define SPI_NSSInternalSoft_Reset       ((u16)0xFEFF)
+/** @defgroup SPI_NSS_internal_software_mangement 
+  * @{
+  */
 
+#define SPI_NSSInternalSoft_Set         ((uint16_t)0x0100)
+#define SPI_NSSInternalSoft_Reset       ((uint16_t)0xFEFF)
 #define IS_SPI_NSS_INTERNAL(INTERNAL) (((INTERNAL) == SPI_NSSInternalSoft_Set) || \
                                        ((INTERNAL) == SPI_NSSInternalSoft_Reset))
+/**
+  * @}
+  */
 
-/* SPI CRC Transmit/Receive */
-#define SPI_CRC_Tx                      ((u8)0x00)
-#define SPI_CRC_Rx                      ((u8)0x01)
+/** @defgroup SPI_CRC_Transmit_Receive 
+  * @{
+  */
 
+#define SPI_CRC_Tx                      ((uint8_t)0x00)
+#define SPI_CRC_Rx                      ((uint8_t)0x01)
 #define IS_SPI_CRC(CRC) (((CRC) == SPI_CRC_Tx) || ((CRC) == SPI_CRC_Rx))
+/**
+  * @}
+  */
 
-/* SPI direction transmit/receive */
-#define SPI_Direction_Rx                ((u16)0xBFFF)
-#define SPI_Direction_Tx                ((u16)0x4000)
+/** @defgroup SPI_direction_transmit_receive 
+  * @{
+  */
 
+#define SPI_Direction_Rx                ((uint16_t)0xBFFF)
+#define SPI_Direction_Tx                ((uint16_t)0x4000)
 #define IS_SPI_DIRECTION(DIRECTION) (((DIRECTION) == SPI_Direction_Rx) || \
                                      ((DIRECTION) == SPI_Direction_Tx))
+/**
+  * @}
+  */
 
-/* SPI_I2S interrupts definition */
-#define SPI_I2S_IT_TXE                  ((u8)0x71)
-#define SPI_I2S_IT_RXNE                 ((u8)0x60)
-#define SPI_I2S_IT_ERR                  ((u8)0x50)
+/** @defgroup SPI_I2S_interrupts_definition 
+  * @{
+  */
 
+#define SPI_I2S_IT_TXE                  ((uint8_t)0x71)
+#define SPI_I2S_IT_RXNE                 ((uint8_t)0x60)
+#define SPI_I2S_IT_ERR                  ((uint8_t)0x50)
 #define IS_SPI_I2S_CONFIG_IT(IT) (((IT) == SPI_I2S_IT_TXE) || \
                                  ((IT) == SPI_I2S_IT_RXNE) || \
                                  ((IT) == SPI_I2S_IT_ERR))
-
-#define SPI_I2S_IT_OVR                  ((u8)0x56)
-#define SPI_IT_MODF                     ((u8)0x55)
-#define SPI_IT_CRCERR                   ((u8)0x54)
-#define I2S_IT_UDR                      ((u8)0x53)
-
+#define SPI_I2S_IT_OVR                  ((uint8_t)0x56)
+#define SPI_IT_MODF                     ((uint8_t)0x55)
+#define SPI_IT_CRCERR                   ((uint8_t)0x54)
+#define I2S_IT_UDR                      ((uint8_t)0x53)
 #define IS_SPI_I2S_CLEAR_IT(IT) (((IT) == SPI_IT_CRCERR))
-
 #define IS_SPI_I2S_GET_IT(IT) (((IT) == SPI_I2S_IT_RXNE) || ((IT) == SPI_I2S_IT_TXE) || \
                                ((IT) == I2S_IT_UDR) || ((IT) == SPI_IT_CRCERR) || \
                                ((IT) == SPI_IT_MODF) || ((IT) == SPI_I2S_IT_OVR))
+/**
+  * @}
+  */
 
-/* SPI_I2S flags definition */
-#define SPI_I2S_FLAG_RXNE               ((u16)0x0001)
-#define SPI_I2S_FLAG_TXE                ((u16)0x0002)
-#define I2S_FLAG_CHSIDE                 ((u16)0x0004)
-#define I2S_FLAG_UDR                    ((u16)0x0008)
-#define SPI_FLAG_CRCERR                 ((u16)0x0010)
-#define SPI_FLAG_MODF                   ((u16)0x0020)
-#define SPI_I2S_FLAG_OVR                ((u16)0x0040)
-#define SPI_I2S_FLAG_BSY                ((u16)0x0080)
+/** @defgroup SPI_I2S_flags_definition 
+  * @{
+  */
 
+#define SPI_I2S_FLAG_RXNE               ((uint16_t)0x0001)
+#define SPI_I2S_FLAG_TXE                ((uint16_t)0x0002)
+#define I2S_FLAG_CHSIDE                 ((uint16_t)0x0004)
+#define I2S_FLAG_UDR                    ((uint16_t)0x0008)
+#define SPI_FLAG_CRCERR                 ((uint16_t)0x0010)
+#define SPI_FLAG_MODF                   ((uint16_t)0x0020)
+#define SPI_I2S_FLAG_OVR                ((uint16_t)0x0040)
+#define SPI_I2S_FLAG_BSY                ((uint16_t)0x0080)
 #define IS_SPI_I2S_CLEAR_FLAG(FLAG) (((FLAG) == SPI_FLAG_CRCERR))
-
 #define IS_SPI_I2S_GET_FLAG(FLAG) (((FLAG) == SPI_I2S_FLAG_BSY) || ((FLAG) == SPI_I2S_FLAG_OVR) || \
                                    ((FLAG) == SPI_FLAG_MODF) || ((FLAG) == SPI_FLAG_CRCERR) || \
                                    ((FLAG) == I2S_FLAG_UDR) || ((FLAG) == I2S_FLAG_CHSIDE) || \
                                    ((FLAG) == SPI_I2S_FLAG_TXE) || ((FLAG) == SPI_I2S_FLAG_RXNE))
+/**
+  * @}
+  */
 
-/* SPI CRC polynomial --------------------------------------------------------*/
+/** @defgroup SPI_CRC_polynomial 
+  * @{
+  */
+
 #define IS_SPI_CRC_POLYNOMIAL(POLYNOMIAL) ((POLYNOMIAL) &gt;= 0x1)
+/**
+  * @}
+  */
 
-/* Exported macro ------------------------------------------------------------*/
-/* Exported functions ------------------------------------------------------- */
+/**
+  * @}
+  */
+
+/** @defgroup SPI_Exported_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup SPI_Exported_Functions
+  * @{
+  */
+
 void SPI_I2S_DeInit(SPI_TypeDef* SPIx);
 void SPI_Init(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct);
 void I2S_Init(SPI_TypeDef* SPIx, I2S_InitTypeDef* I2S_InitStruct);
@@ -267,23 +453,38 @@
 void I2S_StructInit(I2S_InitTypeDef* I2S_InitStruct);
 void SPI_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState);
 void I2S_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState);
-void SPI_I2S_ITConfig(SPI_TypeDef* SPIx, u8 SPI_I2S_IT, FunctionalState NewState);
-void SPI_I2S_DMACmd(SPI_TypeDef* SPIx, u16 SPI_I2S_DMAReq, FunctionalState NewState);
-void SPI_I2S_SendData(SPI_TypeDef* SPIx, u16 Data);
-u16 SPI_I2S_ReceiveData(SPI_TypeDef* SPIx);
-void SPI_NSSInternalSoftwareConfig(SPI_TypeDef* SPIx, u16 SPI_NSSInternalSoft);
+void SPI_I2S_ITConfig(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT, FunctionalState NewState);
+void SPI_I2S_DMACmd(SPI_TypeDef* SPIx, uint16_t SPI_I2S_DMAReq, FunctionalState NewState);
+void SPI_I2S_SendData(SPI_TypeDef* SPIx, uint16_t Data);
+uint16_t SPI_I2S_ReceiveData(SPI_TypeDef* SPIx);
+void SPI_NSSInternalSoftwareConfig(SPI_TypeDef* SPIx, uint16_t SPI_NSSInternalSoft);
 void SPI_SSOutputCmd(SPI_TypeDef* SPIx, FunctionalState NewState);
-void SPI_DataSizeConfig(SPI_TypeDef* SPIx, u16 SPI_DataSize);
+void SPI_DataSizeConfig(SPI_TypeDef* SPIx, uint16_t SPI_DataSize);
 void SPI_TransmitCRC(SPI_TypeDef* SPIx);
 void SPI_CalculateCRC(SPI_TypeDef* SPIx, FunctionalState NewState);
-u16 SPI_GetCRC(SPI_TypeDef* SPIx, u8 SPI_CRC);
-u16 SPI_GetCRCPolynomial(SPI_TypeDef* SPIx);
-void SPI_BiDirectionalLineConfig(SPI_TypeDef* SPIx, u16 SPI_Direction);
-FlagStatus SPI_I2S_GetFlagStatus(SPI_TypeDef* SPIx, u16 SPI_I2S_FLAG);
-void SPI_I2S_ClearFlag(SPI_TypeDef* SPIx, u16 SPI_I2S_FLAG);
-ITStatus SPI_I2S_GetITStatus(SPI_TypeDef* SPIx, u8 SPI_I2S_IT);
-void SPI_I2S_ClearITPendingBit(SPI_TypeDef* SPIx, u8 SPI_I2S_IT);
+uint16_t SPI_GetCRC(SPI_TypeDef* SPIx, uint8_t SPI_CRC);
+uint16_t SPI_GetCRCPolynomial(SPI_TypeDef* SPIx);
+void SPI_BiDirectionalLineConfig(SPI_TypeDef* SPIx, uint16_t SPI_Direction);
+FlagStatus SPI_I2S_GetFlagStatus(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG);
+void SPI_I2S_ClearFlag(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG);
+ITStatus SPI_I2S_GetITStatus(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT);
+void SPI_I2S_ClearITPendingBit(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT);
 
+#ifdef __cplusplus
+}
+#endif
+
 #endif /*__STM32F10x_SPI_H */
+/**
+  * @}
+  */
 
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2009 STMicroelectronics *****END OF FILE****/

Deleted: trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_systick.h
===================================================================
--- trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_systick.h	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_systick.h	2009-07-08 23:39:34 UTC (rev 354)
@@ -1,64 +0,0 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_systick.h
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file contains all the functions prototypes for the
-*                      SysTick firmware library.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
-
-/* Define to prevent recursive inclusion -------------------------------------*/
-#ifndef __STM32F10x_SYSTICK_H
-#define __STM32F10x_SYSTICK_H
-
-/* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_map.h&quot;
-
-/* Exported types ------------------------------------------------------------*/
-/* Exported constants --------------------------------------------------------*/
-/* SysTick clock source */
-#define SysTick_CLKSource_HCLK_Div8    ((u32)0xFFFFFFFB)
-#define SysTick_CLKSource_HCLK         ((u32)0x00000004)
-
-#define IS_SYSTICK_CLK_SOURCE(SOURCE) (((SOURCE) == SysTick_CLKSource_HCLK) || \
-                                       ((SOURCE) == SysTick_CLKSource_HCLK_Div8))
-
-/* SysTick counter state */
-#define SysTick_Counter_Disable        ((u32)0xFFFFFFFE)
-#define SysTick_Counter_Enable         ((u32)0x00000001)
-#define SysTick_Counter_Clear          ((u32)0x00000000)
-
-#define IS_SYSTICK_COUNTER(COUNTER) (((COUNTER) == SysTick_Counter_Disable) || \
-                                     ((COUNTER) == SysTick_Counter_Enable)  || \
-                                     ((COUNTER) == SysTick_Counter_Clear))
-
-/* SysTick Flag */
-#define SysTick_FLAG_COUNT             ((u32)0x00000010)
-#define SysTick_FLAG_SKEW              ((u32)0x0000001E)
-#define SysTick_FLAG_NOREF             ((u32)0x0000001F)
-
-#define IS_SYSTICK_FLAG(FLAG) (((FLAG) == SysTick_FLAG_COUNT) || \
-                               ((FLAG) == SysTick_FLAG_SKEW)  || \
-                               ((FLAG) == SysTick_FLAG_NOREF))
-
-#define IS_SYSTICK_RELOAD(RELOAD) (((RELOAD) &gt; 0) &amp;&amp; ((RELOAD) &lt;= 0xFFFFFF))
-
-/* Exported macro ------------------------------------------------------------*/
-/* Exported functions ------------------------------------------------------- */
-void SysTick_CLKSourceConfig(u32 SysTick_CLKSource);
-void SysTick_SetReload(u32 Reload);
-void SysTick_CounterCmd(u32 SysTick_Counter);
-void SysTick_ITConfig(FunctionalState NewState);
-u32 SysTick_GetCounter(void);
-FlagStatus SysTick_GetFlagStatus(u8 SysTick_FLAG);
-
-#endif /* __STM32F10x_SYSTICK_H */
-
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/

Modified: trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_tim.h
===================================================================
--- trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_tim.h	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_tim.h	2009-07-08 23:39:34 UTC (rev 354)
@@ -1,109 +1,208 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_tim.h
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file contains all the functions prototypes for the 
-*                      TIM firmware library.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
+/**
+  ******************************************************************************
+  * @file    stm32f10x_tim.h
+  * @author  MCD Application Team
+  * @version V3.1.0
+  * @date    06/19/2009
+  * @brief   This file contains all the functions prototypes for the TIM firmware 
+  *          library.
+  ******************************************************************************
+  * @copy
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * &lt;h2&gt;&lt;center&gt;&copy; COPYRIGHT 2009 STMicroelectronics&lt;/center&gt;&lt;/h2&gt;
+  */ 
 
 /* Define to prevent recursive inclusion -------------------------------------*/
 #ifndef __STM32F10x_TIM_H
 #define __STM32F10x_TIM_H
 
+#ifdef __cplusplus
+ extern &quot;C&quot; {
+#endif
+
 /* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_map.h&quot;
+#include &quot;stm32f10x.h&quot;
 
-/* Exported types ------------------------------------------------------------*/
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
 
-/* TIM Time Base Init structure definition */
+/** @addtogroup TIM
+  * @{
+  */ 
+
+/** @defgroup TIM_Exported_Types
+  * @{
+  */ 
+
+/** 
+  * @brief  TIM Time Base Init structure definition
+  * @note   This sturcture is used with all TIMx except for TIM6 and TIM7.    
+  */
+
 typedef struct
 {
-  u16 TIM_Prescaler;
-  u16 TIM_CounterMode;
-  u16 TIM_Period;
-  u16 TIM_ClockDivision;
-  u8 TIM_RepetitionCounter;
-} TIM_TimeBaseInitTypeDef;
+  uint16_t TIM_Prescaler;         /*!&lt; Specifies the prescaler value used to divide the TIM clock.
+                                       This parameter can be a number between 0x0000 and 0xFFFF */
 
-/* TIM Output Compare Init structure definition */
+  uint16_t TIM_CounterMode;       /*!&lt; Specifies the counter mode.
+                                       This parameter can be a value of @ref TIM_Counter_Mode */
+
+  uint16_t TIM_Period;            /*!&lt; Specifies the period value to be loaded into the active
+                                       Auto-Reload Register at the next update event.
+                                       This parameter must be a number between 0x0000 and 0xFFFF.  */ 
+
+  uint16_t TIM_ClockDivision;     /*!&lt; Specifies the clock division.
+                                      This parameter can be a value of @ref TIM_Clock_Division_CKD */
+
+  uint8_t TIM_RepetitionCounter;  /*!&lt; Specifies the repetition counter value. Each time the RCR downcounter
+                                       reaches zero, an update event is generated and counting restarts
+                                       from the RCR value (N).
+                                       This means in PWM mode that (N+1) corresponds to:
+                                          - the number of PWM periods in edge-aligned mode
+                                          - the number of half PWM period in center-aligned mode
+                                       This parameter must be a number between 0x00 and 0xFF. 
+                                       @note This parameter is valid only for TIM1 and TIM8. */
+} TIM_TimeBaseInitTypeDef;       
+
+/** 
+  * @brief  TIM Output Compare Init structure definition  
+  */
+
 typedef struct
 {
-  u16 TIM_OCMode;
-  u16 TIM_OutputState;
-  u16 TIM_OutputNState;
-  u16 TIM_Pulse;
-  u16 TIM_OCPolarity;
-  u16 TIM_OCNPolarity;
-  u16 TIM_OCIdleState;
-  u16 TIM_OCNIdleState;
+  uint16_t TIM_OCMode;        /*!&lt; Specifies the TIM mode.
+                                   This parameter can be a value of @ref TIM_Output_Compare_and_PWM_modes */
+
+  uint16_t TIM_OutputState;   /*!&lt; Specifies the TIM Output Compare state.
+                                   This parameter can be a value of @ref TIM_Output_Compare_state */
+
+  uint16_t TIM_OutputNState;  /*!&lt; Specifies the TIM complementary Output Compare state.
+                                   This parameter can be a value of @ref TIM_Output_Compare_N_state
+                                   @note This parameter is valid only for TIM1 and TIM8. */
+
+  uint16_t TIM_Pulse;         /*!&lt; Specifies the pulse value to be loaded into the Capture Compare Register. 
+                                   This parameter can be a number between 0x0000 and 0xFFFF */
+
+  uint16_t TIM_OCPolarity;    /*!&lt; Specifies the output polarity.
+                                   This parameter can be a value of @ref TIM_Output_Compare_Polarity */
+
+  uint16_t TIM_OCNPolarity;   /*!&lt; Specifies the complementary output polarity.
+                                   This parameter can be a value of @ref TIM_Output_Compare_N_Polarity
+                                   @note This parameter is valid only for TIM1 and TIM8. */
+
+  uint16_t TIM_OCIdleState;   /*!&lt; Specifies the TIM Output Compare pin state during Idle state.
+                                   This parameter can be a value of @ref TIM_Output_Compare_Idle_State
+                                   @note This parameter is valid only for TIM1 and TIM8. */
+
+  uint16_t TIM_OCNIdleState;  /*!&lt; Specifies the TIM Output Compare pin state during Idle state.
+                                   This parameter can be a value of @ref TIM_Output_Compare_N_Idle_State
+                                   @note This parameter is valid only for TIM1 and TIM8. */
 } TIM_OCInitTypeDef;
 
-/* TIM Input Capture Init structure definition */
+/** 
+  * @brief  TIM Input Capture Init structure definition  
+  */
+
 typedef struct
 {
-  u16 TIM_Channel;
-  u16 TIM_ICPolarity;
-  u16 TIM_ICSelection;
-  u16 TIM_ICPrescaler;
-  u16 TIM_ICFilter;
+
+  uint16_t TIM_Channel;      /*!&lt; Specifies the TIM channel.
+                                  This parameter can be a value of @ref TIM_Channel */
+
+  uint16_t TIM_ICPolarity;   /*!&lt; Specifies the active edge of the input signal.
+                                  This parameter can be a value of @ref TIM_Input_Capture_Polarity */
+
+  uint16_t TIM_ICSelection;  /*!&lt; Specifies the input.
+                                  This parameter can be a value of @ref TIM_Input_Capture_Selection */
+
+  uint16_t TIM_ICPrescaler;  /*!&lt; Specifies the Input Capture Prescaler.
+                                  This parameter can be a value of @ref TIM_Input_Capture_Prescaler */
+
+  uint16_t TIM_ICFilter;     /*!&lt; Specifies the input capture filter.
+                                  This parameter can be a number between 0x0 and 0xF */
 } TIM_ICInitTypeDef;
 
-/* BDTR structure definition */
+/** 
+  * @brief  BDTR structure definition 
+  * @note   This sturcture is used only with TIM1 and TIM8.    
+  */
+
 typedef struct
 {
-  u16 TIM_OSSRState;
-  u16 TIM_OSSIState;
-  u16 TIM_LOCKLevel; 
-  u16 TIM_DeadTime;
-  u16 TIM_Break;
-  u16 TIM_BreakPolarity;
-  u16 TIM_AutomaticOutput;
+
+  uint16_t TIM_OSSRState;        /*!&lt; Specifies the Off-State selection used in Run mode.
+                                      This parameter can be a value of @ref OSSR_Off_State_Selection_for_Run_mode_state */
+
+  uint16_t TIM_OSSIState;        /*!&lt; Specifies the Off-State used in Idle state.
+                                      This parameter can be a value of @ref OSSI_Off_State_Selection_for_Idle_mode_state */
+
+  uint16_t TIM_LOCKLevel;        /*!&lt; Specifies the LOCK level parameters.
+                                      This parameter can be a value of @ref Lock_level */ 
+
+  uint16_t TIM_DeadTime;         /*!&lt; Specifies the delay time between the switching-off and the
+                                      switching-on of the outputs.
+                                      This parameter can be a number between 0x00 and 0xFF  */
+
+  uint16_t TIM_Break;            /*!&lt; Specifies whether the TIM Break input is enabled or not. 
+                                      This parameter can be a value of @ref Break_Input_enable_disable */
+
+  uint16_t TIM_BreakPolarity;    /*!&lt; Specifies the TIM Break Input pin polarity.
+                                      This parameter can be a value of @ref Break_Polarity */
+
+  uint16_t TIM_AutomaticOutput;  /*!&lt; Specifies whether the TIM Automatic Output feature is enabled or not. 
+                                      This parameter can be a value of @ref TIM_AOE_Bit_Set_Reset */
 } TIM_BDTRInitTypeDef;
 
-/* Exported constants --------------------------------------------------------*/                             
+/** @defgroup TIM_Exported_constants 
+  * @{
+  */
 
-#define IS_TIM_ALL_PERIPH(PERIPH) (((*(u32*)&amp;(PERIPH)) == TIM1_BASE) || \
-                                   ((*(u32*)&amp;(PERIPH)) == TIM2_BASE) || \
-                                   ((*(u32*)&amp;(PERIPH)) == TIM3_BASE) || \
-                                   ((*(u32*)&amp;(PERIPH)) == TIM4_BASE) || \
-                                   ((*(u32*)&amp;(PERIPH)) == TIM5_BASE) || \
-                                   ((*(u32*)&amp;(PERIPH)) == TIM6_BASE) || \
-                                   ((*(u32*)&amp;(PERIPH)) == TIM7_BASE) || \
-                                   ((*(u32*)&amp;(PERIPH)) == TIM8_BASE))
+#define IS_TIM_ALL_PERIPH(PERIPH) (((PERIPH) == TIM1) || \
+                                   ((PERIPH) == TIM2) || \
+                                   ((PERIPH) == TIM3) || \
+                                   ((PERIPH) == TIM4) || \
+                                   ((PERIPH) == TIM5) || \
+                                   ((PERIPH) == TIM6) || \
+                                   ((PERIPH) == TIM7) || \
+                                   ((PERIPH) == TIM8))
 
-#define IS_TIM_18_PERIPH(PERIPH) (((*(u32*)&amp;(PERIPH)) == TIM1_BASE) || \
-                                  ((*(u32*)&amp;(PERIPH)) == TIM8_BASE))
+#define IS_TIM_18_PERIPH(PERIPH) (((PERIPH) == TIM1) || \
+                                  ((PERIPH) == TIM8))
 
-#define IS_TIM_123458_PERIPH(PERIPH) (((*(u32*)&amp;(PERIPH)) == TIM1_BASE) || \
-                                      ((*(u32*)&amp;(PERIPH)) == TIM2_BASE) || \
-                                      ((*(u32*)&amp;(PERIPH)) == TIM3_BASE) || \
-                                      ((*(u32*)&amp;(PERIPH)) == TIM4_BASE) || \
-                                      ((*(u32*)&amp;(PERIPH)) == TIM5_BASE) || \
-                                      ((*(u32*)&amp;(PERIPH)) == TIM8_BASE))
+#define IS_TIM_123458_PERIPH(PERIPH) (((PERIPH) == TIM1) || \
+                                      ((PERIPH) == TIM2) || \
+                                      ((PERIPH) == TIM3) || \
+                                      ((PERIPH) == TIM4) || \
+                                      ((PERIPH) == TIM5) || \
+                                      ((PERIPH) == TIM8))
+/**
+  * @}
+  */ 
 
-/* TIM Output Compare and PWM modes -----------------------------------------*/
-#define TIM_OCMode_Timing                  ((u16)0x0000)
-#define TIM_OCMode_Active                  ((u16)0x0010)
-#define TIM_OCMode_Inactive                ((u16)0x0020)
-#define TIM_OCMode_Toggle                  ((u16)0x0030)
-#define TIM_OCMode_PWM1                    ((u16)0x0060)
-#define TIM_OCMode_PWM2                    ((u16)0x0070)
+/** @defgroup TIM_Output_Compare_and_PWM_modes 
+  * @{
+  */
 
+#define TIM_OCMode_Timing                  ((uint16_t)0x0000)
+#define TIM_OCMode_Active                  ((uint16_t)0x0010)
+#define TIM_OCMode_Inactive                ((uint16_t)0x0020)
+#define TIM_OCMode_Toggle                  ((uint16_t)0x0030)
+#define TIM_OCMode_PWM1                    ((uint16_t)0x0060)
+#define TIM_OCMode_PWM2                    ((uint16_t)0x0070)
 #define IS_TIM_OC_MODE(MODE) (((MODE) == TIM_OCMode_Timing) || \
                               ((MODE) == TIM_OCMode_Active) || \
                               ((MODE) == TIM_OCMode_Inactive) || \
                               ((MODE) == TIM_OCMode_Toggle)|| \
                               ((MODE) == TIM_OCMode_PWM1) || \
                               ((MODE) == TIM_OCMode_PWM2))
-
 #define IS_TIM_OCM(MODE) (((MODE) == TIM_OCMode_Timing) || \
                           ((MODE) == TIM_OCMode_Active) || \
                           ((MODE) == TIM_OCMode_Inactive) || \
@@ -112,200 +211,305 @@
                           ((MODE) == TIM_OCMode_PWM2) ||	\
                           ((MODE) == TIM_ForcedAction_Active) || \
                           ((MODE) == TIM_ForcedAction_InActive))
-/* TIM One Pulse Mode -------------------------------------------------------*/
-#define TIM_OPMode_Single                  ((u16)0x0008)
-#define TIM_OPMode_Repetitive              ((u16)0x0000)
+/**
+  * @}
+  */
 
+/** @defgroup TIM_One_Pulse_Mode 
+  * @{
+  */
+
+#define TIM_OPMode_Single                  ((uint16_t)0x0008)
+#define TIM_OPMode_Repetitive              ((uint16_t)0x0000)
 #define IS_TIM_OPM_MODE(MODE) (((MODE) == TIM_OPMode_Single) || \
                                ((MODE) == TIM_OPMode_Repetitive))
+/**
+  * @}
+  */ 
 
-/* TIM Channel -------------------------------------------------------------*/
-#define TIM_Channel_1                      ((u16)0x0000)
-#define TIM_Channel_2                      ((u16)0x0004)
-#define TIM_Channel_3                      ((u16)0x0008)
-#define TIM_Channel_4                      ((u16)0x000C)
+/** @defgroup TIM_Channel 
+  * @{
+  */
 
+#define TIM_Channel_1                      ((uint16_t)0x0000)
+#define TIM_Channel_2                      ((uint16_t)0x0004)
+#define TIM_Channel_3                      ((uint16_t)0x0008)
+#define TIM_Channel_4                      ((uint16_t)0x000C)
 #define IS_TIM_CHANNEL(CHANNEL) (((CHANNEL) == TIM_Channel_1) || \
                                  ((CHANNEL) == TIM_Channel_2) || \
                                  ((CHANNEL) == TIM_Channel_3) || \
                                  ((CHANNEL) == TIM_Channel_4))
-
 #define IS_TIM_PWMI_CHANNEL(CHANNEL) (((CHANNEL) == TIM_Channel_1) || \
                                       ((CHANNEL) == TIM_Channel_2))
-
 #define IS_TIM_COMPLEMENTARY_CHANNEL(CHANNEL) (((CHANNEL) == TIM_Channel_1) || \
                                                ((CHANNEL) == TIM_Channel_2) || \
                                                ((CHANNEL) == TIM_Channel_3))
-/* TIM Clock Division CKD --------------------------------------------------*/
-#define TIM_CKD_DIV1                       ((u16)0x0000)
-#define TIM_CKD_DIV2                       ((u16)0x0100)
-#define TIM_CKD_DIV4                       ((u16)0x0200)
+/**
+  * @}
+  */ 
 
+/** @defgroup TIM_Clock_Division_CKD 
+  * @{
+  */
+
+#define TIM_CKD_DIV1                       ((uint16_t)0x0000)
+#define TIM_CKD_DIV2                       ((uint16_t)0x0100)
+#define TIM_CKD_DIV4                       ((uint16_t)0x0200)
 #define IS_TIM_CKD_DIV(DIV) (((DIV) == TIM_CKD_DIV1) || \
                              ((DIV) == TIM_CKD_DIV2) || \
                              ((DIV) == TIM_CKD_DIV4))
+/**
+  * @}
+  */
 
-/* TIM Counter Mode --------------------------------------------------------*/
-#define TIM_CounterMode_Up                 ((u16)0x0000)
-#define TIM_CounterMode_Down               ((u16)0x0010)
-#define TIM_CounterMode_CenterAligned1     ((u16)0x0020)
-#define TIM_CounterMode_CenterAligned2     ((u16)0x0040)
-#define TIM_CounterMode_CenterAligned3     ((u16)0x0060)
+/** @defgroup TIM_Counter_Mode 
+  * @{
+  */
 
+#define TIM_CounterMode_Up                 ((uint16_t)0x0000)
+#define TIM_CounterMode_Down               ((uint16_t)0x0010)
+#define TIM_CounterMode_CenterAligned1     ((uint16_t)0x0020)
+#define TIM_CounterMode_CenterAligned2     ((uint16_t)0x0040)
+#define TIM_CounterMode_CenterAligned3     ((uint16_t)0x0060)
 #define IS_TIM_COUNTER_MODE(MODE) (((MODE) == TIM_CounterMode_Up) ||  \
                                    ((MODE) == TIM_CounterMode_Down) || \
                                    ((MODE) == TIM_CounterMode_CenterAligned1) || \
                                    ((MODE) == TIM_CounterMode_CenterAligned2) || \
                                    ((MODE) == TIM_CounterMode_CenterAligned3))
+/**
+  * @}
+  */ 
 
-/* TIM Output Compare Polarity ---------------------------------------------*/
-#define TIM_OCPolarity_High                ((u16)0x0000)
-#define TIM_OCPolarity_Low                 ((u16)0x0002)
+/** @defgroup TIM_Output_Compare_Polarity 
+  * @{
+  */
 
+#define TIM_OCPolarity_High                ((uint16_t)0x0000)
+#define TIM_OCPolarity_Low                 ((uint16_t)0x0002)
 #define IS_TIM_OC_POLARITY(POLARITY) (((POLARITY) == TIM_OCPolarity_High) || \
                                       ((POLARITY) == TIM_OCPolarity_Low))
+/**
+  * @}
+  */
 
-/* TIM Output Compare N Polarity -------------------------------------------*/
-#define TIM_OCNPolarity_High               ((u16)0x0000)
-#define TIM_OCNPolarity_Low                ((u16)0x0008)
-
+/** @defgroup TIM_Output_Compare_N_Polarity 
+  * @{
+  */
+  
+#define TIM_OCNPolarity_High               ((uint16_t)0x0000)
+#define TIM_OCNPolarity_Low                ((uint16_t)0x0008)
 #define IS_TIM_OCN_POLARITY(POLARITY) (((POLARITY) == TIM_OCNPolarity_High) || \
                                        ((POLARITY) == TIM_OCNPolarity_Low))
+/**
+  * @}
+  */
 
-/* TIM Output Compare states -----------------------------------------------*/
-#define TIM_OutputState_Disable            ((u16)0x0000)
-#define TIM_OutputState_Enable             ((u16)0x0001)
+/** @defgroup TIM_Output_Compare_state 
+  * @{
+  */
 
+#define TIM_OutputState_Disable            ((uint16_t)0x0000)
+#define TIM_OutputState_Enable             ((uint16_t)0x0001)
 #define IS_TIM_OUTPUT_STATE(STATE) (((STATE) == TIM_OutputState_Disable) || \
                                     ((STATE) == TIM_OutputState_Enable))
+/**
+  * @}
+  */ 
 
-/* TIM Output Compare N States ---------------------------------------------*/
-#define TIM_OutputNState_Disable           ((u16)0x0000)
-#define TIM_OutputNState_Enable            ((u16)0x0004)
+/** @defgroup TIM_Output_Compare_N_state 
+  * @{
+  */
 
+#define TIM_OutputNState_Disable           ((uint16_t)0x0000)
+#define TIM_OutputNState_Enable            ((uint16_t)0x0004)
 #define IS_TIM_OUTPUTN_STATE(STATE) (((STATE) == TIM_OutputNState_Disable) || \
                                      ((STATE) == TIM_OutputNState_Enable))
+/**
+  * @}
+  */ 
 
-/* TIM Capture Compare States -----------------------------------------------*/
-#define TIM_CCx_Enable                      ((u16)0x0001)
-#define TIM_CCx_Disable                     ((u16)0x0000)
+/** @defgroup TIM_Capture_Compare_state 
+  * @{
+  */
 
+#define TIM_CCx_Enable                      ((uint16_t)0x0001)
+#define TIM_CCx_Disable                     ((uint16_t)0x0000)
 #define IS_TIM_CCX(CCX) (((CCX) == TIM_CCx_Enable) || \
                          ((CCX) == TIM_CCx_Disable))
+/**
+  * @}
+  */ 
 
-/* TIM Capture Compare N States --------------------------------------------*/
-#define TIM_CCxN_Enable                     ((u16)0x0004)
-#define TIM_CCxN_Disable                    ((u16)0x0000)                                     
+/** @defgroup TIM_Capture_Compare_N_state 
+  * @{
+  */
 
+#define TIM_CCxN_Enable                     ((uint16_t)0x0004)
+#define TIM_CCxN_Disable                    ((uint16_t)0x0000)
 #define IS_TIM_CCXN(CCXN) (((CCXN) == TIM_CCxN_Enable) || \
                            ((CCXN) == TIM_CCxN_Disable))
+/**
+  * @}
+  */ 
 
-/* Break Input enable/disable -----------------------------------------------*/
-#define TIM_Break_Enable                   ((u16)0x1000)
-#define TIM_Break_Disable                  ((u16)0x0000)
+/** @defgroup Break_Input_enable_disable 
+  * @{
+  */
 
+#define TIM_Break_Enable                   ((uint16_t)0x1000)
+#define TIM_Break_Disable                  ((uint16_t)0x0000)
 #define IS_TIM_BREAK_STATE(STATE) (((STATE) == TIM_Break_Enable) || \
                                    ((STATE) == TIM_Break_Disable))
+/**
+  * @}
+  */ 
 
-/* Break Polarity -----------------------------------------------------------*/
-#define TIM_BreakPolarity_Low              ((u16)0x0000)
-#define TIM_BreakPolarity_High             ((u16)0x2000)
+/** @defgroup Break_Polarity 
+  * @{
+  */
 
+#define TIM_BreakPolarity_Low              ((uint16_t)0x0000)
+#define TIM_BreakPolarity_High             ((uint16_t)0x2000)
 #define IS_TIM_BREAK_POLARITY(POLARITY) (((POLARITY) == TIM_BreakPolarity_Low) || \
                                          ((POLARITY) == TIM_BreakPolarity_High))
+/**
+  * @}
+  */ 
 
-/* TIM AOE Bit Set/Reset ---------------------------------------------------*/
-#define TIM_AutomaticOutput_Enable         ((u16)0x4000)
-#define TIM_AutomaticOutput_Disable        ((u16)0x0000)
+/** @defgroup TIM_AOE_Bit_Set_Reset 
+  * @{
+  */
 
+#define TIM_AutomaticOutput_Enable         ((uint16_t)0x4000)
+#define TIM_AutomaticOutput_Disable        ((uint16_t)0x0000)
 #define IS_TIM_AUTOMATIC_OUTPUT_STATE(STATE) (((STATE) == TIM_AutomaticOutput_Enable) || \
                                               ((STATE) == TIM_AutomaticOutput_Disable))
-/* Lock levels --------------------------------------------------------------*/
-#define TIM_LOCKLevel_OFF                  ((u16)0x0000)
-#define TIM_LOCKLevel_1                    ((u16)0x0100)
-#define TIM_LOCKLevel_2                    ((u16)0x0200)
-#define TIM_LOCKLevel_3                    ((u16)0x0300)
+/**
+  * @}
+  */ 
 
+/** @defgroup Lock_level 
+  * @{
+  */
+
+#define TIM_LOCKLevel_OFF                  ((uint16_t)0x0000)
+#define TIM_LOCKLevel_1                    ((uint16_t)0x0100)
+#define TIM_LOCKLevel_2                    ((uint16_t)0x0200)
+#define TIM_LOCKLevel_3                    ((uint16_t)0x0300)
 #define IS_TIM_LOCK_LEVEL(LEVEL) (((LEVEL) == TIM_LOCKLevel_OFF) || \
                                   ((LEVEL) == TIM_LOCKLevel_1) || \
                                   ((LEVEL) == TIM_LOCKLevel_2) || \
                                   ((LEVEL) == TIM_LOCKLevel_3))
+/**
+  * @}
+  */ 
 
-/* OSSI: Off-State Selection for Idle mode states ---------------------------*/
-#define TIM_OSSIState_Enable               ((u16)0x0400)
-#define TIM_OSSIState_Disable              ((u16)0x0000)
+/** @defgroup OSSI_Off_State_Selection_for_Idle_mode_state 
+  * @{
+  */
 
+#define TIM_OSSIState_Enable               ((uint16_t)0x0400)
+#define TIM_OSSIState_Disable              ((uint16_t)0x0000)
 #define IS_TIM_OSSI_STATE(STATE) (((STATE) == TIM_OSSIState_Enable) || \
                                   ((STATE) == TIM_OSSIState_Disable))
+/**
+  * @}
+  */
 
-/* OSSR: Off-State Selection for Run mode states ----------------------------*/
-#define TIM_OSSRState_Enable               ((u16)0x0800)
-#define TIM_OSSRState_Disable              ((u16)0x0000)
+/** @defgroup OSSR_Off_State_Selection_for_Run_mode_state 
+  * @{
+  */
 
+#define TIM_OSSRState_Enable               ((uint16_t)0x0800)
+#define TIM_OSSRState_Disable              ((uint16_t)0x0000)
 #define IS_TIM_OSSR_STATE(STATE) (((STATE) == TIM_OSSRState_Enable) || \
                                   ((STATE) == TIM_OSSRState_Disable))
+/**
+  * @}
+  */ 
 
-/* TIM Output Compare Idle State -------------------------------------------*/
-#define TIM_OCIdleState_Set                ((u16)0x0100)
-#define TIM_OCIdleState_Reset              ((u16)0x0000)
+/** @defgroup TIM_Output_Compare_Idle_State 
+  * @{
+  */
 
+#define TIM_OCIdleState_Set                ((uint16_t)0x0100)
+#define TIM_OCIdleState_Reset              ((uint16_t)0x0000)
 #define IS_TIM_OCIDLE_STATE(STATE) (((STATE) == TIM_OCIdleState_Set) || \
                                     ((STATE) == TIM_OCIdleState_Reset))
+/**
+  * @}
+  */ 
 
-/* TIM Output Compare N Idle State -----------------------------------------*/
-#define TIM_OCNIdleState_Set               ((u16)0x0200)
-#define TIM_OCNIdleState_Reset             ((u16)0x0000)
+/** @defgroup TIM_Output_Compare_N_Idle_State 
+  * @{
+  */
 
+#define TIM_OCNIdleState_Set               ((uint16_t)0x0200)
+#define TIM_OCNIdleState_Reset             ((uint16_t)0x0000)
 #define IS_TIM_OCNIDLE_STATE(STATE) (((STATE) == TIM_OCNIdleState_Set) || \
                                      ((STATE) == TIM_OCNIdleState_Reset))
+/**
+  * @}
+  */ 
 
-/* TIM Input Capture Polarity ----------------------------------------------*/
-#define  TIM_ICPolarity_Rising             ((u16)0x0000)
-#define  TIM_ICPolarity_Falling            ((u16)0x0002)
+/** @defgroup TIM_Input_Capture_Polarity 
+  * @{
+  */
 
+#define  TIM_ICPolarity_Rising             ((uint16_t)0x0000)
+#define  TIM_ICPolarity_Falling            ((uint16_t)0x0002)
 #define IS_TIM_IC_POLARITY(POLARITY) (((POLARITY) == TIM_ICPolarity_Rising) || \
                                       ((POLARITY) == TIM_ICPolarity_Falling))
+/**
+  * @}
+  */ 
 
-/* TIM Input Capture Selection ---------------------------------------------*/
-#define TIM_ICSelection_DirectTI           ((u16)0x0001)
-#define TIM_ICSelection_IndirectTI         ((u16)0x0002)
-#define TIM_ICSelection_TRC                ((u16)0x0003)
+/** @defgroup TIM_Input_Capture_Selection 
+  * @{
+  */
 
+#define TIM_ICSelection_DirectTI           ((uint16_t)0x0001) /*!&lt; TIM Input 1, 2, 3 or 4 is selected to be 
+                                                                   connected to IC1, IC2, IC3 or IC4, respectively */
+#define TIM_ICSelection_IndirectTI         ((uint16_t)0x0002) /*!&lt; TIM Input 1, 2, 3 or 4 is selected to be
+                                                                   connected to IC2, IC1, IC4 or IC3, respectively. */
+#define TIM_ICSelection_TRC                ((uint16_t)0x0003) /*!&lt; TIM Input 1, 2, 3 or 4 is selected to be connected to TRC. */
 #define IS_TIM_IC_SELECTION(SELECTION) (((SELECTION) == TIM_ICSelection_DirectTI) || \
                                         ((SELECTION) == TIM_ICSelection_IndirectTI) || \
                                         ((SELECTION) == TIM_ICSelection_TRC))
+/**
+  * @}
+  */ 
 
-/* TIM Input Capture Prescaler ---------------------------------------------*/
-#define TIM_ICPSC_DIV1                     ((u16)0x0000)
-#define TIM_ICPSC_DIV2                     ((u16)0x0004)
-#define TIM_ICPSC_DIV4                     ((u16)0x0008)
-#define TIM_ICPSC_DIV8                     ((u16)0x000C)
+/** @defgroup TIM_Input_Capture_Prescaler 
+  * @{
+  */
 
+#define TIM_ICPSC_DIV1                     ((uint16_t)0x0000) /*!&lt; Capture performed each time an edge is detected on the capture input. */
+#define TIM_ICPSC_DIV2                     ((uint16_t)0x0004) /*!&lt; Capture performed once every 2 events. */
+#define TIM_ICPSC_DIV4                     ((uint16_t)0x0008) /*!&lt; Capture performed once every 4 events. */
+#define TIM_ICPSC_DIV8                     ((uint16_t)0x000C) /*!&lt; Capture performed once every 8 events. */
 #define IS_TIM_IC_PRESCALER(PRESCALER) (((PRESCALER) == TIM_ICPSC_DIV1) || \
                                         ((PRESCALER) == TIM_ICPSC_DIV2) || \
                                         ((PRESCALER) == TIM_ICPSC_DIV4) || \
-                                        ((PRESCALER) == TIM_ICPSC_DIV8))                                          
+                                        ((PRESCALER) == TIM_ICPSC_DIV8))
+/**
+  * @}
+  */ 
 
-/* TIM interrupt sources ---------------------------------------------------*/
-#define TIM_IT_Update                      ((u16)0x0001)
-#define TIM_IT_CC1                         ((u16)0x0002)
-#define TIM_IT_CC2                         ((u16)0x0004)
-#define TIM_IT_CC3                         ((u16)0x0008)
-#define TIM_IT_CC4                         ((u16)0x0010)
-#define TIM_IT_COM                         ((u16)0x0020)
-#define TIM_IT_Trigger                     ((u16)0x0040)
-#define TIM_IT_Break                       ((u16)0x0080)
+/** @defgroup TIM_interrupt_sources 
+  * @{
+  */
 
-#define IS_TIM_IT(IT) ((((IT) &amp; (u16)0xFF00) == 0x0000) &amp;&amp; ((IT) != 0x0000))
+#define TIM_IT_Update                      ((uint16_t)0x0001)
+#define TIM_IT_CC1                         ((uint16_t)0x0002)
+#define TIM_IT_CC2                         ((uint16_t)0x0004)
+#define TIM_IT_CC3                         ((uint16_t)0x0008)
+#define TIM_IT_CC4                         ((uint16_t)0x0010)
+#define TIM_IT_COM                         ((uint16_t)0x0020)
+#define TIM_IT_Trigger                     ((uint16_t)0x0040)
+#define TIM_IT_Break                       ((uint16_t)0x0080)
+#define IS_TIM_IT(IT) ((((IT) &amp; (uint16_t)0xFF00) == 0x0000) &amp;&amp; ((IT) != 0x0000))
 
-#define IS_TIM_PERIPH_IT(PERIPH, TIM_IT) ((((((*(u32*)&amp;(PERIPH)) == TIM2_BASE) || (((*(u32*)&amp;(PERIPH)) == TIM3_BASE))||\
-                                            (((*(u32*)&amp;(PERIPH)) == TIM4_BASE)) || (((*(u32*)&amp;(PERIPH)) == TIM5_BASE))))&amp;&amp; \
-                                            (((TIM_IT) &amp; (u16)0xFFA0) == 0x0000) &amp;&amp; ((TIM_IT) != 0x0000)) ||\
-                                            (((((*(u32*)&amp;(PERIPH)) == TIM1_BASE) || (((*(u32*)&amp;(PERIPH)) == TIM8_BASE))))&amp;&amp; \
-                                            (((TIM_IT) &amp; (u16)0xFF00) == 0x0000) &amp;&amp; ((TIM_IT) != 0x0000)) ||\
-                                            (((((*(u32*)&amp;(PERIPH)) == TIM6_BASE) || (((*(u32*)&amp;(PERIPH)) == TIM7_BASE))))&amp;&amp; \
-                                            (((TIM_IT) &amp; (u16)0xFFFE) == 0x0000) &amp;&amp; ((TIM_IT) != 0x0000)))
-
 #define IS_TIM_GET_IT(IT) (((IT) == TIM_IT_Update) || \
                            ((IT) == TIM_IT_CC1) || \
                            ((IT) == TIM_IT_CC2) || \
@@ -314,28 +518,33 @@
                            ((IT) == TIM_IT_COM) || \
                            ((IT) == TIM_IT_Trigger) || \
                            ((IT) == TIM_IT_Break))
+/**
+  * @}
+  */ 
 
-/* TIM DMA Base address ----------------------------------------------------*/
-#define TIM_DMABase_CR1                    ((u16)0x0000)
-#define TIM_DMABase_CR2                    ((u16)0x0001)
-#define TIM_DMABase_SMCR                   ((u16)0x0002)
-#define TIM_DMABase_DIER                   ((u16)0x0003)
-#define TIM_DMABase_SR                     ((u16)0x0004)
-#define TIM_DMABase_EGR                    ((u16)0x0005)
-#define TIM_DMABase_CCMR1                  ((u16)0x0006)
-#define TIM_DMABase_CCMR2                  ((u16)0x0007)
-#define TIM_DMABase_CCER                   ((u16)0x0008)
-#define TIM_DMABase_CNT                    ((u16)0x0009)
-#define TIM_DMABase_PSC                    ((u16)0x000A)
-#define TIM_DMABase_ARR                    ((u16)0x000B)
-#define TIM_DMABase_RCR                    ((u16)0x000C)
-#define TIM_DMABase_CCR1                   ((u16)0x000D)
-#define TIM_DMABase_CCR2                   ((u16)0x000E)
-#define TIM_DMABase_CCR3                   ((u16)0x000F)
-#define TIM_DMABase_CCR4                   ((u16)0x0010)
-#define TIM_DMABase_BDTR                   ((u16)0x0011)
-#define TIM_DMABase_DCR                    ((u16)0x0012)
+/** @defgroup TIM_DMA_Base_address 
+  * @{
+  */
 
+#define TIM_DMABase_CR1                    ((uint16_t)0x0000)
+#define TIM_DMABase_CR2                    ((uint16_t)0x0001)
+#define TIM_DMABase_SMCR                   ((uint16_t)0x0002)
+#define TIM_DMABase_DIER                   ((uint16_t)0x0003)
+#define TIM_DMABase_SR                     ((uint16_t)0x0004)
+#define TIM_DMABase_EGR                    ((uint16_t)0x0005)
+#define TIM_DMABase_CCMR1                  ((uint16_t)0x0006)
+#define TIM_DMABase_CCMR2                  ((uint16_t)0x0007)
+#define TIM_DMABase_CCER                   ((uint16_t)0x0008)
+#define TIM_DMABase_CNT                    ((uint16_t)0x0009)
+#define TIM_DMABase_PSC                    ((uint16_t)0x000A)
+#define TIM_DMABase_ARR                    ((uint16_t)0x000B)
+#define TIM_DMABase_RCR                    ((uint16_t)0x000C)
+#define TIM_DMABase_CCR1                   ((uint16_t)0x000D)
+#define TIM_DMABase_CCR2                   ((uint16_t)0x000E)
+#define TIM_DMABase_CCR3                   ((uint16_t)0x000F)
+#define TIM_DMABase_CCR4                   ((uint16_t)0x0010)
+#define TIM_DMABase_BDTR                   ((uint16_t)0x0011)
+#define TIM_DMABase_DCR                    ((uint16_t)0x0012)
 #define IS_TIM_DMA_BASE(BASE) (((BASE) == TIM_DMABase_CR1) || \
                                ((BASE) == TIM_DMABase_CR2) || \
                                ((BASE) == TIM_DMABase_SMCR) || \
@@ -355,27 +564,32 @@
                                ((BASE) == TIM_DMABase_CCR4) || \
                                ((BASE) == TIM_DMABase_BDTR) || \
                                ((BASE) == TIM_DMABase_DCR))
+/**
+  * @}
+  */ 
 
-/* TIM DMA Burst Length ----------------------------------------------------*/
-#define TIM_DMABurstLength_1Byte           ((u16)0x0000)
-#define TIM_DMABurstLength_2Bytes          ((u16)0x0100)
-#define TIM_DMABurstLength_3Bytes          ((u16)0x0200)
-#define TIM_DMABurstLength_4Bytes          ((u16)0x0300)
-#define TIM_DMABurstLength_5Bytes          ((u16)0x0400)
-#define TIM_DMABurstLength_6Bytes          ((u16)0x0500)
-#define TIM_DMABurstLength_7Bytes          ((u16)0x0600)
-#define TIM_DMABurstLength_8Bytes          ((u16)0x0700)
-#define TIM_DMABurstLength_9Bytes          ((u16)0x0800)
-#define TIM_DMABurstLength_10Bytes         ((u16)0x0900)
-#define TIM_DMABurstLength_11Bytes         ((u16)0x0A00)
-#define TIM_DMABurstLength_12Bytes         ((u16)0x0B00)
-#define TIM_DMABurstLength_13Bytes         ((u16)0x0C00)
-#define TIM_DMABurstLength_14Bytes         ((u16)0x0D00)
-#define TIM_DMABurstLength_15Bytes         ((u16)0x0E00)
-#define TIM_DMABurstLength_16Bytes         ((u16)0x0F00)
-#define TIM_DMABurstLength_17Bytes         ((u16)0x1000)
-#define TIM_DMABurstLength_18Bytes         ((u16)0x1100)
+/** @defgroup TIM_DMA_Burst_Length 
+  * @{
+  */
 
+#define TIM_DMABurstLength_1Byte           ((uint16_t)0x0000)
+#define TIM_DMABurstLength_2Bytes          ((uint16_t)0x0100)
+#define TIM_DMABurstLength_3Bytes          ((uint16_t)0x0200)
+#define TIM_DMABurstLength_4Bytes          ((uint16_t)0x0300)
+#define TIM_DMABurstLength_5Bytes          ((uint16_t)0x0400)
+#define TIM_DMABurstLength_6Bytes          ((uint16_t)0x0500)
+#define TIM_DMABurstLength_7Bytes          ((uint16_t)0x0600)
+#define TIM_DMABurstLength_8Bytes          ((uint16_t)0x0700)
+#define TIM_DMABurstLength_9Bytes          ((uint16_t)0x0800)
+#define TIM_DMABurstLength_10Bytes         ((uint16_t)0x0900)
+#define TIM_DMABurstLength_11Bytes         ((uint16_t)0x0A00)
+#define TIM_DMABurstLength_12Bytes         ((uint16_t)0x0B00)
+#define TIM_DMABurstLength_13Bytes         ((uint16_t)0x0C00)
+#define TIM_DMABurstLength_14Bytes         ((uint16_t)0x0D00)
+#define TIM_DMABurstLength_15Bytes         ((uint16_t)0x0E00)
+#define TIM_DMABurstLength_16Bytes         ((uint16_t)0x0F00)
+#define TIM_DMABurstLength_17Bytes         ((uint16_t)0x1000)
+#define TIM_DMABurstLength_18Bytes         ((uint16_t)0x1100)
 #define IS_TIM_DMA_LENGTH(LENGTH) (((LENGTH) == TIM_DMABurstLength_1Byte) || \
                                    ((LENGTH) == TIM_DMABurstLength_2Bytes) || \
                                    ((LENGTH) == TIM_DMABurstLength_3Bytes) || \
@@ -394,47 +608,55 @@
                                    ((LENGTH) == TIM_DMABurstLength_16Bytes) || \
                                    ((LENGTH) == TIM_DMABurstLength_17Bytes) || \
                                    ((LENGTH) == TIM_DMABurstLength_18Bytes))
+/**
+  * @}
+  */ 
 
-/* TIM DMA sources ---------------------------------------------------------*/
-#define TIM_DMA_Update                     ((u16)0x0100)
-#define TIM_DMA_CC1                        ((u16)0x0200)
-#define TIM_DMA_CC2                        ((u16)0x0400)
-#define TIM_DMA_CC3                        ((u16)0x0800)
-#define TIM_DMA_CC4                        ((u16)0x1000)
-#define TIM_DMA_COM                        ((u16)0x2000)
-#define TIM_DMA_Trigger                    ((u16)0x4000)
+/** @defgroup TIM_DMA_sources 
+  * @{
+  */
 
-#define IS_TIM_DMA_SOURCE(SOURCE) ((((SOURCE) &amp; (u16)0x80FF) == 0x0000) &amp;&amp; ((SOURCE) != 0x0000))
+#define TIM_DMA_Update                     ((uint16_t)0x0100)
+#define TIM_DMA_CC1                        ((uint16_t)0x0200)
+#define TIM_DMA_CC2                        ((uint16_t)0x0400)
+#define TIM_DMA_CC3                        ((uint16_t)0x0800)
+#define TIM_DMA_CC4                        ((uint16_t)0x1000)
+#define TIM_DMA_COM                        ((uint16_t)0x2000)
+#define TIM_DMA_Trigger                    ((uint16_t)0x4000)
+#define IS_TIM_DMA_SOURCE(SOURCE) ((((SOURCE) &amp; (uint16_t)0x80FF) == 0x0000) &amp;&amp; ((SOURCE) != 0x0000))
 
-#define IS_TIM_PERIPH_DMA(PERIPH, SOURCE) ((((((*(u32*)&amp;(PERIPH)) == TIM2_BASE) || (((*(u32*)&amp;(PERIPH)) == TIM3_BASE))||\
-                                            (((*(u32*)&amp;(PERIPH)) == TIM4_BASE)) || (((*(u32*)&amp;(PERIPH)) == TIM5_BASE))))&amp;&amp; \
-                                            (((SOURCE) &amp; (u16)0xA0FF) == 0x0000) &amp;&amp; ((SOURCE) != 0x0000)) ||\
-                                            (((((*(u32*)&amp;(PERIPH)) == TIM1_BASE) || (((*(u32*)&amp;(PERIPH)) == TIM8_BASE))))&amp;&amp; \
-                                            (((SOURCE) &amp; (u16)0x80FF) == 0x0000) &amp;&amp; ((SOURCE) != 0x0000)) ||\
-                                            (((((*(u32*)&amp;(PERIPH)) == TIM6_BASE) || (((*(u32*)&amp;(PERIPH)) == TIM7_BASE))))&amp;&amp; \
-                                            (((SOURCE) &amp; (u16)0xFEFF) == 0x0000) &amp;&amp; ((SOURCE) != 0x0000)))
+/**
+  * @}
+  */ 
 
-/* TIM External Trigger Prescaler ------------------------------------------*/
-#define TIM_ExtTRGPSC_OFF                  ((u16)0x0000)
-#define TIM_ExtTRGPSC_DIV2                 ((u16)0x1000)
-#define TIM_ExtTRGPSC_DIV4                 ((u16)0x2000)
-#define TIM_ExtTRGPSC_DIV8                 ((u16)0x3000)
+/** @defgroup TIM_External_Trigger_Prescaler 
+  * @{
+  */
 
+#define TIM_ExtTRGPSC_OFF                  ((uint16_t)0x0000)
+#define TIM_ExtTRGPSC_DIV2                 ((uint16_t)0x1000)
+#define TIM_ExtTRGPSC_DIV4                 ((uint16_t)0x2000)
+#define TIM_ExtTRGPSC_DIV8                 ((uint16_t)0x3000)
 #define IS_TIM_EXT_PRESCALER(PRESCALER) (((PRESCALER) == TIM_ExtTRGPSC_OFF) || \
                                          ((PRESCALER) == TIM_ExtTRGPSC_DIV2) || \
                                          ((PRESCALER) == TIM_ExtTRGPSC_DIV4) || \
                                          ((PRESCALER) == TIM_ExtTRGPSC_DIV8))
+/**
+  * @}
+  */ 
 
-/* TIM Internal Trigger Selection ------------------------------------------*/
-#define TIM_TS_ITR0                        ((u16)0x0000)
-#define TIM_TS_ITR1                        ((u16)0x0010)
-#define TIM_TS_ITR2                        ((u16)0x0020)
-#define TIM_TS_ITR3                        ((u16)0x0030)
-#define TIM_TS_TI1F_ED                     ((u16)0x0040)
-#define TIM_TS_TI1FP1                      ((u16)0x0050)
-#define TIM_TS_TI2FP2                      ((u16)0x0060)
-#define TIM_TS_ETRF                        ((u16)0x0070)
+/** @defgroup TIM_Internal_Trigger_Selection 
+  * @{
+  */
 
+#define TIM_TS_ITR0                        ((uint16_t)0x0000)
+#define TIM_TS_ITR1                        ((uint16_t)0x0010)
+#define TIM_TS_ITR2                        ((uint16_t)0x0020)
+#define TIM_TS_ITR3                        ((uint16_t)0x0030)
+#define TIM_TS_TI1F_ED                     ((uint16_t)0x0040)
+#define TIM_TS_TI1FP1                      ((uint16_t)0x0050)
+#define TIM_TS_TI2FP2                      ((uint16_t)0x0060)
+#define TIM_TS_ETRF                        ((uint16_t)0x0070)
 #define IS_TIM_TRIGGER_SELECTION(SELECTION) (((SELECTION) == TIM_TS_ITR0) || \
                                              ((SELECTION) == TIM_TS_ITR1) || \
                                              ((SELECTION) == TIM_TS_ITR2) || \
@@ -443,109 +665,159 @@
                                              ((SELECTION) == TIM_TS_TI1FP1) || \
                                              ((SELECTION) == TIM_TS_TI2FP2) || \
                                              ((SELECTION) == TIM_TS_ETRF))
-
 #define IS_TIM_INTERNAL_TRIGGER_SELECTION(SELECTION) (((SELECTION) == TIM_TS_ITR0) || \
                                                       ((SELECTION) == TIM_TS_ITR1) || \
                                                       ((SELECTION) == TIM_TS_ITR2) || \
                                                       ((SELECTION) == TIM_TS_ITR3))
+/**
+  * @}
+  */ 
 
-/* TIM TIx External Clock Source -------------------------------------------*/
-#define TIM_TIxExternalCLK1Source_TI1      ((u16)0x0050)
-#define TIM_TIxExternalCLK1Source_TI2      ((u16)0x0060)
-#define TIM_TIxExternalCLK1Source_TI1ED    ((u16)0x0040)
+/** @defgroup TIM_TIx_External_Clock_Source 
+  * @{
+  */
 
+#define TIM_TIxExternalCLK1Source_TI1      ((uint16_t)0x0050)
+#define TIM_TIxExternalCLK1Source_TI2      ((uint16_t)0x0060)
+#define TIM_TIxExternalCLK1Source_TI1ED    ((uint16_t)0x0040)
 #define IS_TIM_TIXCLK_SOURCE(SOURCE) (((SOURCE) == TIM_TIxExternalCLK1Source_TI1) || \
                                       ((SOURCE) == TIM_TIxExternalCLK1Source_TI2) || \
                                       ((SOURCE) == TIM_TIxExternalCLK1Source_TI1ED))
+/**
+  * @}
+  */ 
 
-/* TIM External Trigger Polarity -------------------------------------------*/
-#define TIM_ExtTRGPolarity_Inverted        ((u16)0x8000)
-#define TIM_ExtTRGPolarity_NonInverted     ((u16)0x0000)
-
+/** @defgroup TIM_External_Trigger_Polarity 
+  * @{
+  */ 
+#define TIM_ExtTRGPolarity_Inverted        ((uint16_t)0x8000)
+#define TIM_ExtTRGPolarity_NonInverted     ((uint16_t)0x0000)
 #define IS_TIM_EXT_POLARITY(POLARITY) (((POLARITY) == TIM_ExtTRGPolarity_Inverted) || \
                                        ((POLARITY) == TIM_ExtTRGPolarity_NonInverted))
+/**
+  * @}
+  */
 
-/* TIM Prescaler Reload Mode -----------------------------------------------*/
-#define TIM_PSCReloadMode_Update           ((u16)0x0000)
-#define TIM_PSCReloadMode_Immediate        ((u16)0x0001)
+/** @defgroup TIM_Prescaler_Reload_Mode 
+  * @{
+  */
 
+#define TIM_PSCReloadMode_Update           ((uint16_t)0x0000)
+#define TIM_PSCReloadMode_Immediate        ((uint16_t)0x0001)
 #define IS_TIM_PRESCALER_RELOAD(RELOAD) (((RELOAD) == TIM_PSCReloadMode_Update) || \
                                          ((RELOAD) == TIM_PSCReloadMode_Immediate))
+/**
+  * @}
+  */ 
 
-/* TIM Forced Action -------------------------------------------------------*/
-#define TIM_ForcedAction_Active            ((u16)0x0050)
-#define TIM_ForcedAction_InActive          ((u16)0x0040)
+/** @defgroup TIM_Forced_Action 
+  * @{
+  */
 
+#define TIM_ForcedAction_Active            ((uint16_t)0x0050)
+#define TIM_ForcedAction_InActive          ((uint16_t)0x0040)
 #define IS_TIM_FORCED_ACTION(ACTION) (((ACTION) == TIM_ForcedAction_Active) || \
                                       ((ACTION) == TIM_ForcedAction_InActive))
+/**
+  * @}
+  */ 
 
-/* TIM Encoder Mode --------------------------------------------------------*/ 
-#define TIM_EncoderMode_TI1                ((u16)0x0001)
-#define TIM_EncoderMode_TI2                ((u16)0x0002)
-#define TIM_EncoderMode_TI12               ((u16)0x0003)
+/** @defgroup TIM_Encoder_Mode 
+  * @{
+  */
 
+#define TIM_EncoderMode_TI1                ((uint16_t)0x0001)
+#define TIM_EncoderMode_TI2                ((uint16_t)0x0002)
+#define TIM_EncoderMode_TI12               ((uint16_t)0x0003)
 #define IS_TIM_ENCODER_MODE(MODE) (((MODE) == TIM_EncoderMode_TI1) || \
                                    ((MODE) == TIM_EncoderMode_TI2) || \
                                    ((MODE) == TIM_EncoderMode_TI12))
+/**
+  * @}
+  */ 
 
-/* TIM Event Source --------------------------------------------------------*/
-#define TIM_EventSource_Update             ((u16)0x0001)
-#define TIM_EventSource_CC1                ((u16)0x0002)
-#define TIM_EventSource_CC2                ((u16)0x0004)
-#define TIM_EventSource_CC3                ((u16)0x0008)
-#define TIM_EventSource_CC4                ((u16)0x0010)
-#define TIM_EventSource_COM                ((u16)0x0020)
-#define TIM_EventSource_Trigger            ((u16)0x0040)
-#define TIM_EventSource_Break              ((u16)0x0080)
 
-#define IS_TIM_EVENT_SOURCE(SOURCE) ((((SOURCE) &amp; (u16)0xFF00) == 0x0000) &amp;&amp; ((SOURCE) != 0x0000))
+/** @defgroup TIM_Event_Source 
+  * @{
+  */
 
-#define IS_TIM_PERIPH_EVENT(PERIPH, EVENT) ((((((*(u32*)&amp;(PERIPH)) == TIM2_BASE) || (((*(u32*)&amp;(PERIPH)) == TIM3_BASE))||\
-                                            (((*(u32*)&amp;(PERIPH)) == TIM4_BASE)) || (((*(u32*)&amp;(PERIPH)) == TIM5_BASE))))&amp;&amp; \
-                                            (((EVENT) &amp; (u16)0xFFA0) == 0x0000) &amp;&amp; ((EVENT) != 0x0000)) ||\
-                                            (((((*(u32*)&amp;(PERIPH)) == TIM1_BASE) || (((*(u32*)&amp;(PERIPH)) == TIM8_BASE))))&amp;&amp; \
-                                            (((EVENT) &amp; (u16)0xFF00) == 0x0000) &amp;&amp; ((EVENT) != 0x0000)) ||\
-                                            (((((*(u32*)&amp;(PERIPH)) == TIM6_BASE) || (((*(u32*)&amp;(PERIPH)) == TIM7_BASE))))&amp;&amp; \
-                                            (((EVENT) &amp; (u16)0xFFFE) == 0x0000) &amp;&amp; ((EVENT) != 0x0000)))
+#define TIM_EventSource_Update             ((uint16_t)0x0001)
+#define TIM_EventSource_CC1                ((uint16_t)0x0002)
+#define TIM_EventSource_CC2                ((uint16_t)0x0004)
+#define TIM_EventSource_CC3                ((uint16_t)0x0008)
+#define TIM_EventSource_CC4                ((uint16_t)0x0010)
+#define TIM_EventSource_COM                ((uint16_t)0x0020)
+#define TIM_EventSource_Trigger            ((uint16_t)0x0040)
+#define TIM_EventSource_Break              ((uint16_t)0x0080)
+#define IS_TIM_EVENT_SOURCE(SOURCE) ((((SOURCE) &amp; (uint16_t)0xFF00) == 0x0000) &amp;&amp; ((SOURCE) != 0x0000))
 
-/* TIM Update Source --------------------------------------------------------*/
-#define TIM_UpdateSource_Global            ((u16)0x0000)
-#define TIM_UpdateSource_Regular           ((u16)0x0001)
+/**
+  * @}
+  */ 
 
+/** @defgroup TIM_Update_Source 
+  * @{
+  */
+
+#define TIM_UpdateSource_Global            ((uint16_t)0x0000) /*!&lt; Source of update is the counter overflow/underflow
+                                                                   or the setting of UG bit, or an update generation
+                                                                   through the slave mode controller. */
+#define TIM_UpdateSource_Regular           ((uint16_t)0x0001) /*!&lt; Source of update is counter overflow/underflow. */
 #define IS_TIM_UPDATE_SOURCE(SOURCE) (((SOURCE) == TIM_UpdateSource_Global) || \
                                       ((SOURCE) == TIM_UpdateSource_Regular))
+/**
+  * @}
+  */ 
 
-/* TIM Ouput Compare Preload State ------------------------------------------*/
-#define TIM_OCPreload_Enable               ((u16)0x0008)
-#define TIM_OCPreload_Disable              ((u16)0x0000)
+/** @defgroup TIM_Ouput_Compare_Preload_State 
+  * @{
+  */
 
+#define TIM_OCPreload_Enable               ((uint16_t)0x0008)
+#define TIM_OCPreload_Disable              ((uint16_t)0x0000)
 #define IS_TIM_OCPRELOAD_STATE(STATE) (((STATE) == TIM_OCPreload_Enable) || \
                                        ((STATE) == TIM_OCPreload_Disable))
+/**
+  * @}
+  */ 
 
-/* TIM Ouput Compare Fast State ---------------------------------------------*/
-#define TIM_OCFast_Enable                  ((u16)0x0004)
-#define TIM_OCFast_Disable                 ((u16)0x0000)
+/** @defgroup TIM_Ouput_Compare_Fast_State 
+  * @{
+  */
 
+#define TIM_OCFast_Enable                  ((uint16_t)0x0004)
+#define TIM_OCFast_Disable                 ((uint16_t)0x0000)
 #define IS_TIM_OCFAST_STATE(STATE) (((STATE) == TIM_OCFast_Enable) || \
                                     ((STATE) == TIM_OCFast_Disable))
                                      
-/* TIM Ouput Compare Clear State --------------------------------------------*/
-#define TIM_OCClear_Enable                 ((u16)0x0080)
-#define TIM_OCClear_Disable                ((u16)0x0000)
+/**
+  * @}
+  */ 
 
+/** @defgroup TIM_Ouput_Compare_Clear_State 
+  * @{
+  */
+
+#define TIM_OCClear_Enable                 ((uint16_t)0x0080)
+#define TIM_OCClear_Disable                ((uint16_t)0x0000)
 #define IS_TIM_OCCLEAR_STATE(STATE) (((STATE) == TIM_OCClear_Enable) || \
-                                     ((STATE) == TIM_OCClear_Disable))                                     
+                                     ((STATE) == TIM_OCClear_Disable))
+/**
+  * @}
+  */ 
 
-/* TIM Trigger Output Source ------------------------------------------------*/ 
-#define TIM_TRGOSource_Reset               ((u16)0x0000)
-#define TIM_TRGOSource_Enable              ((u16)0x0010)
-#define TIM_TRGOSource_Update              ((u16)0x0020)
-#define TIM_TRGOSource_OC1                 ((u16)0x0030)
-#define TIM_TRGOSource_OC1Ref              ((u16)0x0040)
-#define TIM_TRGOSource_OC2Ref              ((u16)0x0050)
-#define TIM_TRGOSource_OC3Ref              ((u16)0x0060)
-#define TIM_TRGOSource_OC4Ref              ((u16)0x0070)
+/** @defgroup TIM_Trigger_Output_Source 
+  * @{
+  */
 
+#define TIM_TRGOSource_Reset               ((uint16_t)0x0000)
+#define TIM_TRGOSource_Enable              ((uint16_t)0x0010)
+#define TIM_TRGOSource_Update              ((uint16_t)0x0020)
+#define TIM_TRGOSource_OC1                 ((uint16_t)0x0030)
+#define TIM_TRGOSource_OC1Ref              ((uint16_t)0x0040)
+#define TIM_TRGOSource_OC2Ref              ((uint16_t)0x0050)
+#define TIM_TRGOSource_OC3Ref              ((uint16_t)0x0060)
+#define TIM_TRGOSource_OC4Ref              ((uint16_t)0x0070)
 #define IS_TIM_TRGO_SOURCE(SOURCE) (((SOURCE) == TIM_TRGOSource_Reset) || \
                                     ((SOURCE) == TIM_TRGOSource_Enable) || \
                                     ((SOURCE) == TIM_TRGOSource_Update) || \
@@ -554,75 +826,54 @@
                                     ((SOURCE) == TIM_TRGOSource_OC2Ref) || \
                                     ((SOURCE) == TIM_TRGOSource_OC3Ref) || \
                                     ((SOURCE) == TIM_TRGOSource_OC4Ref))
+/**
+  * @}
+  */ 
 
-#define IS_TIM_PERIPH_TRGO(PERIPH, TRGO)  (((((*(u32*)&amp;(PERIPH)) == TIM2_BASE)||(((*(u32*)&amp;(PERIPH)) == TIM1_BASE))||\
-                                           (((*(u32*)&amp;(PERIPH)) == TIM3_BASE))||(((*(u32*)&amp;(PERIPH)) == TIM4_BASE))|| \
-                                           (((*(u32*)&amp;(PERIPH)) == TIM6_BASE))||(((*(u32*)&amp;(PERIPH)) == TIM7_BASE))|| \
-                                           (((*(u32*)&amp;(PERIPH)) == TIM5_BASE))||(((*(u32*)&amp;(PERIPH)) == TIM8_BASE))) &amp;&amp; \
-                                           ((TRGO) == TIM_TRGOSource_Reset)) ||\
-                                           ((((*(u32*)&amp;(PERIPH)) == TIM2_BASE)||(((*(u32*)&amp;(PERIPH)) == TIM1_BASE))||\
-                                           (((*(u32*)&amp;(PERIPH)) == TIM6_BASE))||(((*(u32*)&amp;(PERIPH)) == TIM7_BASE))|| \
-                                           (((*(u32*)&amp;(PERIPH)) == TIM3_BASE))||(((*(u32*)&amp;(PERIPH)) == TIM4_BASE))|| \
-                                           (((*(u32*)&amp;(PERIPH)) == TIM5_BASE))||(((*(u32*)&amp;(PERIPH)) == TIM8_BASE))) &amp;&amp; \
-                                           ((TRGO) == TIM_TRGOSource_Enable)) ||\
-                                           ((((*(u32*)&amp;(PERIPH)) == TIM2_BASE)||(((*(u32*)&amp;(PERIPH)) == TIM1_BASE))||\
-                                           (((*(u32*)&amp;(PERIPH)) == TIM6_BASE))||(((*(u32*)&amp;(PERIPH)) == TIM7_BASE))|| \
-                                           (((*(u32*)&amp;(PERIPH)) == TIM3_BASE))||(((*(u32*)&amp;(PERIPH)) == TIM4_BASE))|| \
-                                           (((*(u32*)&amp;(PERIPH)) == TIM5_BASE))||(((*(u32*)&amp;(PERIPH)) == TIM8_BASE))) &amp;&amp; \
-                                           ((TRGO) == TIM_TRGOSource_Update)) ||\
-                                           ((((*(u32*)&amp;(PERIPH)) == TIM2_BASE)||(((*(u32*)&amp;(PERIPH)) == TIM1_BASE))||\
-                                           (((*(u32*)&amp;(PERIPH)) == TIM3_BASE))||(((*(u32*)&amp;(PERIPH)) == TIM4_BASE))|| \
-                                           (((*(u32*)&amp;(PERIPH)) == TIM5_BASE))||(((*(u32*)&amp;(PERIPH)) == TIM8_BASE))) &amp;&amp; \
-                                           ((TRGO) == TIM_TRGOSource_OC1)) ||\
-                                           ((((*(u32*)&amp;(PERIPH)) == TIM2_BASE)||(((*(u32*)&amp;(PERIPH)) == TIM1_BASE))||\
-                                           (((*(u32*)&amp;(PERIPH)) == TIM3_BASE))||(((*(u32*)&amp;(PERIPH)) == TIM4_BASE))|| \
-                                           (((*(u32*)&amp;(PERIPH)) == TIM5_BASE))||(((*(u32*)&amp;(PERIPH)) == TIM8_BASE))) &amp;&amp; \
-                                           ((TRGO) == TIM_TRGOSource_OC1Ref)) ||\
-                                           ((((*(u32*)&amp;(PERIPH)) == TIM2_BASE)||(((*(u32*)&amp;(PERIPH)) == TIM1_BASE))||\
-                                           (((*(u32*)&amp;(PERIPH)) == TIM3_BASE))||(((*(u32*)&amp;(PERIPH)) == TIM4_BASE))|| \
-                                           (((*(u32*)&amp;(PERIPH)) == TIM5_BASE))||(((*(u32*)&amp;(PERIPH)) == TIM8_BASE))) &amp;&amp; \
-                                           ((TRGO) == TIM_TRGOSource_OC2Ref)) ||\
-                                           ((((*(u32*)&amp;(PERIPH)) == TIM2_BASE)||(((*(u32*)&amp;(PERIPH)) == TIM1_BASE))||\
-                                           (((*(u32*)&amp;(PERIPH)) == TIM3_BASE))||(((*(u32*)&amp;(PERIPH)) == TIM4_BASE))|| \
-                                           (((*(u32*)&amp;(PERIPH)) == TIM5_BASE))||(((*(u32*)&amp;(PERIPH)) == TIM8_BASE))) &amp;&amp; \
-                                           ((TRGO) == TIM_TRGOSource_OC3Ref)) ||\
-                                           ((((*(u32*)&amp;(PERIPH)) == TIM2_BASE)||(((*(u32*)&amp;(PERIPH)) == TIM1_BASE))||\
-                                           (((*(u32*)&amp;(PERIPH)) == TIM3_BASE))||(((*(u32*)&amp;(PERIPH)) == TIM4_BASE))|| \
-                                           (((*(u32*)&amp;(PERIPH)) == TIM5_BASE))||(((*(u32*)&amp;(PERIPH)) == TIM8_BASE))) &amp;&amp; \
-                                           ((TRGO) == TIM_TRGOSource_OC4Ref)))
+/** @defgroup TIM_Slave_Mode 
+  * @{
+  */
 
-/* TIM Slave Mode ----------------------------------------------------------*/
-#define TIM_SlaveMode_Reset                ((u16)0x0004)
-#define TIM_SlaveMode_Gated                ((u16)0x0005)
-#define TIM_SlaveMode_Trigger              ((u16)0x0006)
-#define TIM_SlaveMode_External1            ((u16)0x0007)
-
+#define TIM_SlaveMode_Reset                ((uint16_t)0x0004)
+#define TIM_SlaveMode_Gated                ((uint16_t)0x0005)
+#define TIM_SlaveMode_Trigger              ((uint16_t)0x0006)
+#define TIM_SlaveMode_External1            ((uint16_t)0x0007)
 #define IS_TIM_SLAVE_MODE(MODE) (((MODE) == TIM_SlaveMode_Reset) || \
                                  ((MODE) == TIM_SlaveMode_Gated) || \
                                  ((MODE) == TIM_SlaveMode_Trigger) || \
                                  ((MODE) == TIM_SlaveMode_External1))
+/**
+  * @}
+  */ 
 
-/* TIM Master Slave Mode ---------------------------------------------------*/
-#define TIM_MasterSlaveMode_Enable         ((u16)0x0080)
-#define TIM_MasterSlaveMode_Disable        ((u16)0x0000)
+/** @defgroup TIM_Master_Slave_Mode 
+  * @{
+  */
 
+#define TIM_MasterSlaveMode_Enable         ((uint16_t)0x0080)
+#define TIM_MasterSlaveMode_Disable        ((uint16_t)0x0000)
 #define IS_TIM_MSM_STATE(STATE) (((STATE) == TIM_MasterSlaveMode_Enable) || \
                                  ((STATE) == TIM_MasterSlaveMode_Disable))
+/**
+  * @}
+  */ 
 
-/* TIM Flags ---------------------------------------------------------------*/
-#define TIM_FLAG_Update                    ((u16)0x0001)
-#define TIM_FLAG_CC1                       ((u16)0x0002)
-#define TIM_FLAG_CC2                       ((u16)0x0004)
-#define TIM_FLAG_CC3                       ((u16)0x0008)
-#define TIM_FLAG_CC4                       ((u16)0x0010)
-#define TIM_FLAG_COM                       ((u16)0x0020)
-#define TIM_FLAG_Trigger                   ((u16)0x0040)
-#define TIM_FLAG_Break                     ((u16)0x0080)
-#define TIM_FLAG_CC1OF                     ((u16)0x0200)
-#define TIM_FLAG_CC2OF                     ((u16)0x0400)
-#define TIM_FLAG_CC3OF                     ((u16)0x0800)
-#define TIM_FLAG_CC4OF                     ((u16)0x1000)
+/** @defgroup TIM_Flags 
+  * @{
+  */
 
+#define TIM_FLAG_Update                    ((uint16_t)0x0001)
+#define TIM_FLAG_CC1                       ((uint16_t)0x0002)
+#define TIM_FLAG_CC2                       ((uint16_t)0x0004)
+#define TIM_FLAG_CC3                       ((uint16_t)0x0008)
+#define TIM_FLAG_CC4                       ((uint16_t)0x0010)
+#define TIM_FLAG_COM                       ((uint16_t)0x0020)
+#define TIM_FLAG_Trigger                   ((uint16_t)0x0040)
+#define TIM_FLAG_Break                     ((uint16_t)0x0080)
+#define TIM_FLAG_CC1OF                     ((uint16_t)0x0200)
+#define TIM_FLAG_CC2OF                     ((uint16_t)0x0400)
+#define TIM_FLAG_CC3OF                     ((uint16_t)0x0800)
+#define TIM_FLAG_CC4OF                     ((uint16_t)0x1000)
 #define IS_TIM_GET_FLAG(FLAG) (((FLAG) == TIM_FLAG_Update) || \
                                ((FLAG) == TIM_FLAG_CC1) || \
                                ((FLAG) == TIM_FLAG_CC2) || \
@@ -635,43 +886,47 @@
                                ((FLAG) == TIM_FLAG_CC2OF) || \
                                ((FLAG) == TIM_FLAG_CC3OF) || \
                                ((FLAG) == TIM_FLAG_CC4OF))
+                               
+                               
+#define IS_TIM_CLEAR_FLAG(TIM_FLAG) ((((TIM_FLAG) &amp; (uint16_t)0xE100) == 0x0000) &amp;&amp; ((TIM_FLAG) != 0x0000))
+/**
+  * @}
+  */ 
 
-#define IS_TIM_CLEAR_FLAG(PERIPH, TIM_FLAG) ((((((*(u32*)&amp;(PERIPH)) == TIM2_BASE) || (((*(u32*)&amp;(PERIPH)) == TIM3_BASE))||\
-                                            (((*(u32*)&amp;(PERIPH)) == TIM4_BASE)) || (((*(u32*)&amp;(PERIPH)) == TIM5_BASE))))&amp;&amp; \
-                                            (((TIM_FLAG) &amp; (u16)0xE1A0) == 0x0000) &amp;&amp; ((TIM_FLAG) != 0x0000)) ||\
-                                            (((((*(u32*)&amp;(PERIPH)) == TIM1_BASE) || (((*(u32*)&amp;(PERIPH)) == TIM8_BASE))))&amp;&amp; \
-                                            (((TIM_FLAG) &amp; (u16)0xE100) == 0x0000) &amp;&amp; ((TIM_FLAG) != 0x0000)) ||\
-                                            (((((*(u32*)&amp;(PERIPH)) == TIM6_BASE) || (((*(u32*)&amp;(PERIPH)) == TIM7_BASE))))&amp;&amp; \
-                                            (((TIM_FLAG) &amp; (u16)0xFFFE) == 0x0000) &amp;&amp; ((TIM_FLAG) != 0x0000)))
+/** @defgroup TIM_Input_Capture_Filer_Value 
+  * @{
+  */
 
-#define IS_TIM_PERIPH_FLAG(PERIPH, TIM_FLAG)  (((((*(u32*)&amp;(PERIPH))==TIM2_BASE) || ((*(u32*)&amp;(PERIPH)) == TIM3_BASE) ||\
-                                                 ((*(u32*)&amp;(PERIPH)) == TIM4_BASE) || ((*(u32*)&amp;(PERIPH))==TIM5_BASE) || \
-                                                 ((*(u32*)&amp;(PERIPH))==TIM1_BASE) || ((*(u32*)&amp;(PERIPH))==TIM8_BASE)) &amp;&amp;\
-                                                 (((TIM_FLAG) == TIM_FLAG_CC1) || ((TIM_FLAG) == TIM_FLAG_CC2) ||\
-                                                 ((TIM_FLAG) == TIM_FLAG_CC3) || ((TIM_FLAG) == TIM_FLAG_CC4) || \
-                                                 ((TIM_FLAG) == TIM_FLAG_Trigger))) ||\
-                                                 ((((*(u32*)&amp;(PERIPH))==TIM2_BASE) || ((*(u32*)&amp;(PERIPH)) == TIM3_BASE) || \
-                                                 ((*(u32*)&amp;(PERIPH)) == TIM4_BASE) || ((*(u32*)&amp;(PERIPH))==TIM5_BASE) ||\
-                                                 ((*(u32*)&amp;(PERIPH))==TIM1_BASE)|| ((*(u32*)&amp;(PERIPH))==TIM8_BASE) || \
-                                                 ((*(u32*)&amp;(PERIPH))==TIM7_BASE) || ((*(u32*)&amp;(PERIPH))==TIM6_BASE)) &amp;&amp; \
-                                                 (((TIM_FLAG) == TIM_FLAG_Update))) ||\
-                                                 ((((*(u32*)&amp;(PERIPH))==TIM1_BASE) || ((*(u32*)&amp;(PERIPH)) == TIM8_BASE)) &amp;&amp;\
-                                                 (((TIM_FLAG) == TIM_FLAG_COM) || ((TIM_FLAG) == TIM_FLAG_Break))) ||\
-                                                 ((((*(u32*)&amp;(PERIPH))==TIM2_BASE) || ((*(u32*)&amp;(PERIPH)) == TIM3_BASE) || \
-                                                 ((*(u32*)&amp;(PERIPH)) == TIM4_BASE) || ((*(u32*)&amp;(PERIPH))==TIM5_BASE) || \
-                                                 ((*(u32*)&amp;(PERIPH))==TIM1_BASE) || ((*(u32*)&amp;(PERIPH))==TIM8_BASE)) &amp;&amp;\
-                                                 (((TIM_FLAG) == TIM_FLAG_CC1OF) || ((TIM_FLAG) == TIM_FLAG_CC2OF) ||\
-                                                 ((TIM_FLAG) == TIM_FLAG_CC3OF) || ((TIM_FLAG) == TIM_FLAG_CC4OF))))             
-                                                                                            
-/* TIM Input Capture Filer Value ---------------------------------------------*/
 #define IS_TIM_IC_FILTER(ICFILTER) ((ICFILTER) &lt;= 0xF) 
+/**
+  * @}
+  */ 
 
-/* TIM External Trigger Filter -----------------------------------------------*/
-#define IS_TIM_EXT_FILTER(EXTFILTER) ((EXTFILTER) &lt;= 0xF)                              
+/** @defgroup TIM_External_Trigger_Filter 
+  * @{
+  */
 
-/* Exported macro ------------------------------------------------------------*/
-/* Exported functions --------------------------------------------------------*/
+#define IS_TIM_EXT_FILTER(EXTFILTER) ((EXTFILTER) &lt;= 0xF)
+/**
+  * @}
+  */ 
 
+/**
+  * @}
+  */
+
+/** @defgroup TIM_Exported_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */ 
+
+/** @defgroup TIM_Exported_Functions
+  * @{
+  */
+
 void TIM_DeInit(TIM_TypeDef* TIMx);
 void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct);
 void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);
@@ -687,92 +942,99 @@
 void TIM_BDTRStructInit(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct);
 void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState);
 void TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState);
-void TIM_ITConfig(TIM_TypeDef* TIMx, u16 TIM_IT, FunctionalState NewState);
-void TIM_GenerateEvent(TIM_TypeDef* TIMx, u16 TIM_EventSource);
-void TIM_DMAConfig(TIM_TypeDef* TIMx, u16 TIM_DMABase, u16 TIM_DMABurstLength);
-void TIM_DMACmd(TIM_TypeDef* TIMx, u16 TIM_DMASource, FunctionalState NewState);
+void TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState);
+void TIM_GenerateEvent(TIM_TypeDef* TIMx, uint16_t TIM_EventSource);
+void TIM_DMAConfig(TIM_TypeDef* TIMx, uint16_t TIM_DMABase, uint16_t TIM_DMABurstLength);
+void TIM_DMACmd(TIM_TypeDef* TIMx, uint16_t TIM_DMASource, FunctionalState NewState);
 void TIM_InternalClockConfig(TIM_TypeDef* TIMx);
-void TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, u16 TIM_InputTriggerSource);
-void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, u16 TIM_TIxExternalCLKSource,
-                                u16 TIM_ICPolarity, u16 ICFilter);                                
-void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, u16 TIM_ExtTRGPrescaler, u16 TIM_ExtTRGPolarity,
-                             u16 ExtTRGFilter);
-void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, u16 TIM_ExtTRGPrescaler, 
-                             u16 TIM_ExtTRGPolarity, u16 ExtTRGFilter);
-void TIM_ETRConfig(TIM_TypeDef* TIMx, u16 TIM_ExtTRGPrescaler, u16 TIM_ExtTRGPolarity,
-                   u16 ExtTRGFilter);
-void TIM_PrescalerConfig(TIM_TypeDef* TIMx, u16 Prescaler, u16 TIM_PSCReloadMode);
-void TIM_CounterModeConfig(TIM_TypeDef* TIMx, u16 TIM_CounterMode);
-void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, u16 TIM_InputTriggerSource);
-void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, u16 TIM_EncoderMode,
-                                u16 TIM_IC1Polarity, u16 TIM_IC2Polarity);
-void TIM_ForcedOC1Config(TIM_TypeDef* TIMx, u16 TIM_ForcedAction);
-void TIM_ForcedOC2Config(TIM_TypeDef* TIMx, u16 TIM_ForcedAction);
-void TIM_ForcedOC3Config(TIM_TypeDef* TIMx, u16 TIM_ForcedAction);
-void TIM_ForcedOC4Config(TIM_TypeDef* TIMx, u16 TIM_ForcedAction);
+void TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource);
+void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource,
+                                uint16_t TIM_ICPolarity, uint16_t ICFilter);
+void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
+                             uint16_t ExtTRGFilter);
+void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, 
+                             uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter);
+void TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
+                   uint16_t ExtTRGFilter);
+void TIM_PrescalerConfig(TIM_TypeDef* TIMx, uint16_t Prescaler, uint16_t TIM_PSCReloadMode);
+void TIM_CounterModeConfig(TIM_TypeDef* TIMx, uint16_t TIM_CounterMode);
+void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource);
+void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t TIM_EncoderMode,
+                                uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity);
+void TIM_ForcedOC1Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);
+void TIM_ForcedOC2Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);
+void TIM_ForcedOC3Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);
+void TIM_ForcedOC4Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);
 void TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState);
 void TIM_SelectCOM(TIM_TypeDef* TIMx, FunctionalState NewState);
 void TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState NewState);
 void TIM_CCPreloadControl(TIM_TypeDef* TIMx, FunctionalState NewState);
-void TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, u16 TIM_OCPreload);
-void TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, u16 TIM_OCPreload);
-void TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, u16 TIM_OCPreload);
-void TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, u16 TIM_OCPreload);
-void TIM_OC1FastConfig(TIM_TypeDef* TIMx, u16 TIM_OCFast);
-void TIM_OC2FastConfig(TIM_TypeDef* TIMx, u16 TIM_OCFast);
-void TIM_OC3FastConfig(TIM_TypeDef* TIMx, u16 TIM_OCFast);
-void TIM_OC4FastConfig(TIM_TypeDef* TIMx, u16 TIM_OCFast);
-void TIM_ClearOC1Ref(TIM_TypeDef* TIMx, u16 TIM_OCClear);
-void TIM_ClearOC2Ref(TIM_TypeDef* TIMx, u16 TIM_OCClear);
-void TIM_ClearOC3Ref(TIM_TypeDef* TIMx, u16 TIM_OCClear);
-void TIM_ClearOC4Ref(TIM_TypeDef* TIMx, u16 TIM_OCClear);
-void TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCPolarity);
-void TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCNPolarity);
-void TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCPolarity);
-void TIM_OC2NPolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCNPolarity);
-void TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCPolarity);
-void TIM_OC3NPolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCNPolarity);
-void TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCPolarity);
-void TIM_CCxCmd(TIM_TypeDef* TIMx, u16 TIM_Channel, u16 TIM_CCx);
-void TIM_CCxNCmd(TIM_TypeDef* TIMx, u16 TIM_Channel, u16 TIM_CCxN);
-void TIM_SelectOCxM(TIM_TypeDef* TIMx, u16 TIM_Channel, u16 TIM_OCMode);
+void TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload);
+void TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload);
+void TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload);
+void TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload);
+void TIM_OC1FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast);
+void TIM_OC2FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast);
+void TIM_OC3FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast);
+void TIM_OC4FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast);
+void TIM_ClearOC1Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear);
+void TIM_ClearOC2Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear);
+void TIM_ClearOC3Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear);
+void TIM_ClearOC4Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear);
+void TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity);
+void TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity);
+void TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity);
+void TIM_OC2NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity);
+void TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity);
+void TIM_OC3NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity);
+void TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity);
+void TIM_CCxCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCx);
+void TIM_CCxNCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCxN);
+void TIM_SelectOCxM(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_OCMode);
 void TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState NewState);
-void TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, u16 TIM_UpdateSource);
+void TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, uint16_t TIM_UpdateSource);
 void TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState NewState);
-void TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, u16 TIM_OPMode);
-void TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, u16 TIM_TRGOSource);
-void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, u16 TIM_SlaveMode);
-void TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, u16 TIM_MasterSlaveMode);
-void TIM_SetCounter(TIM_TypeDef* TIMx, u16 Counter);
-void TIM_SetAutoreload(TIM_TypeDef* TIMx, u16 Autoreload);
-void TIM_SetCompare1(TIM_TypeDef* TIMx, u16 Compare1);
-void TIM_SetCompare2(TIM_TypeDef* TIMx, u16 Compare2);
-void TIM_SetCompare3(TIM_TypeDef* TIMx, u16 Compare3);
-void TIM_SetCompare4(TIM_TypeDef* TIMx, u16 Compare4);
-void TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, u16 TIM_ICPSC);
-void TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, u16 TIM_ICPSC);
-void TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, u16 TIM_ICPSC);
-void TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, u16 TIM_ICPSC);
-void TIM_SetClockDivision(TIM_TypeDef* TIMx, u16 TIM_CKD);
-u16 TIM_GetCapture1(TIM_TypeDef* TIMx);
-u16 TIM_GetCapture2(TIM_TypeDef* TIMx);
-u16 TIM_GetCapture3(TIM_TypeDef* TIMx);
-u16 TIM_GetCapture4(TIM_TypeDef* TIMx);
-u16 TIM_GetCounter(TIM_TypeDef* TIMx);
-u16 TIM_GetPrescaler(TIM_TypeDef* TIMx);
-FlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, u16 TIM_FLAG);
-void TIM_ClearFlag(TIM_TypeDef* TIMx, u16 TIM_FLAG);
-ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, u16 TIM_IT);
-void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, u16 TIM_IT);
-                                                                                                             
-#endif /*__STM32F10x_TIM_H */
+void TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, uint16_t TIM_OPMode);
+void TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_TRGOSource);
+void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode);
+void TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_MasterSlaveMode);
+void TIM_SetCounter(TIM_TypeDef* TIMx, uint16_t Counter);
+void TIM_SetAutoreload(TIM_TypeDef* TIMx, uint16_t Autoreload);
+void TIM_SetCompare1(TIM_TypeDef* TIMx, uint16_t Compare1);
+void TIM_SetCompare2(TIM_TypeDef* TIMx, uint16_t Compare2);
+void TIM_SetCompare3(TIM_TypeDef* TIMx, uint16_t Compare3);
+void TIM_SetCompare4(TIM_TypeDef* TIMx, uint16_t Compare4);
+void TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC);
+void TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC);
+void TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC);
+void TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC);
+void TIM_SetClockDivision(TIM_TypeDef* TIMx, uint16_t TIM_CKD);
+uint16_t TIM_GetCapture1(TIM_TypeDef* TIMx);
+uint16_t TIM_GetCapture2(TIM_TypeDef* TIMx);
+uint16_t TIM_GetCapture3(TIM_TypeDef* TIMx);
+uint16_t TIM_GetCapture4(TIM_TypeDef* TIMx);
+uint16_t TIM_GetCounter(TIM_TypeDef* TIMx);
+uint16_t TIM_GetPrescaler(TIM_TypeDef* TIMx);
+FlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, uint16_t TIM_FLAG);
+void TIM_ClearFlag(TIM_TypeDef* TIMx, uint16_t TIM_FLAG);
+ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, uint16_t TIM_IT);
+void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT);
 
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
+#ifdef __cplusplus
+}
+#endif
 
+#endif /*__STM32F10x_TIM_H */
+/**
+  * @}
+  */ 
 
+/**
+  * @}
+  */ 
 
+/**
+  * @}
+  */
 
-
-
-
-
+/******************* (C) COPYRIGHT 2009 STMicroelectronics *****END OF FILE****/

Deleted: trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_type.h
===================================================================
--- trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_type.h	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_type.h	2009-07-08 23:39:34 UTC (rev 354)
@@ -1,80 +0,0 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_type.h
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file contains all the common data types used for the
-*                      STM32F10x firmware library.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
-
-/* Define to prevent recursive inclusion -------------------------------------*/
-#ifndef __STM32F10x_TYPE_H
-#define __STM32F10x_TYPE_H
-
-/* Includes ------------------------------------------------------------------*/
-/* Exported types ------------------------------------------------------------*/
-typedef signed long  s32;
-typedef signed short s16;
-typedef signed char  s8;
-
-typedef signed long  const sc32;  /* Read Only */
-typedef signed short const sc16;  /* Read Only */
-typedef signed char  const sc8;   /* Read Only */
-
-typedef volatile signed long  vs32;
-typedef volatile signed short vs16;
-typedef volatile signed char  vs8;
-
-typedef volatile signed long  const vsc32;  /* Read Only */
-typedef volatile signed short const vsc16;  /* Read Only */
-typedef volatile signed char  const vsc8;   /* Read Only */
-
-typedef unsigned long  u32;
-typedef unsigned short u16;
-typedef unsigned char  u8;
-
-typedef unsigned long  const uc32;  /* Read Only */
-typedef unsigned short const uc16;  /* Read Only */
-typedef unsigned char  const uc8;   /* Read Only */
-
-typedef volatile unsigned long  vu32;
-typedef volatile unsigned short vu16;
-typedef volatile unsigned char  vu8;
-
-typedef volatile unsigned long  const vuc32;  /* Read Only */
-typedef volatile unsigned short const vuc16;  /* Read Only */
-typedef volatile unsigned char  const vuc8;   /* Read Only */
-
-typedef enum {FALSE = 0, TRUE = !FALSE} bool;
-
-typedef enum {RESET = 0, SET = !RESET} FlagStatus, ITStatus;
-
-typedef enum {DISABLE = 0, ENABLE = !DISABLE} FunctionalState;
-#define IS_FUNCTIONAL_STATE(STATE) (((STATE) == DISABLE) || ((STATE) == ENABLE))
-
-typedef enum {ERROR = 0, SUCCESS = !ERROR} ErrorStatus;
-
-#define U8_MAX     ((u8)255)
-#define S8_MAX     ((s8)127)
-#define S8_MIN     ((s8)-128)
-#define U16_MAX    ((u16)65535u)
-#define S16_MAX    ((s16)32767)
-#define S16_MIN    ((s16)-32768)
-#define U32_MAX    ((u32)4294967295uL)
-#define S32_MAX    ((s32)2147483647)
-#define S32_MIN    ((s32)-2147483648)
-
-/* Exported constants --------------------------------------------------------*/
-/* Exported macro ------------------------------------------------------------*/
-/* Exported functions ------------------------------------------------------- */
-
-#endif /* __STM32F10x_TYPE_H */
-
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/

Modified: trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_usart.h
===================================================================
--- trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_usart.h	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_usart.h	2009-07-08 23:39:34 UTC (rev 354)
@@ -1,253 +1,409 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_usart.h
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file contains all the functions prototypes for the
-*                      USART firmware library.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
+/**
+  ******************************************************************************
+  * @file    stm32f10x_usart.h
+  * @author  MCD Application Team
+  * @version V3.1.0
+  * @date    06/19/2009
+  * @brief   This file contains all the functions prototypes for the USART 
+  *          firmware library.
+  ******************************************************************************
+  * @copy
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * &lt;h2&gt;&lt;center&gt;&copy; COPYRIGHT 2009 STMicroelectronics&lt;/center&gt;&lt;/h2&gt;
+  */ 
 
 /* Define to prevent recursive inclusion -------------------------------------*/
 #ifndef __STM32F10x_USART_H
 #define __STM32F10x_USART_H
 
+#ifdef __cplusplus
+ extern &quot;C&quot; {
+#endif
+
 /* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_map.h&quot;
+#include &quot;stm32f10x.h&quot;
 
-/* Exported types ------------------------------------------------------------*/
-/* USART Init Structure definition */
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @addtogroup USART
+  * @{
+  */ 
+
+/** @defgroup USART_Exported_Types
+  * @{
+  */ 
+
+/** 
+  * @brief  USART Init Structure definition  
+  */ 
+  
 typedef struct
 {
-  u32 USART_BaudRate;
-  u16 USART_WordLength;
-  u16 USART_StopBits;
-  u16 USART_Parity;
-  u16 USART_Mode;
-  u16 USART_HardwareFlowControl;  
+  uint32_t USART_BaudRate;            /*!&lt; This member configures the USART communication baud rate.
+                                           The baud rate is computed using the following formula:
+                                            - IntegerDivider = ((PCLKx) / (16 * (USART_InitStruct-&gt;USART_BaudRate)))
+                                            - FractionalDivider = ((IntegerDivider - ((u32) IntegerDivider)) * 16) + 0.5 */
+
+  uint16_t USART_WordLength;          /*!&lt; Specifies the number of data bits transmitted or received in a frame.
+                                           This parameter can be a value of @ref USART_Word_Length */
+
+  uint16_t USART_StopBits;            /*!&lt; Specifies the number of stop bits transmitted.
+                                           This parameter can be a value of @ref USART_Stop_Bits */
+
+  uint16_t USART_Parity;              /*!&lt; Specifies the parity mode.
+                                           This parameter can be a value of @ref USART_Parity
+                                           @note When parity is enabled, the computed parity is inserted
+                                                 at the MSB position of the transmitted data (9th bit when
+                                                 the word length is set to 9 data bits; 8th bit when the
+                                                 word length is set to 8 data bits). */
+ 
+  uint16_t USART_Mode;                /*!&lt; Specifies wether the Receive or Transmit mode is enabled or disabled.
+                                           This parameter can be a value of @ref USART_Mode */
+
+  uint16_t USART_HardwareFlowControl; /*!&lt; Specifies wether the hardware flow control mode is enabled
+                                           or disabled.
+                                           This parameter can be a value of @ref USART_Hardware_Flow_Control */
 } USART_InitTypeDef;
 
-/* USART Clock Init Structure definition */
+/** 
+  * @brief  USART Clock Init Structure definition  
+  */ 
+  
 typedef struct
 {
-  u16 USART_Clock;
-  u16 USART_CPOL;
-  u16 USART_CPHA;
-  u16 USART_LastBit;
+
+  uint16_t USART_Clock;   /*!&lt; Specifies whether the USART clock is enabled or disabled.
+                               This parameter can be a value of @ref USART_Clock */
+
+  uint16_t USART_CPOL;    /*!&lt; Specifies the steady state value of the serial clock.
+                               This parameter can be a value of @ref USART_Clock_Polarity */
+
+  uint16_t USART_CPHA;    /*!&lt; Specifies the clock transition on which the bit capture is made.
+                               This parameter can be a value of @ref USART_Clock_Phase */
+
+  uint16_t USART_LastBit; /*!&lt; Specifies whether the clock pulse corresponding to the last transmitted
+                               data bit (MSB) has to be output on the SCLK pin in synchronous mode.
+                               This parameter can be a value of @ref USART_Last_Bit */
 } USART_ClockInitTypeDef;
 
-/* Exported constants --------------------------------------------------------*/
-#define IS_USART_ALL_PERIPH(PERIPH) (((*(u32*)&amp;(PERIPH)) == USART1_BASE) || \
-                                     ((*(u32*)&amp;(PERIPH)) == USART2_BASE) || \
-                                     ((*(u32*)&amp;(PERIPH)) == USART3_BASE) || \
-                                     ((*(u32*)&amp;(PERIPH)) == UART4_BASE) || \
-                                     ((*(u32*)&amp;(PERIPH)) == UART5_BASE))
+/**
+  * @}
+  */ 
 
-#define IS_USART_123_PERIPH(PERIPH) (((*(u32*)&amp;(PERIPH)) == USART1_BASE) || \
-                                     ((*(u32*)&amp;(PERIPH)) == USART2_BASE) || \
-                                     ((*(u32*)&amp;(PERIPH)) == USART3_BASE))
+/** @defgroup USART_Exported_Constants
+  * @{
+  */ 
+  
+#define IS_USART_ALL_PERIPH(PERIPH) (((PERIPH) == USART1) || \
+                                     ((PERIPH) == USART2) || \
+                                     ((PERIPH) == USART3) || \
+                                     ((PERIPH) == UART4) || \
+                                     ((PERIPH) == UART5))
 
-#define IS_USART_1234_PERIPH(PERIPH) (((*(u32*)&amp;(PERIPH)) == USART1_BASE) || \
-                                      ((*(u32*)&amp;(PERIPH)) == USART2_BASE) || \
-                                      ((*(u32*)&amp;(PERIPH)) == USART3_BASE) || \
-                                      ((*(u32*)&amp;(PERIPH)) == UART4_BASE))
+#define IS_USART_123_PERIPH(PERIPH) (((PERIPH) == USART1) || \
+                                     ((PERIPH) == USART2) || \
+                                     ((PERIPH) == USART3))
 
-/* USART Word Length ---------------------------------------------------------*/
-#define USART_WordLength_8b                  ((u16)0x0000)
-#define USART_WordLength_9b                  ((u16)0x1000)
+#define IS_USART_1234_PERIPH(PERIPH) (((PERIPH) == USART1) || \
+                                      ((PERIPH) == USART2) || \
+                                      ((PERIPH) == USART3) || \
+                                      ((PERIPH) == UART4))
+/** @defgroup USART_Word_Length 
+  * @{
+  */ 
+  
+#define USART_WordLength_8b                  ((uint16_t)0x0000)
+#define USART_WordLength_9b                  ((uint16_t)0x1000)
                                     
 #define IS_USART_WORD_LENGTH(LENGTH) (((LENGTH) == USART_WordLength_8b) || \
                                       ((LENGTH) == USART_WordLength_9b))
+/**
+  * @}
+  */ 
 
-/* USART Stop Bits -----------------------------------------------------------*/
-#define USART_StopBits_1                     ((u16)0x0000)
-#define USART_StopBits_0_5                   ((u16)0x1000)
-#define USART_StopBits_2                     ((u16)0x2000)
-#define USART_StopBits_1_5                   ((u16)0x3000)
-
+/** @defgroup USART_Stop_Bits 
+  * @{
+  */ 
+  
+#define USART_StopBits_1                     ((uint16_t)0x0000)
+#define USART_StopBits_0_5                   ((uint16_t)0x1000)
+#define USART_StopBits_2                     ((uint16_t)0x2000)
+#define USART_StopBits_1_5                   ((uint16_t)0x3000)
 #define IS_USART_STOPBITS(STOPBITS) (((STOPBITS) == USART_StopBits_1) || \
                                      ((STOPBITS) == USART_StopBits_0_5) || \
                                      ((STOPBITS) == USART_StopBits_2) || \
                                      ((STOPBITS) == USART_StopBits_1_5))
-/* USART Parity --------------------------------------------------------------*/
-#define USART_Parity_No                      ((u16)0x0000)
-#define USART_Parity_Even                    ((u16)0x0400)
-#define USART_Parity_Odd                     ((u16)0x0600) 
+/**
+  * @}
+  */ 
 
+/** @defgroup USART_Parity 
+  * @{
+  */ 
+  
+#define USART_Parity_No                      ((uint16_t)0x0000)
+#define USART_Parity_Even                    ((uint16_t)0x0400)
+#define USART_Parity_Odd                     ((uint16_t)0x0600) 
 #define IS_USART_PARITY(PARITY) (((PARITY) == USART_Parity_No) || \
                                  ((PARITY) == USART_Parity_Even) || \
                                  ((PARITY) == USART_Parity_Odd))
+/**
+  * @}
+  */ 
 
-/* USART Mode ----------------------------------------------------------------*/
-#define USART_Mode_Rx                        ((u16)0x0004)
-#define USART_Mode_Tx                        ((u16)0x0008)
+/** @defgroup USART_Mode 
+  * @{
+  */ 
+  
+#define USART_Mode_Rx                        ((uint16_t)0x0004)
+#define USART_Mode_Tx                        ((uint16_t)0x0008)
+#define IS_USART_MODE(MODE) ((((MODE) &amp; (uint16_t)0xFFF3) == 0x00) &amp;&amp; ((MODE) != (uint16_t)0x00))
+/**
+  * @}
+  */ 
 
-#define IS_USART_MODE(MODE) ((((MODE) &amp; (u16)0xFFF3) == 0x00) &amp;&amp; ((MODE) != (u16)0x00))
-
-/* USART Hardware Flow Control -----------------------------------------------*/
-#define USART_HardwareFlowControl_None       ((u16)0x0000)
-#define USART_HardwareFlowControl_RTS        ((u16)0x0100)
-#define USART_HardwareFlowControl_CTS        ((u16)0x0200)
-#define USART_HardwareFlowControl_RTS_CTS    ((u16)0x0300)
-
+/** @defgroup USART_Hardware_Flow_Control 
+  * @{
+  */ 
+#define USART_HardwareFlowControl_None       ((uint16_t)0x0000)
+#define USART_HardwareFlowControl_RTS        ((uint16_t)0x0100)
+#define USART_HardwareFlowControl_CTS        ((uint16_t)0x0200)
+#define USART_HardwareFlowControl_RTS_CTS    ((uint16_t)0x0300)
 #define IS_USART_HARDWARE_FLOW_CONTROL(CONTROL)\
                               (((CONTROL) == USART_HardwareFlowControl_None) || \
                                ((CONTROL) == USART_HardwareFlowControl_RTS) || \
                                ((CONTROL) == USART_HardwareFlowControl_CTS) || \
                                ((CONTROL) == USART_HardwareFlowControl_RTS_CTS))
+/**
+  * @}
+  */ 
 
-#define IS_USART_PERIPH_HFC(PERIPH, HFC) ((((*(u32*)&amp;(PERIPH)) != UART4_BASE) &amp;&amp; \
-                                          ((*(u32*)&amp;(PERIPH)) != UART5_BASE)) \
-                                          || ((HFC) == USART_HardwareFlowControl_None))                                
-
-/* USART Clock ---------------------------------------------------------------*/
-#define USART_Clock_Disable                  ((u16)0x0000)
-#define USART_Clock_Enable                   ((u16)0x0800)
-
+/** @defgroup USART_Clock 
+  * @{
+  */ 
+#define USART_Clock_Disable                  ((uint16_t)0x0000)
+#define USART_Clock_Enable                   ((uint16_t)0x0800)
 #define IS_USART_CLOCK(CLOCK) (((CLOCK) == USART_Clock_Disable) || \
                                ((CLOCK) == USART_Clock_Enable))
+/**
+  * @}
+  */ 
 
-/* USART Clock Polarity ------------------------------------------------------*/
-#define USART_CPOL_Low                       ((u16)0x0000)
-#define USART_CPOL_High                      ((u16)0x0400)
+/** @defgroup USART_Clock_Polarity 
+  * @{
+  */
+  
+#define USART_CPOL_Low                       ((uint16_t)0x0000)
+#define USART_CPOL_High                      ((uint16_t)0x0400)
+#define IS_USART_CPOL(CPOL) (((CPOL) == USART_CPOL_Low) || ((CPOL) == USART_CPOL_High))
 
-#define IS_USART_CPOL(CPOL) (((CPOL) == USART_CPOL_Low) || ((CPOL) == USART_CPOL_High))
-                               
-/* USART Clock Phase ---------------------------------------------------------*/
-#define USART_CPHA_1Edge                     ((u16)0x0000)
-#define USART_CPHA_2Edge                     ((u16)0x0200)
+/**
+  * @}
+  */ 
+
+/** @defgroup USART_Clock_Phase
+  * @{
+  */
+
+#define USART_CPHA_1Edge                     ((uint16_t)0x0000)
+#define USART_CPHA_2Edge                     ((uint16_t)0x0200)
 #define IS_USART_CPHA(CPHA) (((CPHA) == USART_CPHA_1Edge) || ((CPHA) == USART_CPHA_2Edge))
 
-/* USART Last Bit ------------------------------------------------------------*/
-#define USART_LastBit_Disable                ((u16)0x0000)
-#define USART_LastBit_Enable                 ((u16)0x0100)
+/**
+  * @}
+  */
 
+/** @defgroup USART_Last_Bit
+  * @{
+  */
+
+#define USART_LastBit_Disable                ((uint16_t)0x0000)
+#define USART_LastBit_Enable                 ((uint16_t)0x0100)
 #define IS_USART_LASTBIT(LASTBIT) (((LASTBIT) == USART_LastBit_Disable) || \
                                    ((LASTBIT) == USART_LastBit_Enable))
+/**
+  * @}
+  */ 
 
-/* USART Interrupt definition ------------------------------------------------*/
-#define USART_IT_PE                          ((u16)0x0028)
-#define USART_IT_TXE                         ((u16)0x0727)
-#define USART_IT_TC                          ((u16)0x0626)
-#define USART_IT_RXNE                        ((u16)0x0525)
-#define USART_IT_IDLE                        ((u16)0x0424)
-#define USART_IT_LBD                         ((u16)0x0846)
-#define USART_IT_CTS                         ((u16)0x096A)
-#define USART_IT_ERR                         ((u16)0x0060)
-#define USART_IT_ORE                         ((u16)0x0360)
-#define USART_IT_NE                          ((u16)0x0260)
-#define USART_IT_FE                          ((u16)0x0160)
-
+/** @defgroup USART_Interrupt_definition 
+  * @{
+  */
+  
+#define USART_IT_PE                          ((uint16_t)0x0028)
+#define USART_IT_TXE                         ((uint16_t)0x0727)
+#define USART_IT_TC                          ((uint16_t)0x0626)
+#define USART_IT_RXNE                        ((uint16_t)0x0525)
+#define USART_IT_IDLE                        ((uint16_t)0x0424)
+#define USART_IT_LBD                         ((uint16_t)0x0846)
+#define USART_IT_CTS                         ((uint16_t)0x096A)
+#define USART_IT_ERR                         ((uint16_t)0x0060)
+#define USART_IT_ORE                         ((uint16_t)0x0360)
+#define USART_IT_NE                          ((uint16_t)0x0260)
+#define USART_IT_FE                          ((uint16_t)0x0160)
 #define IS_USART_CONFIG_IT(IT) (((IT) == USART_IT_PE) || ((IT) == USART_IT_TXE) || \
                                ((IT) == USART_IT_TC) || ((IT) == USART_IT_RXNE) || \
                                ((IT) == USART_IT_IDLE) || ((IT) == USART_IT_LBD) || \
                                ((IT) == USART_IT_CTS) || ((IT) == USART_IT_ERR))
-
 #define IS_USART_GET_IT(IT) (((IT) == USART_IT_PE) || ((IT) == USART_IT_TXE) || \
                             ((IT) == USART_IT_TC) || ((IT) == USART_IT_RXNE) || \
                             ((IT) == USART_IT_IDLE) || ((IT) == USART_IT_LBD) || \
                             ((IT) == USART_IT_CTS) || ((IT) == USART_IT_ORE) || \
                             ((IT) == USART_IT_NE) || ((IT) == USART_IT_FE))
-
 #define IS_USART_CLEAR_IT(IT) (((IT) == USART_IT_TC) || ((IT) == USART_IT_RXNE) || \
                                ((IT) == USART_IT_LBD) || ((IT) == USART_IT_CTS))
+/**
+  * @}
+  */
 
-#define IS_USART_PERIPH_IT(PERIPH, USART_IT) ((((*(u32*)&amp;(PERIPH)) != UART4_BASE) &amp;&amp; \
-                                              ((*(u32*)&amp;(PERIPH)) != UART5_BASE)) \
-                                              || ((USART_IT) != USART_IT_CTS))                                                                           
+/** @defgroup USART_DMA_Requests 
+  * @{
+  */
 
-/* USART DMA Requests --------------------------------------------------------*/
-#define USART_DMAReq_Tx                      ((u16)0x0080)
-#define USART_DMAReq_Rx                      ((u16)0x0040)
+#define USART_DMAReq_Tx                      ((uint16_t)0x0080)
+#define USART_DMAReq_Rx                      ((uint16_t)0x0040)
+#define IS_USART_DMAREQ(DMAREQ) ((((DMAREQ) &amp; (uint16_t)0xFF3F) == 0x00) &amp;&amp; ((DMAREQ) != (uint16_t)0x00))
 
-#define IS_USART_DMAREQ(DMAREQ) ((((DMAREQ) &amp; (u16)0xFF3F) == 0x00) &amp;&amp; ((DMAREQ) != (u16)0x00))
+/**
+  * @}
+  */ 
 
-/* USART WakeUp methods ------------------------------------------------------*/
-#define USART_WakeUp_IdleLine                ((u16)0x0000)
-#define USART_WakeUp_AddressMark             ((u16)0x0800)
+/** @defgroup USART_WakeUp_methods
+  * @{
+  */
 
+#define USART_WakeUp_IdleLine                ((uint16_t)0x0000)
+#define USART_WakeUp_AddressMark             ((uint16_t)0x0800)
 #define IS_USART_WAKEUP(WAKEUP) (((WAKEUP) == USART_WakeUp_IdleLine) || \
                                  ((WAKEUP) == USART_WakeUp_AddressMark))
+/**
+  * @}
+  */
 
-/* USART LIN Break Detection Length ------------------------------------------*/
-#define USART_LINBreakDetectLength_10b      ((u16)0x0000)
-#define USART_LINBreakDetectLength_11b      ((u16)0x0020)
-
+/** @defgroup USART_LIN_Break_Detection_Length 
+  * @{
+  */
+  
+#define USART_LINBreakDetectLength_10b      ((uint16_t)0x0000)
+#define USART_LINBreakDetectLength_11b      ((uint16_t)0x0020)
 #define IS_USART_LIN_BREAK_DETECT_LENGTH(LENGTH) \
                                (((LENGTH) == USART_LINBreakDetectLength_10b) || \
                                 ((LENGTH) == USART_LINBreakDetectLength_11b))
+/**
+  * @}
+  */
 
-/* USART IrDA Low Power ------------------------------------------------------*/
-#define USART_IrDAMode_LowPower              ((u16)0x0004)
-#define USART_IrDAMode_Normal                ((u16)0x0000)
+/** @defgroup USART_IrDA_Low_Power 
+  * @{
+  */
 
+#define USART_IrDAMode_LowPower              ((uint16_t)0x0004)
+#define USART_IrDAMode_Normal                ((uint16_t)0x0000)
 #define IS_USART_IRDA_MODE(MODE) (((MODE) == USART_IrDAMode_LowPower) || \
                                   ((MODE) == USART_IrDAMode_Normal))
+/**
+  * @}
+  */ 
 
-/* USART Flags ---------------------------------------------------------------*/
-#define USART_FLAG_CTS                       ((u16)0x0200)
-#define USART_FLAG_LBD                       ((u16)0x0100)
-#define USART_FLAG_TXE                       ((u16)0x0080)
-#define USART_FLAG_TC                        ((u16)0x0040)
-#define USART_FLAG_RXNE                      ((u16)0x0020)
-#define USART_FLAG_IDLE                      ((u16)0x0010)
-#define USART_FLAG_ORE                       ((u16)0x0008)
-#define USART_FLAG_NE                        ((u16)0x0004)
-#define USART_FLAG_FE                        ((u16)0x0002)
-#define USART_FLAG_PE                        ((u16)0x0001)
+/** @defgroup USART_Flags 
+  * @{
+  */
 
+#define USART_FLAG_CTS                       ((uint16_t)0x0200)
+#define USART_FLAG_LBD                       ((uint16_t)0x0100)
+#define USART_FLAG_TXE                       ((uint16_t)0x0080)
+#define USART_FLAG_TC                        ((uint16_t)0x0040)
+#define USART_FLAG_RXNE                      ((uint16_t)0x0020)
+#define USART_FLAG_IDLE                      ((uint16_t)0x0010)
+#define USART_FLAG_ORE                       ((uint16_t)0x0008)
+#define USART_FLAG_NE                        ((uint16_t)0x0004)
+#define USART_FLAG_FE                        ((uint16_t)0x0002)
+#define USART_FLAG_PE                        ((uint16_t)0x0001)
 #define IS_USART_FLAG(FLAG) (((FLAG) == USART_FLAG_PE) || ((FLAG) == USART_FLAG_TXE) || \
                              ((FLAG) == USART_FLAG_TC) || ((FLAG) == USART_FLAG_RXNE) || \
                              ((FLAG) == USART_FLAG_IDLE) || ((FLAG) == USART_FLAG_LBD) || \
                              ((FLAG) == USART_FLAG_CTS) || ((FLAG) == USART_FLAG_ORE) || \
                              ((FLAG) == USART_FLAG_NE) || ((FLAG) == USART_FLAG_FE))
                               
-#define IS_USART_CLEAR_FLAG(FLAG) ((((FLAG) &amp; (u16)0xFC9F) == 0x00) &amp;&amp; ((FLAG) != (u16)0x00))
-
-#define IS_USART_PERIPH_FLAG(PERIPH, USART_FLAG) ((((*(u32*)&amp;(PERIPH)) != UART4_BASE) &amp;&amp;\
-                                                  ((*(u32*)&amp;(PERIPH)) != UART5_BASE)) \
+#define IS_USART_CLEAR_FLAG(FLAG) ((((FLAG) &amp; (uint16_t)0xFC9F) == 0x00) &amp;&amp; ((FLAG) != (uint16_t)0x00))
+#define IS_USART_PERIPH_FLAG(PERIPH, USART_FLAG) ((((*(uint32_t*)&amp;(PERIPH)) != UART4_BASE) &amp;&amp;\
+                                                  ((*(uint32_t*)&amp;(PERIPH)) != UART5_BASE)) \
                                                   || ((USART_FLAG) != USART_FLAG_CTS)) 
-
 #define IS_USART_BAUDRATE(BAUDRATE) (((BAUDRATE) &gt; 0) &amp;&amp; ((BAUDRATE) &lt; 0x0044AA21))
 #define IS_USART_ADDRESS(ADDRESS) ((ADDRESS) &lt;= 0xF)
 #define IS_USART_DATA(DATA) ((DATA) &lt;= 0x1FF)
 
-/* Exported macro ------------------------------------------------------------*/
-/* Exported functions ------------------------------------------------------- */
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/** @defgroup USART_Exported_Macros
+  * @{
+  */ 
+
+/**
+  * @}
+  */ 
+
+/** @defgroup USART_Exported_Functions
+  * @{
+  */
+
 void USART_DeInit(USART_TypeDef* USARTx);
 void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct);
 void USART_StructInit(USART_InitTypeDef* USART_InitStruct);
 void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct);
 void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct);
 void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState);
-void USART_ITConfig(USART_TypeDef* USARTx, u16 USART_IT, FunctionalState NewState);
-void USART_DMACmd(USART_TypeDef* USARTx, u16 USART_DMAReq, FunctionalState NewState);
-void USART_SetAddress(USART_TypeDef* USARTx, u8 USART_Address);
-void USART_WakeUpConfig(USART_TypeDef* USARTx, u16 USART_WakeUp);
+void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState);
+void USART_DMACmd(USART_TypeDef* USARTx, uint16_t USART_DMAReq, FunctionalState NewState);
+void USART_SetAddress(USART_TypeDef* USARTx, uint8_t USART_Address);
+void USART_WakeUpConfig(USART_TypeDef* USARTx, uint16_t USART_WakeUp);
 void USART_ReceiverWakeUpCmd(USART_TypeDef* USARTx, FunctionalState NewState);
-void USART_LINBreakDetectLengthConfig(USART_TypeDef* USARTx, u16 USART_LINBreakDetectLength);
+void USART_LINBreakDetectLengthConfig(USART_TypeDef* USARTx, uint16_t USART_LINBreakDetectLength);
 void USART_LINCmd(USART_TypeDef* USARTx, FunctionalState NewState);
-void USART_SendData(USART_TypeDef* USARTx, u16 Data);
-u16 USART_ReceiveData(USART_TypeDef* USARTx);
+void USART_SendData(USART_TypeDef* USARTx, uint16_t Data);
+uint16_t USART_ReceiveData(USART_TypeDef* USARTx);
 void USART_SendBreak(USART_TypeDef* USARTx);
-void USART_SetGuardTime(USART_TypeDef* USARTx, u8 USART_GuardTime);
-void USART_SetPrescaler(USART_TypeDef* USARTx, u8 USART_Prescaler);
+void USART_SetGuardTime(USART_TypeDef* USARTx, uint8_t USART_GuardTime);
+void USART_SetPrescaler(USART_TypeDef* USARTx, uint8_t USART_Prescaler);
 void USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState);
 void USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState);
 void USART_HalfDuplexCmd(USART_TypeDef* USARTx, FunctionalState NewState);
-void USART_IrDAConfig(USART_TypeDef* USARTx, u16 USART_IrDAMode);
+void USART_IrDAConfig(USART_TypeDef* USARTx, uint16_t USART_IrDAMode);
 void USART_IrDACmd(USART_TypeDef* USARTx, FunctionalState NewState);
-FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, u16 USART_FLAG);
-void USART_ClearFlag(USART_TypeDef* USARTx, u16 USART_FLAG);
-ITStatus USART_GetITStatus(USART_TypeDef* USARTx, u16 USART_IT);
-void USART_ClearITPendingBit(USART_TypeDef* USARTx, u16 USART_IT);
+FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG);
+void USART_ClearFlag(USART_TypeDef* USARTx, uint16_t USART_FLAG);
+ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT);
+void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT);
 
+#ifdef __cplusplus
+}
+#endif
+
 #endif /* __STM32F10x_USART_H */
+/**
+  * @}
+  */ 
 
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/******************* (C) COPYRIGHT 2009 STMicroelectronics *****END OF FILE****/

Modified: trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_wwdg.h
===================================================================
--- trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_wwdg.h	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/inc/stm32f10x_wwdg.h	2009-07-08 23:39:34 UTC (rev 354)
@@ -1,54 +1,114 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_wwdg.h
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file contains all the functions prototypes for the
-*                      WWDG firmware library.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
+/**
+  ******************************************************************************
+  * @file    stm32f10x_wwdg.h
+  * @author  MCD Application Team
+  * @version V3.1.0
+  * @date    06/19/2009
+  * @brief   This file contains all the functions prototypes for the WWDG firmware
+  *          library.
+  ******************************************************************************
+  * @copy
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * &lt;h2&gt;&lt;center&gt;&copy; COPYRIGHT 2009 STMicroelectronics&lt;/center&gt;&lt;/h2&gt;
+  */ 
 
 /* Define to prevent recursive inclusion -------------------------------------*/
 #ifndef __STM32F10x_WWDG_H
 #define __STM32F10x_WWDG_H
 
+#ifdef __cplusplus
+ extern &quot;C&quot; {
+#endif
+
 /* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_map.h&quot;
+#include &quot;stm32f10x.h&quot;
 
-/* Exported types ------------------------------------------------------------*/
-/* Exported constants --------------------------------------------------------*/
-/* WWDG Prescaler */
-#define WWDG_Prescaler_1    ((u32)0x00000000)
-#define WWDG_Prescaler_2    ((u32)0x00000080)
-#define WWDG_Prescaler_4    ((u32)0x00000100)
-#define WWDG_Prescaler_8    ((u32)0x00000180)
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
 
+/** @addtogroup WWDG
+  * @{
+  */ 
+
+/** @defgroup WWDG_Exported_Types
+  * @{
+  */ 
+  
+/**
+  * @}
+  */ 
+
+/** @defgroup WWDG_Exported_Constants
+  * @{
+  */ 
+  
+/** @defgroup WWDG_Prescaler 
+  * @{
+  */ 
+  
+#define WWDG_Prescaler_1    ((uint32_t)0x00000000)
+#define WWDG_Prescaler_2    ((uint32_t)0x00000080)
+#define WWDG_Prescaler_4    ((uint32_t)0x00000100)
+#define WWDG_Prescaler_8    ((uint32_t)0x00000180)
 #define IS_WWDG_PRESCALER(PRESCALER) (((PRESCALER) == WWDG_Prescaler_1) || \
                                       ((PRESCALER) == WWDG_Prescaler_2) || \
                                       ((PRESCALER) == WWDG_Prescaler_4) || \
                                       ((PRESCALER) == WWDG_Prescaler_8))
-
 #define IS_WWDG_WINDOW_VALUE(VALUE) ((VALUE) &lt;= 0x7F)
-
 #define IS_WWDG_COUNTER(COUNTER) (((COUNTER) &gt;= 0x40) &amp;&amp; ((COUNTER) &lt;= 0x7F))
 
-/* Exported macro ------------------------------------------------------------*/
-/* Exported functions ------------------------------------------------------- */
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/** @defgroup WWDG_Exported_Macros
+  * @{
+  */ 
+/**
+  * @}
+  */ 
+
+/** @defgroup WWDG_Exported_Functions
+  * @{
+  */ 
+  
 void WWDG_DeInit(void);
-void WWDG_SetPrescaler(u32 WWDG_Prescaler);
-void WWDG_SetWindowValue(u8 WindowValue);
+void WWDG_SetPrescaler(uint32_t WWDG_Prescaler);
+void WWDG_SetWindowValue(uint8_t WindowValue);
 void WWDG_EnableIT(void);
-void WWDG_SetCounter(u8 Counter);
-void WWDG_Enable(u8 Counter);
+void WWDG_SetCounter(uint8_t Counter);
+void WWDG_Enable(uint8_t Counter);
 FlagStatus WWDG_GetFlagStatus(void);
 void WWDG_ClearFlag(void);
 
+#ifdef __cplusplus
+}
+#endif
+
 #endif /* __STM32F10x_WWDG_H */
 
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/******************* (C) COPYRIGHT 2009 STMicroelectronics *****END OF FILE****/

Added: trunk/src/platform/stm32/FWLib/library/src/misc.c
===================================================================
--- trunk/src/platform/stm32/FWLib/library/src/misc.c	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/src/misc.c	2009-07-08 23:39:34 UTC (rev 354)
@@ -0,0 +1,223 @@
+/**
+  ******************************************************************************
+  * @file    misc.c
+  * @author  MCD Application Team
+  * @version V3.1.0
+  * @date    06/19/2009
+  * @brief   This file provides all the miscellaneous firmware functions (add-on
+  *          to CMSIS functions).
+  ******************************************************************************
+  * @copy
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * &lt;h2&gt;&lt;center&gt;&copy; COPYRIGHT 2009 STMicroelectronics&lt;/center&gt;&lt;/h2&gt;
+  */ 
+
+/* Includes ------------------------------------------------------------------*/
+#include &quot;misc.h&quot;
+
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup MISC 
+  * @brief MISC driver modules
+  * @{
+  */
+
+/** @defgroup MISC_Private_TypesDefinitions
+  * @{
+  */
+
+/**
+  * @}
+  */ 
+
+/** @defgroup MISC_Private_Defines
+  * @{
+  */
+
+#define AIRCR_VECTKEY_MASK    ((uint32_t)0x05FA0000)
+/**
+  * @}
+  */
+
+/** @defgroup MISC_Private_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup MISC_Private_Variables
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup MISC_Private_FunctionPrototypes
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup MISC_Private_Functions
+  * @{
+  */
+
+/**
+  * @brief  Configures the priority grouping: pre-emption priority and subpriority.
+  * @param  NVIC_PriorityGroup: specifies the priority grouping bits length. 
+  *   This parameter can be one of the following values:
+  *     @arg NVIC_PriorityGroup_0: 0 bits for pre-emption priority
+  *                                4 bits for subpriority
+  *     @arg NVIC_PriorityGroup_1: 1 bits for pre-emption priority
+  *                                3 bits for subpriority
+  *     @arg NVIC_PriorityGroup_2: 2 bits for pre-emption priority
+  *                                2 bits for subpriority
+  *     @arg NVIC_PriorityGroup_3: 3 bits for pre-emption priority
+  *                                1 bits for subpriority
+  *     @arg NVIC_PriorityGroup_4: 4 bits for pre-emption priority
+  *                                0 bits for subpriority
+  * @retval None
+  */
+void NVIC_PriorityGroupConfig(uint32_t NVIC_PriorityGroup)
+{
+  /* Check the parameters */
+  assert_param(IS_NVIC_PRIORITY_GROUP(NVIC_PriorityGroup));
+  
+  /* Set the PRIGROUP[10:8] bits according to NVIC_PriorityGroup value */
+  SCB-&gt;AIRCR = AIRCR_VECTKEY_MASK | NVIC_PriorityGroup;
+}
+
+/**
+  * @brief  Initializes the NVIC peripheral according to the specified
+  *   parameters in the NVIC_InitStruct.
+  * @param  NVIC_InitStruct: pointer to a NVIC_InitTypeDef structure that contains
+  *   the configuration information for the specified NVIC peripheral.
+  * @retval None
+  */
+void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct)
+{
+  uint32_t tmppriority = 0x00, tmppre = 0x00, tmpsub = 0x0F;
+  
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NVIC_InitStruct-&gt;NVIC_IRQChannelCmd));
+  assert_param(IS_NVIC_PREEMPTION_PRIORITY(NVIC_InitStruct-&gt;NVIC_IRQChannelPreemptionPriority));  
+  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct-&gt;NVIC_IRQChannelSubPriority));
+    
+  if (NVIC_InitStruct-&gt;NVIC_IRQChannelCmd != DISABLE)
+  {
+    /* Compute the Corresponding IRQ Priority --------------------------------*/    
+    tmppriority = (0x700 - ((SCB-&gt;AIRCR) &amp; (uint32_t)0x700))&gt;&gt; 0x08;
+    tmppre = (0x4 - tmppriority);
+    tmpsub = tmpsub &gt;&gt; tmppriority;
+
+    tmppriority = (uint32_t)NVIC_InitStruct-&gt;NVIC_IRQChannelPreemptionPriority &lt;&lt; tmppre;
+    tmppriority |=  NVIC_InitStruct-&gt;NVIC_IRQChannelSubPriority &amp; tmpsub;
+    tmppriority = tmppriority &lt;&lt; 0x04;
+        
+    NVIC-&gt;IP[NVIC_InitStruct-&gt;NVIC_IRQChannel] = tmppriority;
+    
+    /* Enable the Selected IRQ Channels --------------------------------------*/
+    NVIC-&gt;ISER[NVIC_InitStruct-&gt;NVIC_IRQChannel &gt;&gt; 0x05] =
+      (uint32_t)0x01 &lt;&lt; (NVIC_InitStruct-&gt;NVIC_IRQChannel &amp; (uint8_t)0x1F);
+  }
+  else
+  {
+    /* Disable the Selected IRQ Channels -------------------------------------*/
+    NVIC-&gt;ICER[NVIC_InitStruct-&gt;NVIC_IRQChannel &gt;&gt; 0x05] =
+      (uint32_t)0x01 &lt;&lt; (NVIC_InitStruct-&gt;NVIC_IRQChannel &amp; (uint8_t)0x1F);
+  }
+}
+
+/**
+  * @brief  Sets the vector table location and Offset.
+  * @param  NVIC_VectTab: specifies if the vector table is in RAM or FLASH memory.
+  *   This parameter can be one of the following values:
+  *     @arg NVIC_VectTab_RAM
+  *     @arg NVIC_VectTab_FLASH
+  * @param  Offset: Vector Table base offset field. This value must be a multiple of 0x100.
+  * @retval None
+  */
+void NVIC_SetVectorTable(uint32_t NVIC_VectTab, uint32_t Offset)
+{ 
+  /* Check the parameters */
+  assert_param(IS_NVIC_VECTTAB(NVIC_VectTab));
+  assert_param(IS_NVIC_OFFSET(Offset));  
+   
+  SCB-&gt;VTOR = NVIC_VectTab | (Offset &amp; (uint32_t)0x1FFFFF80);
+}
+
+/**
+  * @brief  Selects the condition for the system to enter low power mode.
+  * @param  LowPowerMode: Specifies the new mode for the system to enter low power mode.
+  *   This parameter can be one of the following values:
+  *     @arg NVIC_LP_SEVONPEND
+  *     @arg NVIC_LP_SLEEPDEEP
+  *     @arg NVIC_LP_SLEEPONEXIT
+  * @param  NewState: new state of LP condition. This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void NVIC_SystemLPConfig(uint8_t LowPowerMode, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_NVIC_LP(LowPowerMode));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));  
+  
+  if (NewState != DISABLE)
+  {
+    SCB-&gt;SCR |= LowPowerMode;
+  }
+  else
+  {
+    SCB-&gt;SCR &amp;= (uint32_t)(~(uint32_t)LowPowerMode);
+  }
+}
+
+/**
+  * @brief  Configures the SysTick clock source.
+  * @param  SysTick_CLKSource: specifies the SysTick clock source.
+  *   This parameter can be one of the following values:
+  *     @arg SysTick_CLKSource_HCLK_Div8: AHB clock divided by 8 selected as SysTick clock source.
+  *     @arg SysTick_CLKSource_HCLK: AHB clock selected as SysTick clock source.
+  * @retval None
+  */
+void SysTick_CLKSourceConfig(uint32_t SysTick_CLKSource)
+{
+  /* Check the parameters */
+  assert_param(IS_SYSTICK_CLK_SOURCE(SysTick_CLKSource));
+  if (SysTick_CLKSource == SysTick_CLKSource_HCLK)
+  {
+    SysTick-&gt;CTRL |= SysTick_CLKSource_HCLK;
+  }
+  else
+  {
+    SysTick-&gt;CTRL &amp;= SysTick_CLKSource_HCLK_Div8;
+  }
+}
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2009 STMicroelectronics *****END OF FILE****/


Property changes on: trunk/src/platform/stm32/FWLib/library/src/misc.c
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/platform/stm32/FWLib/library/src/misc.o
===================================================================
--- trunk/src/platform/stm32/FWLib/library/src/misc.o	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/src/misc.o	2009-07-08 23:39:34 UTC (rev 354)
@@ -0,0 +1,3 @@
+ELF
+M	
+
\ No newline at end of file

Modified: trunk/src/platform/stm32/FWLib/library/src/stm32f10x_adc.c
===================================================================
--- trunk/src/platform/stm32/FWLib/library/src/stm32f10x_adc.c	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/src/stm32f10x_adc.c	2009-07-08 23:39:34 UTC (rev 354)
@@ -1,1402 +1,1306 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_adc.c
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file provides all the ADC firmware functions.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
-
-/* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_adc.h&quot;
-#include &quot;stm32f10x_rcc.h&quot;
-
-/* Private typedef -----------------------------------------------------------*/
-/* Private define ------------------------------------------------------------*/
-/* ADC DISCNUM mask */
-#define CR1_DISCNUM_Reset           ((u32)0xFFFF1FFF)
-
-/* ADC DISCEN mask */
-#define CR1_DISCEN_Set              ((u32)0x00000800)
-#define CR1_DISCEN_Reset            ((u32)0xFFFFF7FF)
-
-/* ADC JAUTO mask */
-#define CR1_JAUTO_Set               ((u32)0x00000400)
-#define CR1_JAUTO_Reset             ((u32)0xFFFFFBFF)
-
-/* ADC JDISCEN mask */
-#define CR1_JDISCEN_Set             ((u32)0x00001000)
-#define CR1_JDISCEN_Reset           ((u32)0xFFFFEFFF)
-
-/* ADC AWDCH mask */
-#define CR1_AWDCH_Reset             ((u32)0xFFFFFFE0)
-
-/* ADC Analog watchdog enable mode mask */
-#define CR1_AWDMode_Reset           ((u32)0xFF3FFDFF)
-
-/* CR1 register Mask */
-#define CR1_CLEAR_Mask              ((u32)0xFFF0FEFF)
-
-/* ADC ADON mask */
-#define CR2_ADON_Set                ((u32)0x00000001)
-#define CR2_ADON_Reset              ((u32)0xFFFFFFFE)
-
-/* ADC DMA mask */
-#define CR2_DMA_Set                 ((u32)0x00000100)
-#define CR2_DMA_Reset               ((u32)0xFFFFFEFF)
-
-/* ADC RSTCAL mask */
-#define CR2_RSTCAL_Set              ((u32)0x00000008)
-
-/* ADC CAL mask */
-#define CR2_CAL_Set                 ((u32)0x00000004)
-
-/* ADC SWSTART mask */
-#define CR2_SWSTART_Set             ((u32)0x00400000)
-
-/* ADC EXTTRIG mask */
-#define CR2_EXTTRIG_Set             ((u32)0x00100000)
-#define CR2_EXTTRIG_Reset           ((u32)0xFFEFFFFF)
-
-/* ADC Software start mask */
-#define CR2_EXTTRIG_SWSTART_Set     ((u32)0x00500000)
-#define CR2_EXTTRIG_SWSTART_Reset   ((u32)0xFFAFFFFF)
-
-/* ADC JEXTSEL mask */
-#define CR2_JEXTSEL_Reset           ((u32)0xFFFF8FFF)
-
-/* ADC JEXTTRIG mask */
-#define CR2_JEXTTRIG_Set            ((u32)0x00008000)
-#define CR2_JEXTTRIG_Reset          ((u32)0xFFFF7FFF)
-
-/* ADC JSWSTART mask */
-#define CR2_JSWSTART_Set            ((u32)0x00200000)
-
-/* ADC injected software start mask */
-#define CR2_JEXTTRIG_JSWSTART_Set   ((u32)0x00208000)
-#define CR2_JEXTTRIG_JSWSTART_Reset ((u32)0xFFDF7FFF)
-
-/* ADC TSPD mask */
-#define CR2_TSVREFE_Set             ((u32)0x00800000)
-#define CR2_TSVREFE_Reset           ((u32)0xFF7FFFFF)
-
-/* CR2 register Mask */
-#define CR2_CLEAR_Mask              ((u32)0xFFF1F7FD)
-
-/* ADC SQx mask */
-#define SQR3_SQ_Set                 ((u32)0x0000001F)
-#define SQR2_SQ_Set                 ((u32)0x0000001F)
-#define SQR1_SQ_Set                 ((u32)0x0000001F)
-
-/* SQR1 register Mask */
-#define SQR1_CLEAR_Mask             ((u32)0xFF0FFFFF)
-
-/* ADC JSQx mask */
-#define JSQR_JSQ_Set                ((u32)0x0000001F)
-
-/* ADC JL mask */
-#define JSQR_JL_Set                 ((u32)0x00300000)
-#define JSQR_JL_Reset               ((u32)0xFFCFFFFF)
-
-/* ADC SMPx mask */
-#define SMPR1_SMP_Set               ((u32)0x00000007)
-#define SMPR2_SMP_Set               ((u32)0x00000007)
-
-/* ADC JDRx registers offset */
-#define JDR_Offset                  ((u8)0x28)
-
-/* ADC1 DR register base address */
-#define DR_ADDRESS                  ((u32)0x4001244C)
-
-/* Private macro -------------------------------------------------------------*/
-/* Private variables ---------------------------------------------------------*/
-/* Private function prototypes -----------------------------------------------*/
-/* Private functions ---------------------------------------------------------*/
-
-/*******************************************************************************
-* Function Name  : ADC_DeInit
-* Description    : Deinitializes the ADCx peripheral registers to their default
-*                  reset values.
-* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void ADC_DeInit(ADC_TypeDef* ADCx)
-{
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-
-  switch (*(u32*)&amp;ADCx)
-  {
-    case ADC1_BASE:
-      /* Enable ADC1 reset state */
-      RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, ENABLE);
-      /* Release ADC1 from reset state */
-      RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, DISABLE);
-      break;
-    
-    case ADC2_BASE:
-      /* Enable ADC2 reset state */
-      RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC2, ENABLE);
-      /* Release ADC2 from reset state */
-      RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC2, DISABLE);
-      break;
-      
-    case ADC3_BASE:
-      /* Enable ADC3 reset state */
-      RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC3, ENABLE);
-      /* Release ADC3 from reset state */
-      RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC3, DISABLE);
-      break; 
-
-    default:
-      break;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : ADC_Init
-* Description    : Initializes the ADCx peripheral according to the specified parameters
-*                  in the ADC_InitStruct.
-* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-*                  - ADC_InitStruct: pointer to an ADC_InitTypeDef structure that
-*                    contains the configuration information for the specified
-*                    ADC peripheral.
-* Output         : None
-* Return         : None
-******************************************************************************/
-void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)
-{
-  u32 tmpreg1 = 0;
-  u8 tmpreg2 = 0;
-
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  assert_param(IS_ADC_MODE(ADC_InitStruct-&gt;ADC_Mode));
-  assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct-&gt;ADC_ScanConvMode));
-  assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct-&gt;ADC_ContinuousConvMode));  		    
-  assert_param(IS_ADC_EXT_TRIG(ADC_InitStruct-&gt;ADC_ExternalTrigConv));   
-  assert_param(IS_ADC_DATA_ALIGN(ADC_InitStruct-&gt;ADC_DataAlign)); 
-  assert_param(IS_ADC_REGULAR_LENGTH(ADC_InitStruct-&gt;ADC_NbrOfChannel));
-
-  /*---------------------------- ADCx CR1 Configuration -----------------*/
-  /* Get the ADCx CR1 value */
-  tmpreg1 = ADCx-&gt;CR1;
-  /* Clear DUALMOD and SCAN bits */
-  tmpreg1 &amp;= CR1_CLEAR_Mask;
-  /* Configure ADCx: Dual mode and scan conversion mode */
-  /* Set DUALMOD bits according to ADC_Mode value */
-  /* Set SCAN bit according to ADC_ScanConvMode value */
-  tmpreg1 |= (u32)(ADC_InitStruct-&gt;ADC_Mode | ((u32)ADC_InitStruct-&gt;ADC_ScanConvMode &lt;&lt; 8));
-  /* Write to ADCx CR1 */
-  ADCx-&gt;CR1 = tmpreg1;
-
-  /*---------------------------- ADCx CR2 Configuration -----------------*/
-  /* Get the ADCx CR2 value */
-  tmpreg1 = ADCx-&gt;CR2;
-  /* Clear CONT, ALIGN and EXTSEL bits */
-  tmpreg1 &amp;= CR2_CLEAR_Mask;
-  /* Configure ADCx: external trigger event and continuous conversion mode */
-  /* Set ALIGN bit according to ADC_DataAlign value */
-  /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
-  /* Set CONT bit according to ADC_ContinuousConvMode value */
-  tmpreg1 |= (u32)(ADC_InitStruct-&gt;ADC_DataAlign | ADC_InitStruct-&gt;ADC_ExternalTrigConv |
-            ((u32)ADC_InitStruct-&gt;ADC_ContinuousConvMode &lt;&lt; 1));
-  /* Write to ADCx CR2 */
-  ADCx-&gt;CR2 = tmpreg1;
-
-  /*---------------------------- ADCx SQR1 Configuration -----------------*/
-  /* Get the ADCx SQR1 value */
-  tmpreg1 = ADCx-&gt;SQR1;
-  /* Clear L bits */
-  tmpreg1 &amp;= SQR1_CLEAR_Mask;
-  /* Configure ADCx: regular channel sequence length */
-  /* Set L bits according to ADC_NbrOfChannel value */
-  tmpreg2 |= (ADC_InitStruct-&gt;ADC_NbrOfChannel - 1);
-  tmpreg1 |= ((u32)tmpreg2 &lt;&lt; 20);
-  /* Write to ADCx SQR1 */
-  ADCx-&gt;SQR1 = tmpreg1;
-}
-
-/*******************************************************************************
-* Function Name  : ADC_StructInit
-* Description    : Fills each ADC_InitStruct member with its default value.
-* Input          : ADC_InitStruct : pointer to an ADC_InitTypeDef structure
-*                  which will be initialized.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)
-{
-  /* Reset ADC init structure parameters values */
-  /* Initialize the ADC_Mode member */
-  ADC_InitStruct-&gt;ADC_Mode = ADC_Mode_Independent;
-
-  /* initialize the ADC_ScanConvMode member */
-  ADC_InitStruct-&gt;ADC_ScanConvMode = DISABLE;
-
-  /* Initialize the ADC_ContinuousConvMode member */
-  ADC_InitStruct-&gt;ADC_ContinuousConvMode = DISABLE;
-
-  /* Initialize the ADC_ExternalTrigConv member */
-  ADC_InitStruct-&gt;ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;
-
-  /* Initialize the ADC_DataAlign member */
-  ADC_InitStruct-&gt;ADC_DataAlign = ADC_DataAlign_Right;
-
-  /* Initialize the ADC_NbrOfChannel member */
-  ADC_InitStruct-&gt;ADC_NbrOfChannel = 1;
-}
-
-/*******************************************************************************
-* Function Name  : ADC_Cmd
-* Description    : Enables or disables the specified ADC peripheral.
-* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-*                  - NewState: new state of the ADCx peripheral. This parameter
-*                    can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Set the ADON bit to wake up the ADC from power down mode */
-    ADCx-&gt;CR2 |= CR2_ADON_Set;
-  }
-  else
-  {
-    /* Disable the selected ADC peripheral */
-    ADCx-&gt;CR2 &amp;= CR2_ADON_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : ADC_DMACmd
-* Description    : Enables or disables the specified ADC DMA request.
-* Input          : - ADCx: where x can be 1 or 3 to select the ADC peripheral.
-*                    Note: ADC2 hasn't a DMA capability.
-*                  - NewState: new state of the selected ADC DMA transfer.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_ADC_DMA_PERIPH(ADCx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected ADC DMA request */
-    ADCx-&gt;CR2 |= CR2_DMA_Set;
-  }
-  else
-  {
-    /* Disable the selected ADC DMA request */
-    ADCx-&gt;CR2 &amp;= CR2_DMA_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : ADC_ITConfig
-* Description    : Enables or disables the specified ADC interrupts.
-* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-*                  - ADC_IT: specifies the ADC interrupt sources to be enabled
-*                    or disabled. 
-*                    This parameter can be any combination of the following values:
-*                       - ADC_IT_EOC: End of conversion interrupt mask
-*                       - ADC_IT_AWD: Analog watchdog interrupt mask
-*                       - ADC_IT_JEOC: End of injected conversion interrupt mask
-*                  - NewState: new state of the specified ADC interrupts.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void ADC_ITConfig(ADC_TypeDef* ADCx, u16 ADC_IT, FunctionalState NewState)
-{
-  u8 itmask = 0;
-
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  assert_param(IS_ADC_IT(ADC_IT));
-
-  /* Get the ADC IT index */
-  itmask = (u8)ADC_IT;
-
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected ADC interrupts */
-    ADCx-&gt;CR1 |= itmask;
-  }
-  else
-  {
-    /* Disable the selected ADC interrupts */
-    ADCx-&gt;CR1 &amp;= (~(u32)itmask);
-  }
-}
-
-/*******************************************************************************
-* Function Name  : ADC_ResetCalibration
-* Description    : Resets the selected ADC calibration registers.
-* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void ADC_ResetCalibration(ADC_TypeDef* ADCx)
-{
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-
-  /* Resets the selected ADC calibartion registers */  
-  ADCx-&gt;CR2 |= CR2_RSTCAL_Set;
-}
-
-/*******************************************************************************
-* Function Name  : ADC_GetResetCalibrationStatus
-* Description    : Gets the selected ADC reset calibration registers status.
-* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-* Output         : None
-* Return         : The new state of ADC reset calibration registers (SET or RESET).
-*******************************************************************************/
-FlagStatus ADC_GetResetCalibrationStatus(ADC_TypeDef* ADCx)
-{
-  FlagStatus bitstatus = RESET;
-
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-
-  /* Check the status of RSTCAL bit */
-  if ((ADCx-&gt;CR2 &amp; CR2_RSTCAL_Set) != (u32)RESET)
-  {
-    /* RSTCAL bit is set */
-    bitstatus = SET;
-  }
-  else
-  {
-    /* RSTCAL bit is reset */
-    bitstatus = RESET;
-  }
-
-  /* Return the RSTCAL bit status */
-  return  bitstatus;
-}
-
-/*******************************************************************************
-* Function Name  : ADC_StartCalibration
-* Description    : Starts the selected ADC calibration process.
-* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void ADC_StartCalibration(ADC_TypeDef* ADCx)
-{
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-
-  /* Enable the selected ADC calibration process */  
-  ADCx-&gt;CR2 |= CR2_CAL_Set;
-}
-
-/*******************************************************************************
-* Function Name  : ADC_GetCalibrationStatus
-* Description    : Gets the selected ADC calibration status.
-* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-* Output         : None
-* Return         : The new state of ADC calibration (SET or RESET).
-*******************************************************************************/
-FlagStatus ADC_GetCalibrationStatus(ADC_TypeDef* ADCx)
-{
-  FlagStatus bitstatus = RESET;
-
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-
-  /* Check the status of CAL bit */
-  if ((ADCx-&gt;CR2 &amp; CR2_CAL_Set) != (u32)RESET)
-  {
-    /* CAL bit is set: calibration on going */
-    bitstatus = SET;
-  }
-  else
-  {
-    /* CAL bit is reset: end of calibration */
-    bitstatus = RESET;
-  }
-
-  /* Return the CAL bit status */
-  return  bitstatus;
-}
-
-/*******************************************************************************
-* Function Name  : ADC_SoftwareStartConvCmd
-* Description    : Enables or disables the selected ADC software start conversion .
-* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-*                  - NewState: new state of the selected ADC software start conversion.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void ADC_SoftwareStartConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected ADC conversion on external event and start the selected
-       ADC conversion */
-    ADCx-&gt;CR2 |= CR2_EXTTRIG_SWSTART_Set;
-  }
-  else
-  {
-    /* Disable the selected ADC conversion on external event and stop the selected
-       ADC conversion */
-    ADCx-&gt;CR2 &amp;= CR2_EXTTRIG_SWSTART_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : ADC_GetSoftwareStartConvStatus
-* Description    : Gets the selected ADC Software start conversion Status.
-* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-* Output         : None
-* Return         : The new state of ADC software start conversion (SET or RESET).
-*******************************************************************************/
-FlagStatus ADC_GetSoftwareStartConvStatus(ADC_TypeDef* ADCx)
-{
-  FlagStatus bitstatus = RESET;
-
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-
-  /* Check the status of SWSTART bit */
-  if ((ADCx-&gt;CR2 &amp; CR2_SWSTART_Set) != (u32)RESET)
-  {
-    /* SWSTART bit is set */
-    bitstatus = SET;
-  }
-  else
-  {
-    /* SWSTART bit is reset */
-    bitstatus = RESET;
-  }
-
-  /* Return the SWSTART bit status */
-  return  bitstatus;
-}
-
-/*******************************************************************************
-* Function Name  : ADC_DiscModeChannelCountConfig
-* Description    : Configures the discontinuous mode for the selected ADC regular
-*                  group channel.
-* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-*                  - Number: specifies the discontinuous mode regular channel
-*                    count value. This number must be between 1 and 8.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void ADC_DiscModeChannelCountConfig(ADC_TypeDef* ADCx, u8 Number)
-{
-  u32 tmpreg1 = 0;
-  u32 tmpreg2 = 0;
-
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  assert_param(IS_ADC_REGULAR_DISC_NUMBER(Number));
-
-  /* Get the old register value */
-  tmpreg1 = ADCx-&gt;CR1;
-  /* Clear the old discontinuous mode channel count */
-  tmpreg1 &amp;= CR1_DISCNUM_Reset;
-  /* Set the discontinuous mode channel count */
-  tmpreg2 = Number - 1;
-  tmpreg1 |= tmpreg2 &lt;&lt; 13;
-  /* Store the new register value */
-  ADCx-&gt;CR1 = tmpreg1;
-}
-
-/*******************************************************************************
-* Function Name  : ADC_DiscModeCmd
-* Description    : Enables or disables the discontinuous mode on regular group
-*                  channel for the specified ADC
-* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-*                  - NewState: new state of the selected ADC discontinuous mode
-*                    on regular group channel.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void ADC_DiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected ADC regular discontinuous mode */
-    ADCx-&gt;CR1 |= CR1_DISCEN_Set;
-  }
-  else
-  {
-    /* Disable the selected ADC regular discontinuous mode */
-    ADCx-&gt;CR1 &amp;= CR1_DISCEN_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : ADC_RegularChannelConfig
-* Description    : Configures for the selected ADC regular channel its corresponding
-*                  rank in the sequencer and its sample time.
-* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-*                  - ADC_Channel: the ADC channel to configure. 
-*                    This parameter can be one of the following values:
-*                       - ADC_Channel_0: ADC Channel0 selected
-*                       - ADC_Channel_1: ADC Channel1 selected
-*                       - ADC_Channel_2: ADC Channel2 selected
-*                       - ADC_Channel_3: ADC Channel3 selected
-*                       - ADC_Channel_4: ADC Channel4 selected
-*                       - ADC_Channel_5: ADC Channel5 selected
-*                       - ADC_Channel_6: ADC Channel6 selected
-*                       - ADC_Channel_7: ADC Channel7 selected
-*                       - ADC_Channel_8: ADC Channel8 selected
-*                       - ADC_Channel_9: ADC Channel9 selected
-*                       - ADC_Channel_10: ADC Channel10 selected
-*                       - ADC_Channel_11: ADC Channel11 selected
-*                       - ADC_Channel_12: ADC Channel12 selected
-*                       - ADC_Channel_13: ADC Channel13 selected
-*                       - ADC_Channel_14: ADC Channel14 selected
-*                       - ADC_Channel_15: ADC Channel15 selected
-*                       - ADC_Channel_16: ADC Channel16 selected
-*                       - ADC_Channel_17: ADC Channel17 selected
-*                  - Rank: The rank in the regular group sequencer. This parameter
-*                    must be between 1 to 16.
-*                  - ADC_SampleTime: The sample time value to be set for the
-*                    selected channel. 
-*                    This parameter can be one of the following values:
-*                       - ADC_SampleTime_1Cycles5: Sample time equal to 1.5 cycles
-*                       - ADC_SampleTime_7Cycles5: Sample time equal to 7.5 cycles
-*                       - ADC_SampleTime_13Cycles5: Sample time equal to 13.5 cycles
-*                       - ADC_SampleTime_28Cycles5: Sample time equal to 28.5 cycles	
-*                       - ADC_SampleTime_41Cycles5: Sample time equal to 41.5 cycles	
-*                       - ADC_SampleTime_55Cycles5: Sample time equal to 55.5 cycles	
-*                       - ADC_SampleTime_71Cycles5: Sample time equal to 71.5 cycles	
-*                       - ADC_SampleTime_239Cycles5: Sample time equal to 239.5 cycles	
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, u8 ADC_Channel, u8 Rank, u8 ADC_SampleTime)
-{
-  u32 tmpreg1 = 0, tmpreg2 = 0;
-
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  assert_param(IS_ADC_CHANNEL(ADC_Channel));
-  assert_param(IS_ADC_REGULAR_RANK(Rank));
-  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
-
-  /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
-  if (ADC_Channel &gt; ADC_Channel_9)
-  {
-    /* Get the old register value */
-    tmpreg1 = ADCx-&gt;SMPR1;
-    /* Calculate the mask to clear */
-    tmpreg2 = SMPR1_SMP_Set &lt;&lt; (3 * (ADC_Channel - 10));
-    /* Clear the old discontinuous mode channel count */
-    tmpreg1 &amp;= ~tmpreg2;
-    /* Calculate the mask to set */
-    tmpreg2 = (u32)ADC_SampleTime &lt;&lt; (3 * (ADC_Channel - 10));
-    /* Set the discontinuous mode channel count */
-    tmpreg1 |= tmpreg2;
-    /* Store the new register value */
-    ADCx-&gt;SMPR1 = tmpreg1;
-  }
-  else /* ADC_Channel include in ADC_Channel_[0..9] */
-  {
-    /* Get the old register value */
-    tmpreg1 = ADCx-&gt;SMPR2;
-    /* Calculate the mask to clear */
-    tmpreg2 = SMPR2_SMP_Set &lt;&lt; (3 * ADC_Channel);
-    /* Clear the old discontinuous mode channel count */
-    tmpreg1 &amp;= ~tmpreg2;
-    /* Calculate the mask to set */
-    tmpreg2 = (u32)ADC_SampleTime &lt;&lt; (3 * ADC_Channel);
-    /* Set the discontinuous mode channel count */
-    tmpreg1 |= tmpreg2;
-    /* Store the new register value */
-    ADCx-&gt;SMPR2 = tmpreg1;
-  }
-  /* For Rank 1 to 6 */
-  if (Rank &lt; 7)
-  {
-    /* Get the old register value */
-    tmpreg1 = ADCx-&gt;SQR3;
-    /* Calculate the mask to clear */
-    tmpreg2 = SQR3_SQ_Set &lt;&lt; (5 * (Rank - 1));
-    /* Clear the old SQx bits for the selected rank */
-    tmpreg1 &amp;= ~tmpreg2;
-    /* Calculate the mask to set */
-    tmpreg2 = (u32)ADC_Channel &lt;&lt; (5 * (Rank - 1));
-    /* Set the SQx bits for the selected rank */
-    tmpreg1 |= tmpreg2;
-    /* Store the new register value */
-    ADCx-&gt;SQR3 = tmpreg1;
-  }
-  /* For Rank 7 to 12 */
-  else if (Rank &lt; 13)
-  {
-    /* Get the old register value */
-    tmpreg1 = ADCx-&gt;SQR2;
-    /* Calculate the mask to clear */
-    tmpreg2 = SQR2_SQ_Set &lt;&lt; (5 * (Rank - 7));
-    /* Clear the old SQx bits for the selected rank */
-    tmpreg1 &amp;= ~tmpreg2;
-    /* Calculate the mask to set */
-    tmpreg2 = (u32)ADC_Channel &lt;&lt; (5 * (Rank - 7));
-    /* Set the SQx bits for the selected rank */
-    tmpreg1 |= tmpreg2;
-    /* Store the new register value */
-    ADCx-&gt;SQR2 = tmpreg1;
-  }
-  /* For Rank 13 to 16 */
-  else
-  {
-    /* Get the old register value */
-    tmpreg1 = ADCx-&gt;SQR1;
-    /* Calculate the mask to clear */
-    tmpreg2 = SQR1_SQ_Set &lt;&lt; (5 * (Rank - 13));
-    /* Clear the old SQx bits for the selected rank */
-    tmpreg1 &amp;= ~tmpreg2;
-    /* Calculate the mask to set */
-    tmpreg2 = (u32)ADC_Channel &lt;&lt; (5 * (Rank - 13));
-    /* Set the SQx bits for the selected rank */
-    tmpreg1 |= tmpreg2;
-    /* Store the new register value */
-    ADCx-&gt;SQR1 = tmpreg1;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : ADC_ExternalTrigConvCmd
-* Description    : Enables or disables the ADCx conversion through external trigger.
-* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-*                  - NewState: new state of the selected ADC external trigger
-*                    start of conversion.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void ADC_ExternalTrigConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected ADC conversion on external event */
-    ADCx-&gt;CR2 |= CR2_EXTTRIG_Set;
-  }
-  else
-  {
-    /* Disable the selected ADC conversion on external event */
-    ADCx-&gt;CR2 &amp;= CR2_EXTTRIG_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : ADC_GetConversionValue
-* Description    : Returns the last ADCx conversion result data for regular channel.
-* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-* Output         : None
-* Return         : The Data conversion value.
-*******************************************************************************/
-u16 ADC_GetConversionValue(ADC_TypeDef* ADCx)
-{
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-
-  /* Return the selected ADC conversion value */
-  return (u16) ADCx-&gt;DR;
-}
-
-/*******************************************************************************
-* Function Name  : ADC_GetDualModeConversionValue
-* Description    : Returns the last ADC1 and ADC2 conversion result data in dual mode.
-* Output         : None
-* Return         : The Data conversion value.
-*******************************************************************************/
-u32 ADC_GetDualModeConversionValue(void)
-{
-  /* Return the dual mode conversion value */
-  return (*(vu32 *) DR_ADDRESS);
-}
-
-/*******************************************************************************
-* Function Name  : ADC_AutoInjectedConvCmd
-* Description    : Enables or disables the selected ADC automatic injected group
-*                  conversion after regular one.
-* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-*                  - NewState: new state of the selected ADC auto injected
-*                    conversion
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void ADC_AutoInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected ADC automatic injected group conversion */
-    ADCx-&gt;CR1 |= CR1_JAUTO_Set;
-  }
-  else
-  {
-    /* Disable the selected ADC automatic injected group conversion */
-    ADCx-&gt;CR1 &amp;= CR1_JAUTO_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : ADC_InjectedDiscModeCmd
-* Description    : Enables or disables the discontinuous mode for injected group
-*                  channel for the specified ADC
-* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-*                  - NewState: new state of the selected ADC discontinuous mode
-*                    on injected group channel.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void ADC_InjectedDiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected ADC injected discontinuous mode */
-    ADCx-&gt;CR1 |= CR1_JDISCEN_Set;
-  }
-  else
-  {
-    /* Disable the selected ADC injected discontinuous mode */
-    ADCx-&gt;CR1 &amp;= CR1_JDISCEN_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : ADC_ExternalTrigInjectedConvConfig
-* Description    : Configures the ADCx external trigger for injected channels conversion.
-* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-*                  - ADC_ExternalTrigInjecConv: specifies the ADC trigger to
-*                    start injected conversion. 
-*                    This parameter can be one of the following values:
-*                       - ADC_ExternalTrigInjecConv_T1_TRGO: Timer1 TRGO event 
-*                         selected (for ADC1, ADC2 and ADC3)
-*                       - ADC_ExternalTrigInjecConv_T1_CC4: Timer1 capture
-*                         compare4 selected (for ADC1, ADC2 and ADC3)
-*                       - ADC_ExternalTrigInjecConv_T2_TRGO: Timer2 TRGO event
-*                         selected (for ADC1 and ADC2)
-*                       - ADC_External TrigInjecConv_T2_CC1: Timer2 capture
-*                         compare1 selected (for ADC1 and ADC2)
-*                       - ADC_ExternalTrigInjecConv_T3_CC4: Timer3 capture
-*                         compare4 selected (for ADC1 and ADC2)
-*                       - ADC_ExternalTrigInjecConv_T4_TRGO: Timer4 TRGO event
-*                         selected (for ADC1 and ADC2)
-*                       - ADC_ExternalTrigInjecConv_Ext_IT15_TIM8_CC4: External
-*                         interrupt line 15 or Timer8 capture compare4 event selected
-*                         (for ADC1 and ADC2)                       
-*                       - ADC_External TrigInjecConv_T4_CC3: Timer4 capture
-*                         compare3 selected (for ADC3 only)
-*                       - ADC_External TrigInjecConv_T8_CC2: Timer8 capture
-*                         compare2 selected (for ADC3 only)                         
-*                       - ADC_External TrigInjecConv_T8_CC4: Timer8 capture
-*                         compare4 selected (for ADC3 only)
-*                       - ADC_ExternalTrigInjecConv_T5_TRGO: Timer5 TRGO event
-*                         selected (for ADC3 only)                         
-*                       - ADC_External TrigInjecConv_T5_CC4: Timer5 capture
-*                         compare4 selected (for ADC3 only)                        
-*                       - ADC_ExternalTrigInjecConv_None: Injected conversion
-*                         started by software and not by external trigger (for 
-*                         ADC1, ADC2 and ADC3)
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void ADC_ExternalTrigInjectedConvConfig(ADC_TypeDef* ADCx, u32 ADC_ExternalTrigInjecConv)
-{
-  u32 tmpreg = 0;
-
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  assert_param(IS_ADC_EXT_INJEC_TRIG(ADC_ExternalTrigInjecConv));
-
-  /* Get the old register value */
-  tmpreg = ADCx-&gt;CR2;
-  /* Clear the old external event selection for injected group */
-  tmpreg &amp;= CR2_JEXTSEL_Reset;
-  /* Set the external event selection for injected group */
-  tmpreg |= ADC_ExternalTrigInjecConv;
-  /* Store the new register value */
-  ADCx-&gt;CR2 = tmpreg;
-}
-
-/*******************************************************************************
-* Function Name  : ADC_ExternalTrigInjectedConvCmd
-* Description    : Enables or disables the ADCx injected channels conversion
-*                  through external trigger
-* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-*                  - NewState: new state of the selected ADC external trigger
-*                    start of injected conversion.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void ADC_ExternalTrigInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected ADC external event selection for injected group */
-    ADCx-&gt;CR2 |= CR2_JEXTTRIG_Set;
-  }
-  else
-  {
-    /* Disable the selected ADC external event selection for injected group */
-    ADCx-&gt;CR2 &amp;= CR2_JEXTTRIG_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : ADC_SoftwareStartInjectedConvCmd
-* Description    : Enables or disables the selected ADC start of the injected 
-*                  channels conversion.
-* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-*                  - NewState: new state of the selected ADC software start
-*                    injected conversion.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void ADC_SoftwareStartInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected ADC conversion for injected group on external event and start the selected
-       ADC injected conversion */
-    ADCx-&gt;CR2 |= CR2_JEXTTRIG_JSWSTART_Set;
-  }
-  else
-  {
-    /* Disable the selected ADC conversion on external event for injected group and stop the selected
-       ADC injected conversion */
-    ADCx-&gt;CR2 &amp;= CR2_JEXTTRIG_JSWSTART_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : ADC_GetSoftwareStartInjectedConvCmdStatus
-* Description    : Gets the selected ADC Software start injected conversion Status.
-* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-* Output         : None
-* Return         : The new state of ADC software start injected conversion (SET or RESET).
-*******************************************************************************/
-FlagStatus ADC_GetSoftwareStartInjectedConvCmdStatus(ADC_TypeDef* ADCx)
-{
-  FlagStatus bitstatus = RESET;
-
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-
-  /* Check the status of JSWSTART bit */
-  if ((ADCx-&gt;CR2 &amp; CR2_JSWSTART_Set) != (u32)RESET)
-  {
-    /* JSWSTART bit is set */
-    bitstatus = SET;
-  }
-  else
-  {
-    /* JSWSTART bit is reset */
-    bitstatus = RESET;
-  }
-
-  /* Return the JSWSTART bit status */
-  return  bitstatus;
-}
-
-/*******************************************************************************
-* Function Name  : ADC_InjectedChannelConfig
-* Description    : Configures for the selected ADC injected channel its corresponding
-*                  rank in the sequencer and its sample time.
-* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-*                  - ADC_Channel: the ADC channel to configure. 
-*                    This parameter can be one of the following values:
-*                       - ADC_Channel_0: ADC Channel0 selected
-*                       - ADC_Channel_1: ADC Channel1 selected
-*                       - ADC_Channel_2: ADC Channel2 selected
-*                       - ADC_Channel_3: ADC Channel3 selected
-*                       - ADC_Channel_4: ADC Channel4 selected
-*                       - ADC_Channel_5: ADC Channel5 selected
-*                       - ADC_Channel_6: ADC Channel6 selected
-*                       - ADC_Channel_7: ADC Channel7 selected
-*                       - ADC_Channel_8: ADC Channel8 selected
-*                       - ADC_Channel_9: ADC Channel9 selected
-*                       - ADC_Channel_10: ADC Channel10 selected
-*                       - ADC_Channel_11: ADC Channel11 selected
-*                       - ADC_Channel_12: ADC Channel12 selected
-*                       - ADC_Channel_13: ADC Channel13 selected
-*                       - ADC_Channel_14: ADC Channel14 selected
-*                       - ADC_Channel_15: ADC Channel15 selected
-*                       - ADC_Channel_16: ADC Channel16 selected
-*                       - ADC_Channel_17: ADC Channel17 selected
-*                  - Rank: The rank in the injected group sequencer. This parameter
-*                    must be between 1 to 4.
-*                  - ADC_SampleTime: The sample time value to be set for the
-*                    selected channel. 
-*                    This parameter can be one of the following values:
-*                       - ADC_SampleTime_1Cycles5: Sample time equal to 1.5 cycles
-*                       - ADC_SampleTime_7Cycles5: Sample time equal to 7.5 cycles
-*                       - ADC_SampleTime_13Cycles5: Sample time equal to 13.5 cycles
-*                       - ADC_SampleTime_28Cycles5: Sample time equal to 28.5 cycles	
-*                       - ADC_SampleTime_41Cycles5: Sample time equal to 41.5 cycles	
-*                       - ADC_SampleTime_55Cycles5: Sample time equal to 55.5 cycles	
-*                       - ADC_SampleTime_71Cycles5: Sample time equal to 71.5 cycles	
-*                       - ADC_SampleTime_239Cycles5: Sample time equal to 239.5 cycles	
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void ADC_InjectedChannelConfig(ADC_TypeDef* ADCx, u8 ADC_Channel, u8 Rank, u8 ADC_SampleTime)
-{
-  u32 tmpreg1 = 0, tmpreg2 = 0, tmpreg3 = 0;
-
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  assert_param(IS_ADC_CHANNEL(ADC_Channel));
-  assert_param(IS_ADC_INJECTED_RANK(Rank));
-  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
-
-  /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
-  if (ADC_Channel &gt; ADC_Channel_9)
-  {
-    /* Get the old register value */
-    tmpreg1 = ADCx-&gt;SMPR1;
-    /* Calculate the mask to clear */
-    tmpreg2 = SMPR1_SMP_Set &lt;&lt; (3*(ADC_Channel - 10));
-    /* Clear the old discontinuous mode channel count */
-    tmpreg1 &amp;= ~tmpreg2;
-    /* Calculate the mask to set */
-    tmpreg2 = (u32)ADC_SampleTime &lt;&lt; (3*(ADC_Channel - 10));
-    /* Set the discontinuous mode channel count */
-    tmpreg1 |= tmpreg2;
-    /* Store the new register value */
-    ADCx-&gt;SMPR1 = tmpreg1;
-  }
-  else /* ADC_Channel include in ADC_Channel_[0..9] */
-  {
-    /* Get the old register value */
-    tmpreg1 = ADCx-&gt;SMPR2;
-    /* Calculate the mask to clear */
-    tmpreg2 = SMPR2_SMP_Set &lt;&lt; (3 * ADC_Channel);
-    /* Clear the old discontinuous mode channel count */
-    tmpreg1 &amp;= ~tmpreg2;
-    /* Calculate the mask to set */
-    tmpreg2 = (u32)ADC_SampleTime &lt;&lt; (3 * ADC_Channel);
-    /* Set the discontinuous mode channel count */
-    tmpreg1 |= tmpreg2;
-    /* Store the new register value */
-    ADCx-&gt;SMPR2 = tmpreg1;
-  }
-
-  /* Rank configuration */
-  /* Get the old register value */
-  tmpreg1 = ADCx-&gt;JSQR;
-  /* Get JL value: Number = JL+1 */
-  tmpreg3 =  (tmpreg1 &amp; JSQR_JL_Set)&gt;&gt; 20;
-  /* Calculate the mask to clear: ((Rank-1)+(4-JL-1)) */
-  tmpreg2 = JSQR_JSQ_Set &lt;&lt; (5 * (u8)((Rank + 3) - (tmpreg3 + 1)));
-  /* Clear the old JSQx bits for the selected rank */
-  tmpreg1 &amp;= ~tmpreg2;
-  /* Calculate the mask to set: ((Rank-1)+(4-JL-1)) */
-  tmpreg2 = (u32)ADC_Channel &lt;&lt; (5 * (u8)((Rank + 3) - (tmpreg3 + 1)));
-  /* Set the JSQx bits for the selected rank */
-  tmpreg1 |= tmpreg2;
-  /* Store the new register value */
-  ADCx-&gt;JSQR = tmpreg1;
-}
-
-/*******************************************************************************
-* Function Name  : ADC_InjectedSequencerLengthConfig
-* Description    : Configures the sequencer length for injected channels
-* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-*                  - Length: The sequencer length. 
-*                    This parameter must be a number between 1 to 4.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void ADC_InjectedSequencerLengthConfig(ADC_TypeDef* ADCx, u8 Length)
-{
-  u32 tmpreg1 = 0;
-  u32 tmpreg2 = 0;
-
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  assert_param(IS_ADC_INJECTED_LENGTH(Length));
-  
-  /* Get the old register value */
-  tmpreg1 = ADCx-&gt;JSQR;
-  /* Clear the old injected sequnence lenght JL bits */
-  tmpreg1 &amp;= JSQR_JL_Reset;
-  /* Set the injected sequnence lenght JL bits */
-  tmpreg2 = Length - 1; 
-  tmpreg1 |= tmpreg2 &lt;&lt; 20;
-  /* Store the new register value */
-  ADCx-&gt;JSQR = tmpreg1;
-}
-
-/*******************************************************************************
-* Function Name  : ADC_SetInjectedOffset
-* Description    : Set the injected channels conversion value offset
-* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-*                  - ADC_InjectedChannel: the ADC injected channel to set its
-*                    offset. 
-*                    This parameter can be one of the following values:
-*                       - ADC_InjectedChannel_1: Injected Channel1 selected
-*                       - ADC_InjectedChannel_2: Injected Channel2 selected
-*                       - ADC_InjectedChannel_3: Injected Channel3 selected
-*                       - ADC_InjectedChannel_4: Injected Channel4 selected
-*                  - Offset: the offset value for the selected ADC injected channel
-*                    This parameter must be a 12bit value.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void ADC_SetInjectedOffset(ADC_TypeDef* ADCx, u8 ADC_InjectedChannel, u16 Offset)
-{
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
-  assert_param(IS_ADC_OFFSET(Offset));  
-
-  /* Set the selected injected channel data offset */
-  *((vu32 *)((*(u32*)&amp;ADCx) + ADC_InjectedChannel)) = (u32)Offset;
-}
-
-/*******************************************************************************
-* Function Name  : ADC_GetInjectedConversionValue
-* Description    : Returns the ADC injected channel conversion result
-* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-*                  - ADC_InjectedChannel: the converted ADC injected channel.
-*                    This parameter can be one of the following values:
-*                       - ADC_InjectedChannel_1: Injected Channel1 selected
-*                       - ADC_InjectedChannel_2: Injected Channel2 selected
-*                       - ADC_InjectedChannel_3: Injected Channel3 selected
-*                       - ADC_InjectedChannel_4: Injected Channel4 selected
-* Output         : None
-* Return         : The Data conversion value.
-*******************************************************************************/
-u16 ADC_GetInjectedConversionValue(ADC_TypeDef* ADCx, u8 ADC_InjectedChannel)
-{
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
-
-  /* Returns the selected injected channel conversion data value */
-  return (u16) (*(vu32*) (((*(u32*)&amp;ADCx) + ADC_InjectedChannel + JDR_Offset)));
-}
-
-/*******************************************************************************
-* Function Name  : ADC_AnalogWatchdogCmd
-* Description    : Enables or disables the analog watchdog on single/all regular
-*                  or injected channels
-* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-*                  - ADC_AnalogWatchdog: the ADC analog watchdog configuration.
-*                    This parameter can be one of the following values:
-*                       - ADC_AnalogWatchdog_SingleRegEnable: Analog watchdog on
-*                         a single regular channel
-*                       - ADC_AnalogWatchdog_SingleInjecEnable: Analog watchdog on
-*                         a single injected channel
-*                       - ADC_AnalogWatchdog_SingleRegOrInjecEnable: Analog 
-*                         watchdog on a single regular or injected channel
-*                       - ADC_AnalogWatchdog_AllRegEnable: Analog watchdog on
-*                         all regular channel
-*                       - ADC_AnalogWatchdog_AllInjecEnable: Analog watchdog on
-*                         all injected channel
-*                       - ADC_AnalogWatchdog_AllRegAllInjecEnable: Analog watchdog
-*                         on all regular and injected channels
-*                       - ADC_AnalogWatchdog_None: No channel guarded by the
-*                         analog watchdog
-* Output         : None
-* Return         : None	  
-*******************************************************************************/
-void ADC_AnalogWatchdogCmd(ADC_TypeDef* ADCx, u32 ADC_AnalogWatchdog)
-{
-  u32 tmpreg = 0;
-
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  assert_param(IS_ADC_ANALOG_WATCHDOG(ADC_AnalogWatchdog));
-
-  /* Get the old register value */
-  tmpreg = ADCx-&gt;CR1;
-  /* Clear AWDEN, AWDENJ and AWDSGL bits */
-  tmpreg &amp;= CR1_AWDMode_Reset;
-  /* Set the analog watchdog enable mode */
-  tmpreg |= ADC_AnalogWatchdog;
-  /* Store the new register value */
-  ADCx-&gt;CR1 = tmpreg;
-}
-
-/*******************************************************************************
-* Function Name  : ADC_AnalogWatchdogThresholdsConfig
-* Description    : Configures the high and low thresholds of the analog watchdog.
-* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-*                  - HighThreshold: the ADC analog watchdog High threshold value.
-*                    This parameter must be a 12bit value.
-*                  - LowThreshold: the ADC analog watchdog Low threshold value.
-*                    This parameter must be a 12bit value.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void ADC_AnalogWatchdogThresholdsConfig(ADC_TypeDef* ADCx, u16 HighThreshold,
-                                        u16 LowThreshold)
-{
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  assert_param(IS_ADC_THRESHOLD(HighThreshold));
-  assert_param(IS_ADC_THRESHOLD(LowThreshold));
-
-  /* Set the ADCx high threshold */
-  ADCx-&gt;HTR = HighThreshold;
-  /* Set the ADCx low threshold */
-  ADCx-&gt;LTR = LowThreshold;
-}
-
-/*******************************************************************************
-* Function Name  : ADC_AnalogWatchdogSingleChannelConfig
-* Description    : Configures the analog watchdog guarded single channel
-* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-*                  - ADC_Channel: the ADC channel to configure for the analog
-*                    watchdog. 
-*                    This parameter can be one of the following values:
-*                       - ADC_Channel_0: ADC Channel0 selected
-*                       - ADC_Channel_1: ADC Channel1 selected
-*                       - ADC_Channel_2: ADC Channel2 selected
-*                       - ADC_Channel_3: ADC Channel3 selected
-*                       - ADC_Channel_4: ADC Channel4 selected
-*                       - ADC_Channel_5: ADC Channel5 selected
-*                       - ADC_Channel_6: ADC Channel6 selected
-*                       - ADC_Channel_7: ADC Channel7 selected
-*                       - ADC_Channel_8: ADC Channel8 selected
-*                       - ADC_Channel_9: ADC Channel9 selected
-*                       - ADC_Channel_10: ADC Channel10 selected
-*                       - ADC_Channel_11: ADC Channel11 selected
-*                       - ADC_Channel_12: ADC Channel12 selected
-*                       - ADC_Channel_13: ADC Channel13 selected
-*                       - ADC_Channel_14: ADC Channel14 selected
-*                       - ADC_Channel_15: ADC Channel15 selected
-*                       - ADC_Channel_16: ADC Channel16 selected
-*                       - ADC_Channel_17: ADC Channel17 selected
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void ADC_AnalogWatchdogSingleChannelConfig(ADC_TypeDef* ADCx, u8 ADC_Channel)
-{
-  u32 tmpreg = 0;
-
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  assert_param(IS_ADC_CHANNEL(ADC_Channel));
-
-  /* Get the old register value */
-  tmpreg = ADCx-&gt;CR1;
-  /* Clear the Analog watchdog channel select bits */
-  tmpreg &amp;= CR1_AWDCH_Reset;
-  /* Set the Analog watchdog channel */
-  tmpreg |= ADC_Channel;
-  /* Store the new register value */
-  ADCx-&gt;CR1 = tmpreg;
-}
-
-/*******************************************************************************
-* Function Name  : ADC_TempSensorVrefintCmd
-* Description    : Enables or disables the temperature sensor and Vrefint channel.
-* Input          : - NewState: new state of the temperature sensor.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void ADC_TempSensorVrefintCmd(FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Enable the temperature sensor and Vrefint channel*/
-    ADC1-&gt;CR2 |= CR2_TSVREFE_Set;
-  }
-  else
-  {
-    /* Disable the temperature sensor and Vrefint channel*/
-    ADC1-&gt;CR2 &amp;= CR2_TSVREFE_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : ADC_GetFlagStatus
-* Description    : Checks whether the specified ADC flag is set or not.
-* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-*                  - ADC_FLAG: specifies the flag to check. 
-*                    This parameter can be one of the following values:
-*                       - ADC_FLAG_AWD: Analog watchdog flag
-*                       - ADC_FLAG_EOC: End of conversion flag
-*                       - ADC_FLAG_JEOC: End of injected group conversion flag
-*                       - ADC_FLAG_JSTRT: Start of injected group conversion flag
-*                       - ADC_FLAG_STRT: Start of regular group conversion flag
-* Output         : None
-* Return         : The new state of ADC_FLAG (SET or RESET).
-*******************************************************************************/
-FlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, u8 ADC_FLAG)
-{
-  FlagStatus bitstatus = RESET;
-
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  assert_param(IS_ADC_GET_FLAG(ADC_FLAG));
-
-  /* Check the status of the specified ADC flag */
-  if ((ADCx-&gt;SR &amp; ADC_FLAG) != (u8)RESET)
-  {
-    /* ADC_FLAG is set */
-    bitstatus = SET;
-  }
-  else
-  {
-    /* ADC_FLAG is reset */
-    bitstatus = RESET;
-  }
-
-  /* Return the ADC_FLAG status */
-  return  bitstatus;
-}
-
-/*******************************************************************************
-* Function Name  : ADC_ClearFlag
-* Description    : Clears the ADCx's pending flags.
-* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-*                  - ADC_FLAG: specifies the flag to clear. 
-*                    This parameter can be any combination of the following values:
-*                       - ADC_FLAG_AWD: Analog watchdog flag
-*                       - ADC_FLAG_EOC: End of conversion flag
-*                       - ADC_FLAG_JEOC: End of injected group conversion flag
-*                       - ADC_FLAG_JSTRT: Start of injected group conversion flag
-*                       - ADC_FLAG_STRT: Start of regular group conversion flag
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void ADC_ClearFlag(ADC_TypeDef* ADCx, u8 ADC_FLAG)
-{
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  assert_param(IS_ADC_CLEAR_FLAG(ADC_FLAG));
-
-  /* Clear the selected ADC flags */
-  ADCx-&gt;SR = ~(u32)ADC_FLAG;
-}
-
-/*******************************************************************************
-* Function Name  : ADC_GetITStatus
-* Description    : Checks whether the specified ADC interrupt has occurred or not.
-* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-*                  - ADC_IT: specifies the ADC interrupt source to check. 
-*                    This parameter can be one of the following values:
-*                       - ADC_IT_EOC: End of conversion interrupt mask
-*                       - ADC_IT_AWD: Analog watchdog interrupt mask
-*                       - ADC_IT_JEOC: End of injected conversion interrupt mask
-* Output         : None
-* Return         : The new state of ADC_IT (SET or RESET).
-*******************************************************************************/
-ITStatus ADC_GetITStatus(ADC_TypeDef* ADCx, u16 ADC_IT)
-{
-  ITStatus bitstatus = RESET;
-  u32 itmask = 0, enablestatus = 0;
-
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  assert_param(IS_ADC_GET_IT(ADC_IT));
-
-  /* Get the ADC IT index */
-  itmask = ADC_IT &gt;&gt; 8;
-
-  /* Get the ADC_IT enable bit status */
-  enablestatus = (ADCx-&gt;CR1 &amp; (u8)ADC_IT) ;
-
-  /* Check the status of the specified ADC interrupt */
-  if (((ADCx-&gt;SR &amp; itmask) != (u32)RESET) &amp;&amp; enablestatus)
-  {
-    /* ADC_IT is set */
-    bitstatus = SET;
-  }
-  else
-  {
-    /* ADC_IT is reset */
-    bitstatus = RESET;
-  }
-
-  /* Return the ADC_IT status */
-  return  bitstatus;
-}
-
-/*******************************************************************************
-* Function Name  : ADC_ClearITPendingBit
-* Description    : Clears the ADCx's interrupt pending bits.
-* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-*                  - ADC_IT: specifies the ADC interrupt pending bit to clear.
-*                    This parameter can be any combination of the following values:
-*                       - ADC_IT_EOC: End of conversion interrupt mask
-*                       - ADC_IT_AWD: Analog watchdog interrupt mask
-*                       - ADC_IT_JEOC: End of injected conversion interrupt mask
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void ADC_ClearITPendingBit(ADC_TypeDef* ADCx, u16 ADC_IT)
-{
-  u8 itmask = 0;
-
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  assert_param(IS_ADC_IT(ADC_IT));
-
-  /* Get the ADC IT index */
-  itmask = (u8)(ADC_IT &gt;&gt; 8);
-
-  /* Clear the selected ADC interrupt pending bits */
-  ADCx-&gt;SR = ~(u32)itmask;
-}
-
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
+/**
+  ******************************************************************************
+  * @file    stm32f10x_adc.c
+  * @author  MCD Application Team
+  * @version V3.1.0
+  * @date    06/19/2009
+  * @brief   This file provides all the ADC firmware functions.
+  ******************************************************************************
+  * @copy
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * &lt;h2&gt;&lt;center&gt;&copy; COPYRIGHT 2009 STMicroelectronics&lt;/center&gt;&lt;/h2&gt;
+  */ 
+
+/* Includes ------------------------------------------------------------------*/
+#include &quot;stm32f10x_adc.h&quot;
+#include &quot;stm32f10x_rcc.h&quot;
+
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup ADC 
+  * @brief ADC driver modules
+  * @{
+  */
+
+/** @defgroup ADC_Private_TypesDefinitions
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup ADC_Private_Defines
+  * @{
+  */
+
+/* ADC DISCNUM mask */
+#define CR1_DISCNUM_Reset           ((uint32_t)0xFFFF1FFF)
+
+/* ADC DISCEN mask */
+#define CR1_DISCEN_Set              ((uint32_t)0x00000800)
+#define CR1_DISCEN_Reset            ((uint32_t)0xFFFFF7FF)
+
+/* ADC JAUTO mask */
+#define CR1_JAUTO_Set               ((uint32_t)0x00000400)
+#define CR1_JAUTO_Reset             ((uint32_t)0xFFFFFBFF)
+
+/* ADC JDISCEN mask */
+#define CR1_JDISCEN_Set             ((uint32_t)0x00001000)
+#define CR1_JDISCEN_Reset           ((uint32_t)0xFFFFEFFF)
+
+/* ADC AWDCH mask */
+#define CR1_AWDCH_Reset             ((uint32_t)0xFFFFFFE0)
+
+/* ADC Analog watchdog enable mode mask */
+#define CR1_AWDMode_Reset           ((uint32_t)0xFF3FFDFF)
+
+/* CR1 register Mask */
+#define CR1_CLEAR_Mask              ((uint32_t)0xFFF0FEFF)
+
+/* ADC ADON mask */
+#define CR2_ADON_Set                ((uint32_t)0x00000001)
+#define CR2_ADON_Reset              ((uint32_t)0xFFFFFFFE)
+
+/* ADC DMA mask */
+#define CR2_DMA_Set                 ((uint32_t)0x00000100)
+#define CR2_DMA_Reset               ((uint32_t)0xFFFFFEFF)
+
+/* ADC RSTCAL mask */
+#define CR2_RSTCAL_Set              ((uint32_t)0x00000008)
+
+/* ADC CAL mask */
+#define CR2_CAL_Set                 ((uint32_t)0x00000004)
+
+/* ADC SWSTART mask */
+#define CR2_SWSTART_Set             ((uint32_t)0x00400000)
+
+/* ADC EXTTRIG mask */
+#define CR2_EXTTRIG_Set             ((uint32_t)0x00100000)
+#define CR2_EXTTRIG_Reset           ((uint32_t)0xFFEFFFFF)
+
+/* ADC Software start mask */
+#define CR2_EXTTRIG_SWSTART_Set     ((uint32_t)0x00500000)
+#define CR2_EXTTRIG_SWSTART_Reset   ((uint32_t)0xFFAFFFFF)
+
+/* ADC JEXTSEL mask */
+#define CR2_JEXTSEL_Reset           ((uint32_t)0xFFFF8FFF)
+
+/* ADC JEXTTRIG mask */
+#define CR2_JEXTTRIG_Set            ((uint32_t)0x00008000)
+#define CR2_JEXTTRIG_Reset          ((uint32_t)0xFFFF7FFF)
+
+/* ADC JSWSTART mask */
+#define CR2_JSWSTART_Set            ((uint32_t)0x00200000)
+
+/* ADC injected software start mask */
+#define CR2_JEXTTRIG_JSWSTART_Set   ((uint32_t)0x00208000)
+#define CR2_JEXTTRIG_JSWSTART_Reset ((uint32_t)0xFFDF7FFF)
+
+/* ADC TSPD mask */
+#define CR2_TSVREFE_Set             ((uint32_t)0x00800000)
+#define CR2_TSVREFE_Reset           ((uint32_t)0xFF7FFFFF)
+
+/* CR2 register Mask */
+#define CR2_CLEAR_Mask              ((uint32_t)0xFFF1F7FD)
+
+/* ADC SQx mask */
+#define SQR3_SQ_Set                 ((uint32_t)0x0000001F)
+#define SQR2_SQ_Set                 ((uint32_t)0x0000001F)
+#define SQR1_SQ_Set                 ((uint32_t)0x0000001F)
+
+/* SQR1 register Mask */
+#define SQR1_CLEAR_Mask             ((uint32_t)0xFF0FFFFF)
+
+/* ADC JSQx mask */
+#define JSQR_JSQ_Set                ((uint32_t)0x0000001F)
+
+/* ADC JL mask */
+#define JSQR_JL_Set                 ((uint32_t)0x00300000)
+#define JSQR_JL_Reset               ((uint32_t)0xFFCFFFFF)
+
+/* ADC SMPx mask */
+#define SMPR1_SMP_Set               ((uint32_t)0x00000007)
+#define SMPR2_SMP_Set               ((uint32_t)0x00000007)
+
+/* ADC JDRx registers offset */
+#define JDR_Offset                  ((uint8_t)0x28)
+
+/* ADC1 DR register base address */
+#define DR_ADDRESS                  ((uint32_t)0x4001244C)
+
+/**
+  * @}
+  */
+
+/** @defgroup ADC_Private_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup ADC_Private_Variables
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup ADC_Private_FunctionPrototypes
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup ADC_Private_Functions
+  * @{
+  */
+
+/**
+  * @brief  Deinitializes the ADCx peripheral registers to their default reset values.
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @retval None
+  */
+void ADC_DeInit(ADC_TypeDef* ADCx)
+{
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  
+  if (ADCx == ADC1)
+  {
+    /* Enable ADC1 reset state */
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, ENABLE);
+    /* Release ADC1 from reset state */
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, DISABLE);
+  }
+  else if (ADCx == ADC2)
+  {
+    /* Enable ADC2 reset state */
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC2, ENABLE);
+    /* Release ADC2 from reset state */
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC2, DISABLE);
+  }
+  else
+  {
+    if (ADCx == ADC3)
+    {
+      /* Enable ADC3 reset state */
+      RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC3, ENABLE);
+      /* Release ADC3 from reset state */
+      RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC3, DISABLE);
+    }
+  }
+}
+
+/**
+  * @brief  Initializes the ADCx peripheral according to the specified parameters
+  *   in the ADC_InitStruct.
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @param  ADC_InitStruct: pointer to an ADC_InitTypeDef structure that contains
+  *   the configuration information for the specified ADC peripheral.
+  * @retval None
+  */
+void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)
+{
+  uint32_t tmpreg1 = 0;
+  uint8_t tmpreg2 = 0;
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_ADC_MODE(ADC_InitStruct-&gt;ADC_Mode));
+  assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct-&gt;ADC_ScanConvMode));
+  assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct-&gt;ADC_ContinuousConvMode));
+  assert_param(IS_ADC_EXT_TRIG(ADC_InitStruct-&gt;ADC_ExternalTrigConv));   
+  assert_param(IS_ADC_DATA_ALIGN(ADC_InitStruct-&gt;ADC_DataAlign)); 
+  assert_param(IS_ADC_REGULAR_LENGTH(ADC_InitStruct-&gt;ADC_NbrOfChannel));
+
+  /*---------------------------- ADCx CR1 Configuration -----------------*/
+  /* Get the ADCx CR1 value */
+  tmpreg1 = ADCx-&gt;CR1;
+  /* Clear DUALMOD and SCAN bits */
+  tmpreg1 &amp;= CR1_CLEAR_Mask;
+  /* Configure ADCx: Dual mode and scan conversion mode */
+  /* Set DUALMOD bits according to ADC_Mode value */
+  /* Set SCAN bit according to ADC_ScanConvMode value */
+  tmpreg1 |= (uint32_t)(ADC_InitStruct-&gt;ADC_Mode | ((uint32_t)ADC_InitStruct-&gt;ADC_ScanConvMode &lt;&lt; 8));
+  /* Write to ADCx CR1 */
+  ADCx-&gt;CR1 = tmpreg1;
+
+  /*---------------------------- ADCx CR2 Configuration -----------------*/
+  /* Get the ADCx CR2 value */
+  tmpreg1 = ADCx-&gt;CR2;
+  /* Clear CONT, ALIGN and EXTSEL bits */
+  tmpreg1 &amp;= CR2_CLEAR_Mask;
+  /* Configure ADCx: external trigger event and continuous conversion mode */
+  /* Set ALIGN bit according to ADC_DataAlign value */
+  /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
+  /* Set CONT bit according to ADC_ContinuousConvMode value */
+  tmpreg1 |= (uint32_t)(ADC_InitStruct-&gt;ADC_DataAlign | ADC_InitStruct-&gt;ADC_ExternalTrigConv |
+            ((uint32_t)ADC_InitStruct-&gt;ADC_ContinuousConvMode &lt;&lt; 1));
+  /* Write to ADCx CR2 */
+  ADCx-&gt;CR2 = tmpreg1;
+
+  /*---------------------------- ADCx SQR1 Configuration -----------------*/
+  /* Get the ADCx SQR1 value */
+  tmpreg1 = ADCx-&gt;SQR1;
+  /* Clear L bits */
+  tmpreg1 &amp;= SQR1_CLEAR_Mask;
+  /* Configure ADCx: regular channel sequence length */
+  /* Set L bits according to ADC_NbrOfChannel value */
+  tmpreg2 |= (uint8_t) (ADC_InitStruct-&gt;ADC_NbrOfChannel - (uint8_t)1);
+  tmpreg1 |= (uint32_t)tmpreg2 &lt;&lt; 20;
+  /* Write to ADCx SQR1 */
+  ADCx-&gt;SQR1 = tmpreg1;
+}
+
+/**
+  * @brief  Fills each ADC_InitStruct member with its default value.
+  * @param  ADC_InitStruct : pointer to an ADC_InitTypeDef structure which will be initialized.
+  * @retval None
+  */
+void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)
+{
+  /* Reset ADC init structure parameters values */
+  /* Initialize the ADC_Mode member */
+  ADC_InitStruct-&gt;ADC_Mode = ADC_Mode_Independent;
+  /* initialize the ADC_ScanConvMode member */
+  ADC_InitStruct-&gt;ADC_ScanConvMode = DISABLE;
+  /* Initialize the ADC_ContinuousConvMode member */
+  ADC_InitStruct-&gt;ADC_ContinuousConvMode = DISABLE;
+  /* Initialize the ADC_ExternalTrigConv member */
+  ADC_InitStruct-&gt;ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;
+  /* Initialize the ADC_DataAlign member */
+  ADC_InitStruct-&gt;ADC_DataAlign = ADC_DataAlign_Right;
+  /* Initialize the ADC_NbrOfChannel member */
+  ADC_InitStruct-&gt;ADC_NbrOfChannel = 1;
+}
+
+/**
+  * @brief  Enables or disables the specified ADC peripheral.
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @param  NewState: new state of the ADCx peripheral.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Set the ADON bit to wake up the ADC from power down mode */
+    ADCx-&gt;CR2 |= CR2_ADON_Set;
+  }
+  else
+  {
+    /* Disable the selected ADC peripheral */
+    ADCx-&gt;CR2 &amp;= CR2_ADON_Reset;
+  }
+}
+
+/**
+  * @brief  Enables or disables the specified ADC DMA request.
+  * @param  ADCx: where x can be 1 or 3 to select the ADC peripheral.
+  *   Note: ADC2 hasn't a DMA capability.
+  * @param  NewState: new state of the selected ADC DMA transfer.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_ADC_DMA_PERIPH(ADCx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected ADC DMA request */
+    ADCx-&gt;CR2 |= CR2_DMA_Set;
+  }
+  else
+  {
+    /* Disable the selected ADC DMA request */
+    ADCx-&gt;CR2 &amp;= CR2_DMA_Reset;
+  }
+}
+
+/**
+  * @brief  Enables or disables the specified ADC interrupts.
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @param  ADC_IT: specifies the ADC interrupt sources to be enabled or disabled. 
+  *   This parameter can be any combination of the following values:
+  *     @arg ADC_IT_EOC: End of conversion interrupt mask
+  *     @arg ADC_IT_AWD: Analog watchdog interrupt mask
+  *     @arg ADC_IT_JEOC: End of injected conversion interrupt mask
+  * @param  NewState: new state of the specified ADC interrupts.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void ADC_ITConfig(ADC_TypeDef* ADCx, uint16_t ADC_IT, FunctionalState NewState)
+{
+  uint8_t itmask = 0;
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  assert_param(IS_ADC_IT(ADC_IT));
+  /* Get the ADC IT index */
+  itmask = (uint8_t)ADC_IT;
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected ADC interrupts */
+    ADCx-&gt;CR1 |= itmask;
+  }
+  else
+  {
+    /* Disable the selected ADC interrupts */
+    ADCx-&gt;CR1 &amp;= (~(uint32_t)itmask);
+  }
+}
+
+/**
+  * @brief  Resets the selected ADC calibration registers.
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @retval None
+  */
+void ADC_ResetCalibration(ADC_TypeDef* ADCx)
+{
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  /* Resets the selected ADC calibartion registers */  
+  ADCx-&gt;CR2 |= CR2_RSTCAL_Set;
+}
+
+/**
+  * @brief  Gets the selected ADC reset calibration registers status.
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @retval The new state of ADC reset calibration registers (SET or RESET).
+  */
+FlagStatus ADC_GetResetCalibrationStatus(ADC_TypeDef* ADCx)
+{
+  FlagStatus bitstatus = RESET;
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  /* Check the status of RSTCAL bit */
+  if ((ADCx-&gt;CR2 &amp; CR2_RSTCAL_Set) != (uint32_t)RESET)
+  {
+    /* RSTCAL bit is set */
+    bitstatus = SET;
+  }
+  else
+  {
+    /* RSTCAL bit is reset */
+    bitstatus = RESET;
+  }
+  /* Return the RSTCAL bit status */
+  return  bitstatus;
+}
+
+/**
+  * @brief  Starts the selected ADC calibration process.
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @retval None
+  */
+void ADC_StartCalibration(ADC_TypeDef* ADCx)
+{
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  /* Enable the selected ADC calibration process */  
+  ADCx-&gt;CR2 |= CR2_CAL_Set;
+}
+
+/**
+  * @brief  Gets the selected ADC calibration status.
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @retval The new state of ADC calibration (SET or RESET).
+  */
+FlagStatus ADC_GetCalibrationStatus(ADC_TypeDef* ADCx)
+{
+  FlagStatus bitstatus = RESET;
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  /* Check the status of CAL bit */
+  if ((ADCx-&gt;CR2 &amp; CR2_CAL_Set) != (uint32_t)RESET)
+  {
+    /* CAL bit is set: calibration on going */
+    bitstatus = SET;
+  }
+  else
+  {
+    /* CAL bit is reset: end of calibration */
+    bitstatus = RESET;
+  }
+  /* Return the CAL bit status */
+  return  bitstatus;
+}
+
+/**
+  * @brief  Enables or disables the selected ADC software start conversion .
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @param  NewState: new state of the selected ADC software start conversion.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void ADC_SoftwareStartConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected ADC conversion on external event and start the selected
+       ADC conversion */
+    ADCx-&gt;CR2 |= CR2_EXTTRIG_SWSTART_Set;
+  }
+  else
+  {
+    /* Disable the selected ADC conversion on external event and stop the selected
+       ADC conversion */
+    ADCx-&gt;CR2 &amp;= CR2_EXTTRIG_SWSTART_Reset;
+  }
+}
+
+/**
+  * @brief  Gets the selected ADC Software start conversion Status.
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @retval The new state of ADC software start conversion (SET or RESET).
+  */
+FlagStatus ADC_GetSoftwareStartConvStatus(ADC_TypeDef* ADCx)
+{
+  FlagStatus bitstatus = RESET;
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  /* Check the status of SWSTART bit */
+  if ((ADCx-&gt;CR2 &amp; CR2_SWSTART_Set) != (uint32_t)RESET)
+  {
+    /* SWSTART bit is set */
+    bitstatus = SET;
+  }
+  else
+  {
+    /* SWSTART bit is reset */
+    bitstatus = RESET;
+  }
+  /* Return the SWSTART bit status */
+  return  bitstatus;
+}
+
+/**
+  * @brief  Configures the discontinuous mode for the selected ADC regular
+  *   group channel.
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @param  Number: specifies the discontinuous mode regular channel
+  *   count value. This number must be between 1 and 8.
+  * @retval None
+  */
+void ADC_DiscModeChannelCountConfig(ADC_TypeDef* ADCx, uint8_t Number)
+{
+  uint32_t tmpreg1 = 0;
+  uint32_t tmpreg2 = 0;
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_ADC_REGULAR_DISC_NUMBER(Number));
+  /* Get the old register value */
+  tmpreg1 = ADCx-&gt;CR1;
+  /* Clear the old discontinuous mode channel count */
+  tmpreg1 &amp;= CR1_DISCNUM_Reset;
+  /* Set the discontinuous mode channel count */
+  tmpreg2 = Number - 1;
+  tmpreg1 |= tmpreg2 &lt;&lt; 13;
+  /* Store the new register value */
+  ADCx-&gt;CR1 = tmpreg1;
+}
+
+/**
+  * @brief  Enables or disables the discontinuous mode on regular group
+  *   channel for the specified ADC
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @param  NewState: new state of the selected ADC discontinuous mode
+  *   on regular group channel.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void ADC_DiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected ADC regular discontinuous mode */
+    ADCx-&gt;CR1 |= CR1_DISCEN_Set;
+  }
+  else
+  {
+    /* Disable the selected ADC regular discontinuous mode */
+    ADCx-&gt;CR1 &amp;= CR1_DISCEN_Reset;
+  }
+}
+
+/**
+  * @brief  Configures for the selected ADC regular channel its corresponding
+  *   rank in the sequencer and its sample time.
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @param  ADC_Channel: the ADC channel to configure. 
+  *   This parameter can be one of the following values:
+  *     @arg ADC_Channel_0: ADC Channel0 selected
+  *     @arg ADC_Channel_1: ADC Channel1 selected
+  *     @arg ADC_Channel_2: ADC Channel2 selected
+  *     @arg ADC_Channel_3: ADC Channel3 selected
+  *     @arg ADC_Channel_4: ADC Channel4 selected
+  *     @arg ADC_Channel_5: ADC Channel5 selected
+  *     @arg ADC_Channel_6: ADC Channel6 selected
+  *     @arg ADC_Channel_7: ADC Channel7 selected
+  *     @arg ADC_Channel_8: ADC Channel8 selected
+  *     @arg ADC_Channel_9: ADC Channel9 selected
+  *     @arg ADC_Channel_10: ADC Channel10 selected
+  *     @arg ADC_Channel_11: ADC Channel11 selected
+  *     @arg ADC_Channel_12: ADC Channel12 selected
+  *     @arg ADC_Channel_13: ADC Channel13 selected
+  *     @arg ADC_Channel_14: ADC Channel14 selected
+  *     @arg ADC_Channel_15: ADC Channel15 selected
+  *     @arg ADC_Channel_16: ADC Channel16 selected
+  *     @arg ADC_Channel_17: ADC Channel17 selected
+  * @param  Rank: The rank in the regular group sequencer. This parameter must be between 1 to 16.
+  * @param  ADC_SampleTime: The sample time value to be set for the selected channel. 
+  *   This parameter can be one of the following values:
+  *     @arg ADC_SampleTime_1Cycles5: Sample time equal to 1.5 cycles
+  *     @arg ADC_SampleTime_7Cycles5: Sample time equal to 7.5 cycles
+  *     @arg ADC_SampleTime_13Cycles5: Sample time equal to 13.5 cycles
+  *     @arg ADC_SampleTime_28Cycles5: Sample time equal to 28.5 cycles	
+  *     @arg ADC_SampleTime_41Cycles5: Sample time equal to 41.5 cycles	
+  *     @arg ADC_SampleTime_55Cycles5: Sample time equal to 55.5 cycles	
+  *     @arg ADC_SampleTime_71Cycles5: Sample time equal to 71.5 cycles	
+  *     @arg ADC_SampleTime_239Cycles5: Sample time equal to 239.5 cycles	
+  * @retval None
+  */
+void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
+{
+  uint32_t tmpreg1 = 0, tmpreg2 = 0;
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_ADC_CHANNEL(ADC_Channel));
+  assert_param(IS_ADC_REGULAR_RANK(Rank));
+  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
+  /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
+  if (ADC_Channel &gt; ADC_Channel_9)
+  {
+    /* Get the old register value */
+    tmpreg1 = ADCx-&gt;SMPR1;
+    /* Calculate the mask to clear */
+    tmpreg2 = SMPR1_SMP_Set &lt;&lt; (3 * (ADC_Channel - 10));
+    /* Clear the old channel sample time */
+    tmpreg1 &amp;= ~tmpreg2;
+    /* Calculate the mask to set */
+    tmpreg2 = (uint32_t)ADC_SampleTime &lt;&lt; (3 * (ADC_Channel - 10));
+    /* Set the new channel sample time */
+    tmpreg1 |= tmpreg2;
+    /* Store the new register value */
+    ADCx-&gt;SMPR1 = tmpreg1;
+  }
+  else /* ADC_Channel include in ADC_Channel_[0..9] */
+  {
+    /* Get the old register value */
+    tmpreg1 = ADCx-&gt;SMPR2;
+    /* Calculate the mask to clear */
+    tmpreg2 = SMPR2_SMP_Set &lt;&lt; (3 * ADC_Channel);
+    /* Clear the old channel sample time */
+    tmpreg1 &amp;= ~tmpreg2;
+    /* Calculate the mask to set */
+    tmpreg2 = (uint32_t)ADC_SampleTime &lt;&lt; (3 * ADC_Channel);
+    /* Set the new channel sample time */
+    tmpreg1 |= tmpreg2;
+    /* Store the new register value */
+    ADCx-&gt;SMPR2 = tmpreg1;
+  }
+  /* For Rank 1 to 6 */
+  if (Rank &lt; 7)
+  {
+    /* Get the old register value */
+    tmpreg1 = ADCx-&gt;SQR3;
+    /* Calculate the mask to clear */
+    tmpreg2 = SQR3_SQ_Set &lt;&lt; (5 * (Rank - 1));
+    /* Clear the old SQx bits for the selected rank */
+    tmpreg1 &amp;= ~tmpreg2;
+    /* Calculate the mask to set */
+    tmpreg2 = (uint32_t)ADC_Channel &lt;&lt; (5 * (Rank - 1));
+    /* Set the SQx bits for the selected rank */
+    tmpreg1 |= tmpreg2;
+    /* Store the new register value */
+    ADCx-&gt;SQR3 = tmpreg1;
+  }
+  /* For Rank 7 to 12 */
+  else if (Rank &lt; 13)
+  {
+    /* Get the old register value */
+    tmpreg1 = ADCx-&gt;SQR2;
+    /* Calculate the mask to clear */
+    tmpreg2 = SQR2_SQ_Set &lt;&lt; (5 * (Rank - 7));
+    /* Clear the old SQx bits for the selected rank */
+    tmpreg1 &amp;= ~tmpreg2;
+    /* Calculate the mask to set */
+    tmpreg2 = (uint32_t)ADC_Channel &lt;&lt; (5 * (Rank - 7));
+    /* Set the SQx bits for the selected rank */
+    tmpreg1 |= tmpreg2;
+    /* Store the new register value */
+    ADCx-&gt;SQR2 = tmpreg1;
+  }
+  /* For Rank 13 to 16 */
+  else
+  {
+    /* Get the old register value */
+    tmpreg1 = ADCx-&gt;SQR1;
+    /* Calculate the mask to clear */
+    tmpreg2 = SQR1_SQ_Set &lt;&lt; (5 * (Rank - 13));
+    /* Clear the old SQx bits for the selected rank */
+    tmpreg1 &amp;= ~tmpreg2;
+    /* Calculate the mask to set */
+    tmpreg2 = (uint32_t)ADC_Channel &lt;&lt; (5 * (Rank - 13));
+    /* Set the SQx bits for the selected rank */
+    tmpreg1 |= tmpreg2;
+    /* Store the new register value */
+    ADCx-&gt;SQR1 = tmpreg1;
+  }
+}
+
+/**
+  * @brief  Enables or disables the ADCx conversion through external trigger.
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @param  NewState: new state of the selected ADC external trigger start of conversion.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void ADC_ExternalTrigConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected ADC conversion on external event */
+    ADCx-&gt;CR2 |= CR2_EXTTRIG_Set;
+  }
+  else
+  {
+    /* Disable the selected ADC conversion on external event */
+    ADCx-&gt;CR2 &amp;= CR2_EXTTRIG_Reset;
+  }
+}
+
+/**
+  * @brief  Returns the last ADCx conversion result data for regular channel.
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @retval The Data conversion value.
+  */
+uint16_t ADC_GetConversionValue(ADC_TypeDef* ADCx)
+{
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  /* Return the selected ADC conversion value */
+  return (uint16_t) ADCx-&gt;DR;
+}
+
+/**
+  * @brief  Returns the last ADC1 and ADC2 conversion result data in dual mode.
+  * @retval The Data conversion value.
+  */
+uint32_t ADC_GetDualModeConversionValue(void)
+{
+  /* Return the dual mode conversion value */
+  return (*(__IO uint32_t *) DR_ADDRESS);
+}
+
+/**
+  * @brief  Enables or disables the selected ADC automatic injected group
+  *   conversion after regular one.
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @param  NewState: new state of the selected ADC auto injected conversion
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void ADC_AutoInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected ADC automatic injected group conversion */
+    ADCx-&gt;CR1 |= CR1_JAUTO_Set;
+  }
+  else
+  {
+    /* Disable the selected ADC automatic injected group conversion */
+    ADCx-&gt;CR1 &amp;= CR1_JAUTO_Reset;
+  }
+}
+
+/**
+  * @brief  Enables or disables the discontinuous mode for injected group
+  *   channel for the specified ADC
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @param  NewState: new state of the selected ADC discontinuous mode
+  *   on injected group channel.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void ADC_InjectedDiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected ADC injected discontinuous mode */
+    ADCx-&gt;CR1 |= CR1_JDISCEN_Set;
+  }
+  else
+  {
+    /* Disable the selected ADC injected discontinuous mode */
+    ADCx-&gt;CR1 &amp;= CR1_JDISCEN_Reset;
+  }
+}
+
+/**
+  * @brief  Configures the ADCx external trigger for injected channels conversion.
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @param  ADC_ExternalTrigInjecConv: specifies the ADC trigger to start injected conversion. 
+  *   This parameter can be one of the following values:
+  *     @arg ADC_ExternalTrigInjecConv_T1_TRGO: Timer1 TRGO event selected (for ADC1, ADC2 and ADC3)
+  *     @arg ADC_ExternalTrigInjecConv_T1_CC4: Timer1 capture compare4 selected (for ADC1, ADC2 and ADC3)
+  *     @arg ADC_ExternalTrigInjecConv_T2_TRGO: Timer2 TRGO event selected (for ADC1 and ADC2)
+  *     @arg ADC_ExternalTrigInjecConv_T2_CC1: Timer2 capture compare1 selected (for ADC1 and ADC2)
+  *     @arg ADC_ExternalTrigInjecConv_T3_CC4: Timer3 capture compare4 selected (for ADC1 and ADC2)
+  *     @arg ADC_ExternalTrigInjecConv_T4_TRGO: Timer4 TRGO event selected (for ADC1 and ADC2)
+  *     @arg ADC_ExternalTrigInjecConv_Ext_IT15_TIM8_CC4: External interrupt line 15 or Timer8
+  *                                                       capture compare4 event selected (for ADC1 and ADC2)                       
+  *     @arg ADC_ExternalTrigInjecConv_T4_CC3: Timer4 capture compare3 selected (for ADC3 only)
+  *     @arg ADC_ExternalTrigInjecConv_T8_CC2: Timer8 capture compare2 selected (for ADC3 only)                         
+  *     @arg ADC_ExternalTrigInjecConv_T8_CC4: Timer8 capture compare4 selected (for ADC3 only)
+  *     @arg ADC_ExternalTrigInjecConv_T5_TRGO: Timer5 TRGO event selected (for ADC3 only)                         
+  *     @arg ADC_ExternalTrigInjecConv_T5_CC4: Timer5 capture compare4 selected (for ADC3 only)                        
+  *     @arg ADC_ExternalTrigInjecConv_None: Injected conversion started by software and not
+  *                                          by external trigger (for ADC1, ADC2 and ADC3)
+  * @retval None
+  */
+void ADC_ExternalTrigInjectedConvConfig(ADC_TypeDef* ADCx, uint32_t ADC_ExternalTrigInjecConv)
+{
+  uint32_t tmpreg = 0;
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_ADC_EXT_INJEC_TRIG(ADC_ExternalTrigInjecConv));
+  /* Get the old register value */
+  tmpreg = ADCx-&gt;CR2;
+  /* Clear the old external event selection for injected group */
+  tmpreg &amp;= CR2_JEXTSEL_Reset;
+  /* Set the external event selection for injected group */
+  tmpreg |= ADC_ExternalTrigInjecConv;
+  /* Store the new register value */
+  ADCx-&gt;CR2 = tmpreg;
+}
+
+/**
+  * @brief  Enables or disables the ADCx injected channels conversion through
+  *   external trigger
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @param  NewState: new state of the selected ADC external trigger start of
+  *   injected conversion.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void ADC_ExternalTrigInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected ADC external event selection for injected group */
+    ADCx-&gt;CR2 |= CR2_JEXTTRIG_Set;
+  }
+  else
+  {
+    /* Disable the selected ADC external event selection for injected group */
+    ADCx-&gt;CR2 &amp;= CR2_JEXTTRIG_Reset;
+  }
+}
+
+/**
+  * @brief  Enables or disables the selected ADC start of the injected 
+  *   channels conversion.
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @param  NewState: new state of the selected ADC software start injected conversion.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void ADC_SoftwareStartInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected ADC conversion for injected group on external event and start the selected
+       ADC injected conversion */
+    ADCx-&gt;CR2 |= CR2_JEXTTRIG_JSWSTART_Set;
+  }
+  else
+  {
+    /* Disable the selected ADC conversion on external event for injected group and stop the selected
+       ADC injected conversion */
+    ADCx-&gt;CR2 &amp;= CR2_JEXTTRIG_JSWSTART_Reset;
+  }
+}
+
+/**
+  * @brief  Gets the selected ADC Software start injected conversion Status.
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @retval The new state of ADC software start injected conversion (SET or RESET).
+  */
+FlagStatus ADC_GetSoftwareStartInjectedConvCmdStatus(ADC_TypeDef* ADCx)
+{
+  FlagStatus bitstatus = RESET;
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  /* Check the status of JSWSTART bit */
+  if ((ADCx-&gt;CR2 &amp; CR2_JSWSTART_Set) != (uint32_t)RESET)
+  {
+    /* JSWSTART bit is set */
+    bitstatus = SET;
+  }
+  else
+  {
+    /* JSWSTART bit is reset */
+    bitstatus = RESET;
+  }
+  /* Return the JSWSTART bit status */
+  return  bitstatus;
+}
+
+/**
+  * @brief  Configures for the selected ADC injected channel its corresponding
+  *   rank in the sequencer and its sample time.
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @param  ADC_Channel: the ADC channel to configure. 
+  *   This parameter can be one of the following values:
+  *     @arg ADC_Channel_0: ADC Channel0 selected
+  *     @arg ADC_Channel_1: ADC Channel1 selected
+  *     @arg ADC_Channel_2: ADC Channel2 selected
+  *     @arg ADC_Channel_3: ADC Channel3 selected
+  *     @arg ADC_Channel_4: ADC Channel4 selected
+  *     @arg ADC_Channel_5: ADC Channel5 selected
+  *     @arg ADC_Channel_6: ADC Channel6 selected
+  *     @arg ADC_Channel_7: ADC Channel7 selected
+  *     @arg ADC_Channel_8: ADC Channel8 selected
+  *     @arg ADC_Channel_9: ADC Channel9 selected
+  *     @arg ADC_Channel_10: ADC Channel10 selected
+  *     @arg ADC_Channel_11: ADC Channel11 selected
+  *     @arg ADC_Channel_12: ADC Channel12 selected
+  *     @arg ADC_Channel_13: ADC Channel13 selected
+  *     @arg ADC_Channel_14: ADC Channel14 selected
+  *     @arg ADC_Channel_15: ADC Channel15 selected
+  *     @arg ADC_Channel_16: ADC Channel16 selected
+  *     @arg ADC_Channel_17: ADC Channel17 selected
+  * @param  Rank: The rank in the injected group sequencer. This parameter must be between 1 and 4.
+  * @param  ADC_SampleTime: The sample time value to be set for the selected channel. 
+  *   This parameter can be one of the following values:
+  *     @arg ADC_SampleTime_1Cycles5: Sample time equal to 1.5 cycles
+  *     @arg ADC_SampleTime_7Cycles5: Sample time equal to 7.5 cycles
+  *     @arg ADC_SampleTime_13Cycles5: Sample time equal to 13.5 cycles
+  *     @arg ADC_SampleTime_28Cycles5: Sample time equal to 28.5 cycles	
+  *     @arg ADC_SampleTime_41Cycles5: Sample time equal to 41.5 cycles	
+  *     @arg ADC_SampleTime_55Cycles5: Sample time equal to 55.5 cycles	
+  *     @arg ADC_SampleTime_71Cycles5: Sample time equal to 71.5 cycles	
+  *     @arg ADC_SampleTime_239Cycles5: Sample time equal to 239.5 cycles	
+  * @retval None
+  */
+void ADC_InjectedChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
+{
+  uint32_t tmpreg1 = 0, tmpreg2 = 0, tmpreg3 = 0;
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_ADC_CHANNEL(ADC_Channel));
+  assert_param(IS_ADC_INJECTED_RANK(Rank));
+  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
+  /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
+  if (ADC_Channel &gt; ADC_Channel_9)
+  {
+    /* Get the old register value */
+    tmpreg1 = ADCx-&gt;SMPR1;
+    /* Calculate the mask to clear */
+    tmpreg2 = SMPR1_SMP_Set &lt;&lt; (3*(ADC_Channel - 10));
+    /* Clear the old channel sample time */
+    tmpreg1 &amp;= ~tmpreg2;
+    /* Calculate the mask to set */
+    tmpreg2 = (uint32_t)ADC_SampleTime &lt;&lt; (3*(ADC_Channel - 10));
+    /* Set the new channel sample time */
+    tmpreg1 |= tmpreg2;
+    /* Store the new register value */
+    ADCx-&gt;SMPR1 = tmpreg1;
+  }
+  else /* ADC_Channel include in ADC_Channel_[0..9] */
+  {
+    /* Get the old register value */
+    tmpreg1 = ADCx-&gt;SMPR2;
+    /* Calculate the mask to clear */
+    tmpreg2 = SMPR2_SMP_Set &lt;&lt; (3 * ADC_Channel);
+    /* Clear the old channel sample time */
+    tmpreg1 &amp;= ~tmpreg2;
+    /* Calculate the mask to set */
+    tmpreg2 = (uint32_t)ADC_SampleTime &lt;&lt; (3 * ADC_Channel);
+    /* Set the new channel sample time */
+    tmpreg1 |= tmpreg2;
+    /* Store the new register value */
+    ADCx-&gt;SMPR2 = tmpreg1;
+  }
+  /* Rank configuration */
+  /* Get the old register value */
+  tmpreg1 = ADCx-&gt;JSQR;
+  /* Get JL value: Number = JL+1 */
+  tmpreg3 =  (tmpreg1 &amp; JSQR_JL_Set)&gt;&gt; 20;
+  /* Calculate the mask to clear: ((Rank-1)+(4-JL-1)) */
+  tmpreg2 = JSQR_JSQ_Set &lt;&lt; (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1)));
+  /* Clear the old JSQx bits for the selected rank */
+  tmpreg1 &amp;= ~tmpreg2;
+  /* Calculate the mask to set: ((Rank-1)+(4-JL-1)) */
+  tmpreg2 = (uint32_t)ADC_Channel &lt;&lt; (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1)));
+  /* Set the JSQx bits for the selected rank */
+  tmpreg1 |= tmpreg2;
+  /* Store the new register value */
+  ADCx-&gt;JSQR = tmpreg1;
+}
+
+/**
+  * @brief  Configures the sequencer length for injected channels
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @param  Length: The sequencer length. 
+  *   This parameter must be a number between 1 to 4.
+  * @retval None
+  */
+void ADC_InjectedSequencerLengthConfig(ADC_TypeDef* ADCx, uint8_t Length)
+{
+  uint32_t tmpreg1 = 0;
+  uint32_t tmpreg2 = 0;
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_ADC_INJECTED_LENGTH(Length));
+  
+  /* Get the old register value */
+  tmpreg1 = ADCx-&gt;JSQR;
+  /* Clear the old injected sequnence lenght JL bits */
+  tmpreg1 &amp;= JSQR_JL_Reset;
+  /* Set the injected sequnence lenght JL bits */
+  tmpreg2 = Length - 1; 
+  tmpreg1 |= tmpreg2 &lt;&lt; 20;
+  /* Store the new register value */
+  ADCx-&gt;JSQR = tmpreg1;
+}
+
+/**
+  * @brief  Set the injected channels conversion value offset
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @param  ADC_InjectedChannel: the ADC injected channel to set its offset. 
+  *   This parameter can be one of the following values:
+  *     @arg ADC_InjectedChannel_1: Injected Channel1 selected
+  *     @arg ADC_InjectedChannel_2: Injected Channel2 selected
+  *     @arg ADC_InjectedChannel_3: Injected Channel3 selected
+  *     @arg ADC_InjectedChannel_4: Injected Channel4 selected
+  * @param  Offset: the offset value for the selected ADC injected channel
+  *   This parameter must be a 12bit value.
+  * @retval None
+  */
+void ADC_SetInjectedOffset(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel, uint16_t Offset)
+{
+  __IO uint32_t tmp = 0;
+  
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
+  assert_param(IS_ADC_OFFSET(Offset));  
+  
+  tmp = (uint32_t)ADCx;
+  tmp += ADC_InjectedChannel;
+  
+  /* Set the selected injected channel data offset */
+  *(__IO uint32_t *) tmp = (uint32_t)Offset;
+}
+
+/**
+  * @brief  Returns the ADC injected channel conversion result
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @param  ADC_InjectedChannel: the converted ADC injected channel.
+  *   This parameter can be one of the following values:
+  *     @arg ADC_InjectedChannel_1: Injected Channel1 selected
+  *     @arg ADC_InjectedChannel_2: Injected Channel2 selected
+  *     @arg ADC_InjectedChannel_3: Injected Channel3 selected
+  *     @arg ADC_InjectedChannel_4: Injected Channel4 selected
+  * @retval The Data conversion value.
+  */
+uint16_t ADC_GetInjectedConversionValue(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel)
+{
+  __IO uint32_t tmp = 0;
+  
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
+
+  tmp = (uint32_t)ADCx;
+  tmp += ADC_InjectedChannel + JDR_Offset;
+  
+  /* Returns the selected injected channel conversion data value */
+  return (uint16_t) (*(__IO uint32_t*)  tmp);   
+}
+
+/**
+  * @brief  Enables or disables the analog watchdog on single/all regular
+  *   or injected channels
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @param  ADC_AnalogWatchdog: the ADC analog watchdog configuration.
+  *   This parameter can be one of the following values:
+  *     @arg ADC_AnalogWatchdog_SingleRegEnable: Analog watchdog on a single regular channel
+  *     @arg ADC_AnalogWatchdog_SingleInjecEnable: Analog watchdog on a single injected channel
+  *     @arg ADC_AnalogWatchdog_SingleRegOrInjecEnable: Analog watchdog on a single regular or injected channel
+  *     @arg ADC_AnalogWatchdog_AllRegEnable: Analog watchdog on  all regular channel
+  *     @arg ADC_AnalogWatchdog_AllInjecEnable: Analog watchdog on  all injected channel
+  *     @arg ADC_AnalogWatchdog_AllRegAllInjecEnable: Analog watchdog on all regular and injected channels
+  *     @arg ADC_AnalogWatchdog_None: No channel guarded by the analog watchdog
+  * @retval None	  
+  */
+void ADC_AnalogWatchdogCmd(ADC_TypeDef* ADCx, uint32_t ADC_AnalogWatchdog)
+{
+  uint32_t tmpreg = 0;
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_ADC_ANALOG_WATCHDOG(ADC_AnalogWatchdog));
+  /* Get the old register value */
+  tmpreg = ADCx-&gt;CR1;
+  /* Clear AWDEN, AWDENJ and AWDSGL bits */
+  tmpreg &amp;= CR1_AWDMode_Reset;
+  /* Set the analog watchdog enable mode */
+  tmpreg |= ADC_AnalogWatchdog;
+  /* Store the new register value */
+  ADCx-&gt;CR1 = tmpreg;
+}
+
+/**
+  * @brief  Configures the high and low thresholds of the analog watchdog.
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @param  HighThreshold: the ADC analog watchdog High threshold value.
+  *   This parameter must be a 12bit value.
+  * @param  LowThreshold: the ADC analog watchdog Low threshold value.
+  *   This parameter must be a 12bit value.
+  * @retval None
+  */
+void ADC_AnalogWatchdogThresholdsConfig(ADC_TypeDef* ADCx, uint16_t HighThreshold,
+                                        uint16_t LowThreshold)
+{
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_ADC_THRESHOLD(HighThreshold));
+  assert_param(IS_ADC_THRESHOLD(LowThreshold));
+  /* Set the ADCx high threshold */
+  ADCx-&gt;HTR = HighThreshold;
+  /* Set the ADCx low threshold */
+  ADCx-&gt;LTR = LowThreshold;
+}
+
+/**
+  * @brief  Configures the analog watchdog guarded single channel
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @param  ADC_Channel: the ADC channel to configure for the analog watchdog. 
+  *   This parameter can be one of the following values:
+  *     @arg ADC_Channel_0: ADC Channel0 selected
+  *     @arg ADC_Channel_1: ADC Channel1 selected
+  *     @arg ADC_Channel_2: ADC Channel2 selected
+  *     @arg ADC_Channel_3: ADC Channel3 selected
+  *     @arg ADC_Channel_4: ADC Channel4 selected
+  *     @arg ADC_Channel_5: ADC Channel5 selected
+  *     @arg ADC_Channel_6: ADC Channel6 selected
+  *     @arg ADC_Channel_7: ADC Channel7 selected
+  *     @arg ADC_Channel_8: ADC Channel8 selected
+  *     @arg ADC_Channel_9: ADC Channel9 selected
+  *     @arg ADC_Channel_10: ADC Channel10 selected
+  *     @arg ADC_Channel_11: ADC Channel11 selected
+  *     @arg ADC_Channel_12: ADC Channel12 selected
+  *     @arg ADC_Channel_13: ADC Channel13 selected
+  *     @arg ADC_Channel_14: ADC Channel14 selected
+  *     @arg ADC_Channel_15: ADC Channel15 selected
+  *     @arg ADC_Channel_16: ADC Channel16 selected
+  *     @arg ADC_Channel_17: ADC Channel17 selected
+  * @retval None
+  */
+void ADC_AnalogWatchdogSingleChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel)
+{
+  uint32_t tmpreg = 0;
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_ADC_CHANNEL(ADC_Channel));
+  /* Get the old register value */
+  tmpreg = ADCx-&gt;CR1;
+  /* Clear the Analog watchdog channel select bits */
+  tmpreg &amp;= CR1_AWDCH_Reset;
+  /* Set the Analog watchdog channel */
+  tmpreg |= ADC_Channel;
+  /* Store the new register value */
+  ADCx-&gt;CR1 = tmpreg;
+}
+
+/**
+  * @brief  Enables or disables the temperature sensor and Vrefint channel.
+  * @param  NewState: new state of the temperature sensor.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void ADC_TempSensorVrefintCmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the temperature sensor and Vrefint channel*/
+    ADC1-&gt;CR2 |= CR2_TSVREFE_Set;
+  }
+  else
+  {
+    /* Disable the temperature sensor and Vrefint channel*/
+    ADC1-&gt;CR2 &amp;= CR2_TSVREFE_Reset;
+  }
+}
+
+/**
+  * @brief  Checks whether the specified ADC flag is set or not.
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @param  ADC_FLAG: specifies the flag to check. 
+  *   This parameter can be one of the following values:
+  *     @arg ADC_FLAG_AWD: Analog watchdog flag
+  *     @arg ADC_FLAG_EOC: End of conversion flag
+  *     @arg ADC_FLAG_JEOC: End of injected group conversion flag
+  *     @arg ADC_FLAG_JSTRT: Start of injected group conversion flag
+  *     @arg ADC_FLAG_STRT: Start of regular group conversion flag
+  * @retval The new state of ADC_FLAG (SET or RESET).
+  */
+FlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, uint8_t ADC_FLAG)
+{
+  FlagStatus bitstatus = RESET;
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_ADC_GET_FLAG(ADC_FLAG));
+  /* Check the status of the specified ADC flag */
+  if ((ADCx-&gt;SR &amp; ADC_FLAG) != (uint8_t)RESET)
+  {
+    /* ADC_FLAG is set */
+    bitstatus = SET;
+  }
+  else
+  {
+    /* ADC_FLAG is reset */
+    bitstatus = RESET;
+  }
+  /* Return the ADC_FLAG status */
+  return  bitstatus;
+}
+
+/**
+  * @brief  Clears the ADCx's pending flags.
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @param  ADC_FLAG: specifies the flag to clear. 
+  *   This parameter can be any combination of the following values:
+  *     @arg ADC_FLAG_AWD: Analog watchdog flag
+  *     @arg ADC_FLAG_EOC: End of conversion flag
+  *     @arg ADC_FLAG_JEOC: End of injected group conversion flag
+  *     @arg ADC_FLAG_JSTRT: Start of injected group conversion flag
+  *     @arg ADC_FLAG_STRT: Start of regular group conversion flag
+  * @retval None
+  */
+void ADC_ClearFlag(ADC_TypeDef* ADCx, uint8_t ADC_FLAG)
+{
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_ADC_CLEAR_FLAG(ADC_FLAG));
+  /* Clear the selected ADC flags */
+  ADCx-&gt;SR = ~(uint32_t)ADC_FLAG;
+}
+
+/**
+  * @brief  Checks whether the specified ADC interrupt has occurred or not.
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @param  ADC_IT: specifies the ADC interrupt source to check. 
+  *   This parameter can be one of the following values:
+  *     @arg ADC_IT_EOC: End of conversion interrupt mask
+  *     @arg ADC_IT_AWD: Analog watchdog interrupt mask
+  *     @arg ADC_IT_JEOC: End of injected conversion interrupt mask
+  * @retval The new state of ADC_IT (SET or RESET).
+  */
+ITStatus ADC_GetITStatus(ADC_TypeDef* ADCx, uint16_t ADC_IT)
+{
+  ITStatus bitstatus = RESET;
+  uint32_t itmask = 0, enablestatus = 0;
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_ADC_GET_IT(ADC_IT));
+  /* Get the ADC IT index */
+  itmask = ADC_IT &gt;&gt; 8;
+  /* Get the ADC_IT enable bit status */
+  enablestatus = (ADCx-&gt;CR1 &amp; (uint8_t)ADC_IT) ;
+  /* Check the status of the specified ADC interrupt */
+  if (((ADCx-&gt;SR &amp; itmask) != (uint32_t)RESET) &amp;&amp; enablestatus)
+  {
+    /* ADC_IT is set */
+    bitstatus = SET;
+  }
+  else
+  {
+    /* ADC_IT is reset */
+    bitstatus = RESET;
+  }
+  /* Return the ADC_IT status */
+  return  bitstatus;
+}
+
+/**
+  * @brief  Clears the ADCx&#146;s interrupt pending bits.
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @param  ADC_IT: specifies the ADC interrupt pending bit to clear.
+  *   This parameter can be any combination of the following values:
+  *     @arg ADC_IT_EOC: End of conversion interrupt mask
+  *     @arg ADC_IT_AWD: Analog watchdog interrupt mask
+  *     @arg ADC_IT_JEOC: End of injected conversion interrupt mask
+  * @retval None
+  */
+void ADC_ClearITPendingBit(ADC_TypeDef* ADCx, uint16_t ADC_IT)
+{
+  uint8_t itmask = 0;
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_ADC_IT(ADC_IT));
+  /* Get the ADC IT index */
+  itmask = (uint8_t)(ADC_IT &gt;&gt; 8);
+  /* Clear the selected ADC interrupt pending bits */
+  ADCx-&gt;SR = ~(uint32_t)itmask;
+}
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2009 STMicroelectronics *****END OF FILE****/

Added: trunk/src/platform/stm32/FWLib/library/src/stm32f10x_adc.o
===================================================================
--- trunk/src/platform/stm32/FWLib/library/src/stm32f10x_adc.o	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/src/stm32f10x_adc.o	2009-07-08 23:39:34 UTC (rev 354)
@@ -0,0 +1,14 @@
+ELF
+h#&#244;p##&#244;&#128;sC
+y&#181;C&#234;#C`&#203;h&#138;h&#132;hCK&#234;CKyB&#234;C&#130;`|&#194;j;&quot;&#244;p&#219;&#178;B&#234;R&#194;b&#189;&#253;&#247;&#241;&#255;
+&#224;&quot;bC#&#147;@&#250;&#242;i!&#234;Ca&#188;&#241;&#216;&quot;&#251;&#242;#:&#147;@&#250;&#242;Ak!&#234;CAc&#224;&#188;&#241;&#216;&quot;&#251;&#242;##:&#147;@&#250;&#242;k!&#234;Cc&#224;&quot;&#251;&#242;#A:&#147;@&#250;&#242;&#193;j!&#234;C&#193;b0&#189;&#177;&#131;hC&#244;&#128;&#224;&#131;h#&#244;&#128;&#131;`pG&#192;l&#128;&#178;pG
+M	

+
+
+
+
+
+w
+w
+w
+w
\ No newline at end of file

Modified: trunk/src/platform/stm32/FWLib/library/src/stm32f10x_bkp.c
===================================================================
--- trunk/src/platform/stm32/FWLib/library/src/stm32f10x_bkp.c	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/src/stm32f10x_bkp.c	2009-07-08 23:39:34 UTC (rev 354)
@@ -1,272 +1,311 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_bkp.c
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file provides all the BKP firmware functions.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
-
-/* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_bkp.h&quot;
-#include &quot;stm32f10x_rcc.h&quot;
-
-/* Private typedef -----------------------------------------------------------*/
-/* Private define ------------------------------------------------------------*/
-/* ------------ BKP registers bit address in the alias region ----------- */
-#define BKP_OFFSET        (BKP_BASE - PERIPH_BASE)
-
-/* --- CR Register ---*/
-/* Alias word address of TPAL bit */
-#define CR_OFFSET         (BKP_OFFSET + 0x30)
-#define TPAL_BitNumber    0x01
-#define CR_TPAL_BB        (PERIPH_BB_BASE + (CR_OFFSET * 32) + (TPAL_BitNumber * 4))
-
-/* Alias word address of TPE bit */
-#define TPE_BitNumber     0x00
-#define CR_TPE_BB         (PERIPH_BB_BASE + (CR_OFFSET * 32) + (TPE_BitNumber * 4))
-
-/* --- CSR Register ---*/
-/* Alias word address of TPIE bit */
-#define CSR_OFFSET        (BKP_OFFSET + 0x34)
-#define TPIE_BitNumber    0x02
-#define CSR_TPIE_BB       (PERIPH_BB_BASE + (CSR_OFFSET * 32) + (TPIE_BitNumber * 4))
-
-/* Alias word address of TIF bit */
-#define TIF_BitNumber     0x09
-#define CSR_TIF_BB        (PERIPH_BB_BASE + (CSR_OFFSET * 32) + (TIF_BitNumber * 4))
-
-/* Alias word address of TEF bit */
-#define TEF_BitNumber     0x08
-#define CSR_TEF_BB        (PERIPH_BB_BASE + (CSR_OFFSET * 32) + (TEF_BitNumber * 4))
-
-
-/* ---------------------- BKP registers bit mask ------------------------ */
-/* RTCCR register bit mask */
-#define RTCCR_CAL_Mask    ((u16)0xFF80)
-#define RTCCR_Mask        ((u16)0xFC7F)
-
-/* CSR register bit mask */
-#define CSR_CTE_Set       ((u16)0x0001)
-#define CSR_CTI_Set       ((u16)0x0002)
-
-/* Private macro -------------------------------------------------------------*/
-/* Private variables ---------------------------------------------------------*/
-/* Private function prototypes -----------------------------------------------*/
-/* Private functions ---------------------------------------------------------*/
-
-/*******************************************************************************
-* Function Name  : BKP_DeInit
-* Description    : Deinitializes the BKP peripheral registers to their default
-*                  reset values.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void BKP_DeInit(void)
-{
-  RCC_BackupResetCmd(ENABLE);
-  RCC_BackupResetCmd(DISABLE);
-}
-
-/*******************************************************************************
-* Function Name  : BKP_TamperPinLevelConfig
-* Description    : Configures the Tamper Pin active level.
-* Input          : - BKP_TamperPinLevel: specifies the Tamper Pin active level.
-*                    This parameter can be one of the following values:
-*                       - BKP_TamperPinLevel_High: Tamper pin active on high level
-*                       - BKP_TamperPinLevel_Low: Tamper pin active on low level
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void BKP_TamperPinLevelConfig(u16 BKP_TamperPinLevel)
-{
-  /* Check the parameters */
-  assert_param(IS_BKP_TAMPER_PIN_LEVEL(BKP_TamperPinLevel));
-
-  *(vu32 *) CR_TPAL_BB = BKP_TamperPinLevel;
-}
-
-/*******************************************************************************
-* Function Name  : BKP_TamperPinCmd
-* Description    : Enables or disables the Tamper Pin activation.
-* Input          : - NewState: new state of the Tamper Pin activation.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void BKP_TamperPinCmd(FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  *(vu32 *) CR_TPE_BB = (u32)NewState;
-}
-
-/*******************************************************************************
-* Function Name  : BKP_ITConfig
-* Description    : Enables or disables the Tamper Pin Interrupt.
-* Input          : - NewState: new state of the Tamper Pin Interrupt.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void BKP_ITConfig(FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  *(vu32 *) CSR_TPIE_BB = (u32)NewState;
-}
-
-/*******************************************************************************
-* Function Name  : BKP_RTCOutputConfig
-* Description    : Select the RTC output source to output on the Tamper pin.
-* Input          : - BKP_RTCOutputSource: specifies the RTC output source.
-*                    This parameter can be one of the following values:
-*                       - BKP_RTCOutputSource_None: no RTC output on the Tamper pin.
-*                       - BKP_RTCOutputSource_CalibClock: output the RTC clock
-*                         with frequency divided by 64 on the Tamper pin.
-*                       - BKP_RTCOutputSource_Alarm: output the RTC Alarm pulse 
-*                         signal on the Tamper pin.
-*                       - BKP_RTCOutputSource_Second: output the RTC Second pulse 
-*                         signal on the Tamper pin.  
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void BKP_RTCOutputConfig(u16 BKP_RTCOutputSource)
-{
-  u16 tmpreg = 0;
-
-  /* Check the parameters */
-  assert_param(IS_BKP_RTC_OUTPUT_SOURCE(BKP_RTCOutputSource));
-
-  tmpreg = BKP-&gt;RTCCR;
-
-  /* Clear CCO, ASOE and ASOS bits */
-  tmpreg &amp;= RTCCR_Mask;
-  
-  /* Set CCO, ASOE and ASOS bits according to BKP_RTCOutputSource value */
-  tmpreg |= BKP_RTCOutputSource;
-
-  /* Store the new value */
-  BKP-&gt;RTCCR = tmpreg;
-}
-
-/*******************************************************************************
-* Function Name  : BKP_SetRTCCalibrationValue
-* Description    : Sets RTC Clock Calibration value.
-* Input          : - CalibrationValue: specifies the RTC Clock Calibration value.
-*                    This parameter must be a number between 0 and 0x7F.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void BKP_SetRTCCalibrationValue(u8 CalibrationValue)
-{
-  u16 tmpreg = 0;
-
-  /* Check the parameters */
-  assert_param(IS_BKP_CALIBRATION_VALUE(CalibrationValue));
-
-  tmpreg = BKP-&gt;RTCCR;
-
-  /* Clear CAL[6:0] bits */
-  tmpreg &amp;= RTCCR_CAL_Mask;
-
-  /* Set CAL[6:0] bits according to CalibrationValue value */
-  tmpreg |= CalibrationValue;
-
-  /* Store the new value */
-  BKP-&gt;RTCCR = tmpreg;
-}
-
-/*******************************************************************************
-* Function Name  : BKP_WriteBackupRegister
-* Description    : Writes user data to the specified Data Backup Register.
-* Input          : - BKP_DR: specifies the Data Backup Register.
-*                    This parameter can be BKP_DRx where x:[1, 42]
-*                  - Data: data to write
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void BKP_WriteBackupRegister(u16 BKP_DR, u16 Data)
-{
-  /* Check the parameters */
-  assert_param(IS_BKP_DR(BKP_DR));
-
-  *(vu16 *) (BKP_BASE + BKP_DR) = Data;
-}
-
-/*******************************************************************************
-* Function Name  : BKP_ReadBackupRegister
-* Description    : Reads data from the specified Data Backup Register.
-* Input          : - BKP_DR: specifies the Data Backup Register.
-*                    This parameter can be BKP_DRx where x:[1, 42]
-* Output         : None
-* Return         : The content of the specified Data Backup Register
-*******************************************************************************/
-u16 BKP_ReadBackupRegister(u16 BKP_DR)
-{
-  /* Check the parameters */
-  assert_param(IS_BKP_DR(BKP_DR));
-
-  return (*(vu16 *) (BKP_BASE + BKP_DR));
-}
-
-/*******************************************************************************
-* Function Name  : BKP_GetFlagStatus
-* Description    : Checks whether the Tamper Pin Event flag is set or not.
-* Input          : None
-* Output         : None
-* Return         : The new state of the Tamper Pin Event flag (SET or RESET).
-*******************************************************************************/
-FlagStatus BKP_GetFlagStatus(void)
-{
-  return (FlagStatus)(*(vu32 *) CSR_TEF_BB);
-}
-
-/*******************************************************************************
-* Function Name  : BKP_ClearFlag
-* Description    : Clears Tamper Pin Event pending flag.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void BKP_ClearFlag(void)
-{
-  /* Set CTE bit to clear Tamper Pin Event flag */
-  BKP-&gt;CSR |= CSR_CTE_Set;
-}
-
-/*******************************************************************************
-* Function Name  : BKP_GetITStatus
-* Description    : Checks whether the Tamper Pin Interrupt has occurred or not.
-* Input          : None
-* Output         : None
-* Return         : The new state of the Tamper Pin Interrupt (SET or RESET).
-*******************************************************************************/
-ITStatus BKP_GetITStatus(void)
-{
-  return (ITStatus)(*(vu32 *) CSR_TIF_BB);
-}
-
-/*******************************************************************************
-* Function Name  : BKP_ClearITPendingBit
-* Description    : Clears Tamper Pin Interrupt pending bit.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void BKP_ClearITPendingBit(void)
-{
-  /* Set CTI bit to clear Tamper Pin Interrupt pending bit */
-  BKP-&gt;CSR |= CSR_CTI_Set;
-}
-
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
+/**
+  ******************************************************************************
+  * @file    stm32f10x_bkp.c
+  * @author  MCD Application Team
+  * @version V3.1.0
+  * @date    06/19/2009
+  * @brief   This file provides all the BKP firmware functions.
+  ******************************************************************************
+  * @copy
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * &lt;h2&gt;&lt;center&gt;&copy; COPYRIGHT 2009 STMicroelectronics&lt;/center&gt;&lt;/h2&gt;
+  */ 
+
+/* Includes ------------------------------------------------------------------*/
+#include &quot;stm32f10x_bkp.h&quot;
+#include &quot;stm32f10x_rcc.h&quot;
+
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup BKP 
+  * @brief BKP driver modules
+  * @{
+  */
+
+/** @defgroup BKP_Private_TypesDefinitions
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup BKP_Private_Defines
+  * @{
+  */
+
+/* ------------ BKP registers bit address in the alias region --------------- */
+#define BKP_OFFSET        (BKP_BASE - PERIPH_BASE)
+
+/* --- CR Register ----*/
+
+/* Alias word address of TPAL bit */
+#define CR_OFFSET         (BKP_OFFSET + 0x30)
+#define TPAL_BitNumber    0x01
+#define CR_TPAL_BB        (PERIPH_BB_BASE + (CR_OFFSET * 32) + (TPAL_BitNumber * 4))
+
+/* Alias word address of TPE bit */
+#define TPE_BitNumber     0x00
+#define CR_TPE_BB         (PERIPH_BB_BASE + (CR_OFFSET * 32) + (TPE_BitNumber * 4))
+
+/* --- CSR Register ---*/
+
+/* Alias word address of TPIE bit */
+#define CSR_OFFSET        (BKP_OFFSET + 0x34)
+#define TPIE_BitNumber    0x02
+#define CSR_TPIE_BB       (PERIPH_BB_BASE + (CSR_OFFSET * 32) + (TPIE_BitNumber * 4))
+
+/* Alias word address of TIF bit */
+#define TIF_BitNumber     0x09
+#define CSR_TIF_BB        (PERIPH_BB_BASE + (CSR_OFFSET * 32) + (TIF_BitNumber * 4))
+
+/* Alias word address of TEF bit */
+#define TEF_BitNumber     0x08
+#define CSR_TEF_BB        (PERIPH_BB_BASE + (CSR_OFFSET * 32) + (TEF_BitNumber * 4))
+
+/* ---------------------- BKP registers bit mask ------------------------ */
+
+/* RTCCR register bit mask */
+#define RTCCR_CAL_Mask    ((uint16_t)0xFF80)
+#define RTCCR_Mask        ((uint16_t)0xFC7F)
+
+/* CSR register bit mask */
+#define CSR_CTE_Set       ((uint16_t)0x0001)
+#define CSR_CTI_Set       ((uint16_t)0x0002)
+
+/**
+  * @}
+  */ 
+
+
+/** @defgroup BKP_Private_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup BKP_Private_Variables
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup BKP_Private_FunctionPrototypes
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup BKP_Private_Functions
+  * @{
+  */
+
+/**
+  * @brief  Deinitializes the BKP peripheral registers to their default reset values.
+  * @param  None
+  * @retval None
+  */
+void BKP_DeInit(void)
+{
+  RCC_BackupResetCmd(ENABLE);
+  RCC_BackupResetCmd(DISABLE);
+}
+
+/**
+  * @brief  Configures the Tamper Pin active level.
+  * @param  BKP_TamperPinLevel: specifies the Tamper Pin active level.
+  *   This parameter can be one of the following values:
+  *     @arg BKP_TamperPinLevel_High: Tamper pin active on high level
+  *     @arg BKP_TamperPinLevel_Low: Tamper pin active on low level
+  * @retval None
+  */
+void BKP_TamperPinLevelConfig(uint16_t BKP_TamperPinLevel)
+{
+  /* Check the parameters */
+  assert_param(IS_BKP_TAMPER_PIN_LEVEL(BKP_TamperPinLevel));
+  *(__IO uint32_t *) CR_TPAL_BB = BKP_TamperPinLevel;
+}
+
+/**
+  * @brief  Enables or disables the Tamper Pin activation.
+  * @param  NewState: new state of the Tamper Pin activation.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void BKP_TamperPinCmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  *(__IO uint32_t *) CR_TPE_BB = (uint32_t)NewState;
+}
+
+/**
+  * @brief  Enables or disables the Tamper Pin Interrupt.
+  * @param  NewState: new state of the Tamper Pin Interrupt.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void BKP_ITConfig(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  *(__IO uint32_t *) CSR_TPIE_BB = (uint32_t)NewState;
+}
+
+/**
+  * @brief  Select the RTC output source to output on the Tamper pin.
+  * @param  BKP_RTCOutputSource: specifies the RTC output source.
+  *   This parameter can be one of the following values:
+  *     @arg BKP_RTCOutputSource_None: no RTC output on the Tamper pin.
+  *     @arg BKP_RTCOutputSource_CalibClock: output the RTC clock with frequency
+  *                                          divided by 64 on the Tamper pin.
+  *     @arg BKP_RTCOutputSource_Alarm: output the RTC Alarm pulse signal on
+  *                                     the Tamper pin.
+  *     @arg BKP_RTCOutputSource_Second: output the RTC Second pulse signal on
+  *                                      the Tamper pin.  
+  * @retval None
+  */
+void BKP_RTCOutputConfig(uint16_t BKP_RTCOutputSource)
+{
+  uint16_t tmpreg = 0;
+  /* Check the parameters */
+  assert_param(IS_BKP_RTC_OUTPUT_SOURCE(BKP_RTCOutputSource));
+  tmpreg = BKP-&gt;RTCCR;
+  /* Clear CCO, ASOE and ASOS bits */
+  tmpreg &amp;= RTCCR_Mask;
+  
+  /* Set CCO, ASOE and ASOS bits according to BKP_RTCOutputSource value */
+  tmpreg |= BKP_RTCOutputSource;
+  /* Store the new value */
+  BKP-&gt;RTCCR = tmpreg;
+}
+
+/**
+  * @brief  Sets RTC Clock Calibration value.
+  * @param  CalibrationValue: specifies the RTC Clock Calibration value.
+  *   This parameter must be a number between 0 and 0x7F.
+  * @retval None
+  */
+void BKP_SetRTCCalibrationValue(uint8_t CalibrationValue)
+{
+  uint16_t tmpreg = 0;
+  /* Check the parameters */
+  assert_param(IS_BKP_CALIBRATION_VALUE(CalibrationValue));
+  tmpreg = BKP-&gt;RTCCR;
+  /* Clear CAL[6:0] bits */
+  tmpreg &amp;= RTCCR_CAL_Mask;
+  /* Set CAL[6:0] bits according to CalibrationValue value */
+  tmpreg |= CalibrationValue;
+  /* Store the new value */
+  BKP-&gt;RTCCR = tmpreg;
+}
+
+/**
+  * @brief  Writes user data to the specified Data Backup Register.
+  * @param  BKP_DR: specifies the Data Backup Register.
+  *   This parameter can be BKP_DRx where x:[1, 42]
+  * @param  Data: data to write
+  * @retval None
+  */
+void BKP_WriteBackupRegister(uint16_t BKP_DR, uint16_t Data)
+{
+  __IO uint32_t tmp = 0;
+
+  /* Check the parameters */
+  assert_param(IS_BKP_DR(BKP_DR));
+
+  tmp = (uint32_t)BKP_BASE; 
+  tmp += BKP_DR;
+
+  *(__IO uint32_t *) tmp = Data;
+}
+
+/**
+  * @brief  Reads data from the specified Data Backup Register.
+  * @param  BKP_DR: specifies the Data Backup Register.
+  *   This parameter can be BKP_DRx where x:[1, 42]
+  * @retval The content of the specified Data Backup Register
+  */
+uint16_t BKP_ReadBackupRegister(uint16_t BKP_DR)
+{
+  __IO uint32_t tmp = 0;
+
+  /* Check the parameters */
+  assert_param(IS_BKP_DR(BKP_DR));
+
+  tmp = (uint32_t)BKP_BASE; 
+  tmp += BKP_DR;
+
+  return (*(__IO uint16_t *) tmp);
+}
+
+/**
+  * @brief  Checks whether the Tamper Pin Event flag is set or not.
+  * @param  None
+  * @retval The new state of the Tamper Pin Event flag (SET or RESET).
+  */
+FlagStatus BKP_GetFlagStatus(void)
+{
+  return (FlagStatus)(*(__IO uint32_t *) CSR_TEF_BB);
+}
+
+/**
+  * @brief  Clears Tamper Pin Event pending flag.
+  * @param  None
+  * @retval None
+  */
+void BKP_ClearFlag(void)
+{
+  /* Set CTE bit to clear Tamper Pin Event flag */
+  BKP-&gt;CSR |= CSR_CTE_Set;
+}
+
+/**
+  * @brief  Checks whether the Tamper Pin Interrupt has occurred or not.
+  * @param  None
+  * @retval The new state of the Tamper Pin Interrupt (SET or RESET).
+  */
+ITStatus BKP_GetITStatus(void)
+{
+  return (ITStatus)(*(__IO uint32_t *) CSR_TIF_BB);
+}
+
+/**
+  * @brief  Clears Tamper Pin Interrupt pending bit.
+  * @param  None
+  * @retval None
+  */
+void BKP_ClearITPendingBit(void)
+{
+  /* Set CTI bit to clear Tamper Pin Interrupt pending bit */
+  BKP-&gt;CSR |= CSR_CTI_Set;
+}
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2009 STMicroelectronics *****END OF FILE****/

Added: trunk/src/platform/stm32/FWLib/library/src/stm32f10x_bkp.o
===================================================================
--- trunk/src/platform/stm32/FWLib/library/src/stm32f10x_bkp.o	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/src/stm32f10x_bkp.o	2009-07-08 23:39:34 UTC (rev 354)
@@ -0,0 +1,10 @@
+ELF
+M	
+
+
+
+
+
+7
+
+7
\ No newline at end of file

Modified: trunk/src/platform/stm32/FWLib/library/src/stm32f10x_can.c
===================================================================
--- trunk/src/platform/stm32/FWLib/library/src/stm32f10x_can.c	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/src/stm32f10x_can.c	2009-07-08 23:39:34 UTC (rev 354)
@@ -1,907 +1,990 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_can.c
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file provides all the CAN firmware functions.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
-
-/* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_can.h&quot;
-#include &quot;stm32f10x_rcc.h&quot;
-
-/* Private typedef -----------------------------------------------------------*/
-
-/* Private define ------------------------------------------------------------*/
-/* CAN Master Control Register bits */
-#define MCR_INRQ     ((u32)0x00000001) /* Initialization request */
-#define MCR_SLEEP    ((u32)0x00000002) /* Sleep mode request */
-#define MCR_TXFP     ((u32)0x00000004) /* Transmit FIFO priority */
-#define MCR_RFLM     ((u32)0x00000008) /* Receive FIFO locked mode */
-#define MCR_NART     ((u32)0x00000010) /* No automatic retransmission */
-#define MCR_AWUM     ((u32)0x00000020) /* Automatic wake up mode */
-#define MCR_ABOM     ((u32)0x00000040) /* Automatic bus-off management */
-#define MCR_TTCM     ((u32)0x00000080) /* time triggered communication */
-
-/* CAN Master Status Register bits */
-#define MSR_INAK     ((u32)0x00000001)    /* Initialization acknowledge */
-#define MSR_WKUI     ((u32)0x00000008)    /* Wake-up interrupt */
-#define MSR_SLAKI    ((u32)0x00000010)    /* Sleep acknowledge interrupt */
-
-/* CAN Transmit Status Register bits */
-#define TSR_RQCP0    ((u32)0x00000001)    /* Request completed mailbox0 */
-#define TSR_TXOK0    ((u32)0x00000002)    /* Transmission OK of mailbox0 */
-#define TSR_ABRQ0    ((u32)0x00000080)    /* Abort request for mailbox0 */
-#define TSR_RQCP1    ((u32)0x00000100)    /* Request completed mailbox1 */
-#define TSR_TXOK1    ((u32)0x00000200)    /* Transmission OK of mailbox1 */
-#define TSR_ABRQ1    ((u32)0x00008000)    /* Abort request for mailbox1 */
-#define TSR_RQCP2    ((u32)0x00010000)    /* Request completed mailbox2 */
-#define TSR_TXOK2    ((u32)0x00020000)    /* Transmission OK of mailbox2 */
-#define TSR_ABRQ2    ((u32)0x00800000)    /* Abort request for mailbox2 */
-#define TSR_TME0     ((u32)0x04000000)    /* Transmit mailbox 0 empty */
-#define TSR_TME1     ((u32)0x08000000)    /* Transmit mailbox 1 empty */
-#define TSR_TME2     ((u32)0x10000000)    /* Transmit mailbox 2 empty */
-
-/* CAN Receive FIFO 0 Register bits */
-#define RF0R_FULL0   ((u32)0x00000008)    /* FIFO 0 full */
-#define RF0R_FOVR0   ((u32)0x00000010)    /* FIFO 0 overrun */
-#define RF0R_RFOM0   ((u32)0x00000020)    /* Release FIFO 0 output mailbox */
-
-/* CAN Receive FIFO 1 Register bits */
-#define RF1R_FULL1   ((u32)0x00000008)    /* FIFO 1 full */
-#define RF1R_FOVR1   ((u32)0x00000010)    /* FIFO 1 overrun */
-#define RF1R_RFOM1   ((u32)0x00000020)    /* Release FIFO 1 output mailbox */
-
-/* CAN Error Status Register bits */
-#define ESR_EWGF     ((u32)0x00000001)    /* Error warning flag */
-#define ESR_EPVF     ((u32)0x00000002)    /* Error passive flag */
-#define ESR_BOFF     ((u32)0x00000004)    /* Bus-off flag */
-
-/* CAN Mailbox Transmit Request */
-#define TMIDxR_TXRQ  ((u32)0x00000001) /* Transmit mailbox request */
-
-/* CAN Filter Master Register bits */
-#define FMR_FINIT    ((u32)0x00000001) /* Filter init mode */
-
-
-/* Private macro -------------------------------------------------------------*/
-/* Private variables ---------------------------------------------------------*/
-/* Private function prototypes -----------------------------------------------*/
-static ITStatus CheckITStatus(u32 CAN_Reg, u32 It_Bit);
-
-/* Private functions ---------------------------------------------------------*/
-/*******************************************************************************
-* Function Name  : CAN_DeInit
-* Description    : Deinitializes the CAN peripheral registers to their default
-*                  reset values.
-* Input          : None.
-* Output         : None.
-* Return         : None.
-*******************************************************************************/
-void CAN_DeInit(void)
-{
-  /* Enable CAN reset state */
-  RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN, ENABLE);
-  /* Release CAN from reset state */
-  RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN, DISABLE);
-}
-
-/*******************************************************************************
-* Function Name  : CAN_Init
-* Description    : Initializes the CAN peripheral according to the specified
-*                  parameters in the CAN_InitStruct.
-* Input          : CAN_InitStruct: pointer to a CAN_InitTypeDef structure that
-                   contains the configuration information for the CAN peripheral.
-* Output         : None.
-* Return         : Constant indicates initialization succeed which will be 
-*                  CANINITFAILED or CANINITOK.
-*******************************************************************************/
-u8 CAN_Init(CAN_InitTypeDef* CAN_InitStruct)
-{
-  u8 InitStatus = 0;
-  u16 WaitAck = 0;
-
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct-&gt;CAN_TTCM));
-  assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct-&gt;CAN_ABOM));
-  assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct-&gt;CAN_AWUM));
-  assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct-&gt;CAN_NART));
-  assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct-&gt;CAN_RFLM));
-  assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct-&gt;CAN_TXFP));
-  assert_param(IS_CAN_MODE(CAN_InitStruct-&gt;CAN_Mode));
-  assert_param(IS_CAN_SJW(CAN_InitStruct-&gt;CAN_SJW));
-  assert_param(IS_CAN_BS1(CAN_InitStruct-&gt;CAN_BS1));
-  assert_param(IS_CAN_BS2(CAN_InitStruct-&gt;CAN_BS2));
-  assert_param(IS_CAN_PRESCALER(CAN_InitStruct-&gt;CAN_Prescaler));
-
-  /* Request initialisation */
-  CAN-&gt;MCR = MCR_INRQ;
-
-  /* ...and check acknowledged */
-  if ((CAN-&gt;MSR &amp; MSR_INAK) == 0)
-  {
-    InitStatus = CANINITFAILED;
-  }
-  else
-  {
-    /* Set the time triggered communication mode */
-    if (CAN_InitStruct-&gt;CAN_TTCM == ENABLE)
-    {
-      CAN-&gt;MCR |= MCR_TTCM;
-    }
-    else
-    {
-      CAN-&gt;MCR &amp;= ~MCR_TTCM;
-    }
-
-    /* Set the automatic bus-off management */
-    if (CAN_InitStruct-&gt;CAN_ABOM == ENABLE)
-    {
-      CAN-&gt;MCR |= MCR_ABOM;
-    }
-    else
-    {
-      CAN-&gt;MCR &amp;= ~MCR_ABOM;
-    }
-
-    /* Set the automatic wake-up mode */
-    if (CAN_InitStruct-&gt;CAN_AWUM == ENABLE)
-    {
-      CAN-&gt;MCR |= MCR_AWUM;
-    }
-    else
-    {
-      CAN-&gt;MCR &amp;= ~MCR_AWUM;
-    }
-
-    /* Set the no automatic retransmission */
-    if (CAN_InitStruct-&gt;CAN_NART == ENABLE)
-    {
-      CAN-&gt;MCR |= MCR_NART;
-    }
-    else
-    {
-      CAN-&gt;MCR &amp;= ~MCR_NART;
-    }
-
-    /* Set the receive FIFO locked mode */
-    if (CAN_InitStruct-&gt;CAN_RFLM == ENABLE)
-    {
-      CAN-&gt;MCR |= MCR_RFLM;
-    }
-    else
-    {
-      CAN-&gt;MCR &amp;= ~MCR_RFLM;
-    }
-
-    /* Set the transmit FIFO priority */
-    if (CAN_InitStruct-&gt;CAN_TXFP == ENABLE)
-    {
-      CAN-&gt;MCR |= MCR_TXFP;
-    }
-    else
-    {
-      CAN-&gt;MCR &amp;= ~MCR_TXFP;
-    }
-
-    /* Set the bit timing register */
-    CAN-&gt;BTR = (u32)((u32)CAN_InitStruct-&gt;CAN_Mode &lt;&lt; 30) | ((u32)CAN_InitStruct-&gt;CAN_SJW &lt;&lt; 24) |
-               ((u32)CAN_InitStruct-&gt;CAN_BS1 &lt;&lt; 16) | ((u32)CAN_InitStruct-&gt;CAN_BS2 &lt;&lt; 20) |
-               ((u32)CAN_InitStruct-&gt;CAN_Prescaler - 1);
-
-    InitStatus = CANINITOK;
-
-    /* Request leave initialisation */
-    CAN-&gt;MCR &amp;= ~MCR_INRQ;
-
-    /* Wait the acknowledge */
-    for(WaitAck = 0x400; WaitAck &gt; 0x0; WaitAck--)
-    {
-    }
-    
-    /* ...and check acknowledged */
-    if ((CAN-&gt;MSR &amp; MSR_INAK) == MSR_INAK)
-    {
-      InitStatus = CANINITFAILED;
-    }
-  }
-
-  /* At this step, return the status of initialization */
-  return InitStatus;
-}
-
-/*******************************************************************************
-* Function Name  : CAN_FilterInit
-* Description    : Initializes the CAN peripheral according to the specified
-*                  parameters in the CAN_FilterInitStruct.
-* Input          : CAN_FilterInitStruct: pointer to a CAN_FilterInitTypeDef
-*                  structure that contains the configuration information.
-* Output         : None.
-* Return         : None.
-*******************************************************************************/
-void CAN_FilterInit(CAN_FilterInitTypeDef* CAN_FilterInitStruct)
-{
-  u16 FilterNumber_BitPos = 0;
-
-  /* Check the parameters */
-  assert_param(IS_CAN_FILTER_NUMBER(CAN_FilterInitStruct-&gt;CAN_FilterNumber));
-  assert_param(IS_CAN_FILTER_MODE(CAN_FilterInitStruct-&gt;CAN_FilterMode));
-  assert_param(IS_CAN_FILTER_SCALE(CAN_FilterInitStruct-&gt;CAN_FilterScale));
-  assert_param(IS_CAN_FILTER_FIFO(CAN_FilterInitStruct-&gt;CAN_FilterFIFOAssignment));
-  assert_param(IS_FUNCTIONAL_STATE(CAN_FilterInitStruct-&gt;CAN_FilterActivation));
-
-  FilterNumber_BitPos = 
-  (u16)(((u16)0x0001) &lt;&lt; ((u16)CAN_FilterInitStruct-&gt;CAN_FilterNumber));
-
-  /* Initialisation mode for the filter */
-  CAN-&gt;FMR |= FMR_FINIT;
-
-  /* Filter Deactivation */
-  CAN-&gt;FA1R &amp;= ~(u32)FilterNumber_BitPos;
-
-  /* Filter Scale */
-  if (CAN_FilterInitStruct-&gt;CAN_FilterScale == CAN_FilterScale_16bit)
-  {
-    /* 16-bit scale for the filter */
-    CAN-&gt;FS1R &amp;= ~(u32)FilterNumber_BitPos;
-
-    /* First 16-bit identifier and First 16-bit mask */
-    /* Or First 16-bit identifier and Second 16-bit identifier */
-    CAN-&gt;sFilterRegister[CAN_FilterInitStruct-&gt;CAN_FilterNumber].FR1 = 
-    ((u32)((u32)0x0000FFFF &amp; CAN_FilterInitStruct-&gt;CAN_FilterMaskIdLow) &lt;&lt; 16) |
-        ((u32)0x0000FFFF &amp; CAN_FilterInitStruct-&gt;CAN_FilterIdLow);
-
-    /* Second 16-bit identifier and Second 16-bit mask */
-    /* Or Third 16-bit identifier and Fourth 16-bit identifier */
-    CAN-&gt;sFilterRegister[CAN_FilterInitStruct-&gt;CAN_FilterNumber].FR2 = 
-    ((u32)((u32)0x0000FFFF &amp; CAN_FilterInitStruct-&gt;CAN_FilterMaskIdHigh) &lt;&lt; 16) |
-        ((u32)0x0000FFFF &amp; CAN_FilterInitStruct-&gt;CAN_FilterIdHigh);
-  }
-  if (CAN_FilterInitStruct-&gt;CAN_FilterScale == CAN_FilterScale_32bit)
-  {
-    /* 32-bit scale for the filter */
-    CAN-&gt;FS1R |= FilterNumber_BitPos;
-
-    /* 32-bit identifier or First 32-bit identifier */
-    CAN-&gt;sFilterRegister[CAN_FilterInitStruct-&gt;CAN_FilterNumber].FR1 = 
-    ((u32)((u32)0x0000FFFF &amp; CAN_FilterInitStruct-&gt;CAN_FilterIdHigh) &lt;&lt; 16) |
-        ((u32)0x0000FFFF &amp; CAN_FilterInitStruct-&gt;CAN_FilterIdLow);
-
-    /* 32-bit mask or Second 32-bit identifier */
-    CAN-&gt;sFilterRegister[CAN_FilterInitStruct-&gt;CAN_FilterNumber].FR2 = 
-    ((u32)((u32)0x0000FFFF &amp; CAN_FilterInitStruct-&gt;CAN_FilterMaskIdHigh) &lt;&lt; 16) |
-        ((u32)0x0000FFFF &amp; CAN_FilterInitStruct-&gt;CAN_FilterMaskIdLow);
-
-  }
-
-  /* Filter Mode */
-  if (CAN_FilterInitStruct-&gt;CAN_FilterMode == CAN_FilterMode_IdMask)
-  {
-    /*Id/Mask mode for the filter*/
-    CAN-&gt;FM1R &amp;= ~(u32)FilterNumber_BitPos;
-  }
-  else /* CAN_FilterInitStruct-&gt;CAN_FilterMode == CAN_FilterMode_IdList */
-  {
-    /*Identifier list mode for the filter*/
-    CAN-&gt;FM1R |= (u32)FilterNumber_BitPos;
-  }
-
-  /* Filter FIFO assignment */
-  if (CAN_FilterInitStruct-&gt;CAN_FilterFIFOAssignment == CAN_FilterFIFO0)
-  {
-    /* FIFO 0 assignation for the filter */
-    CAN-&gt;FFA1R &amp;= ~(u32)FilterNumber_BitPos;
-  }
-  if (CAN_FilterInitStruct-&gt;CAN_FilterFIFOAssignment == CAN_FilterFIFO1)
-  {
-    /* FIFO 1 assignation for the filter */
-    CAN-&gt;FFA1R |= (u32)FilterNumber_BitPos;
-  }
-  
-  /* Filter activation */
-  if (CAN_FilterInitStruct-&gt;CAN_FilterActivation == ENABLE)
-  {
-    CAN-&gt;FA1R |= FilterNumber_BitPos;
-  }
-
-  /* Leave the initialisation mode for the filter */
-  CAN-&gt;FMR &amp;= ~FMR_FINIT;
-}
-
-/*******************************************************************************
-* Function Name  : CAN_StructInit
-* Description    : Fills each CAN_InitStruct member with its default value.
-* Input          : CAN_InitStruct: pointer to a CAN_InitTypeDef structure which
-*                  will be initialized.
-* Output         : None.
-* Return         : None.
-*******************************************************************************/
-void CAN_StructInit(CAN_InitTypeDef* CAN_InitStruct)
-{
-  /* Reset CAN init structure parameters values */
-
-  /* Initialize the time triggered communication mode */
-  CAN_InitStruct-&gt;CAN_TTCM = DISABLE;
-
-  /* Initialize the automatic bus-off management */
-  CAN_InitStruct-&gt;CAN_ABOM = DISABLE;
-
-  /* Initialize the automatic wake-up mode */
-  CAN_InitStruct-&gt;CAN_AWUM = DISABLE;
-
-  /* Initialize the no automatic retransmission */
-  CAN_InitStruct-&gt;CAN_NART = DISABLE;
-
-  /* Initialize the receive FIFO locked mode */
-  CAN_InitStruct-&gt;CAN_RFLM = DISABLE;
-
-  /* Initialize the transmit FIFO priority */
-  CAN_InitStruct-&gt;CAN_TXFP = DISABLE;
-
-  /* Initialize the CAN_Mode member */
-  CAN_InitStruct-&gt;CAN_Mode = CAN_Mode_Normal;
-
-  /* Initialize the CAN_SJW member */
-  CAN_InitStruct-&gt;CAN_SJW = CAN_SJW_1tq;
-
-  /* Initialize the CAN_BS1 member */
-  CAN_InitStruct-&gt;CAN_BS1 = CAN_BS1_4tq;
-
-  /* Initialize the CAN_BS2 member */
-  CAN_InitStruct-&gt;CAN_BS2 = CAN_BS2_3tq;
-
-  /* Initialize the CAN_Prescaler member */
-  CAN_InitStruct-&gt;CAN_Prescaler = 1;
-}
-
-/*******************************************************************************
-* Function Name  : CAN_ITConfig
-* Description    : Enables or disables the specified CAN interrupts.
-* Input          : - CAN_IT: specifies the CAN interrupt sources to be enabled or
-*                    disabled.
-*                    This parameter can be: CAN_IT_TME, CAN_IT_FMP0, CAN_IT_FF0,
-*                                           CAN_IT_FOV0, CAN_IT_FMP1, CAN_IT_FF1,
-*                                           CAN_IT_FOV1, CAN_IT_EWG, CAN_IT_EPV,
-*                                           CAN_IT_LEC, CAN_IT_ERR, CAN_IT_WKU or
-*                                           CAN_IT_SLK.
-*                  - NewState: new state of the CAN interrupts.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None.
-* Return         : None.
-*******************************************************************************/
-void CAN_ITConfig(u32 CAN_IT, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_CAN_ITConfig(CAN_IT));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected CAN interrupt */
-    CAN-&gt;IER |= CAN_IT;
-  }
-  else
-  {
-    /* Disable the selected CAN interrupt */
-    CAN-&gt;IER &amp;= ~CAN_IT;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : CAN_Transmit
-* Description    : Initiates the transmission of a message.
-* Input          : TxMessage: pointer to a structure which contains CAN Id, CAN
-*                  DLC and CAN datas.
-* Output         : None.
-* Return         : The number of the mailbox that is used for transmission
-*                  or CAN_NO_MB if there is no empty mailbox.
-*******************************************************************************/
-u8 CAN_Transmit(CanTxMsg* TxMessage)
-{
-  u8 TransmitMailbox = 0;
-
-  /* Check the parameters */
-  assert_param(IS_CAN_STDID(TxMessage-&gt;StdId));
-  assert_param(IS_CAN_EXTID(TxMessage-&gt;StdId));
-  assert_param(IS_CAN_IDTYPE(TxMessage-&gt;IDE));
-  assert_param(IS_CAN_RTR(TxMessage-&gt;RTR));
-  assert_param(IS_CAN_DLC(TxMessage-&gt;DLC));
-
-  /* Select one empty transmit mailbox */
-  if ((CAN-&gt;TSR&amp;TSR_TME0) == TSR_TME0)
-  {
-    TransmitMailbox = 0;
-  }
-  else if ((CAN-&gt;TSR&amp;TSR_TME1) == TSR_TME1)
-  {
-    TransmitMailbox = 1;
-  }
-  else if ((CAN-&gt;TSR&amp;TSR_TME2) == TSR_TME2)
-  {
-    TransmitMailbox = 2;
-  }
-  else
-  {
-    TransmitMailbox = CAN_NO_MB;
-  }
-
-  if (TransmitMailbox != CAN_NO_MB)
-  {
-    /* Set up the Id */
-    CAN-&gt;sTxMailBox[TransmitMailbox].TIR &amp;= TMIDxR_TXRQ;
-    if (TxMessage-&gt;IDE == CAN_ID_STD)
-    {
-      TxMessage-&gt;StdId &amp;= (u32)0x000007FF;
-      TxMessage-&gt;StdId = TxMessage-&gt;StdId &lt;&lt; 21;
-      
-      CAN-&gt;sTxMailBox[TransmitMailbox].TIR |= (TxMessage-&gt;StdId | TxMessage-&gt;IDE |
-                                               TxMessage-&gt;RTR);
-    }
-    else
-    {
-      TxMessage-&gt;ExtId &amp;= (u32)0x1FFFFFFF;
-      TxMessage-&gt;ExtId &lt;&lt;= 3;
-
-      CAN-&gt;sTxMailBox[TransmitMailbox].TIR |= (TxMessage-&gt;ExtId | TxMessage-&gt;IDE | 
-                                               TxMessage-&gt;RTR);
-    }
-    
-    /* Set up the DLC */
-    TxMessage-&gt;DLC &amp;= (u8)0x0000000F;
-    CAN-&gt;sTxMailBox[TransmitMailbox].TDTR &amp;= (u32)0xFFFFFFF0;
-    CAN-&gt;sTxMailBox[TransmitMailbox].TDTR |= TxMessage-&gt;DLC;
-
-    /* Set up the data field */
-    CAN-&gt;sTxMailBox[TransmitMailbox].TDLR = (((u32)TxMessage-&gt;Data[3] &lt;&lt; 24) | 
-                                             ((u32)TxMessage-&gt;Data[2] &lt;&lt; 16) |
-                                             ((u32)TxMessage-&gt;Data[1] &lt;&lt; 8) | 
-                                             ((u32)TxMessage-&gt;Data[0]));
-    CAN-&gt;sTxMailBox[TransmitMailbox].TDHR = (((u32)TxMessage-&gt;Data[7] &lt;&lt; 24) | 
-                                             ((u32)TxMessage-&gt;Data[6] &lt;&lt; 16) |
-                                             ((u32)TxMessage-&gt;Data[5] &lt;&lt; 8) |
-                                             ((u32)TxMessage-&gt;Data[4]));
-
-    /* Request transmission */
-    CAN-&gt;sTxMailBox[TransmitMailbox].TIR |= TMIDxR_TXRQ;
-  }
-
-  return TransmitMailbox;
-}
-
-/*******************************************************************************
-* Function Name  : CAN_TransmitStatus
-* Description    : Checks the transmission of a message.
-* Input          : TransmitMailbox: the number of the mailbox that is used for
-*                  transmission.
-* Output         : None.
-* Return         : CANTXOK if the CAN driver transmits the message, CANTXFAILED
-*                  in an other case.
-*******************************************************************************/
-u8 CAN_TransmitStatus(u8 TransmitMailbox)
-{
-  /* RQCP, TXOK and TME bits */
-  u8 State = 0;
-
-  /* Check the parameters */
-  assert_param(IS_CAN_TRANSMITMAILBOX(TransmitMailbox));
-
-  switch (TransmitMailbox)
-  {
-    case (0): State |= (u8)((CAN-&gt;TSR &amp; TSR_RQCP0) &lt;&lt; 2);
-      State |= (u8)((CAN-&gt;TSR &amp; TSR_TXOK0) &gt;&gt; 0);
-      State |= (u8)((CAN-&gt;TSR &amp; TSR_TME0) &gt;&gt; 26);
-      break;
-    case (1): State |= (u8)((CAN-&gt;TSR &amp; TSR_RQCP1) &gt;&gt; 6);
-      State |= (u8)((CAN-&gt;TSR &amp; TSR_TXOK1) &gt;&gt; 8);
-      State |= (u8)((CAN-&gt;TSR &amp; TSR_TME1) &gt;&gt; 27);
-      break;
-    case (2): State |= (u8)((CAN-&gt;TSR &amp; TSR_RQCP2) &gt;&gt; 14);
-      State |= (u8)((CAN-&gt;TSR &amp; TSR_TXOK2) &gt;&gt; 16);
-      State |= (u8)((CAN-&gt;TSR &amp; TSR_TME2) &gt;&gt; 28);
-      break;
-    default:
-      State = CANTXFAILED;
-      break;
-  }
-
-  switch (State)
-  {
-      /* transmit pending  */
-    case (0x0): State = CANTXPENDING;
-      break;
-      /* transmit failed  */
-    case (0x5): State = CANTXFAILED;
-      break;
-      /* transmit succedeed  */
-    case (0x7): State = CANTXOK;
-      break;
-    default:
-      State = CANTXFAILED;
-      break;
-  }
-
-  return State;
-}
-
-/*******************************************************************************
-* Function Name  : CAN_CancelTransmit
-* Description    : Cancels a transmit request.
-* Input          : Mailbox number.
-* Output         : None.
-* Return         : None.
-*******************************************************************************/
-void CAN_CancelTransmit(u8 Mailbox)
-{
-  /* Check the parameters */
-  assert_param(IS_CAN_TRANSMITMAILBOX(Mailbox));
-
-  /* abort transmission */
-  switch (Mailbox)
-  {
-    case (0): CAN-&gt;TSR |= TSR_ABRQ0;
-      break;
-    case (1): CAN-&gt;TSR |= TSR_ABRQ1;
-      break;
-    case (2): CAN-&gt;TSR |= TSR_ABRQ2;
-      break;
-    default:
-      break;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : CAN_FIFORelease
-* Description    : Releases a FIFO.
-* Input          : FIFONumber: FIFO to release, CAN_FIFO0 or CAN_FIFO1.
-* Output         : None.
-* Return         : None.
-*******************************************************************************/
-void CAN_FIFORelease(u8 FIFONumber)
-{
-  /* Check the parameters */
-  assert_param(IS_CAN_FIFO(FIFONumber));
-
-  /* Release FIFO0 */
-  if (FIFONumber == CAN_FIFO0)
-  {
-    CAN-&gt;RF0R = RF0R_RFOM0;
-  }
-  /* Release FIFO1 */
-  else /* FIFONumber == CAN_FIFO1 */
-  {
-    CAN-&gt;RF1R = RF1R_RFOM1;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : CAN_MessagePending
-* Description    : Returns the number of pending messages.
-* Input          : FIFONumber: Receive FIFO number, CAN_FIFO0 or CAN_FIFO1.
-* Output         : None.
-* Return         : NbMessage which is the number of pending message.
-*******************************************************************************/
-u8 CAN_MessagePending(u8 FIFONumber)
-{
-  u8 MessagePending=0;
-
-  /* Check the parameters */
-  assert_param(IS_CAN_FIFO(FIFONumber));
-
-  if (FIFONumber == CAN_FIFO0)
-  {
-    MessagePending = (u8)(CAN-&gt;RF0R&amp;(u32)0x03);
-  }
-  else if (FIFONumber == CAN_FIFO1)
-  {
-    MessagePending = (u8)(CAN-&gt;RF1R&amp;(u32)0x03);
-  }
-  else
-  {
-    MessagePending = 0;
-  }
-  return MessagePending;
-}
-
-/*******************************************************************************
-* Function Name  : CAN_Receive
-* Description    : Receives a message.
-* Input          : FIFONumber: Receive FIFO number, CAN_FIFO0 or CAN_FIFO1.
-* Output         : RxMessage: pointer to a structure which contains CAN Id,
-*                  CAN DLC, CAN datas and FMI number.
-* Return         : None.
-*******************************************************************************/
-void CAN_Receive(u8 FIFONumber, CanRxMsg* RxMessage)
-{
-  /* Check the parameters */
-  assert_param(IS_CAN_FIFO(FIFONumber));
-
-  /* Get the Id */
-  RxMessage-&gt;IDE = (u8)0x04 &amp; CAN-&gt;sFIFOMailBox[FIFONumber].RIR;
-  if (RxMessage-&gt;IDE == CAN_ID_STD)
-  {
-    RxMessage-&gt;StdId = (u32)0x000007FF &amp; (CAN-&gt;sFIFOMailBox[FIFONumber].RIR &gt;&gt; 21);
-  }
-  else
-  {
-    RxMessage-&gt;ExtId = (u32)0x1FFFFFFF &amp; (CAN-&gt;sFIFOMailBox[FIFONumber].RIR &gt;&gt; 3);
-  }
-  
-  RxMessage-&gt;RTR = (u8)0x02 &amp; CAN-&gt;sFIFOMailBox[FIFONumber].RIR;
-
-  /* Get the DLC */
-  RxMessage-&gt;DLC = (u8)0x0F &amp; CAN-&gt;sFIFOMailBox[FIFONumber].RDTR;
-
-  /* Get the FMI */
-  RxMessage-&gt;FMI = (u8)0xFF &amp; (CAN-&gt;sFIFOMailBox[FIFONumber].RDTR &gt;&gt; 8);
-
-  /* Get the data field */
-  RxMessage-&gt;Data[0] = (u8)0xFF &amp; CAN-&gt;sFIFOMailBox[FIFONumber].RDLR;
-  RxMessage-&gt;Data[1] = (u8)0xFF &amp; (CAN-&gt;sFIFOMailBox[FIFONumber].RDLR &gt;&gt; 8);
-  RxMessage-&gt;Data[2] = (u8)0xFF &amp; (CAN-&gt;sFIFOMailBox[FIFONumber].RDLR &gt;&gt; 16);
-  RxMessage-&gt;Data[3] = (u8)0xFF &amp; (CAN-&gt;sFIFOMailBox[FIFONumber].RDLR &gt;&gt; 24);
-
-  RxMessage-&gt;Data[4] = (u8)0xFF &amp; CAN-&gt;sFIFOMailBox[FIFONumber].RDHR;
-  RxMessage-&gt;Data[5] = (u8)0xFF &amp; (CAN-&gt;sFIFOMailBox[FIFONumber].RDHR &gt;&gt; 8);
-  RxMessage-&gt;Data[6] = (u8)0xFF &amp; (CAN-&gt;sFIFOMailBox[FIFONumber].RDHR &gt;&gt; 16);
-  RxMessage-&gt;Data[7] = (u8)0xFF &amp; (CAN-&gt;sFIFOMailBox[FIFONumber].RDHR &gt;&gt; 24);
-
-  /* Release the FIFO */
-  CAN_FIFORelease(FIFONumber);
-}
-
-/*******************************************************************************
-* Function Name  : CAN_Sleep
-* Description    : Enters the low power mode.
-* Input          : None.
-* Output         : None.
-* Return         : CANSLEEPOK if sleep entered, CANSLEEPFAILED in an other case.
-*******************************************************************************/
-u8 CAN_Sleep(void)
-{
-  u8 SleepStatus = 0;
-
-  /* Sleep mode entering request */
-  CAN-&gt;MCR |= MCR_SLEEP;
-  SleepStatus = CANSLEEPOK;
-
-  /* Sleep mode status */
-  if ((CAN-&gt;MCR&amp;MCR_SLEEP) == 0)
-  {
-    /* Sleep mode not entered */
-    SleepStatus = CANSLEEPFAILED;
-  }
-
-  /* At this step, sleep mode status */
-  return SleepStatus;
-}
-
-/*******************************************************************************
-* Function Name  : CAN_WakeUp
-* Description    : Wakes the CAN up.
-* Input          : None.
-* Output         : None.
-* Return         : CANWAKEUPOK if sleep mode left, CANWAKEUPFAILED in an other
-*                  case.
-*******************************************************************************/
-u8 CAN_WakeUp(void)
-{
-  u8 WakeUpStatus = 0;
-
-  /* Wake up request */
-  CAN-&gt;MCR &amp;= ~MCR_SLEEP;
-  WakeUpStatus = CANWAKEUPFAILED;
-
-  /* Sleep mode status */
-  if ((CAN-&gt;MCR&amp;MCR_SLEEP) == 0)
-  {
-    /* Sleep mode exited */
-    WakeUpStatus = CANWAKEUPOK;
-  }
-
-  /* At this step, sleep mode status */
-  return WakeUpStatus;
-}
-
-/*******************************************************************************
-* Function Name  : CAN_GetFlagStatus
-* Description    : Checks whether the specified CAN flag is set or not.
-* Input          : CAN_FLAG: specifies the flag to check.
-*                  This parameter can be: CAN_FLAG_EWG, CAN_FLAG_EPV or
-*                                         CAN_FLAG_BOF.
-* Output         : None.
-* Return         : The new state of CAN_FLAG (SET or RESET).
-*******************************************************************************/
-FlagStatus CAN_GetFlagStatus(u32 CAN_FLAG)
-{
-  FlagStatus bitstatus = RESET;
-
-  /* Check the parameters */
-  assert_param(IS_CAN_FLAG(CAN_FLAG));
-
-  /* Check the status of the specified CAN flag */
-  if ((CAN-&gt;ESR &amp; CAN_FLAG) != (u32)RESET)
-  {
-    /* CAN_FLAG is set */
-    bitstatus = SET;
-  }
-  else
-  {
-    /* CAN_FLAG is reset */
-    bitstatus = RESET;
-  }
-  /* Return the CAN_FLAG status */
-  return  bitstatus;
-}
-
-/*******************************************************************************
-* Function Name  : CAN_ClearFlag
-* Description    : Clears the CAN's pending flags.
-* Input          : CAN_FLAG: specifies the flag to clear.
-* Output         : None.
-* Return         : None.
-*******************************************************************************/
-void CAN_ClearFlag(u32 CAN_FLAG)
-{
-  /* Check the parameters */
-  assert_param(IS_CAN_FLAG(CAN_FLAG));
-
-  /* Clear the selected CAN flags */
-  CAN-&gt;ESR &amp;= ~CAN_FLAG;
-}
-
-/*******************************************************************************
-* Function Name  : CAN_GetITStatus
-* Description    : Checks whether the specified CAN interrupt has occurred or 
-*                  not.
-* Input          : CAN_IT: specifies the CAN interrupt source to check.
-*                  This parameter can be: CAN_IT_RQCP0, CAN_IT_RQCP1, CAN_IT_RQCP2,
-*                                         CAN_IT_FF0, CAN_IT_FOV0, CAN_IT_FF1,
-*                                         CAN_IT_FOV1, CAN_IT_EWG, CAN_IT_EPV, 
-*                                         CAN_IT_BOF, CAN_IT_WKU or CAN_IT_SLK.
-* Output         : None.
-* Return         : The new state of CAN_IT (SET or RESET).
-*******************************************************************************/
-ITStatus CAN_GetITStatus(u32 CAN_IT)
-{
-  ITStatus pendingbitstatus = RESET;
-
-  /* Check the parameters */
-  assert_param(IS_CAN_ITStatus(CAN_IT));
-
-  switch (CAN_IT)
-  {
-    case CAN_IT_RQCP0:
-      pendingbitstatus = CheckITStatus(CAN-&gt;TSR, TSR_RQCP0);
-      break;
-    case CAN_IT_RQCP1:
-      pendingbitstatus = CheckITStatus(CAN-&gt;TSR, TSR_RQCP1);
-      break;
-    case CAN_IT_RQCP2:
-      pendingbitstatus = CheckITStatus(CAN-&gt;TSR, TSR_RQCP2);
-      break;
-    case CAN_IT_FF0:
-      pendingbitstatus = CheckITStatus(CAN-&gt;RF0R, RF0R_FULL0);
-      break;
-    case CAN_IT_FOV0:
-      pendingbitstatus = CheckITStatus(CAN-&gt;RF0R, RF0R_FOVR0);
-      break;
-    case CAN_IT_FF1:
-      pendingbitstatus = CheckITStatus(CAN-&gt;RF1R, RF1R_FULL1);
-      break;
-    case CAN_IT_FOV1:
-      pendingbitstatus = CheckITStatus(CAN-&gt;RF1R, RF1R_FOVR1);
-      break;
-    case CAN_IT_EWG:
-      pendingbitstatus = CheckITStatus(CAN-&gt;ESR, ESR_EWGF);
-      break;
-    case CAN_IT_EPV:
-      pendingbitstatus = CheckITStatus(CAN-&gt;ESR, ESR_EPVF);
-      break;
-    case CAN_IT_BOF:
-      pendingbitstatus = CheckITStatus(CAN-&gt;ESR, ESR_BOFF);
-      break;
-    case CAN_IT_SLK:
-      pendingbitstatus = CheckITStatus(CAN-&gt;MSR, MSR_SLAKI);
-      break;
-    case CAN_IT_WKU:
-      pendingbitstatus = CheckITStatus(CAN-&gt;MSR, MSR_WKUI);
-      break;
-
-    default :
-      pendingbitstatus = RESET;
-      break;
-  }
-
-  /* Return the CAN_IT status */
-  return  pendingbitstatus;
-}
-
-/*******************************************************************************
-* Function Name  : CAN_ClearITPendingBit
-* Description    : Clears the CAN's interrupt pending bits.
-* Input          : CAN_IT: specifies the interrupt pending bit to clear.
-* Output         : None.
-* Return         : None.
-*******************************************************************************/
-void CAN_ClearITPendingBit(u32 CAN_IT)
-{
-  /* Check the parameters */
-  assert_param(IS_CAN_ITStatus(CAN_IT));
-
-  switch (CAN_IT)
-  {
-    case CAN_IT_RQCP0:
-      CAN-&gt;TSR = TSR_RQCP0; /* rc_w1*/
-      break;
-    case CAN_IT_RQCP1:
-      CAN-&gt;TSR = TSR_RQCP1; /* rc_w1*/
-      break;
-    case CAN_IT_RQCP2:
-      CAN-&gt;TSR = TSR_RQCP2; /* rc_w1*/
-      break;
-    case CAN_IT_FF0:
-      CAN-&gt;RF0R = RF0R_FULL0; /* rc_w1*/
-      break;
-    case CAN_IT_FOV0:
-      CAN-&gt;RF0R = RF0R_FOVR0; /* rc_w1*/
-      break;
-    case CAN_IT_FF1:
-      CAN-&gt;RF1R = RF1R_FULL1; /* rc_w1*/
-      break;
-    case CAN_IT_FOV1:
-      CAN-&gt;RF1R = RF1R_FOVR1; /* rc_w1*/
-      break;
-    case CAN_IT_EWG:
-      CAN-&gt;ESR &amp;= ~ ESR_EWGF; /* rw */
-      break;
-    case CAN_IT_EPV:
-      CAN-&gt;ESR &amp;= ~ ESR_EPVF; /* rw */
-      break;
-    case CAN_IT_BOF:
-      CAN-&gt;ESR &amp;= ~ ESR_BOFF; /* rw */
-      break;
-    case CAN_IT_WKU:
-      CAN-&gt;MSR = MSR_WKUI;  /* rc_w1*/
-      break;
-    case CAN_IT_SLK:
-      CAN-&gt;MSR = MSR_SLAKI;  /* rc_w1*/
-      break;
-    default :
-      break;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : CheckITStatus
-* Description    : Checks whether the CAN interrupt has occurred or not.
-* Input          : CAN_Reg: specifies the CAN interrupt register to check.
-*                  It_Bit: specifies the interrupt source bit to check.
-* Output         : None.
-* Return         : The new state of the CAN Interrupt (SET or RESET).
-*******************************************************************************/
-static ITStatus CheckITStatus(u32 CAN_Reg, u32 It_Bit)
-{
-  ITStatus pendingbitstatus = RESET;
-
-  if ((CAN_Reg &amp; It_Bit) != (u32)RESET)
-  {
-    /* CAN_IT is set */
-    pendingbitstatus = SET;
-  }
-  else
-  {
-    /* CAN_IT is reset */
-    pendingbitstatus = RESET;
-  }
-
-  return pendingbitstatus;
-}
-
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
+/**
+  ******************************************************************************
+  * @file    stm32f10x_can.c
+  * @author  MCD Application Team
+  * @version V3.1.0
+  * @date    06/19/2009
+  * @brief   This file provides all the CAN firmware functions.
+  ******************************************************************************
+  * @copy
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * &lt;h2&gt;&lt;center&gt;&copy; COPYRIGHT 2009 STMicroelectronics&lt;/center&gt;&lt;/h2&gt;
+  */ 
+
+/* Includes ------------------------------------------------------------------*/
+#include &quot;stm32f10x_can.h&quot;
+#include &quot;stm32f10x_rcc.h&quot;
+
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup CAN 
+  * @brief CAN driver modules
+  * @{
+  */ 
+
+/** @defgroup CAN_Private_TypesDefinitions
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup CAN_Private_Defines
+  * @{
+  */
+
+/* CAN Master Control Register bits */
+#define MCR_INRQ     ((uint32_t)0x00000001) /* Initialization request */
+#define MCR_SLEEP    ((uint32_t)0x00000002) /* Sleep mode request */
+#define MCR_TXFP     ((uint32_t)0x00000004) /* Transmit FIFO priority */
+#define MCR_RFLM     ((uint32_t)0x00000008) /* Receive FIFO locked mode */
+#define MCR_NART     ((uint32_t)0x00000010) /* No automatic retransmission */
+#define MCR_AWUM     ((uint32_t)0x00000020) /* Automatic wake up mode */
+#define MCR_ABOM     ((uint32_t)0x00000040) /* Automatic bus-off management */
+#define MCR_TTCM     ((uint32_t)0x00000080) /* time triggered communication */
+#define MCR_RESET    ((uint32_t)0x00008000) /* time triggered communication */
+#define MCR_DBF      ((uint32_t)0x00010000) /* software master reset */
+
+/* CAN Master Status Register bits */
+#define MSR_INAK     ((uint32_t)0x00000001)    /* Initialization acknowledge */
+#define MSR_WKUI     ((uint32_t)0x00000008)    /* Wake-up interrupt */
+#define MSR_SLAKI    ((uint32_t)0x00000010)    /* Sleep acknowledge interrupt */
+
+/* CAN Transmit Status Register bits */
+#define TSR_RQCP0    ((uint32_t)0x00000001)    /* Request completed mailbox0 */
+#define TSR_TXOK0    ((uint32_t)0x00000002)    /* Transmission OK of mailbox0 */
+#define TSR_ABRQ0    ((uint32_t)0x00000080)    /* Abort request for mailbox0 */
+#define TSR_RQCP1    ((uint32_t)0x00000100)    /* Request completed mailbox1 */
+#define TSR_TXOK1    ((uint32_t)0x00000200)    /* Transmission OK of mailbox1 */
+#define TSR_ABRQ1    ((uint32_t)0x00008000)    /* Abort request for mailbox1 */
+#define TSR_RQCP2    ((uint32_t)0x00010000)    /* Request completed mailbox2 */
+#define TSR_TXOK2    ((uint32_t)0x00020000)    /* Transmission OK of mailbox2 */
+#define TSR_ABRQ2    ((uint32_t)0x00800000)    /* Abort request for mailbox2 */
+#define TSR_TME0     ((uint32_t)0x04000000)    /* Transmit mailbox 0 empty */
+#define TSR_TME1     ((uint32_t)0x08000000)    /* Transmit mailbox 1 empty */
+#define TSR_TME2     ((uint32_t)0x10000000)    /* Transmit mailbox 2 empty */
+
+/* CAN Receive FIFO 0 Register bits */
+#define RF0R_FULL0   ((uint32_t)0x00000008)    /* FIFO 0 full */
+#define RF0R_FOVR0   ((uint32_t)0x00000010)    /* FIFO 0 overrun */
+#define RF0R_RFOM0   ((uint32_t)0x00000020)    /* Release FIFO 0 output mailbox */
+
+/* CAN Receive FIFO 1 Register bits */
+#define RF1R_FULL1   ((uint32_t)0x00000008)    /* FIFO 1 full */
+#define RF1R_FOVR1   ((uint32_t)0x00000010)    /* FIFO 1 overrun */
+#define RF1R_RFOM1   ((uint32_t)0x00000020)    /* Release FIFO 1 output mailbox */
+
+/* CAN Error Status Register bits */
+#define ESR_EWGF     ((uint32_t)0x00000001)    /* Error warning flag */
+#define ESR_EPVF     ((uint32_t)0x00000002)    /* Error passive flag */
+#define ESR_BOFF     ((uint32_t)0x00000004)    /* Bus-off flag */
+
+/* CAN Mailbox Transmit Request */
+#define TMIDxR_TXRQ  ((uint32_t)0x00000001) /* Transmit mailbox request */
+
+/* CAN Filter Master Register bits */
+#define FMR_FINIT    ((uint32_t)0x00000001) /* Filter init mode */
+
+/* Time out for INAK bit */
+#define INAK_TimeOut        ((uint32_t)0x0000FFFF)
+
+/* Time out for SLAK bit */
+#define SLAK_TimeOut        ((uint32_t)0x0000FFFF)
+
+/**
+  * @}
+  */
+
+/** @defgroup CAN_Private_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup CAN_Private_Variables
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup CAN_Private_FunctionPrototypes
+  * @{
+  */
+
+static ITStatus CheckITStatus(uint32_t CAN_Reg, uint32_t It_Bit);
+
+/**
+  * @}
+  */
+
+/** @defgroup CAN_Private_Functions
+  * @{
+  */
+
+/**
+  * @brief  Deinitializes the CAN peripheral registers to their default reset values.
+  * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
+  * @retval None.
+  */
+void CAN_DeInit(CAN_TypeDef* CANx)
+{
+  /* Check the parameters */
+  assert_param(IS_CAN_ALL_PERIPH(CANx));
+ 
+  if (CANx == CAN1)
+  {
+    /* Enable CAN1 reset state */
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN1, ENABLE);
+    /* Release CAN1 from reset state */
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN1, DISABLE);
+  }
+  else
+  {  
+    /* Enable CAN2 reset state */
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN2, ENABLE);
+    /* Release CAN2 from reset state */
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN2, DISABLE);
+  }
+}
+
+/**
+  * @brief  Initializes the CAN peripheral according to the specified
+  *   parameters in the CAN_InitStruct.
+  * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
+  * @param  CAN_InitStruct: pointer to a CAN_InitTypeDef structure that
+  *   contains the configuration information for the CAN peripheral.
+  * @retval Constant indicates initialization succeed which will be 
+  *   CANINITFAILED or CANINITOK.
+  */
+uint8_t CAN_Init(CAN_TypeDef* CANx, CAN_InitTypeDef* CAN_InitStruct)
+{
+  uint8_t InitStatus = CANINITFAILED;
+  uint32_t wait_ack = 0x00000000;
+  /* Check the parameters */
+  assert_param(IS_CAN_ALL_PERIPH(CANx));
+  assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct-&gt;CAN_TTCM));
+  assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct-&gt;CAN_ABOM));
+  assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct-&gt;CAN_AWUM));
+  assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct-&gt;CAN_NART));
+  assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct-&gt;CAN_RFLM));
+  assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct-&gt;CAN_TXFP));
+  assert_param(IS_CAN_MODE(CAN_InitStruct-&gt;CAN_Mode));
+  assert_param(IS_CAN_SJW(CAN_InitStruct-&gt;CAN_SJW));
+  assert_param(IS_CAN_BS1(CAN_InitStruct-&gt;CAN_BS1));
+  assert_param(IS_CAN_BS2(CAN_InitStruct-&gt;CAN_BS2));
+  assert_param(IS_CAN_PRESCALER(CAN_InitStruct-&gt;CAN_Prescaler));
+
+  /* exit from sleep mode */
+  CANx-&gt;MCR &amp;= ~MCR_SLEEP;
+
+  /* Request initialisation */
+  CANx-&gt;MCR |= MCR_INRQ ;
+
+  /* Wait the acknowledge */
+  while (((CANx-&gt;MSR &amp; MSR_INAK) != MSR_INAK) &amp;&amp; (wait_ack != INAK_TimeOut))
+  {
+    wait_ack++;
+  }
+
+  /* ...and check acknowledged */
+  if ((CANx-&gt;MSR &amp; MSR_INAK) != MSR_INAK)
+  {
+    InitStatus = CANINITFAILED;
+  }
+  else 
+  {
+    /* Set the time triggered communication mode */
+    if (CAN_InitStruct-&gt;CAN_TTCM == ENABLE)
+    {
+      CANx-&gt;MCR |= MCR_TTCM;
+    }
+    else
+    {
+      CANx-&gt;MCR &amp;= ~MCR_TTCM;
+    }
+
+    /* Set the automatic bus-off management */
+    if (CAN_InitStruct-&gt;CAN_ABOM == ENABLE)
+    {
+      CANx-&gt;MCR |= MCR_ABOM;
+    }
+    else
+    {
+      CANx-&gt;MCR &amp;= ~MCR_ABOM;
+    }
+
+    /* Set the automatic wake-up mode */
+    if (CAN_InitStruct-&gt;CAN_AWUM == ENABLE)
+    {
+      CANx-&gt;MCR |= MCR_AWUM;
+    }
+    else
+    {
+      CANx-&gt;MCR &amp;= ~MCR_AWUM;
+    }
+
+    /* Set the no automatic retransmission */
+    if (CAN_InitStruct-&gt;CAN_NART == ENABLE)
+    {
+      CANx-&gt;MCR |= MCR_NART;
+    }
+    else
+    {
+      CANx-&gt;MCR &amp;= ~MCR_NART;
+    }
+
+    /* Set the receive FIFO locked mode */
+    if (CAN_InitStruct-&gt;CAN_RFLM == ENABLE)
+    {
+      CANx-&gt;MCR |= MCR_RFLM;
+    }
+    else
+    {
+      CANx-&gt;MCR &amp;= ~MCR_RFLM;
+    }
+
+    /* Set the transmit FIFO priority */
+    if (CAN_InitStruct-&gt;CAN_TXFP == ENABLE)
+    {
+      CANx-&gt;MCR |= MCR_TXFP;
+    }
+    else
+    {
+      CANx-&gt;MCR &amp;= ~MCR_TXFP;
+    }
+
+    /* Set the bit timing register */
+    CANx-&gt;BTR = (uint32_t)((uint32_t)CAN_InitStruct-&gt;CAN_Mode &lt;&lt; 30) | ((uint32_t)CAN_InitStruct-&gt;CAN_SJW &lt;&lt; 24) |
+               ((uint32_t)CAN_InitStruct-&gt;CAN_BS1 &lt;&lt; 16) | ((uint32_t)CAN_InitStruct-&gt;CAN_BS2 &lt;&lt; 20) |
+               ((uint32_t)CAN_InitStruct-&gt;CAN_Prescaler - 1);
+
+    /* Request leave initialisation */
+    CANx-&gt;MCR &amp;= ~MCR_INRQ;
+
+   /* Wait the acknowledge */
+   wait_ack = 0x00;
+
+   while (((CANx-&gt;MSR &amp; MSR_INAK) == MSR_INAK) &amp;&amp; (wait_ack != INAK_TimeOut))
+   {
+     wait_ack++;
+   }
+
+    /* ...and check acknowledged */
+    if ((CANx-&gt;MSR &amp; MSR_INAK) == MSR_INAK)
+    {
+      InitStatus = CANINITFAILED;
+    }
+    else
+    {
+      InitStatus = CANINITOK ;
+    }
+  }
+
+  /* At this step, return the status of initialization */
+  return InitStatus;
+}
+
+/**
+  * @brief  Initializes the CAN peripheral according to the specified
+  *   parameters in the CAN_FilterInitStruct.
+  * @param  CAN_FilterInitStruct: pointer to a CAN_FilterInitTypeDef
+  *   structure that contains the configuration information.
+  * @retval None.
+  */
+void CAN_FilterInit(CAN_FilterInitTypeDef* CAN_FilterInitStruct)
+{
+  uint32_t filter_number_bit_pos = 0;
+  /* Check the parameters */
+  assert_param(IS_CAN_FILTER_NUMBER(CAN_FilterInitStruct-&gt;CAN_FilterNumber));
+  assert_param(IS_CAN_FILTER_MODE(CAN_FilterInitStruct-&gt;CAN_FilterMode));
+  assert_param(IS_CAN_FILTER_SCALE(CAN_FilterInitStruct-&gt;CAN_FilterScale));
+  assert_param(IS_CAN_FILTER_FIFO(CAN_FilterInitStruct-&gt;CAN_FilterFIFOAssignment));
+  assert_param(IS_FUNCTIONAL_STATE(CAN_FilterInitStruct-&gt;CAN_FilterActivation));
+
+  filter_number_bit_pos = ((uint32_t)0x00000001) &lt;&lt; CAN_FilterInitStruct-&gt;CAN_FilterNumber;
+
+  /* Initialisation mode for the filter */
+  CAN1-&gt;FMR |= FMR_FINIT;
+
+  /* Filter Deactivation */
+  CAN1-&gt;FA1R &amp;= ~(uint32_t)filter_number_bit_pos;
+
+  /* Filter Scale */
+  if (CAN_FilterInitStruct-&gt;CAN_FilterScale == CAN_FilterScale_16bit)
+  {
+    /* 16-bit scale for the filter */
+    CAN1-&gt;FS1R &amp;= ~(uint32_t)filter_number_bit_pos;
+
+    /* First 16-bit identifier and First 16-bit mask */
+    /* Or First 16-bit identifier and Second 16-bit identifier */
+    CAN1-&gt;sFilterRegister[CAN_FilterInitStruct-&gt;CAN_FilterNumber].FR1 = 
+    ((0x0000FFFF &amp; (uint32_t)CAN_FilterInitStruct-&gt;CAN_FilterMaskIdLow) &lt;&lt; 16) |
+        (0x0000FFFF &amp; (uint32_t)CAN_FilterInitStruct-&gt;CAN_FilterIdLow);
+
+    /* Second 16-bit identifier and Second 16-bit mask */
+    /* Or Third 16-bit identifier and Fourth 16-bit identifier */
+    CAN1-&gt;sFilterRegister[CAN_FilterInitStruct-&gt;CAN_FilterNumber].FR2 = 
+    ((0x0000FFFF &amp; (uint32_t)CAN_FilterInitStruct-&gt;CAN_FilterMaskIdHigh) &lt;&lt; 16) |
+        (0x0000FFFF &amp; (uint32_t)CAN_FilterInitStruct-&gt;CAN_FilterIdHigh);
+  }
+
+  if (CAN_FilterInitStruct-&gt;CAN_FilterScale == CAN_FilterScale_32bit)
+  {
+    /* 32-bit scale for the filter */
+    CAN1-&gt;FS1R |= filter_number_bit_pos;
+    /* 32-bit identifier or First 32-bit identifier */
+    CAN1-&gt;sFilterRegister[CAN_FilterInitStruct-&gt;CAN_FilterNumber].FR1 = 
+    ((0x0000FFFF &amp; (uint32_t)CAN_FilterInitStruct-&gt;CAN_FilterIdHigh) &lt;&lt; 16) |
+        (0x0000FFFF &amp; (uint32_t)CAN_FilterInitStruct-&gt;CAN_FilterIdLow);
+    /* 32-bit mask or Second 32-bit identifier */
+    CAN1-&gt;sFilterRegister[CAN_FilterInitStruct-&gt;CAN_FilterNumber].FR2 = 
+    ((0x0000FFFF &amp; (uint32_t)CAN_FilterInitStruct-&gt;CAN_FilterMaskIdHigh) &lt;&lt; 16) |
+        (0x0000FFFF &amp; (uint32_t)CAN_FilterInitStruct-&gt;CAN_FilterMaskIdLow);
+  }
+
+  /* Filter Mode */
+  if (CAN_FilterInitStruct-&gt;CAN_FilterMode == CAN_FilterMode_IdMask)
+  {
+    /*Id/Mask mode for the filter*/
+    CAN1-&gt;FM1R &amp;= ~(uint32_t)filter_number_bit_pos;
+  }
+  else /* CAN_FilterInitStruct-&gt;CAN_FilterMode == CAN_FilterMode_IdList */
+  {
+    /*Identifier list mode for the filter*/
+    CAN1-&gt;FM1R |= (uint32_t)filter_number_bit_pos;
+  }
+
+  /* Filter FIFO assignment */
+  if (CAN_FilterInitStruct-&gt;CAN_FilterFIFOAssignment == CAN_FilterFIFO0)
+  {
+    /* FIFO 0 assignation for the filter */
+    CAN1-&gt;FFA1R &amp;= ~(uint32_t)filter_number_bit_pos;
+  }
+
+  if (CAN_FilterInitStruct-&gt;CAN_FilterFIFOAssignment == CAN_FilterFIFO1)
+  {
+    /* FIFO 1 assignation for the filter */
+    CAN1-&gt;FFA1R |= (uint32_t)filter_number_bit_pos;
+  }
+  
+  /* Filter activation */
+  if (CAN_FilterInitStruct-&gt;CAN_FilterActivation == ENABLE)
+  {
+    CAN1-&gt;FA1R |= filter_number_bit_pos;
+  }
+
+  /* Leave the initialisation mode for the filter */
+  CAN1-&gt;FMR &amp;= ~FMR_FINIT;
+}
+
+/**
+  * @brief  Fills each CAN_InitStruct member with its default value.
+  * @param  CAN_InitStruct: pointer to a CAN_InitTypeDef structure which
+  *   will be initialized.
+  * @retval None.
+  */
+void CAN_StructInit(CAN_InitTypeDef* CAN_InitStruct)
+{
+  /* Reset CAN init structure parameters values */
+  /* Initialize the time triggered communication mode */
+  CAN_InitStruct-&gt;CAN_TTCM = DISABLE;
+  /* Initialize the automatic bus-off management */
+  CAN_InitStruct-&gt;CAN_ABOM = DISABLE;
+  /* Initialize the automatic wake-up mode */
+  CAN_InitStruct-&gt;CAN_AWUM = DISABLE;
+  /* Initialize the no automatic retransmission */
+  CAN_InitStruct-&gt;CAN_NART = DISABLE;
+  /* Initialize the receive FIFO locked mode */
+  CAN_InitStruct-&gt;CAN_RFLM = DISABLE;
+  /* Initialize the transmit FIFO priority */
+  CAN_InitStruct-&gt;CAN_TXFP = DISABLE;
+  /* Initialize the CAN_Mode member */
+  CAN_InitStruct-&gt;CAN_Mode = CAN_Mode_Normal;
+  /* Initialize the CAN_SJW member */
+  CAN_InitStruct-&gt;CAN_SJW = CAN_SJW_1tq;
+  /* Initialize the CAN_BS1 member */
+  CAN_InitStruct-&gt;CAN_BS1 = CAN_BS1_4tq;
+  /* Initialize the CAN_BS2 member */
+  CAN_InitStruct-&gt;CAN_BS2 = CAN_BS2_3tq;
+  /* Initialize the CAN_Prescaler member */
+  CAN_InitStruct-&gt;CAN_Prescaler = 1;
+}
+
+/**
+  * @brief  Select the start bank filter for slave CAN.
+  * @note   This function applies only to STM32 Connectivity line devices.
+  * @param  CAN_BankNumber: Select the start slave bank filter from 1..27.
+  * @retval None.
+  */
+void CAN_SlaveStartBank(uint8_t CAN_BankNumber) 
+{
+  /* Check the parameters */
+  assert_param(IS_CAN_BANKNUMBER(CAN_BankNumber));
+  /* enter Initialisation mode for the filter */
+  CAN1-&gt;FMR |= FMR_FINIT;
+  /* Select the start slave bank */
+  CAN1-&gt;FMR &amp;= (uint32_t)0xFFFFC0F1 ;
+  CAN1-&gt;FMR |= (uint32_t)(CAN_BankNumber)&lt;&lt;8;
+  /* Leave Initialisation mode for the filter */
+  CAN1-&gt;FMR &amp;= ~FMR_FINIT;
+}
+
+/**
+  * @brief  Enables or disables the specified CAN interrupts.
+  * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
+  * @param  CAN_IT: specifies the CAN interrupt sources to be enabled or disabled.
+  *   This parameter can be: CAN_IT_TME, CAN_IT_FMP0, CAN_IT_FF0,
+  *   CAN_IT_FOV0, CAN_IT_FMP1, CAN_IT_FF1,
+  *   CAN_IT_FOV1, CAN_IT_EWG, CAN_IT_EPV,
+  *   CAN_IT_LEC, CAN_IT_ERR, CAN_IT_WKU or
+  *   CAN_IT_SLK.
+  * @param  NewState: new state of the CAN interrupts.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None.
+  */
+void CAN_ITConfig(CAN_TypeDef* CANx, uint32_t CAN_IT, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_CAN_ALL_PERIPH(CANx));
+  assert_param(IS_CAN_ITConfig(CAN_IT));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected CAN interrupt */
+    CANx-&gt;IER |= CAN_IT;
+  }
+  else
+  {
+    /* Disable the selected CAN interrupt */
+    CANx-&gt;IER &amp;= ~CAN_IT;
+  }
+}
+
+/**
+  * @brief  Initiates the transmission of a message.
+  * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
+  * @param  TxMessage: pointer to a structure which contains CAN Id, CAN
+  *   DLC and CAN datas.
+  * @retval The number of the mailbox that is used for transmission
+  *   or CAN_NO_MB if there is no empty mailbox.
+  */
+uint8_t CAN_Transmit(CAN_TypeDef* CANx, CanTxMsg* TxMessage)
+{
+  uint8_t transmit_mailbox = 0;
+  /* Check the parameters */
+  assert_param(IS_CAN_ALL_PERIPH(CANx));
+  assert_param(IS_CAN_IDTYPE(TxMessage-&gt;IDE));
+  assert_param(IS_CAN_RTR(TxMessage-&gt;RTR));
+  assert_param(IS_CAN_DLC(TxMessage-&gt;DLC));
+
+  /* Select one empty transmit mailbox */
+  if ((CANx-&gt;TSR&amp;TSR_TME0) == TSR_TME0)
+  {
+    transmit_mailbox = 0;
+  }
+  else if ((CANx-&gt;TSR&amp;TSR_TME1) == TSR_TME1)
+  {
+    transmit_mailbox = 1;
+  }
+  else if ((CANx-&gt;TSR&amp;TSR_TME2) == TSR_TME2)
+  {
+    transmit_mailbox = 2;
+  }
+  else
+  {
+    transmit_mailbox = CAN_NO_MB;
+  }
+
+  if (transmit_mailbox != CAN_NO_MB)
+  {
+    /* Set up the Id */
+    CANx-&gt;sTxMailBox[transmit_mailbox].TIR &amp;= TMIDxR_TXRQ;
+    if (TxMessage-&gt;IDE == CAN_ID_STD)
+    {
+      assert_param(IS_CAN_STDID(TxMessage-&gt;StdId));  
+      CANx-&gt;sTxMailBox[transmit_mailbox].TIR |= ((TxMessage-&gt;StdId &lt;&lt; 21) | TxMessage-&gt;RTR);
+    }
+    else
+    {
+      assert_param(IS_CAN_EXTID(TxMessage-&gt;ExtId));
+      CANx-&gt;sTxMailBox[transmit_mailbox].TIR |= ((TxMessage-&gt;ExtId&lt;&lt;3) | TxMessage-&gt;IDE | 
+                                               TxMessage-&gt;RTR);
+    }
+    
+
+    /* Set up the DLC */
+    TxMessage-&gt;DLC &amp;= (uint8_t)0x0000000F;
+    CANx-&gt;sTxMailBox[transmit_mailbox].TDTR &amp;= (uint32_t)0xFFFFFFF0;
+    CANx-&gt;sTxMailBox[transmit_mailbox].TDTR |= TxMessage-&gt;DLC;
+
+    /* Set up the data field */
+    CANx-&gt;sTxMailBox[transmit_mailbox].TDLR = (((uint32_t)TxMessage-&gt;Data[3] &lt;&lt; 24) | 
+                                             ((uint32_t)TxMessage-&gt;Data[2] &lt;&lt; 16) |
+                                             ((uint32_t)TxMessage-&gt;Data[1] &lt;&lt; 8) | 
+                                             ((uint32_t)TxMessage-&gt;Data[0]));
+    CANx-&gt;sTxMailBox[transmit_mailbox].TDHR = (((uint32_t)TxMessage-&gt;Data[7] &lt;&lt; 24) | 
+                                             ((uint32_t)TxMessage-&gt;Data[6] &lt;&lt; 16) |
+                                             ((uint32_t)TxMessage-&gt;Data[5] &lt;&lt; 8) |
+                                             ((uint32_t)TxMessage-&gt;Data[4]));
+    /* Request transmission */
+    CANx-&gt;sTxMailBox[transmit_mailbox].TIR |= TMIDxR_TXRQ;
+  }
+  return transmit_mailbox;
+}
+
+/**
+  * @brief  Checks the transmission of a message.
+  * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
+  * @param  TransmitMailbox: the number of the mailbox that is used for transmission.
+  * @retval CANTXOK if the CAN driver transmits the message, CANTXFAILED in an other case.
+  */
+uint8_t CAN_TransmitStatus(CAN_TypeDef* CANx, uint8_t TransmitMailbox)
+{
+  /* RQCP, TXOK and TME bits */
+  uint8_t state = 0;
+  /* Check the parameters */
+  assert_param(IS_CAN_ALL_PERIPH(CANx));
+  assert_param(IS_CAN_TRANSMITMAILBOX(TransmitMailbox));
+  switch (TransmitMailbox)
+  {
+    case (0): state |= (uint8_t)((CANx-&gt;TSR &amp; TSR_RQCP0) &lt;&lt; 2);
+      state |= (uint8_t)((CANx-&gt;TSR &amp; TSR_TXOK0) &gt;&gt; 0);
+      state |= (uint8_t)((CANx-&gt;TSR &amp; TSR_TME0) &gt;&gt; 26);
+      break;
+    case (1): state |= (uint8_t)((CANx-&gt;TSR &amp; TSR_RQCP1) &gt;&gt; 6);
+      state |= (uint8_t)((CANx-&gt;TSR &amp; TSR_TXOK1) &gt;&gt; 8);
+      state |= (uint8_t)((CANx-&gt;TSR &amp; TSR_TME1) &gt;&gt; 27);
+      break;
+    case (2): state |= (uint8_t)((CANx-&gt;TSR &amp; TSR_RQCP2) &gt;&gt; 14);
+      state |= (uint8_t)((CANx-&gt;TSR &amp; TSR_TXOK2) &gt;&gt; 16);
+      state |= (uint8_t)((CANx-&gt;TSR &amp; TSR_TME2) &gt;&gt; 28);
+      break;
+    default:
+      state = CANTXFAILED;
+      break;
+  }
+  switch (state)
+  {
+      /* transmit pending  */
+    case (0x0): state = CANTXPENDING;
+      break;
+      /* transmit failed  */
+    case (0x5): state = CANTXFAILED;
+      break;
+      /* transmit succedeed  */
+    case (0x7): state = CANTXOK;
+      break;
+    default:
+      state = CANTXFAILED;
+      break;
+  }
+  return state;
+}
+
+/**
+  * @brief  Cancels a transmit request.
+  * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral. 
+  * @param  Mailbox: Mailbox number.
+  * @retval None.
+  */
+void CAN_CancelTransmit(CAN_TypeDef* CANx, uint8_t Mailbox)
+{
+  /* Check the parameters */
+  assert_param(IS_CAN_ALL_PERIPH(CANx));
+  assert_param(IS_CAN_TRANSMITMAILBOX(Mailbox));
+  /* abort transmission */
+  switch (Mailbox)
+  {
+    case (0): CANx-&gt;TSR |= TSR_ABRQ0;
+      break;
+    case (1): CANx-&gt;TSR |= TSR_ABRQ1;
+      break;
+    case (2): CANx-&gt;TSR |= TSR_ABRQ2;
+      break;
+    default:
+      break;
+  }
+}
+
+/**
+  * @brief  Releases a FIFO.
+  * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral. 
+  * @param  FIFONumber: FIFO to release, CAN_FIFO0 or CAN_FIFO1.
+  * @retval None.
+  */
+void CAN_FIFORelease(CAN_TypeDef* CANx, uint8_t FIFONumber)
+{
+  /* Check the parameters */
+  assert_param(IS_CAN_ALL_PERIPH(CANx));
+  assert_param(IS_CAN_FIFO(FIFONumber));
+  /* Release FIFO0 */
+  if (FIFONumber == CAN_FIFO0)
+  {
+    CANx-&gt;RF0R = RF0R_RFOM0;
+  }
+  /* Release FIFO1 */
+  else /* FIFONumber == CAN_FIFO1 */
+  {
+    CANx-&gt;RF1R = RF1R_RFOM1;
+  }
+}
+
+/**
+  * @brief  Returns the number of pending messages.
+  * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
+  * @param  FIFONumber: Receive FIFO number, CAN_FIFO0 or CAN_FIFO1.
+  * @retval NbMessage which is the number of pending message.
+  */
+uint8_t CAN_MessagePending(CAN_TypeDef* CANx, uint8_t FIFONumber)
+{
+  uint8_t message_pending=0;
+  /* Check the parameters */
+  assert_param(IS_CAN_ALL_PERIPH(CANx));
+  assert_param(IS_CAN_FIFO(FIFONumber));
+  if (FIFONumber == CAN_FIFO0)
+  {
+    message_pending = (uint8_t)(CANx-&gt;RF0R&amp;(uint32_t)0x03);
+  }
+  else if (FIFONumber == CAN_FIFO1)
+  {
+    message_pending = (uint8_t)(CANx-&gt;RF1R&amp;(uint32_t)0x03);
+  }
+  else
+  {
+    message_pending = 0;
+  }
+  return message_pending;
+}
+
+/**
+  * @brief  Receives a message.
+  * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
+  * @param  FIFONumber: Receive FIFO number, CAN_FIFO0 or CAN_FIFO1.
+  * @param  RxMessage: pointer to a structure receive message which 
+  *   contains CAN Id, CAN DLC, CAN datas and FMI number.
+  * @retval None.
+  */
+void CAN_Receive(CAN_TypeDef* CANx, uint8_t FIFONumber, CanRxMsg* RxMessage)
+{
+  /* Check the parameters */
+  assert_param(IS_CAN_ALL_PERIPH(CANx));
+  assert_param(IS_CAN_FIFO(FIFONumber));
+  /* Get the Id */
+  RxMessage-&gt;IDE = (uint8_t)0x04 &amp; CANx-&gt;sFIFOMailBox[FIFONumber].RIR;
+  if (RxMessage-&gt;IDE == CAN_ID_STD)
+  {
+    RxMessage-&gt;StdId = (uint32_t)0x000007FF &amp; (CANx-&gt;sFIFOMailBox[FIFONumber].RIR &gt;&gt; 21);
+  }
+  else
+  {
+    RxMessage-&gt;ExtId = (uint32_t)0x1FFFFFFF &amp; (CANx-&gt;sFIFOMailBox[FIFONumber].RIR &gt;&gt; 3);
+  }
+  
+  RxMessage-&gt;RTR = (uint8_t)0x02 &amp; CANx-&gt;sFIFOMailBox[FIFONumber].RIR;
+  /* Get the DLC */
+  RxMessage-&gt;DLC = (uint8_t)0x0F &amp; CANx-&gt;sFIFOMailBox[FIFONumber].RDTR;
+  /* Get the FMI */
+  RxMessage-&gt;FMI = (uint8_t)0xFF &amp; (CANx-&gt;sFIFOMailBox[FIFONumber].RDTR &gt;&gt; 8);
+  /* Get the data field */
+  RxMessage-&gt;Data[0] = (uint8_t)0xFF &amp; CANx-&gt;sFIFOMailBox[FIFONumber].RDLR;
+  RxMessage-&gt;Data[1] = (uint8_t)0xFF &amp; (CANx-&gt;sFIFOMailBox[FIFONumber].RDLR &gt;&gt; 8);
+  RxMessage-&gt;Data[2] = (uint8_t)0xFF &amp; (CANx-&gt;sFIFOMailBox[FIFONumber].RDLR &gt;&gt; 16);
+  RxMessage-&gt;Data[3] = (uint8_t)0xFF &amp; (CANx-&gt;sFIFOMailBox[FIFONumber].RDLR &gt;&gt; 24);
+  RxMessage-&gt;Data[4] = (uint8_t)0xFF &amp; CANx-&gt;sFIFOMailBox[FIFONumber].RDHR;
+  RxMessage-&gt;Data[5] = (uint8_t)0xFF &amp; (CANx-&gt;sFIFOMailBox[FIFONumber].RDHR &gt;&gt; 8);
+  RxMessage-&gt;Data[6] = (uint8_t)0xFF &amp; (CANx-&gt;sFIFOMailBox[FIFONumber].RDHR &gt;&gt; 16);
+  RxMessage-&gt;Data[7] = (uint8_t)0xFF &amp; (CANx-&gt;sFIFOMailBox[FIFONumber].RDHR &gt;&gt; 24);
+  /* Release the FIFO */
+  CAN_FIFORelease(CANx, FIFONumber);
+}
+
+/**
+  * @brief  Enables or disables the DBG Freeze for CAN.
+  * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
+  * @param  NewState: new state of the CAN peripheral.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None.
+  */
+void CAN_DBGFreeze(CAN_TypeDef* CANx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_CAN_ALL_PERIPH(CANx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable Debug Freeze  */
+    CANx-&gt;MCR |= MCR_DBF;
+  }
+  else
+  {
+    /* Disable Debug Freeze */
+    CANx-&gt;MCR &amp;= ~MCR_DBF;
+  }
+}
+
+/**
+  * @brief  Enters the low power mode.
+  * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
+  * @retval CANSLEEPOK if sleep entered, CANSLEEPFAILED in an other case.
+  */
+uint8_t CAN_Sleep(CAN_TypeDef* CANx)
+{
+  uint8_t sleepstatus = CANSLEEPFAILED;
+  
+  /* Check the parameters */
+  assert_param(IS_CAN_ALL_PERIPH(CANx));
+    
+  /* Request Sleep mode */
+   CANx-&gt;MCR = (((CANx-&gt;MCR) &amp; (uint32_t)(~MCR_INRQ)) | MCR_SLEEP);
+   
+  /* Sleep mode status */
+  if ((CANx-&gt;MSR &amp; (CAN_MSR_SLAK|CAN_MSR_INAK)) == CAN_MSR_SLAK)
+  {
+    /* Sleep mode not entered */
+    sleepstatus =  CANSLEEPOK;
+  }
+  /* At this step, sleep mode status */
+   return (uint8_t)sleepstatus;
+}
+
+/**
+  * @brief  Wakes the CAN up.
+  * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
+  * @retval CANWAKEUPOK if sleep mode left, CANWAKEUPFAILED in an other case.
+  */
+uint8_t CAN_WakeUp(CAN_TypeDef* CANx)
+{
+  uint32_t wait_slak = SLAK_TimeOut	;
+  uint8_t wakeupstatus = CANWAKEUPFAILED;
+  
+  /* Check the parameters */
+  assert_param(IS_CAN_ALL_PERIPH(CANx));
+    
+  /* Wake up request */
+  CANx-&gt;MCR &amp;= ~MCR_SLEEP;
+    
+  /* Sleep mode status */
+  while(((CANx-&gt;MSR &amp; CAN_MSR_SLAK) == CAN_MSR_SLAK)&amp;&amp;(wait_slak!=0x00))
+  {
+   wait_slak--;
+  }
+  if((CANx-&gt;MSR &amp; CAN_MSR_SLAK) != CAN_MSR_SLAK)
+  {
+   /* Sleep mode exited */
+    wakeupstatus = CANWAKEUPOK;
+  }
+  /* At this step, sleep mode status */
+  return (uint8_t)wakeupstatus;
+}
+
+/**
+  * @brief  Checks whether the specified CAN flag is set or not.
+  * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
+  * @param  CAN_FLAG: specifies the flag to check.
+  *   This parameter can be: CAN_FLAG_EWG, CAN_FLAG_EPV or CAN_FLAG_BOF.
+  * @retval The new state of CAN_FLAG (SET or RESET).
+  */
+FlagStatus CAN_GetFlagStatus(CAN_TypeDef* CANx, uint32_t CAN_FLAG)
+{
+  FlagStatus bitstatus = RESET;
+  /* Check the parameters */
+  assert_param(IS_CAN_ALL_PERIPH(CANx));
+  assert_param(IS_CAN_FLAG(CAN_FLAG));
+  /* Check the status of the specified CAN flag */
+  if ((CANx-&gt;ESR &amp; CAN_FLAG) != (uint32_t)RESET)
+  {
+    /* CAN_FLAG is set */
+    bitstatus = SET;
+  }
+  else
+  {
+    /* CAN_FLAG is reset */
+    bitstatus = RESET;
+  }
+  /* Return the CAN_FLAG status */
+  return  bitstatus;
+}
+
+/**
+  * @brief  Clears the CAN's pending flags.
+  * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
+  * @param  CAN_FLAG: specifies the flag to clear.
+  * @retval None.
+  */
+void CAN_ClearFlag(CAN_TypeDef* CANx, uint32_t CAN_FLAG)
+{
+  /* Check the parameters */
+  assert_param(IS_CAN_ALL_PERIPH(CANx));
+  assert_param(IS_CAN_FLAG(CAN_FLAG));
+  /* Clear the selected CAN flags */
+  CANx-&gt;ESR &amp;= ~CAN_FLAG;
+}
+
+/**
+  * @brief  Checks whether the specified CAN interrupt has occurred or not.
+  * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
+  * @param  CAN_IT: specifies the CAN interrupt source to check.
+  *   This parameter can be: CAN_IT_RQCP0, CAN_IT_RQCP1, CAN_IT_RQCP2,
+  *   CAN_IT_FF0, CAN_IT_FOV0, CAN_IT_FF1,
+  *   CAN_IT_FOV1, CAN_IT_EWG, CAN_IT_EPV, 
+  *   CAN_IT_BOF, CAN_IT_WKU or CAN_IT_SLK.
+  * @retval The new state of CAN_IT (SET or RESET).
+  */
+ITStatus CAN_GetITStatus(CAN_TypeDef* CANx, uint32_t CAN_IT)
+{
+  ITStatus pendingbitstatus = RESET;
+  /* Check the parameters */
+  assert_param(IS_CAN_ALL_PERIPH(CANx));
+  assert_param(IS_CAN_ITStatus(CAN_IT));
+  switch (CAN_IT)
+  {
+    case CAN_IT_RQCP0:
+      pendingbitstatus = CheckITStatus(CANx-&gt;TSR, TSR_RQCP0);
+      break;
+    case CAN_IT_RQCP1:
+      pendingbitstatus = CheckITStatus(CANx-&gt;TSR, TSR_RQCP1);
+      break;
+    case CAN_IT_RQCP2:
+      pendingbitstatus = CheckITStatus(CANx-&gt;TSR, TSR_RQCP2);
+      break;
+    case CAN_IT_FF0:
+      pendingbitstatus = CheckITStatus(CANx-&gt;RF0R, RF0R_FULL0);
+      break;
+    case CAN_IT_FOV0:
+      pendingbitstatus = CheckITStatus(CANx-&gt;RF0R, RF0R_FOVR0);
+      break;
+    case CAN_IT_FF1:
+      pendingbitstatus = CheckITStatus(CANx-&gt;RF1R, RF1R_FULL1);
+      break;
+    case CAN_IT_FOV1:
+      pendingbitstatus = CheckITStatus(CANx-&gt;RF1R, RF1R_FOVR1);
+      break;
+    case CAN_IT_EWG:
+      pendingbitstatus = CheckITStatus(CANx-&gt;ESR, ESR_EWGF);
+      break;
+    case CAN_IT_EPV:
+      pendingbitstatus = CheckITStatus(CANx-&gt;ESR, ESR_EPVF);
+      break;
+    case CAN_IT_BOF:
+      pendingbitstatus = CheckITStatus(CANx-&gt;ESR, ESR_BOFF);
+      break;
+    case CAN_IT_SLK:
+      pendingbitstatus = CheckITStatus(CANx-&gt;MSR, MSR_SLAKI);
+      break;
+    case CAN_IT_WKU:
+      pendingbitstatus = CheckITStatus(CANx-&gt;MSR, MSR_WKUI);
+      break;
+    default :
+      pendingbitstatus = RESET;
+      break;
+  }
+  /* Return the CAN_IT status */
+  return  pendingbitstatus;
+}
+
+/**
+  * @brief  Clears the CAN&#146;s interrupt pending bits.
+  * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
+  * @param  CAN_IT: specifies the interrupt pending bit to clear.
+  * @retval None.
+  */
+void CAN_ClearITPendingBit(CAN_TypeDef* CANx, uint32_t CAN_IT)
+{
+  /* Check the parameters */
+  assert_param(IS_CAN_ALL_PERIPH(CANx));
+  assert_param(IS_CAN_ITStatus(CAN_IT));
+  switch (CAN_IT)
+  {
+    case CAN_IT_RQCP0:
+      CANx-&gt;TSR = TSR_RQCP0; /* rc_w1*/
+      break;
+    case CAN_IT_RQCP1:
+      CANx-&gt;TSR = TSR_RQCP1; /* rc_w1*/
+      break;
+    case CAN_IT_RQCP2:
+      CANx-&gt;TSR = TSR_RQCP2; /* rc_w1*/
+      break;
+    case CAN_IT_FF0:
+      CANx-&gt;RF0R = RF0R_FULL0; /* rc_w1*/
+      break;
+    case CAN_IT_FOV0:
+      CANx-&gt;RF0R = RF0R_FOVR0; /* rc_w1*/
+      break;
+    case CAN_IT_FF1:
+      CANx-&gt;RF1R = RF1R_FULL1; /* rc_w1*/
+      break;
+    case CAN_IT_FOV1:
+      CANx-&gt;RF1R = RF1R_FOVR1; /* rc_w1*/
+      break;
+    case CAN_IT_EWG:
+      CANx-&gt;ESR &amp;= ~ ESR_EWGF; /* rw */
+      break;
+    case CAN_IT_EPV:
+      CANx-&gt;ESR &amp;= ~ ESR_EPVF; /* rw */
+      break;
+    case CAN_IT_BOF:
+      CANx-&gt;ESR &amp;= ~ ESR_BOFF; /* rw */
+      break;
+    case CAN_IT_WKU:
+      CANx-&gt;MSR = MSR_WKUI;  /* rc_w1*/
+      break;
+    case CAN_IT_SLK:
+      CANx-&gt;MSR = MSR_SLAKI;  /* rc_w1*/
+      break;
+    default :
+      break;
+  }
+}
+
+/**
+  * @brief  Checks whether the CAN interrupt has occurred or not.
+  * @param  CAN_Reg: specifies the CAN interrupt register to check.
+  * @param  It_Bit: specifies the interrupt source bit to check.
+  * @retval The new state of the CAN Interrupt (SET or RESET).
+  */
+static ITStatus CheckITStatus(uint32_t CAN_Reg, uint32_t It_Bit)
+{
+  ITStatus pendingbitstatus = RESET;
+  
+  if ((CAN_Reg &amp; It_Bit) != (uint32_t)RESET)
+  {
+    /* CAN_IT is set */
+    pendingbitstatus = SET;
+  }
+  else
+  {
+    /* CAN_IT is reset */
+    pendingbitstatus = RESET;
+  }
+  return pendingbitstatus;
+}
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2009 STMicroelectronics *****END OF FILE****/

Added: trunk/src/platform/stm32/FWLib/library/src/stm32f10x_can.o
===================================================================
--- trunk/src/platform/stm32/FWLib/library/src/stm32f10x_can.o	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/src/stm32f10x_can.o	2009-07-08 23:39:34 UTC (rev 354)
@@ -0,0 +1,17 @@
+ELF
+&#192;#0&#181;&#250;&#245;6I&#236;C&#209;&#248;
+&#203;t&#210;&#248;&#184;1&#203;r&#210;&#248;&#184;1
+s&#210;&#248;&#184;1Ks&#210;&#248;&#184;1&#139;s&#210;&#248;&#188;1&#203;s&#210;&#248;&#188;1
+t&#210;&#248;&#188;1Kt&#210;&#248;&#188;1&#139;tqF&#255;&#247;&#254;&#255;&#189;
+&#224;&#128;i!&#224;&#128;i!&#224;@h!&#224;@h!&#255;&#247;&#254;&#255;&#189;
+M	

+
+
+
+
+
+&lt;
++
+G
+G
+G
\ No newline at end of file

Modified: trunk/src/platform/stm32/FWLib/library/src/stm32f10x_crc.c
===================================================================
--- trunk/src/platform/stm32/FWLib/library/src/stm32f10x_crc.c	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/src/stm32f10x_crc.c	2009-07-08 23:39:34 UTC (rev 354)
@@ -1,114 +1,163 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_crc.c
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file provides all the CRC firmware functions.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
-
-/* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_crc.h&quot;
-
-/* Private typedef -----------------------------------------------------------*/
-/* Private define ------------------------------------------------------------*/
-
-/* CR register bit mask */
-#define CR_RESET_Set    ((u32)0x00000001)
-
-/* Private macro -------------------------------------------------------------*/
-/* Private variables ---------------------------------------------------------*/
-/* Private function prototypes -----------------------------------------------*/
-/* Private functions ---------------------------------------------------------*/
-
-/*******************************************************************************
-* Function Name  : CRC_ResetDR
-* Description    : Resets the CRC Data register (DR).
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void CRC_ResetDR(void)
-{
-  /* Reset CRC generator */
-  CRC-&gt;CR = CR_RESET_Set;
-}
-
-/*******************************************************************************
-* Function Name  : CRC_CalcCRC
-* Description    : Computes the 32-bit CRC of a given data word(32-bit).
-* Input          : - Data: data word(32-bit) to compute its CRC
-* Output         : None
-* Return         : 32-bit CRC
-*******************************************************************************/
-u32 CRC_CalcCRC(u32 Data)
-{
-  CRC-&gt;DR = Data;
-  
-  return (CRC-&gt;DR);
-}
-
-/*******************************************************************************
-* Function Name  : CRC_CalcBlockCRC
-* Description    : Computes the 32-bit CRC of a given buffer of data word(32-bit).
-* Input          : - pBuffer: pointer to the buffer containing the data to be 
-*                    computed
-*                  - BufferLength: length of the buffer to be computed					
-* Output         : None
-* Return         : 32-bit CRC
-*******************************************************************************/
-u32 CRC_CalcBlockCRC(u32 pBuffer[], u32 BufferLength)
-{
-  u32 index = 0;
-  
-  for(index = 0; index &lt; BufferLength; index++)
-  {
-    CRC-&gt;DR = pBuffer[index];
-  }
-
-  return (CRC-&gt;DR);
-}
-
-/*******************************************************************************
-* Function Name  : CRC_GetCRC
-* Description    : Returns the current CRC value.
-* Input          : None
-* Output         : None
-* Return         : 32-bit CRC
-*******************************************************************************/
-u32 CRC_GetCRC(void)
-{
-  return (CRC-&gt;DR);
-}
-
-/*******************************************************************************
-* Function Name  : CRC_SetIDRegister
-* Description    : Stores a 8-bit data in the Independent Data(ID) register.
-* Input          : - IDValue: 8-bit value to be stored in the ID register 					
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void CRC_SetIDRegister(u8 IDValue)
-{
-  CRC-&gt;IDR = IDValue;
-}
-
-/*******************************************************************************
-* Function Name  : CRC_GetIDRegister
-* Description    : Returns the 8-bit data stored in the Independent Data(ID) register
-* Input          : None
-* Output         : None
-* Return         : 8-bit value of the ID register 
-*******************************************************************************/
-u8 CRC_GetIDRegister(void)
-{
-  return (CRC-&gt;IDR);
-}
-
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
+/**
+  ******************************************************************************
+  * @file    stm32f10x_crc.c
+  * @author  MCD Application Team
+  * @version V3.1.0
+  * @date    06/19/2009
+  * @brief   This file provides all the CRC firmware functions.
+  ******************************************************************************
+  * @copy
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * &lt;h2&gt;&lt;center&gt;&copy; COPYRIGHT 2009 STMicroelectronics&lt;/center&gt;&lt;/h2&gt;
+  */ 
+
+/* Includes ------------------------------------------------------------------*/
+#include &quot;stm32f10x_crc.h&quot;
+
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup CRC 
+  * @brief CRC driver modules
+  * @{
+  */
+
+/** @defgroup CRC_Private_TypesDefinitions
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup CRC_Private_Defines
+  * @{
+  */
+
+/* CR register bit mask */
+
+#define CR_RESET_Set    ((uint32_t)0x00000001)
+
+/**
+  * @}
+  */
+
+/** @defgroup CRC_Private_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup CRC_Private_Variables
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup CRC_Private_FunctionPrototypes
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup CRC_Private_Functions
+  * @{
+  */
+
+/**
+  * @brief  Resets the CRC Data register (DR).
+  * @param  None
+  * @retval None
+  */
+void CRC_ResetDR(void)
+{
+  /* Reset CRC generator */
+  CRC-&gt;CR = CR_RESET_Set;
+}
+
+/**
+  * @brief  Computes the 32-bit CRC of a given data word(32-bit).
+  * @param  Data: data word(32-bit) to compute its CRC
+  * @retval 32-bit CRC
+  */
+uint32_t CRC_CalcCRC(uint32_t Data)
+{
+  CRC-&gt;DR = Data;
+  
+  return (CRC-&gt;DR);
+}
+
+/**
+  * @brief  Computes the 32-bit CRC of a given buffer of data word(32-bit).
+  * @param  pBuffer: pointer to the buffer containing the data to be computed
+  * @param  BufferLength: length of the buffer to be computed					
+  * @retval 32-bit CRC
+  */
+uint32_t CRC_CalcBlockCRC(uint32_t pBuffer[], uint32_t BufferLength)
+{
+  uint32_t index = 0;
+  
+  for(index = 0; index &lt; BufferLength; index++)
+  {
+    CRC-&gt;DR = pBuffer[index];
+  }
+  return (CRC-&gt;DR);
+}
+
+/**
+  * @brief  Returns the current CRC value.
+  * @param  None
+  * @retval 32-bit CRC
+  */
+uint32_t CRC_GetCRC(void)
+{
+  return (CRC-&gt;DR);
+}
+
+/**
+  * @brief  Stores a 8-bit data in the Independent Data(ID) register.
+  * @param  IDValue: 8-bit value to be stored in the ID register 					
+  * @retval None
+  */
+void CRC_SetIDRegister(uint8_t IDValue)
+{
+  CRC-&gt;IDR = IDValue;
+}
+
+/**
+  * @brief  Returns the 8-bit data stored in the Independent Data(ID) register
+  * @param  None
+  * @retval 8-bit value of the ID register 
+  */
+uint8_t CRC_GetIDRegister(void)
+{
+  return (CRC-&gt;IDR);
+}
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2009 STMicroelectronics *****END OF FILE****/

Added: trunk/src/platform/stm32/FWLib/library/src/stm32f10x_crc.o
===================================================================
--- trunk/src/platform/stm32/FWLib/library/src/stm32f10x_crc.o	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/src/stm32f10x_crc.o	2009-07-08 23:39:34 UTC (rev 354)
@@ -0,0 +1,3 @@
+ELF
+M	
+
\ No newline at end of file

Modified: trunk/src/platform/stm32/FWLib/library/src/stm32f10x_dac.c
===================================================================
--- trunk/src/platform/stm32/FWLib/library/src/stm32f10x_dac.c	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/src/stm32f10x_dac.c	2009-07-08 23:39:34 UTC (rev 354)
@@ -1,389 +1,431 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_dac.c
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file provides all the DAC firmware functions.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
-
-/* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_dac.h&quot;
-#include &quot;stm32f10x_rcc.h&quot;
-
-/* Private typedef -----------------------------------------------------------*/
-/* Private define ------------------------------------------------------------*/
-/* DAC EN mask */
-#define CR_EN_Set                  ((u32)0x00000001)
-
-/* DAC DMAEN mask */
-#define CR_DMAEN_Set               ((u32)0x00001000)
-
-/* CR register Mask */
-#define CR_CLEAR_Mask              ((u32)0x00000FFE)
-
-/* DAC SWTRIG mask */
-#define SWTRIGR_SWTRIG_Set         ((u32)0x00000001)
-
-/* DAC Dual Channels SWTRIG masks */
-#define DUAL_SWTRIG_Set            ((u32)0x00000003)
-#define DUAL_SWTRIG_Reset          ((u32)0xFFFFFFFC)
-
-/* DHR registers offsets */
-#define DHR12R1_Offset             ((u32)0x00000008)
-#define DHR12R2_Offset             ((u32)0x00000014)
-#define DHR12RD_Offset             ((u32)0x00000020)
-
-/* DOR register offset */
-#define DOR_Offset                 ((u32)0x0000002C)
-
-/* Private macro -------------------------------------------------------------*/
-/* Private variables ---------------------------------------------------------*/
-/* Private function prototypes -----------------------------------------------*/
-/* Private functions ---------------------------------------------------------*/
-
-/*******************************************************************************
-* Function Name  : DAC_DeInit
-* Description    : Deinitializes the DAC peripheral registers to their default
-*                  reset values.
-* Input          : None.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void DAC_DeInit(void)
-{
-  /* Enable DAC reset state */
-  RCC_APB1PeriphResetCmd(RCC_APB1Periph_DAC, ENABLE);
-  /* Release DAC from reset state */
-  RCC_APB1PeriphResetCmd(RCC_APB1Periph_DAC, DISABLE);
-}
-
-/*******************************************************************************
-* Function Name  : DAC_Init
-* Description    : Initializes the DAC peripheral according to the specified 
-*                  parameters in the DAC_InitStruct.
-* Input          : - DAC_Channel: the selected DAC channel. 
-*                    This parameter can be one of the following values:
-*                       - DAC_Channel_1: DAC Channel1 selected
-*                       - DAC_Channel_2: DAC Channel2 selected
-*                  - DAC_InitStruct: pointer to a DAC_InitTypeDef structure that
-*                    contains the configuration information for the specified
-*                    DAC channel.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void DAC_Init(u32 DAC_Channel, DAC_InitTypeDef* DAC_InitStruct)
-{
-  u32 tmpreg1 = 0, tmpreg2 = 0;
-
-  /* Check the DAC parameters */
-  assert_param(IS_DAC_TRIGGER(DAC_InitStruct-&gt;DAC_Trigger));
-  assert_param(IS_DAC_GENERATE_WAVE(DAC_InitStruct-&gt;DAC_WaveGeneration));
-  assert_param(IS_DAC_LFSR_UNMASK_TRIANGLE_AMPLITUDE(DAC_InitStruct-&gt;DAC_LFSRUnmask_TriangleAmplitude));
-  assert_param(IS_DAC_OUTPUT_BUFFER_STATE(DAC_InitStruct-&gt;DAC_OutputBuffer));
-
-/*---------------------------- DAC CR Configuration --------------------------*/
-  /* Get the DAC CR value */
-  tmpreg1 = DAC-&gt;CR;
-  /* Clear BOFFx, TENx, TSELx, WAVEx and MAMPx bits */
-  tmpreg1 &amp;= ~(CR_CLEAR_Mask &lt;&lt; DAC_Channel);
-  /* Configure for the selected DAC channel: buffer output, trigger, wave genration,
-     mask/amplitude for wave genration */
-  /* Set TSELx and TENx bits according to DAC_Trigger value */
-  /* Set WAVEx bits according to DAC_WaveGeneration value */
-  /* Set MAMPx bits according to DAC_LFSRUnmask_TriangleAmplitude value */ 
-  /* Set BOFFx bit according to DAC_OutputBuffer value */   
-  tmpreg2 = (DAC_InitStruct-&gt;DAC_Trigger | DAC_InitStruct-&gt;DAC_WaveGeneration |
-             DAC_InitStruct-&gt;DAC_LFSRUnmask_TriangleAmplitude | DAC_InitStruct-&gt;DAC_OutputBuffer);
-  /* Calculate CR register value depending on DAC_Channel */
-  tmpreg1 |= tmpreg2 &lt;&lt; DAC_Channel;
-  /* Write to DAC CR */
-  DAC-&gt;CR = tmpreg1;
-}
-
-/*******************************************************************************
-* Function Name  : DAC_StructInit
-* Description    : Fills each DAC_InitStruct member with its default value.
-* Input          : - DAC_InitStruct : pointer to a DAC_InitTypeDef structure
-*                    which will be initialized.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void DAC_StructInit(DAC_InitTypeDef* DAC_InitStruct)
-{
-/*--------------- Reset DAC init structure parameters values -----------------*/
-  /* Initialize the DAC_Trigger member */
-  DAC_InitStruct-&gt;DAC_Trigger = DAC_Trigger_None;
-
-  /* Initialize the DAC_WaveGeneration member */
-  DAC_InitStruct-&gt;DAC_WaveGeneration = DAC_WaveGeneration_None;
-
-  /* Initialize the DAC_LFSRUnmask_TriangleAmplitude member */
-  DAC_InitStruct-&gt;DAC_LFSRUnmask_TriangleAmplitude = DAC_LFSRUnmask_Bit0;
-
-  /* Initialize the DAC_OutputBuffer member */
-  DAC_InitStruct-&gt;DAC_OutputBuffer = DAC_OutputBuffer_Enable;
-}
-
-/*******************************************************************************
-* Function Name  : DAC_Cmd
-* Description    : Enables or disables the specified DAC channel.
-* Input            - DAC_Channel: the selected DAC channel. 
-*                    This parameter can be one of the following values:
-*                       - DAC_Channel_1: DAC Channel1 selected
-*                       - DAC_Channel_2: DAC Channel2 selected
-*                  - NewState: new state of the DAC channel. 
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void DAC_Cmd(u32 DAC_Channel, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_DAC_CHANNEL(DAC_Channel));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected DAC channel */
-    DAC-&gt;CR |= CR_EN_Set &lt;&lt; DAC_Channel;
-  }
-  else
-  {
-    /* Disable the selected DAC channel */
-    DAC-&gt;CR &amp;= ~(CR_EN_Set &lt;&lt; DAC_Channel);
-  }
-}
-
-/*******************************************************************************
-* Function Name  : DAC_DMACmd
-* Description    : Enables or disables the specified DAC channel DMA request.
-* Input            - DAC_Channel: the selected DAC channel. 
-*                    This parameter can be one of the following values:
-*                       - DAC_Channel_1: DAC Channel1 selected
-*                       - DAC_Channel_2: DAC Channel2 selected
-*                  - NewState: new state of the selected DAC channel DMA request.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void DAC_DMACmd(u32 DAC_Channel, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_DAC_CHANNEL(DAC_Channel));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected DAC channel DMA request */
-    DAC-&gt;CR |= CR_DMAEN_Set &lt;&lt; DAC_Channel;
-  }
-  else
-  {
-    /* Disable the selected DAC channel DMA request */
-    DAC-&gt;CR &amp;= ~(CR_DMAEN_Set &lt;&lt; DAC_Channel);
-  }
-}
-
-/*******************************************************************************
-* Function Name  : DAC_SoftwareTriggerCmd
-* Description    : Enables or disables the selected DAC channel software trigger.
-* Input            - DAC_Channel: the selected DAC channel. 
-*                    This parameter can be one of the following values:
-*                       - DAC_Channel_1: DAC Channel1 selected
-*                       - DAC_Channel_2: DAC Channel2 selected
-*                  - NewState: new state of the selected DAC channel software trigger.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void DAC_SoftwareTriggerCmd(u32 DAC_Channel, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_DAC_CHANNEL(DAC_Channel));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Enable software trigger for the selected DAC channel */
-    DAC-&gt;SWTRIGR |= SWTRIGR_SWTRIG_Set &lt;&lt; (DAC_Channel &gt;&gt; 4);
-  }
-  else
-  {
-    /* Disable software trigger for the selected DAC channel */
-    DAC-&gt;SWTRIGR &amp;= ~(SWTRIGR_SWTRIG_Set &lt;&lt; (DAC_Channel &gt;&gt; 4));
-  }
-}
-
-/*******************************************************************************
-* Function Name  : DAC_DualSoftwareTriggerCmd
-* Description    : Enables or disables simultaneously the two DAC channels software
-*                  triggers.
-* Input            - NewState: new state of the DAC channels software triggers.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void DAC_DualSoftwareTriggerCmd(FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Enable software trigger for both DAC channels */
-    DAC-&gt;SWTRIGR |= DUAL_SWTRIG_Set ;
-  }
-  else
-  {
-    /* Disable software trigger for both DAC channels */
-    DAC-&gt;SWTRIGR &amp;= DUAL_SWTRIG_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : DAC_WaveGenerationCmd
-* Description    : Enables or disables the selected DAC channel wave generation.
-* Input            - DAC_Channel: the selected DAC channel. 
-*                    This parameter can be one of the following values:
-*                       - DAC_Channel_1: DAC Channel1 selected
-*                       - DAC_Channel_2: DAC Channel2 selected
-*                  - DAC_Wave: Specifies the wave type to enable or disable.
-*                    This parameter can be one of the following values:
-*                       - DAC_Wave_Noise: noise wave generation
-*                       - DAC_Wave_Triangle: triangle wave generation
-*                  - NewState: new state of the selected DAC channel wave generation.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void DAC_WaveGenerationCmd(u32 DAC_Channel, u32 DAC_Wave, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_DAC_CHANNEL(DAC_Channel));
-  assert_param(IS_DAC_WAVE(DAC_Wave)); 
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected wave generation for the selected DAC channel */
-    DAC-&gt;CR |= DAC_Wave &lt;&lt; DAC_Channel;
-  }
-  else
-  {
-    /* Disable the selected wave generation for the selected DAC channel */
-    DAC-&gt;CR &amp;= ~(DAC_Wave &lt;&lt; DAC_Channel);
-  }
-}
-
-/*******************************************************************************
-* Function Name  : DAC_SetChannel1Data
-* Description    : Set the specified data holding register value for DAC channel1.
-* Input          : - DAC_Align: Specifies the data alignement for DAC channel1.
-*                    This parameter can be one of the following values:
-*                       - DAC_Align_8b_R: 8bit right data alignement selected
-*                       - DAC_Align_12b_L: 12bit left data alignement selected
-*                       - DAC_Align_12b_R: 12bit right data alignement selected
-*                  - Data : Data to be loaded in the selected data holding 
-*                    register.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void DAC_SetChannel1Data(u32 DAC_Align, u16 Data)
-{
-  /* Check the parameters */
-  assert_param(IS_DAC_ALIGN(DAC_Align));
-  assert_param(IS_DAC_DATA(Data));
-
-  /* Set the DAC channel1 selected data holding register */
-  *((vu32 *)(DAC_BASE + DHR12R1_Offset + DAC_Align)) = (u32)Data;
-}
-
-/*******************************************************************************
-* Function Name  : DAC_SetChannel2Data
-* Description    : Set the specified data holding register value for DAC channel2.
-* Input          : - DAC_Align: Specifies the data alignement for DAC channel2.
-*                    This parameter can be one of the following values:
-*                       - DAC_Align_8b_R: 8bit right data alignement selected
-*                       - DAC_Align_12b_L: 12bit left data alignement selected
-*                       - DAC_Align_12b_R: 12bit right data alignement selected
-*                  - Data : Data to be loaded in the selected data holding 
-*                    register.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void DAC_SetChannel2Data(u32 DAC_Align, u16 Data)
-{
-  /* Check the parameters */
-  assert_param(IS_DAC_ALIGN(DAC_Align));
-  assert_param(IS_DAC_DATA(Data));
-
-  /* Set the DAC channel2 selected data holding register */
-  *((vu32 *)(DAC_BASE + DHR12R2_Offset + DAC_Align)) = (u32)Data;
-}
-
-/*******************************************************************************
-* Function Name  : DAC_SetDualChannelData
-* Description    : Set the specified data holding register value for dual channel
-*                  DAC.
-* Input          : - DAC_Align: Specifies the data alignement for dual channel DAC.
-*                    This parameter can be one of the following values:
-*                       - DAC_Align_8b_R: 8bit right data alignement selected
-*                       - DAC_Align_12b_L: 12bit left data alignement selected
-*                       - DAC_Align_12b_R: 12bit right data alignement selected
-*                  - Data2: Data for DAC Channel2 to be loaded in the selected data 
-*                    holding register.
-*                  - Data1: Data for DAC Channel1 to be loaded in the selected data 
-*                    holding register.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void DAC_SetDualChannelData(u32 DAC_Align, u16 Data2, u16 Data1)
-{
-  u32 data = 0;
-
-  /* Check the parameters */
-  assert_param(IS_DAC_ALIGN(DAC_Align));
-  assert_param(IS_DAC_DATA(Data1));
-  assert_param(IS_DAC_DATA(Data2));
-  
-  /* Calculate and set dual DAC data holding register value */
-  if (DAC_Align == DAC_Align_8b_R)
-  {
-    data = ((u32)Data2 &lt;&lt; 8) | Data1; 
-  }
-  else
-  {
-    data = ((u32)Data2 &lt;&lt; 16) | Data1;
-  }
-
-  /* Set the dual DAC selected data holding register */
-  *((vu32 *)(DAC_BASE + DHR12RD_Offset + DAC_Align)) = data;
-}
-
-/*******************************************************************************
-* Function Name  : DAC_GetDataOutputValue
-* Description    : Returns the last data output value of the selected DAC cahnnel.
-* Input            - DAC_Channel: the selected DAC channel. 
-*                    This parameter can be one of the following values:
-*                       - DAC_Channel_1: DAC Channel1 selected
-*                       - DAC_Channel_2: DAC Channel2 selected
-* Output         : None
-* Return         : The selected DAC channel data output value.
-*******************************************************************************/
-u16 DAC_GetDataOutputValue(u32 DAC_Channel)
-{
-  /* Check the parameters */
-  assert_param(IS_DAC_CHANNEL(DAC_Channel));
-
-  /* Returns the DAC channel data output register value */
-  return (u16) (*(vu32*)(DAC_BASE + DOR_Offset + ((u32)DAC_Channel &gt;&gt; 2)));
-}
-
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
+/**
+  ******************************************************************************
+  * @file    stm32f10x_dac.c
+  * @author  MCD Application Team
+  * @version V3.1.0
+  * @date    06/19/2009
+  * @brief   This file provides all the DAC firmware functions.
+  ******************************************************************************
+  * @copy
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * &lt;h2&gt;&lt;center&gt;&copy; COPYRIGHT 2009 STMicroelectronics&lt;/center&gt;&lt;/h2&gt;
+  */ 
+
+/* Includes ------------------------------------------------------------------*/
+#include &quot;stm32f10x_dac.h&quot;
+#include &quot;stm32f10x_rcc.h&quot;
+
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup DAC 
+  * @brief DAC driver modules
+  * @{
+  */ 
+
+/** @defgroup DAC_Private_TypesDefinitions
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup DAC_Private_Defines
+  * @{
+  */
+
+/* DAC EN mask */
+#define CR_EN_Set                  ((uint32_t)0x00000001)
+
+/* DAC DMAEN mask */
+#define CR_DMAEN_Set               ((uint32_t)0x00001000)
+
+/* CR register Mask */
+#define CR_CLEAR_Mask              ((uint32_t)0x00000FFE)
+
+/* DAC SWTRIG mask */
+#define SWTRIGR_SWTRIG_Set         ((uint32_t)0x00000001)
+
+/* DAC Dual Channels SWTRIG masks */
+#define DUAL_SWTRIG_Set            ((uint32_t)0x00000003)
+#define DUAL_SWTRIG_Reset          ((uint32_t)0xFFFFFFFC)
+
+/* DHR registers offsets */
+#define DHR12R1_Offset             ((uint32_t)0x00000008)
+#define DHR12R2_Offset             ((uint32_t)0x00000014)
+#define DHR12RD_Offset             ((uint32_t)0x00000020)
+
+/* DOR register offset */
+#define DOR_Offset                 ((uint32_t)0x0000002C)
+/**
+  * @}
+  */
+
+/** @defgroup DAC_Private_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup DAC_Private_Variables
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup DAC_Private_FunctionPrototypes
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup DAC_Private_Functions
+  * @{
+  */
+
+/**
+  * @brief  Deinitializes the DAC peripheral registers to their default reset values.
+  * @param  None
+  * @retval None
+  */
+void DAC_DeInit(void)
+{
+  /* Enable DAC reset state */
+  RCC_APB1PeriphResetCmd(RCC_APB1Periph_DAC, ENABLE);
+  /* Release DAC from reset state */
+  RCC_APB1PeriphResetCmd(RCC_APB1Periph_DAC, DISABLE);
+}
+
+/**
+  * @brief  Initializes the DAC peripheral according to the specified 
+  *   parameters in the DAC_InitStruct.
+  * @param  DAC_Channel: the selected DAC channel. 
+  *   This parameter can be one of the following values:
+  *     @arg DAC_Channel_1: DAC Channel1 selected
+  *     @arg DAC_Channel_2: DAC Channel2 selected
+  * @param  DAC_InitStruct: pointer to a DAC_InitTypeDef structure that
+  *   contains the configuration information for the specified DAC channel.
+  * @retval None
+  */
+void DAC_Init(uint32_t DAC_Channel, DAC_InitTypeDef* DAC_InitStruct)
+{
+  uint32_t tmpreg1 = 0, tmpreg2 = 0;
+  /* Check the DAC parameters */
+  assert_param(IS_DAC_TRIGGER(DAC_InitStruct-&gt;DAC_Trigger));
+  assert_param(IS_DAC_GENERATE_WAVE(DAC_InitStruct-&gt;DAC_WaveGeneration));
+  assert_param(IS_DAC_LFSR_UNMASK_TRIANGLE_AMPLITUDE(DAC_InitStruct-&gt;DAC_LFSRUnmask_TriangleAmplitude));
+  assert_param(IS_DAC_OUTPUT_BUFFER_STATE(DAC_InitStruct-&gt;DAC_OutputBuffer));
+/*---------------------------- DAC CR Configuration --------------------------*/
+  /* Get the DAC CR value */
+  tmpreg1 = DAC-&gt;CR;
+  /* Clear BOFFx, TENx, TSELx, WAVEx and MAMPx bits */
+  tmpreg1 &amp;= ~(CR_CLEAR_Mask &lt;&lt; DAC_Channel);
+  /* Configure for the selected DAC channel: buffer output, trigger, wave genration,
+     mask/amplitude for wave genration */
+  /* Set TSELx and TENx bits according to DAC_Trigger value */
+  /* Set WAVEx bits according to DAC_WaveGeneration value */
+  /* Set MAMPx bits according to DAC_LFSRUnmask_TriangleAmplitude value */ 
+  /* Set BOFFx bit according to DAC_OutputBuffer value */   
+  tmpreg2 = (DAC_InitStruct-&gt;DAC_Trigger | DAC_InitStruct-&gt;DAC_WaveGeneration |
+             DAC_InitStruct-&gt;DAC_LFSRUnmask_TriangleAmplitude | DAC_InitStruct-&gt;DAC_OutputBuffer);
+  /* Calculate CR register value depending on DAC_Channel */
+  tmpreg1 |= tmpreg2 &lt;&lt; DAC_Channel;
+  /* Write to DAC CR */
+  DAC-&gt;CR = tmpreg1;
+}
+
+/**
+  * @brief  Fills each DAC_InitStruct member with its default value.
+  * @param  DAC_InitStruct : pointer to a DAC_InitTypeDef structure which will
+  *   be initialized.
+  * @retval None
+  */
+void DAC_StructInit(DAC_InitTypeDef* DAC_InitStruct)
+{
+/*--------------- Reset DAC init structure parameters values -----------------*/
+  /* Initialize the DAC_Trigger member */
+  DAC_InitStruct-&gt;DAC_Trigger = DAC_Trigger_None;
+  /* Initialize the DAC_WaveGeneration member */
+  DAC_InitStruct-&gt;DAC_WaveGeneration = DAC_WaveGeneration_None;
+  /* Initialize the DAC_LFSRUnmask_TriangleAmplitude member */
+  DAC_InitStruct-&gt;DAC_LFSRUnmask_TriangleAmplitude = DAC_LFSRUnmask_Bit0;
+  /* Initialize the DAC_OutputBuffer member */
+  DAC_InitStruct-&gt;DAC_OutputBuffer = DAC_OutputBuffer_Enable;
+}
+
+/**
+  * @brief  Enables or disables the specified DAC channel.
+  * @param  DAC_Channel: the selected DAC channel. 
+  *   This parameter can be one of the following values:
+  *     @arg DAC_Channel_1: DAC Channel1 selected
+  *     @arg DAC_Channel_2: DAC Channel2 selected
+  * @param  NewState: new state of the DAC channel. 
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void DAC_Cmd(uint32_t DAC_Channel, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_DAC_CHANNEL(DAC_Channel));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected DAC channel */
+    DAC-&gt;CR |= CR_EN_Set &lt;&lt; DAC_Channel;
+  }
+  else
+  {
+    /* Disable the selected DAC channel */
+    DAC-&gt;CR &amp;= ~(CR_EN_Set &lt;&lt; DAC_Channel);
+  }
+}
+
+/**
+  * @brief  Enables or disables the specified DAC channel DMA request.
+  * @param  DAC_Channel: the selected DAC channel. 
+  *   This parameter can be one of the following values:
+  *     @arg DAC_Channel_1: DAC Channel1 selected
+  *     @arg DAC_Channel_2: DAC Channel2 selected
+  * @param  NewState: new state of the selected DAC channel DMA request.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void DAC_DMACmd(uint32_t DAC_Channel, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_DAC_CHANNEL(DAC_Channel));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected DAC channel DMA request */
+    DAC-&gt;CR |= CR_DMAEN_Set &lt;&lt; DAC_Channel;
+  }
+  else
+  {
+    /* Disable the selected DAC channel DMA request */
+    DAC-&gt;CR &amp;= ~(CR_DMAEN_Set &lt;&lt; DAC_Channel);
+  }
+}
+
+/**
+  * @brief  Enables or disables the selected DAC channel software trigger.
+  * @param  DAC_Channel: the selected DAC channel. 
+  *   This parameter can be one of the following values:
+  *     @arg DAC_Channel_1: DAC Channel1 selected
+  *     @arg DAC_Channel_2: DAC Channel2 selected
+  * @param  NewState: new state of the selected DAC channel software trigger.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void DAC_SoftwareTriggerCmd(uint32_t DAC_Channel, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_DAC_CHANNEL(DAC_Channel));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable software trigger for the selected DAC channel */
+    DAC-&gt;SWTRIGR |= SWTRIGR_SWTRIG_Set &lt;&lt; (DAC_Channel &gt;&gt; 4);
+  }
+  else
+  {
+    /* Disable software trigger for the selected DAC channel */
+    DAC-&gt;SWTRIGR &amp;= ~(SWTRIGR_SWTRIG_Set &lt;&lt; (DAC_Channel &gt;&gt; 4));
+  }
+}
+
+/**
+  * @brief  Enables or disables simultaneously the two DAC channels software
+  *   triggers.
+  * @param  NewState: new state of the DAC channels software triggers.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void DAC_DualSoftwareTriggerCmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable software trigger for both DAC channels */
+    DAC-&gt;SWTRIGR |= DUAL_SWTRIG_Set ;
+  }
+  else
+  {
+    /* Disable software trigger for both DAC channels */
+    DAC-&gt;SWTRIGR &amp;= DUAL_SWTRIG_Reset;
+  }
+}
+
+/**
+  * @brief  Enables or disables the selected DAC channel wave generation.
+  * @param  DAC_Channel: the selected DAC channel. 
+  *   This parameter can be one of the following values:
+  *     @arg DAC_Channel_1: DAC Channel1 selected
+  *     @arg DAC_Channel_2: DAC Channel2 selected
+  * @param  DAC_Wave: Specifies the wave type to enable or disable.
+  *   This parameter can be one of the following values:
+  *     @arg DAC_Wave_Noise: noise wave generation
+  *     @arg DAC_Wave_Triangle: triangle wave generation
+  * @param  NewState: new state of the selected DAC channel wave generation.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void DAC_WaveGenerationCmd(uint32_t DAC_Channel, uint32_t DAC_Wave, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_DAC_CHANNEL(DAC_Channel));
+  assert_param(IS_DAC_WAVE(DAC_Wave)); 
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected wave generation for the selected DAC channel */
+    DAC-&gt;CR |= DAC_Wave &lt;&lt; DAC_Channel;
+  }
+  else
+  {
+    /* Disable the selected wave generation for the selected DAC channel */
+    DAC-&gt;CR &amp;= ~(DAC_Wave &lt;&lt; DAC_Channel);
+  }
+}
+
+/**
+  * @brief  Set the specified data holding register value for DAC channel1.
+  * @param  DAC_Align: Specifies the data alignement for DAC channel1.
+  *   This parameter can be one of the following values:
+  *     @arg DAC_Align_8b_R: 8bit right data alignement selected
+  *     @arg DAC_Align_12b_L: 12bit left data alignement selected
+  *     @arg DAC_Align_12b_R: 12bit right data alignement selected
+  * @param  Data : Data to be loaded in the selected data holding register.
+  * @retval None
+  */
+void DAC_SetChannel1Data(uint32_t DAC_Align, uint16_t Data)
+{  
+  __IO uint32_t tmp = 0;
+  
+  /* Check the parameters */
+  assert_param(IS_DAC_ALIGN(DAC_Align));
+  assert_param(IS_DAC_DATA(Data));
+  
+  tmp = (uint32_t)DAC_BASE; 
+  tmp += DHR12R1_Offset + DAC_Align;
+
+  /* Set the DAC channel1 selected data holding register */
+  *(__IO uint32_t *) tmp = Data;
+}
+
+/**
+  * @brief  Set the specified data holding register value for DAC channel2.
+  * @param  DAC_Align: Specifies the data alignement for DAC channel2.
+  *   This parameter can be one of the following values:
+  *     @arg DAC_Align_8b_R: 8bit right data alignement selected
+  *     @arg DAC_Align_12b_L: 12bit left data alignement selected
+  *     @arg DAC_Align_12b_R: 12bit right data alignement selected
+  * @param  Data : Data to be loaded in the selected data holding register.
+  * @retval None
+  */
+void DAC_SetChannel2Data(uint32_t DAC_Align, uint16_t Data)
+{
+  __IO uint32_t tmp = 0;
+
+  /* Check the parameters */
+  assert_param(IS_DAC_ALIGN(DAC_Align));
+  assert_param(IS_DAC_DATA(Data));
+  
+  tmp = (uint32_t)DAC_BASE;
+  tmp += DHR12R2_Offset + DAC_Align;
+
+  /* Set the DAC channel2 selected data holding register */
+  *(__IO uint32_t *)tmp = Data;
+}
+
+/**
+  * @brief  Set the specified data holding register value for dual channel
+  *   DAC.
+  * @param  DAC_Align: Specifies the data alignement for dual channel DAC.
+  *   This parameter can be one of the following values:
+  *     @arg DAC_Align_8b_R: 8bit right data alignement selected
+  *     @arg DAC_Align_12b_L: 12bit left data alignement selected
+  *     @arg DAC_Align_12b_R: 12bit right data alignement selected
+  * @param  Data2: Data for DAC Channel2 to be loaded in the selected data 
+  *   holding register.
+  * @param  Data1: Data for DAC Channel1 to be loaded in the selected data 
+  *   holding register.
+  * @retval None
+  */
+void DAC_SetDualChannelData(uint32_t DAC_Align, uint16_t Data2, uint16_t Data1)
+{
+  uint32_t data = 0, tmp = 0;
+  
+  /* Check the parameters */
+  assert_param(IS_DAC_ALIGN(DAC_Align));
+  assert_param(IS_DAC_DATA(Data1));
+  assert_param(IS_DAC_DATA(Data2));
+  
+  /* Calculate and set dual DAC data holding register value */
+  if (DAC_Align == DAC_Align_8b_R)
+  {
+    data = ((uint32_t)Data2 &lt;&lt; 8) | Data1; 
+  }
+  else
+  {
+    data = ((uint32_t)Data2 &lt;&lt; 16) | Data1;
+  }
+  
+  tmp = (uint32_t)DAC_BASE;
+  tmp += DHR12RD_Offset + DAC_Align;
+
+  /* Set the dual DAC selected data holding register */
+  *(__IO uint32_t *)tmp = data;
+}
+
+/**
+  * @brief  Returns the last data output value of the selected DAC cahnnel.
+  * @param  DAC_Channel: the selected DAC channel. 
+  *   This parameter can be one of the following values:
+  *     @arg DAC_Channel_1: DAC Channel1 selected
+  *     @arg DAC_Channel_2: DAC Channel2 selected
+  * @retval The selected DAC channel data output value.
+  */
+uint16_t DAC_GetDataOutputValue(uint32_t DAC_Channel)
+{
+  __IO uint32_t tmp = 0;
+  
+  /* Check the parameters */
+  assert_param(IS_DAC_CHANNEL(DAC_Channel));
+  
+  tmp = (uint32_t) DAC_BASE ;
+  tmp += DOR_Offset + ((uint32_t)DAC_Channel &gt;&gt; 2);
+  
+  /* Returns the DAC channel data output register value */
+  return (uint16_t) (*(__IO uint32_t*) tmp);
+}
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2009 STMicroelectronics *****END OF FILE****/

Added: trunk/src/platform/stm32/FWLib/library/src/stm32f10x_dac.o
===================================================================
--- trunk/src/platform/stm32/FWLib/library/src/stm32f10x_dac.o	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/src/stm32f10x_dac.o	2009-07-08 23:39:34 UTC (rev 354)
@@ -0,0 +1,16 @@
+ELF
+h,h$&#234;KhC&#138;hC&#202;hC&#131;@C,`0&#189;
+hC`&#224;#&#131;@I
+h&quot;&#234;
+`pG
+hC`&#224;O&#244;&#128;S&#131;@I
+h&quot;&#234;
+`pG
+M	
+
+
+
+
+
+6
+6
\ No newline at end of file

Modified: trunk/src/platform/stm32/FWLib/library/src/stm32f10x_dbgmcu.c
===================================================================
--- trunk/src/platform/stm32/FWLib/library/src/stm32f10x_dbgmcu.c	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/src/stm32f10x_dbgmcu.c	2009-07-08 23:39:34 UTC (rev 354)
@@ -1,97 +1,152 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_dbgmcu.c
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file provides all the DBGMCU firmware functions.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
-
-/* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_dbgmcu.h&quot;
-
-/* Private typedef -----------------------------------------------------------*/
-/* Private define ------------------------------------------------------------*/
-#define IDCODE_DEVID_Mask    ((u32)0x00000FFF)
-
-/* Private macro -------------------------------------------------------------*/
-/* Private variables ---------------------------------------------------------*/
-/* Private function prototypes -----------------------------------------------*/
-/* Private functions ---------------------------------------------------------*/
-
-/*******************************************************************************
-* Function Name  : DBGMCU_GetREVID
-* Description    : Returns the device revision identifier.
-* Input          : None
-* Output         : None
-* Return         : Device revision identifier
-*******************************************************************************/
-u32 DBGMCU_GetREVID(void)
-{
-   return(DBGMCU-&gt;IDCODE &gt;&gt; 16);
-}
-
-/*******************************************************************************
-* Function Name  : DBGMCU_GetDEVID
-* Description    : Returns the device identifier.
-* Input          : None
-* Output         : None
-* Return         : Device identifier
-*******************************************************************************/
-u32 DBGMCU_GetDEVID(void)
-{
-   return(DBGMCU-&gt;IDCODE &amp; IDCODE_DEVID_Mask);
-}
-
-/*******************************************************************************
-* Function Name  : DBGMCU_Config
-* Description    : Configures the specified peripheral and low power mode behavior
-*                  when the MCU under Debug mode.
-* Input          : - DBGMCU_Periph: specifies the peripheral and low power mode.
-*                    This parameter can be any combination of the following values:
-*                       - DBGMCU_SLEEP: Keep debugger connection during SLEEP mode              
-*                       - DBGMCU_STOP: Keep debugger connection during STOP mode               
-*                       - DBGMCU_STANDBY: Keep debugger connection during STANDBY mode            
-*                       - DBGMCU_IWDG_STOP: Debug IWDG stopped when Core is halted          
-*                       - DBGMCU_WWDG_STOP: Debug WWDG stopped when Core is halted          
-*                       - DBGMCU_TIM1_STOP: TIM1 counter stopped when Core is halted          
-*                       - DBGMCU_TIM2_STOP: TIM2 counter stopped when Core is halted          
-*                       - DBGMCU_TIM3_STOP: TIM3 counter stopped when Core is halted          
-*                       - DBGMCU_TIM4_STOP: TIM4 counter stopped when Core is halted          
-*                       - DBGMCU_CAN_STOP: Debug CAN stopped when Core is halted           
-*                       - DBGMCU_I2C1_SMBUS_TIMEOUT: I2C1 SMBUS timeout mode stopped
-*                                                    when Core is halted
-*                       - DBGMCU_I2C2_SMBUS_TIMEOUT: I2C2 SMBUS timeout mode stopped
-*                                                    when Core is halted
-*                       - DBGMCU_TIM5_STOP: TIM5 counter stopped when Core is halted          
-*                       - DBGMCU_TIM6_STOP: TIM6 counter stopped when Core is halted          
-*                       - DBGMCU_TIM7_STOP: TIM7 counter stopped when Core is halted          
-*                       - DBGMCU_TIM8_STOP: TIM8 counter stopped when Core is halted          
-*                  - NewState: new state of the specified peripheral in Debug mode.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void DBGMCU_Config(u32 DBGMCU_Periph, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_DBGMCU_PERIPH(DBGMCU_Periph));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    DBGMCU-&gt;CR |= DBGMCU_Periph;
-  }
-  else
-  {
-    DBGMCU-&gt;CR &amp;= ~DBGMCU_Periph;
-  }
-}
-
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
+/**
+  ******************************************************************************
+  * @file    stm32f10x_dbgmcu.c
+  * @author  MCD Application Team
+  * @version V3.1.0
+  * @date    06/19/2009
+  * @brief   This file provides all the DBGMCU firmware functions.
+  ******************************************************************************
+  * @copy
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * &lt;h2&gt;&lt;center&gt;&copy; COPYRIGHT 2009 STMicroelectronics&lt;/center&gt;&lt;/h2&gt;
+  */ 
+
+/* Includes ------------------------------------------------------------------*/
+#include &quot;stm32f10x_dbgmcu.h&quot;
+
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup DBGMCU 
+  * @brief DBGMCU driver modules
+  * @{
+  */ 
+
+/** @defgroup DBGMCU_Private_TypesDefinitions
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup DBGMCU_Private_Defines
+  * @{
+  */
+
+#define IDCODE_DEVID_Mask    ((uint32_t)0x00000FFF)
+/**
+  * @}
+  */
+
+/** @defgroup DBGMCU_Private_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup DBGMCU_Private_Variables
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup DBGMCU_Private_FunctionPrototypes
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup DBGMCU_Private_Functions
+  * @{
+  */
+
+/**
+  * @brief  Returns the device revision identifier.
+  * @param  None
+  * @retval Device revision identifier
+  */
+uint32_t DBGMCU_GetREVID(void)
+{
+   return(DBGMCU-&gt;IDCODE &gt;&gt; 16);
+}
+
+/**
+  * @brief  Returns the device identifier.
+  * @param  None
+  * @retval Device identifier
+  */
+uint32_t DBGMCU_GetDEVID(void)
+{
+   return(DBGMCU-&gt;IDCODE &amp; IDCODE_DEVID_Mask);
+}
+
+/**
+  * @brief  Configures the specified peripheral and low power mode behavior
+  *   when the MCU under Debug mode.
+  * @param  DBGMCU_Periph: specifies the peripheral and low power mode.
+  *   This parameter can be any combination of the following values:
+  *     @arg DBGMCU_SLEEP: Keep debugger connection during SLEEP mode              
+  *     @arg DBGMCU_STOP: Keep debugger connection during STOP mode               
+  *     @arg DBGMCU_STANDBY: Keep debugger connection during STANDBY mode            
+  *     @arg DBGMCU_IWDG_STOP: Debug IWDG stopped when Core is halted          
+  *     @arg DBGMCU_WWDG_STOP: Debug WWDG stopped when Core is halted          
+  *     @arg DBGMCU_TIM1_STOP: TIM1 counter stopped when Core is halted          
+  *     @arg DBGMCU_TIM2_STOP: TIM2 counter stopped when Core is halted          
+  *     @arg DBGMCU_TIM3_STOP: TIM3 counter stopped when Core is halted          
+  *     @arg DBGMCU_TIM4_STOP: TIM4 counter stopped when Core is halted          
+  *     @arg DBGMCU_CAN1_STOP: Debug CAN2 stopped when Core is halted           
+  *     @arg DBGMCU_I2C1_SMBUS_TIMEOUT: I2C1 SMBUS timeout mode stopped when Core is halted
+  *     @arg DBGMCU_I2C2_SMBUS_TIMEOUT: I2C2 SMBUS timeout mode stopped when Core is halted
+  *     @arg DBGMCU_TIM5_STOP: TIM5 counter stopped when Core is halted          
+  *     @arg DBGMCU_TIM6_STOP: TIM6 counter stopped when Core is halted          
+  *     @arg DBGMCU_TIM7_STOP: TIM7 counter stopped when Core is halted          
+  *     @arg DBGMCU_TIM8_STOP: TIM8 counter stopped when Core is halted
+  *     @arg DBGMCU_CAN2_STOP: Debug CAN2 stopped when Core is halted           
+  * @param  NewState: new state of the specified peripheral in Debug mode.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void DBGMCU_Config(uint32_t DBGMCU_Periph, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_DBGMCU_PERIPH(DBGMCU_Periph));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    DBGMCU-&gt;CR |= DBGMCU_Periph;
+  }
+  else
+  {
+    DBGMCU-&gt;CR &amp;= ~DBGMCU_Periph;
+  }
+}
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2009 STMicroelectronics *****END OF FILE****/

Added: trunk/src/platform/stm32/FWLib/library/src/stm32f10x_dbgmcu.o
===================================================================
--- trunk/src/platform/stm32/FWLib/library/src/stm32f10x_dbgmcu.o	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/src/stm32f10x_dbgmcu.o	2009-07-08 23:39:34 UTC (rev 354)
@@ -0,0 +1,2 @@
+ELF
+M	
\ No newline at end of file

Modified: trunk/src/platform/stm32/FWLib/library/src/stm32f10x_dma.c
===================================================================
--- trunk/src/platform/stm32/FWLib/library/src/stm32f10x_dma.c	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/src/stm32f10x_dma.c	2009-07-08 23:39:34 UTC (rev 354)
@@ -1,678 +1,693 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_dma.c
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file provides all the DMA firmware functions.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
-
-/* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_dma.h&quot;
-#include &quot;stm32f10x_rcc.h&quot;
-
-/* Private typedef -----------------------------------------------------------*/
-/* Private define ------------------------------------------------------------*/
-/* DMA ENABLE mask */
-#define CCR_ENABLE_Set          ((u32)0x00000001)
-#define CCR_ENABLE_Reset        ((u32)0xFFFFFFFE)
-
-/* DMA1 Channelx interrupt pending bit masks */
-#define DMA1_Channel1_IT_Mask    ((u32)0x0000000F)
-#define DMA1_Channel2_IT_Mask    ((u32)0x000000F0)
-#define DMA1_Channel3_IT_Mask    ((u32)0x00000F00)
-#define DMA1_Channel4_IT_Mask    ((u32)0x0000F000)
-#define DMA1_Channel5_IT_Mask    ((u32)0x000F0000)
-#define DMA1_Channel6_IT_Mask    ((u32)0x00F00000)
-#define DMA1_Channel7_IT_Mask    ((u32)0x0F000000)
-
-/* DMA2 Channelx interrupt pending bit masks */
-#define DMA2_Channel1_IT_Mask    ((u32)0x0000000F)
-#define DMA2_Channel2_IT_Mask    ((u32)0x000000F0)
-#define DMA2_Channel3_IT_Mask    ((u32)0x00000F00)
-#define DMA2_Channel4_IT_Mask    ((u32)0x0000F000)
-#define DMA2_Channel5_IT_Mask    ((u32)0x000F0000)
-
-/* DMA2 FLAG mask */
-#define FLAG_Mask                ((u32)0x10000000)
-
-/* DMA registers Masks */
-#define CCR_CLEAR_Mask           ((u32)0xFFFF800F)
-
-/* Private macro -------------------------------------------------------------*/
-/* Private variables ---------------------------------------------------------*/
-/* Private function prototypes -----------------------------------------------*/
-/* Private functions ---------------------------------------------------------*/
-
-/*******************************************************************************
-* Function Name  : DMA_DeInit
-* Description    : Deinitializes the DMAy Channelx registers to their default reset
-*                  values.
-* Input          : - DMAy_Channelx: where y can be 1 or 2 to select the DMA and
-*                    x can be 1 to 7 for DMA1 and 1 to 5 for DMA2 to select the 
-*                    DMA Channel.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void DMA_DeInit(DMA_Channel_TypeDef* DMAy_Channelx)
-{
-  /* Check the parameters */
-  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
-
-  /* Disable the selected DMAy Channelx */
-  DMAy_Channelx-&gt;CCR &amp;= CCR_ENABLE_Reset;
-
-  /* Reset DMAy Channelx control register */
-  DMAy_Channelx-&gt;CCR  = 0;
-  
-  /* Reset DMAy Channelx remaining bytes register */
-  DMAy_Channelx-&gt;CNDTR = 0;
-  
-  /* Reset DMAy Channelx peripheral address register */
-  DMAy_Channelx-&gt;CPAR  = 0;
-  
-  /* Reset DMAy Channelx memory address register */
-  DMAy_Channelx-&gt;CMAR = 0;
-
-  switch (*(u32*)&amp;DMAy_Channelx)
-  {
-    case DMA1_Channel1_BASE:
-      /* Reset interrupt pending bits for DMA1 Channel1 */
-      DMA1-&gt;IFCR |= DMA1_Channel1_IT_Mask;
-      break;
-
-    case DMA1_Channel2_BASE:
-      /* Reset interrupt pending bits for DMA1 Channel2 */
-      DMA1-&gt;IFCR |= DMA1_Channel2_IT_Mask;
-      break;
-
-    case DMA1_Channel3_BASE:
-      /* Reset interrupt pending bits for DMA1 Channel3 */
-      DMA1-&gt;IFCR |= DMA1_Channel3_IT_Mask;
-      break;
-
-    case DMA1_Channel4_BASE:
-      /* Reset interrupt pending bits for DMA1 Channel4 */
-      DMA1-&gt;IFCR |= DMA1_Channel4_IT_Mask;
-      break;
-
-    case DMA1_Channel5_BASE:
-      /* Reset interrupt pending bits for DMA1 Channel5 */
-      DMA1-&gt;IFCR |= DMA1_Channel5_IT_Mask;
-      break;
-
-    case DMA1_Channel6_BASE:
-      /* Reset interrupt pending bits for DMA1 Channel6 */
-      DMA1-&gt;IFCR |= DMA1_Channel6_IT_Mask;
-      break;
-
-    case DMA1_Channel7_BASE:
-      /* Reset interrupt pending bits for DMA1 Channel7 */
-      DMA1-&gt;IFCR |= DMA1_Channel7_IT_Mask;
-      break;
-
-    case DMA2_Channel1_BASE:
-      /* Reset interrupt pending bits for DMA2 Channel1 */
-      DMA2-&gt;IFCR |= DMA2_Channel1_IT_Mask;
-      break;
-
-    case DMA2_Channel2_BASE:
-      /* Reset interrupt pending bits for DMA2 Channel2 */
-      DMA2-&gt;IFCR |= DMA2_Channel2_IT_Mask;
-      break;
-
-    case DMA2_Channel3_BASE:
-      /* Reset interrupt pending bits for DMA2 Channel3 */
-      DMA2-&gt;IFCR |= DMA2_Channel3_IT_Mask;
-      break;
-
-    case DMA2_Channel4_BASE:
-      /* Reset interrupt pending bits for DMA2 Channel4 */
-      DMA2-&gt;IFCR |= DMA2_Channel4_IT_Mask;
-      break;
-
-    case DMA2_Channel5_BASE:
-      /* Reset interrupt pending bits for DMA2 Channel5 */
-      DMA2-&gt;IFCR |= DMA2_Channel5_IT_Mask;
-      break;
-      
-    default:
-      break;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : DMA_Init
-* Description    : Initializes the DMAy Channelx according to the specified
-*                  parameters in the DMA_InitStruct.
-* Input          : - DMAy_Channelx: where y can be 1 or 2 to select the DMA and 
-*                    x can be 1 to 7 for DMA1 and 1 to 5 for DMA2 to select the 
-*                    DMA Channel.
-*                  - DMA_InitStruct: pointer to a DMA_InitTypeDef structure that
-*                    contains the configuration information for the specified
-*                    DMA Channel.
-* Output         : None
-* Return         : None
-******************************************************************************/
-void DMA_Init(DMA_Channel_TypeDef* DMAy_Channelx, DMA_InitTypeDef* DMA_InitStruct)
-{
-  u32 tmpreg = 0;
-
-  /* Check the parameters */
-  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
-  assert_param(IS_DMA_DIR(DMA_InitStruct-&gt;DMA_DIR));
-  assert_param(IS_DMA_BUFFER_SIZE(DMA_InitStruct-&gt;DMA_BufferSize));
-  assert_param(IS_DMA_PERIPHERAL_INC_STATE(DMA_InitStruct-&gt;DMA_PeripheralInc));
-  assert_param(IS_DMA_MEMORY_INC_STATE(DMA_InitStruct-&gt;DMA_MemoryInc));   
-  assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(DMA_InitStruct-&gt;DMA_PeripheralDataSize));
-  assert_param(IS_DMA_MEMORY_DATA_SIZE(DMA_InitStruct-&gt;DMA_MemoryDataSize));
-  assert_param(IS_DMA_MODE(DMA_InitStruct-&gt;DMA_Mode));
-  assert_param(IS_DMA_PRIORITY(DMA_InitStruct-&gt;DMA_Priority));
-  assert_param(IS_DMA_M2M_STATE(DMA_InitStruct-&gt;DMA_M2M));
-
-/*--------------------------- DMAy Channelx CCR Configuration -----------------*/
-  /* Get the DMAy_Channelx CCR value */
-  tmpreg = DMAy_Channelx-&gt;CCR;
-  /* Clear MEM2MEM, PL, MSIZE, PSIZE, MINC, PINC, CIRC and DIR bits */
-  tmpreg &amp;= CCR_CLEAR_Mask;
-  /* Configure DMAy Channelx: data transfer, data size, priority level and mode */
-  /* Set DIR bit according to DMA_DIR value */
-  /* Set CIRC bit according to DMA_Mode value */
-  /* Set PINC bit according to DMA_PeripheralInc value */
-  /* Set MINC bit according to DMA_MemoryInc value */
-  /* Set PSIZE bits according to DMA_PeripheralDataSize value */
-  /* Set MSIZE bits according to DMA_MemoryDataSize value */
-  /* Set PL bits according to DMA_Priority value */
-  /* Set the MEM2MEM bit according to DMA_M2M value */
-  tmpreg |= DMA_InitStruct-&gt;DMA_DIR | DMA_InitStruct-&gt;DMA_Mode |
-            DMA_InitStruct-&gt;DMA_PeripheralInc | DMA_InitStruct-&gt;DMA_MemoryInc |
-            DMA_InitStruct-&gt;DMA_PeripheralDataSize | DMA_InitStruct-&gt;DMA_MemoryDataSize |
-            DMA_InitStruct-&gt;DMA_Priority | DMA_InitStruct-&gt;DMA_M2M;
-  /* Write to DMAy Channelx CCR */
-  DMAy_Channelx-&gt;CCR = tmpreg;
-
-/*--------------------------- DMAy Channelx CNDTR Configuration ---------------*/
-  /* Write to DMAy Channelx CNDTR */
-  DMAy_Channelx-&gt;CNDTR = DMA_InitStruct-&gt;DMA_BufferSize;
-
-/*--------------------------- DMAy Channelx CPAR Configuration ----------------*/
-  /* Write to DMAy Channelx CPAR */
-  DMAy_Channelx-&gt;CPAR = DMA_InitStruct-&gt;DMA_PeripheralBaseAddr;
-
-/*--------------------------- DMAy Channelx CMAR Configuration ----------------*/
-  /* Write to DMAy Channelx CMAR */
-  DMAy_Channelx-&gt;CMAR = DMA_InitStruct-&gt;DMA_MemoryBaseAddr;
-}
-
-/*******************************************************************************
-* Function Name  : DMA_StructInit
-* Description    : Fills each DMA_InitStruct member with its default value.
-* Input          : - DMA_InitStruct : pointer to a DMA_InitTypeDef structure
-*                    which will be initialized.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void DMA_StructInit(DMA_InitTypeDef* DMA_InitStruct)
-{
-/*-------------- Reset DMA init structure parameters values ------------------*/
-  /* Initialize the DMA_PeripheralBaseAddr member */
-  DMA_InitStruct-&gt;DMA_PeripheralBaseAddr = 0;
-
-  /* Initialize the DMA_MemoryBaseAddr member */
-  DMA_InitStruct-&gt;DMA_MemoryBaseAddr = 0;
-
-  /* Initialize the DMA_DIR member */
-  DMA_InitStruct-&gt;DMA_DIR = DMA_DIR_PeripheralSRC;
-
-  /* Initialize the DMA_BufferSize member */
-  DMA_InitStruct-&gt;DMA_BufferSize = 0;
-
-  /* Initialize the DMA_PeripheralInc member */
-  DMA_InitStruct-&gt;DMA_PeripheralInc = DMA_PeripheralInc_Disable;
-
-  /* Initialize the DMA_MemoryInc member */
-  DMA_InitStruct-&gt;DMA_MemoryInc = DMA_MemoryInc_Disable;
-
-  /* Initialize the DMA_PeripheralDataSize member */
-  DMA_InitStruct-&gt;DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
-
-  /* Initialize the DMA_MemoryDataSize member */
-  DMA_InitStruct-&gt;DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
-
-  /* Initialize the DMA_Mode member */
-  DMA_InitStruct-&gt;DMA_Mode = DMA_Mode_Normal;
-
-  /* Initialize the DMA_Priority member */
-  DMA_InitStruct-&gt;DMA_Priority = DMA_Priority_Low;
-
-  /* Initialize the DMA_M2M member */
-  DMA_InitStruct-&gt;DMA_M2M = DMA_M2M_Disable;
-}
-
-/*******************************************************************************
-* Function Name  : DMA_Cmd
-* Description    : Enables or disables the specified DMAy Channelx.
-* Input          : - DMAy_Channelx: where y can be 1 or 2 to select the DMA and 
-*                    x can be 1 to 7 for DMA1 and 1 to 5 for DMA2 to select the 
-*                    DMA Channel.
-*                  - NewState: new state of the DMAy Channelx. 
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void DMA_Cmd(DMA_Channel_TypeDef* DMAy_Channelx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected DMAy Channelx */
-    DMAy_Channelx-&gt;CCR |= CCR_ENABLE_Set;
-  }
-  else
-  {
-    /* Disable the selected DMAy Channelx */
-    DMAy_Channelx-&gt;CCR &amp;= CCR_ENABLE_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : DMA_ITConfig
-* Description    : Enables or disables the specified DMAy Channelx interrupts.
-* Input          : - DMAy_Channelx: where y can be 1 or 2 to select the DMA and 
-*                    x can be 1 to 7 for DMA1 and 1 to 5 for DMA2 to select the 
-*                    DMA Channel.
-*                  - DMA_IT: specifies the DMA interrupts sources to be enabled
-*                    or disabled. 
-*                    This parameter can be any combination of the following values:
-*                       - DMA_IT_TC:  Transfer complete interrupt mask
-*                       - DMA_IT_HT:  Half transfer interrupt mask
-*                       - DMA_IT_TE:  Transfer error interrupt mask
-*                  - NewState: new state of the specified DMA interrupts.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void DMA_ITConfig(DMA_Channel_TypeDef* DMAy_Channelx, u32 DMA_IT, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
-  assert_param(IS_DMA_CONFIG_IT(DMA_IT));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected DMA interrupts */
-    DMAy_Channelx-&gt;CCR |= DMA_IT;
-  }
-  else
-  {
-    /* Disable the selected DMA interrupts */
-    DMAy_Channelx-&gt;CCR &amp;= ~DMA_IT;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : DMA_GetCurrDataCounter
-* Description    : Returns the number of remaining data units in the current
-*                  DMAy Channelx transfer.
-* Input          : - DMAy_Channelx: where y can be 1 or 2 to select the DMA and 
-*                    x can be 1 to 7 for DMA1 and 1 to 5 for DMA2 to select the 
-*                    DMA Channel.
-* Output         : None
-* Return         : The number of remaining data units in the current DMAy Channelx
-*                  transfer.
-*******************************************************************************/
-u16 DMA_GetCurrDataCounter(DMA_Channel_TypeDef* DMAy_Channelx)
-{
-  /* Check the parameters */
-  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
-
-  /* Return the number of remaining data units for DMAy Channelx */
-  return ((u16)(DMAy_Channelx-&gt;CNDTR));
-}
-
-/*******************************************************************************
-* Function Name  : DMA_GetFlagStatus
-* Description    : Checks whether the specified DMAy Channelx flag is set or not.
-* Input          : - DMA_FLAG: specifies the flag to check.
-*                    This parameter can be one of the following values:
-*                       - DMA1_FLAG_GL1: DMA1 Channel1 global flag.
-*                       - DMA1_FLAG_TC1: DMA1 Channel1 transfer complete flag.
-*                       - DMA1_FLAG_HT1: DMA1 Channel1 half transfer flag.
-*                       - DMA1_FLAG_TE1: DMA1 Channel1 transfer error flag.
-*                       - DMA1_FLAG_GL2: DMA1 Channel2 global flag.
-*                       - DMA1_FLAG_TC2: DMA1 Channel2 transfer complete flag.
-*                       - DMA1_FLAG_HT2: DMA1 Channel2 half transfer flag.
-*                       - DMA1_FLAG_TE2: DMA1 Channel2 transfer error flag.
-*                       - DMA1_FLAG_GL3: DMA1 Channel3 global flag.
-*                       - DMA1_FLAG_TC3: DMA1 Channel3 transfer complete flag.
-*                       - DMA1_FLAG_HT3: DMA1 Channel3 half transfer flag.
-*                       - DMA1_FLAG_TE3: DMA1 Channel3 transfer error flag.
-*                       - DMA1_FLAG_GL4: DMA1 Channel4 global flag.
-*                       - DMA1_FLAG_TC4: DMA1 Channel4 transfer complete flag.
-*                       - DMA1_FLAG_HT4: DMA1 Channel4 half transfer flag.
-*                       - DMA1_FLAG_TE4: DMA1 Channel4 transfer error flag.
-*                       - DMA1_FLAG_GL5: DMA1 Channel5 global flag.
-*                       - DMA1_FLAG_TC5: DMA1 Channel5 transfer complete flag.
-*                       - DMA1_FLAG_HT5: DMA1 Channel5 half transfer flag.
-*                       - DMA1_FLAG_TE5: DMA1 Channel5 transfer error flag.
-*                       - DMA1_FLAG_GL6: DMA1 Channel6 global flag.
-*                       - DMA1_FLAG_TC6: DMA1 Channel6 transfer complete flag.
-*                       - DMA1_FLAG_HT6: DMA1 Channel6 half transfer flag.
-*                       - DMA1_FLAG_TE6: DMA1 Channel6 transfer error flag.
-*                       - DMA1_FLAG_GL7: DMA1 Channel7 global flag.
-*                       - DMA1_FLAG_TC7: DMA1 Channel7 transfer complete flag.
-*                       - DMA1_FLAG_HT7: DMA1 Channel7 half transfer flag.
-*                       - DMA1_FLAG_TE7: DMA1 Channel7 transfer error flag.
-*                       - DMA2_FLAG_GL1: DMA2 Channel1 global flag.
-*                       - DMA2_FLAG_TC1: DMA2 Channel1 transfer complete flag.
-*                       - DMA2_FLAG_HT1: DMA2 Channel1 half transfer flag.
-*                       - DMA2_FLAG_TE1: DMA2 Channel1 transfer error flag.
-*                       - DMA2_FLAG_GL2: DMA2 Channel2 global flag.
-*                       - DMA2_FLAG_TC2: DMA2 Channel2 transfer complete flag.
-*                       - DMA2_FLAG_HT2: DMA2 Channel2 half transfer flag.
-*                       - DMA2_FLAG_TE2: DMA2 Channel2 transfer error flag.
-*                       - DMA2_FLAG_GL3: DMA2 Channel3 global flag.
-*                       - DMA2_FLAG_TC3: DMA2 Channel3 transfer complete flag.
-*                       - DMA2_FLAG_HT3: DMA2 Channel3 half transfer flag.
-*                       - DMA2_FLAG_TE3: DMA2 Channel3 transfer error flag.
-*                       - DMA2_FLAG_GL4: DMA2 Channel4 global flag.
-*                       - DMA2_FLAG_TC4: DMA2 Channel4 transfer complete flag.
-*                       - DMA2_FLAG_HT4: DMA2 Channel4 half transfer flag.
-*                       - DMA2_FLAG_TE4: DMA2 Channel4 transfer error flag.
-*                       - DMA2_FLAG_GL5: DMA2 Channel5 global flag.
-*                       - DMA2_FLAG_TC5: DMA2 Channel5 transfer complete flag.
-*                       - DMA2_FLAG_HT5: DMA2 Channel5 half transfer flag.
-*                       - DMA2_FLAG_TE5: DMA2 Channel5 transfer error flag.
-* Output         : None
-* Return         : The new state of DMA_FLAG (SET or RESET).
-*******************************************************************************/
-FlagStatus DMA_GetFlagStatus(u32 DMA_FLAG)
-{
-  FlagStatus bitstatus = RESET;
-  u32 tmpreg = 0;
-
-  /* Check the parameters */
-  assert_param(IS_DMA_GET_FLAG(DMA_FLAG));
-
-  /* Calculate the used DMA */
-  if ((DMA_FLAG &amp; FLAG_Mask) != (u32)RESET)
-  {
-    /* Get DMA2 ISR register value */
-    tmpreg = DMA2-&gt;ISR ;
-  }
-  else
-  {
-    /* Get DMA1 ISR register value */
-    tmpreg = DMA1-&gt;ISR ;
-  }
-
-  /* Check the status of the specified DMA flag */
-  if ((tmpreg &amp; DMA_FLAG) != (u32)RESET)
-  {
-    /* DMA_FLAG is set */
-    bitstatus = SET;
-  }
-  else
-  {
-    /* DMA_FLAG is reset */
-    bitstatus = RESET;
-  }
-  
-  /* Return the DMA_FLAG status */
-  return  bitstatus;
-}
-
-/*******************************************************************************
-* Function Name  : DMA_ClearFlag
-* Description    : Clears the DMAy Channelx's pending flags.
-* Input          : - DMA_FLAG: specifies the flag to clear.
-*                    This parameter can be any combination (for the same DMA) of 
-*                    the following values:
-*                       - DMA1_FLAG_GL1: DMA1 Channel1 global flag.
-*                       - DMA1_FLAG_TC1: DMA1 Channel1 transfer complete flag.
-*                       - DMA1_FLAG_HT1: DMA1 Channel1 half transfer flag.
-*                       - DMA1_FLAG_TE1: DMA1 Channel1 transfer error flag.
-*                       - DMA1_FLAG_GL2: DMA1 Channel2 global flag.
-*                       - DMA1_FLAG_TC2: DMA1 Channel2 transfer complete flag.
-*                       - DMA1_FLAG_HT2: DMA1 Channel2 half transfer flag.
-*                       - DMA1_FLAG_TE2: DMA1 Channel2 transfer error flag.
-*                       - DMA1_FLAG_GL3: DMA1 Channel3 global flag.
-*                       - DMA1_FLAG_TC3: DMA1 Channel3 transfer complete flag.
-*                       - DMA1_FLAG_HT3: DMA1 Channel3 half transfer flag.
-*                       - DMA1_FLAG_TE3: DMA1 Channel3 transfer error flag.
-*                       - DMA1_FLAG_GL4: DMA1 Channel4 global flag.
-*                       - DMA1_FLAG_TC4: DMA1 Channel4 transfer complete flag.
-*                       - DMA1_FLAG_HT4: DMA1 Channel4 half transfer flag.
-*                       - DMA1_FLAG_TE4: DMA1 Channel4 transfer error flag.
-*                       - DMA1_FLAG_GL5: DMA1 Channel5 global flag.
-*                       - DMA1_FLAG_TC5: DMA1 Channel5 transfer complete flag.
-*                       - DMA1_FLAG_HT5: DMA1 Channel5 half transfer flag.
-*                       - DMA1_FLAG_TE5: DMA1 Channel5 transfer error flag.
-*                       - DMA1_FLAG_GL6: DMA1 Channel6 global flag.
-*                       - DMA1_FLAG_TC6: DMA1 Channel6 transfer complete flag.
-*                       - DMA1_FLAG_HT6: DMA1 Channel6 half transfer flag.
-*                       - DMA1_FLAG_TE6: DMA1 Channel6 transfer error flag.
-*                       - DMA1_FLAG_GL7: DMA1 Channel7 global flag.
-*                       - DMA1_FLAG_TC7: DMA1 Channel7 transfer complete flag.
-*                       - DMA1_FLAG_HT7: DMA1 Channel7 half transfer flag.
-*                       - DMA1_FLAG_TE7: DMA1 Channel7 transfer error flag.
-*                       - DMA2_FLAG_GL1: DMA2 Channel1 global flag.
-*                       - DMA2_FLAG_TC1: DMA2 Channel1 transfer complete flag.
-*                       - DMA2_FLAG_HT1: DMA2 Channel1 half transfer flag.
-*                       - DMA2_FLAG_TE1: DMA2 Channel1 transfer error flag.
-*                       - DMA2_FLAG_GL2: DMA2 Channel2 global flag.
-*                       - DMA2_FLAG_TC2: DMA2 Channel2 transfer complete flag.
-*                       - DMA2_FLAG_HT2: DMA2 Channel2 half transfer flag.
-*                       - DMA2_FLAG_TE2: DMA2 Channel2 transfer error flag.
-*                       - DMA2_FLAG_GL3: DMA2 Channel3 global flag.
-*                       - DMA2_FLAG_TC3: DMA2 Channel3 transfer complete flag.
-*                       - DMA2_FLAG_HT3: DMA2 Channel3 half transfer flag.
-*                       - DMA2_FLAG_TE3: DMA2 Channel3 transfer error flag.
-*                       - DMA2_FLAG_GL4: DMA2 Channel4 global flag.
-*                       - DMA2_FLAG_TC4: DMA2 Channel4 transfer complete flag.
-*                       - DMA2_FLAG_HT4: DMA2 Channel4 half transfer flag.
-*                       - DMA2_FLAG_TE4: DMA2 Channel4 transfer error flag.
-*                       - DMA2_FLAG_GL5: DMA2 Channel5 global flag.
-*                       - DMA2_FLAG_TC5: DMA2 Channel5 transfer complete flag.
-*                       - DMA2_FLAG_HT5: DMA2 Channel5 half transfer flag.
-*                       - DMA2_FLAG_TE5: DMA2 Channel5 transfer error flag.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void DMA_ClearFlag(u32 DMA_FLAG)
-{
-  /* Check the parameters */
-  assert_param(IS_DMA_CLEAR_FLAG(DMA_FLAG));
-
-  /* Calculate the used DMA */
-  if ((DMA_FLAG &amp; FLAG_Mask) != (u32)RESET)
-  {
-    /* Clear the selected DMA flags */
-    DMA2-&gt;IFCR = DMA_FLAG;
-  }
-  else
-  {
-    /* Clear the selected DMA flags */
-    DMA1-&gt;IFCR = DMA_FLAG;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : DMA_GetITStatus
-* Description    : Checks whether the specified DMAy Channelx interrupt has 
-*                  occurred or not.
-* Input          : - DMA_IT: specifies the DMA interrupt source to check. 
-*                    This parameter can be one of the following values:
-*                       - DMA1_IT_GL1: DMA1 Channel1 global interrupt.
-*                       - DMA1_IT_TC1: DMA1 Channel1 transfer complete interrupt.
-*                       - DMA1_IT_HT1: DMA1 Channel1 half transfer interrupt.
-*                       - DMA1_IT_TE1: DMA1 Channel1 transfer error interrupt.
-*                       - DMA1_IT_GL2: DMA1 Channel2 global interrupt.
-*                       - DMA1_IT_TC2: DMA1 Channel2 transfer complete interrupt.
-*                       - DMA1_IT_HT2: DMA1 Channel2 half transfer interrupt.
-*                       - DMA1_IT_TE2: DMA1 Channel2 transfer error interrupt.
-*                       - DMA1_IT_GL3: DMA1 Channel3 global interrupt.
-*                       - DMA1_IT_TC3: DMA1 Channel3 transfer complete interrupt.
-*                       - DMA1_IT_HT3: DMA1 Channel3 half transfer interrupt.
-*                       - DMA1_IT_TE3: DMA1 Channel3 transfer error interrupt.
-*                       - DMA1_IT_GL4: DMA1 Channel4 global interrupt.
-*                       - DMA1_IT_TC4: DMA1 Channel4 transfer complete interrupt.
-*                       - DMA1_IT_HT4: DMA1 Channel4 half transfer interrupt.
-*                       - DMA1_IT_TE4: DMA1 Channel4 transfer error interrupt.
-*                       - DMA1_IT_GL5: DMA1 Channel5 global interrupt.
-*                       - DMA1_IT_TC5: DMA1 Channel5 transfer complete interrupt.
-*                       - DMA1_IT_HT5: DMA1 Channel5 half transfer interrupt.
-*                       - DMA1_IT_TE5: DMA1 Channel5 transfer error interrupt.
-*                       - DMA1_IT_GL6: DMA1 Channel6 global interrupt.
-*                       - DMA1_IT_TC6: DMA1 Channel6 transfer complete interrupt.
-*                       - DMA1_IT_HT6: DMA1 Channel6 half transfer interrupt.
-*                       - DMA1_IT_TE6: DMA1 Channel6 transfer error interrupt.
-*                       - DMA1_IT_GL7: DMA1 Channel7 global interrupt.
-*                       - DMA1_IT_TC7: DMA1 Channel7 transfer complete interrupt.
-*                       - DMA1_IT_HT7: DMA1 Channel7 half transfer interrupt.
-*                       - DMA1_IT_TE7: DMA1 Channel7 transfer error interrupt.
-*                       - DMA2_IT_GL1: DMA2 Channel1 global interrupt.
-*                       - DMA2_IT_TC1: DMA2 Channel1 transfer complete interrupt.
-*                       - DMA2_IT_HT1: DMA2 Channel1 half transfer interrupt.
-*                       - DMA2_IT_TE1: DMA2 Channel1 transfer error interrupt.
-*                       - DMA2_IT_GL2: DMA2 Channel2 global interrupt.
-*                       - DMA2_IT_TC2: DMA2 Channel2 transfer complete interrupt.
-*                       - DMA2_IT_HT2: DMA2 Channel2 half transfer interrupt.
-*                       - DMA2_IT_TE2: DMA2 Channel2 transfer error interrupt.
-*                       - DMA2_IT_GL3: DMA2 Channel3 global interrupt.
-*                       - DMA2_IT_TC3: DMA2 Channel3 transfer complete interrupt.
-*                       - DMA2_IT_HT3: DMA2 Channel3 half transfer interrupt.
-*                       - DMA2_IT_TE3: DMA2 Channel3 transfer error interrupt.
-*                       - DMA2_IT_GL4: DMA2 Channel4 global interrupt.
-*                       - DMA2_IT_TC4: DMA2 Channel4 transfer complete interrupt.
-*                       - DMA2_IT_HT4: DMA2 Channel4 half transfer interrupt.
-*                       - DMA2_IT_TE4: DMA2 Channel4 transfer error interrupt.
-*                       - DMA2_IT_GL5: DMA2 Channel5 global interrupt.
-*                       - DMA2_IT_TC5: DMA2 Channel5 transfer complete interrupt.
-*                       - DMA2_IT_HT5: DMA2 Channel5 half transfer interrupt.
-*                       - DMA2_IT_TE5: DMA2 Channel5 transfer error interrupt.
-* Output         : None
-* Return         : The new state of DMA_IT (SET or RESET).
-*******************************************************************************/
-ITStatus DMA_GetITStatus(u32 DMA_IT)
-{
-  ITStatus bitstatus = RESET;
-  u32 tmpreg = 0;
-
-  /* Check the parameters */
-  assert_param(IS_DMA_GET_IT(DMA_IT));
-
-  /* Calculate the used DMA */
-  if ((DMA_IT &amp; FLAG_Mask) != (u32)RESET)
-  {
-    /* Get DMA2 ISR register value */
-    tmpreg = DMA2-&gt;ISR ;
-  }
-  else
-  {
-    /* Get DMA1 ISR register value */
-    tmpreg = DMA1-&gt;ISR ;
-  }
-
-  /* Check the status of the specified DMA interrupt */
-  if ((tmpreg &amp; DMA_IT) != (u32)RESET)
-  {
-    /* DMA_IT is set */
-    bitstatus = SET;
-  }
-  else
-  {
-    /* DMA_IT is reset */
-    bitstatus = RESET;
-  }
-  /* Return the DMA_IT status */
-  return  bitstatus;
-}
-
-/*******************************************************************************
-* Function Name  : DMA_ClearITPendingBit
-* Description    : Clears the DMAy Channelx's interrupt pending bits.
-* Input          : - DMA_IT: specifies the DMA interrupt pending bit to clear.
-*                    This parameter can be any combination (for the same DMA) of
-*                    the following values:
-*                       - DMA1_IT_GL1: DMA1 Channel1 global interrupt.
-*                       - DMA1_IT_TC1: DMA1 Channel1 transfer complete interrupt.
-*                       - DMA1_IT_HT1: DMA1 Channel1 half transfer interrupt.
-*                       - DMA1_IT_TE1: DMA1 Channel1 transfer error interrupt.
-*                       - DMA1_IT_GL2: DMA1 Channel2 global interrupt.
-*                       - DMA1_IT_TC2: DMA1 Channel2 transfer complete interrupt.
-*                       - DMA1_IT_HT2: DMA1 Channel2 half transfer interrupt.
-*                       - DMA1_IT_TE2: DMA1 Channel2 transfer error interrupt.
-*                       - DMA1_IT_GL3: DMA1 Channel3 global interrupt.
-*                       - DMA1_IT_TC3: DMA1 Channel3 transfer complete interrupt.
-*                       - DMA1_IT_HT3: DMA1 Channel3 half transfer interrupt.
-*                       - DMA1_IT_TE3: DMA1 Channel3 transfer error interrupt.
-*                       - DMA1_IT_GL4: DMA1 Channel4 global interrupt.
-*                       - DMA1_IT_TC4: DMA1 Channel4 transfer complete interrupt.
-*                       - DMA1_IT_HT4: DMA1 Channel4 half transfer interrupt.
-*                       - DMA1_IT_TE4: DMA1 Channel4 transfer error interrupt.
-*                       - DMA1_IT_GL5: DMA1 Channel5 global interrupt.
-*                       - DMA1_IT_TC5: DMA1 Channel5 transfer complete interrupt.
-*                       - DMA1_IT_HT5: DMA1 Channel5 half transfer interrupt.
-*                       - DMA1_IT_TE5: DMA1 Channel5 transfer error interrupt.
-*                       - DMA1_IT_GL6: DMA1 Channel6 global interrupt.
-*                       - DMA1_IT_TC6: DMA1 Channel6 transfer complete interrupt.
-*                       - DMA1_IT_HT6: DMA1 Channel6 half transfer interrupt.
-*                       - DMA1_IT_TE6: DMA1 Channel6 transfer error interrupt.
-*                       - DMA1_IT_GL7: DMA1 Channel7 global interrupt.
-*                       - DMA1_IT_TC7: DMA1 Channel7 transfer complete interrupt.
-*                       - DMA1_IT_HT7: DMA1 Channel7 half transfer interrupt.
-*                       - DMA1_IT_TE7: DMA1 Channel7 transfer error interrupt.
-*                       - DMA2_IT_GL1: DMA2 Channel1 global interrupt.
-*                       - DMA2_IT_TC1: DMA2 Channel1 transfer complete interrupt.
-*                       - DMA2_IT_HT1: DMA2 Channel1 half transfer interrupt.
-*                       - DMA2_IT_TE1: DMA2 Channel1 transfer error interrupt.
-*                       - DMA2_IT_GL2: DMA2 Channel2 global interrupt.
-*                       - DMA2_IT_TC2: DMA2 Channel2 transfer complete interrupt.
-*                       - DMA2_IT_HT2: DMA2 Channel2 half transfer interrupt.
-*                       - DMA2_IT_TE2: DMA2 Channel2 transfer error interrupt.
-*                       - DMA2_IT_GL3: DMA2 Channel3 global interrupt.
-*                       - DMA2_IT_TC3: DMA2 Channel3 transfer complete interrupt.
-*                       - DMA2_IT_HT3: DMA2 Channel3 half transfer interrupt.
-*                       - DMA2_IT_TE3: DMA2 Channel3 transfer error interrupt.
-*                       - DMA2_IT_GL4: DMA2 Channel4 global interrupt.
-*                       - DMA2_IT_TC4: DMA2 Channel4 transfer complete interrupt.
-*                       - DMA2_IT_HT4: DMA2 Channel4 half transfer interrupt.
-*                       - DMA2_IT_TE4: DMA2 Channel4 transfer error interrupt.
-*                       - DMA2_IT_GL5: DMA2 Channel5 global interrupt.
-*                       - DMA2_IT_TC5: DMA2 Channel5 transfer complete interrupt.
-*                       - DMA2_IT_HT5: DMA2 Channel5 half transfer interrupt.
-*                       - DMA2_IT_TE5: DMA2 Channel5 transfer error interrupt.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void DMA_ClearITPendingBit(u32 DMA_IT)
-{
-  /* Check the parameters */
-  assert_param(IS_DMA_CLEAR_IT(DMA_IT));
-
-  /* Calculate the used DMA */
-  if ((DMA_IT &amp; FLAG_Mask) != (u32)RESET)
-  {
-    /* Clear the selected DMA interrupt pending bits */
-    DMA2-&gt;IFCR = DMA_IT;
-  }
-  else
-  {
-    /* Clear the selected DMA interrupt pending bits */
-    DMA1-&gt;IFCR = DMA_IT;
-  }
-}
-
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
-
+/**
+  ******************************************************************************
+  * @file    stm32f10x_dma.c
+  * @author  MCD Application Team
+  * @version V3.1.0
+  * @date    06/19/2009
+  * @brief   This file provides all the DMA firmware functions.
+  ******************************************************************************
+  * @copy
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * &lt;h2&gt;&lt;center&gt;&copy; COPYRIGHT 2009 STMicroelectronics&lt;/center&gt;&lt;/h2&gt;
+  */ 
+
+/* Includes ------------------------------------------------------------------*/
+#include &quot;stm32f10x_dma.h&quot;
+#include &quot;stm32f10x_rcc.h&quot;
+
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup DMA 
+  * @brief DMA driver modules
+  * @{
+  */ 
+
+/** @defgroup DMA_Private_TypesDefinitions
+  * @{
+  */ 
+/**
+  * @}
+  */
+
+/** @defgroup DMA_Private_Defines
+  * @{
+  */
+
+/* DMA ENABLE mask */
+#define CCR_ENABLE_Set          ((uint32_t)0x00000001)
+#define CCR_ENABLE_Reset        ((uint32_t)0xFFFFFFFE)
+
+/* DMA1 Channelx interrupt pending bit masks */
+#define DMA1_Channel1_IT_Mask    ((uint32_t)0x0000000F)
+#define DMA1_Channel2_IT_Mask    ((uint32_t)0x000000F0)
+#define DMA1_Channel3_IT_Mask    ((uint32_t)0x00000F00)
+#define DMA1_Channel4_IT_Mask    ((uint32_t)0x0000F000)
+#define DMA1_Channel5_IT_Mask    ((uint32_t)0x000F0000)
+#define DMA1_Channel6_IT_Mask    ((uint32_t)0x00F00000)
+#define DMA1_Channel7_IT_Mask    ((uint32_t)0x0F000000)
+
+/* DMA2 Channelx interrupt pending bit masks */
+#define DMA2_Channel1_IT_Mask    ((uint32_t)0x0000000F)
+#define DMA2_Channel2_IT_Mask    ((uint32_t)0x000000F0)
+#define DMA2_Channel3_IT_Mask    ((uint32_t)0x00000F00)
+#define DMA2_Channel4_IT_Mask    ((uint32_t)0x0000F000)
+#define DMA2_Channel5_IT_Mask    ((uint32_t)0x000F0000)
+
+/* DMA2 FLAG mask */
+#define FLAG_Mask                ((uint32_t)0x10000000)
+
+/* DMA registers Masks */
+#define CCR_CLEAR_Mask           ((uint32_t)0xFFFF800F)
+
+/**
+  * @}
+  */
+
+/** @defgroup DMA_Private_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup DMA_Private_Variables
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup DMA_Private_FunctionPrototypes
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup DMA_Private_Functions
+  * @{
+  */
+
+/**
+  * @brief  Deinitializes the DMAy Channelx registers to their default reset
+  *   values.
+  * @param  DMAy_Channelx: where y can be 1 or 2 to select the DMA and
+  *   x can be 1 to 7 for DMA1 and 1 to 5 for DMA2 to select the DMA Channel.
+  * @retval None
+  */
+void DMA_DeInit(DMA_Channel_TypeDef* DMAy_Channelx)
+{
+  /* Check the parameters */
+  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
+  /* Disable the selected DMAy Channelx */
+  DMAy_Channelx-&gt;CCR &amp;= CCR_ENABLE_Reset;
+  /* Reset DMAy Channelx control register */
+  DMAy_Channelx-&gt;CCR  = 0;
+  
+  /* Reset DMAy Channelx remaining bytes register */
+  DMAy_Channelx-&gt;CNDTR = 0;
+  
+  /* Reset DMAy Channelx peripheral address register */
+  DMAy_Channelx-&gt;CPAR  = 0;
+  
+  /* Reset DMAy Channelx memory address register */
+  DMAy_Channelx-&gt;CMAR = 0;
+  
+  if (DMAy_Channelx == DMA1_Channel1)
+  {
+    /* Reset interrupt pending bits for DMA1 Channel1 */
+    DMA1-&gt;IFCR |= DMA1_Channel1_IT_Mask;
+  }
+  else if (DMAy_Channelx == DMA1_Channel2)
+  {
+    /* Reset interrupt pending bits for DMA1 Channel2 */
+    DMA1-&gt;IFCR |= DMA1_Channel2_IT_Mask;
+  }
+  else if (DMAy_Channelx == DMA1_Channel3)
+  {
+    /* Reset interrupt pending bits for DMA1 Channel3 */
+    DMA1-&gt;IFCR |= DMA1_Channel3_IT_Mask;
+  }
+  else if (DMAy_Channelx == DMA1_Channel4)
+  {
+    /* Reset interrupt pending bits for DMA1 Channel4 */
+    DMA1-&gt;IFCR |= DMA1_Channel4_IT_Mask;
+  }
+  else if (DMAy_Channelx == DMA1_Channel5)
+  {
+    /* Reset interrupt pending bits for DMA1 Channel5 */
+    DMA1-&gt;IFCR |= DMA1_Channel5_IT_Mask;
+  }
+  else if (DMAy_Channelx == DMA1_Channel6)
+  {
+    /* Reset interrupt pending bits for DMA1 Channel6 */
+    DMA1-&gt;IFCR |= DMA1_Channel6_IT_Mask;
+  }
+  else if (DMAy_Channelx == DMA1_Channel7)
+  {
+    /* Reset interrupt pending bits for DMA1 Channel7 */
+    DMA1-&gt;IFCR |= DMA1_Channel7_IT_Mask;
+  }
+  else if (DMAy_Channelx == DMA2_Channel1)
+  {
+    /* Reset interrupt pending bits for DMA2 Channel1 */
+    DMA2-&gt;IFCR |= DMA2_Channel1_IT_Mask;
+  }
+  else if (DMAy_Channelx == DMA2_Channel2)
+  {
+    /* Reset interrupt pending bits for DMA2 Channel2 */
+    DMA2-&gt;IFCR |= DMA2_Channel2_IT_Mask;
+  }
+  else if (DMAy_Channelx == DMA2_Channel3)
+  {
+    /* Reset interrupt pending bits for DMA2 Channel3 */
+    DMA2-&gt;IFCR |= DMA2_Channel3_IT_Mask;
+  }
+  else if (DMAy_Channelx == DMA2_Channel4)
+  {
+    /* Reset interrupt pending bits for DMA2 Channel4 */
+    DMA2-&gt;IFCR |= DMA2_Channel4_IT_Mask;
+  }
+  else
+  { 
+    if (DMAy_Channelx == DMA2_Channel5)
+    {
+      /* Reset interrupt pending bits for DMA2 Channel5 */
+      DMA2-&gt;IFCR |= DMA2_Channel5_IT_Mask;
+    }
+  }
+}
+
+/**
+  * @brief  Initializes the DMAy Channelx according to the specified
+  *   parameters in the DMA_InitStruct.
+  * @param  DMAy_Channelx: where y can be 1 or 2 to select the DMA and 
+  *   x can be 1 to 7 for DMA1 and 1 to 5 for DMA2 to select the DMA Channel.
+  * @param  DMA_InitStruct: pointer to a DMA_InitTypeDef structure that
+  *   contains the configuration information for the specified DMA Channel.
+  * @retval None
+  */
+void DMA_Init(DMA_Channel_TypeDef* DMAy_Channelx, DMA_InitTypeDef* DMA_InitStruct)
+{
+  uint32_t tmpreg = 0;
+
+  /* Check the parameters */
+  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
+  assert_param(IS_DMA_DIR(DMA_InitStruct-&gt;DMA_DIR));
+  assert_param(IS_DMA_BUFFER_SIZE(DMA_InitStruct-&gt;DMA_BufferSize));
+  assert_param(IS_DMA_PERIPHERAL_INC_STATE(DMA_InitStruct-&gt;DMA_PeripheralInc));
+  assert_param(IS_DMA_MEMORY_INC_STATE(DMA_InitStruct-&gt;DMA_MemoryInc));   
+  assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(DMA_InitStruct-&gt;DMA_PeripheralDataSize));
+  assert_param(IS_DMA_MEMORY_DATA_SIZE(DMA_InitStruct-&gt;DMA_MemoryDataSize));
+  assert_param(IS_DMA_MODE(DMA_InitStruct-&gt;DMA_Mode));
+  assert_param(IS_DMA_PRIORITY(DMA_InitStruct-&gt;DMA_Priority));
+  assert_param(IS_DMA_M2M_STATE(DMA_InitStruct-&gt;DMA_M2M));
+
+/*--------------------------- DMAy Channelx CCR Configuration -----------------*/
+  /* Get the DMAy_Channelx CCR value */
+  tmpreg = DMAy_Channelx-&gt;CCR;
+  /* Clear MEM2MEM, PL, MSIZE, PSIZE, MINC, PINC, CIRC and DIR bits */
+  tmpreg &amp;= CCR_CLEAR_Mask;
+  /* Configure DMAy Channelx: data transfer, data size, priority level and mode */
+  /* Set DIR bit according to DMA_DIR value */
+  /* Set CIRC bit according to DMA_Mode value */
+  /* Set PINC bit according to DMA_PeripheralInc value */
+  /* Set MINC bit according to DMA_MemoryInc value */
+  /* Set PSIZE bits according to DMA_PeripheralDataSize value */
+  /* Set MSIZE bits according to DMA_MemoryDataSize value */
+  /* Set PL bits according to DMA_Priority value */
+  /* Set the MEM2MEM bit according to DMA_M2M value */
+  tmpreg |= DMA_InitStruct-&gt;DMA_DIR | DMA_InitStruct-&gt;DMA_Mode |
+            DMA_InitStruct-&gt;DMA_PeripheralInc | DMA_InitStruct-&gt;DMA_MemoryInc |
+            DMA_InitStruct-&gt;DMA_PeripheralDataSize | DMA_InitStruct-&gt;DMA_MemoryDataSize |
+            DMA_InitStruct-&gt;DMA_Priority | DMA_InitStruct-&gt;DMA_M2M;
+
+  /* Write to DMAy Channelx CCR */
+  DMAy_Channelx-&gt;CCR = tmpreg;
+
+/*--------------------------- DMAy Channelx CNDTR Configuration ---------------*/
+  /* Write to DMAy Channelx CNDTR */
+  DMAy_Channelx-&gt;CNDTR = DMA_InitStruct-&gt;DMA_BufferSize;
+
+/*--------------------------- DMAy Channelx CPAR Configuration ----------------*/
+  /* Write to DMAy Channelx CPAR */
+  DMAy_Channelx-&gt;CPAR = DMA_InitStruct-&gt;DMA_PeripheralBaseAddr;
+
+/*--------------------------- DMAy Channelx CMAR Configuration ----------------*/
+  /* Write to DMAy Channelx CMAR */
+  DMAy_Channelx-&gt;CMAR = DMA_InitStruct-&gt;DMA_MemoryBaseAddr;
+}
+
+/**
+  * @brief  Fills each DMA_InitStruct member with its default value.
+  * @param  DMA_InitStruct : pointer to a DMA_InitTypeDef structure which will
+  *   be initialized.
+  * @retval None
+  */
+void DMA_StructInit(DMA_InitTypeDef* DMA_InitStruct)
+{
+/*-------------- Reset DMA init structure parameters values ------------------*/
+  /* Initialize the DMA_PeripheralBaseAddr member */
+  DMA_InitStruct-&gt;DMA_PeripheralBaseAddr = 0;
+  /* Initialize the DMA_MemoryBaseAddr member */
+  DMA_InitStruct-&gt;DMA_MemoryBaseAddr = 0;
+  /* Initialize the DMA_DIR member */
+  DMA_InitStruct-&gt;DMA_DIR = DMA_DIR_PeripheralSRC;
+  /* Initialize the DMA_BufferSize member */
+  DMA_InitStruct-&gt;DMA_BufferSize = 0;
+  /* Initialize the DMA_PeripheralInc member */
+  DMA_InitStruct-&gt;DMA_PeripheralInc = DMA_PeripheralInc_Disable;
+  /* Initialize the DMA_MemoryInc member */
+  DMA_InitStruct-&gt;DMA_MemoryInc = DMA_MemoryInc_Disable;
+  /* Initialize the DMA_PeripheralDataSize member */
+  DMA_InitStruct-&gt;DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
+  /* Initialize the DMA_MemoryDataSize member */
+  DMA_InitStruct-&gt;DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
+  /* Initialize the DMA_Mode member */
+  DMA_InitStruct-&gt;DMA_Mode = DMA_Mode_Normal;
+  /* Initialize the DMA_Priority member */
+  DMA_InitStruct-&gt;DMA_Priority = DMA_Priority_Low;
+  /* Initialize the DMA_M2M member */
+  DMA_InitStruct-&gt;DMA_M2M = DMA_M2M_Disable;
+}
+
+/**
+  * @brief  Enables or disables the specified DMAy Channelx.
+  * @param  DMAy_Channelx: where y can be 1 or 2 to select the DMA and 
+  *   x can be 1 to 7 for DMA1 and 1 to 5 for DMA2 to select the DMA Channel.
+  * @param  NewState: new state of the DMAy Channelx. 
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void DMA_Cmd(DMA_Channel_TypeDef* DMAy_Channelx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected DMAy Channelx */
+    DMAy_Channelx-&gt;CCR |= CCR_ENABLE_Set;
+  }
+  else
+  {
+    /* Disable the selected DMAy Channelx */
+    DMAy_Channelx-&gt;CCR &amp;= CCR_ENABLE_Reset;
+  }
+}
+
+/**
+  * @brief  Enables or disables the specified DMAy Channelx interrupts.
+  * @param  DMAy_Channelx: where y can be 1 or 2 to select the DMA and 
+  *   x can be 1 to 7 for DMA1 and 1 to 5 for DMA2 to select the DMA Channel.
+  * @param  DMA_IT: specifies the DMA interrupts sources to be enabled
+  *   or disabled. 
+  *   This parameter can be any combination of the following values:
+  *     @arg DMA_IT_TC:  Transfer complete interrupt mask
+  *     @arg DMA_IT_HT:  Half transfer interrupt mask
+  *     @arg DMA_IT_TE:  Transfer error interrupt mask
+  * @param  NewState: new state of the specified DMA interrupts.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void DMA_ITConfig(DMA_Channel_TypeDef* DMAy_Channelx, uint32_t DMA_IT, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
+  assert_param(IS_DMA_CONFIG_IT(DMA_IT));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected DMA interrupts */
+    DMAy_Channelx-&gt;CCR |= DMA_IT;
+  }
+  else
+  {
+    /* Disable the selected DMA interrupts */
+    DMAy_Channelx-&gt;CCR &amp;= ~DMA_IT;
+  }
+}
+
+/**
+  * @brief  Returns the number of remaining data units in the current
+  *   DMAy Channelx transfer.
+  * @param  DMAy_Channelx: where y can be 1 or 2 to select the DMA and 
+  *   x can be 1 to 7 for DMA1 and 1 to 5 for DMA2 to select the DMA Channel.
+  * @retval The number of remaining data units in the current DMAy Channelx
+  *   transfer.
+  */
+uint16_t DMA_GetCurrDataCounter(DMA_Channel_TypeDef* DMAy_Channelx)
+{
+  /* Check the parameters */
+  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
+  /* Return the number of remaining data units for DMAy Channelx */
+  return ((uint16_t)(DMAy_Channelx-&gt;CNDTR));
+}
+
+/**
+  * @brief  Checks whether the specified DMAy Channelx flag is set or not.
+  * @param  DMA_FLAG: specifies the flag to check.
+  *   This parameter can be one of the following values:
+  *     @arg DMA1_FLAG_GL1: DMA1 Channel1 global flag.
+  *     @arg DMA1_FLAG_TC1: DMA1 Channel1 transfer complete flag.
+  *     @arg DMA1_FLAG_HT1: DMA1 Channel1 half transfer flag.
+  *     @arg DMA1_FLAG_TE1: DMA1 Channel1 transfer error flag.
+  *     @arg DMA1_FLAG_GL2: DMA1 Channel2 global flag.
+  *     @arg DMA1_FLAG_TC2: DMA1 Channel2 transfer complete flag.
+  *     @arg DMA1_FLAG_HT2: DMA1 Channel2 half transfer flag.
+  *     @arg DMA1_FLAG_TE2: DMA1 Channel2 transfer error flag.
+  *     @arg DMA1_FLAG_GL3: DMA1 Channel3 global flag.
+  *     @arg DMA1_FLAG_TC3: DMA1 Channel3 transfer complete flag.
+  *     @arg DMA1_FLAG_HT3: DMA1 Channel3 half transfer flag.
+  *     @arg DMA1_FLAG_TE3: DMA1 Channel3 transfer error flag.
+  *     @arg DMA1_FLAG_GL4: DMA1 Channel4 global flag.
+  *     @arg DMA1_FLAG_TC4: DMA1 Channel4 transfer complete flag.
+  *     @arg DMA1_FLAG_HT4: DMA1 Channel4 half transfer flag.
+  *     @arg DMA1_FLAG_TE4: DMA1 Channel4 transfer error flag.
+  *     @arg DMA1_FLAG_GL5: DMA1 Channel5 global flag.
+  *     @arg DMA1_FLAG_TC5: DMA1 Channel5 transfer complete flag.
+  *     @arg DMA1_FLAG_HT5: DMA1 Channel5 half transfer flag.
+  *     @arg DMA1_FLAG_TE5: DMA1 Channel5 transfer error flag.
+  *     @arg DMA1_FLAG_GL6: DMA1 Channel6 global flag.
+  *     @arg DMA1_FLAG_TC6: DMA1 Channel6 transfer complete flag.
+  *     @arg DMA1_FLAG_HT6: DMA1 Channel6 half transfer flag.
+  *     @arg DMA1_FLAG_TE6: DMA1 Channel6 transfer error flag.
+  *     @arg DMA1_FLAG_GL7: DMA1 Channel7 global flag.
+  *     @arg DMA1_FLAG_TC7: DMA1 Channel7 transfer complete flag.
+  *     @arg DMA1_FLAG_HT7: DMA1 Channel7 half transfer flag.
+  *     @arg DMA1_FLAG_TE7: DMA1 Channel7 transfer error flag.
+  *     @arg DMA2_FLAG_GL1: DMA2 Channel1 global flag.
+  *     @arg DMA2_FLAG_TC1: DMA2 Channel1 transfer complete flag.
+  *     @arg DMA2_FLAG_HT1: DMA2 Channel1 half transfer flag.
+  *     @arg DMA2_FLAG_TE1: DMA2 Channel1 transfer error flag.
+  *     @arg DMA2_FLAG_GL2: DMA2 Channel2 global flag.
+  *     @arg DMA2_FLAG_TC2: DMA2 Channel2 transfer complete flag.
+  *     @arg DMA2_FLAG_HT2: DMA2 Channel2 half transfer flag.
+  *     @arg DMA2_FLAG_TE2: DMA2 Channel2 transfer error flag.
+  *     @arg DMA2_FLAG_GL3: DMA2 Channel3 global flag.
+  *     @arg DMA2_FLAG_TC3: DMA2 Channel3 transfer complete flag.
+  *     @arg DMA2_FLAG_HT3: DMA2 Channel3 half transfer flag.
+  *     @arg DMA2_FLAG_TE3: DMA2 Channel3 transfer error flag.
+  *     @arg DMA2_FLAG_GL4: DMA2 Channel4 global flag.
+  *     @arg DMA2_FLAG_TC4: DMA2 Channel4 transfer complete flag.
+  *     @arg DMA2_FLAG_HT4: DMA2 Channel4 half transfer flag.
+  *     @arg DMA2_FLAG_TE4: DMA2 Channel4 transfer error flag.
+  *     @arg DMA2_FLAG_GL5: DMA2 Channel5 global flag.
+  *     @arg DMA2_FLAG_TC5: DMA2 Channel5 transfer complete flag.
+  *     @arg DMA2_FLAG_HT5: DMA2 Channel5 half transfer flag.
+  *     @arg DMA2_FLAG_TE5: DMA2 Channel5 transfer error flag.
+  * @retval The new state of DMA_FLAG (SET or RESET).
+  */
+FlagStatus DMA_GetFlagStatus(uint32_t DMA_FLAG)
+{
+  FlagStatus bitstatus = RESET;
+  uint32_t tmpreg = 0;
+  /* Check the parameters */
+  assert_param(IS_DMA_GET_FLAG(DMA_FLAG));
+
+  /* Calculate the used DMA */
+  if ((DMA_FLAG &amp; FLAG_Mask) != (uint32_t)RESET)
+  {
+    /* Get DMA2 ISR register value */
+    tmpreg = DMA2-&gt;ISR ;
+  }
+  else
+  {
+    /* Get DMA1 ISR register value */
+    tmpreg = DMA1-&gt;ISR ;
+  }
+
+  /* Check the status of the specified DMA flag */
+  if ((tmpreg &amp; DMA_FLAG) != (uint32_t)RESET)
+  {
+    /* DMA_FLAG is set */
+    bitstatus = SET;
+  }
+  else
+  {
+    /* DMA_FLAG is reset */
+    bitstatus = RESET;
+  }
+  
+  /* Return the DMA_FLAG status */
+  return  bitstatus;
+}
+
+/**
+  * @brief  Clears the DMAy Channelx's pending flags.
+  * @param  DMA_FLAG: specifies the flag to clear.
+  *   This parameter can be any combination (for the same DMA) of the following values:
+  *     @arg DMA1_FLAG_GL1: DMA1 Channel1 global flag.
+  *     @arg DMA1_FLAG_TC1: DMA1 Channel1 transfer complete flag.
+  *     @arg DMA1_FLAG_HT1: DMA1 Channel1 half transfer flag.
+  *     @arg DMA1_FLAG_TE1: DMA1 Channel1 transfer error flag.
+  *     @arg DMA1_FLAG_GL2: DMA1 Channel2 global flag.
+  *     @arg DMA1_FLAG_TC2: DMA1 Channel2 transfer complete flag.
+  *     @arg DMA1_FLAG_HT2: DMA1 Channel2 half transfer flag.
+  *     @arg DMA1_FLAG_TE2: DMA1 Channel2 transfer error flag.
+  *     @arg DMA1_FLAG_GL3: DMA1 Channel3 global flag.
+  *     @arg DMA1_FLAG_TC3: DMA1 Channel3 transfer complete flag.
+  *     @arg DMA1_FLAG_HT3: DMA1 Channel3 half transfer flag.
+  *     @arg DMA1_FLAG_TE3: DMA1 Channel3 transfer error flag.
+  *     @arg DMA1_FLAG_GL4: DMA1 Channel4 global flag.
+  *     @arg DMA1_FLAG_TC4: DMA1 Channel4 transfer complete flag.
+  *     @arg DMA1_FLAG_HT4: DMA1 Channel4 half transfer flag.
+  *     @arg DMA1_FLAG_TE4: DMA1 Channel4 transfer error flag.
+  *     @arg DMA1_FLAG_GL5: DMA1 Channel5 global flag.
+  *     @arg DMA1_FLAG_TC5: DMA1 Channel5 transfer complete flag.
+  *     @arg DMA1_FLAG_HT5: DMA1 Channel5 half transfer flag.
+  *     @arg DMA1_FLAG_TE5: DMA1 Channel5 transfer error flag.
+  *     @arg DMA1_FLAG_GL6: DMA1 Channel6 global flag.
+  *     @arg DMA1_FLAG_TC6: DMA1 Channel6 transfer complete flag.
+  *     @arg DMA1_FLAG_HT6: DMA1 Channel6 half transfer flag.
+  *     @arg DMA1_FLAG_TE6: DMA1 Channel6 transfer error flag.
+  *     @arg DMA1_FLAG_GL7: DMA1 Channel7 global flag.
+  *     @arg DMA1_FLAG_TC7: DMA1 Channel7 transfer complete flag.
+  *     @arg DMA1_FLAG_HT7: DMA1 Channel7 half transfer flag.
+  *     @arg DMA1_FLAG_TE7: DMA1 Channel7 transfer error flag.
+  *     @arg DMA2_FLAG_GL1: DMA2 Channel1 global flag.
+  *     @arg DMA2_FLAG_TC1: DMA2 Channel1 transfer complete flag.
+  *     @arg DMA2_FLAG_HT1: DMA2 Channel1 half transfer flag.
+  *     @arg DMA2_FLAG_TE1: DMA2 Channel1 transfer error flag.
+  *     @arg DMA2_FLAG_GL2: DMA2 Channel2 global flag.
+  *     @arg DMA2_FLAG_TC2: DMA2 Channel2 transfer complete flag.
+  *     @arg DMA2_FLAG_HT2: DMA2 Channel2 half transfer flag.
+  *     @arg DMA2_FLAG_TE2: DMA2 Channel2 transfer error flag.
+  *     @arg DMA2_FLAG_GL3: DMA2 Channel3 global flag.
+  *     @arg DMA2_FLAG_TC3: DMA2 Channel3 transfer complete flag.
+  *     @arg DMA2_FLAG_HT3: DMA2 Channel3 half transfer flag.
+  *     @arg DMA2_FLAG_TE3: DMA2 Channel3 transfer error flag.
+  *     @arg DMA2_FLAG_GL4: DMA2 Channel4 global flag.
+  *     @arg DMA2_FLAG_TC4: DMA2 Channel4 transfer complete flag.
+  *     @arg DMA2_FLAG_HT4: DMA2 Channel4 half transfer flag.
+  *     @arg DMA2_FLAG_TE4: DMA2 Channel4 transfer error flag.
+  *     @arg DMA2_FLAG_GL5: DMA2 Channel5 global flag.
+  *     @arg DMA2_FLAG_TC5: DMA2 Channel5 transfer complete flag.
+  *     @arg DMA2_FLAG_HT5: DMA2 Channel5 half transfer flag.
+  *     @arg DMA2_FLAG_TE5: DMA2 Channel5 transfer error flag.
+  * @retval None
+  */
+void DMA_ClearFlag(uint32_t DMA_FLAG)
+{
+  /* Check the parameters */
+  assert_param(IS_DMA_CLEAR_FLAG(DMA_FLAG));
+  /* Calculate the used DMA */
+
+  if ((DMA_FLAG &amp; FLAG_Mask) != (uint32_t)RESET)
+  {
+    /* Clear the selected DMA flags */
+    DMA2-&gt;IFCR = DMA_FLAG;
+  }
+  else
+  {
+    /* Clear the selected DMA flags */
+    DMA1-&gt;IFCR = DMA_FLAG;
+  }
+}
+
+/**
+  * @brief  Checks whether the specified DMAy Channelx interrupt has occurred or not.
+  * @param  DMA_IT: specifies the DMA interrupt source to check. 
+  *   This parameter can be one of the following values:
+  *     @arg DMA1_IT_GL1: DMA1 Channel1 global interrupt.
+  *     @arg DMA1_IT_TC1: DMA1 Channel1 transfer complete interrupt.
+  *     @arg DMA1_IT_HT1: DMA1 Channel1 half transfer interrupt.
+  *     @arg DMA1_IT_TE1: DMA1 Channel1 transfer error interrupt.
+  *     @arg DMA1_IT_GL2: DMA1 Channel2 global interrupt.
+  *     @arg DMA1_IT_TC2: DMA1 Channel2 transfer complete interrupt.
+  *     @arg DMA1_IT_HT2: DMA1 Channel2 half transfer interrupt.
+  *     @arg DMA1_IT_TE2: DMA1 Channel2 transfer error interrupt.
+  *     @arg DMA1_IT_GL3: DMA1 Channel3 global interrupt.
+  *     @arg DMA1_IT_TC3: DMA1 Channel3 transfer complete interrupt.
+  *     @arg DMA1_IT_HT3: DMA1 Channel3 half transfer interrupt.
+  *     @arg DMA1_IT_TE3: DMA1 Channel3 transfer error interrupt.
+  *     @arg DMA1_IT_GL4: DMA1 Channel4 global interrupt.
+  *     @arg DMA1_IT_TC4: DMA1 Channel4 transfer complete interrupt.
+  *     @arg DMA1_IT_HT4: DMA1 Channel4 half transfer interrupt.
+  *     @arg DMA1_IT_TE4: DMA1 Channel4 transfer error interrupt.
+  *     @arg DMA1_IT_GL5: DMA1 Channel5 global interrupt.
+  *     @arg DMA1_IT_TC5: DMA1 Channel5 transfer complete interrupt.
+  *     @arg DMA1_IT_HT5: DMA1 Channel5 half transfer interrupt.
+  *     @arg DMA1_IT_TE5: DMA1 Channel5 transfer error interrupt.
+  *     @arg DMA1_IT_GL6: DMA1 Channel6 global interrupt.
+  *     @arg DMA1_IT_TC6: DMA1 Channel6 transfer complete interrupt.
+  *     @arg DMA1_IT_HT6: DMA1 Channel6 half transfer interrupt.
+  *     @arg DMA1_IT_TE6: DMA1 Channel6 transfer error interrupt.
+  *     @arg DMA1_IT_GL7: DMA1 Channel7 global interrupt.
+  *     @arg DMA1_IT_TC7: DMA1 Channel7 transfer complete interrupt.
+  *     @arg DMA1_IT_HT7: DMA1 Channel7 half transfer interrupt.
+  *     @arg DMA1_IT_TE7: DMA1 Channel7 transfer error interrupt.
+  *     @arg DMA2_IT_GL1: DMA2 Channel1 global interrupt.
+  *     @arg DMA2_IT_TC1: DMA2 Channel1 transfer complete interrupt.
+  *     @arg DMA2_IT_HT1: DMA2 Channel1 half transfer interrupt.
+  *     @arg DMA2_IT_TE1: DMA2 Channel1 transfer error interrupt.
+  *     @arg DMA2_IT_GL2: DMA2 Channel2 global interrupt.
+  *     @arg DMA2_IT_TC2: DMA2 Channel2 transfer complete interrupt.
+  *     @arg DMA2_IT_HT2: DMA2 Channel2 half transfer interrupt.
+  *     @arg DMA2_IT_TE2: DMA2 Channel2 transfer error interrupt.
+  *     @arg DMA2_IT_GL3: DMA2 Channel3 global interrupt.
+  *     @arg DMA2_IT_TC3: DMA2 Channel3 transfer complete interrupt.
+  *     @arg DMA2_IT_HT3: DMA2 Channel3 half transfer interrupt.
+  *     @arg DMA2_IT_TE3: DMA2 Channel3 transfer error interrupt.
+  *     @arg DMA2_IT_GL4: DMA2 Channel4 global interrupt.
+  *     @arg DMA2_IT_TC4: DMA2 Channel4 transfer complete interrupt.
+  *     @arg DMA2_IT_HT4: DMA2 Channel4 half transfer interrupt.
+  *     @arg DMA2_IT_TE4: DMA2 Channel4 transfer error interrupt.
+  *     @arg DMA2_IT_GL5: DMA2 Channel5 global interrupt.
+  *     @arg DMA2_IT_TC5: DMA2 Channel5 transfer complete interrupt.
+  *     @arg DMA2_IT_HT5: DMA2 Channel5 half transfer interrupt.
+  *     @arg DMA2_IT_TE5: DMA2 Channel5 transfer error interrupt.
+  * @retval The new state of DMA_IT (SET or RESET).
+  */
+ITStatus DMA_GetITStatus(uint32_t DMA_IT)
+{
+  ITStatus bitstatus = RESET;
+  uint32_t tmpreg = 0;
+  /* Check the parameters */
+  assert_param(IS_DMA_GET_IT(DMA_IT));
+
+  /* Calculate the used DMA */
+  if ((DMA_IT &amp; FLAG_Mask) != (uint32_t)RESET)
+  {
+    /* Get DMA2 ISR register value */
+    tmpreg = DMA2-&gt;ISR ;
+  }
+  else
+  {
+    /* Get DMA1 ISR register value */
+    tmpreg = DMA1-&gt;ISR ;
+  }
+
+  /* Check the status of the specified DMA interrupt */
+  if ((tmpreg &amp; DMA_IT) != (uint32_t)RESET)
+  {
+    /* DMA_IT is set */
+    bitstatus = SET;
+  }
+  else
+  {
+    /* DMA_IT is reset */
+    bitstatus = RESET;
+  }
+  /* Return the DMA_IT status */
+  return  bitstatus;
+}
+
+/**
+  * @brief  Clears the DMAy Channelx&#146;s interrupt pending bits.
+  * @param  DMA_IT: specifies the DMA interrupt pending bit to clear.
+  *   This parameter can be any combination (for the same DMA) of the following values:
+  *     @arg DMA1_IT_GL1: DMA1 Channel1 global interrupt.
+  *     @arg DMA1_IT_TC1: DMA1 Channel1 transfer complete interrupt.
+  *     @arg DMA1_IT_HT1: DMA1 Channel1 half transfer interrupt.
+  *     @arg DMA1_IT_TE1: DMA1 Channel1 transfer error interrupt.
+  *     @arg DMA1_IT_GL2: DMA1 Channel2 global interrupt.
+  *     @arg DMA1_IT_TC2: DMA1 Channel2 transfer complete interrupt.
+  *     @arg DMA1_IT_HT2: DMA1 Channel2 half transfer interrupt.
+  *     @arg DMA1_IT_TE2: DMA1 Channel2 transfer error interrupt.
+  *     @arg DMA1_IT_GL3: DMA1 Channel3 global interrupt.
+  *     @arg DMA1_IT_TC3: DMA1 Channel3 transfer complete interrupt.
+  *     @arg DMA1_IT_HT3: DMA1 Channel3 half transfer interrupt.
+  *     @arg DMA1_IT_TE3: DMA1 Channel3 transfer error interrupt.
+  *     @arg DMA1_IT_GL4: DMA1 Channel4 global interrupt.
+  *     @arg DMA1_IT_TC4: DMA1 Channel4 transfer complete interrupt.
+  *     @arg DMA1_IT_HT4: DMA1 Channel4 half transfer interrupt.
+  *     @arg DMA1_IT_TE4: DMA1 Channel4 transfer error interrupt.
+  *     @arg DMA1_IT_GL5: DMA1 Channel5 global interrupt.
+  *     @arg DMA1_IT_TC5: DMA1 Channel5 transfer complete interrupt.
+  *     @arg DMA1_IT_HT5: DMA1 Channel5 half transfer interrupt.
+  *     @arg DMA1_IT_TE5: DMA1 Channel5 transfer error interrupt.
+  *     @arg DMA1_IT_GL6: DMA1 Channel6 global interrupt.
+  *     @arg DMA1_IT_TC6: DMA1 Channel6 transfer complete interrupt.
+  *     @arg DMA1_IT_HT6: DMA1 Channel6 half transfer interrupt.
+  *     @arg DMA1_IT_TE6: DMA1 Channel6 transfer error interrupt.
+  *     @arg DMA1_IT_GL7: DMA1 Channel7 global interrupt.
+  *     @arg DMA1_IT_TC7: DMA1 Channel7 transfer complete interrupt.
+  *     @arg DMA1_IT_HT7: DMA1 Channel7 half transfer interrupt.
+  *     @arg DMA1_IT_TE7: DMA1 Channel7 transfer error interrupt.
+  *     @arg DMA2_IT_GL1: DMA2 Channel1 global interrupt.
+  *     @arg DMA2_IT_TC1: DMA2 Channel1 transfer complete interrupt.
+  *     @arg DMA2_IT_HT1: DMA2 Channel1 half transfer interrupt.
+  *     @arg DMA2_IT_TE1: DMA2 Channel1 transfer error interrupt.
+  *     @arg DMA2_IT_GL2: DMA2 Channel2 global interrupt.
+  *     @arg DMA2_IT_TC2: DMA2 Channel2 transfer complete interrupt.
+  *     @arg DMA2_IT_HT2: DMA2 Channel2 half transfer interrupt.
+  *     @arg DMA2_IT_TE2: DMA2 Channel2 transfer error interrupt.
+  *     @arg DMA2_IT_GL3: DMA2 Channel3 global interrupt.
+  *     @arg DMA2_IT_TC3: DMA2 Channel3 transfer complete interrupt.
+  *     @arg DMA2_IT_HT3: DMA2 Channel3 half transfer interrupt.
+  *     @arg DMA2_IT_TE3: DMA2 Channel3 transfer error interrupt.
+  *     @arg DMA2_IT_GL4: DMA2 Channel4 global interrupt.
+  *     @arg DMA2_IT_TC4: DMA2 Channel4 transfer complete interrupt.
+  *     @arg DMA2_IT_HT4: DMA2 Channel4 half transfer interrupt.
+  *     @arg DMA2_IT_TE4: DMA2 Channel4 transfer error interrupt.
+  *     @arg DMA2_IT_GL5: DMA2 Channel5 global interrupt.
+  *     @arg DMA2_IT_TC5: DMA2 Channel5 transfer complete interrupt.
+  *     @arg DMA2_IT_HT5: DMA2 Channel5 half transfer interrupt.
+  *     @arg DMA2_IT_TE5: DMA2 Channel5 transfer error interrupt.
+  * @retval None
+  */
+void DMA_ClearITPendingBit(uint32_t DMA_IT)
+{
+  /* Check the parameters */
+  assert_param(IS_DMA_CLEAR_IT(DMA_IT));
+
+  /* Calculate the used DMA */
+  if ((DMA_IT &amp; FLAG_Mask) != (uint32_t)RESET)
+  {
+    /* Clear the selected DMA interrupt pending bits */
+    DMA2-&gt;IFCR = DMA_IT;
+  }
+  else
+  {
+    /* Clear the selected DMA interrupt pending bits */
+    DMA1-&gt;IFCR = DMA_IT;
+  }
+}
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2009 STMicroelectronics *****END OF FILE****/

Added: trunk/src/platform/stm32/FWLib/library/src/stm32f10x_dma.o
===================================================================
--- trunk/src/platform/stm32/FWLib/library/src/stm32f10x_dma.o	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/src/stm32f10x_dma.o	2009-07-08 23:39:34 UTC (rev 354)
@@ -0,0 +1,7 @@
+ELF
+ihCJi$&#244;&#254;DC&#138;i$&#240;&#240;C&#202;iCJjC&#138;jC#C`&#203;hC`h&#131;`Kh&#195;`&#189;
+M	
+
+
+
+
\ No newline at end of file

Modified: trunk/src/platform/stm32/FWLib/library/src/stm32f10x_exti.c
===================================================================
--- trunk/src/platform/stm32/FWLib/library/src/stm32f10x_exti.c	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/src/stm32f10x_exti.c	2009-07-08 23:39:34 UTC (rev 354)
@@ -1,219 +1,268 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_exti.c
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file provides all the EXTI firmware functions.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
-
-/* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_exti.h&quot;
-
-/* Private typedef -----------------------------------------------------------*/
-/* Private define ------------------------------------------------------------*/
-#define EXTI_LineNone    ((u32)0x00000)  /* No interrupt selected */
-
-/* Private macro -------------------------------------------------------------*/
-/* Private variables ---------------------------------------------------------*/
-/* Private function prototypes -----------------------------------------------*/
-/* Private functions ---------------------------------------------------------*/
-
-/*******************************************************************************
-* Function Name  : EXTI_DeInit
-* Description    : Deinitializes the EXTI peripheral registers to their default 
-*                  reset values.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void EXTI_DeInit(void)
-{
-  EXTI-&gt;IMR = 0x00000000;
-  EXTI-&gt;EMR = 0x00000000;
-  EXTI-&gt;RTSR = 0x00000000; 
-  EXTI-&gt;FTSR = 0x00000000; 
-  EXTI-&gt;PR = 0x0007FFFF;
-}
-
-/*******************************************************************************
-* Function Name  : EXTI_Init
-* Description    : Initializes the EXTI peripheral according to the specified
-*                  parameters in the EXTI_InitStruct.
-* Input          : - EXTI_InitStruct: pointer to a EXTI_InitTypeDef structure
-*                    that contains the configuration information for the EXTI
-*                    peripheral.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void EXTI_Init(EXTI_InitTypeDef* EXTI_InitStruct)
-{
-  /* Check the parameters */
-  assert_param(IS_EXTI_MODE(EXTI_InitStruct-&gt;EXTI_Mode));
-  assert_param(IS_EXTI_TRIGGER(EXTI_InitStruct-&gt;EXTI_Trigger));
-  assert_param(IS_EXTI_LINE(EXTI_InitStruct-&gt;EXTI_Line));  
-  assert_param(IS_FUNCTIONAL_STATE(EXTI_InitStruct-&gt;EXTI_LineCmd));
-     
-  if (EXTI_InitStruct-&gt;EXTI_LineCmd != DISABLE)
-  {
-    /* Clear EXTI line configuration */
-    EXTI-&gt;IMR &amp;= ~EXTI_InitStruct-&gt;EXTI_Line;
-    EXTI-&gt;EMR &amp;= ~EXTI_InitStruct-&gt;EXTI_Line;
-    
-    *(vu32 *)(EXTI_BASE + (u32)EXTI_InitStruct-&gt;EXTI_Mode)|= EXTI_InitStruct-&gt;EXTI_Line;
-
-    /* Clear Rising Falling edge configuration */
-    EXTI-&gt;RTSR &amp;= ~EXTI_InitStruct-&gt;EXTI_Line;
-    EXTI-&gt;FTSR &amp;= ~EXTI_InitStruct-&gt;EXTI_Line;
-    
-    /* Select the trigger for the selected external interrupts */
-    if (EXTI_InitStruct-&gt;EXTI_Trigger == EXTI_Trigger_Rising_Falling)
-    {
-      /* Rising Falling edge */
-      EXTI-&gt;RTSR |= EXTI_InitStruct-&gt;EXTI_Line;
-      EXTI-&gt;FTSR |= EXTI_InitStruct-&gt;EXTI_Line;
-    }
-    else
-    {
-      *(vu32 *)(EXTI_BASE + (u32)EXTI_InitStruct-&gt;EXTI_Trigger)|= EXTI_InitStruct-&gt;EXTI_Line;
-    }
-  }
-  else
-  {
-    /* Disable the selected external lines */
-    *(vu32 *)(EXTI_BASE + (u32)EXTI_InitStruct-&gt;EXTI_Mode)&amp;= ~EXTI_InitStruct-&gt;EXTI_Line;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : EXTI_StructInit
-* Description    : Fills each EXTI_InitStruct member with its reset value.
-* Input          : - EXTI_InitStruct: pointer to a EXTI_InitTypeDef structure
-*                    which will be initialized.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void EXTI_StructInit(EXTI_InitTypeDef* EXTI_InitStruct)
-{
-  EXTI_InitStruct-&gt;EXTI_Line = EXTI_LineNone;
-  EXTI_InitStruct-&gt;EXTI_Mode = EXTI_Mode_Interrupt;
-  EXTI_InitStruct-&gt;EXTI_Trigger = EXTI_Trigger_Falling;
-  EXTI_InitStruct-&gt;EXTI_LineCmd = DISABLE;
-}
-
-/*******************************************************************************
-* Function Name  : EXTI_GenerateSWInterrupt
-* Description    : Generates a Software interrupt.
-* Input          : - EXTI_Line: specifies the EXTI lines to be enabled or
-*                    disabled.
-*                    This parameter can be any combination of EXTI_Linex where 
-*                    x can be (0..18).
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void EXTI_GenerateSWInterrupt(u32 EXTI_Line)
-{
-  /* Check the parameters */
-  assert_param(IS_EXTI_LINE(EXTI_Line));
-  
-  EXTI-&gt;SWIER |= EXTI_Line;
-}
-
-/*******************************************************************************
-* Function Name  : EXTI_GetFlagStatus
-* Description    : Checks whether the specified EXTI line flag is set or not.
-* Input          : - EXTI_Line: specifies the EXTI line flag to check.
-*                    This parameter can be:
-*                       - EXTI_Linex: External interrupt line x where x(0..18)
-* Output         : None
-* Return         : The new state of EXTI_Line (SET or RESET).
-*******************************************************************************/
-FlagStatus EXTI_GetFlagStatus(u32 EXTI_Line)
-{
-  FlagStatus bitstatus = RESET;
-
-  /* Check the parameters */
-  assert_param(IS_GET_EXTI_LINE(EXTI_Line));
-  
-  if ((EXTI-&gt;PR &amp; EXTI_Line) != (u32)RESET)
-  {
-    bitstatus = SET;
-  }
-  else
-  {
-    bitstatus = RESET;
-  }
-  return bitstatus;
-}
-
-/*******************************************************************************
-* Function Name  : EXTI_ClearFlag
-* Description    : Clears the EXTI's line pending flags.
-* Input          : - EXTI_Line: specifies the EXTI lines flags to clear.
-*                    This parameter can be any combination of EXTI_Linex where 
-*                    x can be (0..18).
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void EXTI_ClearFlag(u32 EXTI_Line)
-{
-  /* Check the parameters */
-  assert_param(IS_EXTI_LINE(EXTI_Line));
-  
-  EXTI-&gt;PR = EXTI_Line;
-}
-
-/*******************************************************************************
-* Function Name  : EXTI_GetITStatus
-* Description    : Checks whether the specified EXTI line is asserted or not.
-* Input          : - EXTI_Line: specifies the EXTI line to check.
-*                    This parameter can be:
-*                       - EXTI_Linex: External interrupt line x where x(0..18)
-* Output         : None
-* Return         : The new state of EXTI_Line (SET or RESET).
-*******************************************************************************/
-ITStatus EXTI_GetITStatus(u32 EXTI_Line)
-{
-  ITStatus bitstatus = RESET;
-  u32 enablestatus = 0;
-
-  /* Check the parameters */
-  assert_param(IS_GET_EXTI_LINE(EXTI_Line));
-  
-  enablestatus =  EXTI-&gt;IMR &amp; EXTI_Line;
-
-  if (((EXTI-&gt;PR &amp; EXTI_Line) != (u32)RESET) &amp;&amp; (enablestatus != (u32)RESET))
-  {
-    bitstatus = SET;
-  }
-  else
-  {
-    bitstatus = RESET;
-  }
-  return bitstatus;
-}
-
-/*******************************************************************************
-* Function Name  : EXTI_ClearITPendingBit
-* Description    : Clears the EXTI's line pending bits.
-* Input          : - EXTI_Line: specifies the EXTI lines to clear.
-*                    This parameter can be any combination of EXTI_Linex where 
-*                    x can be (0..18).
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void EXTI_ClearITPendingBit(u32 EXTI_Line)
-{
-  /* Check the parameters */
-  assert_param(IS_EXTI_LINE(EXTI_Line));
-  
-  EXTI-&gt;PR = EXTI_Line;
-}
-
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
+/**
+  ******************************************************************************
+  * @file    stm32f10x_exti.c
+  * @author  MCD Application Team
+  * @version V3.1.0
+  * @date    06/19/2009
+  * @brief   This file provides all the EXTI firmware functions.
+  ******************************************************************************
+  * @copy
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * &lt;h2&gt;&lt;center&gt;&copy; COPYRIGHT 2009 STMicroelectronics&lt;/center&gt;&lt;/h2&gt;
+  */ 
+
+/* Includes ------------------------------------------------------------------*/
+#include &quot;stm32f10x_exti.h&quot;
+
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup EXTI 
+  * @brief EXTI driver modules
+  * @{
+  */
+
+/** @defgroup EXTI_Private_TypesDefinitions
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup EXTI_Private_Defines
+  * @{
+  */
+
+#define EXTI_LineNone    ((uint32_t)0x00000)  /* No interrupt selected */
+
+/**
+  * @}
+  */
+
+/** @defgroup EXTI_Private_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup EXTI_Private_Variables
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup EXTI_Private_FunctionPrototypes
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup EXTI_Private_Functions
+  * @{
+  */
+
+/**
+  * @brief  Deinitializes the EXTI peripheral registers to their default reset values.
+  * @param  None
+  * @retval None
+  */
+void EXTI_DeInit(void)
+{
+  EXTI-&gt;IMR = 0x00000000;
+  EXTI-&gt;EMR = 0x00000000;
+  EXTI-&gt;RTSR = 0x00000000; 
+  EXTI-&gt;FTSR = 0x00000000; 
+  EXTI-&gt;PR = 0x000FFFFF;
+}
+
+/**
+  * @brief  Initializes the EXTI peripheral according to the specified
+  *   parameters in the EXTI_InitStruct.
+  * @param  EXTI_InitStruct: pointer to a EXTI_InitTypeDef structure
+  *   that contains the configuration information for the EXTI peripheral.
+  * @retval None
+  */
+void EXTI_Init(EXTI_InitTypeDef* EXTI_InitStruct)
+{
+  uint32_t tmp = 0;
+
+  /* Check the parameters */
+  assert_param(IS_EXTI_MODE(EXTI_InitStruct-&gt;EXTI_Mode));
+  assert_param(IS_EXTI_TRIGGER(EXTI_InitStruct-&gt;EXTI_Trigger));
+  assert_param(IS_EXTI_LINE(EXTI_InitStruct-&gt;EXTI_Line));  
+  assert_param(IS_FUNCTIONAL_STATE(EXTI_InitStruct-&gt;EXTI_LineCmd));
+
+  tmp = (uint32_t)EXTI_BASE;
+     
+  if (EXTI_InitStruct-&gt;EXTI_LineCmd != DISABLE)
+  {
+    /* Clear EXTI line configuration */
+    EXTI-&gt;IMR &amp;= ~EXTI_InitStruct-&gt;EXTI_Line;
+    EXTI-&gt;EMR &amp;= ~EXTI_InitStruct-&gt;EXTI_Line;
+    
+    tmp += EXTI_InitStruct-&gt;EXTI_Mode;
+
+    *(__IO uint32_t *) tmp |= EXTI_InitStruct-&gt;EXTI_Line;
+
+    /* Clear Rising Falling edge configuration */
+    EXTI-&gt;RTSR &amp;= ~EXTI_InitStruct-&gt;EXTI_Line;
+    EXTI-&gt;FTSR &amp;= ~EXTI_InitStruct-&gt;EXTI_Line;
+    
+    /* Select the trigger for the selected external interrupts */
+    if (EXTI_InitStruct-&gt;EXTI_Trigger == EXTI_Trigger_Rising_Falling)
+    {
+      /* Rising Falling edge */
+      EXTI-&gt;RTSR |= EXTI_InitStruct-&gt;EXTI_Line;
+      EXTI-&gt;FTSR |= EXTI_InitStruct-&gt;EXTI_Line;
+    }
+    else
+    {
+      tmp = (uint32_t)EXTI_BASE;
+      tmp += EXTI_InitStruct-&gt;EXTI_Trigger;
+
+      *(__IO uint32_t *) tmp |= EXTI_InitStruct-&gt;EXTI_Line;
+    }
+  }
+  else
+  {
+    tmp += EXTI_InitStruct-&gt;EXTI_Mode;
+
+    /* Disable the selected external lines */
+    *(__IO uint32_t *) tmp &amp;= ~EXTI_InitStruct-&gt;EXTI_Line;
+  }
+}
+
+/**
+  * @brief  Fills each EXTI_InitStruct member with its reset value.
+  * @param  EXTI_InitStruct: pointer to a EXTI_InitTypeDef structure which will
+  *   be initialized.
+  * @retval None
+  */
+void EXTI_StructInit(EXTI_InitTypeDef* EXTI_InitStruct)
+{
+  EXTI_InitStruct-&gt;EXTI_Line = EXTI_LineNone;
+  EXTI_InitStruct-&gt;EXTI_Mode = EXTI_Mode_Interrupt;
+  EXTI_InitStruct-&gt;EXTI_Trigger = EXTI_Trigger_Falling;
+  EXTI_InitStruct-&gt;EXTI_LineCmd = DISABLE;
+}
+
+/**
+  * @brief  Generates a Software interrupt.
+  * @param  EXTI_Line: specifies the EXTI lines to be enabled or disabled.
+  *   This parameter can be any combination of EXTI_Linex where x can be (0..19).
+  * @retval None
+  */
+void EXTI_GenerateSWInterrupt(uint32_t EXTI_Line)
+{
+  /* Check the parameters */
+  assert_param(IS_EXTI_LINE(EXTI_Line));
+  
+  EXTI-&gt;SWIER |= EXTI_Line;
+}
+
+/**
+  * @brief  Checks whether the specified EXTI line flag is set or not.
+  * @param  EXTI_Line: specifies the EXTI line flag to check.
+  *   This parameter can be:
+  *     @arg EXTI_Linex: External interrupt line x where x(0..19)
+  * @retval The new state of EXTI_Line (SET or RESET).
+  */
+FlagStatus EXTI_GetFlagStatus(uint32_t EXTI_Line)
+{
+  FlagStatus bitstatus = RESET;
+  /* Check the parameters */
+  assert_param(IS_GET_EXTI_LINE(EXTI_Line));
+  
+  if ((EXTI-&gt;PR &amp; EXTI_Line) != (uint32_t)RESET)
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  return bitstatus;
+}
+
+/**
+  * @brief  Clears the EXTI&#146;s line pending flags.
+  * @param  EXTI_Line: specifies the EXTI lines flags to clear.
+  *   This parameter can be any combination of EXTI_Linex where x can be (0..19).
+  * @retval None
+  */
+void EXTI_ClearFlag(uint32_t EXTI_Line)
+{
+  /* Check the parameters */
+  assert_param(IS_EXTI_LINE(EXTI_Line));
+  
+  EXTI-&gt;PR = EXTI_Line;
+}
+
+/**
+  * @brief  Checks whether the specified EXTI line is asserted or not.
+  * @param  EXTI_Line: specifies the EXTI line to check.
+  *   This parameter can be:
+  *     @arg EXTI_Linex: External interrupt line x where x(0..19)
+  * @retval The new state of EXTI_Line (SET or RESET).
+  */
+ITStatus EXTI_GetITStatus(uint32_t EXTI_Line)
+{
+  ITStatus bitstatus = RESET;
+  uint32_t enablestatus = 0;
+  /* Check the parameters */
+  assert_param(IS_GET_EXTI_LINE(EXTI_Line));
+  
+  enablestatus =  EXTI-&gt;IMR &amp; EXTI_Line;
+  if (((EXTI-&gt;PR &amp; EXTI_Line) != (uint32_t)RESET) &amp;&amp; (enablestatus != (uint32_t)RESET))
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  return bitstatus;
+}
+
+/**
+  * @brief  Clears the EXTI&#146;s line pending bits.
+  * @param  EXTI_Line: specifies the EXTI lines to clear.
+  *   This parameter can be any combination of EXTI_Linex where x can be (0..19).
+  * @retval None
+  */
+void EXTI_ClearITPendingBit(uint32_t EXTI_Line)
+{
+  /* Check the parameters */
+  assert_param(IS_EXTI_LINE(EXTI_Line));
+  
+  EXTI-&gt;PR = EXTI_Line;
+}
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2009 STMicroelectronics *****END OF FILE****/

Added: trunk/src/platform/stm32/FWLib/library/src/stm32f10x_exti.o
===================================================================
--- trunk/src/platform/stm32/FWLib/library/src/stm32f10x_exti.o	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/src/stm32f10x_exti.o	2009-07-08 23:39:34 UTC (rev 354)
@@ -0,0 +1,6 @@
+ELF
+M	
+
+
+
+
\ No newline at end of file

Modified: trunk/src/platform/stm32/FWLib/library/src/stm32f10x_flash.c
===================================================================
--- trunk/src/platform/stm32/FWLib/library/src/stm32f10x_flash.c	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/src/stm32f10x_flash.c	2009-07-08 23:39:34 UTC (rev 354)
@@ -1,911 +1,874 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_flash.c
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file provides all the FLASH firmware functions.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
-
-/* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_flash.h&quot;
-
-/* Private typedef -----------------------------------------------------------*/
-/* Private define ------------------------------------------------------------*/
-/* Flash Access Control Register bits */
-#define ACR_LATENCY_Mask         ((u32)0x00000038)
-#define ACR_HLFCYA_Mask          ((u32)0xFFFFFFF7)
-#define ACR_PRFTBE_Mask          ((u32)0xFFFFFFEF)
-
-#ifdef _FLASH_PROG
-/* Flash Access Control Register bits */
-#define ACR_PRFTBS_Mask          ((u32)0x00000020) 
-
-/* Flash Control Register bits */
-#define CR_PG_Set                ((u32)0x00000001)
-#define CR_PG_Reset              ((u32)0x00001FFE) 
-
-#define CR_PER_Set               ((u32)0x00000002)
-#define CR_PER_Reset             ((u32)0x00001FFD)
-
-#define CR_MER_Set               ((u32)0x00000004)
-#define CR_MER_Reset             ((u32)0x00001FFB)
-
-#define CR_OPTPG_Set             ((u32)0x00000010)
-#define CR_OPTPG_Reset           ((u32)0x00001FEF)
-
-#define CR_OPTER_Set             ((u32)0x00000020)
-#define CR_OPTER_Reset           ((u32)0x00001FDF)
-
-#define CR_STRT_Set              ((u32)0x00000040)
-							 
-#define CR_LOCK_Set              ((u32)0x00000080)
-
-/* FLASH Mask */
-#define RDPRT_Mask               ((u32)0x00000002)
-#define WRP0_Mask                ((u32)0x000000FF)
-#define WRP1_Mask                ((u32)0x0000FF00)
-#define WRP2_Mask                ((u32)0x00FF0000)
-#define WRP3_Mask                ((u32)0xFF000000)
-
-/* FLASH Keys */
-#define RDP_Key                  ((u16)0x00A5)
-#define FLASH_KEY1               ((u32)0x45670123)
-#define FLASH_KEY2               ((u32)0xCDEF89AB)
-
-/* Delay definition */   
-#define EraseTimeout             ((u32)0x00000FFF)
-#define ProgramTimeout           ((u32)0x0000000F)
-#endif
-
-/* Private macro -------------------------------------------------------------*/
-/* Private variables ---------------------------------------------------------*/
-/* Private function prototypes -----------------------------------------------*/
-#ifdef _FLASH_PROG
-static void delay(void);
-#endif
-
-/* Private functions ---------------------------------------------------------*/
-/*******************************************************************************
-* Function Name  : FLASH_SetLatency
-* Description    : Sets the code latency value.
-* Input          : - FLASH_Latency: specifies the FLASH Latency value.
-*                    This parameter can be one of the following values:
-*                       - FLASH_Latency_0: FLASH Zero Latency cycle
-*                       - FLASH_Latency_1: FLASH One Latency cycle
-*                       - FLASH_Latency_2: FLASH Two Latency cycles
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void FLASH_SetLatency(u32 FLASH_Latency)
-{
-  /* Check the parameters */
-  assert_param(IS_FLASH_LATENCY(FLASH_Latency));
-  
-  /* Sets the Latency value */
-  FLASH-&gt;ACR &amp;= ACR_LATENCY_Mask;
-  FLASH-&gt;ACR |= FLASH_Latency;
-}
-
-/*******************************************************************************
-* Function Name  : FLASH_HalfCycleAccessCmd
-* Description    : Enables or disables the Half cycle flash access.
-* Input          : - FLASH_HalfCycle: specifies the FLASH Half cycle Access mode.
-*                    This parameter can be one of the following values:
-*                       - FLASH_HalfCycleAccess_Enable: FLASH Half Cycle Enable
-*                       - FLASH_HalfCycleAccess_Disable: FLASH Half Cycle Disable
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void FLASH_HalfCycleAccessCmd(u32 FLASH_HalfCycleAccess)
-{
-  /* Check the parameters */
-  assert_param(IS_FLASH_HALFCYCLEACCESS_STATE(FLASH_HalfCycleAccess));
-  
-  /* Enable or disable the Half cycle access */
-  FLASH-&gt;ACR &amp;= ACR_HLFCYA_Mask;
-  FLASH-&gt;ACR |= FLASH_HalfCycleAccess;
-}
-
-/*******************************************************************************
-* Function Name  : FLASH_PrefetchBufferCmd
-* Description    : Enables or disables the Prefetch Buffer.
-* Input          : - FLASH_PrefetchBuffer: specifies the Prefetch buffer status.
-*                    This parameter can be one of the following values:
-*                       - FLASH_PrefetchBuffer_Enable: FLASH Prefetch Buffer Enable
-*                       - FLASH_PrefetchBuffer_Disable: FLASH Prefetch Buffer Disable
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void FLASH_PrefetchBufferCmd(u32 FLASH_PrefetchBuffer)
-{
-  /* Check the parameters */
-  assert_param(IS_FLASH_PREFETCHBUFFER_STATE(FLASH_PrefetchBuffer));
-  
-  /* Enable or disable the Prefetch Buffer */
-  FLASH-&gt;ACR &amp;= ACR_PRFTBE_Mask;
-  FLASH-&gt;ACR |= FLASH_PrefetchBuffer;
-}
-
-#ifdef _FLASH_PROG
-/*******************************************************************************
-* Function Name  : FLASH_Unlock
-* Description    : Unlocks the FLASH Program Erase Controller.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void FLASH_Unlock(void)
-{
-  /* Authorize the FPEC Access */
-  FLASH-&gt;KEYR = FLASH_KEY1;
-  FLASH-&gt;KEYR = FLASH_KEY2;
-}
-
-/*******************************************************************************
-* Function Name  : FLASH_Lock
-* Description    : Locks the FLASH Program Erase Controller.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void FLASH_Lock(void)
-{
-  /* Set the Lock Bit to lock the FPEC and the FCR */
-  FLASH-&gt;CR |= CR_LOCK_Set;
-}
-
-/*******************************************************************************
-* Function Name  : FLASH_ErasePage
-* Description    : Erases a specified FLASH page.
-* Input          : - Page_Address: The page address to be erased.
-* Output         : None
-* Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
-*                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
-*                  FLASH_TIMEOUT.
-*******************************************************************************/
-FLASH_Status FLASH_ErasePage(u32 Page_Address)
-{
-  FLASH_Status status = FLASH_COMPLETE;
-
-  /* Check the parameters */
-  assert_param(IS_FLASH_ADDRESS(Page_Address));
-
-  /* Wait for last operation to be completed */
-  status = FLASH_WaitForLastOperation(EraseTimeout);
-  
-  if(status == FLASH_COMPLETE)
-  { 
-    /* if the previous operation is completed, proceed to erase the page */
-    FLASH-&gt;CR|= CR_PER_Set;
-    FLASH-&gt;AR = Page_Address; 
-    FLASH-&gt;CR|= CR_STRT_Set;
-    
-    /* Wait for last operation to be completed */
-    status = FLASH_WaitForLastOperation(EraseTimeout);
-
-    if(status != FLASH_BUSY)
-    {
-      /* if the erase operation is completed, disable the PER Bit */
-      FLASH-&gt;CR &amp;= CR_PER_Reset;
-    }
-  }
-  /* Return the Erase Status */
-  return status;
-}
-
-/*******************************************************************************
-* Function Name  : FLASH_EraseAllPages
-* Description    : Erases all FLASH pages.
-* Input          : None
-* Output         : None
-* Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
-*                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
-*                  FLASH_TIMEOUT.
-*******************************************************************************/
-FLASH_Status FLASH_EraseAllPages(void)
-{
-  FLASH_Status status = FLASH_COMPLETE;
-
-  /* Wait for last operation to be completed */
-  status = FLASH_WaitForLastOperation(EraseTimeout);
-  
-  if(status == FLASH_COMPLETE)
-  {
-    /* if the previous operation is completed, proceed to erase all pages */
-     FLASH-&gt;CR |= CR_MER_Set;
-     FLASH-&gt;CR |= CR_STRT_Set;
-    
-    /* Wait for last operation to be completed */
-    status = FLASH_WaitForLastOperation(EraseTimeout);
-
-    if(status != FLASH_BUSY)
-    {
-      /* if the erase operation is completed, disable the MER Bit */
-      FLASH-&gt;CR &amp;= CR_MER_Reset;
-    }
-  }	   
-  /* Return the Erase Status */
-  return status;
-}
-
-/*******************************************************************************
-* Function Name  : FLASH_EraseOptionBytes
-* Description    : Erases the FLASH option bytes.
-* Input          : None
-* Output         : None
-* Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
-*                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
-*                  FLASH_TIMEOUT.
-*******************************************************************************/
-FLASH_Status FLASH_EraseOptionBytes(void)
-{
-  FLASH_Status status = FLASH_COMPLETE;
-  
-  /* Wait for last operation to be completed */
-  status = FLASH_WaitForLastOperation(EraseTimeout);
-
-  if(status == FLASH_COMPLETE)
-  {
-    /* Authorize the small information block programming */
-    FLASH-&gt;OPTKEYR = FLASH_KEY1;
-    FLASH-&gt;OPTKEYR = FLASH_KEY2;
-    
-    /* if the previous operation is completed, proceed to erase the option bytes */
-    FLASH-&gt;CR |= CR_OPTER_Set;
-    FLASH-&gt;CR |= CR_STRT_Set;
-
-    /* Wait for last operation to be completed */
-    status = FLASH_WaitForLastOperation(EraseTimeout);
-    
-    if(status == FLASH_COMPLETE)
-    {
-      /* if the erase operation is completed, disable the OPTER Bit */
-      FLASH-&gt;CR &amp;= CR_OPTER_Reset;
-       
-      /* Enable the Option Bytes Programming operation */
-      FLASH-&gt;CR |= CR_OPTPG_Set;
-
-      /* Enable the readout access */
-      OB-&gt;RDP= RDP_Key; 
-
-      /* Wait for last operation to be completed */
-      status = FLASH_WaitForLastOperation(ProgramTimeout);
- 
-      if(status != FLASH_BUSY)
-      {
-        /* if the program operation is completed, disable the OPTPG Bit */
-        FLASH-&gt;CR &amp;= CR_OPTPG_Reset;
-      }
-    }
-    else
-    {
-      if (status != FLASH_BUSY)
-      {
-        /* Disable the OPTPG Bit */
-        FLASH-&gt;CR &amp;= CR_OPTPG_Reset;
-      }
-    }  
-  }
-  /* Return the erase status */
-  return status;
-}
-
-/*******************************************************************************
-* Function Name  : FLASH_ProgramWord
-* Description    : Programs a word at a specified address.
-* Input          : - Address: specifies the address to be programmed.
-*                  - Data: specifies the data to be programmed.
-* Output         : None
-* Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
-*                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
-*                  FLASH_TIMEOUT. 
-*******************************************************************************/
-FLASH_Status FLASH_ProgramWord(u32 Address, u32 Data)
-{
-  FLASH_Status status = FLASH_COMPLETE;
-
-  /* Check the parameters */
-  assert_param(IS_FLASH_ADDRESS(Address));
-
-  /* Wait for last operation to be completed */
-  status = FLASH_WaitForLastOperation(ProgramTimeout);
-  
-  if(status == FLASH_COMPLETE)
-  {
-    /* if the previous operation is completed, proceed to program the new first 
-    half word */
-    FLASH-&gt;CR |= CR_PG_Set;
-  
-    *(vu16*)Address = (u16)Data;
-
-    /* Wait for last operation to be completed */
-    status = FLASH_WaitForLastOperation(ProgramTimeout);
- 
-    if(status == FLASH_COMPLETE)
-    {
-      /* if the previous operation is completed, proceed to program the new second 
-      half word */
-      *(vu16*)(Address + 2) = Data &gt;&gt; 16;
-    
-      /* Wait for last operation to be completed */
-      status = FLASH_WaitForLastOperation(ProgramTimeout);
-        
-      if(status != FLASH_BUSY)
-      {
-        /* Disable the PG Bit */
-        FLASH-&gt;CR &amp;= CR_PG_Reset;
-      }
-    }
-    else
-    {
-      if (status != FLASH_BUSY)
-      {
-        /* Disable the PG Bit */
-        FLASH-&gt;CR &amp;= CR_PG_Reset;
-      }
-     }
-  }
-  /* Return the Program Status */
-  return status;
-}
-
-/*******************************************************************************
-* Function Name  : FLASH_ProgramHalfWord
-* Description    : Programs a half word at a specified address.
-* Input          : - Address: specifies the address to be programmed.
-*                  - Data: specifies the data to be programmed.
-* Output         : None
-* Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
-*                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
-*                  FLASH_TIMEOUT. 
-*******************************************************************************/
-FLASH_Status FLASH_ProgramHalfWord(u32 Address, u16 Data)
-{
-  FLASH_Status status = FLASH_COMPLETE;
-
-  /* Check the parameters */
-  assert_param(IS_FLASH_ADDRESS(Address));
-
-  /* Wait for last operation to be completed */
-  status = FLASH_WaitForLastOperation(ProgramTimeout);
-  
-  if(status == FLASH_COMPLETE)
-  {
-    /* if the previous operation is completed, proceed to program the new data */
-    FLASH-&gt;CR |= CR_PG_Set;
-  
-    *(vu16*)Address = Data;
-    /* Wait for last operation to be completed */
-    status = FLASH_WaitForLastOperation(ProgramTimeout);
-
-    if(status != FLASH_BUSY)
-    {
-      /* if the program operation is completed, disable the PG Bit */
-      FLASH-&gt;CR &amp;= CR_PG_Reset;
-    }
-  } 
-  /* Return the Program Status */
-  return status;
-}
-
-/*******************************************************************************
-* Function Name  : FLASH_ProgramOptionByteData
-* Description    : Programs a half word at a specified Option Byte Data address.
-* Input          : - Address: specifies the address to be programmed.
-*                    This parameter can be 0x1FFFF804 or 0x1FFFF806. 
-*                  - Data: specifies the data to be programmed.
-* Output         : None
-* Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
-*                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
-*                  FLASH_TIMEOUT. 
-*******************************************************************************/
-FLASH_Status FLASH_ProgramOptionByteData(u32 Address, u8 Data)
-{
-  FLASH_Status status = FLASH_COMPLETE;
-
-  /* Check the parameters */
-  assert_param(IS_OB_DATA_ADDRESS(Address));
-
-  status = FLASH_WaitForLastOperation(ProgramTimeout);
-
-  if(status == FLASH_COMPLETE)
-  {
-    /* Authorize the small information block programming */
-    FLASH-&gt;OPTKEYR = FLASH_KEY1;
-    FLASH-&gt;OPTKEYR = FLASH_KEY2;
-
-    /* Enables the Option Bytes Programming operation */
-    FLASH-&gt;CR |= CR_OPTPG_Set; 
-    *(vu16*)Address = Data;
-    
-    /* Wait for last operation to be completed */
-    status = FLASH_WaitForLastOperation(ProgramTimeout);
-
-    if(status != FLASH_BUSY)
-    {
-      /* if the program operation is completed, disable the OPTPG Bit */
-      FLASH-&gt;CR &amp;= CR_OPTPG_Reset;
-    }
-  }    
-  /* Return the Option Byte Data Program Status */
-  return status;      
-}
-
-/*******************************************************************************
-* Function Name  : FLASH_EnableWriteProtection
-* Description    : Write protects the desired pages
-* Input          : - FLASH_Pages: specifies the address of the pages to be 
-*                    write protected. This parameter can be:
-*                    - For STM32F10Xxx Medium-density devices (FLASH page size equal to 1 KB)
-*                       - A value between FLASH_WRProt_Pages0to3 and 
-*                         FLASH_WRProt_Pages124to127
-*                    - For STM32F10Xxx High-density devices (FLASH page size equal to 2 KB) 
-*                       - A value between FLASH_WRProt_Pages0to1 and
-*                         FLASH_WRProt_Pages60to61 or FLASH_WRProt_Pages62to255 
-*                       - FLASH_WRProt_AllPages
-* Output         : None
-* Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
-*                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
-*                  FLASH_TIMEOUT.
-*******************************************************************************/
-FLASH_Status FLASH_EnableWriteProtection(u32 FLASH_Pages)
-{
-  u16 WRP0_Data = 0xFFFF, WRP1_Data = 0xFFFF, WRP2_Data = 0xFFFF, WRP3_Data = 0xFFFF;
-  
-  FLASH_Status status = FLASH_COMPLETE;
-  
-  /* Check the parameters */
-  assert_param(IS_FLASH_WRPROT_PAGE(FLASH_Pages));
-  
-  FLASH_Pages = (u32)(~FLASH_Pages);
-  WRP0_Data = (vu16)(FLASH_Pages &amp; WRP0_Mask);
-  WRP1_Data = (vu16)((FLASH_Pages &amp; WRP1_Mask) &gt;&gt; 8);
-  WRP2_Data = (vu16)((FLASH_Pages &amp; WRP2_Mask) &gt;&gt; 16);
-  WRP3_Data = (vu16)((FLASH_Pages &amp; WRP3_Mask) &gt;&gt; 24);
-  
-  /* Wait for last operation to be completed */
-  status = FLASH_WaitForLastOperation(ProgramTimeout);
-  
-  if(status == FLASH_COMPLETE)
-  {
-    /* Authorizes the small information block programming */
-    FLASH-&gt;OPTKEYR = FLASH_KEY1;
-    FLASH-&gt;OPTKEYR = FLASH_KEY2;
-    FLASH-&gt;CR |= CR_OPTPG_Set;
-
-    if(WRP0_Data != 0xFF)
-    {
-      OB-&gt;WRP0 = WRP0_Data;
-      
-      /* Wait for last operation to be completed */
-      status = FLASH_WaitForLastOperation(ProgramTimeout);
-    }
-    if((status == FLASH_COMPLETE) &amp;&amp; (WRP1_Data != 0xFF))
-    {
-      OB-&gt;WRP1 = WRP1_Data;
-      
-      /* Wait for last operation to be completed */
-      status = FLASH_WaitForLastOperation(ProgramTimeout);
-    }
-
-    if((status == FLASH_COMPLETE) &amp;&amp; (WRP2_Data != 0xFF))
-    {
-      OB-&gt;WRP2 = WRP2_Data;
-      
-      /* Wait for last operation to be completed */
-      status = FLASH_WaitForLastOperation(ProgramTimeout);
-    }
-    
-    if((status == FLASH_COMPLETE)&amp;&amp; (WRP3_Data != 0xFF))
-    {
-      OB-&gt;WRP3 = WRP3_Data;
-     
-      /* Wait for last operation to be completed */
-      status = FLASH_WaitForLastOperation(ProgramTimeout);
-    }
-          
-    if(status != FLASH_BUSY)
-    {
-      /* if the program operation is completed, disable the OPTPG Bit */
-      FLASH-&gt;CR &amp;= CR_OPTPG_Reset;
-    }
-  } 
-  /* Return the write protection operation Status */
-  return status;       
-}
-
-/*******************************************************************************
-* Function Name  : FLASH_ReadOutProtection
-* Description    : Enables or disables the read out protection.
-*                  If the user has already programmed the other option bytes before 
-*                  calling this function, he must re-program them since this 
-*                  function erases all option bytes.
-* Input          : - Newstate: new state of the ReadOut Protection.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
-*                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
-*                  FLASH_TIMEOUT.
-*******************************************************************************/
-FLASH_Status FLASH_ReadOutProtection(FunctionalState NewState)
-{
-  FLASH_Status status = FLASH_COMPLETE;
-
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  status = FLASH_WaitForLastOperation(EraseTimeout);
-
-  if(status == FLASH_COMPLETE)
-  {
-    /* Authorizes the small information block programming */
-    FLASH-&gt;OPTKEYR = FLASH_KEY1;
-    FLASH-&gt;OPTKEYR = FLASH_KEY2;
-
-    FLASH-&gt;CR |= CR_OPTER_Set;
-    FLASH-&gt;CR |= CR_STRT_Set;
-
-    /* Wait for last operation to be completed */
-    status = FLASH_WaitForLastOperation(EraseTimeout);
-
-    if(status == FLASH_COMPLETE)
-    {
-      /* if the erase operation is completed, disable the OPTER Bit */
-      FLASH-&gt;CR &amp;= CR_OPTER_Reset;
-
-      /* Enable the Option Bytes Programming operation */
-      FLASH-&gt;CR |= CR_OPTPG_Set; 
-
-      if(NewState != DISABLE)
-      {
-        OB-&gt;RDP = 0x00;
-      }
-      else
-      {
-        OB-&gt;RDP = RDP_Key;  
-      }
-
-      /* Wait for last operation to be completed */
-      status = FLASH_WaitForLastOperation(EraseTimeout); 
-    
-      if(status != FLASH_BUSY)
-      {
-        /* if the program operation is completed, disable the OPTPG Bit */
-        FLASH-&gt;CR &amp;= CR_OPTPG_Reset;
-      }
-    }
-    else 
-    {
-      if(status != FLASH_BUSY)
-      {
-        /* Disable the OPTER Bit */
-        FLASH-&gt;CR &amp;= CR_OPTER_Reset;
-      }
-    }
-  }
-  /* Return the protection operation Status */
-  return status;      
-}
-  	
-/*******************************************************************************
-* Function Name  : FLASH_UserOptionByteConfig
-* Description    : Programs the FLASH User Option Byte: IWDG_SW / RST_STOP /
-*                  RST_STDBY.
-* Input          : - OB_IWDG: Selects the IWDG mode
-*                     This parameter can be one of the following values:
-*                     - OB_IWDG_SW: Software IWDG selected
-*                     - OB_IWDG_HW: Hardware IWDG selected
-*                  - OB_STOP: Reset event when entering STOP mode.
-*                     This parameter can be one of the following values:
-*                     - OB_STOP_NoRST: No reset generated when entering in STOP
-*                     - OB_STOP_RST: Reset generated when entering in STOP
-*                  - OB_STDBY: Reset event when entering Standby mode.
-*                    This parameter can be one of the following values:
-*                     - OB_STDBY_NoRST: No reset generated when entering in STANDBY
-*                     - OB_STDBY_RST: Reset generated when entering in STANDBY
-* Output         : None
-* Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
-*                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
-*                  FLASH_TIMEOUT.
-*******************************************************************************/
-FLASH_Status FLASH_UserOptionByteConfig(u16 OB_IWDG, u16 OB_STOP, u16 OB_STDBY)
-{
-  FLASH_Status status = FLASH_COMPLETE; 
-
-  /* Check the parameters */
-  assert_param(IS_OB_IWDG_SOURCE(OB_IWDG));
-  assert_param(IS_OB_STOP_SOURCE(OB_STOP));
-  assert_param(IS_OB_STDBY_SOURCE(OB_STDBY));
-
-  /* Authorize the small information block programming */
-  FLASH-&gt;OPTKEYR = FLASH_KEY1;
-  FLASH-&gt;OPTKEYR = FLASH_KEY2;
-  
-  /* Wait for last operation to be completed */
-  status = FLASH_WaitForLastOperation(ProgramTimeout);
-  
-  if(status == FLASH_COMPLETE)
-  {  
-    /* Enable the Option Bytes Programming operation */
-    FLASH-&gt;CR |= CR_OPTPG_Set; 
-           
-    OB-&gt;USER = ( OB_IWDG | OB_STOP |OB_STDBY) | (u16)0xF8; 
-  
-    /* Wait for last operation to be completed */
-    status = FLASH_WaitForLastOperation(ProgramTimeout);
-
-    if(status != FLASH_BUSY)
-    {
-      /* if the program operation is completed, disable the OPTPG Bit */
-      FLASH-&gt;CR &amp;= CR_OPTPG_Reset;
-    }
-  }    
-  /* Return the Option Byte program Status */
-  return status;
-}
-
-/*******************************************************************************
-* Function Name  : FLASH_GetUserOptionByte
-* Description    : Returns the FLASH User Option Bytes values.
-* Input          : None
-* Output         : None
-* Return         : The FLASH User Option Bytes values:IWDG_SW(Bit0), RST_STOP(Bit1)
-*                  and RST_STDBY(Bit2).
-*******************************************************************************/
-u32 FLASH_GetUserOptionByte(void)
-{
-  /* Return the User Option Byte */
-  return (u32)(FLASH-&gt;OBR &gt;&gt; 2);
-}
-
-/*******************************************************************************
-* Function Name  : FLASH_GetWriteProtectionOptionByte
-* Description    : Returns the FLASH Write Protection Option Bytes Register value.
-* Input          : None
-* Output         : None
-* Return         : The FLASH Write Protection  Option Bytes Register value
-*******************************************************************************/
-u32 FLASH_GetWriteProtectionOptionByte(void)
-{
-  /* Return the Falsh write protection Register value */
-  return (u32)(FLASH-&gt;WRPR);
-}
-
-/*******************************************************************************
-* Function Name  : FLASH_GetReadOutProtectionStatus
-* Description    : Checks whether the FLASH Read Out Protection Status is set 
-*                  or not.
-* Input          : None
-* Output         : None
-* Return         : FLASH ReadOut Protection Status(SET or RESET)
-*******************************************************************************/
-FlagStatus FLASH_GetReadOutProtectionStatus(void)
-{
-  FlagStatus readoutstatus = RESET;
-
-  if ((FLASH-&gt;OBR &amp; RDPRT_Mask) != (u32)RESET)
-  {
-    readoutstatus = SET;
-  }
-  else
-  {
-    readoutstatus = RESET;
-  }
-  return readoutstatus;
-}
-
-/*******************************************************************************
-* Function Name  : FLASH_GetPrefetchBufferStatus
-* Description    : Checks whether the FLASH Prefetch Buffer status is set or not.
-* Input          : None
-* Output         : None
-* Return         : FLASH Prefetch Buffer Status (SET or RESET).
-*******************************************************************************/
-FlagStatus FLASH_GetPrefetchBufferStatus(void)
-{
-  FlagStatus bitstatus = RESET;
-  
-  if ((FLASH-&gt;ACR &amp; ACR_PRFTBS_Mask) != (u32)RESET)
-  {
-    bitstatus = SET;
-  }
-  else
-  {
-    bitstatus = RESET;
-  }
-  /* Return the new state of FLASH Prefetch Buffer Status (SET or RESET) */
-  return bitstatus; 
-}
-
-/*******************************************************************************
-* Function Name  : FLASH_ITConfig
-* Description    : Enables or disables the specified FLASH interrupts.
-* Input          : - FLASH_IT: specifies the FLASH interrupt sources to be 
-*                    enabled or disabled.
-*                    This parameter can be any combination of the following values:
-*                       - FLASH_IT_ERROR: FLASH Error Interrupt
-*                       - FLASH_IT_EOP: FLASH end of operation Interrupt
-* Output         : None
-* Return         : None 
-*******************************************************************************/
-void FLASH_ITConfig(u16 FLASH_IT, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_FLASH_IT(FLASH_IT)); 
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if(NewState != DISABLE)
-  {
-    /* Enable the interrupt sources */
-    FLASH-&gt;CR |= FLASH_IT;
-  }
-  else
-  {
-    /* Disable the interrupt sources */
-    FLASH-&gt;CR &amp;= ~(u32)FLASH_IT;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : FLASH_GetFlagStatus
-* Description    : Checks whether the specified FLASH flag is set or not.
-* Input          : - FLASH_FLAG: specifies the FLASH flag to check.
-*                     This parameter can be one of the following values:
-*                    - FLASH_FLAG_BSY: FLASH Busy flag           
-*                    - FLASH_FLAG_PGERR: FLASH Program error flag       
-*                    - FLASH_FLAG_WRPRTERR: FLASH Write protected error flag      
-*                    - FLASH_FLAG_EOP: FLASH End of Operation flag           
-*                    - FLASH_FLAG_OPTERR:  FLASH Option Byte error flag     
-* Output         : None
-* Return         : The new state of FLASH_FLAG (SET or RESET).
-*******************************************************************************/
-FlagStatus FLASH_GetFlagStatus(u16 FLASH_FLAG)
-{
-  FlagStatus bitstatus = RESET;
-
-  /* Check the parameters */
-  assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG)) ;
-
-  if(FLASH_FLAG == FLASH_FLAG_OPTERR) 
-  {
-    if((FLASH-&gt;OBR &amp; FLASH_FLAG_OPTERR) != (u32)RESET)
-    {
-      bitstatus = SET;
-    }
-    else
-    {
-      bitstatus = RESET;
-    }
-  }
-  else
-  {
-   if((FLASH-&gt;SR &amp; FLASH_FLAG) != (u32)RESET)
-    {
-      bitstatus = SET;
-    }
-    else
-    {
-      bitstatus = RESET;
-    }
-  }
-  /* Return the new state of FLASH_FLAG (SET or RESET) */
-  return bitstatus;
-}
-
-/*******************************************************************************
-* Function Name  : FLASH_ClearFlag
-* Description    : Clears the FLASH's pending flags.
-* Input          : - FLASH_FLAG: specifies the FLASH flags to clear.
-*                    This parameter can be any combination of the following values:
-*                    - FLASH_FLAG_BSY: FLASH Busy flag           
-*                    - FLASH_FLAG_PGERR: FLASH Program error flag       
-*                    - FLASH_FLAG_WRPRTERR: FLASH Write protected error flag      
-*                    - FLASH_FLAG_EOP: FLASH End of Operation flag           
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void FLASH_ClearFlag(u16 FLASH_FLAG)
-{
-  /* Check the parameters */
-  assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG)) ;
-  
-  /* Clear the flags */
-  FLASH-&gt;SR = FLASH_FLAG;
-}
-
-/*******************************************************************************
-* Function Name  : FLASH_GetStatus
-* Description    : Returns the FLASH Status.
-* Input          : None
-* Output         : None
-* Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
-*                  FLASH_ERROR_PG, FLASH_ERROR_WRP or FLASH_COMPLETE
-*******************************************************************************/
-FLASH_Status FLASH_GetStatus(void)
-{
-  FLASH_Status flashstatus = FLASH_COMPLETE;
-  
-  if((FLASH-&gt;SR &amp; FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
-  {
-    flashstatus = FLASH_BUSY;
-  }
-  else 
-  {  
-    if(FLASH-&gt;SR &amp; FLASH_FLAG_PGERR)
-    { 
-      flashstatus = FLASH_ERROR_PG;
-    }
-    else 
-    {
-      if(FLASH-&gt;SR &amp; FLASH_FLAG_WRPRTERR)
-      {
-        flashstatus = FLASH_ERROR_WRP;
-      }
-      else
-      {
-        flashstatus = FLASH_COMPLETE;
-      }
-    }
-  }
-  /* Return the Flash Status */
-  return flashstatus;
-}
-
-/*******************************************************************************
-* Function Name  : FLASH_WaitForLastOperation
-* Description    : Waits for a Flash operation to complete or a TIMEOUT to occur.
-* Input          : - Timeout: FLASH progamming Timeout
-* Output         : None
-* Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
-*                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
-*                  FLASH_TIMEOUT.
-*******************************************************************************/
-FLASH_Status FLASH_WaitForLastOperation(u32 Timeout)
-{ 
-  FLASH_Status status = FLASH_COMPLETE;
-   
-  /* Check for the Flash Status */
-  status = FLASH_GetStatus();
-
-  /* Wait for a Flash operation to complete or a TIMEOUT to occur */
-  while((status == FLASH_BUSY) &amp;&amp; (Timeout != 0x00))
-  {
-    delay();
-    status = FLASH_GetStatus();
-    Timeout--;
-  }
-
-  if(Timeout == 0x00 )
-  {
-    status = FLASH_TIMEOUT;
-  }
-
-  /* Return the operation status */
-  return status;
-}
-
-/*******************************************************************************
-* Function Name  : delay
-* Description    : Inserts a time delay.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-static void delay(void)
-{
-  vu32 i = 0;
-
-  for(i = 0xFF; i != 0; i--)
-  {
-  }
-}
-#endif
-
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
+/**
+  ******************************************************************************
+  * @file    stm32f10x_flash.c
+  * @author  MCD Application Team
+  * @version V3.1.0
+  * @date    06/19/2009
+  * @brief   This file provides all the FLASH firmware functions.
+  ******************************************************************************
+  * @copy
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * &lt;h2&gt;&lt;center&gt;&copy; COPYRIGHT 2009 STMicroelectronics&lt;/center&gt;&lt;/h2&gt;
+  */ 
+
+/* Includes ------------------------------------------------------------------*/
+#include &quot;stm32f10x_flash.h&quot;
+
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup FLASH 
+  * @brief FLASH driver modules
+  * @{
+  */ 
+
+/** @defgroup FLASH_Private_TypesDefinitions
+  * @{
+  */
+
+/**
+  * @}
+  */ 
+
+/** @defgroup FLASH_Private_Defines
+  * @{
+  */ 
+
+/* Flash Access Control Register bits */
+#define ACR_LATENCY_Mask         ((uint32_t)0x00000038)
+#define ACR_HLFCYA_Mask          ((uint32_t)0xFFFFFFF7)
+#define ACR_PRFTBE_Mask          ((uint32_t)0xFFFFFFEF)
+
+/* Flash Access Control Register bits */
+#define ACR_PRFTBS_Mask          ((uint32_t)0x00000020) 
+
+/* Flash Control Register bits */
+#define CR_PG_Set                ((uint32_t)0x00000001)
+#define CR_PG_Reset              ((uint32_t)0x00001FFE) 
+#define CR_PER_Set               ((uint32_t)0x00000002)
+#define CR_PER_Reset             ((uint32_t)0x00001FFD)
+#define CR_MER_Set               ((uint32_t)0x00000004)
+#define CR_MER_Reset             ((uint32_t)0x00001FFB)
+#define CR_OPTPG_Set             ((uint32_t)0x00000010)
+#define CR_OPTPG_Reset           ((uint32_t)0x00001FEF)
+#define CR_OPTER_Set             ((uint32_t)0x00000020)
+#define CR_OPTER_Reset           ((uint32_t)0x00001FDF)
+#define CR_STRT_Set              ((uint32_t)0x00000040)
+#define CR_LOCK_Set              ((uint32_t)0x00000080)
+
+/* FLASH Mask */
+#define RDPRT_Mask               ((uint32_t)0x00000002)
+#define WRP0_Mask                ((uint32_t)0x000000FF)
+#define WRP1_Mask                ((uint32_t)0x0000FF00)
+#define WRP2_Mask                ((uint32_t)0x00FF0000)
+#define WRP3_Mask                ((uint32_t)0xFF000000)
+
+/* FLASH Keys */
+#define RDP_Key                  ((uint16_t)0x00A5)
+#define FLASH_KEY1               ((uint32_t)0x45670123)
+#define FLASH_KEY2               ((uint32_t)0xCDEF89AB)
+
+/* Delay definition */   
+#define EraseTimeout             ((uint32_t)0x00000FFF)
+#define ProgramTimeout           ((uint32_t)0x0000000F)
+
+/**
+  * @}
+  */ 
+
+/** @defgroup FLASH_Private_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */ 
+
+/** @defgroup FLASH_Private_Variables
+  * @{
+  */
+
+/**
+  * @}
+  */ 
+
+/** @defgroup FLASH_Private_FunctionPrototypes
+  * @{
+  */
+
+static void delay(void);
+/**
+  * @}
+  */
+
+/** @defgroup FLASH_Private_Functions
+  * @{
+  */
+
+/**
+  * @brief  Sets the code latency value.
+  * @param  FLASH_Latency: specifies the FLASH Latency value.
+  *   This parameter can be one of the following values:
+  *     @arg FLASH_Latency_0: FLASH Zero Latency cycle
+  *     @arg FLASH_Latency_1: FLASH One Latency cycle
+  *     @arg FLASH_Latency_2: FLASH Two Latency cycles
+  * @retval None
+  */
+void FLASH_SetLatency(uint32_t FLASH_Latency)
+{
+  uint32_t tmpreg = 0;
+  
+  /* Check the parameters */
+  assert_param(IS_FLASH_LATENCY(FLASH_Latency));
+  
+  /* Read the ACR register */
+  tmpreg = FLASH-&gt;ACR;  
+  
+  /* Sets the Latency value */
+  tmpreg &amp;= ACR_LATENCY_Mask;
+  tmpreg |= FLASH_Latency;
+  
+  /* Write the ACR register */
+  FLASH-&gt;ACR = tmpreg;
+}
+
+/**
+  * @brief  Enables or disables the Half cycle flash access.
+  * @param  FLASH_HalfCycleAccess: specifies the FLASH Half cycle Access mode.
+  *   This parameter can be one of the following values:
+  *     @arg FLASH_HalfCycleAccess_Enable: FLASH Half Cycle Enable
+  *     @arg FLASH_HalfCycleAccess_Disable: FLASH Half Cycle Disable
+  * @retval None
+  */
+void FLASH_HalfCycleAccessCmd(uint32_t FLASH_HalfCycleAccess)
+{
+  /* Check the parameters */
+  assert_param(IS_FLASH_HALFCYCLEACCESS_STATE(FLASH_HalfCycleAccess));
+  
+  /* Enable or disable the Half cycle access */
+  FLASH-&gt;ACR &amp;= ACR_HLFCYA_Mask;
+  FLASH-&gt;ACR |= FLASH_HalfCycleAccess;
+}
+
+/**
+  * @brief  Enables or disables the Prefetch Buffer.
+  * @param  FLASH_PrefetchBuffer: specifies the Prefetch buffer status.
+  *   This parameter can be one of the following values:
+  *     @arg FLASH_PrefetchBuffer_Enable: FLASH Prefetch Buffer Enable
+  *     @arg FLASH_PrefetchBuffer_Disable: FLASH Prefetch Buffer Disable
+  * @retval None
+  */
+void FLASH_PrefetchBufferCmd(uint32_t FLASH_PrefetchBuffer)
+{
+  /* Check the parameters */
+  assert_param(IS_FLASH_PREFETCHBUFFER_STATE(FLASH_PrefetchBuffer));
+  
+  /* Enable or disable the Prefetch Buffer */
+  FLASH-&gt;ACR &amp;= ACR_PRFTBE_Mask;
+  FLASH-&gt;ACR |= FLASH_PrefetchBuffer;
+}
+
+/**
+  * @brief  Unlocks the FLASH Program Erase Controller.
+  * @param  None
+  * @retval None
+  */
+void FLASH_Unlock(void)
+{
+  /* Authorize the FPEC Access */
+  FLASH-&gt;KEYR = FLASH_KEY1;
+  FLASH-&gt;KEYR = FLASH_KEY2;
+}
+
+/**
+  * @brief  Locks the FLASH Program Erase Controller.
+  * @param  None
+  * @retval None
+  */
+void FLASH_Lock(void)
+{
+  /* Set the Lock Bit to lock the FPEC and the FCR */
+  FLASH-&gt;CR |= CR_LOCK_Set;
+}
+
+/**
+  * @brief  Erases a specified FLASH page.
+  * @param  Page_Address: The page address to be erased.
+  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PG,
+  *   FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
+  */
+FLASH_Status FLASH_ErasePage(uint32_t Page_Address)
+{
+  FLASH_Status status = FLASH_COMPLETE;
+  /* Check the parameters */
+  assert_param(IS_FLASH_ADDRESS(Page_Address));
+  /* Wait for last operation to be completed */
+  status = FLASH_WaitForLastOperation(EraseTimeout);
+  
+  if(status == FLASH_COMPLETE)
+  { 
+    /* if the previous operation is completed, proceed to erase the page */
+    FLASH-&gt;CR|= CR_PER_Set;
+    FLASH-&gt;AR = Page_Address; 
+    FLASH-&gt;CR|= CR_STRT_Set;
+    
+    /* Wait for last operation to be completed */
+    status = FLASH_WaitForLastOperation(EraseTimeout);
+    if(status != FLASH_TIMEOUT)
+    {
+      /* if the erase operation is completed, disable the PER Bit */
+      FLASH-&gt;CR &amp;= CR_PER_Reset;
+    }
+  }
+  /* Return the Erase Status */
+  return status;
+}
+
+/**
+  * @brief  Erases all FLASH pages.
+  * @param  None
+  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
+  *   FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
+  */
+FLASH_Status FLASH_EraseAllPages(void)
+{
+  FLASH_Status status = FLASH_COMPLETE;
+  /* Wait for last operation to be completed */
+  status = FLASH_WaitForLastOperation(EraseTimeout);
+  
+  if(status == FLASH_COMPLETE)
+  {
+    /* if the previous operation is completed, proceed to erase all pages */
+     FLASH-&gt;CR |= CR_MER_Set;
+     FLASH-&gt;CR |= CR_STRT_Set;
+    
+    /* Wait for last operation to be completed */
+    status = FLASH_WaitForLastOperation(EraseTimeout);
+    if(status != FLASH_TIMEOUT)
+    {
+      /* if the erase operation is completed, disable the MER Bit */
+      FLASH-&gt;CR &amp;= CR_MER_Reset;
+    }
+  }	   
+  /* Return the Erase Status */
+  return status;
+}
+
+/**
+  * @brief  Erases the FLASH option bytes.
+  * @param  None
+  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
+  *   FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
+  */
+FLASH_Status FLASH_EraseOptionBytes(void)
+{
+  FLASH_Status status = FLASH_COMPLETE;
+  
+  /* Wait for last operation to be completed */
+  status = FLASH_WaitForLastOperation(EraseTimeout);
+  if(status == FLASH_COMPLETE)
+  {
+    /* Authorize the small information block programming */
+    FLASH-&gt;OPTKEYR = FLASH_KEY1;
+    FLASH-&gt;OPTKEYR = FLASH_KEY2;
+    
+    /* if the previous operation is completed, proceed to erase the option bytes */
+    FLASH-&gt;CR |= CR_OPTER_Set;
+    FLASH-&gt;CR |= CR_STRT_Set;
+    /* Wait for last operation to be completed */
+    status = FLASH_WaitForLastOperation(EraseTimeout);
+    
+    if(status == FLASH_COMPLETE)
+    {
+      /* if the erase operation is completed, disable the OPTER Bit */
+      FLASH-&gt;CR &amp;= CR_OPTER_Reset;
+       
+      /* Enable the Option Bytes Programming operation */
+      FLASH-&gt;CR |= CR_OPTPG_Set;
+      /* Enable the readout access */
+      OB-&gt;RDP= RDP_Key; 
+      /* Wait for last operation to be completed */
+      status = FLASH_WaitForLastOperation(ProgramTimeout);
+ 
+      if(status != FLASH_TIMEOUT)
+      {
+        /* if the program operation is completed, disable the OPTPG Bit */
+        FLASH-&gt;CR &amp;= CR_OPTPG_Reset;
+      }
+    }
+    else
+    {
+      if (status != FLASH_TIMEOUT)
+      {
+        /* Disable the OPTPG Bit */
+        FLASH-&gt;CR &amp;= CR_OPTPG_Reset;
+      }
+    }  
+  }
+  /* Return the erase status */
+  return status;
+}
+
+/**
+  * @brief  Programs a word at a specified address.
+  * @param  Address: specifies the address to be programmed.
+  * @param  Data: specifies the data to be programmed.
+  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
+  *   FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT. 
+  */
+FLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data)
+{
+  FLASH_Status status = FLASH_COMPLETE;
+  __IO uint32_t tmp = 0;
+
+  /* Check the parameters */
+  assert_param(IS_FLASH_ADDRESS(Address));
+  /* Wait for last operation to be completed */
+  status = FLASH_WaitForLastOperation(ProgramTimeout);
+  
+  if(status == FLASH_COMPLETE)
+  {
+    /* if the previous operation is completed, proceed to program the new first 
+    half word */
+    FLASH-&gt;CR |= CR_PG_Set;
+  
+    *(__IO uint16_t*)Address = (uint16_t)Data;
+    /* Wait for last operation to be completed */
+    status = FLASH_WaitForLastOperation(ProgramTimeout);
+ 
+    if(status == FLASH_COMPLETE)
+    {
+      /* if the previous operation is completed, proceed to program the new second 
+      half word */
+      tmp = Address + 2;
+
+      *(__IO uint16_t*) tmp = Data &gt;&gt; 16;
+    
+      /* Wait for last operation to be completed */
+      status = FLASH_WaitForLastOperation(ProgramTimeout);
+        
+      if(status != FLASH_TIMEOUT)
+      {
+        /* Disable the PG Bit */
+        FLASH-&gt;CR &amp;= CR_PG_Reset;
+      }
+    }
+    else
+    {
+      if (status != FLASH_TIMEOUT)
+      {
+        /* Disable the PG Bit */
+        FLASH-&gt;CR &amp;= CR_PG_Reset;
+      }
+     }
+  }
+  /* Return the Program Status */
+  return status;
+}
+
+/**
+  * @brief  Programs a half word at a specified address.
+  * @param  Address: specifies the address to be programmed.
+  * @param  Data: specifies the data to be programmed.
+  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
+  *   FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT. 
+  */
+FLASH_Status FLASH_ProgramHalfWord(uint32_t Address, uint16_t Data)
+{
+  FLASH_Status status = FLASH_COMPLETE;
+  /* Check the parameters */
+  assert_param(IS_FLASH_ADDRESS(Address));
+  /* Wait for last operation to be completed */
+  status = FLASH_WaitForLastOperation(ProgramTimeout);
+  
+  if(status == FLASH_COMPLETE)
+  {
+    /* if the previous operation is completed, proceed to program the new data */
+    FLASH-&gt;CR |= CR_PG_Set;
+  
+    *(__IO uint16_t*)Address = Data;
+    /* Wait for last operation to be completed */
+    status = FLASH_WaitForLastOperation(ProgramTimeout);
+    if(status != FLASH_TIMEOUT)
+    {
+      /* if the program operation is completed, disable the PG Bit */
+      FLASH-&gt;CR &amp;= CR_PG_Reset;
+    }
+  } 
+  /* Return the Program Status */
+  return status;
+}
+
+/**
+  * @brief  Programs a half word at a specified Option Byte Data address.
+  * @param  Address: specifies the address to be programmed.
+  *   This parameter can be 0x1FFFF804 or 0x1FFFF806. 
+  * @param  Data: specifies the data to be programmed.
+  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
+  *   FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT. 
+  */
+FLASH_Status FLASH_ProgramOptionByteData(uint32_t Address, uint8_t Data)
+{
+  FLASH_Status status = FLASH_COMPLETE;
+  /* Check the parameters */
+  assert_param(IS_OB_DATA_ADDRESS(Address));
+  status = FLASH_WaitForLastOperation(ProgramTimeout);
+  if(status == FLASH_COMPLETE)
+  {
+    /* Authorize the small information block programming */
+    FLASH-&gt;OPTKEYR = FLASH_KEY1;
+    FLASH-&gt;OPTKEYR = FLASH_KEY2;
+    /* Enables the Option Bytes Programming operation */
+    FLASH-&gt;CR |= CR_OPTPG_Set; 
+    *(__IO uint16_t*)Address = Data;
+    
+    /* Wait for last operation to be completed */
+    status = FLASH_WaitForLastOperation(ProgramTimeout);
+    if(status != FLASH_TIMEOUT)
+    {
+      /* if the program operation is completed, disable the OPTPG Bit */
+      FLASH-&gt;CR &amp;= CR_OPTPG_Reset;
+    }
+  }    
+  /* Return the Option Byte Data Program Status */
+  return status;
+}
+
+/**
+  * @brief  Write protects the desired pages
+  * @param  FLASH_Pages: specifies the address of the pages to be write protected.
+  *   This parameter can be:
+  *     @arg For @b STM32_Low-density_devices: value between FLASH_WRProt_Pages0to3 and FLASH_WRProt_Pages28to31  
+  *     @arg For @b STM32_Medium-density_devices: value between FLASH_WRProt_Pages0to3
+  *       and FLASH_WRProt_Pages124to127
+  *     @arg For @b STM32_High-density_devices: value between FLASH_WRProt_Pages0to1 and
+  *       FLASH_WRProt_Pages60to61 or FLASH_WRProt_Pages62to255
+  *     @arg For @b STM32_Connectivity_line_devices: value between FLASH_WRProt_Pages0to1 and
+  *       FLASH_WRProt_Pages60to61 or FLASH_WRProt_Pages62to127    
+  *     @arg FLASH_WRProt_AllPages
+  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
+  *   FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
+  */
+FLASH_Status FLASH_EnableWriteProtection(uint32_t FLASH_Pages)
+{
+  uint16_t WRP0_Data = 0xFFFF, WRP1_Data = 0xFFFF, WRP2_Data = 0xFFFF, WRP3_Data = 0xFFFF;
+  
+  FLASH_Status status = FLASH_COMPLETE;
+  
+  /* Check the parameters */
+  assert_param(IS_FLASH_WRPROT_PAGE(FLASH_Pages));
+  
+  FLASH_Pages = (uint32_t)(~FLASH_Pages);
+  WRP0_Data = (uint16_t)(FLASH_Pages &amp; WRP0_Mask);
+  WRP1_Data = (uint16_t)((FLASH_Pages &amp; WRP1_Mask) &gt;&gt; 8);
+  WRP2_Data = (uint16_t)((FLASH_Pages &amp; WRP2_Mask) &gt;&gt; 16);
+  WRP3_Data = (uint16_t)((FLASH_Pages &amp; WRP3_Mask) &gt;&gt; 24);
+  
+  /* Wait for last operation to be completed */
+  status = FLASH_WaitForLastOperation(ProgramTimeout);
+  
+  if(status == FLASH_COMPLETE)
+  {
+    /* Authorizes the small information block programming */
+    FLASH-&gt;OPTKEYR = FLASH_KEY1;
+    FLASH-&gt;OPTKEYR = FLASH_KEY2;
+    FLASH-&gt;CR |= CR_OPTPG_Set;
+    if(WRP0_Data != 0xFF)
+    {
+      OB-&gt;WRP0 = WRP0_Data;
+      
+      /* Wait for last operation to be completed */
+      status = FLASH_WaitForLastOperation(ProgramTimeout);
+    }
+    if((status == FLASH_COMPLETE) &amp;&amp; (WRP1_Data != 0xFF))
+    {
+      OB-&gt;WRP1 = WRP1_Data;
+      
+      /* Wait for last operation to be completed */
+      status = FLASH_WaitForLastOperation(ProgramTimeout);
+    }
+    if((status == FLASH_COMPLETE) &amp;&amp; (WRP2_Data != 0xFF))
+    {
+      OB-&gt;WRP2 = WRP2_Data;
+      
+      /* Wait for last operation to be completed */
+      status = FLASH_WaitForLastOperation(ProgramTimeout);
+    }
+    
+    if((status == FLASH_COMPLETE)&amp;&amp; (WRP3_Data != 0xFF))
+    {
+      OB-&gt;WRP3 = WRP3_Data;
+     
+      /* Wait for last operation to be completed */
+      status = FLASH_WaitForLastOperation(ProgramTimeout);
+    }
+          
+    if(status != FLASH_TIMEOUT)
+    {
+      /* if the program operation is completed, disable the OPTPG Bit */
+      FLASH-&gt;CR &amp;= CR_OPTPG_Reset;
+    }
+  } 
+  /* Return the write protection operation Status */
+  return status;       
+}
+
+/**
+  * @brief  Enables or disables the read out protection.
+  * @note   If the user has already programmed the other option bytes before calling 
+  *   this function, he must re-program them since this function erases all option bytes.
+  * @param  Newstate: new state of the ReadOut Protection.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
+  *   FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
+  */
+FLASH_Status FLASH_ReadOutProtection(FunctionalState NewState)
+{
+  FLASH_Status status = FLASH_COMPLETE;
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  status = FLASH_WaitForLastOperation(EraseTimeout);
+  if(status == FLASH_COMPLETE)
+  {
+    /* Authorizes the small information block programming */
+    FLASH-&gt;OPTKEYR = FLASH_KEY1;
+    FLASH-&gt;OPTKEYR = FLASH_KEY2;
+    FLASH-&gt;CR |= CR_OPTER_Set;
+    FLASH-&gt;CR |= CR_STRT_Set;
+    /* Wait for last operation to be completed */
+    status = FLASH_WaitForLastOperation(EraseTimeout);
+    if(status == FLASH_COMPLETE)
+    {
+      /* if the erase operation is completed, disable the OPTER Bit */
+      FLASH-&gt;CR &amp;= CR_OPTER_Reset;
+      /* Enable the Option Bytes Programming operation */
+      FLASH-&gt;CR |= CR_OPTPG_Set; 
+      if(NewState != DISABLE)
+      {
+        OB-&gt;RDP = 0x00;
+      }
+      else
+      {
+        OB-&gt;RDP = RDP_Key;  
+      }
+      /* Wait for last operation to be completed */
+      status = FLASH_WaitForLastOperation(EraseTimeout); 
+    
+      if(status != FLASH_TIMEOUT)
+      {
+        /* if the program operation is completed, disable the OPTPG Bit */
+        FLASH-&gt;CR &amp;= CR_OPTPG_Reset;
+      }
+    }
+    else 
+    {
+      if(status != FLASH_TIMEOUT)
+      {
+        /* Disable the OPTER Bit */
+        FLASH-&gt;CR &amp;= CR_OPTER_Reset;
+      }
+    }
+  }
+  /* Return the protection operation Status */
+  return status;      
+}
+
+/**
+  * @brief  Programs the FLASH User Option Byte: IWDG_SW / RST_STOP / RST_STDBY.
+  * @param  OB_IWDG: Selects the IWDG mode
+  *   This parameter can be one of the following values:
+  *     @arg OB_IWDG_SW: Software IWDG selected
+  *     @arg OB_IWDG_HW: Hardware IWDG selected
+  * @param  OB_STOP: Reset event when entering STOP mode.
+  *   This parameter can be one of the following values:
+  *     @arg OB_STOP_NoRST: No reset generated when entering in STOP
+  *     @arg OB_STOP_RST: Reset generated when entering in STOP
+  * @param  OB_STDBY: Reset event when entering Standby mode.
+  *   This parameter can be one of the following values:
+  *     @arg OB_STDBY_NoRST: No reset generated when entering in STANDBY
+  *     @arg OB_STDBY_RST: Reset generated when entering in STANDBY
+  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG, 
+  * FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
+  */
+FLASH_Status FLASH_UserOptionByteConfig(uint16_t OB_IWDG, uint16_t OB_STOP, uint16_t OB_STDBY)
+{
+  FLASH_Status status = FLASH_COMPLETE; 
+
+  /* Check the parameters */
+  assert_param(IS_OB_IWDG_SOURCE(OB_IWDG));
+  assert_param(IS_OB_STOP_SOURCE(OB_STOP));
+  assert_param(IS_OB_STDBY_SOURCE(OB_STDBY));
+
+  /* Authorize the small information block programming */
+  FLASH-&gt;OPTKEYR = FLASH_KEY1;
+  FLASH-&gt;OPTKEYR = FLASH_KEY2;
+  
+  /* Wait for last operation to be completed */
+  status = FLASH_WaitForLastOperation(ProgramTimeout);
+  
+  if(status == FLASH_COMPLETE)
+  {  
+    /* Enable the Option Bytes Programming operation */
+    FLASH-&gt;CR |= CR_OPTPG_Set; 
+           
+    OB-&gt;USER = OB_IWDG | (uint16_t)(OB_STOP | (uint16_t)(OB_STDBY | ((uint16_t)0xF8))); 
+  
+    /* Wait for last operation to be completed */
+    status = FLASH_WaitForLastOperation(ProgramTimeout);
+    if(status != FLASH_TIMEOUT)
+    {
+      /* if the program operation is completed, disable the OPTPG Bit */
+      FLASH-&gt;CR &amp;= CR_OPTPG_Reset;
+    }
+  }    
+  /* Return the Option Byte program Status */
+  return status;
+}
+
+/**
+  * @brief  Returns the FLASH User Option Bytes values.
+  * @param  None
+  * @retval The FLASH User Option Bytes values:IWDG_SW(Bit0), RST_STOP(Bit1)
+  *   and RST_STDBY(Bit2).
+  */
+uint32_t FLASH_GetUserOptionByte(void)
+{
+  /* Return the User Option Byte */
+  return (uint32_t)(FLASH-&gt;OBR &gt;&gt; 2);
+}
+
+/**
+  * @brief  Returns the FLASH Write Protection Option Bytes Register value.
+  * @param  None
+  * @retval The FLASH Write Protection  Option Bytes Register value
+  */
+uint32_t FLASH_GetWriteProtectionOptionByte(void)
+{
+  /* Return the Falsh write protection Register value */
+  return (uint32_t)(FLASH-&gt;WRPR);
+}
+
+/**
+  * @brief  Checks whether the FLASH Read Out Protection Status is set or not.
+  * @param  None
+  * @retval FLASH ReadOut Protection Status(SET or RESET)
+  */
+FlagStatus FLASH_GetReadOutProtectionStatus(void)
+{
+  FlagStatus readoutstatus = RESET;
+  if ((FLASH-&gt;OBR &amp; RDPRT_Mask) != (uint32_t)RESET)
+  {
+    readoutstatus = SET;
+  }
+  else
+  {
+    readoutstatus = RESET;
+  }
+  return readoutstatus;
+}
+
+/**
+  * @brief  Checks whether the FLASH Prefetch Buffer status is set or not.
+  * @param  None
+  * @retval FLASH Prefetch Buffer Status (SET or RESET).
+  */
+FlagStatus FLASH_GetPrefetchBufferStatus(void)
+{
+  FlagStatus bitstatus = RESET;
+  
+  if ((FLASH-&gt;ACR &amp; ACR_PRFTBS_Mask) != (uint32_t)RESET)
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  /* Return the new state of FLASH Prefetch Buffer Status (SET or RESET) */
+  return bitstatus; 
+}
+
+/**
+  * @brief  Enables or disables the specified FLASH interrupts.
+  * @param  FLASH_IT: specifies the FLASH interrupt sources to be enabled or disabled.
+  *   This parameter can be any combination of the following values:
+  *     @arg FLASH_IT_ERROR: FLASH Error Interrupt
+  *     @arg FLASH_IT_EOP: FLASH end of operation Interrupt
+  * @param  NewState: new state of the specified Flash interrupts.
+  *   This parameter can be: ENABLE or DISABLE.      
+  * @retval None 
+  */
+void FLASH_ITConfig(uint16_t FLASH_IT, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FLASH_IT(FLASH_IT)); 
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if(NewState != DISABLE)
+  {
+    /* Enable the interrupt sources */
+    FLASH-&gt;CR |= FLASH_IT;
+  }
+  else
+  {
+    /* Disable the interrupt sources */
+    FLASH-&gt;CR &amp;= ~(uint32_t)FLASH_IT;
+  }
+}
+
+/**
+  * @brief  Checks whether the specified FLASH flag is set or not.
+  * @param  FLASH_FLAG: specifies the FLASH flag to check.
+  *   This parameter can be one of the following values:
+  *     @arg FLASH_FLAG_BSY: FLASH Busy flag           
+  *     @arg FLASH_FLAG_PGERR: FLASH Program error flag       
+  *     @arg FLASH_FLAG_WRPRTERR: FLASH Write protected error flag      
+  *     @arg FLASH_FLAG_EOP: FLASH End of Operation flag           
+  *     @arg FLASH_FLAG_OPTERR:  FLASH Option Byte error flag     
+  * @retval The new state of FLASH_FLAG (SET or RESET).
+  */
+FlagStatus FLASH_GetFlagStatus(uint16_t FLASH_FLAG)
+{
+  FlagStatus bitstatus = RESET;
+  /* Check the parameters */
+  assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG)) ;
+  if(FLASH_FLAG == FLASH_FLAG_OPTERR) 
+  {
+    if((FLASH-&gt;OBR &amp; FLASH_FLAG_OPTERR) != (uint32_t)RESET)
+    {
+      bitstatus = SET;
+    }
+    else
+    {
+      bitstatus = RESET;
+    }
+  }
+  else
+  {
+   if((FLASH-&gt;SR &amp; FLASH_FLAG) != (uint32_t)RESET)
+    {
+      bitstatus = SET;
+    }
+    else
+    {
+      bitstatus = RESET;
+    }
+  }
+  /* Return the new state of FLASH_FLAG (SET or RESET) */
+  return bitstatus;
+}
+
+/**
+  * @brief  Clears the FLASH&#146;s pending flags.
+  * @param  FLASH_FLAG: specifies the FLASH flags to clear.
+  *   This parameter can be any combination of the following values:         
+  *     @arg FLASH_FLAG_PGERR: FLASH Program error flag       
+  *     @arg FLASH_FLAG_WRPRTERR: FLASH Write protected error flag      
+  *     @arg FLASH_FLAG_EOP: FLASH End of Operation flag           
+  * @retval None
+  */
+void FLASH_ClearFlag(uint16_t FLASH_FLAG)
+{
+  /* Check the parameters */
+  assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG)) ;
+  
+  /* Clear the flags */
+  FLASH-&gt;SR = FLASH_FLAG;
+}
+
+/**
+  * @brief  Returns the FLASH Status.
+  * @param  None
+  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PG,
+  *   FLASH_ERROR_WRP or FLASH_COMPLETE
+  */
+FLASH_Status FLASH_GetStatus(void)
+{
+  FLASH_Status flashstatus = FLASH_COMPLETE;
+  
+  if((FLASH-&gt;SR &amp; FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
+  {
+    flashstatus = FLASH_BUSY;
+  }
+  else 
+  {  
+    if((FLASH-&gt;SR &amp; FLASH_FLAG_PGERR) != 0)
+    { 
+      flashstatus = FLASH_ERROR_PG;
+    }
+    else 
+    {
+      if((FLASH-&gt;SR &amp; FLASH_FLAG_WRPRTERR) != 0 )
+      {
+        flashstatus = FLASH_ERROR_WRP;
+      }
+      else
+      {
+        flashstatus = FLASH_COMPLETE;
+      }
+    }
+  }
+  /* Return the Flash Status */
+  return flashstatus;
+}
+
+/**
+  * @brief  Waits for a Flash operation to complete or a TIMEOUT to occur.
+  * @param  Timeout: FLASH progamming Timeout
+  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
+  *   FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
+  */
+FLASH_Status FLASH_WaitForLastOperation(uint32_t Timeout)
+{ 
+  FLASH_Status status = FLASH_COMPLETE;
+   
+  /* Check for the Flash Status */
+  status = FLASH_GetStatus();
+  /* Wait for a Flash operation to complete or a TIMEOUT to occur */
+  while((status == FLASH_BUSY) &amp;&amp; (Timeout != 0x00))
+  {
+    delay();
+    status = FLASH_GetStatus();
+    Timeout--;
+  }
+  if(Timeout == 0x00 )
+  {
+    status = FLASH_TIMEOUT;
+  }
+  /* Return the operation status */
+  return status;
+}
+
+/**
+  * @brief  Inserts a time delay.
+  * @param  None
+  * @retval None
+  */
+static void delay(void)
+{
+  __IO uint32_t i = 0;
+  for(i = 0xFF; i != 0; i--)
+  {
+  }
+}
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2009 STMicroelectronics *****END OF FILE****/

Added: trunk/src/platform/stm32/FWLib/library/src/stm32f10x_flash.o
===================================================================
--- trunk/src/platform/stm32/FWLib/library/src/stm32f10x_flash.o	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/src/stm32f10x_flash.o	2009-07-08 23:39:34 UTC (rev 354)
@@ -0,0 +1,34 @@
+ELF
+i&#234;a&#224;(&#208;&quot;iA&#246;&#223;s&#234;#ap&#189;
+i&#234;a&#189;
+M	

+
+
+
+
+W
+W
+X
+X
+X
+X
+X
+X
+X
+X
+X
+X
+X
+X
+X
+X
+X
+X
+X
+X
+X
+X
+X
+X
+X
+X
\ No newline at end of file

Modified: trunk/src/platform/stm32/FWLib/library/src/stm32f10x_fsmc.c
===================================================================
--- trunk/src/platform/stm32/FWLib/library/src/stm32f10x_fsmc.c	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/src/stm32f10x_fsmc.c	2009-07-08 23:39:34 UTC (rev 354)
@@ -1,857 +1,858 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_fsmc.c
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file provides all the FSMC firmware functions.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
-
-/* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_fsmc.h&quot;
-#include &quot;stm32f10x_rcc.h&quot;
-
-/* Private typedef -----------------------------------------------------------*/
-/* Private define ------------------------------------------------------------*/
-/* --------------------- FSMC registers bit mask ---------------------------- */
-/* FSMC BCRx Mask */
-#define BCR_MBKEN_Set                       ((u32)0x00000001)
-#define BCR_MBKEN_Reset                     ((u32)0x000FFFFE)
-#define BCR_FACCEN_Set                      ((u32)0x00000040)
-
-/* FSMC PCRx Mask */
-#define PCR_PBKEN_Set                       ((u32)0x00000004)
-#define PCR_PBKEN_Reset                     ((u32)0x000FFFFB)
-#define PCR_ECCEN_Set                       ((u32)0x00000040)
-#define PCR_ECCEN_Reset                     ((u32)0x000FFFBF)
-#define PCR_MemoryType_NAND                 ((u32)0x00000008)
-
-/* Private macro -------------------------------------------------------------*/
-/* Private variables ---------------------------------------------------------*/
-/* Private function prototypes -----------------------------------------------*/
-/* Private functions ---------------------------------------------------------*/
-
-/*******************************************************************************
-* Function Name  : FSMC_NORSRAMDeInit
-* Description    : Deinitializes the FSMC NOR/SRAM Banks registers to their default 
-*                  reset values.
-* Input          : - FSMC_Bank: specifies the FSMC Bank to be used
-*                    This parameter can be one of the following values:
-*                       - FSMC_Bank1_NORSRAM1: FSMC Bank1 NOR/SRAM1  
-*                       - FSMC_Bank1_NORSRAM2: FSMC Bank1 NOR/SRAM2 
-*                       - FSMC_Bank1_NORSRAM3: FSMC Bank1 NOR/SRAM3 
-*                       - FSMC_Bank1_NORSRAM4: FSMC Bank1 NOR/SRAM4                       
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void FSMC_NORSRAMDeInit(u32 FSMC_Bank)
-{
-  /* Check the parameter */
-  assert_param(IS_FSMC_NORSRAM_BANK(FSMC_Bank));
-  
-  /* FSMC_Bank1_NORSRAM1 */
-  if(FSMC_Bank == FSMC_Bank1_NORSRAM1)
-  {
-    FSMC_Bank1-&gt;BTCR[FSMC_Bank] = 0x000030DB;    
-  }
-  /* FSMC_Bank1_NORSRAM2,  FSMC_Bank1_NORSRAM3 or FSMC_Bank1_NORSRAM4 */
-  else
-  {   
-    FSMC_Bank1-&gt;BTCR[FSMC_Bank] = 0x000030D2; 
-  }
-
-  FSMC_Bank1-&gt;BTCR[FSMC_Bank + 1] = 0x0FFFFFFF;
-  FSMC_Bank1E-&gt;BWTR[FSMC_Bank] = 0x0FFFFFFF;  
-}
-
-/*******************************************************************************
-* Function Name  : FSMC_NANDDeInit
-* Description    : Deinitializes the FSMC NAND Banks registers to their default 
-*                  reset values.
-* Input          : - FSMC_Bank: specifies the FSMC Bank to be used
-*                    This parameter can be one of the following values:
-*                       - FSMC_Bank2_NAND: FSMC Bank2 NAND 
-*                       - FSMC_Bank3_NAND: FSMC Bank3 NAND                       
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void FSMC_NANDDeInit(u32 FSMC_Bank)
-{
-  /* Check the parameter */
-  assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
-  
-  if(FSMC_Bank == FSMC_Bank2_NAND)
-  {
-    /* Set the FSMC_Bank2 registers to their reset values */
-    FSMC_Bank2-&gt;PCR2 = 0x00000018;
-    FSMC_Bank2-&gt;SR2 = 0x00000040;
-    FSMC_Bank2-&gt;PMEM2 = 0xFCFCFCFC;
-    FSMC_Bank2-&gt;PATT2 = 0xFCFCFCFC;  
-  }
-  /* FSMC_Bank3_NAND */  
-  else
-  {
-    /* Set the FSMC_Bank3 registers to their reset values */
-    FSMC_Bank3-&gt;PCR3 = 0x00000018;
-    FSMC_Bank3-&gt;SR3 = 0x00000040;
-    FSMC_Bank3-&gt;PMEM3 = 0xFCFCFCFC;
-    FSMC_Bank3-&gt;PATT3 = 0xFCFCFCFC; 
-  }  
-}
-
-/*******************************************************************************
-* Function Name  : FSMC_PCCARDDeInit
-* Description    : Deinitializes the FSMC PCCARD Bank registers to their default 
-*                  reset values.
-* Input          : None                       
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void FSMC_PCCARDDeInit(void)
-{
-  /* Set the FSMC_Bank4 registers to their reset values */
-  FSMC_Bank4-&gt;PCR4 = 0x00000018; 
-  FSMC_Bank4-&gt;SR4 = 0x00000000;	
-  FSMC_Bank4-&gt;PMEM4 = 0xFCFCFCFC;
-  FSMC_Bank4-&gt;PATT4 = 0xFCFCFCFC;
-  FSMC_Bank4-&gt;PIO4 = 0xFCFCFCFC;
-}
-
-/*******************************************************************************
-* Function Name  : FSMC_NORSRAMInit
-* Description    : Initializes the FSMC NOR/SRAM Banks according to the 
-*                  specified parameters in the FSMC_NORSRAMInitStruct.
-* Input          : - FSMC_NORSRAMInitStruct : pointer to a FSMC_NORSRAMInitTypeDef
-*                  structure that contains the configuration information for 
-*                  the FSMC NOR/SRAM specified Banks.                       
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void FSMC_NORSRAMInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
-{ 
-  /* Check the parameters */
-  assert_param(IS_FSMC_NORSRAM_BANK(FSMC_NORSRAMInitStruct-&gt;FSMC_Bank));
-  assert_param(IS_FSMC_MUX(FSMC_NORSRAMInitStruct-&gt;FSMC_DataAddressMux));
-  assert_param(IS_FSMC_MEMORY(FSMC_NORSRAMInitStruct-&gt;FSMC_MemoryType));
-  assert_param(IS_FSMC_MEMORY_WIDTH(FSMC_NORSRAMInitStruct-&gt;FSMC_MemoryDataWidth));
-  assert_param(IS_FSMC_BURSTMODE(FSMC_NORSRAMInitStruct-&gt;FSMC_BurstAccessMode));
-  assert_param(IS_FSMC_WAIT_POLARITY(FSMC_NORSRAMInitStruct-&gt;FSMC_WaitSignalPolarity));
-  assert_param(IS_FSMC_WRAP_MODE(FSMC_NORSRAMInitStruct-&gt;FSMC_WrapMode));
-  assert_param(IS_FSMC_WAIT_SIGNAL_ACTIVE(FSMC_NORSRAMInitStruct-&gt;FSMC_WaitSignalActive));
-  assert_param(IS_FSMC_WRITE_OPERATION(FSMC_NORSRAMInitStruct-&gt;FSMC_WriteOperation));
-  assert_param(IS_FSMC_WAITE_SIGNAL(FSMC_NORSRAMInitStruct-&gt;FSMC_WaitSignal));
-  assert_param(IS_FSMC_EXTENDED_MODE(FSMC_NORSRAMInitStruct-&gt;FSMC_ExtendedMode));
-  assert_param(IS_FSMC_WRITE_BURST(FSMC_NORSRAMInitStruct-&gt;FSMC_WriteBurst));  
-  assert_param(IS_FSMC_ADDRESS_SETUP_TIME(FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_AddressSetupTime));
-  assert_param(IS_FSMC_ADDRESS_HOLD_TIME(FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_AddressHoldTime));
-  assert_param(IS_FSMC_DATASETUP_TIME(FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_DataSetupTime));
-  assert_param(IS_FSMC_TURNAROUND_TIME(FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_BusTurnAroundDuration));
-  assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_CLKDivision));
-  assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_DataLatency));
-  assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_AccessMode)); 
-  
-  /* Bank1 NOR/SRAM control register configuration */ 
-  FSMC_Bank1-&gt;BTCR[FSMC_NORSRAMInitStruct-&gt;FSMC_Bank] = 
-            (u32)FSMC_NORSRAMInitStruct-&gt;FSMC_DataAddressMux |
-            FSMC_NORSRAMInitStruct-&gt;FSMC_MemoryType |
-            FSMC_NORSRAMInitStruct-&gt;FSMC_MemoryDataWidth |
-            FSMC_NORSRAMInitStruct-&gt;FSMC_BurstAccessMode |
-            FSMC_NORSRAMInitStruct-&gt;FSMC_WaitSignalPolarity |
-            FSMC_NORSRAMInitStruct-&gt;FSMC_WrapMode |
-            FSMC_NORSRAMInitStruct-&gt;FSMC_WaitSignalActive |
-            FSMC_NORSRAMInitStruct-&gt;FSMC_WriteOperation |
-            FSMC_NORSRAMInitStruct-&gt;FSMC_WaitSignal |
-            FSMC_NORSRAMInitStruct-&gt;FSMC_ExtendedMode |
-            FSMC_NORSRAMInitStruct-&gt;FSMC_WriteBurst;
-
-  if(FSMC_NORSRAMInitStruct-&gt;FSMC_MemoryType == FSMC_MemoryType_NOR)
-  {
-    FSMC_Bank1-&gt;BTCR[FSMC_NORSRAMInitStruct-&gt;FSMC_Bank] |= (u32)BCR_FACCEN_Set;
-  }
-
-  /* Bank1 NOR/SRAM timing register configuration */
-  FSMC_Bank1-&gt;BTCR[FSMC_NORSRAMInitStruct-&gt;FSMC_Bank+1] = 
-            (u32)FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_AddressSetupTime |
-            (FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_AddressHoldTime &lt;&lt; 4) |
-            (FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_DataSetupTime &lt;&lt; 8) |
-            (FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_BusTurnAroundDuration &lt;&lt; 16) |
-            (FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_CLKDivision &lt;&lt; 20) |
-            (FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_DataLatency &lt;&lt; 24) |
-             FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_AccessMode;
-            
-
-    
-  /* Bank1 NOR/SRAM timing register for write configuration, if extended mode is used */
-  if(FSMC_NORSRAMInitStruct-&gt;FSMC_ExtendedMode == FSMC_ExtendedMode_Enable)
-  {
-    assert_param(IS_FSMC_ADDRESS_SETUP_TIME(FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_AddressSetupTime));
-    assert_param(IS_FSMC_ADDRESS_HOLD_TIME(FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_AddressHoldTime));
-    assert_param(IS_FSMC_DATASETUP_TIME(FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_DataSetupTime));
-    assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_CLKDivision));
-    assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_DataLatency));
-    assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_AccessMode));
-
-    FSMC_Bank1E-&gt;BWTR[FSMC_NORSRAMInitStruct-&gt;FSMC_Bank] = 
-              (u32)FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_AddressSetupTime |
-              (FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_AddressHoldTime &lt;&lt; 4 )|
-              (FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_DataSetupTime &lt;&lt; 8) |
-              (FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_CLKDivision &lt;&lt; 20) |
-              (FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_DataLatency &lt;&lt; 24) |
-               FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_AccessMode;
-  }
-  else
-  {
-    FSMC_Bank1E-&gt;BWTR[FSMC_NORSRAMInitStruct-&gt;FSMC_Bank] = 0x0FFFFFFF;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : FSMC_NANDInit
-* Description    : Initializes the FSMC NAND Banks according to the specified 
-*                  parameters in the FSMC_NANDInitStruct.
-* Input          : - FSMC_NANDInitStruct : pointer to a FSMC_NANDInitTypeDef 
-*                    structure that contains the configuration information for 
-*                    the FSMC NAND specified Banks.                       
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void FSMC_NANDInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)
-{
-  u32 tmppcr = 0x00000000, tmppmem = 0x00000000, tmppatt = 0x00000000; 
-    
-  /* Check the parameters */
-  assert_param( IS_FSMC_NAND_BANK(FSMC_NANDInitStruct-&gt;FSMC_Bank));
-  assert_param( IS_FSMC_WAIT_FEATURE(FSMC_NANDInitStruct-&gt;FSMC_Waitfeature));
-  assert_param( IS_FSMC_DATA_WIDTH(FSMC_NANDInitStruct-&gt;FSMC_MemoryDataWidth));
-  assert_param( IS_FSMC_ECC_STATE(FSMC_NANDInitStruct-&gt;FSMC_ECC));
-  assert_param( IS_FSMC_ECCPAGE_SIZE(FSMC_NANDInitStruct-&gt;FSMC_ECCPageSize));
-  assert_param( IS_FSMC_ADDRESS_LOW_MAPPING(FSMC_NANDInitStruct-&gt;FSMC_AddressLowMapping));
-  assert_param( IS_FSMC_TCLR_TIME(FSMC_NANDInitStruct-&gt;FSMC_TCLRSetupTime));
-  assert_param( IS_FSMC_TAR_TIME(FSMC_NANDInitStruct-&gt;FSMC_TARSetupTime));
-
-  assert_param(IS_FSMC_SETUP_TIME(FSMC_NANDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_SetupTime));
-  assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_WaitSetupTime));
-  assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_HoldSetupTime));
-  assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_HiZSetupTime));
-
-  assert_param(IS_FSMC_SETUP_TIME(FSMC_NANDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_SetupTime));
-  assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_WaitSetupTime));
-  assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_HoldSetupTime));
-  assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_HiZSetupTime));
-  
-  /* Set the tmppcr value according to FSMC_NANDInitStruct parameters */
-  tmppcr = (u32)FSMC_NANDInitStruct-&gt;FSMC_Waitfeature |
-            PCR_MemoryType_NAND |
-            FSMC_NANDInitStruct-&gt;FSMC_MemoryDataWidth |
-            FSMC_NANDInitStruct-&gt;FSMC_ECC |
-            FSMC_NANDInitStruct-&gt;FSMC_ECCPageSize |
-            FSMC_NANDInitStruct-&gt;FSMC_AddressLowMapping |
-            (FSMC_NANDInitStruct-&gt;FSMC_TCLRSetupTime &lt;&lt; 9 )|
-            (FSMC_NANDInitStruct-&gt;FSMC_TARSetupTime &lt;&lt; 13);
-            
-  /* Set tmppmem value according to FSMC_CommonSpaceTimingStructure parameters */
-  tmppmem = (u32)FSMC_NANDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_SetupTime |
-            (FSMC_NANDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_WaitSetupTime &lt;&lt; 8) |
-            (FSMC_NANDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_HoldSetupTime &lt;&lt; 16)|
-            (FSMC_NANDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_HiZSetupTime &lt;&lt; 24); 
-            
-  /* Set tmppatt value according to FSMC_AttributeSpaceTimingStructure parameters */
-  tmppatt = (u32)FSMC_NANDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_SetupTime |
-            (FSMC_NANDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_WaitSetupTime &lt;&lt; 8) |
-            (FSMC_NANDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_HoldSetupTime &lt;&lt; 16)|
-            (FSMC_NANDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_HiZSetupTime &lt;&lt; 24);
-  
-  if(FSMC_NANDInitStruct-&gt;FSMC_Bank == FSMC_Bank2_NAND)
-  {
-    /* FSMC_Bank2_NAND registers configuration */
-    FSMC_Bank2-&gt;PCR2 = tmppcr;
-    FSMC_Bank2-&gt;PMEM2 = tmppmem;
-    FSMC_Bank2-&gt;PATT2 = tmppatt;
-  }
-  else
-  {
-    /* FSMC_Bank3_NAND registers configuration */
-    FSMC_Bank3-&gt;PCR3 = tmppcr;
-    FSMC_Bank3-&gt;PMEM3 = tmppmem;
-    FSMC_Bank3-&gt;PATT3 = tmppatt;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : FSMC_PCCARDInit
-* Description    : Initializes the FSMC PCCARD Bank according to the specified 
-*                  parameters in the FSMC_PCCARDInitStruct.
-* Input          : - FSMC_PCCARDInitStruct : pointer to a FSMC_PCCARDInitTypeDef
-*                    structure that contains the configuration information for 
-*                    the FSMC PCCARD Bank.                       
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void FSMC_PCCARDInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct)
-{
-  /* Check the parameters */
-  assert_param(IS_FSMC_WAIT_FEATURE(FSMC_PCCARDInitStruct-&gt;FSMC_Waitfeature));
-  assert_param(IS_FSMC_ADDRESS_LOW_MAPPING(FSMC_PCCARDInitStruct-&gt;FSMC_AddressLowMapping));
-  assert_param(IS_FSMC_TCLR_TIME(FSMC_PCCARDInitStruct-&gt;FSMC_TCLRSetupTime));
-  assert_param(IS_FSMC_TAR_TIME(FSMC_PCCARDInitStruct-&gt;FSMC_TARSetupTime));
-
- 
-  assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_SetupTime));
-  assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_WaitSetupTime));
-  assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_HoldSetupTime));
-  assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_HiZSetupTime));
-  
-  assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_SetupTime));
-  assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_WaitSetupTime));
-  assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_HoldSetupTime));
-  assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_HiZSetupTime));
-
-  assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct-&gt;FSMC_IOSpaceTimingStruct-&gt;FSMC_SetupTime));
-  assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct-&gt;FSMC_IOSpaceTimingStruct-&gt;FSMC_WaitSetupTime));
-  assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct-&gt;FSMC_IOSpaceTimingStruct-&gt;FSMC_HoldSetupTime));
-  assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct-&gt;FSMC_IOSpaceTimingStruct-&gt;FSMC_HiZSetupTime));
-  
-  /* Set the PCR4 register value according to FSMC_PCCARDInitStruct parameters */
-  FSMC_Bank4-&gt;PCR4 = (u32)FSMC_PCCARDInitStruct-&gt;FSMC_Waitfeature |
-                     FSMC_MemoryDataWidth_16b |  
-                     FSMC_PCCARDInitStruct-&gt;FSMC_AddressLowMapping |
-                     (FSMC_PCCARDInitStruct-&gt;FSMC_TCLRSetupTime &lt;&lt; 9) |
-                     (FSMC_PCCARDInitStruct-&gt;FSMC_TARSetupTime &lt;&lt; 13);
-            
-  /* Set PMEM4 register value according to FSMC_CommonSpaceTimingStructure parameters */
-  FSMC_Bank4-&gt;PMEM4 = (u32)FSMC_PCCARDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_SetupTime |
-                      (FSMC_PCCARDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_WaitSetupTime &lt;&lt; 8) |
-                      (FSMC_PCCARDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_HoldSetupTime &lt;&lt; 16)|
-                      (FSMC_PCCARDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_HiZSetupTime &lt;&lt; 24); 
-            
-  /* Set PATT4 register value according to FSMC_AttributeSpaceTimingStructure parameters */
-  FSMC_Bank4-&gt;PATT4 = (u32)FSMC_PCCARDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_SetupTime |
-                      (FSMC_PCCARDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_WaitSetupTime &lt;&lt; 8) |
-                      (FSMC_PCCARDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_HoldSetupTime &lt;&lt; 16)|
-                      (FSMC_PCCARDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_HiZSetupTime &lt;&lt; 24);	
-            
-  /* Set PIO4 register value according to FSMC_IOSpaceTimingStructure parameters */
-  FSMC_Bank4-&gt;PIO4 = (u32)FSMC_PCCARDInitStruct-&gt;FSMC_IOSpaceTimingStruct-&gt;FSMC_SetupTime |
-                     (FSMC_PCCARDInitStruct-&gt;FSMC_IOSpaceTimingStruct-&gt;FSMC_WaitSetupTime &lt;&lt; 8) |
-                     (FSMC_PCCARDInitStruct-&gt;FSMC_IOSpaceTimingStruct-&gt;FSMC_HoldSetupTime &lt;&lt; 16)|
-                     (FSMC_PCCARDInitStruct-&gt;FSMC_IOSpaceTimingStruct-&gt;FSMC_HiZSetupTime &lt;&lt; 24);             
-}
-
-/*******************************************************************************
-* Function Name  : FSMC_NORSRAMStructInit
-* Description    : Fills each FSMC_NORSRAMInitStruct member with its default value.
-* Input          : - FSMC_NORSRAMInitStruct: pointer to a FSMC_NORSRAMInitTypeDef 
-*                    structure which will be initialized.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void FSMC_NORSRAMStructInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
-{  
-  /* Reset NOR/SRAM Init structure parameters values */
-  FSMC_NORSRAMInitStruct-&gt;FSMC_Bank = FSMC_Bank1_NORSRAM1;
-  FSMC_NORSRAMInitStruct-&gt;FSMC_DataAddressMux = FSMC_DataAddressMux_Enable;
-  FSMC_NORSRAMInitStruct-&gt;FSMC_MemoryType = FSMC_MemoryType_SRAM;
-  FSMC_NORSRAMInitStruct-&gt;FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
-  FSMC_NORSRAMInitStruct-&gt;FSMC_BurstAccessMode = FSMC_BurstAccessMode_Disable;
-  FSMC_NORSRAMInitStruct-&gt;FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low;
-  FSMC_NORSRAMInitStruct-&gt;FSMC_WrapMode = FSMC_WrapMode_Disable;
-  FSMC_NORSRAMInitStruct-&gt;FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;
-  FSMC_NORSRAMInitStruct-&gt;FSMC_WriteOperation = FSMC_WriteOperation_Enable;
-  FSMC_NORSRAMInitStruct-&gt;FSMC_WaitSignal = FSMC_WaitSignal_Enable;
-  FSMC_NORSRAMInitStruct-&gt;FSMC_ExtendedMode = FSMC_ExtendedMode_Disable;
-  FSMC_NORSRAMInitStruct-&gt;FSMC_WriteBurst = FSMC_WriteBurst_Disable;
-  FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_AddressSetupTime = 0xF;
-  FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_AddressHoldTime = 0xF;
-  FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_DataSetupTime = 0xFF;
-  FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_BusTurnAroundDuration = 0xF;
-  FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_CLKDivision = 0xF;
-  FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_DataLatency = 0xF;
-  FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_AccessMode = FSMC_AccessMode_A; 
-  FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_AddressSetupTime = 0xF;
-  FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_AddressHoldTime = 0xF;
-  FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_DataSetupTime = 0xFF;
-  FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_BusTurnAroundDuration = 0xF;
-  FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_CLKDivision = 0xF;
-  FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_DataLatency = 0xF;
-  FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_AccessMode = FSMC_AccessMode_A;
-}
-
-/*******************************************************************************
-* Function Name  : FSMC_NANDStructInit
-* Description    : Fills each FSMC_NANDInitStruct member with its default value.
-* Input          : - FSMC_NORSRAMInitStruct: pointer to a FSMC_NANDInitTypeDef 
-*                    structure which will be initialized.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void FSMC_NANDStructInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)
-{ 
-  /* Reset NAND Init structure parameters values */
-  FSMC_NANDInitStruct-&gt;FSMC_Bank = FSMC_Bank2_NAND;
-  FSMC_NANDInitStruct-&gt;FSMC_Waitfeature = FSMC_Waitfeature_Disable;
-  FSMC_NANDInitStruct-&gt;FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
-  FSMC_NANDInitStruct-&gt;FSMC_ECC = FSMC_ECC_Disable;
-  FSMC_NANDInitStruct-&gt;FSMC_ECCPageSize = FSMC_ECCPageSize_256Bytes;
-  FSMC_NANDInitStruct-&gt;FSMC_AddressLowMapping = FSMC_AddressLowMapping_Direct;
-  FSMC_NANDInitStruct-&gt;FSMC_TCLRSetupTime = 0x0;
-  FSMC_NANDInitStruct-&gt;FSMC_TARSetupTime = 0x0;
-  FSMC_NANDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_SetupTime = 0xFC;
-  FSMC_NANDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_WaitSetupTime = 0xFC;
-  FSMC_NANDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_HoldSetupTime = 0xFC;
-  FSMC_NANDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_HiZSetupTime = 0xFC;
-  FSMC_NANDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_SetupTime = 0xFC;
-  FSMC_NANDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_WaitSetupTime = 0xFC;
-  FSMC_NANDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_HoldSetupTime = 0xFC;
-  FSMC_NANDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_HiZSetupTime = 0xFC;	  
-}
-
-/*******************************************************************************
-* Function Name  : FSMC_PCCARDStructInit
-* Description    : Fills each FSMC_PCCARDInitStruct member with its default value.
-* Input          : - FSMC_PCCARDInitStruct: pointer to a FSMC_PCCARDInitTypeDef 
-*                    structure which will be initialized.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void FSMC_PCCARDStructInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct)
-{
-  /* Reset PCCARD Init structure parameters values */
-  FSMC_PCCARDInitStruct-&gt;FSMC_Waitfeature = FSMC_Waitfeature_Disable;
-  FSMC_PCCARDInitStruct-&gt;FSMC_AddressLowMapping = FSMC_AddressLowMapping_Direct;
-  FSMC_PCCARDInitStruct-&gt;FSMC_TCLRSetupTime = 0x0;
-  FSMC_PCCARDInitStruct-&gt;FSMC_TARSetupTime = 0x0;
-  FSMC_PCCARDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_SetupTime = 0xFC;
-  FSMC_PCCARDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_WaitSetupTime = 0xFC;
-  FSMC_PCCARDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_HoldSetupTime = 0xFC;
-  FSMC_PCCARDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_HiZSetupTime = 0xFC;
-  FSMC_PCCARDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_SetupTime = 0xFC;
-  FSMC_PCCARDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_WaitSetupTime = 0xFC;
-  FSMC_PCCARDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_HoldSetupTime = 0xFC;
-  FSMC_PCCARDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_HiZSetupTime = 0xFC;	
-  FSMC_PCCARDInitStruct-&gt;FSMC_IOSpaceTimingStruct-&gt;FSMC_SetupTime = 0xFC;
-  FSMC_PCCARDInitStruct-&gt;FSMC_IOSpaceTimingStruct-&gt;FSMC_WaitSetupTime = 0xFC;
-  FSMC_PCCARDInitStruct-&gt;FSMC_IOSpaceTimingStruct-&gt;FSMC_HoldSetupTime = 0xFC;
-  FSMC_PCCARDInitStruct-&gt;FSMC_IOSpaceTimingStruct-&gt;FSMC_HiZSetupTime = 0xFC;
-}
-
-/*******************************************************************************
-* Function Name  : FSMC_NORSRAMCmd
-* Description    : Enables or disables the specified NOR/SRAM Memory Bank.
-* Input          : - FSMC_Bank: specifies the FSMC Bank to be used
-*                    This parameter can be one of the following values:
-*                       - FSMC_Bank1_NORSRAM1: FSMC Bank1 NOR/SRAM1  
-*                       - FSMC_Bank1_NORSRAM2: FSMC Bank1 NOR/SRAM2 
-*                       - FSMC_Bank1_NORSRAM3: FSMC Bank1 NOR/SRAM3 
-*                       - FSMC_Bank1_NORSRAM4: FSMC Bank1 NOR/SRAM4 
-*                : - NewState: new state of the FSMC_Bank.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void FSMC_NORSRAMCmd(u32 FSMC_Bank, FunctionalState NewState)
-{
-  assert_param(IS_FSMC_NORSRAM_BANK(FSMC_Bank));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected NOR/SRAM Bank by setting the PBKEN bit in the BCRx register */
-    FSMC_Bank1-&gt;BTCR[FSMC_Bank] |= BCR_MBKEN_Set;
-  }
-  else
-  {
-    /* Disable the selected NOR/SRAM Bank by clearing the PBKEN bit in the BCRx register */
-    FSMC_Bank1-&gt;BTCR[FSMC_Bank] &amp;= BCR_MBKEN_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : FSMC_NANDCmd
-* Description    : Enables or disables the specified NAND Memory Bank.
-* Input          : - FSMC_Bank: specifies the FSMC Bank to be used
-*                    This parameter can be one of the following values:
-*                       - FSMC_Bank2_NAND: FSMC Bank2 NAND 
-*                       - FSMC_Bank3_NAND: FSMC Bank3 NAND
-*                : - NewState: new state of the FSMC_Bank.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void FSMC_NANDCmd(u32 FSMC_Bank, FunctionalState NewState)
-{
-  assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected NAND Bank by setting the PBKEN bit in the PCRx register */
-    if(FSMC_Bank == FSMC_Bank2_NAND)
-    {
-      FSMC_Bank2-&gt;PCR2 |= PCR_PBKEN_Set;
-    }
-    else
-    {
-      FSMC_Bank3-&gt;PCR3 |= PCR_PBKEN_Set;
-    }
-  }
-  else
-  {
-    /* Disable the selected NAND Bank by clearing the PBKEN bit in the PCRx register */
-    if(FSMC_Bank == FSMC_Bank2_NAND)
-    {
-      FSMC_Bank2-&gt;PCR2 &amp;= PCR_PBKEN_Reset;
-    }
-    else
-    {
-      FSMC_Bank3-&gt;PCR3 &amp;= PCR_PBKEN_Reset;
-    }
-  }
-}
-
-/*******************************************************************************
-* Function Name  : FSMC_PCCARDCmd
-* Description    : Enables or disables the PCCARD Memory Bank.
-* Input          : - NewState: new state of the PCCARD Memory Bank.  
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void FSMC_PCCARDCmd(FunctionalState NewState)
-{
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  
-  if (NewState != DISABLE)
-  {
-    /* Enable the PCCARD Bank by setting the PBKEN bit in the PCR4 register */
-    FSMC_Bank4-&gt;PCR4 |= PCR_PBKEN_Set;
-  }
-  else
-  {
-    /* Disable the PCCARD Bank by clearing the PBKEN bit in the PCR4 register */
-    FSMC_Bank4-&gt;PCR4 &amp;= PCR_PBKEN_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : FSMC_NANDECCCmd
-* Description    : Enables or disables the FSMC NAND ECC feature.
-* Input          : - FSMC_Bank: specifies the FSMC Bank to be used
-*                    This parameter can be one of the following values:
-*                       - FSMC_Bank2_NAND: FSMC Bank2 NAND 
-*                       - FSMC_Bank3_NAND: FSMC Bank3 NAND
-*                : - NewState: new state of the FSMC NAND ECC feature.  
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void FSMC_NANDECCCmd(u32 FSMC_Bank, FunctionalState NewState)
-{
-  assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected NAND Bank ECC function by setting the ECCEN bit in the PCRx register */
-    if(FSMC_Bank == FSMC_Bank2_NAND)
-    {
-      FSMC_Bank2-&gt;PCR2 |= PCR_ECCEN_Set;
-    }
-    else
-    {
-      FSMC_Bank3-&gt;PCR3 |= PCR_ECCEN_Set;
-    }
-  }
-  else
-  {
-    /* Disable the selected NAND Bank ECC function by clearing the ECCEN bit in the PCRx register */
-    if(FSMC_Bank == FSMC_Bank2_NAND)
-    {
-      FSMC_Bank2-&gt;PCR2 &amp;= PCR_ECCEN_Reset;
-    }
-    else
-    {
-      FSMC_Bank3-&gt;PCR3 &amp;= PCR_ECCEN_Reset;
-    }
-  }
-}
-
-/*******************************************************************************
-* Function Name  : FSMC_GetECC
-* Description    : Returns the error correction code register value.
-* Input          : - FSMC_Bank: specifies the FSMC Bank to be used
-*                    This parameter can be one of the following values:
-*                       - FSMC_Bank2_NAND: FSMC Bank2 NAND 
-*                       - FSMC_Bank3_NAND: FSMC Bank3 NAND
-* Output         : None
-* Return         : The Error Correction Code (ECC) value.
-*******************************************************************************/
-u32 FSMC_GetECC(u32 FSMC_Bank)
-{
-  u32 eccval = 0x00000000;
-  
-  if(FSMC_Bank == FSMC_Bank2_NAND)
-  {
-    /* Get the ECCR2 register value */
-    eccval = FSMC_Bank2-&gt;ECCR2;
-  }
-  else
-  {
-    /* Get the ECCR3 register value */
-    eccval = FSMC_Bank3-&gt;ECCR3;
-  }
-  /* Return the error correction code value */
-  return(eccval);
-}
-
-/*******************************************************************************
-* Function Name  : FSMC_ITConfig
-* Description    : Enables or disables the specified FSMC interrupts.
-* Input          : - FSMC_Bank: specifies the FSMC Bank to be used
-*                    This parameter can be one of the following values:
-*                       - FSMC_Bank2_NAND: FSMC Bank2 NAND 
-*                       - FSMC_Bank3_NAND: FSMC Bank3 NAND
-*                       - FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
-*                  - FSMC_IT: specifies the FSMC interrupt sources to be
-*                    enabled or disabled.
-*                    This parameter can be any combination of the following values:
-*                       - FSMC_IT_RisingEdge: Rising edge detection interrupt. 
-*                       - FSMC_IT_Level: Level edge detection interrupt.                                  
-*                       - FSMC_IT_FallingEdge: Falling edge detection interrupt.
-*                  - NewState: new state of the specified FSMC interrupts.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void FSMC_ITConfig(u32 FSMC_Bank, u32 FSMC_IT, FunctionalState NewState)
-{
-  assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
-  assert_param(IS_FSMC_IT(FSMC_IT));	
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected FSMC_Bank2 interrupts */
-    if(FSMC_Bank == FSMC_Bank2_NAND)
-    {
-      FSMC_Bank2-&gt;SR2 |= FSMC_IT;
-    }
-    /* Enable the selected FSMC_Bank3 interrupts */
-    else if (FSMC_Bank == FSMC_Bank3_NAND)
-    {
-      FSMC_Bank3-&gt;SR3 |= FSMC_IT;
-    }
-    /* Enable the selected FSMC_Bank4 interrupts */
-    else
-    {
-      FSMC_Bank4-&gt;SR4 |= FSMC_IT;    
-    }
-  }
-  else
-  {
-    /* Disable the selected FSMC_Bank2 interrupts */
-    if(FSMC_Bank == FSMC_Bank2_NAND)
-    {
-      
-      FSMC_Bank2-&gt;SR2 &amp;= (u32)~FSMC_IT;
-    }
-    /* Disable the selected FSMC_Bank3 interrupts */
-    else if (FSMC_Bank == FSMC_Bank3_NAND)
-    {
-      FSMC_Bank3-&gt;SR3 &amp;= (u32)~FSMC_IT;
-    }
-    /* Disable the selected FSMC_Bank4 interrupts */
-    else
-    {
-      FSMC_Bank4-&gt;SR4 &amp;= (u32)~FSMC_IT;    
-    }
-  }
-}
-                  
-/*******************************************************************************
-* Function Name  : FSMC_GetFlagStatus
-* Description    : Checks whether the specified FSMC flag is set or not.
-* Input          : - FSMC_Bank: specifies the FSMC Bank to be used
-*                    This parameter can be one of the following values:
-*                       - FSMC_Bank2_NAND: FSMC Bank2 NAND 
-*                       - FSMC_Bank3_NAND: FSMC Bank3 NAND
-*                       - FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
-*                  - FSMC_FLAG: specifies the flag to check.
-*                    This parameter can be one of the following values:
-*                       - FSMC_FLAG_RisingEdge: Rising egde detection Flag.
-*                       - FSMC_FLAG_Level: Level detection Flag.
-*                       - FSMC_FLAG_FallingEdge: Falling egde detection Flag.
-*                       - FSMC_FLAG_FEMPT: Fifo empty Flag. 
-* Output         : None
-* Return         : The new state of FSMC_FLAG (SET or RESET).
-*******************************************************************************/                   
-FlagStatus FSMC_GetFlagStatus(u32 FSMC_Bank, u32 FSMC_FLAG)
-{
-  FlagStatus bitstatus = RESET;
-  u32 tmpsr = 0x00000000;
-  
-  /* Check the parameters */
-  assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));
-  assert_param(IS_FSMC_GET_FLAG(FSMC_FLAG));
-  
-  if(FSMC_Bank == FSMC_Bank2_NAND)
-  {
-    tmpsr = FSMC_Bank2-&gt;SR2;
-  }  
-  else if(FSMC_Bank == FSMC_Bank3_NAND)
-  {
-    tmpsr = FSMC_Bank3-&gt;SR3;
-  }
-  /* FSMC_Bank4_PCCARD*/
-  else
-  {
-    tmpsr = FSMC_Bank4-&gt;SR4;
-  } 
-  
-  /* Get the flag status */
-  if ((tmpsr &amp; FSMC_FLAG) != (u16)RESET )
-  {
-    bitstatus = SET;
-  }
-  else
-  {
-    bitstatus = RESET;
-  }
-  /* Return the flag status */
-  return bitstatus;
-}
-
-/*******************************************************************************
-* Function Name  : FSMC_ClearFlag
-* Description    : Clears the FSMC's pending flags.
-* Input          : - FSMC_Bank: specifies the FSMC Bank to be used
-*                    This parameter can be one of the following values:
-*                       - FSMC_Bank2_NAND: FSMC Bank2 NAND 
-*                       - FSMC_Bank3_NAND: FSMC Bank3 NAND
-*                       - FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
-*                  - FSMC_FLAG: specifies the flag to clear.
-*                    This parameter can be any combination of the following values:
-*                       - FSMC_FLAG_RisingEdge: Rising egde detection Flag.
-*                       - FSMC_FLAG_Level: Level detection Flag.
-*                       - FSMC_FLAG_FallingEdge: Falling egde detection Flag.
-* Output         : None
-* Return         : None
-*******************************************************************************/                   
-void FSMC_ClearFlag(u32 FSMC_Bank, u32 FSMC_FLAG)
-{
- /* Check the parameters */
-  assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));
-  assert_param(IS_FSMC_CLEAR_FLAG(FSMC_FLAG)) ;
-    
-  if(FSMC_Bank == FSMC_Bank2_NAND)
-  {
-    FSMC_Bank2-&gt;SR2 &amp;= ~FSMC_FLAG; 
-  }  
-  else if(FSMC_Bank == FSMC_Bank3_NAND)
-  {
-    FSMC_Bank3-&gt;SR3 &amp;= ~FSMC_FLAG;
-  }
-  /* FSMC_Bank4_PCCARD*/
-  else
-  {
-    FSMC_Bank4-&gt;SR4 &amp;= ~FSMC_FLAG;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : FSMC_GetITStatus
-* Description    : Checks whether the specified FSMC interrupt has occurred or not.
-* Input          : - FSMC_Bank: specifies the FSMC Bank to be used
-*                    This parameter can be one of the following values:
-*                       - FSMC_Bank2_NAND: FSMC Bank2 NAND 
-*                       - FSMC_Bank3_NAND: FSMC Bank3 NAND
-*                       - FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
-*                  - FSMC_IT: specifies the FSMC interrupt source to check.
-*                    This parameter can be one of the following values:
-*                       - FSMC_IT_RisingEdge: Rising edge detection interrupt. 
-*                       - FSMC_IT_Level: Level edge detection interrupt.                                  
-*                       - FSMC_IT_FallingEdge: Falling edge detection interrupt. 
-* Output         : None
-* Return         : The new state of FSMC_IT (SET or RESET).
-*******************************************************************************/ 
-ITStatus FSMC_GetITStatus(u32 FSMC_Bank, u32 FSMC_IT)
-{
-  ITStatus bitstatus = RESET;
-  u32 tmpsr = 0x0, itstatus = 0x0, itenable = 0x0; 
-  
-  /* Check the parameters */
-  assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
-  assert_param(IS_FSMC_GET_IT(FSMC_IT));
-  
-  if(FSMC_Bank == FSMC_Bank2_NAND)
-  {
-    tmpsr = FSMC_Bank2-&gt;SR2;
-  }  
-  else if(FSMC_Bank == FSMC_Bank3_NAND)
-  {
-    tmpsr = FSMC_Bank3-&gt;SR3;
-  }
-  /* FSMC_Bank4_PCCARD*/
-  else
-  {
-    tmpsr = FSMC_Bank4-&gt;SR4;
-  } 
-  
-  itstatus = tmpsr &amp; FSMC_IT;
-  
-  itenable = tmpsr &amp; (FSMC_IT &gt;&gt; 3);
-
-  if ((itstatus != (u32)RESET)  &amp;&amp; (itenable != (u32)RESET))
-  {
-    bitstatus = SET;
-  }
-  else
-  {
-    bitstatus = RESET;
-  }
-  return bitstatus; 
-}
-
-/*******************************************************************************
-* Function Name  : FSMC_ClearITPendingBit
-* Description    : Clears the FSMC's interrupt pending bits.
-* Input          : - FSMC_Bank: specifies the FSMC Bank to be used
-*                    This parameter can be one of the following values:
-*                       - FSMC_Bank2_NAND: FSMC Bank2 NAND 
-*                       - FSMC_Bank3_NAND: FSMC Bank3 NAND
-*                       - FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
-*                  - FSMC_IT: specifies the interrupt pending bit to clear.
-*                    This parameter can be any combination of the following values:
-*                       - FSMC_IT_RisingEdge: Rising edge detection interrupt. 
-*                       - FSMC_IT_Level: Level edge detection interrupt.                                  
-*                       - FSMC_IT_FallingEdge: Falling edge detection interrupt.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void FSMC_ClearITPendingBit(u32 FSMC_Bank, u32 FSMC_IT)
-{
-  /* Check the parameters */
-  assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
-  assert_param(IS_FSMC_IT(FSMC_IT));
-    
-  if(FSMC_Bank == FSMC_Bank2_NAND)
-  {
-    FSMC_Bank2-&gt;SR2 &amp;= ~(FSMC_IT &gt;&gt; 3); 
-  }  
-  else if(FSMC_Bank == FSMC_Bank3_NAND)
-  {
-    FSMC_Bank3-&gt;SR3 &amp;= ~(FSMC_IT &gt;&gt; 3);
-  }
-  /* FSMC_Bank4_PCCARD*/
-  else
-  {
-    FSMC_Bank4-&gt;SR4 &amp;= ~(FSMC_IT &gt;&gt; 3);
-  }
-}
-
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
+/**
+  ******************************************************************************
+  * @file    stm32f10x_fsmc.c
+  * @author  MCD Application Team
+  * @version V3.1.0
+  * @date    06/19/2009
+  * @brief   This file provides all the FSMC firmware functions.
+  ******************************************************************************
+  * @copy
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * &lt;h2&gt;&lt;center&gt;&copy; COPYRIGHT 2009 STMicroelectronics&lt;/center&gt;&lt;/h2&gt;
+  */ 
+
+/* Includes ------------------------------------------------------------------*/
+#include &quot;stm32f10x_fsmc.h&quot;
+#include &quot;stm32f10x_rcc.h&quot;
+
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup FSMC 
+  * @brief FSMC driver modules
+  * @{
+  */ 
+
+/** @defgroup FSMC_Private_TypesDefinitions
+  * @{
+  */ 
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_Private_Defines
+  * @{
+  */
+
+/* --------------------- FSMC registers bit mask ---------------------------- */
+
+/* FSMC BCRx Mask */
+#define BCR_MBKEN_Set                       ((uint32_t)0x00000001)
+#define BCR_MBKEN_Reset                     ((uint32_t)0x000FFFFE)
+#define BCR_FACCEN_Set                      ((uint32_t)0x00000040)
+
+/* FSMC PCRx Mask */
+#define PCR_PBKEN_Set                       ((uint32_t)0x00000004)
+#define PCR_PBKEN_Reset                     ((uint32_t)0x000FFFFB)
+#define PCR_ECCEN_Set                       ((uint32_t)0x00000040)
+#define PCR_ECCEN_Reset                     ((uint32_t)0x000FFFBF)
+#define PCR_MemoryType_NAND                 ((uint32_t)0x00000008)
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_Private_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_Private_Variables
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_Private_FunctionPrototypes
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_Private_Functions
+  * @{
+  */
+
+/**
+  * @brief  Deinitializes the FSMC NOR/SRAM Banks registers to their default 
+  *   reset values.
+  * @param  FSMC_Bank: specifies the FSMC Bank to be used
+  *   This parameter can be one of the following values:
+  *     @arg FSMC_Bank1_NORSRAM1: FSMC Bank1 NOR/SRAM1  
+  *     @arg FSMC_Bank1_NORSRAM2: FSMC Bank1 NOR/SRAM2 
+  *     @arg FSMC_Bank1_NORSRAM3: FSMC Bank1 NOR/SRAM3 
+  *     @arg FSMC_Bank1_NORSRAM4: FSMC Bank1 NOR/SRAM4 
+  * @retval None
+  */
+void FSMC_NORSRAMDeInit(uint32_t FSMC_Bank)
+{
+  /* Check the parameter */
+  assert_param(IS_FSMC_NORSRAM_BANK(FSMC_Bank));
+  
+  /* FSMC_Bank1_NORSRAM1 */
+  if(FSMC_Bank == FSMC_Bank1_NORSRAM1)
+  {
+    FSMC_Bank1-&gt;BTCR[FSMC_Bank] = 0x000030DB;    
+  }
+  /* FSMC_Bank1_NORSRAM2,  FSMC_Bank1_NORSRAM3 or FSMC_Bank1_NORSRAM4 */
+  else
+  {   
+    FSMC_Bank1-&gt;BTCR[FSMC_Bank] = 0x000030D2; 
+  }
+  FSMC_Bank1-&gt;BTCR[FSMC_Bank + 1] = 0x0FFFFFFF;
+  FSMC_Bank1E-&gt;BWTR[FSMC_Bank] = 0x0FFFFFFF;  
+}
+
+/**
+  * @brief  Deinitializes the FSMC NAND Banks registers to their default reset values.
+  * @param  FSMC_Bank: specifies the FSMC Bank to be used
+  *   This parameter can be one of the following values:
+  *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
+  *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND 
+  * @retval None
+  */
+void FSMC_NANDDeInit(uint32_t FSMC_Bank)
+{
+  /* Check the parameter */
+  assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
+  
+  if(FSMC_Bank == FSMC_Bank2_NAND)
+  {
+    /* Set the FSMC_Bank2 registers to their reset values */
+    FSMC_Bank2-&gt;PCR2 = 0x00000018;
+    FSMC_Bank2-&gt;SR2 = 0x00000040;
+    FSMC_Bank2-&gt;PMEM2 = 0xFCFCFCFC;
+    FSMC_Bank2-&gt;PATT2 = 0xFCFCFCFC;  
+  }
+  /* FSMC_Bank3_NAND */  
+  else
+  {
+    /* Set the FSMC_Bank3 registers to their reset values */
+    FSMC_Bank3-&gt;PCR3 = 0x00000018;
+    FSMC_Bank3-&gt;SR3 = 0x00000040;
+    FSMC_Bank3-&gt;PMEM3 = 0xFCFCFCFC;
+    FSMC_Bank3-&gt;PATT3 = 0xFCFCFCFC; 
+  }  
+}
+
+/**
+  * @brief  Deinitializes the FSMC PCCARD Bank registers to their default reset values.
+  * @param  None                       
+  * @retval None
+  */
+void FSMC_PCCARDDeInit(void)
+{
+  /* Set the FSMC_Bank4 registers to their reset values */
+  FSMC_Bank4-&gt;PCR4 = 0x00000018; 
+  FSMC_Bank4-&gt;SR4 = 0x00000000;	
+  FSMC_Bank4-&gt;PMEM4 = 0xFCFCFCFC;
+  FSMC_Bank4-&gt;PATT4 = 0xFCFCFCFC;
+  FSMC_Bank4-&gt;PIO4 = 0xFCFCFCFC;
+}
+
+/**
+  * @brief  Initializes the FSMC NOR/SRAM Banks according to the specified
+  *   parameters in the FSMC_NORSRAMInitStruct.
+  * @param  FSMC_NORSRAMInitStruct : pointer to a FSMC_NORSRAMInitTypeDef
+  *   structure that contains the configuration information for 
+  *   the FSMC NOR/SRAM specified Banks.                       
+  * @retval None
+  */
+void FSMC_NORSRAMInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
+{ 
+  /* Check the parameters */
+  assert_param(IS_FSMC_NORSRAM_BANK(FSMC_NORSRAMInitStruct-&gt;FSMC_Bank));
+  assert_param(IS_FSMC_MUX(FSMC_NORSRAMInitStruct-&gt;FSMC_DataAddressMux));
+  assert_param(IS_FSMC_MEMORY(FSMC_NORSRAMInitStruct-&gt;FSMC_MemoryType));
+  assert_param(IS_FSMC_MEMORY_WIDTH(FSMC_NORSRAMInitStruct-&gt;FSMC_MemoryDataWidth));
+  assert_param(IS_FSMC_BURSTMODE(FSMC_NORSRAMInitStruct-&gt;FSMC_BurstAccessMode));
+  assert_param(IS_FSMC_WAIT_POLARITY(FSMC_NORSRAMInitStruct-&gt;FSMC_WaitSignalPolarity));
+  assert_param(IS_FSMC_WRAP_MODE(FSMC_NORSRAMInitStruct-&gt;FSMC_WrapMode));
+  assert_param(IS_FSMC_WAIT_SIGNAL_ACTIVE(FSMC_NORSRAMInitStruct-&gt;FSMC_WaitSignalActive));
+  assert_param(IS_FSMC_WRITE_OPERATION(FSMC_NORSRAMInitStruct-&gt;FSMC_WriteOperation));
+  assert_param(IS_FSMC_WAITE_SIGNAL(FSMC_NORSRAMInitStruct-&gt;FSMC_WaitSignal));
+  assert_param(IS_FSMC_EXTENDED_MODE(FSMC_NORSRAMInitStruct-&gt;FSMC_ExtendedMode));
+  assert_param(IS_FSMC_WRITE_BURST(FSMC_NORSRAMInitStruct-&gt;FSMC_WriteBurst));  
+  assert_param(IS_FSMC_ADDRESS_SETUP_TIME(FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_AddressSetupTime));
+  assert_param(IS_FSMC_ADDRESS_HOLD_TIME(FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_AddressHoldTime));
+  assert_param(IS_FSMC_DATASETUP_TIME(FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_DataSetupTime));
+  assert_param(IS_FSMC_TURNAROUND_TIME(FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_BusTurnAroundDuration));
+  assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_CLKDivision));
+  assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_DataLatency));
+  assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_AccessMode)); 
+  
+  /* Bank1 NOR/SRAM control register configuration */ 
+  FSMC_Bank1-&gt;BTCR[FSMC_NORSRAMInitStruct-&gt;FSMC_Bank] = 
+            (uint32_t)FSMC_NORSRAMInitStruct-&gt;FSMC_DataAddressMux |
+            FSMC_NORSRAMInitStruct-&gt;FSMC_MemoryType |
+            FSMC_NORSRAMInitStruct-&gt;FSMC_MemoryDataWidth |
+            FSMC_NORSRAMInitStruct-&gt;FSMC_BurstAccessMode |
+            FSMC_NORSRAMInitStruct-&gt;FSMC_WaitSignalPolarity |
+            FSMC_NORSRAMInitStruct-&gt;FSMC_WrapMode |
+            FSMC_NORSRAMInitStruct-&gt;FSMC_WaitSignalActive |
+            FSMC_NORSRAMInitStruct-&gt;FSMC_WriteOperation |
+            FSMC_NORSRAMInitStruct-&gt;FSMC_WaitSignal |
+            FSMC_NORSRAMInitStruct-&gt;FSMC_ExtendedMode |
+            FSMC_NORSRAMInitStruct-&gt;FSMC_WriteBurst;
+  if(FSMC_NORSRAMInitStruct-&gt;FSMC_MemoryType == FSMC_MemoryType_NOR)
+  {
+    FSMC_Bank1-&gt;BTCR[FSMC_NORSRAMInitStruct-&gt;FSMC_Bank] |= (uint32_t)BCR_FACCEN_Set;
+  }
+  /* Bank1 NOR/SRAM timing register configuration */
+  FSMC_Bank1-&gt;BTCR[FSMC_NORSRAMInitStruct-&gt;FSMC_Bank+1] = 
+            (uint32_t)FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_AddressSetupTime |
+            (FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_AddressHoldTime &lt;&lt; 4) |
+            (FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_DataSetupTime &lt;&lt; 8) |
+            (FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_BusTurnAroundDuration &lt;&lt; 16) |
+            (FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_CLKDivision &lt;&lt; 20) |
+            (FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_DataLatency &lt;&lt; 24) |
+             FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_AccessMode;
+            
+    
+  /* Bank1 NOR/SRAM timing register for write configuration, if extended mode is used */
+  if(FSMC_NORSRAMInitStruct-&gt;FSMC_ExtendedMode == FSMC_ExtendedMode_Enable)
+  {
+    assert_param(IS_FSMC_ADDRESS_SETUP_TIME(FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_AddressSetupTime));
+    assert_param(IS_FSMC_ADDRESS_HOLD_TIME(FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_AddressHoldTime));
+    assert_param(IS_FSMC_DATASETUP_TIME(FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_DataSetupTime));
+    assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_CLKDivision));
+    assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_DataLatency));
+    assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_AccessMode));
+    FSMC_Bank1E-&gt;BWTR[FSMC_NORSRAMInitStruct-&gt;FSMC_Bank] = 
+              (uint32_t)FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_AddressSetupTime |
+              (FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_AddressHoldTime &lt;&lt; 4 )|
+              (FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_DataSetupTime &lt;&lt; 8) |
+              (FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_CLKDivision &lt;&lt; 20) |
+              (FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_DataLatency &lt;&lt; 24) |
+               FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_AccessMode;
+  }
+  else
+  {
+    FSMC_Bank1E-&gt;BWTR[FSMC_NORSRAMInitStruct-&gt;FSMC_Bank] = 0x0FFFFFFF;
+  }
+}
+
+/**
+  * @brief  Initializes the FSMC NAND Banks according to the specified 
+  *   parameters in the FSMC_NANDInitStruct.
+  * @param  FSMC_NANDInitStruct : pointer to a FSMC_NANDInitTypeDef 
+  *   structure that contains the configuration information for the FSMC NAND specified Banks.                       
+  * @retval None
+  */
+void FSMC_NANDInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)
+{
+  uint32_t tmppcr = 0x00000000, tmppmem = 0x00000000, tmppatt = 0x00000000; 
+    
+  /* Check the parameters */
+  assert_param( IS_FSMC_NAND_BANK(FSMC_NANDInitStruct-&gt;FSMC_Bank));
+  assert_param( IS_FSMC_WAIT_FEATURE(FSMC_NANDInitStruct-&gt;FSMC_Waitfeature));
+  assert_param( IS_FSMC_MEMORY_WIDTH(FSMC_NANDInitStruct-&gt;FSMC_MemoryDataWidth));
+  assert_param( IS_FSMC_ECC_STATE(FSMC_NANDInitStruct-&gt;FSMC_ECC));
+  assert_param( IS_FSMC_ECCPAGE_SIZE(FSMC_NANDInitStruct-&gt;FSMC_ECCPageSize));
+  assert_param( IS_FSMC_TCLR_TIME(FSMC_NANDInitStruct-&gt;FSMC_TCLRSetupTime));
+  assert_param( IS_FSMC_TAR_TIME(FSMC_NANDInitStruct-&gt;FSMC_TARSetupTime));
+  assert_param(IS_FSMC_SETUP_TIME(FSMC_NANDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_SetupTime));
+  assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_WaitSetupTime));
+  assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_HoldSetupTime));
+  assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_HiZSetupTime));
+  assert_param(IS_FSMC_SETUP_TIME(FSMC_NANDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_SetupTime));
+  assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_WaitSetupTime));
+  assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_HoldSetupTime));
+  assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_HiZSetupTime));
+  
+  /* Set the tmppcr value according to FSMC_NANDInitStruct parameters */
+  tmppcr = (uint32_t)FSMC_NANDInitStruct-&gt;FSMC_Waitfeature |
+            PCR_MemoryType_NAND |
+            FSMC_NANDInitStruct-&gt;FSMC_MemoryDataWidth |
+            FSMC_NANDInitStruct-&gt;FSMC_ECC |
+            FSMC_NANDInitStruct-&gt;FSMC_ECCPageSize |
+            (FSMC_NANDInitStruct-&gt;FSMC_TCLRSetupTime &lt;&lt; 9 )|
+            (FSMC_NANDInitStruct-&gt;FSMC_TARSetupTime &lt;&lt; 13);
+            
+  /* Set tmppmem value according to FSMC_CommonSpaceTimingStructure parameters */
+  tmppmem = (uint32_t)FSMC_NANDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_SetupTime |
+            (FSMC_NANDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_WaitSetupTime &lt;&lt; 8) |
+            (FSMC_NANDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_HoldSetupTime &lt;&lt; 16)|
+            (FSMC_NANDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_HiZSetupTime &lt;&lt; 24); 
+            
+  /* Set tmppatt value according to FSMC_AttributeSpaceTimingStructure parameters */
+  tmppatt = (uint32_t)FSMC_NANDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_SetupTime |
+            (FSMC_NANDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_WaitSetupTime &lt;&lt; 8) |
+            (FSMC_NANDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_HoldSetupTime &lt;&lt; 16)|
+            (FSMC_NANDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_HiZSetupTime &lt;&lt; 24);
+  
+  if(FSMC_NANDInitStruct-&gt;FSMC_Bank == FSMC_Bank2_NAND)
+  {
+    /* FSMC_Bank2_NAND registers configuration */
+    FSMC_Bank2-&gt;PCR2 = tmppcr;
+    FSMC_Bank2-&gt;PMEM2 = tmppmem;
+    FSMC_Bank2-&gt;PATT2 = tmppatt;
+  }
+  else
+  {
+    /* FSMC_Bank3_NAND registers configuration */
+    FSMC_Bank3-&gt;PCR3 = tmppcr;
+    FSMC_Bank3-&gt;PMEM3 = tmppmem;
+    FSMC_Bank3-&gt;PATT3 = tmppatt;
+  }
+}
+
+/**
+  * @brief  Initializes the FSMC PCCARD Bank according to the specified 
+  *   parameters in the FSMC_PCCARDInitStruct.
+  * @param  FSMC_PCCARDInitStruct : pointer to a FSMC_PCCARDInitTypeDef
+  *   structure that contains the configuration information for the FSMC PCCARD Bank.                       
+  * @retval None
+  */
+void FSMC_PCCARDInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct)
+{
+  /* Check the parameters */
+  assert_param(IS_FSMC_WAIT_FEATURE(FSMC_PCCARDInitStruct-&gt;FSMC_Waitfeature));
+  assert_param(IS_FSMC_TCLR_TIME(FSMC_PCCARDInitStruct-&gt;FSMC_TCLRSetupTime));
+  assert_param(IS_FSMC_TAR_TIME(FSMC_PCCARDInitStruct-&gt;FSMC_TARSetupTime));
+ 
+  assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_SetupTime));
+  assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_WaitSetupTime));
+  assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_HoldSetupTime));
+  assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_HiZSetupTime));
+  
+  assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_SetupTime));
+  assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_WaitSetupTime));
+  assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_HoldSetupTime));
+  assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_HiZSetupTime));
+  assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct-&gt;FSMC_IOSpaceTimingStruct-&gt;FSMC_SetupTime));
+  assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct-&gt;FSMC_IOSpaceTimingStruct-&gt;FSMC_WaitSetupTime));
+  assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct-&gt;FSMC_IOSpaceTimingStruct-&gt;FSMC_HoldSetupTime));
+  assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct-&gt;FSMC_IOSpaceTimingStruct-&gt;FSMC_HiZSetupTime));
+  
+  /* Set the PCR4 register value according to FSMC_PCCARDInitStruct parameters */
+  FSMC_Bank4-&gt;PCR4 = (uint32_t)FSMC_PCCARDInitStruct-&gt;FSMC_Waitfeature |
+                     FSMC_MemoryDataWidth_16b |  
+                     (FSMC_PCCARDInitStruct-&gt;FSMC_TCLRSetupTime &lt;&lt; 9) |
+                     (FSMC_PCCARDInitStruct-&gt;FSMC_TARSetupTime &lt;&lt; 13);
+            
+  /* Set PMEM4 register value according to FSMC_CommonSpaceTimingStructure parameters */
+  FSMC_Bank4-&gt;PMEM4 = (uint32_t)FSMC_PCCARDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_SetupTime |
+                      (FSMC_PCCARDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_WaitSetupTime &lt;&lt; 8) |
+                      (FSMC_PCCARDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_HoldSetupTime &lt;&lt; 16)|
+                      (FSMC_PCCARDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_HiZSetupTime &lt;&lt; 24); 
+            
+  /* Set PATT4 register value according to FSMC_AttributeSpaceTimingStructure parameters */
+  FSMC_Bank4-&gt;PATT4 = (uint32_t)FSMC_PCCARDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_SetupTime |
+                      (FSMC_PCCARDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_WaitSetupTime &lt;&lt; 8) |
+                      (FSMC_PCCARDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_HoldSetupTime &lt;&lt; 16)|
+                      (FSMC_PCCARDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_HiZSetupTime &lt;&lt; 24);	
+            
+  /* Set PIO4 register value according to FSMC_IOSpaceTimingStructure parameters */
+  FSMC_Bank4-&gt;PIO4 = (uint32_t)FSMC_PCCARDInitStruct-&gt;FSMC_IOSpaceTimingStruct-&gt;FSMC_SetupTime |
+                     (FSMC_PCCARDInitStruct-&gt;FSMC_IOSpaceTimingStruct-&gt;FSMC_WaitSetupTime &lt;&lt; 8) |
+                     (FSMC_PCCARDInitStruct-&gt;FSMC_IOSpaceTimingStruct-&gt;FSMC_HoldSetupTime &lt;&lt; 16)|
+                     (FSMC_PCCARDInitStruct-&gt;FSMC_IOSpaceTimingStruct-&gt;FSMC_HiZSetupTime &lt;&lt; 24);             
+}
+
+/**
+  * @brief  Fills each FSMC_NORSRAMInitStruct member with its default value.
+  * @param  FSMC_NORSRAMInitStruct: pointer to a FSMC_NORSRAMInitTypeDef 
+  *   structure which will be initialized.
+  * @retval None
+  */
+void FSMC_NORSRAMStructInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
+{  
+  /* Reset NOR/SRAM Init structure parameters values */
+  FSMC_NORSRAMInitStruct-&gt;FSMC_Bank = FSMC_Bank1_NORSRAM1;
+  FSMC_NORSRAMInitStruct-&gt;FSMC_DataAddressMux = FSMC_DataAddressMux_Enable;
+  FSMC_NORSRAMInitStruct-&gt;FSMC_MemoryType = FSMC_MemoryType_SRAM;
+  FSMC_NORSRAMInitStruct-&gt;FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
+  FSMC_NORSRAMInitStruct-&gt;FSMC_BurstAccessMode = FSMC_BurstAccessMode_Disable;
+  FSMC_NORSRAMInitStruct-&gt;FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low;
+  FSMC_NORSRAMInitStruct-&gt;FSMC_WrapMode = FSMC_WrapMode_Disable;
+  FSMC_NORSRAMInitStruct-&gt;FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;
+  FSMC_NORSRAMInitStruct-&gt;FSMC_WriteOperation = FSMC_WriteOperation_Enable;
+  FSMC_NORSRAMInitStruct-&gt;FSMC_WaitSignal = FSMC_WaitSignal_Enable;
+  FSMC_NORSRAMInitStruct-&gt;FSMC_ExtendedMode = FSMC_ExtendedMode_Disable;
+  FSMC_NORSRAMInitStruct-&gt;FSMC_WriteBurst = FSMC_WriteBurst_Disable;
+  FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_AddressSetupTime = 0xF;
+  FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_AddressHoldTime = 0xF;
+  FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_DataSetupTime = 0xFF;
+  FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_BusTurnAroundDuration = 0xF;
+  FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_CLKDivision = 0xF;
+  FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_DataLatency = 0xF;
+  FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_AccessMode = FSMC_AccessMode_A; 
+  FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_AddressSetupTime = 0xF;
+  FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_AddressHoldTime = 0xF;
+  FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_DataSetupTime = 0xFF;
+  FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_BusTurnAroundDuration = 0xF;
+  FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_CLKDivision = 0xF;
+  FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_DataLatency = 0xF;
+  FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_AccessMode = FSMC_AccessMode_A;
+}
+
+/**
+  * @brief  Fills each FSMC_NANDInitStruct member with its default value.
+  * @param  FSMC_NANDInitStruct: pointer to a FSMC_NANDInitTypeDef 
+  *   structure which will be initialized.
+  * @retval None
+  */
+void FSMC_NANDStructInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)
+{ 
+  /* Reset NAND Init structure parameters values */
+  FSMC_NANDInitStruct-&gt;FSMC_Bank = FSMC_Bank2_NAND;
+  FSMC_NANDInitStruct-&gt;FSMC_Waitfeature = FSMC_Waitfeature_Disable;
+  FSMC_NANDInitStruct-&gt;FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
+  FSMC_NANDInitStruct-&gt;FSMC_ECC = FSMC_ECC_Disable;
+  FSMC_NANDInitStruct-&gt;FSMC_ECCPageSize = FSMC_ECCPageSize_256Bytes;
+  FSMC_NANDInitStruct-&gt;FSMC_TCLRSetupTime = 0x0;
+  FSMC_NANDInitStruct-&gt;FSMC_TARSetupTime = 0x0;
+  FSMC_NANDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_SetupTime = 0xFC;
+  FSMC_NANDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_WaitSetupTime = 0xFC;
+  FSMC_NANDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_HoldSetupTime = 0xFC;
+  FSMC_NANDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_HiZSetupTime = 0xFC;
+  FSMC_NANDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_SetupTime = 0xFC;
+  FSMC_NANDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_WaitSetupTime = 0xFC;
+  FSMC_NANDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_HoldSetupTime = 0xFC;
+  FSMC_NANDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_HiZSetupTime = 0xFC;	  
+}
+
+/**
+  * @brief  Fills each FSMC_PCCARDInitStruct member with its default value.
+  * @param  FSMC_PCCARDInitStruct: pointer to a FSMC_PCCARDInitTypeDef 
+  *   structure which will be initialized.
+  * @retval None
+  */
+void FSMC_PCCARDStructInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct)
+{
+  /* Reset PCCARD Init structure parameters values */
+  FSMC_PCCARDInitStruct-&gt;FSMC_Waitfeature = FSMC_Waitfeature_Disable;
+  FSMC_PCCARDInitStruct-&gt;FSMC_TCLRSetupTime = 0x0;
+  FSMC_PCCARDInitStruct-&gt;FSMC_TARSetupTime = 0x0;
+  FSMC_PCCARDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_SetupTime = 0xFC;
+  FSMC_PCCARDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_WaitSetupTime = 0xFC;
+  FSMC_PCCARDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_HoldSetupTime = 0xFC;
+  FSMC_PCCARDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_HiZSetupTime = 0xFC;
+  FSMC_PCCARDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_SetupTime = 0xFC;
+  FSMC_PCCARDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_WaitSetupTime = 0xFC;
+  FSMC_PCCARDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_HoldSetupTime = 0xFC;
+  FSMC_PCCARDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_HiZSetupTime = 0xFC;	
+  FSMC_PCCARDInitStruct-&gt;FSMC_IOSpaceTimingStruct-&gt;FSMC_SetupTime = 0xFC;
+  FSMC_PCCARDInitStruct-&gt;FSMC_IOSpaceTimingStruct-&gt;FSMC_WaitSetupTime = 0xFC;
+  FSMC_PCCARDInitStruct-&gt;FSMC_IOSpaceTimingStruct-&gt;FSMC_HoldSetupTime = 0xFC;
+  FSMC_PCCARDInitStruct-&gt;FSMC_IOSpaceTimingStruct-&gt;FSMC_HiZSetupTime = 0xFC;
+}
+
+/**
+  * @brief  Enables or disables the specified NOR/SRAM Memory Bank.
+  * @param  FSMC_Bank: specifies the FSMC Bank to be used
+  *   This parameter can be one of the following values:
+  *     @arg FSMC_Bank1_NORSRAM1: FSMC Bank1 NOR/SRAM1  
+  *     @arg FSMC_Bank1_NORSRAM2: FSMC Bank1 NOR/SRAM2 
+  *     @arg FSMC_Bank1_NORSRAM3: FSMC Bank1 NOR/SRAM3 
+  *     @arg FSMC_Bank1_NORSRAM4: FSMC Bank1 NOR/SRAM4 
+  * @param  NewState: new state of the FSMC_Bank. This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void FSMC_NORSRAMCmd(uint32_t FSMC_Bank, FunctionalState NewState)
+{
+  assert_param(IS_FSMC_NORSRAM_BANK(FSMC_Bank));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected NOR/SRAM Bank by setting the PBKEN bit in the BCRx register */
+    FSMC_Bank1-&gt;BTCR[FSMC_Bank] |= BCR_MBKEN_Set;
+  }
+  else
+  {
+    /* Disable the selected NOR/SRAM Bank by clearing the PBKEN bit in the BCRx register */
+    FSMC_Bank1-&gt;BTCR[FSMC_Bank] &amp;= BCR_MBKEN_Reset;
+  }
+}
+
+/**
+  * @brief  Enables or disables the specified NAND Memory Bank.
+  * @param  FSMC_Bank: specifies the FSMC Bank to be used
+  *   This parameter can be one of the following values:
+  *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
+  *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
+  * @param  NewState: new state of the FSMC_Bank. This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void FSMC_NANDCmd(uint32_t FSMC_Bank, FunctionalState NewState)
+{
+  assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected NAND Bank by setting the PBKEN bit in the PCRx register */
+    if(FSMC_Bank == FSMC_Bank2_NAND)
+    {
+      FSMC_Bank2-&gt;PCR2 |= PCR_PBKEN_Set;
+    }
+    else
+    {
+      FSMC_Bank3-&gt;PCR3 |= PCR_PBKEN_Set;
+    }
+  }
+  else
+  {
+    /* Disable the selected NAND Bank by clearing the PBKEN bit in the PCRx register */
+    if(FSMC_Bank == FSMC_Bank2_NAND)
+    {
+      FSMC_Bank2-&gt;PCR2 &amp;= PCR_PBKEN_Reset;
+    }
+    else
+    {
+      FSMC_Bank3-&gt;PCR3 &amp;= PCR_PBKEN_Reset;
+    }
+  }
+}
+
+/**
+  * @brief  Enables or disables the PCCARD Memory Bank.
+  * @param  NewState: new state of the PCCARD Memory Bank.  
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void FSMC_PCCARDCmd(FunctionalState NewState)
+{
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the PCCARD Bank by setting the PBKEN bit in the PCR4 register */
+    FSMC_Bank4-&gt;PCR4 |= PCR_PBKEN_Set;
+  }
+  else
+  {
+    /* Disable the PCCARD Bank by clearing the PBKEN bit in the PCR4 register */
+    FSMC_Bank4-&gt;PCR4 &amp;= PCR_PBKEN_Reset;
+  }
+}
+
+/**
+  * @brief  Enables or disables the FSMC NAND ECC feature.
+  * @param  FSMC_Bank: specifies the FSMC Bank to be used
+  *   This parameter can be one of the following values:
+  *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
+  *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
+  * @param  NewState: new state of the FSMC NAND ECC feature.  
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void FSMC_NANDECCCmd(uint32_t FSMC_Bank, FunctionalState NewState)
+{
+  assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected NAND Bank ECC function by setting the ECCEN bit in the PCRx register */
+    if(FSMC_Bank == FSMC_Bank2_NAND)
+    {
+      FSMC_Bank2-&gt;PCR2 |= PCR_ECCEN_Set;
+    }
+    else
+    {
+      FSMC_Bank3-&gt;PCR3 |= PCR_ECCEN_Set;
+    }
+  }
+  else
+  {
+    /* Disable the selected NAND Bank ECC function by clearing the ECCEN bit in the PCRx register */
+    if(FSMC_Bank == FSMC_Bank2_NAND)
+    {
+      FSMC_Bank2-&gt;PCR2 &amp;= PCR_ECCEN_Reset;
+    }
+    else
+    {
+      FSMC_Bank3-&gt;PCR3 &amp;= PCR_ECCEN_Reset;
+    }
+  }
+}
+
+/**
+  * @brief  Returns the error correction code register value.
+  * @param  FSMC_Bank: specifies the FSMC Bank to be used
+  *   This parameter can be one of the following values:
+  *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
+  *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
+  * @retval The Error Correction Code (ECC) value.
+  */
+uint32_t FSMC_GetECC(uint32_t FSMC_Bank)
+{
+  uint32_t eccval = 0x00000000;
+  
+  if(FSMC_Bank == FSMC_Bank2_NAND)
+  {
+    /* Get the ECCR2 register value */
+    eccval = FSMC_Bank2-&gt;ECCR2;
+  }
+  else
+  {
+    /* Get the ECCR3 register value */
+    eccval = FSMC_Bank3-&gt;ECCR3;
+  }
+  /* Return the error correction code value */
+  return(eccval);
+}
+
+/**
+  * @brief  Enables or disables the specified FSMC interrupts.
+  * @param  FSMC_Bank: specifies the FSMC Bank to be used
+  *   This parameter can be one of the following values:
+  *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
+  *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
+  *     @arg FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
+  * @param  FSMC_IT: specifies the FSMC interrupt sources to be enabled or disabled.
+  *   This parameter can be any combination of the following values:
+  *     @arg FSMC_IT_RisingEdge: Rising edge detection interrupt. 
+  *     @arg FSMC_IT_Level: Level edge detection interrupt.
+  *     @arg FSMC_IT_FallingEdge: Falling edge detection interrupt.
+  * @param  NewState: new state of the specified FSMC interrupts.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void FSMC_ITConfig(uint32_t FSMC_Bank, uint32_t FSMC_IT, FunctionalState NewState)
+{
+  assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
+  assert_param(IS_FSMC_IT(FSMC_IT));	
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected FSMC_Bank2 interrupts */
+    if(FSMC_Bank == FSMC_Bank2_NAND)
+    {
+      FSMC_Bank2-&gt;SR2 |= FSMC_IT;
+    }
+    /* Enable the selected FSMC_Bank3 interrupts */
+    else if (FSMC_Bank == FSMC_Bank3_NAND)
+    {
+      FSMC_Bank3-&gt;SR3 |= FSMC_IT;
+    }
+    /* Enable the selected FSMC_Bank4 interrupts */
+    else
+    {
+      FSMC_Bank4-&gt;SR4 |= FSMC_IT;    
+    }
+  }
+  else
+  {
+    /* Disable the selected FSMC_Bank2 interrupts */
+    if(FSMC_Bank == FSMC_Bank2_NAND)
+    {
+      
+      FSMC_Bank2-&gt;SR2 &amp;= (uint32_t)~FSMC_IT;
+    }
+    /* Disable the selected FSMC_Bank3 interrupts */
+    else if (FSMC_Bank == FSMC_Bank3_NAND)
+    {
+      FSMC_Bank3-&gt;SR3 &amp;= (uint32_t)~FSMC_IT;
+    }
+    /* Disable the selected FSMC_Bank4 interrupts */
+    else
+    {
+      FSMC_Bank4-&gt;SR4 &amp;= (uint32_t)~FSMC_IT;    
+    }
+  }
+}
+
+/**
+  * @brief  Checks whether the specified FSMC flag is set or not.
+  * @param  FSMC_Bank: specifies the FSMC Bank to be used
+  *   This parameter can be one of the following values:
+  *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
+  *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
+  *     @arg FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
+  * @param  FSMC_FLAG: specifies the flag to check.
+  *   This parameter can be one of the following values:
+  *     @arg FSMC_FLAG_RisingEdge: Rising egde detection Flag.
+  *     @arg FSMC_FLAG_Level: Level detection Flag.
+  *     @arg FSMC_FLAG_FallingEdge: Falling egde detection Flag.
+  *     @arg FSMC_FLAG_FEMPT: Fifo empty Flag. 
+  * @retval The new state of FSMC_FLAG (SET or RESET).
+  */
+FlagStatus FSMC_GetFlagStatus(uint32_t FSMC_Bank, uint32_t FSMC_FLAG)
+{
+  FlagStatus bitstatus = RESET;
+  uint32_t tmpsr = 0x00000000;
+  
+  /* Check the parameters */
+  assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));
+  assert_param(IS_FSMC_GET_FLAG(FSMC_FLAG));
+  
+  if(FSMC_Bank == FSMC_Bank2_NAND)
+  {
+    tmpsr = FSMC_Bank2-&gt;SR2;
+  }  
+  else if(FSMC_Bank == FSMC_Bank3_NAND)
+  {
+    tmpsr = FSMC_Bank3-&gt;SR3;
+  }
+  /* FSMC_Bank4_PCCARD*/
+  else
+  {
+    tmpsr = FSMC_Bank4-&gt;SR4;
+  } 
+  
+  /* Get the flag status */
+  if ((tmpsr &amp; FSMC_FLAG) != (uint16_t)RESET )
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  /* Return the flag status */
+  return bitstatus;
+}
+
+/**
+  * @brief  Clears the FSMC&#146;s pending flags.
+  * @param  FSMC_Bank: specifies the FSMC Bank to be used
+  *   This parameter can be one of the following values:
+  *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
+  *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
+  *     @arg FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
+  * @param  FSMC_FLAG: specifies the flag to clear.
+  *   This parameter can be any combination of the following values:
+  *     @arg FSMC_FLAG_RisingEdge: Rising egde detection Flag.
+  *     @arg FSMC_FLAG_Level: Level detection Flag.
+  *     @arg FSMC_FLAG_FallingEdge: Falling egde detection Flag.
+  * @retval None
+  */
+void FSMC_ClearFlag(uint32_t FSMC_Bank, uint32_t FSMC_FLAG)
+{
+ /* Check the parameters */
+  assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));
+  assert_param(IS_FSMC_CLEAR_FLAG(FSMC_FLAG)) ;
+    
+  if(FSMC_Bank == FSMC_Bank2_NAND)
+  {
+    FSMC_Bank2-&gt;SR2 &amp;= ~FSMC_FLAG; 
+  }  
+  else if(FSMC_Bank == FSMC_Bank3_NAND)
+  {
+    FSMC_Bank3-&gt;SR3 &amp;= ~FSMC_FLAG;
+  }
+  /* FSMC_Bank4_PCCARD*/
+  else
+  {
+    FSMC_Bank4-&gt;SR4 &amp;= ~FSMC_FLAG;
+  }
+}
+
+/**
+  * @brief  Checks whether the specified FSMC interrupt has occurred or not.
+  * @param  FSMC_Bank: specifies the FSMC Bank to be used
+  *   This parameter can be one of the following values:
+  *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
+  *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
+  *     @arg FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
+  * @param  FSMC_IT: specifies the FSMC interrupt source to check.
+  *   This parameter can be one of the following values:
+  *     @arg FSMC_IT_RisingEdge: Rising edge detection interrupt. 
+  *     @arg FSMC_IT_Level: Level edge detection interrupt.
+  *     @arg FSMC_IT_FallingEdge: Falling edge detection interrupt. 
+  * @retval The new state of FSMC_IT (SET or RESET).
+  */
+ITStatus FSMC_GetITStatus(uint32_t FSMC_Bank, uint32_t FSMC_IT)
+{
+  ITStatus bitstatus = RESET;
+  uint32_t tmpsr = 0x0, itstatus = 0x0, itenable = 0x0; 
+  
+  /* Check the parameters */
+  assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
+  assert_param(IS_FSMC_GET_IT(FSMC_IT));
+  
+  if(FSMC_Bank == FSMC_Bank2_NAND)
+  {
+    tmpsr = FSMC_Bank2-&gt;SR2;
+  }  
+  else if(FSMC_Bank == FSMC_Bank3_NAND)
+  {
+    tmpsr = FSMC_Bank3-&gt;SR3;
+  }
+  /* FSMC_Bank4_PCCARD*/
+  else
+  {
+    tmpsr = FSMC_Bank4-&gt;SR4;
+  } 
+  
+  itstatus = tmpsr &amp; FSMC_IT;
+  
+  itenable = tmpsr &amp; (FSMC_IT &gt;&gt; 3);
+  if ((itstatus != (uint32_t)RESET)  &amp;&amp; (itenable != (uint32_t)RESET))
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  return bitstatus; 
+}
+
+/**
+  * @brief  Clears the FSMC&#146;s interrupt pending bits.
+  * @param  FSMC_Bank: specifies the FSMC Bank to be used
+  *   This parameter can be one of the following values:
+  *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
+  *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
+  *     @arg FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
+  * @param  FSMC_IT: specifies the interrupt pending bit to clear.
+  *   This parameter can be any combination of the following values:
+  *     @arg FSMC_IT_RisingEdge: Rising edge detection interrupt. 
+  *     @arg FSMC_IT_Level: Level edge detection interrupt.
+  *     @arg FSMC_IT_FallingEdge: Falling edge detection interrupt.
+  * @retval None
+  */
+void FSMC_ClearITPendingBit(uint32_t FSMC_Bank, uint32_t FSMC_IT)
+{
+  /* Check the parameters */
+  assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
+  assert_param(IS_FSMC_IT(FSMC_IT));
+    
+  if(FSMC_Bank == FSMC_Bank2_NAND)
+  {
+    FSMC_Bank2-&gt;SR2 &amp;= ~(FSMC_IT &gt;&gt; 3); 
+  }  
+  else if(FSMC_Bank == FSMC_Bank3_NAND)
+  {
+    FSMC_Bank3-&gt;SR3 &amp;= ~(FSMC_IT &gt;&gt; 3);
+  }
+  /* FSMC_Bank4_PCCARD*/
+  else
+  {
+    FSMC_Bank4-&gt;SR4 &amp;= ~(FSMC_IT &gt;&gt; 3);
+  }
+}
+
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2009 STMicroelectronics *****END OF FILE****/

Added: trunk/src/platform/stm32/FWLib/library/src/stm32f10x_fsmc.o
===================================================================
--- trunk/src/platform/stm32/FWLib/library/src/stm32f10x_fsmc.o	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/src/stm32f10x_fsmc.o	2009-07-08 23:39:34 UTC (rev 354)
@@ -0,0 +1,16 @@
+ELF
+h&#139;iCJhC&#234;&#138;hC&#234;#
+iC&#234;SJiC&#234;cJB&#248;%0&#224;Ko&#240;pBC&#248;% p&#189;
+hC&#202;hjC&#234;d&#139;hJhC&#234;#
+hC&#202;hC&#234;bh+&#191;KK`&#156;`&#218;`0&#189;
+hC&#202;hC&#234;c&#163;`i&#139;hJhC&#234;#
+hC&#202;hC&#234;c&#227;`Ai&#139;hJhC&#234;#
+hC&#202;hC&#234;c#a&#189;
+h&#234;`pG`
+h&#234;`pG&#160;
+h&#234;`pG`
+&#224;&#176;&#245;&#128;&#191;JJO&#234;&#209;Sh#&#234;S`pG`
+M	
+
+
+
\ No newline at end of file

Modified: trunk/src/platform/stm32/FWLib/library/src/stm32f10x_gpio.c
===================================================================
--- trunk/src/platform/stm32/FWLib/library/src/stm32f10x_gpio.c	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/src/stm32f10x_gpio.c	2009-07-08 23:39:34 UTC (rev 354)
@@ -1,583 +1,617 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_gpio.c
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file provides all the GPIO firmware functions.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
-
-/* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_gpio.h&quot;
-#include &quot;stm32f10x_rcc.h&quot;
-
-/* Private typedef -----------------------------------------------------------*/
-/* Private define ------------------------------------------------------------*/
-/* ------------ RCC registers bit address in the alias region ----------- */
-#define AFIO_OFFSET                 (AFIO_BASE - PERIPH_BASE)
-
-/* --- EVENTCR Register ---*/
-/* Alias word address of EVOE bit */
-#define EVCR_OFFSET                 (AFIO_OFFSET + 0x00)
-#define EVOE_BitNumber              ((u8)0x07)
-#define EVCR_EVOE_BB                (PERIPH_BB_BASE + (EVCR_OFFSET * 32) + (EVOE_BitNumber * 4))
-
-#define EVCR_PORTPINCONFIG_MASK     ((u16)0xFF80)
-#define LSB_MASK                    ((u16)0xFFFF)
-#define DBGAFR_POSITION_MASK        ((u32)0x000F0000)
-#define DBGAFR_SWJCFG_MASK          ((u32)0xF0FFFFFF)
-#define DBGAFR_LOCATION_MASK        ((u32)0x00200000)
-#define DBGAFR_NUMBITS_MASK         ((u32)0x00100000)
-
-/* Private macro -------------------------------------------------------------*/
-/* Private variables ---------------------------------------------------------*/
-/* Private function prototypes -----------------------------------------------*/
-/* Private functions ---------------------------------------------------------*/
-
-/*******************************************************************************
-* Function Name  : GPIO_DeInit
-* Description    : Deinitializes the GPIOx peripheral registers to their default
-*                  reset values.
-* Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void GPIO_DeInit(GPIO_TypeDef* GPIOx)
-{
-  /* Check the parameters */
-  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
-  
-  switch (*(u32*)&amp;GPIOx)
-  {
-    case GPIOA_BASE:
-      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOA, ENABLE);
-      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOA, DISABLE);
-      break;
-
-    case GPIOB_BASE:
-      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOB, ENABLE);
-      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOB, DISABLE);
-      break;
-
-    case GPIOC_BASE:
-      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOC, ENABLE);
-      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOC, DISABLE);
-      break;
-
-    case GPIOD_BASE:
-      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOD, ENABLE);
-      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOD, DISABLE);
-      break;
-      
-    case GPIOE_BASE:
-      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOE, ENABLE);
-      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOE, DISABLE);
-      break; 
-
-    case GPIOF_BASE:
-      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOF, ENABLE);
-      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOF, DISABLE);
-      break;
-
-    case GPIOG_BASE:
-      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, ENABLE);
-      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, DISABLE);
-      break;                       
-
-    default:
-      break;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : GPIO_AFIODeInit
-* Description    : Deinitializes the Alternate Functions (remap, event control
-*                  and EXTI configuration) registers to their default reset
-*                  values.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void GPIO_AFIODeInit(void)
-{
-  RCC_APB2PeriphResetCmd(RCC_APB2Periph_AFIO, ENABLE);
-  RCC_APB2PeriphResetCmd(RCC_APB2Periph_AFIO, DISABLE);
-}
-
-/*******************************************************************************
-* Function Name  : GPIO_Init
-* Description    : Initializes the GPIOx peripheral according to the specified
-*                  parameters in the GPIO_InitStruct.
-* Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
-*                  - GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that
-*                    contains the configuration information for the specified GPIO
-*                    peripheral.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
-{
-  u32 currentmode = 0x00, currentpin = 0x00, pinpos = 0x00, pos = 0x00;
-  u32 tmpreg = 0x00, pinmask = 0x00;
-
-  /* Check the parameters */
-  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
-  assert_param(IS_GPIO_MODE(GPIO_InitStruct-&gt;GPIO_Mode));
-  assert_param(IS_GPIO_PIN(GPIO_InitStruct-&gt;GPIO_Pin));  
-  
-/*---------------------------- GPIO Mode Configuration -----------------------*/
-  currentmode = ((u32)GPIO_InitStruct-&gt;GPIO_Mode) &amp; ((u32)0x0F);
-
-  if ((((u32)GPIO_InitStruct-&gt;GPIO_Mode) &amp; ((u32)0x10)) != 0x00)
-  { 
-    /* Check the parameters */
-    assert_param(IS_GPIO_SPEED(GPIO_InitStruct-&gt;GPIO_Speed));
-    /* Output mode */
-    currentmode |= (u32)GPIO_InitStruct-&gt;GPIO_Speed;
-  }
-
-/*---------------------------- GPIO CRL Configuration ------------------------*/
-  /* Configure the eight low port pins */
-  if (((u32)GPIO_InitStruct-&gt;GPIO_Pin &amp; ((u32)0x00FF)) != 0x00)
-  {
-    tmpreg = GPIOx-&gt;CRL;
-
-    for (pinpos = 0x00; pinpos &lt; 0x08; pinpos++)
-    {
-      pos = ((u32)0x01) &lt;&lt; pinpos;
-      /* Get the port pins position */
-      currentpin = (GPIO_InitStruct-&gt;GPIO_Pin) &amp; pos;
-
-      if (currentpin == pos)
-      {
-        pos = pinpos &lt;&lt; 2;
-        /* Clear the corresponding low control register bits */
-        pinmask = ((u32)0x0F) &lt;&lt; pos;
-        tmpreg &amp;= ~pinmask;
-
-        /* Write the mode configuration in the corresponding bits */
-        tmpreg |= (currentmode &lt;&lt; pos);
-
-        /* Reset the corresponding ODR bit */
-        if (GPIO_InitStruct-&gt;GPIO_Mode == GPIO_Mode_IPD)
-        {
-          GPIOx-&gt;BRR = (((u32)0x01) &lt;&lt; pinpos);
-        }
-        else
-        {
-          /* Set the corresponding ODR bit */
-          if (GPIO_InitStruct-&gt;GPIO_Mode == GPIO_Mode_IPU)
-          {
-            GPIOx-&gt;BSRR = (((u32)0x01) &lt;&lt; pinpos);
-          }
-        }
-      }
-    }
-    GPIOx-&gt;CRL = tmpreg;
-  }
-
-/*---------------------------- GPIO CRH Configuration ------------------------*/
-  /* Configure the eight high port pins */
-  if (GPIO_InitStruct-&gt;GPIO_Pin &gt; 0x00FF)
-  {
-    tmpreg = GPIOx-&gt;CRH;
-    for (pinpos = 0x00; pinpos &lt; 0x08; pinpos++)
-    {
-      pos = (((u32)0x01) &lt;&lt; (pinpos + 0x08));
-      /* Get the port pins position */
-      currentpin = ((GPIO_InitStruct-&gt;GPIO_Pin) &amp; pos);
-      if (currentpin == pos)
-      {
-        pos = pinpos &lt;&lt; 2;
-        /* Clear the corresponding high control register bits */
-        pinmask = ((u32)0x0F) &lt;&lt; pos;
-        tmpreg &amp;= ~pinmask;
-
-        /* Write the mode configuration in the corresponding bits */
-        tmpreg |= (currentmode &lt;&lt; pos);
-
-        /* Reset the corresponding ODR bit */
-        if (GPIO_InitStruct-&gt;GPIO_Mode == GPIO_Mode_IPD)
-        {
-          GPIOx-&gt;BRR = (((u32)0x01) &lt;&lt; (pinpos + 0x08));
-        }
-        /* Set the corresponding ODR bit */
-        if (GPIO_InitStruct-&gt;GPIO_Mode == GPIO_Mode_IPU)
-        {
-          GPIOx-&gt;BSRR = (((u32)0x01) &lt;&lt; (pinpos + 0x08));
-        }
-      }
-    }
-    GPIOx-&gt;CRH = tmpreg;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : GPIO_StructInit
-* Description    : Fills each GPIO_InitStruct member with its default value.
-* Input          : - GPIO_InitStruct : pointer to a GPIO_InitTypeDef structure
-*                    which will be initialized.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
-{
-  /* Reset GPIO init structure parameters values */
-  GPIO_InitStruct-&gt;GPIO_Pin  = GPIO_Pin_All;
-  GPIO_InitStruct-&gt;GPIO_Speed = GPIO_Speed_2MHz;
-  GPIO_InitStruct-&gt;GPIO_Mode = GPIO_Mode_IN_FLOATING;
-}
-
-/*******************************************************************************
-* Function Name  : GPIO_ReadInputDataBit
-* Description    : Reads the specified input port pin.
-* Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
-*                : - GPIO_Pin:  specifies the port bit to read.
-*                    This parameter can be GPIO_Pin_x where x can be (0..15).
-* Output         : None
-* Return         : The input port pin value.
-*******************************************************************************/
-u8 GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, u16 GPIO_Pin)
-{
-  u8 bitstatus = 0x00;
-  
-  /* Check the parameters */
-  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
-  assert_param(IS_GET_GPIO_PIN(GPIO_Pin)); 
-  
-  if ((GPIOx-&gt;IDR &amp; GPIO_Pin) != (u32)Bit_RESET)
-  {
-    bitstatus = (u8)Bit_SET;
-  }
-  else
-  {
-    bitstatus = (u8)Bit_RESET;
-  }
-  return bitstatus;
-}
-
-/*******************************************************************************
-* Function Name  : GPIO_ReadInputData
-* Description    : Reads the specified GPIO input data port.
-* Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
-* Output         : None
-* Return         : GPIO input data port value.
-*******************************************************************************/
-u16 GPIO_ReadInputData(GPIO_TypeDef* GPIOx)
-{
-  /* Check the parameters */
-  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
-  
-  return ((u16)GPIOx-&gt;IDR);
-}
-
-/*******************************************************************************
-* Function Name  : GPIO_ReadOutputDataBit
-* Description    : Reads the specified output data port bit.
-* Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
-*                : - GPIO_Pin:  specifies the port bit to read.
-*                    This parameter can be GPIO_Pin_x where x can be (0..15).
-* Output         : None
-* Return         : The output port pin value.
-*******************************************************************************/
-u8 GPIO_ReadOutputDataBit(GPIO_TypeDef* GPIOx, u16 GPIO_Pin)
-{
-  u8 bitstatus = 0x00;
-
-  /* Check the parameters */
-  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
-  assert_param(IS_GET_GPIO_PIN(GPIO_Pin)); 
-  
-  if ((GPIOx-&gt;ODR &amp; GPIO_Pin) != (u32)Bit_RESET)
-  {
-    bitstatus = (u8)Bit_SET;
-  }
-  else
-  {
-    bitstatus = (u8)Bit_RESET;
-  }
-  return bitstatus;
-}
-
-/*******************************************************************************
-* Function Name  : GPIO_ReadOutputData
-* Description    : Reads the specified GPIO output data port.
-* Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
-* Output         : None
-* Return         : GPIO output data port value.
-*******************************************************************************/
-u16 GPIO_ReadOutputData(GPIO_TypeDef* GPIOx)
-{
-  /* Check the parameters */
-  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
-    
-  return ((u16)GPIOx-&gt;ODR);
-}
-
-/*******************************************************************************
-* Function Name  : GPIO_SetBits
-* Description    : Sets the selected data port bits.
-* Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
-*                  - GPIO_Pin: specifies the port bits to be written.
-*                    This parameter can be any combination of GPIO_Pin_x where 
-*                    x can be (0..15).
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void GPIO_SetBits(GPIO_TypeDef* GPIOx, u16 GPIO_Pin)
-{
-  /* Check the parameters */
-  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
-  assert_param(IS_GPIO_PIN(GPIO_Pin));
-  
-  GPIOx-&gt;BSRR = GPIO_Pin;
-}
-
-/*******************************************************************************
-* Function Name  : GPIO_ResetBits
-* Description    : Clears the selected data port bits.
-* Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
-*                  - GPIO_Pin: specifies the port bits to be written.
-*                    This parameter can be any combination of GPIO_Pin_x where 
-*                    x can be (0..15).
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void GPIO_ResetBits(GPIO_TypeDef* GPIOx, u16 GPIO_Pin)
-{
-  /* Check the parameters */
-  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
-  assert_param(IS_GPIO_PIN(GPIO_Pin));
-  
-  GPIOx-&gt;BRR = GPIO_Pin;
-}
-
-/*******************************************************************************
-* Function Name  : GPIO_WriteBit
-* Description    : Sets or clears the selected data port bit.
-* Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
-*                  - GPIO_Pin: specifies the port bit to be written.
-*                    This parameter can be one of GPIO_Pin_x where x can be (0..15).
-*                  - BitVal: specifies the value to be written to the selected bit.
-*                    This parameter can be one of the BitAction enum values:
-*                       - Bit_RESET: to clear the port pin
-*                       - Bit_SET: to set the port pin
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void GPIO_WriteBit(GPIO_TypeDef* GPIOx, u16 GPIO_Pin, BitAction BitVal)
-{
-  /* Check the parameters */
-  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
-  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
-  assert_param(IS_GPIO_BIT_ACTION(BitVal)); 
-  
-  if (BitVal != Bit_RESET)
-  {
-    GPIOx-&gt;BSRR = GPIO_Pin;
-  }
-  else
-  {
-    GPIOx-&gt;BRR = GPIO_Pin;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : GPIO_Write
-* Description    : Writes data to the specified GPIO data port.
-* Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
-*                  - PortVal: specifies the value to be written to the port output
-*                    data register.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void GPIO_Write(GPIO_TypeDef* GPIOx, u16 PortVal)
-{
-  /* Check the parameters */
-  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
-  
-  GPIOx-&gt;ODR = PortVal;
-}
-
-/*******************************************************************************
-* Function Name  : GPIO_PinLockConfig
-* Description    : Locks GPIO Pins configuration registers.
-* Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
-*                  - GPIO_Pin: specifies the port bit to be written.
-*                    This parameter can be any combination of GPIO_Pin_x where 
-*                    x can be (0..15).
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void GPIO_PinLockConfig(GPIO_TypeDef* GPIOx, u16 GPIO_Pin)
-{
-  u32 tmp = 0x00010000;
-  
-  /* Check the parameters */
-  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
-  assert_param(IS_GPIO_PIN(GPIO_Pin));
-  
-  tmp |= GPIO_Pin;
-  /* Set LCKK bit */
-  GPIOx-&gt;LCKR = tmp;
-  /* Reset LCKK bit */
-  GPIOx-&gt;LCKR =  GPIO_Pin;
-  /* Set LCKK bit */
-  GPIOx-&gt;LCKR = tmp;
-  /* Read LCKK bit*/
-  tmp = GPIOx-&gt;LCKR;
-  /* Read LCKK bit*/
-  tmp = GPIOx-&gt;LCKR;
-}
-
-/*******************************************************************************
-* Function Name  : GPIO_EventOutputConfig
-* Description    : Selects the GPIO pin used as Event output.
-* Input          : - GPIO_PortSource: selects the GPIO port to be used as source
-*                    for Event output.
-*                    This parameter can be GPIO_PortSourceGPIOx where x can be
-*                    (A..E).
-*                  - GPIO_PinSource: specifies the pin for the Event output.
-*                    This parameter can be GPIO_PinSourcex where x can be (0..15).
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void GPIO_EventOutputConfig(u8 GPIO_PortSource, u8 GPIO_PinSource)
-{
-  u32 tmpreg = 0x00;
-
-  /* Check the parameters */
-  assert_param(IS_GPIO_EVENTOUT_PORT_SOURCE(GPIO_PortSource));
-  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
-    
-  tmpreg = AFIO-&gt;EVCR;
-  /* Clear the PORT[6:4] and PIN[3:0] bits */
-  tmpreg &amp;= EVCR_PORTPINCONFIG_MASK;
-  tmpreg |= (u32)GPIO_PortSource &lt;&lt; 0x04;
-  tmpreg |= GPIO_PinSource;
-
-  AFIO-&gt;EVCR = tmpreg;
-}
-
-/*******************************************************************************
-* Function Name  : GPIO_EventOutputCmd
-* Description    : Enables or disables the Event Output.
-* Input          : - NewState: new state of the Event output.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void GPIO_EventOutputCmd(FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  
-  *(vu32 *) EVCR_EVOE_BB = (u32)NewState;
-}
-
-/*******************************************************************************
-* Function Name  : GPIO_PinRemapConfig
-* Description    : Changes the mapping of the specified pin.
-* Input          : - GPIO_Remap: selects the pin to remap.
-*                    This parameter can be one of the following values:
-*                       - GPIO_Remap_SPI1
-*                       - GPIO_Remap_I2C1
-*                       - GPIO_Remap_USART1
-*                       - GPIO_Remap_USART2
-*                       - GPIO_PartialRemap_USART3
-*                       - GPIO_FullRemap_USART3
-*                       - GPIO_PartialRemap_TIM1
-*                       - GPIO_FullRemap_TIM1
-*                       - GPIO_PartialRemap1_TIM2
-*                       - GPIO_PartialRemap2_TIM2
-*                       - GPIO_FullRemap_TIM2
-*                       - GPIO_PartialRemap_TIM3
-*                       - GPIO_FullRemap_TIM3
-*                       - GPIO_Remap_TIM4
-*                       - GPIO_Remap1_CAN
-*                       - GPIO_Remap2_CAN
-*                       - GPIO_Remap_PD01
-*                       - GPIO_Remap_TIM5CH4_LSI
-*                       - GPIO_Remap_ADC1_ETRGINJ
-*                       - GPIO_Remap_ADC1_ETRGREG
-*                       - GPIO_Remap_ADC2_ETRGINJ
-*                       - GPIO_Remap_ADC2_ETRGREG
-*                       - GPIO_Remap_SWJ_NoJTRST
-*                       - GPIO_Remap_SWJ_JTAGDisable
-*                       - GPIO_Remap_SWJ_Disable
-*                  - NewState: new state of the port pin remapping.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void GPIO_PinRemapConfig(u32 GPIO_Remap, FunctionalState NewState)
-{
-  u32 tmp = 0x00, tmp1 = 0x00, tmpreg = 0x00, tmpmask = 0x00;
-
-  /* Check the parameters */
-  assert_param(IS_GPIO_REMAP(GPIO_Remap));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));  
-  
-  tmpreg = AFIO-&gt;MAPR;
-
-  tmpmask = (GPIO_Remap &amp; DBGAFR_POSITION_MASK) &gt;&gt; 0x10;
-  tmp = GPIO_Remap &amp; LSB_MASK;
-
-  if ((GPIO_Remap &amp; (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK)) == (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK))
-  {
-    tmpreg &amp;= DBGAFR_SWJCFG_MASK;
-    AFIO-&gt;MAPR &amp;= DBGAFR_SWJCFG_MASK;
-  }
-  else if ((GPIO_Remap &amp; DBGAFR_NUMBITS_MASK) == DBGAFR_NUMBITS_MASK)
-  {
-    tmp1 = ((u32)0x03) &lt;&lt; tmpmask;
-    tmpreg &amp;= ~tmp1;
-    tmpreg |= ~DBGAFR_SWJCFG_MASK;
-  }
-  else
-  {
-    tmpreg &amp;= ~(tmp &lt;&lt; ((GPIO_Remap &gt;&gt; 0x15)*0x10));
-    tmpreg |= ~DBGAFR_SWJCFG_MASK;
-  }
-
-  if (NewState != DISABLE)
-  {
-    tmpreg |= (tmp &lt;&lt; ((GPIO_Remap &gt;&gt; 0x15)*0x10));
-  }
-
-  AFIO-&gt;MAPR = tmpreg;
-}
-
-/*******************************************************************************
-* Function Name  : GPIO_EXTILineConfig
-* Description    : Selects the GPIO pin used as EXTI Line.
-* Input          : - GPIO_PortSource: selects the GPIO port to be used as
-*                    source for EXTI lines.
-*                    This parameter can be GPIO_PortSourceGPIOx where x can be
-*                    (A..G).
-*                  - GPIO_PinSource: specifies the EXTI line to be configured.
-*                   This parameter can be GPIO_PinSourcex where x can be (0..15).
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void GPIO_EXTILineConfig(u8 GPIO_PortSource, u8 GPIO_PinSource)
-{
-  u32 tmp = 0x00;
-
-  /* Check the parameters */
-  assert_param(IS_GPIO_EXTI_PORT_SOURCE(GPIO_PortSource));
-  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
-  
-  tmp = ((u32)0x0F) &lt;&lt; (0x04 * (GPIO_PinSource &amp; (u8)0x03));
-
-  AFIO-&gt;EXTICR[GPIO_PinSource &gt;&gt; 0x02] &amp;= ~tmp;
-  AFIO-&gt;EXTICR[GPIO_PinSource &gt;&gt; 0x02] |= (((u32)GPIO_PortSource) &lt;&lt; (0x04 * (GPIO_PinSource &amp; (u8)0x03)));
-}
-
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
+/**
+  ******************************************************************************
+  * @file    stm32f10x_gpio.c
+  * @author  MCD Application Team
+  * @version V3.1.0
+  * @date    06/19/2009
+  * @brief   This file provides all the GPIO firmware functions.
+  ******************************************************************************
+  * @copy
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * &lt;h2&gt;&lt;center&gt;&copy; COPYRIGHT 2009 STMicroelectronics&lt;/center&gt;&lt;/h2&gt;
+  */ 
+
+/* Includes ------------------------------------------------------------------*/
+#include &quot;stm32f10x_gpio.h&quot;
+#include &quot;stm32f10x_rcc.h&quot;
+
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup GPIO 
+  * @brief GPIO driver modules
+  * @{
+  */ 
+
+/** @defgroup GPIO_Private_TypesDefinitions
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup GPIO_Private_Defines
+  * @{
+  */
+
+/* ------------ RCC registers bit address in the alias region ----------------*/
+#define AFIO_OFFSET                 (AFIO_BASE - PERIPH_BASE)
+
+/* --- EVENTCR Register -----*/
+
+/* Alias word address of EVOE bit */
+#define EVCR_OFFSET                 (AFIO_OFFSET + 0x00)
+#define EVOE_BitNumber              ((uint8_t)0x07)
+#define EVCR_EVOE_BB                (PERIPH_BB_BASE + (EVCR_OFFSET * 32) + (EVOE_BitNumber * 4))
+
+
+/* ---  MAPR Register ---*/ 
+/* Alias word address of MII_RMII_SEL bit */ 
+#define MAPR_OFFSET                 (AFIO_OFFSET + 0x04) 
+#define MII_RMII_SEL_BitNumber      ((u8)0x17) 
+#define MAPR_MII_RMII_SEL_BB        (PERIPH_BB_BASE + (MAPR_OFFSET * 32) + (MII_RMII_SEL_BitNumber * 4))
+
+
+#define EVCR_PORTPINCONFIG_MASK     ((uint16_t)0xFF80)
+#define LSB_MASK                    ((uint16_t)0xFFFF)
+#define DBGAFR_POSITION_MASK        ((uint32_t)0x000F0000)
+#define DBGAFR_SWJCFG_MASK          ((uint32_t)0xF0FFFFFF)
+#define DBGAFR_LOCATION_MASK        ((uint32_t)0x00200000)
+#define DBGAFR_NUMBITS_MASK         ((uint32_t)0x00100000)
+/**
+  * @}
+  */
+
+/** @defgroup GPIO_Private_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup GPIO_Private_Variables
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup GPIO_Private_FunctionPrototypes
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup GPIO_Private_Functions
+  * @{
+  */
+
+/**
+  * @brief  Deinitializes the GPIOx peripheral registers to their default reset values.
+  * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.
+  * @retval None
+  */
+void GPIO_DeInit(GPIO_TypeDef* GPIOx)
+{
+  /* Check the parameters */
+  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
+  
+  if (GPIOx == GPIOA)
+  {
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOA, ENABLE);
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOA, DISABLE);
+  }
+  else if (GPIOx == GPIOB)
+  {
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOB, ENABLE);
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOB, DISABLE);
+  }
+  else if (GPIOx == GPIOC)
+  {
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOC, ENABLE);
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOC, DISABLE);
+  }
+  else if (GPIOx == GPIOD)
+  {
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOD, ENABLE);
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOD, DISABLE);
+  }    
+  else if (GPIOx == GPIOE)
+  {
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOE, ENABLE);
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOE, DISABLE);
+  } 
+  else if (GPIOx == GPIOF)
+  {
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOF, ENABLE);
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOF, DISABLE);
+  }
+  else
+  {
+    if (GPIOx == GPIOG)
+    {
+      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, ENABLE);
+      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, DISABLE);
+    }
+  }
+}
+
+/**
+  * @brief  Deinitializes the Alternate Functions (remap, event control
+  *   and EXTI configuration) registers to their default reset values.
+  * @param  None
+  * @retval None
+  */
+void GPIO_AFIODeInit(void)
+{
+  RCC_APB2PeriphResetCmd(RCC_APB2Periph_AFIO, ENABLE);
+  RCC_APB2PeriphResetCmd(RCC_APB2Periph_AFIO, DISABLE);
+}
+
+/**
+  * @brief  Initializes the GPIOx peripheral according to the specified
+  *   parameters in the GPIO_InitStruct.
+  * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.
+  * @param  GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that
+  *   contains the configuration information for the specified GPIO peripheral.
+  * @retval None
+  */
+void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
+{
+  uint32_t currentmode = 0x00, currentpin = 0x00, pinpos = 0x00, pos = 0x00;
+  uint32_t tmpreg = 0x00, pinmask = 0x00;
+  /* Check the parameters */
+  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
+  assert_param(IS_GPIO_MODE(GPIO_InitStruct-&gt;GPIO_Mode));
+  assert_param(IS_GPIO_PIN(GPIO_InitStruct-&gt;GPIO_Pin));  
+  
+/*---------------------------- GPIO Mode Configuration -----------------------*/
+  currentmode = ((uint32_t)GPIO_InitStruct-&gt;GPIO_Mode) &amp; ((uint32_t)0x0F);
+  if ((((uint32_t)GPIO_InitStruct-&gt;GPIO_Mode) &amp; ((uint32_t)0x10)) != 0x00)
+  { 
+    /* Check the parameters */
+    assert_param(IS_GPIO_SPEED(GPIO_InitStruct-&gt;GPIO_Speed));
+    /* Output mode */
+    currentmode |= (uint32_t)GPIO_InitStruct-&gt;GPIO_Speed;
+  }
+/*---------------------------- GPIO CRL Configuration ------------------------*/
+  /* Configure the eight low port pins */
+  if (((uint32_t)GPIO_InitStruct-&gt;GPIO_Pin &amp; ((uint32_t)0x00FF)) != 0x00)
+  {
+    tmpreg = GPIOx-&gt;CRL;
+    for (pinpos = 0x00; pinpos &lt; 0x08; pinpos++)
+    {
+      pos = ((uint32_t)0x01) &lt;&lt; pinpos;
+      /* Get the port pins position */
+      currentpin = (GPIO_InitStruct-&gt;GPIO_Pin) &amp; pos;
+      if (currentpin == pos)
+      {
+        pos = pinpos &lt;&lt; 2;
+        /* Clear the corresponding low control register bits */
+        pinmask = ((uint32_t)0x0F) &lt;&lt; pos;
+        tmpreg &amp;= ~pinmask;
+        /* Write the mode configuration in the corresponding bits */
+        tmpreg |= (currentmode &lt;&lt; pos);
+        /* Reset the corresponding ODR bit */
+        if (GPIO_InitStruct-&gt;GPIO_Mode == GPIO_Mode_IPD)
+        {
+          GPIOx-&gt;BRR = (((uint32_t)0x01) &lt;&lt; pinpos);
+        }
+        else
+        {
+          /* Set the corresponding ODR bit */
+          if (GPIO_InitStruct-&gt;GPIO_Mode == GPIO_Mode_IPU)
+          {
+            GPIOx-&gt;BSRR = (((uint32_t)0x01) &lt;&lt; pinpos);
+          }
+        }
+      }
+    }
+    GPIOx-&gt;CRL = tmpreg;
+  }
+/*---------------------------- GPIO CRH Configuration ------------------------*/
+  /* Configure the eight high port pins */
+  if (GPIO_InitStruct-&gt;GPIO_Pin &gt; 0x00FF)
+  {
+    tmpreg = GPIOx-&gt;CRH;
+    for (pinpos = 0x00; pinpos &lt; 0x08; pinpos++)
+    {
+      pos = (((uint32_t)0x01) &lt;&lt; (pinpos + 0x08));
+      /* Get the port pins position */
+      currentpin = ((GPIO_InitStruct-&gt;GPIO_Pin) &amp; pos);
+      if (currentpin == pos)
+      {
+        pos = pinpos &lt;&lt; 2;
+        /* Clear the corresponding high control register bits */
+        pinmask = ((uint32_t)0x0F) &lt;&lt; pos;
+        tmpreg &amp;= ~pinmask;
+        /* Write the mode configuration in the corresponding bits */
+        tmpreg |= (currentmode &lt;&lt; pos);
+        /* Reset the corresponding ODR bit */
+        if (GPIO_InitStruct-&gt;GPIO_Mode == GPIO_Mode_IPD)
+        {
+          GPIOx-&gt;BRR = (((uint32_t)0x01) &lt;&lt; (pinpos + 0x08));
+        }
+        /* Set the corresponding ODR bit */
+        if (GPIO_InitStruct-&gt;GPIO_Mode == GPIO_Mode_IPU)
+        {
+          GPIOx-&gt;BSRR = (((uint32_t)0x01) &lt;&lt; (pinpos + 0x08));
+        }
+      }
+    }
+    GPIOx-&gt;CRH = tmpreg;
+  }
+}
+
+/**
+  * @brief  Fills each GPIO_InitStruct member with its default value.
+  * @param  GPIO_InitStruct : pointer to a GPIO_InitTypeDef structure which will
+  *   be initialized.
+  * @retval None
+  */
+void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
+{
+  /* Reset GPIO init structure parameters values */
+  GPIO_InitStruct-&gt;GPIO_Pin  = GPIO_Pin_All;
+  GPIO_InitStruct-&gt;GPIO_Speed = GPIO_Speed_2MHz;
+  GPIO_InitStruct-&gt;GPIO_Mode = GPIO_Mode_IN_FLOATING;
+}
+
+/**
+  * @brief  Reads the specified input port pin.
+  * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.
+  * @param  GPIO_Pin:  specifies the port bit to read.
+  *   This parameter can be GPIO_Pin_x where x can be (0..15).
+  * @retval The input port pin value.
+  */
+uint8_t GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
+{
+  uint8_t bitstatus = 0x00;
+  
+  /* Check the parameters */
+  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
+  assert_param(IS_GET_GPIO_PIN(GPIO_Pin)); 
+  
+  if ((GPIOx-&gt;IDR &amp; GPIO_Pin) != (uint32_t)Bit_RESET)
+  {
+    bitstatus = (uint8_t)Bit_SET;
+  }
+  else
+  {
+    bitstatus = (uint8_t)Bit_RESET;
+  }
+  return bitstatus;
+}
+
+/**
+  * @brief  Reads the specified GPIO input data port.
+  * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.
+  * @retval GPIO input data port value.
+  */
+uint16_t GPIO_ReadInputData(GPIO_TypeDef* GPIOx)
+{
+  /* Check the parameters */
+  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
+  
+  return ((uint16_t)GPIOx-&gt;IDR);
+}
+
+/**
+  * @brief  Reads the specified output data port bit.
+  * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.
+  * @param  GPIO_Pin:  specifies the port bit to read.
+  *   This parameter can be GPIO_Pin_x where x can be (0..15).
+  * @retval The output port pin value.
+  */
+uint8_t GPIO_ReadOutputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
+{
+  uint8_t bitstatus = 0x00;
+  /* Check the parameters */
+  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
+  assert_param(IS_GET_GPIO_PIN(GPIO_Pin)); 
+  
+  if ((GPIOx-&gt;ODR &amp; GPIO_Pin) != (uint32_t)Bit_RESET)
+  {
+    bitstatus = (uint8_t)Bit_SET;
+  }
+  else
+  {
+    bitstatus = (uint8_t)Bit_RESET;
+  }
+  return bitstatus;
+}
+
+/**
+  * @brief  Reads the specified GPIO output data port.
+  * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.
+  * @retval GPIO output data port value.
+  */
+uint16_t GPIO_ReadOutputData(GPIO_TypeDef* GPIOx)
+{
+  /* Check the parameters */
+  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
+    
+  return ((uint16_t)GPIOx-&gt;ODR);
+}
+
+/**
+  * @brief  Sets the selected data port bits.
+  * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.
+  * @param  GPIO_Pin: specifies the port bits to be written.
+  *   This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
+  * @retval None
+  */
+void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
+{
+  /* Check the parameters */
+  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
+  assert_param(IS_GPIO_PIN(GPIO_Pin));
+  
+  GPIOx-&gt;BSRR = GPIO_Pin;
+}
+
+/**
+  * @brief  Clears the selected data port bits.
+  * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.
+  * @param  GPIO_Pin: specifies the port bits to be written.
+  *   This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
+  * @retval None
+  */
+void GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
+{
+  /* Check the parameters */
+  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
+  assert_param(IS_GPIO_PIN(GPIO_Pin));
+  
+  GPIOx-&gt;BRR = GPIO_Pin;
+}
+
+/**
+  * @brief  Sets or clears the selected data port bit.
+  * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.
+  * @param  GPIO_Pin: specifies the port bit to be written.
+  *   This parameter can be one of GPIO_Pin_x where x can be (0..15).
+  * @param  BitVal: specifies the value to be written to the selected bit.
+  *   This parameter can be one of the BitAction enum values:
+  *     @arg Bit_RESET: to clear the port pin
+  *     @arg Bit_SET: to set the port pin
+  * @retval None
+  */
+void GPIO_WriteBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, BitAction BitVal)
+{
+  /* Check the parameters */
+  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
+  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
+  assert_param(IS_GPIO_BIT_ACTION(BitVal)); 
+  
+  if (BitVal != Bit_RESET)
+  {
+    GPIOx-&gt;BSRR = GPIO_Pin;
+  }
+  else
+  {
+    GPIOx-&gt;BRR = GPIO_Pin;
+  }
+}
+
+/**
+  * @brief  Writes data to the specified GPIO data port.
+  * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.
+  * @param  PortVal: specifies the value to be written to the port output data register.
+  * @retval None
+  */
+void GPIO_Write(GPIO_TypeDef* GPIOx, uint16_t PortVal)
+{
+  /* Check the parameters */
+  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
+  
+  GPIOx-&gt;ODR = PortVal;
+}
+
+/**
+  * @brief  Locks GPIO Pins configuration registers.
+  * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.
+  * @param  GPIO_Pin: specifies the port bit to be written.
+  *   This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
+  * @retval None
+  */
+void GPIO_PinLockConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
+{
+  uint32_t tmp = 0x00010000;
+  
+  /* Check the parameters */
+  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
+  assert_param(IS_GPIO_PIN(GPIO_Pin));
+  
+  tmp |= GPIO_Pin;
+  /* Set LCKK bit */
+  GPIOx-&gt;LCKR = tmp;
+  /* Reset LCKK bit */
+  GPIOx-&gt;LCKR =  GPIO_Pin;
+  /* Set LCKK bit */
+  GPIOx-&gt;LCKR = tmp;
+  /* Read LCKK bit*/
+  tmp = GPIOx-&gt;LCKR;
+  /* Read LCKK bit*/
+  tmp = GPIOx-&gt;LCKR;
+}
+
+/**
+  * @brief  Selects the GPIO pin used as Event output.
+  * @param  GPIO_PortSource: selects the GPIO port to be used as source
+  *   for Event output.
+  *   This parameter can be GPIO_PortSourceGPIOx where x can be (A..E).
+  * @param  GPIO_PinSource: specifies the pin for the Event output.
+  *   This parameter can be GPIO_PinSourcex where x can be (0..15).
+  * @retval None
+  */
+void GPIO_EventOutputConfig(uint8_t GPIO_PortSource, uint8_t GPIO_PinSource)
+{
+  uint32_t tmpreg = 0x00;
+  /* Check the parameters */
+  assert_param(IS_GPIO_EVENTOUT_PORT_SOURCE(GPIO_PortSource));
+  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
+    
+  tmpreg = AFIO-&gt;EVCR;
+  /* Clear the PORT[6:4] and PIN[3:0] bits */
+  tmpreg &amp;= EVCR_PORTPINCONFIG_MASK;
+  tmpreg |= (uint32_t)GPIO_PortSource &lt;&lt; 0x04;
+  tmpreg |= GPIO_PinSource;
+  AFIO-&gt;EVCR = tmpreg;
+}
+
+/**
+  * @brief  Enables or disables the Event Output.
+  * @param  NewState: new state of the Event output.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void GPIO_EventOutputCmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  *(__IO uint32_t *) EVCR_EVOE_BB = (uint32_t)NewState;
+}
+
+/**
+  * @brief  Changes the mapping of the specified pin.
+  * @param  GPIO_Remap: selects the pin to remap.
+  *   This parameter can be one of the following values:
+  *     @arg GPIO_Remap_SPI1
+  *     @arg GPIO_Remap_I2C1
+  *     @arg GPIO_Remap_USART1
+  *     @arg GPIO_Remap_USART2
+  *     @arg GPIO_PartialRemap_USART3
+  *     @arg GPIO_FullRemap_USART3
+  *     @arg GPIO_PartialRemap_TIM1
+  *     @arg GPIO_FullRemap_TIM1
+  *     @arg GPIO_PartialRemap1_TIM2
+  *     @arg GPIO_PartialRemap2_TIM2
+  *     @arg GPIO_FullRemap_TIM2
+  *     @arg GPIO_PartialRemap_TIM3
+  *     @arg GPIO_FullRemap_TIM3
+  *     @arg GPIO_Remap_TIM4
+  *     @arg GPIO_Remap1_CAN1
+  *     @arg GPIO_Remap2_CAN1
+  *     @arg GPIO_Remap_PD01
+  *     @arg GPIO_Remap_TIM5CH4_LSI
+  *     @arg GPIO_Remap_ADC1_ETRGINJ
+  *     @arg GPIO_Remap_ADC1_ETRGREG
+  *     @arg GPIO_Remap_ADC2_ETRGINJ
+  *     @arg GPIO_Remap_ADC2_ETRGREG
+  *     @arg GPIO_Remap_ETH
+  *     @arg GPIO_Remap_CAN2  
+  *     @arg GPIO_Remap_SWJ_NoJTRST
+  *     @arg GPIO_Remap_SWJ_JTAGDisable
+  *     @arg GPIO_Remap_SWJ_Disable
+  *     @arg GPIO_Remap_SPI3
+  *     @arg GPIO_Remap_TIM2ITR1_PTP_SOF
+  *     @arg GPIO_Remap_PTP_PPS  
+  * @note  If the GPIO_Remap_TIM2ITR1_PTP_SOF is enabled the TIM2 ITR1 is connected 
+  *        to Ethernet PTP output. When Reset TIM2 ITR1 is connected to USB OTG SOF output.       
+  * @param  NewState: new state of the port pin remapping.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void GPIO_PinRemapConfig(uint32_t GPIO_Remap, FunctionalState NewState)
+{
+  uint32_t tmp = 0x00, tmp1 = 0x00, tmpreg = 0x00, tmpmask = 0x00;
+
+  /* Check the parameters */
+  assert_param(IS_GPIO_REMAP(GPIO_Remap));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));  
+  
+  tmpreg = AFIO-&gt;MAPR;
+
+  tmpmask = (GPIO_Remap &amp; DBGAFR_POSITION_MASK) &gt;&gt; 0x10;
+  tmp = GPIO_Remap &amp; LSB_MASK;
+
+  if ((GPIO_Remap &amp; (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK)) == (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK))
+  {
+    tmpreg &amp;= DBGAFR_SWJCFG_MASK;
+    AFIO-&gt;MAPR &amp;= DBGAFR_SWJCFG_MASK;
+  }
+  else if ((GPIO_Remap &amp; DBGAFR_NUMBITS_MASK) == DBGAFR_NUMBITS_MASK)
+  {
+    tmp1 = ((uint32_t)0x03) &lt;&lt; tmpmask;
+    tmpreg &amp;= ~tmp1;
+    tmpreg |= ~DBGAFR_SWJCFG_MASK;
+  }
+  else
+  {
+    tmpreg &amp;= ~(tmp &lt;&lt; ((GPIO_Remap &gt;&gt; 0x15)*0x10));
+    tmpreg |= ~DBGAFR_SWJCFG_MASK;
+  }
+
+  if (NewState != DISABLE)
+  {
+    tmpreg |= (tmp &lt;&lt; ((GPIO_Remap &gt;&gt; 0x15)*0x10));
+  }
+
+  AFIO-&gt;MAPR = tmpreg;
+}
+
+/**
+  * @brief  Selects the GPIO pin used as EXTI Line.
+  * @param  GPIO_PortSource: selects the GPIO port to be used as source for EXTI lines.
+  *   This parameter can be GPIO_PortSourceGPIOx where x can be (A..G).
+  * @param  GPIO_PinSource: specifies the EXTI line to be configured.
+  *   This parameter can be GPIO_PinSourcex where x can be (0..15).
+  * @retval None
+  */
+void GPIO_EXTILineConfig(uint8_t GPIO_PortSource, uint8_t GPIO_PinSource)
+{
+  uint32_t tmp = 0x00;
+  /* Check the parameters */
+  assert_param(IS_GPIO_EXTI_PORT_SOURCE(GPIO_PortSource));
+  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
+  
+  tmp = ((uint32_t)0x0F) &lt;&lt; (0x04 * (GPIO_PinSource &amp; (uint8_t)0x03));
+  AFIO-&gt;EXTICR[GPIO_PinSource &gt;&gt; 0x02] &amp;= ~tmp;
+  AFIO-&gt;EXTICR[GPIO_PinSource &gt;&gt; 0x02] |= (((uint32_t)GPIO_PortSource) &lt;&lt; (0x04 * (GPIO_PinSource &amp; (uint8_t)0x03)));
+}
+
+/**
+  * @brief  Selects the Ethernet media interface.
+  * @note   This function applies only to STM32 Connectivity line devices.  
+  * @param  GPIO_ETH_MediaInterface: specifies the Media Interface mode.
+  *   This parameter can be one of the following values:
+  *     @arg GPIO_ETH_MediaInterface_MII: MII mode
+  *     @arg GPIO_ETH_MediaInterface_RMII: RMII mode    
+  * @retval None
+  */
+void GPIO_ETH_MediaInterfaceConfig(uint32_t GPIO_ETH_MediaInterface) 
+{ 
+  assert_param(IS_GPIO_ETH_MEDIA_INTERFACE(GPIO_ETH_MediaInterface)); 
+
+  /* Configure MII_RMII selection bit */ 
+  *(__IO uint32_t *) MAPR_MII_RMII_SEL_BB = GPIO_ETH_MediaInterface; 
+}
+  
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2009 STMicroelectronics *****END OF FILE****/

Added: trunk/src/platform/stm32/FWLib/library/src/stm32f10x_gpio.o
===================================================================
--- trunk/src/platform/stm32/FWLib/library/src/stm32f10x_gpio.o	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/src/stm32f10x_gpio.o	2009-07-08 23:39:34 UTC (rev 354)
@@ -0,0 +1,17 @@
+ELF
+&#177;a
+M	
+
+
+
+
+B
+B
+B
+B
+B
+B
+B
+B
+B
+B
\ No newline at end of file

Modified: trunk/src/platform/stm32/FWLib/library/src/stm32f10x_i2c.c
===================================================================
--- trunk/src/platform/stm32/FWLib/library/src/stm32f10x_i2c.c	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/src/stm32f10x_i2c.c	2009-07-08 23:39:34 UTC (rev 354)
@@ -1,1216 +1,1152 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_i2c.c
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file provides all the I2C firmware functions.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
-
-/* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_i2c.h&quot;
-#include &quot;stm32f10x_rcc.h&quot;
-	 
-/* Private typedef -----------------------------------------------------------*/
-/* Private define ------------------------------------------------------------*/
-/* I2C SPE mask */
-#define CR1_PE_Set              ((u16)0x0001)
-#define CR1_PE_Reset            ((u16)0xFFFE)
-
-/* I2C START mask */
-#define CR1_START_Set           ((u16)0x0100)
-#define CR1_START_Reset         ((u16)0xFEFF)
-
-/* I2C STOP mask */
-#define CR1_STOP_Set            ((u16)0x0200)
-#define CR1_STOP_Reset          ((u16)0xFDFF)
-
-/* I2C ACK mask */
-#define CR1_ACK_Set             ((u16)0x0400)
-#define CR1_ACK_Reset           ((u16)0xFBFF)
-
-/* I2C ENGC mask */
-#define CR1_ENGC_Set            ((u16)0x0040)
-#define CR1_ENGC_Reset          ((u16)0xFFBF)
-
-/* I2C SWRST mask */
-#define CR1_SWRST_Set           ((u16)0x8000)
-#define CR1_SWRST_Reset         ((u16)0x7FFF)
-
-/* I2C PEC mask */
-#define CR1_PEC_Set             ((u16)0x1000)
-#define CR1_PEC_Reset           ((u16)0xEFFF)
-
-/* I2C ENPEC mask */
-#define CR1_ENPEC_Set           ((u16)0x0020)
-#define CR1_ENPEC_Reset         ((u16)0xFFDF)
-
-/* I2C ENARP mask */
-#define CR1_ENARP_Set           ((u16)0x0010)
-#define CR1_ENARP_Reset         ((u16)0xFFEF)
-
-/* I2C NOSTRETCH mask */
-#define CR1_NOSTRETCH_Set       ((u16)0x0080)
-#define CR1_NOSTRETCH_Reset     ((u16)0xFF7F)
-
-/* I2C registers Masks */
-#define CR1_CLEAR_Mask          ((u16)0xFBF5)
-
-/* I2C DMAEN mask */
-#define CR2_DMAEN_Set           ((u16)0x0800)
-#define CR2_DMAEN_Reset         ((u16)0xF7FF)
-
-/* I2C LAST mask */
-#define CR2_LAST_Set            ((u16)0x1000)
-#define CR2_LAST_Reset          ((u16)0xEFFF)
-
-/* I2C FREQ mask */
-#define CR2_FREQ_Reset          ((u16)0xFFC0)
-
-/* I2C ADD0 mask */
-#define OAR1_ADD0_Set           ((u16)0x0001)
-#define OAR1_ADD0_Reset         ((u16)0xFFFE)
-
-/* I2C ENDUAL mask */
-#define OAR2_ENDUAL_Set         ((u16)0x0001)
-#define OAR2_ENDUAL_Reset       ((u16)0xFFFE)
-
-/* I2C ADD2 mask */
-#define OAR2_ADD2_Reset         ((u16)0xFF01)
-
-/* I2C F/S mask */
-#define CCR_FS_Set              ((u16)0x8000)
-
-/* I2C CCR mask */
-#define CCR_CCR_Set             ((u16)0x0FFF)
-
-/* I2C FLAG mask */
-#define FLAG_Mask               ((u32)0x00FFFFFF)
-
-/* I2C Interrupt Enable mask */
-#define ITEN_Mask               ((u32)0x07000000)
-
-/* Private macro -------------------------------------------------------------*/
-/* Private variables ---------------------------------------------------------*/
-/* Private function prototypes -----------------------------------------------*/
-/* Private functions ---------------------------------------------------------*/
-
-/*******************************************************************************
-* Function Name  : I2C_DeInit
-* Description    : Deinitializes the I2Cx peripheral registers to their default
-*                  reset values.
-* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void I2C_DeInit(I2C_TypeDef* I2Cx)
-{
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-
-  switch (*(u32*)&amp;I2Cx)
-  {
-    case I2C1_BASE:
-      /* Enable I2C1 reset state */
-      RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, ENABLE);
-      /* Release I2C1 from reset state */
-      RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, DISABLE);
-      break;
-
-    case I2C2_BASE:
-      /* Enable I2C2 reset state */
-      RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, ENABLE);
-      /* Release I2C2 from reset state */
-      RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, DISABLE);
-      break;
-
-    default:
-      break;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : I2C_Init
-* Description    : Initializes the I2Cx peripheral according to the specified 
-*                  parameters in the I2C_InitStruct.
-* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-*                  - I2C_InitStruct: pointer to a I2C_InitTypeDef structure that
-*                    contains the configuration information for the specified
-*                    I2C peripheral.
-* Output         : None
-* Return         : None
-******************************************************************************/
-void I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct)
-{
-  u16 tmpreg = 0, freqrange = 0;
-  u16 result = 0x04;
-  u32 pclk1 = 8000000;
-  RCC_ClocksTypeDef  rcc_clocks;
-
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_I2C_MODE(I2C_InitStruct-&gt;I2C_Mode));
-  assert_param(IS_I2C_DUTY_CYCLE(I2C_InitStruct-&gt;I2C_DutyCycle));
-  assert_param(IS_I2C_OWN_ADDRESS1(I2C_InitStruct-&gt;I2C_OwnAddress1));
-  assert_param(IS_I2C_ACK_STATE(I2C_InitStruct-&gt;I2C_Ack));
-  assert_param(IS_I2C_ACKNOWLEDGE_ADDRESS(I2C_InitStruct-&gt;I2C_AcknowledgedAddress));
-  assert_param(IS_I2C_CLOCK_SPEED(I2C_InitStruct-&gt;I2C_ClockSpeed));
-
-/*---------------------------- I2Cx CR2 Configuration ------------------------*/
-  /* Get the I2Cx CR2 value */
-  tmpreg = I2Cx-&gt;CR2;
-  /* Clear frequency FREQ[5:0] bits */
-  tmpreg &amp;= CR2_FREQ_Reset;
-  /* Get pclk1 frequency value */
-  RCC_GetClocksFreq(&amp;rcc_clocks);
-  pclk1 = rcc_clocks.PCLK1_Frequency;
-  /* Set frequency bits depending on pclk1 value */
-  freqrange = (u16)(pclk1 / 1000000);
-  tmpreg |= freqrange;
-  /* Write to I2Cx CR2 */
-  I2Cx-&gt;CR2 = tmpreg;
-
-/*---------------------------- I2Cx CCR Configuration ------------------------*/
-  /* Disable the selected I2C peripheral to configure TRISE */
-  I2Cx-&gt;CR1 &amp;= CR1_PE_Reset;
-
-  /* Reset tmpreg value */
-  /* Clear F/S, DUTY and CCR[11:0] bits */
-  tmpreg = 0;
-
-  /* Configure speed in standard mode */
-  if (I2C_InitStruct-&gt;I2C_ClockSpeed &lt;= 100000)
-  {
-    /* Standard mode speed calculate */
-    result = (u16)(pclk1 / (I2C_InitStruct-&gt;I2C_ClockSpeed &lt;&lt; 1));
-    /* Test if CCR value is under 0x4*/
-    if (result &lt; 0x04)
-    {
-      /* Set minimum allowed value */
-      result = 0x04;  
-    }
-    /* Set speed value for standard mode */
-    tmpreg |= result;	  
-    /* Set Maximum Rise Time for standard mode */
-    I2Cx-&gt;TRISE = freqrange + 1; 
-  }
-  /* Configure speed in fast mode */
-  else /*(I2C_InitStruct-&gt;I2C_ClockSpeed &lt;= 400000)*/
-  {
-    if (I2C_InitStruct-&gt;I2C_DutyCycle == I2C_DutyCycle_2)
-    {
-      /* Fast mode speed calculate: Tlow/Thigh = 2 */
-      result = (u16)(pclk1 / (I2C_InitStruct-&gt;I2C_ClockSpeed * 3));
-    }
-    else /*I2C_InitStruct-&gt;I2C_DutyCycle == I2C_DutyCycle_16_9*/
-    {
-      /* Fast mode speed calculate: Tlow/Thigh = 16/9 */
-      result = (u16)(pclk1 / (I2C_InitStruct-&gt;I2C_ClockSpeed * 25));
-      /* Set DUTY bit */
-      result |= I2C_DutyCycle_16_9;
-    }
-    /* Test if CCR value is under 0x1*/
-    if ((result &amp; CCR_CCR_Set) == 0)
-    {
-      /* Set minimum allowed value */
-      result |= (u16)0x0001;  
-    }
-    /* Set speed value and set F/S bit for fast mode */
-    tmpreg |= result | CCR_FS_Set;
-    /* Set Maximum Rise Time for fast mode */
-    I2Cx-&gt;TRISE = (u16)(((freqrange * 300) / 1000) + 1);  
-  }
-  /* Write to I2Cx CCR */
-  I2Cx-&gt;CCR = tmpreg;
-
-  /* Enable the selected I2C peripheral */
-  I2Cx-&gt;CR1 |= CR1_PE_Set;
-
-/*---------------------------- I2Cx CR1 Configuration ------------------------*/
-  /* Get the I2Cx CR1 value */
-  tmpreg = I2Cx-&gt;CR1;
-  /* Clear ACK, SMBTYPE and  SMBUS bits */
-  tmpreg &amp;= CR1_CLEAR_Mask;
-  /* Configure I2Cx: mode and acknowledgement */
-  /* Set SMBTYPE and SMBUS bits according to I2C_Mode value */
-  /* Set ACK bit according to I2C_Ack value */
-  tmpreg |= (u16)((u32)I2C_InitStruct-&gt;I2C_Mode | I2C_InitStruct-&gt;I2C_Ack);
-  /* Write to I2Cx CR1 */
-  I2Cx-&gt;CR1 = tmpreg;
-
-/*---------------------------- I2Cx OAR1 Configuration -----------------------*/
-  /* Set I2Cx Own Address1 and acknowledged address */
-  I2Cx-&gt;OAR1 = (I2C_InitStruct-&gt;I2C_AcknowledgedAddress | I2C_InitStruct-&gt;I2C_OwnAddress1);
-}
-
-/*******************************************************************************
-* Function Name  : I2C_StructInit
-* Description    : Fills each I2C_InitStruct member with its default value.
-* Input          : - I2C_InitStruct: pointer to an I2C_InitTypeDef structure
-*                    which will be initialized.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct)
-{
-/*---------------- Reset I2C init structure parameters values ----------------*/
-  /* Initialize the I2C_Mode member */
-  I2C_InitStruct-&gt;I2C_Mode = I2C_Mode_I2C;
-
-  /* Initialize the I2C_DutyCycle member */
-  I2C_InitStruct-&gt;I2C_DutyCycle = I2C_DutyCycle_2;
-
-  /* Initialize the I2C_OwnAddress1 member */
-  I2C_InitStruct-&gt;I2C_OwnAddress1 = 0;
-
-  /* Initialize the I2C_Ack member */
-  I2C_InitStruct-&gt;I2C_Ack = I2C_Ack_Disable;
-
-  /* Initialize the I2C_AcknowledgedAddress member */
-  I2C_InitStruct-&gt;I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
-
-  /* initialize the I2C_ClockSpeed member */
-  I2C_InitStruct-&gt;I2C_ClockSpeed = 5000;
-}
-
-/*******************************************************************************
-* Function Name  : I2C_Cmd
-* Description    : Enables or disables the specified I2C peripheral.
-* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-*                  - NewState: new state of the I2Cx peripheral. This parameter
-*                    can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected I2C peripheral */
-    I2Cx-&gt;CR1 |= CR1_PE_Set;
-  }
-  else
-  {
-    /* Disable the selected I2C peripheral */
-    I2Cx-&gt;CR1 &amp;= CR1_PE_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : I2C_DMACmd
-* Description    : Enables or disables the specified I2C DMA requests.
-* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-*                  - NewState: new state of the I2C DMA transfer.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void I2C_DMACmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected I2C DMA requests */
-    I2Cx-&gt;CR2 |= CR2_DMAEN_Set;
-  }
-  else
-  {
-    /* Disable the selected I2C DMA requests */
-    I2Cx-&gt;CR2 &amp;= CR2_DMAEN_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : I2C_DMALastTransferCmd
-* Description    : Specifies that the next DMA transfer is the last one.
-* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-*                  - NewState: new state of the I2C DMA last transfer.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void I2C_DMALastTransferCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Next DMA transfer is the last transfer */
-    I2Cx-&gt;CR2 |= CR2_LAST_Set;
-  }
-  else
-  {
-    /* Next DMA transfer is not the last transfer */
-    I2Cx-&gt;CR2 &amp;= CR2_LAST_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : I2C_GenerateSTART
-* Description    : Generates I2Cx communication START condition.
-* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-*                  - NewState: new state of the I2C START condition generation.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None.
-*******************************************************************************/
-void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Generate a START condition */
-    I2Cx-&gt;CR1 |= CR1_START_Set;
-  }
-  else
-  {
-    /* Disable the START condition generation */
-    I2Cx-&gt;CR1 &amp;= CR1_START_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : I2C_GenerateSTOP
-* Description    : Generates I2Cx communication STOP condition.
-* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-*                  - NewState: new state of the I2C STOP condition generation.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None.
-*******************************************************************************/
-void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Generate a STOP condition */
-    I2Cx-&gt;CR1 |= CR1_STOP_Set;
-  }
-  else
-  {
-    /* Disable the STOP condition generation */
-    I2Cx-&gt;CR1 &amp;= CR1_STOP_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : I2C_AcknowledgeConfig
-* Description    : Enables or disables the specified I2C acknowledge feature.
-* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-*                  - NewState: new state of the I2C Acknowledgement.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None.
-*******************************************************************************/
-void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Enable the acknowledgement */
-    I2Cx-&gt;CR1 |= CR1_ACK_Set;
-  }
-  else
-  {
-    /* Disable the acknowledgement */
-    I2Cx-&gt;CR1 &amp;= CR1_ACK_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : I2C_OwnAddress2Config
-* Description    : Configures the specified I2C own address2.
-* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-*                  - Address: specifies the 7bit I2C own address2.
-* Output         : None
-* Return         : None.
-*******************************************************************************/
-void I2C_OwnAddress2Config(I2C_TypeDef* I2Cx, u8 Address)
-{
-  u16 tmpreg = 0;
-
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-
-  /* Get the old register value */
-  tmpreg = I2Cx-&gt;OAR2;
-  /* Reset I2Cx Own address2 bit [7:1] */
-  tmpreg &amp;= OAR2_ADD2_Reset;
-  /* Set I2Cx Own address2 */
-  tmpreg |= (u16)(Address &amp; (u16)0x00FE);
-  /* Store the new register value */
-  I2Cx-&gt;OAR2 = tmpreg;
-}
-
-/*******************************************************************************
-* Function Name  : I2C_DualAddressCmd
-* Description    : Enables or disables the specified I2C dual addressing mode.
-* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-*                  - NewState: new state of the I2C dual addressing mode.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void I2C_DualAddressCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Enable dual addressing mode */
-    I2Cx-&gt;OAR2 |= OAR2_ENDUAL_Set;
-  }
-  else
-  {
-    /* Disable dual addressing mode */
-    I2Cx-&gt;OAR2 &amp;= OAR2_ENDUAL_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : I2C_GeneralCallCmd
-* Description    : Enables or disables the specified I2C general call feature.
-* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-*                  - NewState: new state of the I2C General call.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void I2C_GeneralCallCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Enable generall call */
-    I2Cx-&gt;CR1 |= CR1_ENGC_Set;
-  }
-  else
-  {
-    /* Disable generall call */
-    I2Cx-&gt;CR1 &amp;= CR1_ENGC_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : I2C_ITConfig
-* Description    : Enables or disables the specified I2C interrupts.
-* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-*                  - I2C_IT: specifies the I2C interrupts sources to be enabled
-*                    or disabled. 
-*                    This parameter can be any combination of the following values:
-*                       - I2C_IT_BUF: Buffer interrupt mask
-*                       - I2C_IT_EVT: Event interrupt mask
-*                       - I2C_IT_ERR: Error interrupt mask
-*                  - NewState: new state of the specified I2C interrupts.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void I2C_ITConfig(I2C_TypeDef* I2Cx, u16 I2C_IT, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  assert_param(IS_I2C_CONFIG_IT(I2C_IT));
-  
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected I2C interrupts */
-    I2Cx-&gt;CR2 |= I2C_IT;
-  }
-  else
-  {
-    /* Disable the selected I2C interrupts */
-    I2Cx-&gt;CR2 &amp;= (u16)~I2C_IT;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : I2C_SendData
-* Description    : Sends a data byte through the I2Cx peripheral.
-* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-*                  - Data: Byte to be transmitted..
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void I2C_SendData(I2C_TypeDef* I2Cx, u8 Data)
-{
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-
-  /* Write in the DR register the data to be sent */
-  I2Cx-&gt;DR = Data;
-}
-
-/*******************************************************************************
-* Function Name  : I2C_ReceiveData
-* Description    : Returns the most recent received data by the I2Cx peripheral.
-* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-* Output         : None
-* Return         : The value of the received data.
-*******************************************************************************/
-u8 I2C_ReceiveData(I2C_TypeDef* I2Cx)
-{
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-
-  /* Return the data in the DR register */
-  return (u8)I2Cx-&gt;DR;
-}
-
-/*******************************************************************************
-* Function Name  : I2C_Send7bitAddress
-* Description    : Transmits the address byte to select the slave device.
-* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-*                  - Address: specifies the slave address which will be transmitted
-*                  - I2C_Direction: specifies whether the I2C device will be a
-*                    Transmitter or a Receiver. 
-*                    This parameter can be one of the following values
-*                       - I2C_Direction_Transmitter: Transmitter mode
-*                       - I2C_Direction_Receiver: Receiver mode
-* Output         : None
-* Return         : None.
-*******************************************************************************/
-void I2C_Send7bitAddress(I2C_TypeDef* I2Cx, u8 Address, u8 I2C_Direction)
-{
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_I2C_DIRECTION(I2C_Direction));
-
-  /* Test on the direction to set/reset the read/write bit */
-  if (I2C_Direction != I2C_Direction_Transmitter)
-  {
-    /* Set the address bit0 for read */
-    Address |= OAR1_ADD0_Set;
-  }
-  else
-  {
-    /* Reset the address bit0 for write */
-    Address &amp;= OAR1_ADD0_Reset;
-  }
-  /* Send the address */
-  I2Cx-&gt;DR = Address;
-}
-
-/*******************************************************************************
-* Function Name  : I2C_ReadRegister
-* Description    : Reads the specified I2C register and returns its value.
-* Input1         : - I2C_Register: specifies the register to read.
-*                    This parameter can be one of the following values:
-*                       - I2C_Register_CR1:  CR1 register.
-*                       - I2C_Register_CR2:   CR2 register.
-*                       - I2C_Register_OAR1:  OAR1 register.
-*                       - I2C_Register_OAR2:  OAR2 register.
-*                       - I2C_Register_DR:    DR register.
-*                       - I2C_Register_SR1:   SR1 register.
-*                       - I2C_Register_SR2:   SR2 register.
-*                       - I2C_Register_CCR:   CCR register.
-*                       - I2C_Register_TRISE: TRISE register.
-* Output         : None
-* Return         : The value of the read register.
-*******************************************************************************/
-u16 I2C_ReadRegister(I2C_TypeDef* I2Cx, u8 I2C_Register)
-{
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_I2C_REGISTER(I2C_Register));
-
-  /* Return the selected register value */
-  return (*(vu16 *)(*((vu32 *)&amp;I2Cx) + I2C_Register));
-}
-
-/*******************************************************************************
-* Function Name  : I2C_SoftwareResetCmd
-* Description    : Enables or disables the specified I2C software reset.
-* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-*                  - NewState: new state of the I2C software reset.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void I2C_SoftwareResetCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Peripheral under reset */
-    I2Cx-&gt;CR1 |= CR1_SWRST_Set;
-  }
-  else
-  {
-    /* Peripheral not under reset */
-    I2Cx-&gt;CR1 &amp;= CR1_SWRST_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : I2C_SMBusAlertConfig
-* Description    : Drives the SMBusAlert pin high or low for the specified I2C.
-* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-*                  - I2C_SMBusAlert: specifies SMBAlert pin level. 
-*                    This parameter can be one of the following values:
-*                       - I2C_SMBusAlert_Low: SMBAlert pin driven low
-*                       - I2C_SMBusAlert_High: SMBAlert pin driven high
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void I2C_SMBusAlertConfig(I2C_TypeDef* I2Cx, u16 I2C_SMBusAlert)
-{
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_I2C_SMBUS_ALERT(I2C_SMBusAlert));
-
-  if (I2C_SMBusAlert == I2C_SMBusAlert_Low)
-  {
-    /* Drive the SMBusAlert pin Low */
-    I2Cx-&gt;CR1 |= I2C_SMBusAlert_Low;
-  }
-  else
-  {
-    /* Drive the SMBusAlert pin High  */
-    I2Cx-&gt;CR1 &amp;= I2C_SMBusAlert_High;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : I2C_TransmitPEC
-* Description    : Enables or disables the specified I2C PEC transfer.
-* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-*                  - NewState: new state of the I2C PEC transmission.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void I2C_TransmitPEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected I2C PEC transmission */
-    I2Cx-&gt;CR1 |= CR1_PEC_Set;
-  }
-  else
-  {
-    /* Disable the selected I2C PEC transmission */
-    I2Cx-&gt;CR1 &amp;= CR1_PEC_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : I2C_PECPositionConfig
-* Description    : Selects the specified I2C PEC position.
-* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-*                  - I2C_PECPosition: specifies the PEC position. 
-*                    This parameter can be one of the following values:
-*                       - I2C_PECPosition_Next: indicates that the next
-*                         byte is PEC
-*                       - I2C_PECPosition_Current: indicates that current
-*                         byte is PEC
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void I2C_PECPositionConfig(I2C_TypeDef* I2Cx, u16 I2C_PECPosition)
-{
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_I2C_PEC_POSITION(I2C_PECPosition));
-
-  if (I2C_PECPosition == I2C_PECPosition_Next)
-  {
-    /* Next byte in shift register is PEC */
-    I2Cx-&gt;CR1 |= I2C_PECPosition_Next;
-  }
-  else
-  {
-    /* Current byte in shift register is PEC */
-    I2Cx-&gt;CR1 &amp;= I2C_PECPosition_Current;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : I2C_CalculatePEC
-* Description    : Enables or disables the PEC value calculation of the
-*                  transfered bytes.
-* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-*                  - NewState: new state of the I2Cx PEC value calculation.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void I2C_CalculatePEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected I2C PEC calculation */
-    I2Cx-&gt;CR1 |= CR1_ENPEC_Set;
-  }
-  else
-  {
-    /* Disable the selected I2C PEC calculation */
-    I2Cx-&gt;CR1 &amp;= CR1_ENPEC_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : I2C_GetPEC
-* Description    : Returns the PEC value for the specified I2C.
-* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-* Output         : None
-* Return         : The PEC value.
-*******************************************************************************/
-u8 I2C_GetPEC(I2C_TypeDef* I2Cx)
-{
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-
-  /* Return the selected I2C PEC value */
-  return ((I2Cx-&gt;SR2) &gt;&gt; 8);
-}
-
-/*******************************************************************************
-* Function Name  : I2C_ARPCmd
-* Description    : Enables or disables the specified I2C ARP.
-* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-*                  - NewState: new state of the I2Cx ARP. 
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void I2C_ARPCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected I2C ARP */
-    I2Cx-&gt;CR1 |= CR1_ENARP_Set;
-  }
-  else
-  {
-    /* Disable the selected I2C ARP */
-    I2Cx-&gt;CR1 &amp;= CR1_ENARP_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : I2C_StretchClockCmd
-* Description    : Enables or disables the specified I2C Clock stretching.
-* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-*                  - NewState: new state of the I2Cx Clock stretching.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void I2C_StretchClockCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState == DISABLE)
-  {
-    /* Enable the selected I2C Clock stretching */
-    I2Cx-&gt;CR1 |= CR1_NOSTRETCH_Set;
-  }
-  else
-  {
-    /* Disable the selected I2C Clock stretching */
-    I2Cx-&gt;CR1 &amp;= CR1_NOSTRETCH_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : I2C_FastModeDutyCycleConfig
-* Description    : Selects the specified I2C fast mode duty cycle.
-* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-*                  - I2C_DutyCycle: specifies the fast mode duty cycle.
-*                    This parameter can be one of the following values:
-*                       - I2C_DutyCycle_2: I2C fast mode Tlow/Thigh = 2
-*                       - I2C_DutyCycle_16_9: I2C fast mode Tlow/Thigh = 16/9
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void I2C_FastModeDutyCycleConfig(I2C_TypeDef* I2Cx, u16 I2C_DutyCycle)
-{
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_I2C_DUTY_CYCLE(I2C_DutyCycle));
-
-  if (I2C_DutyCycle != I2C_DutyCycle_16_9)
-  {
-    /* I2C fast mode Tlow/Thigh=2 */
-    I2Cx-&gt;CCR &amp;= I2C_DutyCycle_2;
-  }
-  else
-  {
-    /* I2C fast mode Tlow/Thigh=16/9 */
-    I2Cx-&gt;CCR |= I2C_DutyCycle_16_9;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : I2C_GetLastEvent
-* Description    : Returns the last I2Cx Event.
-* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-* Output         : None
-* Return         : The last event
-*******************************************************************************/
-u32 I2C_GetLastEvent(I2C_TypeDef* I2Cx)
-{
-  u32 lastevent = 0;
-  u32 flag1 = 0, flag2 = 0;
-
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-
-  /* Read the I2Cx status register */
-  flag1 = I2Cx-&gt;SR1;
-  flag2 = I2Cx-&gt;SR2;
-  flag2 = flag2 &lt;&lt; 16;
-
-  /* Get the last event value from I2C status register */
-  lastevent = (flag1 | flag2) &amp; FLAG_Mask;
-
-  /* Return status */
-  return lastevent;
-}
-
-/*******************************************************************************
-* Function Name  : I2C_CheckEvent
-* Description    : Checks whether the last I2Cx Event is equal to the one passed
-*                  as parameter.
-* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-*                  - I2C_EVENT: specifies the event to be checked. 
-*                    This parameter can be one of the following values:
-*                       - I2C_EVENT_SLAVE_ADDRESS_MATCHED   : EV1
-*                       - I2C_EVENT_SLAVE_BYTE_RECEIVED     : EV2
-*                       - I2C_EVENT_SLAVE_BYTE_TRANSMITTED  : EV3
-*                       - I2C_EVENT_SLAVE_ACK_FAILURE       : EV3-2
-*                       - I2C_EVENT_MASTER_MODE_SELECT      : EV5
-*                       - I2C_EVENT_MASTER_MODE_SELECTED    : EV6
-*                       - I2C_EVENT_MASTER_BYTE_RECEIVED    : EV7
-*                       - I2C_EVENT_MASTER_BYTE_TRANSMITTED : EV8
-*                       - I2C_EVENT_MASTER_MODE_ADDRESS10   : EV9
-*                       - I2C_EVENT_SLAVE_STOP_DETECTED     : EV4
-* Output         : None
-* Return         : An ErrorStatus enumuration value:
-*                       - SUCCESS: Last event is equal to the I2C_EVENT
-*                       - ERROR: Last event is different from the I2C_EVENT
-*******************************************************************************/
-ErrorStatus I2C_CheckEvent(I2C_TypeDef* I2Cx, u32 I2C_EVENT)
-{
-  u32 lastevent = 0;
-  u32 flag1 = 0, flag2 = 0;
-  ErrorStatus status = ERROR;
-
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_I2C_EVENT(I2C_EVENT));
-
-  /* Read the I2Cx status register */
-  flag1 = I2Cx-&gt;SR1;
-  flag2 = I2Cx-&gt;SR2;
-  flag2 = flag2 &lt;&lt; 16;
-
-  /* Get the last event value from I2C status register */
-  lastevent = (flag1 | flag2) &amp; FLAG_Mask;
-
-  /* Check whether the last event is equal to I2C_EVENT */
-  if (lastevent == I2C_EVENT )
-  {
-    /* SUCCESS: last event is equal to I2C_EVENT */
-    status = SUCCESS;
-  }
-  else
-  {
-    /* ERROR: last event is different from I2C_EVENT */
-    status = ERROR;
-  }
-
-  /* Return status */
-  return status;
-}
-
-/*******************************************************************************
-* Function Name  : I2C_GetFlagStatus
-* Description    : Checks whether the specified I2C flag is set or not.
-* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-*                  - I2C_FLAG: specifies the flag to check. 
-*                    This parameter can be one of the following values:
-*                       - I2C_FLAG_DUALF: Dual flag (Slave mode)
-*                       - I2C_FLAG_SMBHOST: SMBus host header (Slave mode)
-*                       - I2C_FLAG_SMBDEFAULT: SMBus default header (Slave mode)
-*                       - I2C_FLAG_GENCALL: General call header flag (Slave mode)
-*                       - I2C_FLAG_TRA: Transmitter/Receiver flag
-*                       - I2C_FLAG_BUSY: Bus busy flag
-*                       - I2C_FLAG_MSL: Master/Slave flag
-*                       - I2C_FLAG_SMBALERT: SMBus Alert flag
-*                       - I2C_FLAG_TIMEOUT: Timeout or Tlow error flag
-*                       - I2C_FLAG_PECERR: PEC error in reception flag
-*                       - I2C_FLAG_OVR: Overrun/Underrun flag (Slave mode)
-*                       - I2C_FLAG_AF: Acknowledge failure flag
-*                       - I2C_FLAG_ARLO: Arbitration lost flag (Master mode)
-*                       - I2C_FLAG_BERR: Bus error flag
-*                       - I2C_FLAG_TXE: Data register empty flag (Transmitter)
-*                       - I2C_FLAG_RXNE: Data register not empty (Receiver) flag
-*                       - I2C_FLAG_STOPF: Stop detection flag (Slave mode)
-*                       - I2C_FLAG_ADD10: 10-bit header sent flag (Master mode)
-*                       - I2C_FLAG_BTF: Byte transfer finished flag
-*                       - I2C_FLAG_ADDR: Address sent flag (Master mode) 'ADSL'
-*                                        Address matched flag (Slave mode)'ENDAD'
-*                       - I2C_FLAG_SB: Start bit flag (Master mode)
-* Output         : None
-* Return         : The new state of I2C_FLAG (SET or RESET).
-*******************************************************************************/
-FlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, u32 I2C_FLAG)
-{
-  FlagStatus bitstatus = RESET;
-  u32 i2creg = 0, i2cxbase = 0;
-
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_I2C_GET_FLAG(I2C_FLAG));
-
-  /* Get the I2Cx peripheral base address */
-  i2cxbase = (*(u32*)&amp;(I2Cx));
-  
-  /* Read flag register index */
-  i2creg = I2C_FLAG &gt;&gt; 28;
-  
-  /* Get bit[23:0] of the flag */
-  I2C_FLAG &amp;= FLAG_Mask;
-  
-  if(i2creg != 0)
-  {
-    /* Get the I2Cx SR1 register address */
-    i2cxbase += 0x14;
-  }
-  else
-  {
-    /* Flag in I2Cx SR2 Register */
-    I2C_FLAG = (u32)(I2C_FLAG &gt;&gt; 16);
-    /* Get the I2Cx SR2 register address */
-    i2cxbase += 0x18;
-  }
-  
-  if(((*(vu32 *)i2cxbase) &amp; I2C_FLAG) != (u32)RESET)
-  {
-    /* I2C_FLAG is set */
-    bitstatus = SET;
-  }
-  else
-  {
-    /* I2C_FLAG is reset */
-    bitstatus = RESET;
-  }
-  
-  /* Return the I2C_FLAG status */
-  return  bitstatus;
-}
-
-/*******************************************************************************
-* Function Name  : I2C_ClearFlag
-* Description    : Clears the I2Cx's pending flags.
-* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-*                  - I2C_FLAG: specifies the flag to clear. 
-*                    This parameter can be any combination of the following
-*                    values:
-*                       - I2C_FLAG_SMBALERT: SMBus Alert flag
-*                       - I2C_FLAG_TIMEOUT: Timeout or Tlow error flag
-*                       - I2C_FLAG_PECERR: PEC error in reception flag
-*                       - I2C_FLAG_OVR: Overrun/Underrun flag (Slave mode)
-*                       - I2C_FLAG_AF: Acknowledge failure flag
-*                       - I2C_FLAG_ARLO: Arbitration lost flag (Master mode)
-*                       - I2C_FLAG_BERR: Bus error flag
-*                       
-*                  Notes: 
-*                        - STOPF (STOP detection) is cleared by software 
-*                          sequence: a read operation to I2C_SR1 register 
-*                          (I2C_GetFlagStatus()) followed by a write operation 
-*                          to I2C_CR1 register (I2C_Cmd() to re-enable the 
-*                          I2C peripheral). 
-*                        - ADD10 (10-bit header sent) is cleared by software 
-*                          sequence: a read operation to I2C_SR1 
-*                          (I2C_GetFlagStatus()) followed by writing the
-*                          second byte of the address in DR register.
-*                        - BTF (Byte Transfer Finished) is cleared by software 
-*                          sequence: a read operation to I2C_SR1 register 
-*                          (I2C_GetFlagStatus()) followed by a read/write to 
-*                          I2C_DR register (I2C_SendData()).
-*                        - ADDR (Address sent) is cleared by software sequence: 
-*                          a read operation to I2C_SR1 register 
-*                          (I2C_GetFlagStatus()) followed by a read operation to 
-*                          I2C_SR2 register ((void)(I2Cx-&gt;SR2)).
-*                        - SB (Start Bit) is cleared software sequence: a read 
-*                          operation to I2C_SR1 register (I2C_GetFlagStatus()) 
-*                          followed by a write operation to I2C_DR reigister 
-*                          (I2C_SendData()). 
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void I2C_ClearFlag(I2C_TypeDef* I2Cx, u32 I2C_FLAG)
-{
-  u32 flagpos = 0;
-
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_I2C_CLEAR_FLAG(I2C_FLAG));
-
-  /* Get the I2C flag position */
-  flagpos = I2C_FLAG &amp; FLAG_Mask;
-
-  /* Clear the selected I2C flag */
-  I2Cx-&gt;SR1 = (u16)~flagpos;
-}
-
-/*******************************************************************************
-* Function Name  : I2C_GetITStatus
-* Description    : Checks whether the specified I2C interrupt has occurred or not.
-* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-*                  - I2C_IT: specifies the interrupt source to check. 
-*                    This parameter can be one of the following values:
-*                       - I2C_IT_SMBALERT: SMBus Alert flag
-*                       - I2C_IT_TIMEOUT: Timeout or Tlow error flag
-*                       - I2C_IT_PECERR: PEC error in reception flag
-*                       - I2C_IT_OVR: Overrun/Underrun flag (Slave mode)
-*                       - I2C_IT_AF: Acknowledge failure flag
-*                       - I2C_IT_ARLO: Arbitration lost flag (Master mode)
-*                       - I2C_IT_BERR: Bus error flag
-*                       - I2C_IT_TXE: Data register empty flag (Transmitter)
-*                       - I2C_IT_RXNE: Data register not empty (Receiver) flag
-*                       - I2C_IT_STOPF: Stop detection flag (Slave mode)
-*                       - I2C_IT_ADD10: 10-bit header sent flag (Master mode)
-*                       - I2C_IT_BTF: Byte transfer finished flag
-*                       - I2C_IT_ADDR: Address sent flag (Master mode) 'ADSL'
-*                                      Address matched flag (Slave mode)'ENDAD'
-*                       - I2C_IT_SB: Start bit flag (Master mode)
-* Output         : None
-* Return         : The new state of I2C_IT (SET or RESET).
-*******************************************************************************/
-ITStatus I2C_GetITStatus(I2C_TypeDef* I2Cx, u32 I2C_IT)
-{
-  ITStatus bitstatus = RESET;
-  u32 enablestatus = 0;
-
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_I2C_GET_IT(I2C_IT));
-
-  /* Check if the interrupt source is enabled or not */
-  enablestatus = (u32)(((I2C_IT &amp; ITEN_Mask) &gt;&gt; 16) &amp; (I2Cx-&gt;CR2)) ;  
-
-  /* Get bit[23:0] of the flag */
-  I2C_IT &amp;= FLAG_Mask;
-
-  /* Check the status of the specified I2C flag */
-  if (((I2Cx-&gt;SR1 &amp; I2C_IT) != (u32)RESET) &amp;&amp; enablestatus)
-  {
-    /* I2C_IT is set */
-    bitstatus = SET;
-  }
-  else
-  {
-    /* I2C_IT is reset */
-    bitstatus = RESET;
-  }
-  /* Return the I2C_IT status */
-  return  bitstatus;
-}
-
-/*******************************************************************************
-* Function Name  : I2C_ClearITPendingBit
-* Description    : Clears the I2Cx's interrupt pending bits.
-* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-*                  - I2C_IT: specifies the interrupt pending bit to clear. 
-*                    This parameter can be any combination of the following 
-*                    values:
-*                       - I2C_IT_SMBALERT: SMBus Alert interrupt
-*                       - I2C_IT_TIMEOUT: Timeout or Tlow error interrupt
-*                       - I2C_IT_PECERR: PEC error in reception  interrupt
-*                       - I2C_IT_OVR: Overrun/Underrun interrupt (Slave mode)
-*                       - I2C_IT_AF: Acknowledge failure interrupt
-*                       - I2C_IT_ARLO: Arbitration lost interrupt (Master mode)
-*                       - I2C_IT_BERR: Bus error interrupt
-*                       
-*                  Notes:
-*                        - STOPF (STOP detection) is cleared by software 
-*                          sequence: a read operation to I2C_SR1 register 
-*                          (I2C_GetITStatus()) followed by a write operation to 
-*                          I2C_CR1 register (I2C_Cmd() to re-enable the I2C 
-*                          peripheral). 
-*                        - ADD10 (10-bit header sent) is cleared by software 
-*                          sequence: a read operation to I2C_SR1 
-*                          (I2C_GetITStatus()) followed by writing the second 
-*                          byte of the address in I2C_DR register.
-*                        - BTF (Byte Transfer Finished) is cleared by software 
-*                          sequence: a read operation to I2C_SR1 register 
-*                          (I2C_GetITStatus()) followed by a read/write to 
-*                          I2C_DR register (I2C_SendData()).
-*                        - ADDR (Address sent) is cleared by software sequence: 
-*                          a read operation to I2C_SR1 register (I2C_GetITStatus()) 
-*                          followed by a read operation to I2C_SR2 register 
-*                          ((void)(I2Cx-&gt;SR2)).
-*                        - SB (Start Bit) is cleared by software sequence: a 
-*                          read operation to I2C_SR1 register (I2C_GetITStatus()) 
-*                          followed by a write operation to I2C_DR reigister 
-*                          (I2C_SendData()). 
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void I2C_ClearITPendingBit(I2C_TypeDef* I2Cx, u32 I2C_IT)
-{
-  u32 flagpos = 0;
-
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_I2C_CLEAR_IT(I2C_IT));
-
-  /* Get the I2C flag position */
-  flagpos = I2C_IT &amp; FLAG_Mask;
-
-  /* Clear the selected I2C flag */
-  I2Cx-&gt;SR1 = (u16)~flagpos;
-}
-
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
+/**
+  ******************************************************************************
+  * @file    stm32f10x_i2c.c
+  * @author  MCD Application Team
+  * @version V3.1.0
+  * @date    06/19/2009
+  * @brief   This file provides all the I2C firmware functions.
+  ******************************************************************************
+  * @copy
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * &lt;h2&gt;&lt;center&gt;&copy; COPYRIGHT 2009 STMicroelectronics&lt;/center&gt;&lt;/h2&gt;
+  */ 
+
+/* Includes ------------------------------------------------------------------*/
+#include &quot;stm32f10x_i2c.h&quot;
+#include &quot;stm32f10x_rcc.h&quot;
+
+
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup I2C 
+  * @brief I2C driver modules
+  * @{
+  */ 
+
+/** @defgroup I2C_Private_TypesDefinitions
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup I2C_Private_Defines
+  * @{
+  */
+
+/* I2C SPE mask */
+#define CR1_PE_Set              ((uint16_t)0x0001)
+#define CR1_PE_Reset            ((uint16_t)0xFFFE)
+
+/* I2C START mask */
+#define CR1_START_Set           ((uint16_t)0x0100)
+#define CR1_START_Reset         ((uint16_t)0xFEFF)
+
+/* I2C STOP mask */
+#define CR1_STOP_Set            ((uint16_t)0x0200)
+#define CR1_STOP_Reset          ((uint16_t)0xFDFF)
+
+/* I2C ACK mask */
+#define CR1_ACK_Set             ((uint16_t)0x0400)
+#define CR1_ACK_Reset           ((uint16_t)0xFBFF)
+
+/* I2C ENGC mask */
+#define CR1_ENGC_Set            ((uint16_t)0x0040)
+#define CR1_ENGC_Reset          ((uint16_t)0xFFBF)
+
+/* I2C SWRST mask */
+#define CR1_SWRST_Set           ((uint16_t)0x8000)
+#define CR1_SWRST_Reset         ((uint16_t)0x7FFF)
+
+/* I2C PEC mask */
+#define CR1_PEC_Set             ((uint16_t)0x1000)
+#define CR1_PEC_Reset           ((uint16_t)0xEFFF)
+
+/* I2C ENPEC mask */
+#define CR1_ENPEC_Set           ((uint16_t)0x0020)
+#define CR1_ENPEC_Reset         ((uint16_t)0xFFDF)
+
+/* I2C ENARP mask */
+#define CR1_ENARP_Set           ((uint16_t)0x0010)
+#define CR1_ENARP_Reset         ((uint16_t)0xFFEF)
+
+/* I2C NOSTRETCH mask */
+#define CR1_NOSTRETCH_Set       ((uint16_t)0x0080)
+#define CR1_NOSTRETCH_Reset     ((uint16_t)0xFF7F)
+
+/* I2C registers Masks */
+#define CR1_CLEAR_Mask          ((uint16_t)0xFBF5)
+
+/* I2C DMAEN mask */
+#define CR2_DMAEN_Set           ((uint16_t)0x0800)
+#define CR2_DMAEN_Reset         ((uint16_t)0xF7FF)
+
+/* I2C LAST mask */
+#define CR2_LAST_Set            ((uint16_t)0x1000)
+#define CR2_LAST_Reset          ((uint16_t)0xEFFF)
+
+/* I2C FREQ mask */
+#define CR2_FREQ_Reset          ((uint16_t)0xFFC0)
+
+/* I2C ADD0 mask */
+#define OAR1_ADD0_Set           ((uint16_t)0x0001)
+#define OAR1_ADD0_Reset         ((uint16_t)0xFFFE)
+
+/* I2C ENDUAL mask */
+#define OAR2_ENDUAL_Set         ((uint16_t)0x0001)
+#define OAR2_ENDUAL_Reset       ((uint16_t)0xFFFE)
+
+/* I2C ADD2 mask */
+#define OAR2_ADD2_Reset         ((uint16_t)0xFF01)
+
+/* I2C F/S mask */
+#define CCR_FS_Set              ((uint16_t)0x8000)
+
+/* I2C CCR mask */
+#define CCR_CCR_Set             ((uint16_t)0x0FFF)
+
+/* I2C FLAG mask */
+#define FLAG_Mask               ((uint32_t)0x00FFFFFF)
+
+/* I2C Interrupt Enable mask */
+#define ITEN_Mask               ((uint32_t)0x07000000)
+
+/**
+  * @}
+  */
+
+/** @defgroup I2C_Private_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup I2C_Private_Variables
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup I2C_Private_FunctionPrototypes
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup I2C_Private_Functions
+  * @{
+  */
+
+/**
+  * @brief  Deinitializes the I2Cx peripheral registers to their default reset values.
+  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+  * @retval None
+  */
+void I2C_DeInit(I2C_TypeDef* I2Cx)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+
+  if (I2Cx == I2C1)
+  {
+    /* Enable I2C1 reset state */
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, ENABLE);
+    /* Release I2C1 from reset state */
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, DISABLE);
+  }
+  else
+  {
+    /* Enable I2C2 reset state */
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, ENABLE);
+    /* Release I2C2 from reset state */
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, DISABLE);
+  }
+}
+
+/**
+  * @brief  Initializes the I2Cx peripheral according to the specified 
+  *   parameters in the I2C_InitStruct.
+  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+  * @param  I2C_InitStruct: pointer to a I2C_InitTypeDef structure that
+  *   contains the configuration information for the specified I2C peripheral.
+  * @retval None
+  */
+void I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct)
+{
+  uint16_t tmpreg = 0, freqrange = 0;
+  uint16_t result = 0x04;
+  uint32_t pclk1 = 8000000;
+  RCC_ClocksTypeDef  rcc_clocks;
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_I2C_CLOCK_SPEED(I2C_InitStruct-&gt;I2C_ClockSpeed));
+  assert_param(IS_I2C_MODE(I2C_InitStruct-&gt;I2C_Mode));
+  assert_param(IS_I2C_DUTY_CYCLE(I2C_InitStruct-&gt;I2C_DutyCycle));
+  assert_param(IS_I2C_OWN_ADDRESS1(I2C_InitStruct-&gt;I2C_OwnAddress1));
+  assert_param(IS_I2C_ACK_STATE(I2C_InitStruct-&gt;I2C_Ack));
+  assert_param(IS_I2C_ACKNOWLEDGE_ADDRESS(I2C_InitStruct-&gt;I2C_AcknowledgedAddress));
+
+/*---------------------------- I2Cx CR2 Configuration ------------------------*/
+  /* Get the I2Cx CR2 value */
+  tmpreg = I2Cx-&gt;CR2;
+  /* Clear frequency FREQ[5:0] bits */
+  tmpreg &amp;= CR2_FREQ_Reset;
+  /* Get pclk1 frequency value */
+  RCC_GetClocksFreq(&amp;rcc_clocks);
+  pclk1 = rcc_clocks.PCLK1_Frequency;
+  /* Set frequency bits depending on pclk1 value */
+  freqrange = (uint16_t)(pclk1 / 1000000);
+  tmpreg |= freqrange;
+  /* Write to I2Cx CR2 */
+  I2Cx-&gt;CR2 = tmpreg;
+
+/*---------------------------- I2Cx CCR Configuration ------------------------*/
+  /* Disable the selected I2C peripheral to configure TRISE */
+  I2Cx-&gt;CR1 &amp;= CR1_PE_Reset;
+  /* Reset tmpreg value */
+  /* Clear F/S, DUTY and CCR[11:0] bits */
+  tmpreg = 0;
+
+  /* Configure speed in standard mode */
+  if (I2C_InitStruct-&gt;I2C_ClockSpeed &lt;= 100000)
+  {
+    /* Standard mode speed calculate */
+    result = (uint16_t)(pclk1 / (I2C_InitStruct-&gt;I2C_ClockSpeed &lt;&lt; 1));
+    /* Test if CCR value is under 0x4*/
+    if (result &lt; 0x04)
+    {
+      /* Set minimum allowed value */
+      result = 0x04;  
+    }
+    /* Set speed value for standard mode */
+    tmpreg |= result;	  
+    /* Set Maximum Rise Time for standard mode */
+    I2Cx-&gt;TRISE = freqrange + 1; 
+  }
+  /* Configure speed in fast mode */
+  else /*(I2C_InitStruct-&gt;I2C_ClockSpeed &lt;= 400000)*/
+  {
+    if (I2C_InitStruct-&gt;I2C_DutyCycle == I2C_DutyCycle_2)
+    {
+      /* Fast mode speed calculate: Tlow/Thigh = 2 */
+      result = (uint16_t)(pclk1 / (I2C_InitStruct-&gt;I2C_ClockSpeed * 3));
+    }
+    else /*I2C_InitStruct-&gt;I2C_DutyCycle == I2C_DutyCycle_16_9*/
+    {
+      /* Fast mode speed calculate: Tlow/Thigh = 16/9 */
+      result = (uint16_t)(pclk1 / (I2C_InitStruct-&gt;I2C_ClockSpeed * 25));
+      /* Set DUTY bit */
+      result |= I2C_DutyCycle_16_9;
+    }
+
+    /* Test if CCR value is under 0x1*/
+    if ((result &amp; CCR_CCR_Set) == 0)
+    {
+      /* Set minimum allowed value */
+      result |= (uint16_t)0x0001;  
+    }
+    /* Set speed value and set F/S bit for fast mode */
+    tmpreg |= (uint16_t)(result | CCR_FS_Set);
+    /* Set Maximum Rise Time for fast mode */
+    I2Cx-&gt;TRISE = (uint16_t)(((freqrange * (uint16_t)300) / (uint16_t)1000) + (uint16_t)1);  
+  }
+
+  /* Write to I2Cx CCR */
+  I2Cx-&gt;CCR = tmpreg;
+  /* Enable the selected I2C peripheral */
+  I2Cx-&gt;CR1 |= CR1_PE_Set;
+
+/*---------------------------- I2Cx CR1 Configuration ------------------------*/
+  /* Get the I2Cx CR1 value */
+  tmpreg = I2Cx-&gt;CR1;
+  /* Clear ACK, SMBTYPE and  SMBUS bits */
+  tmpreg &amp;= CR1_CLEAR_Mask;
+  /* Configure I2Cx: mode and acknowledgement */
+  /* Set SMBTYPE and SMBUS bits according to I2C_Mode value */
+  /* Set ACK bit according to I2C_Ack value */
+  tmpreg |= (uint16_t)((uint32_t)I2C_InitStruct-&gt;I2C_Mode | I2C_InitStruct-&gt;I2C_Ack);
+  /* Write to I2Cx CR1 */
+  I2Cx-&gt;CR1 = tmpreg;
+
+/*---------------------------- I2Cx OAR1 Configuration -----------------------*/
+  /* Set I2Cx Own Address1 and acknowledged address */
+  I2Cx-&gt;OAR1 = (I2C_InitStruct-&gt;I2C_AcknowledgedAddress | I2C_InitStruct-&gt;I2C_OwnAddress1);
+}
+
+/**
+  * @brief  Fills each I2C_InitStruct member with its default value.
+  * @param  I2C_InitStruct: pointer to an I2C_InitTypeDef structure which will be initialized.
+  * @retval None
+  */
+void I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct)
+{
+/*---------------- Reset I2C init structure parameters values ----------------*/
+  /* initialize the I2C_ClockSpeed member */
+  I2C_InitStruct-&gt;I2C_ClockSpeed = 5000;
+  /* Initialize the I2C_Mode member */
+  I2C_InitStruct-&gt;I2C_Mode = I2C_Mode_I2C;
+  /* Initialize the I2C_DutyCycle member */
+  I2C_InitStruct-&gt;I2C_DutyCycle = I2C_DutyCycle_2;
+  /* Initialize the I2C_OwnAddress1 member */
+  I2C_InitStruct-&gt;I2C_OwnAddress1 = 0;
+  /* Initialize the I2C_Ack member */
+  I2C_InitStruct-&gt;I2C_Ack = I2C_Ack_Disable;
+  /* Initialize the I2C_AcknowledgedAddress member */
+  I2C_InitStruct-&gt;I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
+}
+
+/**
+  * @brief  Enables or disables the specified I2C peripheral.
+  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+  * @param  NewState: new state of the I2Cx peripheral. 
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected I2C peripheral */
+    I2Cx-&gt;CR1 |= CR1_PE_Set;
+  }
+  else
+  {
+    /* Disable the selected I2C peripheral */
+    I2Cx-&gt;CR1 &amp;= CR1_PE_Reset;
+  }
+}
+
+/**
+  * @brief  Enables or disables the specified I2C DMA requests.
+  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+  * @param  NewState: new state of the I2C DMA transfer.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void I2C_DMACmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected I2C DMA requests */
+    I2Cx-&gt;CR2 |= CR2_DMAEN_Set;
+  }
+  else
+  {
+    /* Disable the selected I2C DMA requests */
+    I2Cx-&gt;CR2 &amp;= CR2_DMAEN_Reset;
+  }
+}
+
+/**
+  * @brief  Specifies that the next DMA transfer is the last one.
+  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+  * @param  NewState: new state of the I2C DMA last transfer.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void I2C_DMALastTransferCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Next DMA transfer is the last transfer */
+    I2Cx-&gt;CR2 |= CR2_LAST_Set;
+  }
+  else
+  {
+    /* Next DMA transfer is not the last transfer */
+    I2Cx-&gt;CR2 &amp;= CR2_LAST_Reset;
+  }
+}
+
+/**
+  * @brief  Generates I2Cx communication START condition.
+  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+  * @param  NewState: new state of the I2C START condition generation.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None.
+  */
+void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Generate a START condition */
+    I2Cx-&gt;CR1 |= CR1_START_Set;
+  }
+  else
+  {
+    /* Disable the START condition generation */
+    I2Cx-&gt;CR1 &amp;= CR1_START_Reset;
+  }
+}
+
+/**
+  * @brief  Generates I2Cx communication STOP condition.
+  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+  * @param  NewState: new state of the I2C STOP condition generation.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None.
+  */
+void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Generate a STOP condition */
+    I2Cx-&gt;CR1 |= CR1_STOP_Set;
+  }
+  else
+  {
+    /* Disable the STOP condition generation */
+    I2Cx-&gt;CR1 &amp;= CR1_STOP_Reset;
+  }
+}
+
+/**
+  * @brief  Enables or disables the specified I2C acknowledge feature.
+  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+  * @param  NewState: new state of the I2C Acknowledgement.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None.
+  */
+void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the acknowledgement */
+    I2Cx-&gt;CR1 |= CR1_ACK_Set;
+  }
+  else
+  {
+    /* Disable the acknowledgement */
+    I2Cx-&gt;CR1 &amp;= CR1_ACK_Reset;
+  }
+}
+
+/**
+  * @brief  Configures the specified I2C own address2.
+  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+  * @param  Address: specifies the 7bit I2C own address2.
+  * @retval None.
+  */
+void I2C_OwnAddress2Config(I2C_TypeDef* I2Cx, uint8_t Address)
+{
+  uint16_t tmpreg = 0;
+
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+
+  /* Get the old register value */
+  tmpreg = I2Cx-&gt;OAR2;
+
+  /* Reset I2Cx Own address2 bit [7:1] */
+  tmpreg &amp;= OAR2_ADD2_Reset;
+
+  /* Set I2Cx Own address2 */
+  tmpreg |= (uint16_t)((uint16_t)Address &amp; (uint16_t)0x00FE);
+
+  /* Store the new register value */
+  I2Cx-&gt;OAR2 = tmpreg;
+}
+
+/**
+  * @brief  Enables or disables the specified I2C dual addressing mode.
+  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+  * @param  NewState: new state of the I2C dual addressing mode.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void I2C_DualAddressCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable dual addressing mode */
+    I2Cx-&gt;OAR2 |= OAR2_ENDUAL_Set;
+  }
+  else
+  {
+    /* Disable dual addressing mode */
+    I2Cx-&gt;OAR2 &amp;= OAR2_ENDUAL_Reset;
+  }
+}
+
+/**
+  * @brief  Enables or disables the specified I2C general call feature.
+  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+  * @param  NewState: new state of the I2C General call.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void I2C_GeneralCallCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable generall call */
+    I2Cx-&gt;CR1 |= CR1_ENGC_Set;
+  }
+  else
+  {
+    /* Disable generall call */
+    I2Cx-&gt;CR1 &amp;= CR1_ENGC_Reset;
+  }
+}
+
+/**
+  * @brief  Enables or disables the specified I2C interrupts.
+  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+  * @param  I2C_IT: specifies the I2C interrupts sources to be enabled or disabled. 
+  *   This parameter can be any combination of the following values:
+  *     @arg I2C_IT_BUF: Buffer interrupt mask
+  *     @arg I2C_IT_EVT: Event interrupt mask
+  *     @arg I2C_IT_ERR: Error interrupt mask
+  * @param  NewState: new state of the specified I2C interrupts.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void I2C_ITConfig(I2C_TypeDef* I2Cx, uint16_t I2C_IT, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  assert_param(IS_I2C_CONFIG_IT(I2C_IT));
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected I2C interrupts */
+    I2Cx-&gt;CR2 |= I2C_IT;
+  }
+  else
+  {
+    /* Disable the selected I2C interrupts */
+    I2Cx-&gt;CR2 &amp;= (uint16_t)~I2C_IT;
+  }
+}
+
+/**
+  * @brief  Sends a data byte through the I2Cx peripheral.
+  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+  * @param  Data: Byte to be transmitted..
+  * @retval None
+  */
+void I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  /* Write in the DR register the data to be sent */
+  I2Cx-&gt;DR = Data;
+}
+
+/**
+  * @brief  Returns the most recent received data by the I2Cx peripheral.
+  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+  * @retval The value of the received data.
+  */
+uint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  /* Return the data in the DR register */
+  return (uint8_t)I2Cx-&gt;DR;
+}
+
+/**
+  * @brief  Transmits the address byte to select the slave device.
+  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+  * @param  Address: specifies the slave address which will be transmitted
+  * @param  I2C_Direction: specifies whether the I2C device will be a
+  *   Transmitter or a Receiver. This parameter can be one of the following values
+  *     @arg I2C_Direction_Transmitter: Transmitter mode
+  *     @arg I2C_Direction_Receiver: Receiver mode
+  * @retval None.
+  */
+void I2C_Send7bitAddress(I2C_TypeDef* I2Cx, uint8_t Address, uint8_t I2C_Direction)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_I2C_DIRECTION(I2C_Direction));
+  /* Test on the direction to set/reset the read/write bit */
+  if (I2C_Direction != I2C_Direction_Transmitter)
+  {
+    /* Set the address bit0 for read */
+    Address |= OAR1_ADD0_Set;
+  }
+  else
+  {
+    /* Reset the address bit0 for write */
+    Address &amp;= OAR1_ADD0_Reset;
+  }
+  /* Send the address */
+  I2Cx-&gt;DR = Address;
+}
+
+/**
+  * @brief  Reads the specified I2C register and returns its value.
+  * @param  I2C_Register: specifies the register to read.
+  *   This parameter can be one of the following values:
+  *     @arg I2C_Register_CR1:  CR1 register.
+  *     @arg I2C_Register_CR2:   CR2 register.
+  *     @arg I2C_Register_OAR1:  OAR1 register.
+  *     @arg I2C_Register_OAR2:  OAR2 register.
+  *     @arg I2C_Register_DR:    DR register.
+  *     @arg I2C_Register_SR1:   SR1 register.
+  *     @arg I2C_Register_SR2:   SR2 register.
+  *     @arg I2C_Register_CCR:   CCR register.
+  *     @arg I2C_Register_TRISE: TRISE register.
+  * @retval The value of the read register.
+  */
+uint16_t I2C_ReadRegister(I2C_TypeDef* I2Cx, uint8_t I2C_Register)
+{
+  __IO uint32_t tmp = 0;
+
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_I2C_REGISTER(I2C_Register));
+
+  tmp = (uint32_t) I2Cx;
+  tmp += I2C_Register;
+
+  /* Return the selected register value */
+  return (*(__IO uint16_t *) tmp);
+}
+
+/**
+  * @brief  Enables or disables the specified I2C software reset.
+  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+  * @param  NewState: new state of the I2C software reset.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void I2C_SoftwareResetCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Peripheral under reset */
+    I2Cx-&gt;CR1 |= CR1_SWRST_Set;
+  }
+  else
+  {
+    /* Peripheral not under reset */
+    I2Cx-&gt;CR1 &amp;= CR1_SWRST_Reset;
+  }
+}
+
+/**
+  * @brief  Drives the SMBusAlert pin high or low for the specified I2C.
+  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+  * @param  I2C_SMBusAlert: specifies SMBAlert pin level. 
+  *   This parameter can be one of the following values:
+  *     @arg I2C_SMBusAlert_Low: SMBAlert pin driven low
+  *     @arg I2C_SMBusAlert_High: SMBAlert pin driven high
+  * @retval None
+  */
+void I2C_SMBusAlertConfig(I2C_TypeDef* I2Cx, uint16_t I2C_SMBusAlert)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_I2C_SMBUS_ALERT(I2C_SMBusAlert));
+  if (I2C_SMBusAlert == I2C_SMBusAlert_Low)
+  {
+    /* Drive the SMBusAlert pin Low */
+    I2Cx-&gt;CR1 |= I2C_SMBusAlert_Low;
+  }
+  else
+  {
+    /* Drive the SMBusAlert pin High  */
+    I2Cx-&gt;CR1 &amp;= I2C_SMBusAlert_High;
+  }
+}
+
+/**
+  * @brief  Enables or disables the specified I2C PEC transfer.
+  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+  * @param  NewState: new state of the I2C PEC transmission.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void I2C_TransmitPEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected I2C PEC transmission */
+    I2Cx-&gt;CR1 |= CR1_PEC_Set;
+  }
+  else
+  {
+    /* Disable the selected I2C PEC transmission */
+    I2Cx-&gt;CR1 &amp;= CR1_PEC_Reset;
+  }
+}
+
+/**
+  * @brief  Selects the specified I2C PEC position.
+  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+  * @param  I2C_PECPosition: specifies the PEC position. 
+  *   This parameter can be one of the following values:
+  *     @arg I2C_PECPosition_Next: indicates that the next byte is PEC
+  *     @arg I2C_PECPosition_Current: indicates that current byte is PEC
+  * @retval None
+  */
+void I2C_PECPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_PECPosition)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_I2C_PEC_POSITION(I2C_PECPosition));
+  if (I2C_PECPosition == I2C_PECPosition_Next)
+  {
+    /* Next byte in shift register is PEC */
+    I2Cx-&gt;CR1 |= I2C_PECPosition_Next;
+  }
+  else
+  {
+    /* Current byte in shift register is PEC */
+    I2Cx-&gt;CR1 &amp;= I2C_PECPosition_Current;
+  }
+}
+
+/**
+  * @brief  Enables or disables the PEC value calculation of the transfered bytes.
+  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+  * @param  NewState: new state of the I2Cx PEC value calculation.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void I2C_CalculatePEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected I2C PEC calculation */
+    I2Cx-&gt;CR1 |= CR1_ENPEC_Set;
+  }
+  else
+  {
+    /* Disable the selected I2C PEC calculation */
+    I2Cx-&gt;CR1 &amp;= CR1_ENPEC_Reset;
+  }
+}
+
+/**
+  * @brief  Returns the PEC value for the specified I2C.
+  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+  * @retval The PEC value.
+  */
+uint8_t I2C_GetPEC(I2C_TypeDef* I2Cx)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  /* Return the selected I2C PEC value */
+  return ((I2Cx-&gt;SR2) &gt;&gt; 8);
+}
+
+/**
+  * @brief  Enables or disables the specified I2C ARP.
+  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+  * @param  NewState: new state of the I2Cx ARP. 
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void I2C_ARPCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected I2C ARP */
+    I2Cx-&gt;CR1 |= CR1_ENARP_Set;
+  }
+  else
+  {
+    /* Disable the selected I2C ARP */
+    I2Cx-&gt;CR1 &amp;= CR1_ENARP_Reset;
+  }
+}
+
+/**
+  * @brief  Enables or disables the specified I2C Clock stretching.
+  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+  * @param  NewState: new state of the I2Cx Clock stretching.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void I2C_StretchClockCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState == DISABLE)
+  {
+    /* Enable the selected I2C Clock stretching */
+    I2Cx-&gt;CR1 |= CR1_NOSTRETCH_Set;
+  }
+  else
+  {
+    /* Disable the selected I2C Clock stretching */
+    I2Cx-&gt;CR1 &amp;= CR1_NOSTRETCH_Reset;
+  }
+}
+
+/**
+  * @brief  Selects the specified I2C fast mode duty cycle.
+  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+  * @param  I2C_DutyCycle: specifies the fast mode duty cycle.
+  *   This parameter can be one of the following values:
+  *     @arg I2C_DutyCycle_2: I2C fast mode Tlow/Thigh = 2
+  *     @arg I2C_DutyCycle_16_9: I2C fast mode Tlow/Thigh = 16/9
+  * @retval None
+  */
+void I2C_FastModeDutyCycleConfig(I2C_TypeDef* I2Cx, uint16_t I2C_DutyCycle)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_I2C_DUTY_CYCLE(I2C_DutyCycle));
+  if (I2C_DutyCycle != I2C_DutyCycle_16_9)
+  {
+    /* I2C fast mode Tlow/Thigh=2 */
+    I2Cx-&gt;CCR &amp;= I2C_DutyCycle_2;
+  }
+  else
+  {
+    /* I2C fast mode Tlow/Thigh=16/9 */
+    I2Cx-&gt;CCR |= I2C_DutyCycle_16_9;
+  }
+}
+
+/**
+  * @brief  Returns the last I2Cx Event.
+  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+  * @retval The last event
+  */
+uint32_t I2C_GetLastEvent(I2C_TypeDef* I2Cx)
+{
+  uint32_t lastevent = 0;
+  uint32_t flag1 = 0, flag2 = 0;
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  /* Read the I2Cx status register */
+  flag1 = I2Cx-&gt;SR1;
+  flag2 = I2Cx-&gt;SR2;
+  flag2 = flag2 &lt;&lt; 16;
+  /* Get the last event value from I2C status register */
+  lastevent = (flag1 | flag2) &amp; FLAG_Mask;
+  /* Return status */
+  return lastevent;
+}
+
+/**
+  * @brief  Checks whether the last I2Cx Event is equal to the one passed
+  *   as parameter.
+  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+  * @param  I2C_EVENT: specifies the event to be checked. 
+  *   This parameter can be one of the following values:
+  *     @arg I2C_EVENT_SLAVE_ADDRESS_MATCHED   : EV1
+  *     @arg I2C_EVENT_SLAVE_BYTE_RECEIVED     : EV2
+  *     @arg I2C_EVENT_SLAVE_BYTE_TRANSMITTED  : EV3
+  *     @arg I2C_EVENT_SLAVE_ACK_FAILURE       : EV3-2
+  *     @arg I2C_EVENT_MASTER_MODE_SELECT      : EV5
+  *     @arg I2C_EVENT_MASTER_MODE_SELECTED    : EV6
+  *     @arg I2C_EVENT_MASTER_BYTE_RECEIVED    : EV7
+  *     @arg I2C_EVENT_MASTER_BYTE_TRANSMITTED : EV8
+  *     @arg I2C_EVENT_MASTER_MODE_ADDRESS10   : EV9
+  *     @arg I2C_EVENT_SLAVE_STOP_DETECTED     : EV4
+  * @retval An ErrorStatus enumuration value:
+  * - SUCCESS: Last event is equal to the I2C_EVENT
+  * - ERROR: Last event is different from the I2C_EVENT
+  */
+ErrorStatus I2C_CheckEvent(I2C_TypeDef* I2Cx, uint32_t I2C_EVENT)
+{
+  uint32_t lastevent = 0;
+  uint32_t flag1 = 0, flag2 = 0;
+  ErrorStatus status = ERROR;
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_I2C_EVENT(I2C_EVENT));
+  /* Read the I2Cx status register */
+  flag1 = I2Cx-&gt;SR1;
+  flag2 = I2Cx-&gt;SR2;
+  flag2 = flag2 &lt;&lt; 16;
+  /* Get the last event value from I2C status register */
+  lastevent = (flag1 | flag2) &amp; FLAG_Mask;
+  /* Check whether the last event is equal to I2C_EVENT */
+  if (lastevent == I2C_EVENT )
+  {
+    /* SUCCESS: last event is equal to I2C_EVENT */
+    status = SUCCESS;
+  }
+  else
+  {
+    /* ERROR: last event is different from I2C_EVENT */
+    status = ERROR;
+  }
+  /* Return status */
+  return status;
+}
+
+/**
+  * @brief  Checks whether the specified I2C flag is set or not.
+  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+  * @param  I2C_FLAG: specifies the flag to check. 
+  *   This parameter can be one of the following values:
+  *     @arg I2C_FLAG_DUALF: Dual flag (Slave mode)
+  *     @arg I2C_FLAG_SMBHOST: SMBus host header (Slave mode)
+  *     @arg I2C_FLAG_SMBDEFAULT: SMBus default header (Slave mode)
+  *     @arg I2C_FLAG_GENCALL: General call header flag (Slave mode)
+  *     @arg I2C_FLAG_TRA: Transmitter/Receiver flag
+  *     @arg I2C_FLAG_BUSY: Bus busy flag
+  *     @arg I2C_FLAG_MSL: Master/Slave flag
+  *     @arg I2C_FLAG_SMBALERT: SMBus Alert flag
+  *     @arg I2C_FLAG_TIMEOUT: Timeout or Tlow error flag
+  *     @arg I2C_FLAG_PECERR: PEC error in reception flag
+  *     @arg I2C_FLAG_OVR: Overrun/Underrun flag (Slave mode)
+  *     @arg I2C_FLAG_AF: Acknowledge failure flag
+  *     @arg I2C_FLAG_ARLO: Arbitration lost flag (Master mode)
+  *     @arg I2C_FLAG_BERR: Bus error flag
+  *     @arg I2C_FLAG_TXE: Data register empty flag (Transmitter)
+  *     @arg I2C_FLAG_RXNE: Data register not empty (Receiver) flag
+  *     @arg I2C_FLAG_STOPF: Stop detection flag (Slave mode)
+  *     @arg I2C_FLAG_ADD10: 10-bit header sent flag (Master mode)
+  *     @arg I2C_FLAG_BTF: Byte transfer finished flag
+  *     @arg I2C_FLAG_ADDR: Address sent flag (Master mode) &#147;ADSL&#148;
+  *   Address matched flag (Slave mode)&#148;ENDAD&#148;
+  *     @arg I2C_FLAG_SB: Start bit flag (Master mode)
+  * @retval The new state of I2C_FLAG (SET or RESET).
+  */
+FlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
+{
+  FlagStatus bitstatus = RESET;
+  __IO uint32_t i2creg = 0, i2cxbase = 0;
+
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_I2C_GET_FLAG(I2C_FLAG));
+
+  /* Get the I2Cx peripheral base address */
+  i2cxbase = (uint32_t)I2Cx;
+  
+  /* Read flag register index */
+  i2creg = I2C_FLAG &gt;&gt; 28;
+  
+  /* Get bit[23:0] of the flag */
+  I2C_FLAG &amp;= FLAG_Mask;
+  
+  if(i2creg != 0)
+  {
+    /* Get the I2Cx SR1 register address */
+    i2cxbase += 0x14;
+  }
+  else
+  {
+    /* Flag in I2Cx SR2 Register */
+    I2C_FLAG = (uint32_t)(I2C_FLAG &gt;&gt; 16);
+    /* Get the I2Cx SR2 register address */
+    i2cxbase += 0x18;
+  }
+  
+  if(((*(__IO uint32_t *)i2cxbase) &amp; I2C_FLAG) != (uint32_t)RESET)
+  {
+    /* I2C_FLAG is set */
+    bitstatus = SET;
+  }
+  else
+  {
+    /* I2C_FLAG is reset */
+    bitstatus = RESET;
+  }
+  
+  /* Return the I2C_FLAG status */
+  return  bitstatus;
+}
+
+/**
+  * @brief  Clears the I2Cx's pending flags.
+  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+  * @param  I2C_FLAG: specifies the flag to clear. 
+  *   This parameter can be any combination of the following values:
+  *     @arg I2C_FLAG_SMBALERT: SMBus Alert flag
+  *     @arg I2C_FLAG_TIMEOUT: Timeout or Tlow error flag
+  *     @arg I2C_FLAG_PECERR: PEC error in reception flag
+  *     @arg I2C_FLAG_OVR: Overrun/Underrun flag (Slave mode)
+  *     @arg I2C_FLAG_AF: Acknowledge failure flag
+  *     @arg I2C_FLAG_ARLO: Arbitration lost flag (Master mode)
+  *     @arg I2C_FLAG_BERR: Bus error flag
+  *   
+  * @note
+  *   - STOPF (STOP detection) is cleared by software sequence: a read operation 
+  *     to I2C_SR1 register (I2C_GetFlagStatus()) followed by a write operation 
+  *     to I2C_CR1 register (I2C_Cmd() to re-enable the I2C peripheral).
+  *   - ADD10 (10-bit header sent) is cleared by software sequence: a read 
+  *     operation to I2C_SR1 (I2C_GetFlagStatus()) followed by writing the 
+  *     second byte of the address in DR register.
+  *   - BTF (Byte Transfer Finished) is cleared by software sequence: a read 
+  *     operation to I2C_SR1 register (I2C_GetFlagStatus()) followed by a 
+  *     read/write to I2C_DR register (I2C_SendData()).
+  *   - ADDR (Address sent) is cleared by software sequence: a read operation to 
+  *     I2C_SR1 register (I2C_GetFlagStatus()) followed by a read operation to 
+  *     I2C_SR2 register ((void)(I2Cx-&gt;SR2)).
+  *   - SB (Start Bit) is cleared software sequence: a read operation to I2C_SR1
+  *     register (I2C_GetFlagStatus()) followed by a write operation to I2C_DR
+  *     register  (I2C_SendData()).
+  * @retval None
+  */
+void I2C_ClearFlag(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
+{
+  uint32_t flagpos = 0;
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_I2C_CLEAR_FLAG(I2C_FLAG));
+  /* Get the I2C flag position */
+  flagpos = I2C_FLAG &amp; FLAG_Mask;
+  /* Clear the selected I2C flag */
+  I2Cx-&gt;SR1 = (uint16_t)~flagpos;
+}
+
+/**
+  * @brief  Checks whether the specified I2C interrupt has occurred or not.
+  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+  * @param  I2C_IT: specifies the interrupt source to check. 
+  *   This parameter can be one of the following values:
+  *     @arg I2C_IT_SMBALERT: SMBus Alert flag
+  *     @arg I2C_IT_TIMEOUT: Timeout or Tlow error flag
+  *     @arg I2C_IT_PECERR: PEC error in reception flag
+  *     @arg I2C_IT_OVR: Overrun/Underrun flag (Slave mode)
+  *     @arg I2C_IT_AF: Acknowledge failure flag
+  *     @arg I2C_IT_ARLO: Arbitration lost flag (Master mode)
+  *     @arg I2C_IT_BERR: Bus error flag
+  *     @arg I2C_IT_TXE: Data register empty flag (Transmitter)
+  *     @arg I2C_IT_RXNE: Data register not empty (Receiver) flag
+  *     @arg I2C_IT_STOPF: Stop detection flag (Slave mode)
+  *     @arg I2C_IT_ADD10: 10-bit header sent flag (Master mode)
+  *     @arg I2C_IT_BTF: Byte transfer finished flag
+  *     @arg I2C_IT_ADDR: Address sent flag (Master mode) &#147;ADSL&#148;
+  *                       Address matched flag (Slave mode)&#148;ENDAD&#148;
+  *     @arg I2C_IT_SB: Start bit flag (Master mode)
+  * @retval The new state of I2C_IT (SET or RESET).
+  */
+ITStatus I2C_GetITStatus(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
+{
+  ITStatus bitstatus = RESET;
+  uint32_t enablestatus = 0;
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_I2C_GET_IT(I2C_IT));
+  /* Check if the interrupt source is enabled or not */
+  enablestatus = (uint32_t)(((I2C_IT &amp; ITEN_Mask) &gt;&gt; 16) &amp; (I2Cx-&gt;CR2)) ;  
+  /* Get bit[23:0] of the flag */
+  I2C_IT &amp;= FLAG_Mask;
+  /* Check the status of the specified I2C flag */
+  if (((I2Cx-&gt;SR1 &amp; I2C_IT) != (uint32_t)RESET) &amp;&amp; enablestatus)
+  {
+    /* I2C_IT is set */
+    bitstatus = SET;
+  }
+  else
+  {
+    /* I2C_IT is reset */
+    bitstatus = RESET;
+  }
+  /* Return the I2C_IT status */
+  return  bitstatus;
+}
+
+/**
+  * @brief  Clears the I2Cx&#146;s interrupt pending bits.
+  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+  * @param  I2C_IT: specifies the interrupt pending bit to clear. 
+  *   This parameter can be any combination of the following values:
+  *     @arg I2C_IT_SMBALERT: SMBus Alert interrupt
+  *     @arg I2C_IT_TIMEOUT: Timeout or Tlow error interrupt
+  *     @arg I2C_IT_PECERR: PEC error in reception  interrupt
+  *     @arg I2C_IT_OVR: Overrun/Underrun interrupt (Slave mode)
+  *     @arg I2C_IT_AF: Acknowledge failure interrupt
+  *     @arg I2C_IT_ARLO: Arbitration lost interrupt (Master mode)
+  *     @arg I2C_IT_BERR: Bus error interrupt
+  *   
+  * @note
+  *   - STOPF (STOP detection) is cleared by software sequence: a read operation 
+  *     to I2C_SR1 register (I2C_GetITStatus()) followed by a write operation to 
+  *     I2C_CR1 register (I2C_Cmd() to re-enable the I2C peripheral).
+  *   - ADD10 (10-bit header sent) is cleared by software sequence: a read 
+  *     operation to I2C_SR1 (I2C_GetITStatus()) followed by writing the second 
+  *     byte of the address in I2C_DR register.
+  *   - BTF (Byte Transfer Finished) is cleared by software sequence: a read 
+  *     operation to I2C_SR1 register (I2C_GetITStatus()) followed by a 
+  *     read/write to I2C_DR register (I2C_SendData()).
+  *   - ADDR (Address sent) is cleared by software sequence: a read operation to 
+  *     I2C_SR1 register (I2C_GetITStatus()) followed by a read operation to 
+  *     I2C_SR2 register ((void)(I2Cx-&gt;SR2)).
+  *   - SB (Start Bit) is cleared by software sequence: a read operation to 
+  *     I2C_SR1 register (I2C_GetITStatus()) followed by a write operation to 
+  *     I2C_DR register (I2C_SendData()).
+  * @retval None
+  */
+void I2C_ClearITPendingBit(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
+{
+  uint32_t flagpos = 0;
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_I2C_CLEAR_IT(I2C_IT));
+  /* Get the I2C flag position */
+  flagpos = I2C_IT &amp; FLAG_Mask;
+  /* Clear the selected I2C flag */
+  I2Cx-&gt;SR1 = (uint16_t)~flagpos;
+}
+
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/******************* (C) COPYRIGHT 2009 STMicroelectronics *****END OF FILE****/

Added: trunk/src/platform/stm32/FWLib/library/src/stm32f10x_i2c.o
===================================================================
--- trunk/src/platform/stm32/FWLib/library/src/stm32f10x_i2c.o	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/src/stm32f10x_i2c.o	2009-07-08 23:39:34 UTC (rev 354)
@@ -0,0 +1,11 @@
+ELF
+
+CC&#155;&#178;+&#128;3&#137;&#178;&#137;C&#155;&#178;+&#129;&#176;p&#189;@B
+M	

+
+
+
+h
+j
+j
+j
\ No newline at end of file

Modified: trunk/src/platform/stm32/FWLib/library/src/stm32f10x_iwdg.c
===================================================================
--- trunk/src/platform/stm32/FWLib/library/src/stm32f10x_iwdg.c	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/src/stm32f10x_iwdg.c	2009-07-08 23:39:34 UTC (rev 354)
@@ -1,148 +1,189 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_iwdg.c
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file provides all the IWDG firmware functions.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
-
-/* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_iwdg.h&quot;
-
-/* Private typedef -----------------------------------------------------------*/
-/* Private define ------------------------------------------------------------*/
-/* ---------------------- IWDG registers bit mask ------------------------ */
-/* KR register bit mask */
-#define KR_KEY_Reload    ((u16)0xAAAA)
-#define KR_KEY_Enable    ((u16)0xCCCC)
-
-/* Private macro -------------------------------------------------------------*/
-/* Private variables ---------------------------------------------------------*/
-/* Private function prototypes -----------------------------------------------*/
-/* Private functions ---------------------------------------------------------*/
-
-/*******************************************************************************
-* Function Name  : IWDG_WriteAccessCmd
-* Description    : Enables or disables write access to IWDG_PR and IWDG_RLR
-*                  registers.
-* Input          : - IWDG_WriteAccess: new state of write access to IWDG_PR and
-*                    IWDG_RLR registers.
-*                    This parameter can be one of the following values:
-*                       - IWDG_WriteAccess_Enable: Enable write access to 
-*                         IWDG_PR and IWDG_RLR registers
-*                       - IWDG_WriteAccess_Disable: Disable write access to
-*                         IWDG_PR and IWDG_RLR registers
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void IWDG_WriteAccessCmd(u16 IWDG_WriteAccess)
-{
-  /* Check the parameters */
-  assert_param(IS_IWDG_WRITE_ACCESS(IWDG_WriteAccess));
-
-  IWDG-&gt;KR = IWDG_WriteAccess;
-}
-
-/*******************************************************************************
-* Function Name  : IWDG_SetPrescaler
-* Description    : Sets IWDG Prescaler value.
-* Input          : - IWDG_Prescaler: specifies the IWDG Prescaler value.
-*                    This parameter can be one of the following values:
-*                       - IWDG_Prescaler_4: IWDG prescaler set to 4
-*                       - IWDG_Prescaler_8: IWDG prescaler set to 8
-*                       - IWDG_Prescaler_16: IWDG prescaler set to 16
-*                       - IWDG_Prescaler_32: IWDG prescaler set to 32
-*                       - IWDG_Prescaler_64: IWDG prescaler set to 64
-*                       - IWDG_Prescaler_128: IWDG prescaler set to 128
-*                       - IWDG_Prescaler_256: IWDG prescaler set to 256
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void IWDG_SetPrescaler(u8 IWDG_Prescaler)
-{
-  /* Check the parameters */
-  assert_param(IS_IWDG_PRESCALER(IWDG_Prescaler));
-
-  IWDG-&gt;PR = IWDG_Prescaler;
-}
-
-/*******************************************************************************
-* Function Name  : IWDG_SetReload
-* Description    : Sets IWDG Reload value.
-* Input          : - Reload: specifies the IWDG Reload value.
-*                    This parameter must be a number between 0 and 0x0FFF.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void IWDG_SetReload(u16 Reload)
-{
-  /* Check the parameters */
-  assert_param(IS_IWDG_RELOAD(Reload));
-
-  IWDG-&gt;RLR = Reload;
-}
-
-/*******************************************************************************
-* Function Name  : IWDG_ReloadCounter
-* Description    : Reloads IWDG counter with value defined in the reload register
-*                  (write access to IWDG_PR and IWDG_RLR registers disabled).
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void IWDG_ReloadCounter(void)
-{
-  IWDG-&gt;KR = KR_KEY_Reload;
-}
-
-/*******************************************************************************
-* Function Name  : IWDG_Enable
-* Description    : Enables IWDG (write access to IWDG_PR and IWDG_RLR registers
-*                  disabled).
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void IWDG_Enable(void)
-{
-  IWDG-&gt;KR = KR_KEY_Enable;
-}
-
-/*******************************************************************************
-* Function Name  : IWDG_GetFlagStatus
-* Description    : Checks whether the specified IWDG flag is set or not.
-* Input          : - IWDG_FLAG: specifies the flag to check.
-*                    This parameter can be one of the following values:
-*                       - IWDG_FLAG_PVU: Prescaler Value Update on going
-*                       - IWDG_FLAG_RVU: Reload Value Update on going
-* Output         : None
-* Return         : The new state of IWDG_FLAG (SET or RESET).
-*******************************************************************************/
-FlagStatus IWDG_GetFlagStatus(u16 IWDG_FLAG)
-{
-  FlagStatus bitstatus = RESET;
-
-  /* Check the parameters */
-  assert_param(IS_IWDG_FLAG(IWDG_FLAG));
-
-  if ((IWDG-&gt;SR &amp; IWDG_FLAG) != (u32)RESET)
-  {
-    bitstatus = SET;
-  }
-  else
-  {
-    bitstatus = RESET;
-  }
-
-  /* Return the flag status */
-  return bitstatus;
-}
-
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
+/**
+  ******************************************************************************
+  * @file    stm32f10x_iwdg.c
+  * @author  MCD Application Team
+  * @version V3.1.0
+  * @date    06/19/2009
+  * @brief   This file provides all the IWDG firmware functions.
+  ******************************************************************************
+  * @copy
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * &lt;h2&gt;&lt;center&gt;&copy; COPYRIGHT 2009 STMicroelectronics&lt;/center&gt;&lt;/h2&gt;
+  */ 
+
+/* Includes ------------------------------------------------------------------*/
+#include &quot;stm32f10x_iwdg.h&quot;
+
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup IWDG 
+  * @brief IWDG driver modules
+  * @{
+  */ 
+
+/** @defgroup IWDG_Private_TypesDefinitions
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup IWDG_Private_Defines
+  * @{
+  */ 
+
+/* ---------------------- IWDG registers bit mask ----------------------------*/
+
+/* KR register bit mask */
+#define KR_KEY_Reload    ((uint16_t)0xAAAA)
+#define KR_KEY_Enable    ((uint16_t)0xCCCC)
+
+/**
+  * @}
+  */ 
+
+/** @defgroup IWDG_Private_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup IWDG_Private_Variables
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup IWDG_Private_FunctionPrototypes
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup IWDG_Private_Functions
+  * @{
+  */
+
+/**
+  * @brief  Enables or disables write access to IWDG_PR and IWDG_RLR registers.
+  * @param  IWDG_WriteAccess: new state of write access to IWDG_PR and IWDG_RLR registers.
+  *   This parameter can be one of the following values:
+  *     @arg IWDG_WriteAccess_Enable: Enable write access to IWDG_PR and IWDG_RLR registers
+  *     @arg IWDG_WriteAccess_Disable: Disable write access to IWDG_PR and IWDG_RLR registers
+  * @retval None
+  */
+void IWDG_WriteAccessCmd(uint16_t IWDG_WriteAccess)
+{
+  /* Check the parameters */
+  assert_param(IS_IWDG_WRITE_ACCESS(IWDG_WriteAccess));
+  IWDG-&gt;KR = IWDG_WriteAccess;
+}
+
+/**
+  * @brief  Sets IWDG Prescaler value.
+  * @param  IWDG_Prescaler: specifies the IWDG Prescaler value.
+  *   This parameter can be one of the following values:
+  *     @arg IWDG_Prescaler_4: IWDG prescaler set to 4
+  *     @arg IWDG_Prescaler_8: IWDG prescaler set to 8
+  *     @arg IWDG_Prescaler_16: IWDG prescaler set to 16
+  *     @arg IWDG_Prescaler_32: IWDG prescaler set to 32
+  *     @arg IWDG_Prescaler_64: IWDG prescaler set to 64
+  *     @arg IWDG_Prescaler_128: IWDG prescaler set to 128
+  *     @arg IWDG_Prescaler_256: IWDG prescaler set to 256
+  * @retval None
+  */
+void IWDG_SetPrescaler(uint8_t IWDG_Prescaler)
+{
+  /* Check the parameters */
+  assert_param(IS_IWDG_PRESCALER(IWDG_Prescaler));
+  IWDG-&gt;PR = IWDG_Prescaler;
+}
+
+/**
+  * @brief  Sets IWDG Reload value.
+  * @param  Reload: specifies the IWDG Reload value.
+  *   This parameter must be a number between 0 and 0x0FFF.
+  * @retval None
+  */
+void IWDG_SetReload(uint16_t Reload)
+{
+  /* Check the parameters */
+  assert_param(IS_IWDG_RELOAD(Reload));
+  IWDG-&gt;RLR = Reload;
+}
+
+/**
+  * @brief  Reloads IWDG counter with value defined in the reload register
+  *   (write access to IWDG_PR and IWDG_RLR registers disabled).
+  * @param  None
+  * @retval None
+  */
+void IWDG_ReloadCounter(void)
+{
+  IWDG-&gt;KR = KR_KEY_Reload;
+}
+
+/**
+  * @brief  Enables IWDG (write access to IWDG_PR and IWDG_RLR registers disabled).
+  * @param  None
+  * @retval None
+  */
+void IWDG_Enable(void)
+{
+  IWDG-&gt;KR = KR_KEY_Enable;
+}
+
+/**
+  * @brief  Checks whether the specified IWDG flag is set or not.
+  * @param  IWDG_FLAG: specifies the flag to check.
+  *   This parameter can be one of the following values:
+  *     @arg IWDG_FLAG_PVU: Prescaler Value Update on going
+  *     @arg IWDG_FLAG_RVU: Reload Value Update on going
+  * @retval The new state of IWDG_FLAG (SET or RESET).
+  */
+FlagStatus IWDG_GetFlagStatus(uint16_t IWDG_FLAG)
+{
+  FlagStatus bitstatus = RESET;
+  /* Check the parameters */
+  assert_param(IS_IWDG_FLAG(IWDG_FLAG));
+  if ((IWDG-&gt;SR &amp; IWDG_FLAG) != (uint32_t)RESET)
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  /* Return the flag status */
+  return bitstatus;
+}
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2009 STMicroelectronics *****END OF FILE****/

Added: trunk/src/platform/stm32/FWLib/library/src/stm32f10x_iwdg.o
===================================================================
--- trunk/src/platform/stm32/FWLib/library/src/stm32f10x_iwdg.o	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/src/stm32f10x_iwdg.o	2009-07-08 23:39:34 UTC (rev 354)
@@ -0,0 +1,3 @@
+ELF
+M	
+
\ No newline at end of file

Deleted: trunk/src/platform/stm32/FWLib/library/src/stm32f10x_lib.c
===================================================================
--- trunk/src/platform/stm32/FWLib/library/src/stm32f10x_lib.c	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/src/stm32f10x_lib.c	2009-07-08 23:39:34 UTC (rev 354)
@@ -1,303 +0,0 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_lib.c
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file provides all peripherals pointers initialization.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
-
-#define EXT
-
-/* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_lib.h&quot;
-
-/* Private typedef -----------------------------------------------------------*/
-/* Private define ------------------------------------------------------------*/
-/* Private macro -------------------------------------------------------------*/
-/* Private variables ---------------------------------------------------------*/
-/* Private function prototypes -----------------------------------------------*/
-/* Private functions ---------------------------------------------------------*/
-
-#ifdef DEBUG
-/*******************************************************************************
-* Function Name  : debug
-* Description    : This function initialize peripherals pointers.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void debug(void)
-{
-
-/************************************* ADC ************************************/
-#ifdef _ADC1
-  ADC1 = (ADC_TypeDef *)  ADC1_BASE;
-#endif /*_ADC1 */
-
-#ifdef _ADC2
-  ADC2 = (ADC_TypeDef *)  ADC2_BASE;
-#endif /*_ADC2 */
-
-#ifdef _ADC3
-  ADC3 = (ADC_TypeDef *)  ADC3_BASE;
-#endif /*_ADC3 */
-
-/************************************* BKP ************************************/
-#ifdef _BKP
-  BKP = (BKP_TypeDef *)  BKP_BASE;
-#endif /*_BKP */
-
-/************************************* CAN ************************************/
-#ifdef _CAN
-  CAN = (CAN_TypeDef *)  CAN_BASE;
-#endif /*_CAN */
-
-/************************************* CRC ************************************/
-#ifdef _CRC
-  CRC = (CRC_TypeDef *)  CRC_BASE;
-#endif /*_CRC */
-
-/************************************* DAC ************************************/
-#ifdef _DAC
-  DAC = (DAC_TypeDef *)  DAC_BASE;
-#endif /*_DAC */
-
-/************************************* DBGMCU**********************************/
-#ifdef _DBGMCU
-  DBGMCU = (DBGMCU_TypeDef *)  DBGMCU_BASE;
-#endif /*_DBGMCU */
-
-/************************************* DMA ************************************/
-#ifdef _DMA
-  DMA1 = (DMA_TypeDef *)  DMA1_BASE;
-  DMA2 = (DMA_TypeDef *)  DMA2_BASE;
-#endif /*_DMA */
-
-#ifdef _DMA1_Channel1
-  DMA1_Channel1 = (DMA_Channel_TypeDef *)  DMA1_Channel1_BASE;
-#endif /*_DMA1_Channel1 */
-
-#ifdef _DMA1_Channel2
-  DMA1_Channel2 = (DMA_Channel_TypeDef *)  DMA1_Channel2_BASE;
-#endif /*_DMA1_Channel2 */
-
-#ifdef _DMA1_Channel3
-  DMA1_Channel3 = (DMA_Channel_TypeDef *)  DMA1_Channel3_BASE;
-#endif /*_DMA1_Channel3 */
-
-#ifdef _DMA1_Channel4
-  DMA1_Channel4 = (DMA_Channel_TypeDef *)  DMA1_Channel4_BASE;
-#endif /*_DMA1_Channel4 */
-
-#ifdef _DMA1_Channel5
-  DMA1_Channel5 = (DMA_Channel_TypeDef *)  DMA1_Channel5_BASE;
-#endif /*_DMA1_Channel5 */
-
-#ifdef _DMA1_Channel6
-  DMA1_Channel6 = (DMA_Channel_TypeDef *)  DMA1_Channel6_BASE;
-#endif /*_DMA1_Channel6 */
-
-#ifdef _DMA1_Channel7
-  DMA1_Channel7 = (DMA_Channel_TypeDef *)  DMA1_Channel7_BASE;
-#endif /*_DMA1_Channel7 */
-
-#ifdef _DMA2_Channel1
-  DMA2_Channel1 = (DMA_Channel_TypeDef *)  DMA2_Channel1_BASE;
-#endif /*_DMA2_Channel1 */
-
-#ifdef _DMA2_Channel2
-  DMA2_Channel2 = (DMA_Channel_TypeDef *)  DMA2_Channel2_BASE;
-#endif /*_DMA2_Channel2 */
-
-#ifdef _DMA2_Channel3
-  DMA2_Channel3 = (DMA_Channel_TypeDef *)  DMA2_Channel3_BASE;
-#endif /*_DMA2_Channel3 */
-
-#ifdef _DMA2_Channel4
-  DMA2_Channel4 = (DMA_Channel_TypeDef *)  DMA2_Channel4_BASE;
-#endif /*_DMA2_Channel4 */
-
-#ifdef _DMA2_Channel5
-  DMA2_Channel5 = (DMA_Channel_TypeDef *)  DMA2_Channel5_BASE;
-#endif /*_DMA2_Channel5 */
-
-/************************************* EXTI ***********************************/
-#ifdef _EXTI
-  EXTI = (EXTI_TypeDef *)  EXTI_BASE;
-#endif /*_EXTI */
-
-/************************************* FLASH and Option Bytes *****************/
-#ifdef _FLASH
-  FLASH = (FLASH_TypeDef *)  FLASH_R_BASE;
-  OB = (OB_TypeDef *)        OB_BASE;
-#endif /*_FLASH */
-
-/************************************* FSMC ***********************************/
-#ifdef _FSMC
-  FSMC_Bank1 = (FSMC_Bank1_TypeDef *)    FSMC_Bank1_R_BASE;
-  FSMC_Bank1E = (FSMC_Bank1E_TypeDef *)  FSMC_Bank1E_R_BASE;  
-  FSMC_Bank2 = (FSMC_Bank2_TypeDef *)    FSMC_Bank2_R_BASE; 
-  FSMC_Bank3 = (FSMC_Bank3_TypeDef *)    FSMC_Bank3_R_BASE;
-  FSMC_Bank4 = (FSMC_Bank4_TypeDef *)    FSMC_Bank4_R_BASE;
-#endif /*_FSMC */
-
-/************************************* GPIO ***********************************/
-#ifdef _GPIOA
-  GPIOA = (GPIO_TypeDef *)  GPIOA_BASE;
-#endif /*_GPIOA */
-
-#ifdef _GPIOB
-  GPIOB = (GPIO_TypeDef *)  GPIOB_BASE;
-#endif /*_GPIOB */
-
-#ifdef _GPIOC
-  GPIOC = (GPIO_TypeDef *)  GPIOC_BASE;
-#endif /*_GPIOC */
-
-#ifdef _GPIOD
-  GPIOD = (GPIO_TypeDef *)  GPIOD_BASE;
-#endif /*_GPIOD */
-
-#ifdef _GPIOE
-  GPIOE = (GPIO_TypeDef *)  GPIOE_BASE;
-#endif /*_GPIOE */
-
-#ifdef _GPIOF
-  GPIOF = (GPIO_TypeDef *)  GPIOF_BASE;
-#endif /*_GPIOF */
-
-#ifdef _GPIOG
-  GPIOG = (GPIO_TypeDef *)  GPIOG_BASE;
-#endif /*_GPIOG */
-
-#ifdef _AFIO
-  AFIO = (AFIO_TypeDef *)  AFIO_BASE;
-#endif /*_AFIO */
-
-/************************************* I2C ************************************/
-#ifdef _I2C1
-  I2C1 = (I2C_TypeDef *)  I2C1_BASE;
-#endif /*_I2C1 */
-
-#ifdef _I2C2
-  I2C2 = (I2C_TypeDef *)  I2C2_BASE;
-#endif /*_I2C2 */
-
-/************************************* IWDG ***********************************/
-#ifdef _IWDG
-  IWDG = (IWDG_TypeDef *) IWDG_BASE;
-#endif /*_IWDG */
-
-/************************************* NVIC ***********************************/
-#ifdef _NVIC
-  NVIC = (NVIC_TypeDef *)  NVIC_BASE;
-  SCB = (SCB_TypeDef *)  SCB_BASE;
-#endif /*_NVIC */
-
-/************************************* PWR ************************************/
-#ifdef _PWR
-  PWR = (PWR_TypeDef *)  PWR_BASE;
-#endif /*_PWR */
-
-/************************************* RCC ************************************/
-#ifdef _RCC
-  RCC = (RCC_TypeDef *)  RCC_BASE;
-#endif /*_RCC */
-
-/************************************* RTC ************************************/
-#ifdef _RTC
-  RTC = (RTC_TypeDef *)  RTC_BASE;
-#endif /*_RTC */
-
-/************************************* SDIO ***********************************/
-#ifdef _SDIO
-  SDIO = (SDIO_TypeDef *)  SDIO_BASE;
-#endif /*_SDIO */
-
-/************************************* SPI ************************************/
-#ifdef _SPI1
-  SPI1 = (SPI_TypeDef *)  SPI1_BASE;
-#endif /*_SPI1 */
-
-#ifdef _SPI2
-  SPI2 = (SPI_TypeDef *)  SPI2_BASE;
-#endif /*_SPI2 */
-
-#ifdef _SPI3
-  SPI3 = (SPI_TypeDef *)  SPI3_BASE;
-#endif /*_SPI3 */
-
-/************************************* SysTick ********************************/
-#ifdef _SysTick
-  SysTick = (SysTick_TypeDef *)  SysTick_BASE;
-#endif /*_SysTick */
-
-/************************************* TIM ************************************/
-#ifdef _TIM1
-  TIM1 = (TIM_TypeDef *)  TIM1_BASE;
-#endif /*_TIM1 */
-
-#ifdef _TIM2
-  TIM2 = (TIM_TypeDef *)  TIM2_BASE;
-#endif /*_TIM2 */
-
-#ifdef _TIM3
-  TIM3 = (TIM_TypeDef *)  TIM3_BASE;
-#endif /*_TIM3 */
-
-#ifdef _TIM4
-  TIM4 = (TIM_TypeDef *)  TIM4_BASE;
-#endif /*_TIM4 */
-
-#ifdef _TIM5
-  TIM5 = (TIM_TypeDef *)  TIM5_BASE;
-#endif /*_TIM5 */
-
-#ifdef _TIM6
-  TIM6 = (TIM_TypeDef *)  TIM6_BASE;
-#endif /*_TIM6 */
-
-#ifdef _TIM7
-  TIM7 = (TIM_TypeDef *)  TIM7_BASE;
-#endif /*_TIM7 */
-
-#ifdef _TIM8
-  TIM8 = (TIM_TypeDef *)  TIM8_BASE;
-#endif /*_TIM8 */
-
-/************************************* USART **********************************/
-#ifdef _USART1
-  USART1 = (USART_TypeDef *) USART1_BASE;
-#endif /*_USART1 */
-
-#ifdef _USART2
-  USART2 = (USART_TypeDef *) USART2_BASE;
-#endif /*_USART2 */
-
-#ifdef _USART3
-  USART3 = (USART_TypeDef *) USART3_BASE;
-#endif /*_USART3 */
-
-#ifdef _UART4
-  UART4 = (USART_TypeDef *) UART4_BASE;
-#endif /*_UART4 */
-
-#ifdef _UART5
-  UART5 = (USART_TypeDef *) UART5_BASE;
-#endif /*_UART5 */
-
-/************************************* WWDG ***********************************/
-#ifdef _WWDG
-  WWDG = (WWDG_TypeDef *)  WWDG_BASE;
-#endif /*_WWDG */
-}
-#endif  /* DEBUG*/
-
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/

Deleted: trunk/src/platform/stm32/FWLib/library/src/stm32f10x_nvic.c
===================================================================
--- trunk/src/platform/stm32/FWLib/library/src/stm32f10x_nvic.c	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/src/stm32f10x_nvic.c	2009-07-08 23:39:34 UTC (rev 354)
@@ -1,751 +0,0 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_nvic.c
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file provides all the NVIC firmware functions.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
-
-/* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_nvic.h&quot;
-
-/* Private typedef -----------------------------------------------------------*/
-/* Private define ------------------------------------------------------------*/
-#define AIRCR_VECTKEY_MASK    ((u32)0x05FA0000)
-
-/* Private macro -------------------------------------------------------------*/
-/* Private variables ---------------------------------------------------------*/
-/* Private function prototypes -----------------------------------------------*/
-/* Private functions ---------------------------------------------------------*/
-
-/*******************************************************************************
-* Function Name  : NVIC_DeInit
-* Description    : Deinitializes the NVIC peripheral registers to their default
-*                  reset values.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void NVIC_DeInit(void)
-{
-  u32 index = 0;
-  
-  NVIC-&gt;ICER[0] = 0xFFFFFFFF;
-  NVIC-&gt;ICER[1] = 0x0FFFFFFF;
-  NVIC-&gt;ICPR[0] = 0xFFFFFFFF;
-  NVIC-&gt;ICPR[1] = 0x0FFFFFFF;
-  
-  for(index = 0; index &lt; 0x0F; index++)
-  {
-     NVIC-&gt;IPR[index] = 0x00000000;
-  } 
-}
-
-/*******************************************************************************
-* Function Name  : NVIC_SCBDeInit
-* Description    : Deinitializes the SCB peripheral registers to their default 
-*                  reset values.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void NVIC_SCBDeInit(void)
-{
-  u32 index = 0x00;
-  
-  SCB-&gt;ICSR = 0x0A000000;
-  SCB-&gt;VTOR = 0x00000000;
-  SCB-&gt;AIRCR = AIRCR_VECTKEY_MASK;
-  SCB-&gt;SCR = 0x00000000;
-  SCB-&gt;CCR = 0x00000000;
-  for(index = 0; index &lt; 0x03; index++)
-  {
-     SCB-&gt;SHPR[index] = 0;
-  }
-  SCB-&gt;SHCSR = 0x00000000;
-  SCB-&gt;CFSR = 0xFFFFFFFF;
-  SCB-&gt;HFSR = 0xFFFFFFFF;
-  SCB-&gt;DFSR = 0xFFFFFFFF;
-}
-
-/*******************************************************************************
-* Function Name  : NVIC_PriorityGroupConfig
-* Description    : Configures the priority grouping: pre-emption priority
-*                  and subpriority.
-* Input          : - NVIC_PriorityGroup: specifies the priority grouping bits
-*                    length. This parameter can be one of the following values:
-*                       - NVIC_PriorityGroup_0: 0 bits for pre-emption priority
-*                         4 bits for subpriority
-*                       - NVIC_PriorityGroup_1: 1 bits for pre-emption priority
-*                         3 bits for subpriority
-*                       - NVIC_PriorityGroup_2: 2 bits for pre-emption priority
-*                         2 bits for subpriority
-*                       - NVIC_PriorityGroup_3: 3 bits for pre-emption priority
-*                         1 bits for subpriority
-*                       - NVIC_PriorityGroup_4: 4 bits for pre-emption priority
-*                         0 bits for subpriority
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void NVIC_PriorityGroupConfig(u32 NVIC_PriorityGroup)
-{
-  /* Check the parameters */
-  assert_param(IS_NVIC_PRIORITY_GROUP(NVIC_PriorityGroup));
-  
-  /* Set the PRIGROUP[10:8] bits according to NVIC_PriorityGroup value */
-  SCB-&gt;AIRCR = AIRCR_VECTKEY_MASK | NVIC_PriorityGroup;
-}
-
-/*******************************************************************************
-* Function Name  : NVIC_Init
-* Description    : Initializes the NVIC peripheral according to the specified
-*                  parameters in the NVIC_InitStruct.
-* Input          : - NVIC_InitStruct: pointer to a NVIC_InitTypeDef structure
-*                    that contains the configuration information for the
-*                    specified NVIC peripheral.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct)
-{
-  u32 tmppriority = 0x00, tmpreg = 0x00, tmpmask = 0x00;
-  u32 tmppre = 0, tmpsub = 0x0F;
-
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NVIC_InitStruct-&gt;NVIC_IRQChannelCmd));
-  assert_param(IS_NVIC_IRQ_CHANNEL(NVIC_InitStruct-&gt;NVIC_IRQChannel));
-  assert_param(IS_NVIC_PREEMPTION_PRIORITY(NVIC_InitStruct-&gt;NVIC_IRQChannelPreemptionPriority));  
-  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct-&gt;NVIC_IRQChannelSubPriority));
-    
-  if (NVIC_InitStruct-&gt;NVIC_IRQChannelCmd != DISABLE)
-  {
-    /* Compute the Corresponding IRQ Priority --------------------------------*/    
-    tmppriority = (0x700 - (SCB-&gt;AIRCR &amp; (u32)0x700))&gt;&gt; 0x08;
-    tmppre = (0x4 - tmppriority);
-    tmpsub = tmpsub &gt;&gt; tmppriority;
-    
-    tmppriority = (u32)NVIC_InitStruct-&gt;NVIC_IRQChannelPreemptionPriority &lt;&lt; tmppre;
-    tmppriority |=  NVIC_InitStruct-&gt;NVIC_IRQChannelSubPriority &amp; tmpsub;
-
-    tmppriority = tmppriority &lt;&lt; 0x04;
-    tmppriority = ((u32)tmppriority) &lt;&lt; ((NVIC_InitStruct-&gt;NVIC_IRQChannel &amp; (u8)0x03) * 0x08);
-    
-    tmpreg = NVIC-&gt;IPR[(NVIC_InitStruct-&gt;NVIC_IRQChannel &gt;&gt; 0x02)];
-    tmpmask = (u32)0xFF &lt;&lt; ((NVIC_InitStruct-&gt;NVIC_IRQChannel &amp; (u8)0x03) * 0x08);
-    tmpreg &amp;= ~tmpmask;
-    tmppriority &amp;= tmpmask;  
-    tmpreg |= tmppriority;
-
-    NVIC-&gt;IPR[(NVIC_InitStruct-&gt;NVIC_IRQChannel &gt;&gt; 0x02)] = tmpreg;
-    
-    /* Enable the Selected IRQ Channels --------------------------------------*/
-    NVIC-&gt;ISER[(NVIC_InitStruct-&gt;NVIC_IRQChannel &gt;&gt; 0x05)] =
-      (u32)0x01 &lt;&lt; (NVIC_InitStruct-&gt;NVIC_IRQChannel &amp; (u8)0x1F);
-  }
-  else
-  {
-    /* Disable the Selected IRQ Channels -------------------------------------*/
-    NVIC-&gt;ICER[(NVIC_InitStruct-&gt;NVIC_IRQChannel &gt;&gt; 0x05)] =
-      (u32)0x01 &lt;&lt; (NVIC_InitStruct-&gt;NVIC_IRQChannel &amp; (u8)0x1F);
-  }
-}
-
-/*******************************************************************************
-* Function Name  : NVIC_StructInit
-* Description    : Fills each NVIC_InitStruct member with its default value.
-* Input          : - NVIC_InitStruct: pointer to a NVIC_InitTypeDef structure which
-*                    will be initialized.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void NVIC_StructInit(NVIC_InitTypeDef* NVIC_InitStruct)
-{
-  /* NVIC_InitStruct members default value */
-  NVIC_InitStruct-&gt;NVIC_IRQChannel = 0x00;
-  NVIC_InitStruct-&gt;NVIC_IRQChannelPreemptionPriority = 0x00;
-  NVIC_InitStruct-&gt;NVIC_IRQChannelSubPriority = 0x00;
-  NVIC_InitStruct-&gt;NVIC_IRQChannelCmd = DISABLE;
-}
-
-/*******************************************************************************
-* Function Name  : NVIC_SETPRIMASK
-* Description    : Enables the PRIMASK priority: Raises the execution priority to 0.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void NVIC_SETPRIMASK(void)
-{
-  __SETPRIMASK();
-}
-
-/*******************************************************************************
-* Function Name  : NVIC_RESETPRIMASK
-* Description    : Disables the PRIMASK priority.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void NVIC_RESETPRIMASK(void)
-{
-  __RESETPRIMASK();
-}
-
-/*******************************************************************************
-* Function Name  : NVIC_SETFAULTMASK
-* Description    : Enables the FAULTMASK priority: Raises the execution priority to -1.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void NVIC_SETFAULTMASK(void)
-{
-  __SETFAULTMASK();
-}
-
-/*******************************************************************************
-* Function Name  : NVIC_RESETFAULTMASK
-* Description    : Disables the FAULTMASK priority.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void NVIC_RESETFAULTMASK(void)
-{
-  __RESETFAULTMASK();
-}
-
-/*******************************************************************************
-* Function Name  : NVIC_BASEPRICONFIG
-* Description    : The execution priority can be changed from 15 (lowest 
-                   configurable priority) to 1. Writing a zero  value will disable 
-*                  the mask of execution priority.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void NVIC_BASEPRICONFIG(u32 NewPriority)
-{
-  /* Check the parameters */
-  assert_param(IS_NVIC_BASE_PRI(NewPriority));
-  
-  __BASEPRICONFIG(NewPriority &lt;&lt; 0x04);
-}
-
-/*******************************************************************************
-* Function Name  : NVIC_GetBASEPRI
-* Description    : Returns the BASEPRI mask value.
-* Input          : None
-* Output         : None
-* Return         : BASEPRI register value
-*******************************************************************************/
-u32 NVIC_GetBASEPRI(void)
-{
-  return (__GetBASEPRI());
-}
-
-/*******************************************************************************
-* Function Name  : NVIC_GetCurrentPendingIRQChannel
-* Description    : Returns the current pending IRQ channel identifier.
-* Input          : None
-* Output         : None
-* Return         : Pending IRQ Channel Identifier.
-*******************************************************************************/
-u16 NVIC_GetCurrentPendingIRQChannel(void)
-{
-  return ((u16)((SCB-&gt;ICSR &amp; (u32)0x003FF000) &gt;&gt; 0x0C));
-}
-
-/*******************************************************************************
-* Function Name  : NVIC_GetIRQChannelPendingBitStatus
-* Description    : Checks whether the specified IRQ Channel pending bit is set
-*                  or not.
-* Input          : - NVIC_IRQChannel: specifies the interrupt pending bit to check.
-* Output         : None
-* Return         : The new state of IRQ Channel pending bit(SET or RESET).
-*******************************************************************************/
-ITStatus NVIC_GetIRQChannelPendingBitStatus(u8 NVIC_IRQChannel)
-{
-  ITStatus pendingirqstatus = RESET;
-  u32 tmp = 0x00;
-  
-  /* Check the parameters */
-  assert_param(IS_NVIC_IRQ_CHANNEL(NVIC_IRQChannel));
-  
-  tmp = ((u32)0x01 &lt;&lt; (NVIC_IRQChannel &amp; (u32)0x1F));
-
-  if (((NVIC-&gt;ISPR[(NVIC_IRQChannel &gt;&gt; 0x05)]) &amp; tmp) == tmp)
-  {
-    pendingirqstatus = SET;
-  }
-  else
-  {
-    pendingirqstatus = RESET;
-  }
-  return pendingirqstatus;
-}
-
-/*******************************************************************************
-* Function Name  : NVIC_SetIRQChannelPendingBit
-* Description    : Sets the NVIC's interrupt pending bit.
-* Input          : - NVIC_IRQChannel: specifies the interrupt pending bit to Set.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void NVIC_SetIRQChannelPendingBit(u8 NVIC_IRQChannel)
-{
-  /* Check the parameters */
-  assert_param(IS_NVIC_IRQ_CHANNEL(NVIC_IRQChannel));
-  
-  *(vu32*) 0xE000EF00 = (u32)NVIC_IRQChannel;
-}
-
-/*******************************************************************************
-* Function Name  : NVIC_ClearIRQChannelPendingBit
-* Description    : Clears the NVIC's interrupt pending bit.
-* Input          : - NVIC_IRQChannel: specifies the interrupt pending bit to clear.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void NVIC_ClearIRQChannelPendingBit(u8 NVIC_IRQChannel)
-{
-  /* Check the parameters */
-  assert_param(IS_NVIC_IRQ_CHANNEL(NVIC_IRQChannel));
-  
-  NVIC-&gt;ICPR[(NVIC_IRQChannel &gt;&gt; 0x05)] = (u32)0x01 &lt;&lt; (NVIC_IRQChannel &amp; (u32)0x1F);
-}
-
-/*******************************************************************************
-* Function Name  : NVIC_GetCurrentActiveHandler
-* Description    : Returns the current active Handler (IRQ Channel and
-*                  SystemHandler) identifier.
-* Input          : None
-* Output         : None
-* Return         : Active Handler Identifier.
-*******************************************************************************/
-u16 NVIC_GetCurrentActiveHandler(void)
-{
-  return ((u16)(SCB-&gt;ICSR &amp; (u32)0x3FF));
-}
-
-/*******************************************************************************
-* Function Name  : NVIC_GetIRQChannelActiveBitStatus
-* Description    : Checks whether the specified IRQ Channel active bit is set
-*                  or not.
-* Input          : - NVIC_IRQChannel: specifies the interrupt active bit to check.
-* Output         : None
-* Return         : The new state of IRQ Channel active bit(SET or RESET).
-*******************************************************************************/
-ITStatus NVIC_GetIRQChannelActiveBitStatus(u8 NVIC_IRQChannel)
-{
-  ITStatus activeirqstatus = RESET;
-  u32 tmp = 0x00;
-
-  /* Check the parameters */
-  assert_param(IS_NVIC_IRQ_CHANNEL(NVIC_IRQChannel));
-  
-  tmp = ((u32)0x01 &lt;&lt; (NVIC_IRQChannel &amp; (u32)0x1F));
-
-  if (((NVIC-&gt;IABR[(NVIC_IRQChannel &gt;&gt; 0x05)]) &amp; tmp) == tmp )
-  {
-    activeirqstatus = SET;
-  }
-  else
-  {
-    activeirqstatus = RESET;
-  }
-  return activeirqstatus;
-}
-
-/*******************************************************************************
-* Function Name  : NVIC_GetCPUID
-* Description    : Returns the ID number, the version number and the implementation
-*                  details of the Cortex-M3 core.
-* Input          : None
-* Output         : None
-* Return         : CPU ID.
-*******************************************************************************/
-u32 NVIC_GetCPUID(void)
-{
-  return (SCB-&gt;CPUID);
-}
-
-/*******************************************************************************
-* Function Name  : NVIC_SetVectorTable
-* Description    : Sets the vector table location and Offset.
-* Input          : - NVIC_VectTab: specifies if the vector table is in RAM or
-*                    FLASH memory.
-*                    This parameter can be one of the following values:
-*                       - NVIC_VectTab_RAM
-*                       - NVIC_VectTab_FLASH
-*                  - Offset: Vector Table base offset field. 
-*                            This value must be a multiple of 0x100.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void NVIC_SetVectorTable(u32 NVIC_VectTab, u32 Offset)
-{ 
-  /* Check the parameters */
-  assert_param(IS_NVIC_VECTTAB(NVIC_VectTab));
-  assert_param(IS_NVIC_OFFSET(Offset));  
-   
-  SCB-&gt;VTOR = NVIC_VectTab | (Offset &amp; (u32)0x1FFFFF80);
-}
-
-/*******************************************************************************
-* Function Name  : NVIC_GenerateSystemReset
-* Description    : Generates a system reset.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void NVIC_GenerateSystemReset(void)
-{
-  SCB-&gt;AIRCR = AIRCR_VECTKEY_MASK | (u32)0x04;
-}
-
-/*******************************************************************************
-* Function Name  : NVIC_GenerateCoreReset
-* Description    : Generates a Core (Core + NVIC) reset.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void NVIC_GenerateCoreReset(void)
-{
-  SCB-&gt;AIRCR = AIRCR_VECTKEY_MASK | (u32)0x01;
-}
-
-/*******************************************************************************
-* Function Name  : NVIC_SystemLPConfig
-* Description    : Selects the condition for the system to enter low power mode.
-* Input          : - LowPowerMode: Specifies the new mode for the system to enter
-*                    low power mode.
-*                    This parameter can be one of the following values:
-*                       - NVIC_LP_SEVONPEND
-*                       - NVIC_LP_SLEEPDEEP
-*                       - NVIC_LP_SLEEPONEXIT
-*                  - NewState: new state of LP condition.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void NVIC_SystemLPConfig(u8 LowPowerMode, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_NVIC_LP(LowPowerMode));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));  
-  
-  if (NewState != DISABLE)
-  {
-    SCB-&gt;SCR |= LowPowerMode;
-  }
-  else
-  {
-    SCB-&gt;SCR &amp;= (u32)(~(u32)LowPowerMode);
-  }
-}
-
-/*******************************************************************************
-* Function Name  : NVIC_SystemHandlerConfig
-* Description    : Enables or disables the specified System Handlers.
-* Input          : - SystemHandler: specifies the system handler to be enabled
-*                    or disabled.
-*                    This parameter can be one of the following values:
-*                       - SystemHandler_MemoryManage
-*                       - SystemHandler_BusFault
-*                       - SystemHandler_UsageFault
-*                  - NewState: new state of  specified System Handlers.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void NVIC_SystemHandlerConfig(u32 SystemHandler, FunctionalState NewState)
-{
-  u32 tmpreg = 0x00;
-
-  /* Check the parameters */
-  assert_param(IS_CONFIG_SYSTEM_HANDLER(SystemHandler));
-  assert_param(IS_FUNCTIONAL_STATE(NewState)); 
-  
-  tmpreg =  (u32)0x01 &lt;&lt; (SystemHandler &amp; (u32)0x1F);
-
-  if (NewState != DISABLE)
-  {
-    SCB-&gt;SHCSR |= tmpreg;
-  }
-  else
-  {
-    SCB-&gt;SHCSR &amp;= ~tmpreg;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : NVIC_SystemHandlerPriorityConfig
-* Description    : Configures the specified System Handlers priority.
-* Input          : - SystemHandler: specifies the system handler to be
-*                    enabled or disabled.
-*                    This parameter can be one of the following values:
-*                       - SystemHandler_MemoryManage
-*                       - SystemHandler_BusFault
-*                       - SystemHandler_UsageFault
-*                       - SystemHandler_SVCall
-*                       - SystemHandler_DebugMonitor
-*                       - SystemHandler_PSV
-*                       - SystemHandler_SysTick
-*                  - SystemHandlerPreemptionPriority: new priority group of the
-*                    specified system handlers.
-*                  - SystemHandlerSubPriority: new sub priority of the specified
-*                    system handlers.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void NVIC_SystemHandlerPriorityConfig(u32 SystemHandler, u8 SystemHandlerPreemptionPriority,
-                                      u8 SystemHandlerSubPriority)
-{
-  u32 tmp1 = 0x00, tmp2 = 0xFF, handlermask = 0x00;
-  u32 tmppriority = 0x00;
-
-  /* Check the parameters */
-  assert_param(IS_PRIORITY_SYSTEM_HANDLER(SystemHandler));
-  assert_param(IS_NVIC_PREEMPTION_PRIORITY(SystemHandlerPreemptionPriority));  
-  assert_param(IS_NVIC_SUB_PRIORITY(SystemHandlerSubPriority));
-    
-  tmppriority = (0x700 - (SCB-&gt;AIRCR &amp; (u32)0x700))&gt;&gt; 0x08;
-  tmp1 = (0x4 - tmppriority);
-  tmp2 = tmp2 &gt;&gt; tmppriority;
-    
-  tmppriority = (u32)SystemHandlerPreemptionPriority &lt;&lt; tmp1;
-  tmppriority |=  SystemHandlerSubPriority &amp; tmp2;
-
-  tmppriority = tmppriority &lt;&lt; 0x04;
-  tmp1 = SystemHandler &amp; (u32)0xC0;
-  tmp1 = tmp1 &gt;&gt; 0x06; 
-  tmp2 = (SystemHandler &gt;&gt; 0x08) &amp; (u32)0x03;
-  tmppriority = tmppriority &lt;&lt; (tmp2 * 0x08);
-  handlermask = (u32)0xFF &lt;&lt; (tmp2 * 0x08);
-  
-  SCB-&gt;SHPR[tmp1] &amp;= ~handlermask;
-  SCB-&gt;SHPR[tmp1] |= tmppriority;
-}
-
-/*******************************************************************************
-* Function Name  : NVIC_GetSystemHandlerPendingBitStatus
-* Description    : Checks whether the specified System handlers pending bit is
-*                  set or not.
-* Input          : - SystemHandler: specifies the system handler pending bit to
-*                    check.
-*                    This parameter can be one of the following values:
-*                       - SystemHandler_MemoryManage
-*                       - SystemHandler_BusFault
-*                       - SystemHandler_SVCall
-* Output         : None
-* Return         : The new state of System Handler pending bit(SET or RESET).
-*******************************************************************************/
-ITStatus NVIC_GetSystemHandlerPendingBitStatus(u32 SystemHandler)
-{
-  ITStatus bitstatus  = RESET;
-  u32 tmp = 0x00, tmppos = 0x00;
-
-  /* Check the parameters */
-  assert_param(IS_GET_PENDING_SYSTEM_HANDLER(SystemHandler));
-  
-  tmppos = (SystemHandler &gt;&gt; 0x0A);
-  tmppos &amp;= (u32)0x0F;
-
-  tmppos = (u32)0x01 &lt;&lt; tmppos;
-
-  tmp = SCB-&gt;SHCSR &amp; tmppos;
-
-  if (tmp == tmppos)
-  {
-    bitstatus = SET;
-  }
-  else
-  {
-    bitstatus = RESET;
-  }
-  return bitstatus;
-}
-
-/*******************************************************************************
-* Function Name  : NVIC_SetSystemHandlerPendingBit
-* Description    : Sets System Handler pending bit.
-* Input          : - SystemHandler: specifies the system handler pending bit
-*                    to be set.
-*                    This parameter can be one of the following values:
-*                       - SystemHandler_NMI
-*                       - SystemHandler_PSV
-*                       - SystemHandler_SysTick
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void NVIC_SetSystemHandlerPendingBit(u32 SystemHandler)
-{
-  u32 tmp = 0x00;
-
-  /* Check the parameters */
-  assert_param(IS_SET_PENDING_SYSTEM_HANDLER(SystemHandler));
-  
-  /* Get the System Handler pending bit position */
-  tmp = SystemHandler &amp; (u32)0x1F;
-  /* Set the corresponding System Handler pending bit */
-  SCB-&gt;ICSR |= ((u32)0x01 &lt;&lt; tmp);
-}
-
-/*******************************************************************************
-* Function Name  : NVIC_ClearSystemHandlerPendingBit
-* Description    : Clears System Handler pending bit.
-* Input          : - SystemHandler: specifies the system handler pending bit to
-*                    be clear.
-*                    This parameter can be one of the following values:
-*                       - SystemHandler_PSV
-*                       - SystemHandler_SysTick
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void NVIC_ClearSystemHandlerPendingBit(u32 SystemHandler)
-{
-  u32 tmp = 0x00;
-
-  /* Check the parameters */
-  assert_param(IS_CLEAR_SYSTEM_HANDLER(SystemHandler));
-  
-  /* Get the System Handler pending bit position */
-  tmp = SystemHandler &amp; (u32)0x1F;
-  /* Clear the corresponding System Handler pending bit */
-  SCB-&gt;ICSR |= ((u32)0x01 &lt;&lt; (tmp - 0x01));
-}
-
-/*******************************************************************************
-* Function Name  : NVIC_GetSystemHandlerActiveBitStatus
-* Description    : Checks whether the specified System handlers active bit is
-*                  set or not.
-* Input          : - SystemHandler: specifies the system handler active bit to
-*                    check.
-*                    This parameter can be one of the following values:
-*                       - SystemHandler_MemoryManage
-*                       - SystemHandler_BusFault
-*                       - SystemHandler_UsageFault
-*                       - SystemHandler_SVCall
-*                       - SystemHandler_DebugMonitor
-*                       - SystemHandler_PSV
-*                       - SystemHandler_SysTick
-* Output         : None
-* Return         : The new state of System Handler active bit(SET or RESET).
-*******************************************************************************/
-ITStatus NVIC_GetSystemHandlerActiveBitStatus(u32 SystemHandler)
-{
-  ITStatus bitstatus  = RESET;
-
-  u32 tmp = 0x00, tmppos = 0x00;
-
-  /* Check the parameters */
-  assert_param(IS_GET_ACTIVE_SYSTEM_HANDLER(SystemHandler));
-  
-  tmppos = (SystemHandler &gt;&gt; 0x0E) &amp; (u32)0x0F;
-
-  tmppos = (u32)0x01 &lt;&lt; tmppos;
-
-  tmp = SCB-&gt;SHCSR &amp; tmppos;
-
-  if (tmp == tmppos)
-  {
-    bitstatus = SET;
-  }
-  else
-  {
-    bitstatus = RESET;
-  }
-  return bitstatus;
-}
-
-/*******************************************************************************
-* Function Name  : NVIC_GetFaultHandlerSources
-* Description    : Returns the system fault handlers sources.
-* Input          : - SystemHandler: specifies the system handler to get its fault
-*                    sources.
-*                    This parameter can be one of the following values:
-*                       - SystemHandler_HardFault
-*                       - SystemHandler_MemoryManage
-*                       - SystemHandler_BusFault
-*                       - SystemHandler_UsageFault
-*                       - SystemHandler_DebugMonitor
-* Output         : None
-* Return         : Source of the fault handler.
-*******************************************************************************/
-u32 NVIC_GetFaultHandlerSources(u32 SystemHandler)
-{
-  u32 faultsources = 0x00;
-  u32 tmpreg = 0x00, tmppos = 0x00;
-
-  /* Check the parameters */
-  assert_param(IS_FAULT_SOURCE_SYSTEM_HANDLER(SystemHandler));
-  
-  tmpreg = (SystemHandler &gt;&gt; 0x12) &amp; (u32)0x03;
-  tmppos = (SystemHandler &gt;&gt; 0x14) &amp; (u32)0x03;
-
-  if (tmpreg == 0x00)
-  {
-    faultsources = SCB-&gt;HFSR;
-  }
-  else if (tmpreg == 0x01)
-  {
-    faultsources = SCB-&gt;CFSR &gt;&gt; (tmppos * 0x08);
-    if (tmppos != 0x02)
-    {
-      faultsources &amp;= (u32)0x0F;
-    }
-    else
-    {
-      faultsources &amp;= (u32)0xFF;
-    }
-  }
-  else
-  {
-    faultsources = SCB-&gt;DFSR;
-  }
-  return faultsources;
-}
-
-/*******************************************************************************
-* Function Name  : NVIC_GetFaultAddress
-* Description    : Returns the address of the location that generated a fault
-*                  handler.
-* Input          : - SystemHandler: specifies the system handler to get its
-*                    fault address.
-*                    This parameter can be one of the following values:
-*                       - SystemHandler_MemoryManage
-*                       - SystemHandler_BusFault
-* Output         : None
-* Return         : Fault address.
-*******************************************************************************/
-u32 NVIC_GetFaultAddress(u32 SystemHandler)
-{
-  u32 faultaddress = 0x00;
-  u32 tmp = 0x00;
-
-  /* Check the parameters */
-  assert_param(IS_FAULT_ADDRESS_SYSTEM_HANDLER(SystemHandler));
-  
-  tmp = (SystemHandler &gt;&gt; 0x16) &amp; (u32)0x01;
-
-  if (tmp == 0x00)
-  {
-    faultaddress = SCB-&gt;MMFAR;
-  }
-  else
-  {
-    faultaddress = SCB-&gt;BFAR;
-  }
-  return faultaddress;
-}
-
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/

Modified: trunk/src/platform/stm32/FWLib/library/src/stm32f10x_pwr.c
===================================================================
--- trunk/src/platform/stm32/FWLib/library/src/stm32f10x_pwr.c	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/src/stm32f10x_pwr.c	2009-07-08 23:39:34 UTC (rev 354)
@@ -1,280 +1,311 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_pwr.c
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file provides all the PWR firmware functions.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
-
-/* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_pwr.h&quot;
-#include &quot;stm32f10x_rcc.h&quot;
-
-/* Private typedef -----------------------------------------------------------*/
-/* Private define ------------------------------------------------------------*/
-/* --------- PWR registers bit address in the alias region ---------- */
-#define PWR_OFFSET               (PWR_BASE - PERIPH_BASE)
-
-/* --- CR Register ---*/
-/* Alias word address of DBP bit */
-#define CR_OFFSET                (PWR_OFFSET + 0x00)
-#define DBP_BitNumber            0x08
-#define CR_DBP_BB                (PERIPH_BB_BASE + (CR_OFFSET * 32) + (DBP_BitNumber * 4))
-
-/* Alias word address of PVDE bit */
-#define PVDE_BitNumber           0x04
-#define CR_PVDE_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (PVDE_BitNumber * 4))
-
-/* --- CSR Register ---*/
-/* Alias word address of EWUP bit */
-#define CSR_OFFSET               (PWR_OFFSET + 0x04)
-#define EWUP_BitNumber           0x08
-#define CSR_EWUP_BB              (PERIPH_BB_BASE + (CSR_OFFSET * 32) + (EWUP_BitNumber * 4))
-
-/* ------------------ PWR registers bit mask ------------------------ */
-/* CR register bit mask */
-#define CR_PDDS_Set              ((u32)0x00000002)
-#define CR_DS_Mask               ((u32)0xFFFFFFFC)
-#define CR_CWUF_Set              ((u32)0x00000004)
-#define CR_PLS_Mask              ((u32)0xFFFFFF1F)
-
-/* --------- Cortex System Control register bit mask ---------------- */
-/* Cortex System Control register address */
-#define SCB_SysCtrl              ((u32)0xE000ED10)
-/* SLEEPDEEP bit mask */
-#define SysCtrl_SLEEPDEEP_Set    ((u32)0x00000004)
-
-/* Private macro -------------------------------------------------------------*/
-/* Private variables ---------------------------------------------------------*/
-/* Private function prototypes -----------------------------------------------*/
-/* Private functions ---------------------------------------------------------*/
-
-/*******************************************************************************
-* Function Name  : PWR_DeInit
-* Description    : Deinitializes the PWR peripheral registers to their default
-*                  reset values.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void PWR_DeInit(void)
-{
-  RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, ENABLE);
-  RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, DISABLE);
-}
-
-/*******************************************************************************
-* Function Name  : PWR_BackupAccessCmd
-* Description    : Enables or disables access to the RTC and backup registers.
-* Input          : - NewState: new state of the access to the RTC and backup
-*                    registers. This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void PWR_BackupAccessCmd(FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  *(vu32 *) CR_DBP_BB = (u32)NewState;
-}
-
-/*******************************************************************************
-* Function Name  : PWR_PVDCmd
-* Description    : Enables or disables the Power Voltage Detector(PVD).
-* Input          : - NewState: new state of the PVD.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void PWR_PVDCmd(FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  *(vu32 *) CR_PVDE_BB = (u32)NewState;
-}
-
-/*******************************************************************************
-* Function Name  : PWR_PVDLevelConfig
-* Description    : Configures the voltage threshold detected by the Power Voltage
-*                  Detector(PVD).
-* Input          : - PWR_PVDLevel: specifies the PVD detection level
-*                    This parameter can be one of the following values:
-*                       - PWR_PVDLevel_2V2: PVD detection level set to 2.2V
-*                       - PWR_PVDLevel_2V3: PVD detection level set to 2.3V
-*                       - PWR_PVDLevel_2V4: PVD detection level set to 2.4V
-*                       - PWR_PVDLevel_2V5: PVD detection level set to 2.5V
-*                       - PWR_PVDLevel_2V6: PVD detection level set to 2.6V
-*                       - PWR_PVDLevel_2V7: PVD detection level set to 2.7V
-*                       - PWR_PVDLevel_2V8: PVD detection level set to 2.8V
-*                       - PWR_PVDLevel_2V9: PVD detection level set to 2.9V
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void PWR_PVDLevelConfig(u32 PWR_PVDLevel)
-{
-  u32 tmpreg = 0;
-
-  /* Check the parameters */
-  assert_param(IS_PWR_PVD_LEVEL(PWR_PVDLevel));
-
-  tmpreg = PWR-&gt;CR;
-
-  /* Clear PLS[7:5] bits */
-  tmpreg &amp;= CR_PLS_Mask;
-
-  /* Set PLS[7:5] bits according to PWR_PVDLevel value */
-  tmpreg |= PWR_PVDLevel;
-
-  /* Store the new value */
-  PWR-&gt;CR = tmpreg;
-}
-
-/*******************************************************************************
-* Function Name  : PWR_WakeUpPinCmd
-* Description    : Enables or disables the WakeUp Pin functionality.
-* Input          : - NewState: new state of the WakeUp Pin functionality.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void PWR_WakeUpPinCmd(FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  *(vu32 *) CSR_EWUP_BB = (u32)NewState;
-}
-
-/*******************************************************************************
-* Function Name  : PWR_EnterSTOPMode
-* Description    : Enters STOP mode.
-* Input          : - PWR_Regulator: specifies the regulator state in STOP mode.
-*                    This parameter can be one of the following values:
-*                       - PWR_Regulator_ON: STOP mode with regulator ON
-*                       - PWR_Regulator_LowPower: STOP mode with
-*                         regulator in low power mode
-*                  - PWR_STOPEntry: specifies if STOP mode in entered with WFI or 
-*                    WFE instruction.
-*                    This parameter can be one of the following values:
-*                       - PWR_STOPEntry_WFI: enter STOP mode with WFI instruction
-*                       - PWR_STOPEntry_WFE: enter STOP mode with WFE instruction
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void PWR_EnterSTOPMode(u32 PWR_Regulator, u8 PWR_STOPEntry)
-{
-  u32 tmpreg = 0;
-
-  /* Check the parameters */
-  assert_param(IS_PWR_REGULATOR(PWR_Regulator));
-  assert_param(IS_PWR_STOP_ENTRY(PWR_STOPEntry));
-  
-  /* Select the regulator state in STOP mode ---------------------------------*/
-  tmpreg = PWR-&gt;CR;
-
-  /* Clear PDDS and LPDS bits */
-  tmpreg &amp;= CR_DS_Mask;
-
-  /* Set LPDS bit according to PWR_Regulator value */
-  tmpreg |= PWR_Regulator;
-
-  /* Store the new value */
-  PWR-&gt;CR = tmpreg;
-
-  /* Set SLEEPDEEP bit of Cortex System Control Register */
-  *(vu32 *) SCB_SysCtrl |= SysCtrl_SLEEPDEEP_Set;
-  
-  /* Select STOP mode entry --------------------------------------------------*/
-  if(PWR_STOPEntry == PWR_STOPEntry_WFI)
-  {   
-    /* Request Wait For Interrupt */
-    __WFI();
-  }
-  else
-  {
-    /* Request Wait For Event */
-    __WFE();
-  }
-}
-
-/*******************************************************************************
-* Function Name  : PWR_EnterSTANDBYMode
-* Description    : Enters STANDBY mode.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void PWR_EnterSTANDBYMode(void)
-{
-  /* Clear Wake-up flag */
-  PWR-&gt;CR |= CR_CWUF_Set;
-
-  /* Select STANDBY mode */
-  PWR-&gt;CR |= CR_PDDS_Set;
-
-  /* Set SLEEPDEEP bit of Cortex System Control Register */
-  *(vu32 *) SCB_SysCtrl |= SysCtrl_SLEEPDEEP_Set;
-
-  /* Request Wait For Interrupt */
-  __WFI();
-}
-
-/*******************************************************************************
-* Function Name  : PWR_GetFlagStatus
-* Description    : Checks whether the specified PWR flag is set or not.
-* Input          : - PWR_FLAG: specifies the flag to check.
-*                    This parameter can be one of the following values:
-*                       - PWR_FLAG_WU: Wake Up flag
-*                       - PWR_FLAG_SB: StandBy flag
-*                       - PWR_FLAG_PVDO: PVD Output
-* Output         : None
-* Return         : The new state of PWR_FLAG (SET or RESET).
-*******************************************************************************/
-FlagStatus PWR_GetFlagStatus(u32 PWR_FLAG)
-{
-  FlagStatus bitstatus = RESET;
-
-  /* Check the parameters */
-  assert_param(IS_PWR_GET_FLAG(PWR_FLAG));
-  
-  if ((PWR-&gt;CSR &amp; PWR_FLAG) != (u32)RESET)
-  {
-    bitstatus = SET;
-  }
-  else
-  {
-    bitstatus = RESET;
-  }
-
-  /* Return the flag status */
-  return bitstatus;
-}
-
-/*******************************************************************************
-* Function Name  : PWR_ClearFlag
-* Description    : Clears the PWR's pending flags.
-* Input          : - PWR_FLAG: specifies the flag to clear.
-*                    This parameter can be one of the following values:
-*                       - PWR_FLAG_WU: Wake Up flag
-*                       - PWR_FLAG_SB: StandBy flag
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void PWR_ClearFlag(u32 PWR_FLAG)
-{
-  /* Check the parameters */
-  assert_param(IS_PWR_CLEAR_FLAG(PWR_FLAG));
-         
-  PWR-&gt;CR |=  PWR_FLAG &lt;&lt; 2;
-}
-
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
+/**
+  ******************************************************************************
+  * @file    stm32f10x_pwr.c
+  * @author  MCD Application Team
+  * @version V3.1.0
+  * @date    06/19/2009
+  * @brief   This file provides all the PWR firmware functions.
+  ******************************************************************************
+  * @copy
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * &lt;h2&gt;&lt;center&gt;&copy; COPYRIGHT 2009 STMicroelectronics&lt;/center&gt;&lt;/h2&gt;
+  */ 
+
+/* Includes ------------------------------------------------------------------*/
+#include &quot;stm32f10x_pwr.h&quot;
+#include &quot;stm32f10x_rcc.h&quot;
+
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup PWR 
+  * @brief PWR driver modules
+  * @{
+  */ 
+
+/** @defgroup PWR_Private_TypesDefinitions
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup PWR_Private_Defines
+  * @{
+  */
+
+/* --------- PWR registers bit address in the alias region ---------- */
+#define PWR_OFFSET               (PWR_BASE - PERIPH_BASE)
+
+/* --- CR Register ---*/
+
+/* Alias word address of DBP bit */
+#define CR_OFFSET                (PWR_OFFSET + 0x00)
+#define DBP_BitNumber            0x08
+#define CR_DBP_BB                (PERIPH_BB_BASE + (CR_OFFSET * 32) + (DBP_BitNumber * 4))
+
+/* Alias word address of PVDE bit */
+#define PVDE_BitNumber           0x04
+#define CR_PVDE_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (PVDE_BitNumber * 4))
+
+/* --- CSR Register ---*/
+
+/* Alias word address of EWUP bit */
+#define CSR_OFFSET               (PWR_OFFSET + 0x04)
+#define EWUP_BitNumber           0x08
+#define CSR_EWUP_BB              (PERIPH_BB_BASE + (CSR_OFFSET * 32) + (EWUP_BitNumber * 4))
+
+/* ------------------ PWR registers bit mask ------------------------ */
+
+/* CR register bit mask */
+#define CR_PDDS_Set              ((uint32_t)0x00000002)
+#define CR_DS_Mask               ((uint32_t)0xFFFFFFFC)
+#define CR_CWUF_Set              ((uint32_t)0x00000004)
+#define CR_PLS_Mask              ((uint32_t)0xFFFFFF1F)
+
+/* --------- Cortex System Control register bit mask ---------------- */
+
+/* Cortex System Control register address */
+#define SCB_SysCtrl              ((uint32_t)0xE000ED10)
+
+/* SLEEPDEEP bit mask */
+#define SysCtrl_SLEEPDEEP_Set    ((uint32_t)0x00000004)
+/**
+  * @}
+  */
+
+/** @defgroup PWR_Private_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup PWR_Private_Variables
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup PWR_Private_FunctionPrototypes
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup PWR_Private_Functions
+  * @{
+  */
+
+/**
+  * @brief  Deinitializes the PWR peripheral registers to their default reset values.
+  * @param  None
+  * @retval None
+  */
+void PWR_DeInit(void)
+{
+  RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, ENABLE);
+  RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, DISABLE);
+}
+
+/**
+  * @brief  Enables or disables access to the RTC and backup registers.
+  * @param  NewState: new state of the access to the RTC and backup registers.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void PWR_BackupAccessCmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  *(__IO uint32_t *) CR_DBP_BB = (uint32_t)NewState;
+}
+
+/**
+  * @brief  Enables or disables the Power Voltage Detector(PVD).
+  * @param  NewState: new state of the PVD.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void PWR_PVDCmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  *(__IO uint32_t *) CR_PVDE_BB = (uint32_t)NewState;
+}
+
+/**
+  * @brief  Configures the voltage threshold detected by the Power Voltage Detector(PVD).
+  * @param  PWR_PVDLevel: specifies the PVD detection level
+  *   This parameter can be one of the following values:
+  *     @arg PWR_PVDLevel_2V2: PVD detection level set to 2.2V
+  *     @arg PWR_PVDLevel_2V3: PVD detection level set to 2.3V
+  *     @arg PWR_PVDLevel_2V4: PVD detection level set to 2.4V
+  *     @arg PWR_PVDLevel_2V5: PVD detection level set to 2.5V
+  *     @arg PWR_PVDLevel_2V6: PVD detection level set to 2.6V
+  *     @arg PWR_PVDLevel_2V7: PVD detection level set to 2.7V
+  *     @arg PWR_PVDLevel_2V8: PVD detection level set to 2.8V
+  *     @arg PWR_PVDLevel_2V9: PVD detection level set to 2.9V
+  * @retval None
+  */
+void PWR_PVDLevelConfig(uint32_t PWR_PVDLevel)
+{
+  uint32_t tmpreg = 0;
+  /* Check the parameters */
+  assert_param(IS_PWR_PVD_LEVEL(PWR_PVDLevel));
+  tmpreg = PWR-&gt;CR;
+  /* Clear PLS[7:5] bits */
+  tmpreg &amp;= CR_PLS_Mask;
+  /* Set PLS[7:5] bits according to PWR_PVDLevel value */
+  tmpreg |= PWR_PVDLevel;
+  /* Store the new value */
+  PWR-&gt;CR = tmpreg;
+}
+
+/**
+  * @brief  Enables or disables the WakeUp Pin functionality.
+  * @param  NewState: new state of the WakeUp Pin functionality.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void PWR_WakeUpPinCmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  *(__IO uint32_t *) CSR_EWUP_BB = (uint32_t)NewState;
+}
+
+/**
+  * @brief  Enters STOP mode.
+  * @param  PWR_Regulator: specifies the regulator state in STOP mode.
+  *   This parameter can be one of the following values:
+  *     @arg PWR_Regulator_ON: STOP mode with regulator ON
+  *     @arg PWR_Regulator_LowPower: STOP mode with regulator in low power mode
+  * @param  PWR_STOPEntry: specifies if STOP mode in entered with WFI or WFE instruction.
+  *   This parameter can be one of the following values:
+  *     @arg PWR_STOPEntry_WFI: enter STOP mode with WFI instruction
+  *     @arg PWR_STOPEntry_WFE: enter STOP mode with WFE instruction
+  * @retval None
+  */
+void PWR_EnterSTOPMode(uint32_t PWR_Regulator, uint8_t PWR_STOPEntry)
+{
+  uint32_t tmpreg = 0;
+  /* Check the parameters */
+  assert_param(IS_PWR_REGULATOR(PWR_Regulator));
+  assert_param(IS_PWR_STOP_ENTRY(PWR_STOPEntry));
+  
+  /* Select the regulator state in STOP mode ---------------------------------*/
+  tmpreg = PWR-&gt;CR;
+  /* Clear PDDS and LPDS bits */
+  tmpreg &amp;= CR_DS_Mask;
+  /* Set LPDS bit according to PWR_Regulator value */
+  tmpreg |= PWR_Regulator;
+  /* Store the new value */
+  PWR-&gt;CR = tmpreg;
+  /* Set SLEEPDEEP bit of Cortex System Control Register */
+  *(__IO uint32_t *) SCB_SysCtrl |= SysCtrl_SLEEPDEEP_Set;
+  
+  /* Select STOP mode entry --------------------------------------------------*/
+  if(PWR_STOPEntry == PWR_STOPEntry_WFI)
+  {   
+    /* Request Wait For Interrupt */
+    __WFI();
+  }
+  else
+  {
+    /* Request Wait For Event */
+    __WFE();
+  }
+}
+
+/**
+  * @brief  Enters STANDBY mode.
+  * @param  None
+  * @retval None
+  */
+void PWR_EnterSTANDBYMode(void)
+{
+  /* Clear Wake-up flag */
+  PWR-&gt;CR |= CR_CWUF_Set;
+  /* Select STANDBY mode */
+  PWR-&gt;CR |= CR_PDDS_Set;
+  /* Set SLEEPDEEP bit of Cortex System Control Register */
+  *(__IO uint32_t *) SCB_SysCtrl |= SysCtrl_SLEEPDEEP_Set;
+/* This option is used to ensure that store operations are completed */
+#if defined ( __CC_ARM   )
+  __force_stores();
+#endif
+  /* Request Wait For Interrupt */
+  __WFI();
+}
+
+/**
+  * @brief  Checks whether the specified PWR flag is set or not.
+  * @param  PWR_FLAG: specifies the flag to check.
+  *   This parameter can be one of the following values:
+  *     @arg PWR_FLAG_WU: Wake Up flag
+  *     @arg PWR_FLAG_SB: StandBy flag
+  *     @arg PWR_FLAG_PVDO: PVD Output
+  * @retval The new state of PWR_FLAG (SET or RESET).
+  */
+FlagStatus PWR_GetFlagStatus(uint32_t PWR_FLAG)
+{
+  FlagStatus bitstatus = RESET;
+  /* Check the parameters */
+  assert_param(IS_PWR_GET_FLAG(PWR_FLAG));
+  
+  if ((PWR-&gt;CSR &amp; PWR_FLAG) != (uint32_t)RESET)
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  /* Return the flag status */
+  return bitstatus;
+}
+
+/**
+  * @brief  Clears the PWR's pending flags.
+  * @param  PWR_FLAG: specifies the flag to clear.
+  *   This parameter can be one of the following values:
+  *     @arg PWR_FLAG_WU: Wake Up flag
+  *     @arg PWR_FLAG_SB: StandBy flag
+  * @retval None
+  */
+void PWR_ClearFlag(uint32_t PWR_FLAG)
+{
+  /* Check the parameters */
+  assert_param(IS_PWR_CLEAR_FLAG(PWR_FLAG));
+         
+  PWR-&gt;CR |=  PWR_FLAG &lt;&lt; 2;
+}
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2009 STMicroelectronics *****END OF FILE****/

Added: trunk/src/platform/stm32/FWLib/library/src/stm32f10x_pwr.o
===================================================================
--- trunk/src/platform/stm32/FWLib/library/src/stm32f10x_pwr.o	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/src/stm32f10x_pwr.o	2009-07-08 23:39:34 UTC (rev 354)
@@ -0,0 +1,6 @@
+ELF
+M	
WR_EnterSTOPMode
+
+
+.
+.
\ No newline at end of file

Modified: trunk/src/platform/stm32/FWLib/library/src/stm32f10x_rcc.c
===================================================================
--- trunk/src/platform/stm32/FWLib/library/src/stm32f10x_rcc.c	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/src/stm32f10x_rcc.c	2009-07-08 23:39:34 UTC (rev 354)
@@ -1,1105 +1,1447 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_rcc.c
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file provides all the RCC firmware functions.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
-
-/* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_rcc.h&quot;
-
-/* Private typedef -----------------------------------------------------------*/
-/* Private define ------------------------------------------------------------*/
-/* ------------ RCC registers bit address in the alias region ----------- */
-#define RCC_OFFSET                (RCC_BASE - PERIPH_BASE)
-
-/* --- CR Register ---*/
-/* Alias word address of HSION bit */
-#define CR_OFFSET                 (RCC_OFFSET + 0x00)
-#define HSION_BitNumber           0x00
-#define CR_HSION_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (HSION_BitNumber * 4))
-
-/* Alias word address of PLLON bit */
-#define PLLON_BitNumber           0x18
-#define CR_PLLON_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (PLLON_BitNumber * 4))
-
-/* Alias word address of CSSON bit */
-#define CSSON_BitNumber           0x13
-#define CR_CSSON_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (CSSON_BitNumber * 4))
-
-/* --- CFGR Register ---*/
-/* Alias word address of USBPRE bit */
-#define CFGR_OFFSET               (RCC_OFFSET + 0x04)
-#define USBPRE_BitNumber          0x16
-#define CFGR_USBPRE_BB            (PERIPH_BB_BASE + (CFGR_OFFSET * 32) + (USBPRE_BitNumber * 4))
-
-/* --- BDCR Register ---*/
-/* Alias word address of RTCEN bit */
-#define BDCR_OFFSET               (RCC_OFFSET + 0x20)
-#define RTCEN_BitNumber           0x0F
-#define BDCR_RTCEN_BB             (PERIPH_BB_BASE + (BDCR_OFFSET * 32) + (RTCEN_BitNumber * 4))
-
-/* Alias word address of BDRST bit */
-#define BDRST_BitNumber           0x10
-#define BDCR_BDRST_BB             (PERIPH_BB_BASE + (BDCR_OFFSET * 32) + (BDRST_BitNumber * 4))
-
-/* --- CSR Register ---*/
-/* Alias word address of LSION bit */
-#define CSR_OFFSET                (RCC_OFFSET + 0x24)
-#define LSION_BitNumber           0x00
-#define CSR_LSION_BB              (PERIPH_BB_BASE + (CSR_OFFSET * 32) + (LSION_BitNumber * 4))
-
-/* ---------------------- RCC registers bit mask ------------------------ */
-/* CR register bit mask */
-#define CR_HSEBYP_Reset           ((u32)0xFFFBFFFF)
-#define CR_HSEBYP_Set             ((u32)0x00040000)
-#define CR_HSEON_Reset            ((u32)0xFFFEFFFF)
-#define CR_HSEON_Set              ((u32)0x00010000)
-#define CR_HSITRIM_Mask           ((u32)0xFFFFFF07)
-
-/* CFGR register bit mask */
-#define CFGR_PLL_Mask             ((u32)0xFFC0FFFF)
-#define CFGR_PLLMull_Mask         ((u32)0x003C0000)
-#define CFGR_PLLSRC_Mask          ((u32)0x00010000)
-#define CFGR_PLLXTPRE_Mask        ((u32)0x00020000)
-#define CFGR_SWS_Mask             ((u32)0x0000000C)
-#define CFGR_SW_Mask              ((u32)0xFFFFFFFC)
-#define CFGR_HPRE_Reset_Mask      ((u32)0xFFFFFF0F)
-#define CFGR_HPRE_Set_Mask        ((u32)0x000000F0)
-#define CFGR_PPRE1_Reset_Mask     ((u32)0xFFFFF8FF)
-#define CFGR_PPRE1_Set_Mask       ((u32)0x00000700)
-#define CFGR_PPRE2_Reset_Mask     ((u32)0xFFFFC7FF)
-#define CFGR_PPRE2_Set_Mask       ((u32)0x00003800)
-#define CFGR_ADCPRE_Reset_Mask    ((u32)0xFFFF3FFF)
-#define CFGR_ADCPRE_Set_Mask      ((u32)0x0000C000)
-
-/* CSR register bit mask */
-#define CSR_RMVF_Set              ((u32)0x01000000)
-
-/* RCC Flag Mask */
-#define FLAG_Mask                 ((u8)0x1F)
-
-/* Typical Value of the HSI in Hz */
-#define HSI_Value                 ((u32)8000000)
-
-/* CIR register byte 2 (Bits[15:8]) base address */
-#define CIR_BYTE2_ADDRESS         ((u32)0x40021009)
-/* CIR register byte 3 (Bits[23:16]) base address */
-#define CIR_BYTE3_ADDRESS         ((u32)0x4002100A)
-
-/* CFGR register byte 4 (Bits[31:24]) base address */
-#define CFGR_BYTE4_ADDRESS        ((u32)0x40021007)
-
-/* BDCR register base address */
-#define BDCR_ADDRESS              (PERIPH_BASE + BDCR_OFFSET)
-
-#ifndef HSEStartUp_TimeOut
-/* Time out for HSE start up */
-#define HSEStartUp_TimeOut        ((u16)0x0500)
-#endif
-
-/* Private macro -------------------------------------------------------------*/
-/* Private variables ---------------------------------------------------------*/
-static uc8 APBAHBPrescTable[16] = {0, 0, 0, 0, 1, 2, 3, 4, 1, 2, 3, 4, 6, 7, 8, 9};
-static uc8 ADCPrescTable[4] = {2, 4, 6, 8};
-
-/* Private function prototypes -----------------------------------------------*/
-/* Private functions ---------------------------------------------------------*/
-
-/*******************************************************************************
-* Function Name  : RCC_DeInit
-* Description    : Resets the RCC clock configuration to the default reset state.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RCC_DeInit(void)
-{
-  /* Set HSION bit */
-  RCC-&gt;CR |= (u32)0x00000001;
-
-  /* Reset SW[1:0], HPRE[3:0], PPRE1[2:0], PPRE2[2:0], ADCPRE[1:0] and MCO[2:0] bits */
-  RCC-&gt;CFGR &amp;= (u32)0xF8FF0000;
-  
-  /* Reset HSEON, CSSON and PLLON bits */
-  RCC-&gt;CR &amp;= (u32)0xFEF6FFFF;
-
-  /* Reset HSEBYP bit */
-  RCC-&gt;CR &amp;= (u32)0xFFFBFFFF;
-
-  /* Reset PLLSRC, PLLXTPRE, PLLMUL[3:0] and USBPRE bits */
-  RCC-&gt;CFGR &amp;= (u32)0xFF80FFFF;
-
-  /* Disable all interrupts */
-  RCC-&gt;CIR = 0x00000000;
-}
-
-/*******************************************************************************
-* Function Name  : RCC_HSEConfig
-* Description    : Configures the External High Speed oscillator (HSE).
-*                  HSE can not be stopped if it is used directly or through the 
-*                  PLL as system clock.
-* Input          : - RCC_HSE: specifies the new state of the HSE.
-*                    This parameter can be one of the following values:
-*                       - RCC_HSE_OFF: HSE oscillator OFF
-*                       - RCC_HSE_ON: HSE oscillator ON
-*                       - RCC_HSE_Bypass: HSE oscillator bypassed with external
-*                         clock
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RCC_HSEConfig(u32 RCC_HSE)
-{
-  /* Check the parameters */
-  assert_param(IS_RCC_HSE(RCC_HSE));
-
-  /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
-  /* Reset HSEON bit */
-  RCC-&gt;CR &amp;= CR_HSEON_Reset;
-
-  /* Reset HSEBYP bit */
-  RCC-&gt;CR &amp;= CR_HSEBYP_Reset;
-
-  /* Configure HSE (RCC_HSE_OFF is already covered by the code section above) */
-  switch(RCC_HSE)
-  {
-    case RCC_HSE_ON:
-      /* Set HSEON bit */
-      RCC-&gt;CR |= CR_HSEON_Set;
-      break;
-      
-    case RCC_HSE_Bypass:
-      /* Set HSEBYP and HSEON bits */
-      RCC-&gt;CR |= CR_HSEBYP_Set | CR_HSEON_Set;
-      break;            
-      
-    default:
-      break;      
-  }
-}
-
-/*******************************************************************************
-* Function Name  : RCC_WaitForHSEStartUp
-* Description    : Waits for HSE start-up.
-* Input          : None
-* Output         : None
-* Return         : An ErrorStatus enumuration value:
-*                         - SUCCESS: HSE oscillator is stable and ready to use
-*                         - ERROR: HSE oscillator not yet ready
-*******************************************************************************/
-ErrorStatus RCC_WaitForHSEStartUp(void)
-{
-  vu32 StartUpCounter = 0;
-  ErrorStatus status = ERROR;
-  FlagStatus HSEStatus = RESET;
-  
-  /* Wait till HSE is ready and if Time out is reached exit */
-  do
-  {
-    HSEStatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
-    StartUpCounter++;  
-  } while((HSEStatus == RESET) &amp;&amp; (StartUpCounter != HSEStartUp_TimeOut));
-
-
-  if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
-  {
-    status = SUCCESS;
-  }
-  else
-  {
-    status = ERROR;
-  }  
-
-  return (status);
-}
-
-/*******************************************************************************
-* Function Name  : RCC_AdjustHSICalibrationValue
-* Description    : Adjusts the Internal High Speed oscillator (HSI) calibration
-*                  value.
-* Input          : - HSICalibrationValue: specifies the calibration trimming value.
-*                    This parameter must be a number between 0 and 0x1F.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RCC_AdjustHSICalibrationValue(u8 HSICalibrationValue)
-{
-  u32 tmpreg = 0;
-
-  /* Check the parameters */
-  assert_param(IS_RCC_CALIBRATION_VALUE(HSICalibrationValue));
-
-  tmpreg = RCC-&gt;CR;
-
-  /* Clear HSITRIM[4:0] bits */
-  tmpreg &amp;= CR_HSITRIM_Mask;
-
-  /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
-  tmpreg |= (u32)HSICalibrationValue &lt;&lt; 3;
-
-  /* Store the new value */
-  RCC-&gt;CR = tmpreg;
-}
-
-/*******************************************************************************
-* Function Name  : RCC_HSICmd
-* Description    : Enables or disables the Internal High Speed oscillator (HSI).
-*                  HSI can not be stopped if it is used directly or through the 
-*                  PLL as system clock.
-* Input          : - NewState: new state of the HSI.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RCC_HSICmd(FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  *(vu32 *) CR_HSION_BB = (u32)NewState;
-}
-
-/*******************************************************************************
-* Function Name  : RCC_PLLConfig
-* Description    : Configures the PLL clock source and multiplication factor.
-*                  This function must be used only when the PLL is disabled.
-* Input          : - RCC_PLLSource: specifies the PLL entry clock source.
-*                    This parameter can be one of the following values:
-*                       - RCC_PLLSource_HSI_Div2: HSI oscillator clock divided
-*                         by 2 selected as PLL clock entry
-*                       - RCC_PLLSource_HSE_Div1: HSE oscillator clock selected
-*                         as PLL clock entry
-*                       - RCC_PLLSource_HSE_Div2: HSE oscillator clock divided
-*                         by 2 selected as PLL clock entry
-*                  - RCC_PLLMul: specifies the PLL multiplication factor.
-*                    This parameter can be RCC_PLLMul_x where x:[2,16]
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RCC_PLLConfig(u32 RCC_PLLSource, u32 RCC_PLLMul)
-{
-  u32 tmpreg = 0;
-
-  /* Check the parameters */
-  assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
-  assert_param(IS_RCC_PLL_MUL(RCC_PLLMul));
-
-  tmpreg = RCC-&gt;CFGR;
-
-  /* Clear PLLSRC, PLLXTPRE and PLLMUL[3:0] bits */
-  tmpreg &amp;= CFGR_PLL_Mask;
-
-  /* Set the PLL configuration bits */
-  tmpreg |= RCC_PLLSource | RCC_PLLMul;
-
-  /* Store the new value */
-  RCC-&gt;CFGR = tmpreg;
-}
-
-/*******************************************************************************
-* Function Name  : RCC_PLLCmd
-* Description    : Enables or disables the PLL.
-*                  The PLL can not be disabled if it is used as system clock.
-* Input          : - NewState: new state of the PLL.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RCC_PLLCmd(FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  *(vu32 *) CR_PLLON_BB = (u32)NewState;
-}
-
-/*******************************************************************************
-* Function Name  : RCC_SYSCLKConfig
-* Description    : Configures the system clock (SYSCLK).
-* Input          : - RCC_SYSCLKSource: specifies the clock source used as system
-*                    clock. This parameter can be one of the following values:
-*                       - RCC_SYSCLKSource_HSI: HSI selected as system clock
-*                       - RCC_SYSCLKSource_HSE: HSE selected as system clock
-*                       - RCC_SYSCLKSource_PLLCLK: PLL selected as system clock
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RCC_SYSCLKConfig(u32 RCC_SYSCLKSource)
-{
-  u32 tmpreg = 0;
-
-  /* Check the parameters */
-  assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
-
-  tmpreg = RCC-&gt;CFGR;
-
-  /* Clear SW[1:0] bits */
-  tmpreg &amp;= CFGR_SW_Mask;
-
-  /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
-  tmpreg |= RCC_SYSCLKSource;
-
-  /* Store the new value */
-  RCC-&gt;CFGR = tmpreg;
-}
-
-/*******************************************************************************
-* Function Name  : RCC_GetSYSCLKSource
-* Description    : Returns the clock source used as system clock.
-* Input          : None
-* Output         : None
-* Return         : The clock source used as system clock. The returned value can
-*                  be one of the following:
-*                       - 0x00: HSI used as system clock
-*                       - 0x04: HSE used as system clock
-*                       - 0x08: PLL used as system clock
-*******************************************************************************/
-u8 RCC_GetSYSCLKSource(void)
-{
-  return ((u8)(RCC-&gt;CFGR &amp; CFGR_SWS_Mask));
-}
-
-/*******************************************************************************
-* Function Name  : RCC_HCLKConfig
-* Description    : Configures the AHB clock (HCLK).
-* Input          : - RCC_SYSCLK: defines the AHB clock divider. This clock is
-*                    derived from the system clock (SYSCLK).
-*                    This parameter can be one of the following values:
-*                       - RCC_SYSCLK_Div1: AHB clock = SYSCLK
-*                       - RCC_SYSCLK_Div2: AHB clock = SYSCLK/2
-*                       - RCC_SYSCLK_Div4: AHB clock = SYSCLK/4
-*                       - RCC_SYSCLK_Div8: AHB clock = SYSCLK/8
-*                       - RCC_SYSCLK_Div16: AHB clock = SYSCLK/16
-*                       - RCC_SYSCLK_Div64: AHB clock = SYSCLK/64
-*                       - RCC_SYSCLK_Div128: AHB clock = SYSCLK/128
-*                       - RCC_SYSCLK_Div256: AHB clock = SYSCLK/256
-*                       - RCC_SYSCLK_Div512: AHB clock = SYSCLK/512
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RCC_HCLKConfig(u32 RCC_SYSCLK)
-{
-  u32 tmpreg = 0;
-
-  /* Check the parameters */
-  assert_param(IS_RCC_HCLK(RCC_SYSCLK));
-
-  tmpreg = RCC-&gt;CFGR;
-
-  /* Clear HPRE[3:0] bits */
-  tmpreg &amp;= CFGR_HPRE_Reset_Mask;
-
-  /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
-  tmpreg |= RCC_SYSCLK;
-
-  /* Store the new value */
-  RCC-&gt;CFGR = tmpreg;
-}
-
-/*******************************************************************************
-* Function Name  : RCC_PCLK1Config
-* Description    : Configures the Low Speed APB clock (PCLK1).
-* Input          : - RCC_HCLK: defines the APB1 clock divider. This clock is
-*                    derived from the AHB clock (HCLK).
-*                    This parameter can be one of the following values:
-*                       - RCC_HCLK_Div1: APB1 clock = HCLK
-*                       - RCC_HCLK_Div2: APB1 clock = HCLK/2
-*                       - RCC_HCLK_Div4: APB1 clock = HCLK/4
-*                       - RCC_HCLK_Div8: APB1 clock = HCLK/8
-*                       - RCC_HCLK_Div16: APB1 clock = HCLK/16
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RCC_PCLK1Config(u32 RCC_HCLK)
-{
-  u32 tmpreg = 0;
-
-  /* Check the parameters */
-  assert_param(IS_RCC_PCLK(RCC_HCLK));
-
-  tmpreg = RCC-&gt;CFGR;
-
-  /* Clear PPRE1[2:0] bits */
-  tmpreg &amp;= CFGR_PPRE1_Reset_Mask;
-
-  /* Set PPRE1[2:0] bits according to RCC_HCLK value */
-  tmpreg |= RCC_HCLK;
-
-  /* Store the new value */
-  RCC-&gt;CFGR = tmpreg;
-}
-
-/*******************************************************************************
-* Function Name  : RCC_PCLK2Config
-* Description    : Configures the High Speed APB clock (PCLK2).
-* Input          : - RCC_HCLK: defines the APB2 clock divider. This clock is
-*                    derived from the AHB clock (HCLK).
-*                    This parameter can be one of the following values:
-*                       - RCC_HCLK_Div1: APB2 clock = HCLK
-*                       - RCC_HCLK_Div2: APB2 clock = HCLK/2
-*                       - RCC_HCLK_Div4: APB2 clock = HCLK/4
-*                       - RCC_HCLK_Div8: APB2 clock = HCLK/8
-*                       - RCC_HCLK_Div16: APB2 clock = HCLK/16
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RCC_PCLK2Config(u32 RCC_HCLK)
-{
-  u32 tmpreg = 0;
-
-  /* Check the parameters */
-  assert_param(IS_RCC_PCLK(RCC_HCLK));
-
-  tmpreg = RCC-&gt;CFGR;
-
-  /* Clear PPRE2[2:0] bits */
-  tmpreg &amp;= CFGR_PPRE2_Reset_Mask;
-
-  /* Set PPRE2[2:0] bits according to RCC_HCLK value */
-  tmpreg |= RCC_HCLK &lt;&lt; 3;
-
-  /* Store the new value */
-  RCC-&gt;CFGR = tmpreg;
-}
-
-/*******************************************************************************
-* Function Name  : RCC_ITConfig
-* Description    : Enables or disables the specified RCC interrupts.
-* Input          : - RCC_IT: specifies the RCC interrupt sources to be enabled
-*                    or disabled.
-*                    This parameter can be any combination of the following values:
-*                       - RCC_IT_LSIRDY: LSI ready interrupt
-*                       - RCC_IT_LSERDY: LSE ready interrupt
-*                       - RCC_IT_HSIRDY: HSI ready interrupt
-*                       - RCC_IT_HSERDY: HSE ready interrupt
-*                       - RCC_IT_PLLRDY: PLL ready interrupt
-*                  - NewState: new state of the specified RCC interrupts.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RCC_ITConfig(u8 RCC_IT, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_RCC_IT(RCC_IT));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Perform Byte access to RCC_CIR[12:8] bits to enable the selected interrupts */
-    *(vu8 *) CIR_BYTE2_ADDRESS |= RCC_IT;
-  }
-  else
-  {
-    /* Perform Byte access to RCC_CIR[12:8] bits to disable the selected interrupts */
-    *(vu8 *) CIR_BYTE2_ADDRESS &amp;= (u8)~RCC_IT;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : RCC_USBCLKConfig
-* Description    : Configures the USB clock (USBCLK).
-* Input          : - RCC_USBCLKSource: specifies the USB clock source. This clock
-*                    is derived from the PLL output.
-*                    This parameter can be one of the following values:
-*                       - RCC_USBCLKSource_PLLCLK_1Div5: PLL clock divided by 1,5
-*                         selected as USB clock source
-*                       - RCC_USBCLKSource_PLLCLK_Div1: PLL clock selected as USB
-*                         clock source
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RCC_USBCLKConfig(u32 RCC_USBCLKSource)
-{
-  /* Check the parameters */
-  assert_param(IS_RCC_USBCLK_SOURCE(RCC_USBCLKSource));
-
-  *(vu32 *) CFGR_USBPRE_BB = RCC_USBCLKSource;
-}
-
-/*******************************************************************************
-* Function Name  : RCC_ADCCLKConfig
-* Description    : Configures the ADC clock (ADCCLK).
-* Input          : - RCC_PCLK2: defines the ADC clock divider. This clock is
-*                    derived from the APB2 clock (PCLK2).
-*                    This parameter can be one of the following values:
-*                       - RCC_PCLK2_Div2: ADC clock = PCLK2/2
-*                       - RCC_PCLK2_Div4: ADC clock = PCLK2/4
-*                       - RCC_PCLK2_Div6: ADC clock = PCLK2/6
-*                       - RCC_PCLK2_Div8: ADC clock = PCLK2/8
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RCC_ADCCLKConfig(u32 RCC_PCLK2)
-{
-  u32 tmpreg = 0;
-
-  /* Check the parameters */
-  assert_param(IS_RCC_ADCCLK(RCC_PCLK2));
-
-  tmpreg = RCC-&gt;CFGR;
-
-  /* Clear ADCPRE[1:0] bits */
-  tmpreg &amp;= CFGR_ADCPRE_Reset_Mask;
-
-  /* Set ADCPRE[1:0] bits according to RCC_PCLK2 value */
-  tmpreg |= RCC_PCLK2;
-
-  /* Store the new value */
-  RCC-&gt;CFGR = tmpreg;
-}
-
-/*******************************************************************************
-* Function Name  : RCC_LSEConfig
-* Description    : Configures the External Low Speed oscillator (LSE).
-* Input          : - RCC_LSE: specifies the new state of the LSE.
-*                    This parameter can be one of the following values:
-*                       - RCC_LSE_OFF: LSE oscillator OFF
-*                       - RCC_LSE_ON: LSE oscillator ON
-*                       - RCC_LSE_Bypass: LSE oscillator bypassed with external
-*                         clock
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RCC_LSEConfig(u8 RCC_LSE)
-{
-  /* Check the parameters */
-  assert_param(IS_RCC_LSE(RCC_LSE));
-
-  /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
-  /* Reset LSEON bit */
-  *(vu8 *) BDCR_ADDRESS = RCC_LSE_OFF;
-
-  /* Reset LSEBYP bit */
-  *(vu8 *) BDCR_ADDRESS = RCC_LSE_OFF;
-
-  /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
-  switch(RCC_LSE)
-  {
-    case RCC_LSE_ON:
-      /* Set LSEON bit */
-      *(vu8 *) BDCR_ADDRESS = RCC_LSE_ON;
-      break;
-      
-    case RCC_LSE_Bypass:
-      /* Set LSEBYP and LSEON bits */
-      *(vu8 *) BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;
-      break;            
-      
-    default:
-      break;      
-  }
-}
-
-/*******************************************************************************
-* Function Name  : RCC_LSICmd
-* Description    : Enables or disables the Internal Low Speed oscillator (LSI).
-*                  LSI can not be disabled if the IWDG is running.
-* Input          : - NewState: new state of the LSI.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RCC_LSICmd(FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  *(vu32 *) CSR_LSION_BB = (u32)NewState;
-}
-
-/*******************************************************************************
-* Function Name  : RCC_RTCCLKConfig
-* Description    : Configures the RTC clock (RTCCLK).
-*                  Once the RTC clock is selected it can't be changed unless the
-*                  Backup domain is reset.
-* Input          : - RCC_RTCCLKSource: specifies the RTC clock source.
-*                    This parameter can be one of the following values:
-*                       - RCC_RTCCLKSource_LSE: LSE selected as RTC clock
-*                       - RCC_RTCCLKSource_LSI: LSI selected as RTC clock
-*                       - RCC_RTCCLKSource_HSE_Div128: HSE clock divided by 128
-*                         selected as RTC clock
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RCC_RTCCLKConfig(u32 RCC_RTCCLKSource)
-{
-  /* Check the parameters */
-  assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));
-
-  /* Select the RTC clock source */
-  RCC-&gt;BDCR |= RCC_RTCCLKSource;
-}
-
-/*******************************************************************************
-* Function Name  : RCC_RTCCLKCmd
-* Description    : Enables or disables the RTC clock.
-*                  This function must be used only after the RTC clock was
-*                  selected using the RCC_RTCCLKConfig function.
-* Input          : - NewState: new state of the RTC clock.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RCC_RTCCLKCmd(FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  *(vu32 *) BDCR_RTCEN_BB = (u32)NewState;
-}
-
-/*******************************************************************************
-* Function Name  : RCC_GetClocksFreq
-* Description    : Returns the frequencies of different on chip clocks.
-* Input          : - RCC_Clocks: pointer to a RCC_ClocksTypeDef structure which
-*                    will hold the clocks frequencies.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
-{
-  u32 tmp = 0, pllmull = 0, pllsource = 0, presc = 0;
-
-  /* Get SYSCLK source -------------------------------------------------------*/
-  tmp = RCC-&gt;CFGR &amp; CFGR_SWS_Mask;
-
-  switch (tmp)
-  {
-    case 0x00:  /* HSI used as system clock */
-      RCC_Clocks-&gt;SYSCLK_Frequency = HSI_Value;
-      break;
-
-    case 0x04:  /* HSE used as system clock */
-      RCC_Clocks-&gt;SYSCLK_Frequency = HSE_Value;
-      break;
-
-    case 0x08:  /* PLL used as system clock */
-      /* Get PLL clock source and multiplication factor ----------------------*/
-      pllmull = RCC-&gt;CFGR &amp; CFGR_PLLMull_Mask;
-      pllmull = ( pllmull &gt;&gt; 18) + 2;
-
-      pllsource = RCC-&gt;CFGR &amp; CFGR_PLLSRC_Mask;
-
-      if (pllsource == 0x00)
-      {/* HSI oscillator clock divided by 2 selected as PLL clock entry */
-        RCC_Clocks-&gt;SYSCLK_Frequency = (HSI_Value &gt;&gt; 1) * pllmull;
-      }
-      else
-      {/* HSE selected as PLL clock entry */
-
-        if ((RCC-&gt;CFGR &amp; CFGR_PLLXTPRE_Mask) != (u32)RESET)
-        {/* HSE oscillator clock divided by 2 */
-
-          RCC_Clocks-&gt;SYSCLK_Frequency = (HSE_Value &gt;&gt; 1) * pllmull;
-        }
-        else
-        {
-          RCC_Clocks-&gt;SYSCLK_Frequency = HSE_Value * pllmull;
-        }
-      }
-      break;
-
-    default:
-      RCC_Clocks-&gt;SYSCLK_Frequency = HSI_Value;
-      break;
-  }
-
-  /* Compute HCLK, PCLK1, PCLK2 and ADCCLK clocks frequencies ----------------*/
-  /* Get HCLK prescaler */
-  tmp = RCC-&gt;CFGR &amp; CFGR_HPRE_Set_Mask;
-  tmp = tmp &gt;&gt; 4;
-  presc = APBAHBPrescTable[tmp];
-
-  /* HCLK clock frequency */
-  RCC_Clocks-&gt;HCLK_Frequency = RCC_Clocks-&gt;SYSCLK_Frequency &gt;&gt; presc;
-
-  /* Get PCLK1 prescaler */
-  tmp = RCC-&gt;CFGR &amp; CFGR_PPRE1_Set_Mask;
-  tmp = tmp &gt;&gt; 8;
-  presc = APBAHBPrescTable[tmp];
-
-  /* PCLK1 clock frequency */
-  RCC_Clocks-&gt;PCLK1_Frequency = RCC_Clocks-&gt;HCLK_Frequency &gt;&gt; presc;
-
-  /* Get PCLK2 prescaler */
-  tmp = RCC-&gt;CFGR &amp; CFGR_PPRE2_Set_Mask;
-  tmp = tmp &gt;&gt; 11;
-  presc = APBAHBPrescTable[tmp];
-
-  /* PCLK2 clock frequency */
-  RCC_Clocks-&gt;PCLK2_Frequency = RCC_Clocks-&gt;HCLK_Frequency &gt;&gt; presc;
-
-  /* Get ADCCLK prescaler */
-  tmp = RCC-&gt;CFGR &amp; CFGR_ADCPRE_Set_Mask;
-  tmp = tmp &gt;&gt; 14;
-  presc = ADCPrescTable[tmp];
-
-  /* ADCCLK clock frequency */
-  RCC_Clocks-&gt;ADCCLK_Frequency = RCC_Clocks-&gt;PCLK2_Frequency / presc;
-}
-
-/*******************************************************************************
-* Function Name  : RCC_AHBPeriphClockCmd
-* Description    : Enables or disables the AHB peripheral clock.
-* Input          : - RCC_AHBPeriph: specifies the AHB peripheral to gates its clock.
-*                    This parameter can be any combination of the following values:
-*                       - RCC_AHBPeriph_DMA1
-*                       - RCC_AHBPeriph_DMA2
-*                       - RCC_AHBPeriph_SRAM
-*                       - RCC_AHBPeriph_FLITF
-*                       - RCC_AHBPeriph_CRC
-*                       - RCC_AHBPeriph_FSMC
-*                       - RCC_AHBPeriph_SDIO
-*                    SRAM and FLITF clock can be disabled only during sleep mode.
-*                  - NewState: new state of the specified peripheral clock.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RCC_AHBPeriphClockCmd(u32 RCC_AHBPeriph, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    RCC-&gt;AHBENR |= RCC_AHBPeriph;
-  }
-  else
-  {
-    RCC-&gt;AHBENR &amp;= ~RCC_AHBPeriph;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : RCC_APB2PeriphClockCmd
-* Description    : Enables or disables the High Speed APB (APB2) peripheral clock.
-* Input          : - RCC_APB2Periph: specifies the APB2 peripheral to gates its
-*                    clock.
-*                    This parameter can be any combination of the following values:
-*                       - RCC_APB2Periph_AFIO, RCC_APB2Periph_GPIOA, RCC_APB2Periph_GPIOB,
-*                         RCC_APB2Periph_GPIOC, RCC_APB2Periph_GPIOD, RCC_APB2Periph_GPIOE,
-*                         RCC_APB2Periph_GPIOF, RCC_APB2Periph_GPIOG, RCC_APB2Periph_ADC1,
-*                         RCC_APB2Periph_ADC2, RCC_APB2Periph_TIM1, RCC_APB2Periph_SPI1,
-*                         RCC_APB2Periph_TIM8, RCC_APB2Periph_USART1, RCC_APB2Periph_ADC3,
-*                         RCC_APB2Periph_ALL
-*                  - NewState: new state of the specified peripheral clock.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RCC_APB2PeriphClockCmd(u32 RCC_APB2Periph, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    RCC-&gt;APB2ENR |= RCC_APB2Periph;
-  }
-  else
-  {
-    RCC-&gt;APB2ENR &amp;= ~RCC_APB2Periph;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : RCC_APB1PeriphClockCmd
-* Description    : Enables or disables the Low Speed APB (APB1) peripheral clock.
-* Input          : - RCC_APB1Periph: specifies the APB1 peripheral to gates its
-*                    clock.
-*                    This parameter can be any combination of the following values:
-*                       - RCC_APB1Periph_TIM2, RCC_APB1Periph_TIM3, RCC_APB1Periph_TIM4,
-*                         RCC_APB1Periph_TIM5, RCC_APB1Periph_TIM6, RCC_APB1Periph_TIM7,
-*                         RCC_APB1Periph_WWDG, RCC_APB1Periph_SPI2, RCC_APB1Periph_SPI3,
-*                         RCC_APB1Periph_USART2, RCC_APB1Periph_USART3, RCC_APB1Periph_USART4, 
-*                         RCC_APB1Periph_USART5, RCC_APB1Periph_I2C1, RCC_APB1Periph_I2C2,
-*                         RCC_APB1Periph_USB, RCC_APB1Periph_CAN, RCC_APB1Periph_BKP,
-*                         RCC_APB1Periph_PWR, RCC_APB1Periph_DAC, RCC_APB1Periph_ALL
-*                  - NewState: new state of the specified peripheral clock.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RCC_APB1PeriphClockCmd(u32 RCC_APB1Periph, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    RCC-&gt;APB1ENR |= RCC_APB1Periph;
-  }
-  else
-  {
-    RCC-&gt;APB1ENR &amp;= ~RCC_APB1Periph;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : RCC_APB2PeriphResetCmd
-* Description    : Forces or releases High Speed APB (APB2) peripheral reset.
-* Input          : - RCC_APB2Periph: specifies the APB2 peripheral to reset.
-*                    This parameter can be any combination of the following values:
-*                       - RCC_APB2Periph_AFIO, RCC_APB2Periph_GPIOA, RCC_APB2Periph_GPIOB,
-*                         RCC_APB2Periph_GPIOC, RCC_APB2Periph_GPIOD, RCC_APB2Periph_GPIOE,
-*                         RCC_APB2Periph_GPIOF, RCC_APB2Periph_GPIOG, RCC_APB2Periph_ADC1,
-*                         RCC_APB2Periph_ADC2, RCC_APB2Periph_TIM1, RCC_APB2Periph_SPI1,
-*                         RCC_APB2Periph_TIM8, RCC_APB2Periph_USART1, RCC_APB2Periph_ADC3,
-*                         RCC_APB2Periph_ALL
-*                  - NewState: new state of the specified peripheral reset.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RCC_APB2PeriphResetCmd(u32 RCC_APB2Periph, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    RCC-&gt;APB2RSTR |= RCC_APB2Periph;
-  }
-  else
-  {
-    RCC-&gt;APB2RSTR &amp;= ~RCC_APB2Periph;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : RCC_APB1PeriphResetCmd
-* Description    : Forces or releases Low Speed APB (APB1) peripheral reset.
-* Input          : - RCC_APB1Periph: specifies the APB1 peripheral to reset.
-*                    This parameter can be any combination of the following values:
-*                       - RCC_APB1Periph_TIM2, RCC_APB1Periph_TIM3, RCC_APB1Periph_TIM4,
-*                         RCC_APB1Periph_TIM5, RCC_APB1Periph_TIM6, RCC_APB1Periph_TIM7,
-*                         RCC_APB1Periph_WWDG, RCC_APB1Periph_SPI2, RCC_APB1Periph_SPI3,
-*                         RCC_APB1Periph_USART2, RCC_APB1Periph_USART3, RCC_APB1Periph_USART4, 
-*                         RCC_APB1Periph_USART5, RCC_APB1Periph_I2C1, RCC_APB1Periph_I2C2,
-*                         RCC_APB1Periph_USB, RCC_APB1Periph_CAN, RCC_APB1Periph_BKP,
-*                         RCC_APB1Periph_PWR, RCC_APB1Periph_DAC, RCC_APB1Periph_ALL
-*                  - NewState: new state of the specified peripheral clock.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RCC_APB1PeriphResetCmd(u32 RCC_APB1Periph, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    RCC-&gt;APB1RSTR |= RCC_APB1Periph;
-  }
-  else
-  {
-    RCC-&gt;APB1RSTR &amp;= ~RCC_APB1Periph;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : RCC_BackupResetCmd
-* Description    : Forces or releases the Backup domain reset.
-* Input          : - NewState: new state of the Backup domain reset.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RCC_BackupResetCmd(FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  *(vu32 *) BDCR_BDRST_BB = (u32)NewState;
-}
-
-/*******************************************************************************
-* Function Name  : RCC_ClockSecuritySystemCmd
-* Description    : Enables or disables the Clock Security System.
-* Input          : - NewState: new state of the Clock Security System..
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  *(vu32 *) CR_CSSON_BB = (u32)NewState;
-}
-
-/*******************************************************************************
-* Function Name  : RCC_MCOConfig
-* Description    : Selects the clock source to output on MCO pin.
-* Input          : - RCC_MCO: specifies the clock source to output.
-*                    This parameter can be one of the following values:
-*                       - RCC_MCO_NoClock: No clock selected
-*                       - RCC_MCO_SYSCLK: System clock selected
-*                       - RCC_MCO_HSI: HSI oscillator clock selected
-*                       - RCC_MCO_HSE: HSE oscillator clock selected
-*                       - RCC_MCO_PLLCLK_Div2: PLL clock divided by 2 selected
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RCC_MCOConfig(u8 RCC_MCO)
-{
-  /* Check the parameters */
-  assert_param(IS_RCC_MCO(RCC_MCO));
-
-  /* Perform Byte access to MCO[2:0] bits to select the MCO source */
-  *(vu8 *) CFGR_BYTE4_ADDRESS = RCC_MCO;
-}
-
-/*******************************************************************************
-* Function Name  : RCC_GetFlagStatus
-* Description    : Checks whether the specified RCC flag is set or not.
-* Input          : - RCC_FLAG: specifies the flag to check.
-*                    This parameter can be one of the following values:
-*                       - RCC_FLAG_HSIRDY: HSI oscillator clock ready
-*                       - RCC_FLAG_HSERDY: HSE oscillator clock ready
-*                       - RCC_FLAG_PLLRDY: PLL clock ready
-*                       - RCC_FLAG_LSERDY: LSE oscillator clock ready
-*                       - RCC_FLAG_LSIRDY: LSI oscillator clock ready
-*                       - RCC_FLAG_PINRST: Pin reset
-*                       - RCC_FLAG_PORRST: POR/PDR reset
-*                       - RCC_FLAG_SFTRST: Software reset
-*                       - RCC_FLAG_IWDGRST: Independent Watchdog reset
-*                       - RCC_FLAG_WWDGRST: Window Watchdog reset
-*                       - RCC_FLAG_LPWRRST: Low Power reset
-* Output         : None
-* Return         : The new state of RCC_FLAG (SET or RESET).
-*******************************************************************************/
-FlagStatus RCC_GetFlagStatus(u8 RCC_FLAG)
-{
-  u32 tmp = 0;
-  u32 statusreg = 0;
-  FlagStatus bitstatus = RESET;
-
-  /* Check the parameters */
-  assert_param(IS_RCC_FLAG(RCC_FLAG));
-
-  /* Get the RCC register index */
-  tmp = RCC_FLAG &gt;&gt; 5;
-
-  if (tmp == 1)               /* The flag to check is in CR register */
-  {
-    statusreg = RCC-&gt;CR;
-  }
-  else if (tmp == 2)          /* The flag to check is in BDCR register */
-  {
-    statusreg = RCC-&gt;BDCR;
-  }
-  else                       /* The flag to check is in CSR register */
-  {
-    statusreg = RCC-&gt;CSR;
-  }
-
-  /* Get the flag position */
-  tmp = RCC_FLAG &amp; FLAG_Mask;
-
-  if ((statusreg &amp; ((u32)1 &lt;&lt; tmp)) != (u32)RESET)
-  {
-    bitstatus = SET;
-  }
-  else
-  {
-    bitstatus = RESET;
-  }
-
-  /* Return the flag status */
-  return bitstatus;
-}
-
-/*******************************************************************************
-* Function Name  : RCC_ClearFlag
-* Description    : Clears the RCC reset flags.
-*                  The reset flags are: RCC_FLAG_PINRST, RCC_FLAG_PORRST,
-*                  RCC_FLAG_SFTRST, RCC_FLAG_IWDGRST, RCC_FLAG_WWDGRST,
-*                  RCC_FLAG_LPWRRST
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RCC_ClearFlag(void)
-{
-  /* Set RMVF bit to clear the reset flags */
-  RCC-&gt;CSR |= CSR_RMVF_Set;
-}
-
-/*******************************************************************************
-* Function Name  : RCC_GetITStatus
-* Description    : Checks whether the specified RCC interrupt has occurred or not.
-* Input          : - RCC_IT: specifies the RCC interrupt source to check.
-*                    This parameter can be one of the following values:
-*                       - RCC_IT_LSIRDY: LSI ready interrupt
-*                       - RCC_IT_LSERDY: LSE ready interrupt
-*                       - RCC_IT_HSIRDY: HSI ready interrupt
-*                       - RCC_IT_HSERDY: HSE ready interrupt
-*                       - RCC_IT_PLLRDY: PLL ready interrupt
-*                       - RCC_IT_CSS: Clock Security System interrupt
-* Output         : None
-* Return         : The new state of RCC_IT (SET or RESET).
-*******************************************************************************/
-ITStatus RCC_GetITStatus(u8 RCC_IT)
-{
-  ITStatus bitstatus = RESET;
-
-  /* Check the parameters */
-  assert_param(IS_RCC_GET_IT(RCC_IT));
-
-  /* Check the status of the specified RCC interrupt */
-  if ((RCC-&gt;CIR &amp; RCC_IT) != (u32)RESET)
-  {
-    bitstatus = SET;
-  }
-  else
-  {
-    bitstatus = RESET;
-  }
-
-  /* Return the RCC_IT status */
-  return  bitstatus;
-}
-
-/*******************************************************************************
-* Function Name  : RCC_ClearITPendingBit
-* Description    : Clears the RCC's interrupt pending bits.
-* Input          : - RCC_IT: specifies the interrupt pending bit to clear.
-*                    This parameter can be any combination of the following values:
-*                       - RCC_IT_LSIRDY: LSI ready interrupt
-*                       - RCC_IT_LSERDY: LSE ready interrupt
-*                       - RCC_IT_HSIRDY: HSI ready interrupt
-*                       - RCC_IT_HSERDY: HSE ready interrupt
-*                       - RCC_IT_PLLRDY: PLL ready interrupt
-*                       - RCC_IT_CSS: Clock Security System interrupt
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RCC_ClearITPendingBit(u8 RCC_IT)
-{
-  /* Check the parameters */
-  assert_param(IS_RCC_CLEAR_IT(RCC_IT));
-
-  /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
-     pending bits */
-  *(vu8 *) CIR_BYTE3_ADDRESS = RCC_IT;
-}
-
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
+/**
+  ******************************************************************************
+  * @file    stm32f10x_rcc.c
+  * @author  MCD Application Team
+  * @version V3.1.0
+  * @date    06/19/2009
+  * @brief   This file provides all the RCC firmware functions.
+  ******************************************************************************
+  * @copy
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * &lt;h2&gt;&lt;center&gt;&copy; COPYRIGHT 2009 STMicroelectronics&lt;/center&gt;&lt;/h2&gt;
+  */ 
+
+/* Includes ------------------------------------------------------------------*/
+#include &quot;stm32f10x_rcc.h&quot;
+
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup RCC 
+  * @brief RCC driver modules
+  * @{
+  */ 
+
+/** @defgroup RCC_Private_TypesDefinitions
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup RCC_Private_Defines
+  * @{
+  */
+
+/* ------------ RCC registers bit address in the alias region ----------- */
+#define RCC_OFFSET                (RCC_BASE - PERIPH_BASE)
+
+/* --- CR Register ---*/
+
+/* Alias word address of HSION bit */
+#define CR_OFFSET                 (RCC_OFFSET + 0x00)
+#define HSION_BitNumber           0x00
+#define CR_HSION_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (HSION_BitNumber * 4))
+
+/* Alias word address of PLLON bit */
+#define PLLON_BitNumber           0x18
+#define CR_PLLON_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (PLLON_BitNumber * 4))
+
+#ifdef STM32F10X_CL
+ /* Alias word address of PLL2ON bit */
+ #define PLL2ON_BitNumber          0x1A
+ #define CR_PLL2ON_BB              (PERIPH_BB_BASE + (CR_OFFSET * 32) + (PLL2ON_BitNumber * 4))
+
+ /* Alias word address of PLL3ON bit */
+ #define PLL3ON_BitNumber          0x1C
+ #define CR_PLL3ON_BB              (PERIPH_BB_BASE + (CR_OFFSET * 32) + (PLL3ON_BitNumber * 4))
+#endif /* STM32F10X_CL */ 
+
+/* Alias word address of CSSON bit */
+#define CSSON_BitNumber           0x13
+#define CR_CSSON_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (CSSON_BitNumber * 4))
+
+/* --- CFGR Register ---*/
+
+/* Alias word address of USBPRE bit */
+#define CFGR_OFFSET               (RCC_OFFSET + 0x04)
+
+#ifndef STM32F10X_CL
+ #define USBPRE_BitNumber          0x16
+ #define CFGR_USBPRE_BB            (PERIPH_BB_BASE + (CFGR_OFFSET * 32) + (USBPRE_BitNumber * 4))
+#else
+ #define OTGFSPRE_BitNumber        0x16
+ #define CFGR_OTGFSPRE_BB          (PERIPH_BB_BASE + (CFGR_OFFSET * 32) + (OTGFSPRE_BitNumber * 4))
+#endif /* STM32F10X_CL */ 
+
+/* --- BDCR Register ---*/
+
+/* Alias word address of RTCEN bit */
+#define BDCR_OFFSET               (RCC_OFFSET + 0x20)
+#define RTCEN_BitNumber           0x0F
+#define BDCR_RTCEN_BB             (PERIPH_BB_BASE + (BDCR_OFFSET * 32) + (RTCEN_BitNumber * 4))
+
+/* Alias word address of BDRST bit */
+#define BDRST_BitNumber           0x10
+#define BDCR_BDRST_BB             (PERIPH_BB_BASE + (BDCR_OFFSET * 32) + (BDRST_BitNumber * 4))
+
+/* --- CSR Register ---*/
+
+/* Alias word address of LSION bit */
+#define CSR_OFFSET                (RCC_OFFSET + 0x24)
+#define LSION_BitNumber           0x00
+#define CSR_LSION_BB              (PERIPH_BB_BASE + (CSR_OFFSET * 32) + (LSION_BitNumber * 4))
+
+#ifdef STM32F10X_CL
+/* --- CFGR2 Register ---*/
+
+ /* Alias word address of I2S2SRC bit */
+ #define CFGR2_OFFSET              (RCC_OFFSET + 0x2C)
+ #define I2S2SRC_BitNumber         0x11
+ #define CFGR2_I2S2SRC_BB          (PERIPH_BB_BASE + (CFGR2_OFFSET * 32) + (I2S2SRC_BitNumber * 4))
+
+ /* Alias word address of I2S3SRC bit */
+ #define I2S3SRC_BitNumber         0x12
+ #define CFGR2_I2S3SRC_BB          (PERIPH_BB_BASE + (CFGR2_OFFSET * 32) + (I2S3SRC_BitNumber * 4))
+#endif /* STM32F10X_CL */
+
+/* ---------------------- RCC registers bit mask ------------------------ */
+
+/* CR register bit mask */
+#define CR_HSEBYP_Reset           ((uint32_t)0xFFFBFFFF)
+#define CR_HSEBYP_Set             ((uint32_t)0x00040000)
+#define CR_HSEON_Reset            ((uint32_t)0xFFFEFFFF)
+#define CR_HSEON_Set              ((uint32_t)0x00010000)
+#define CR_HSITRIM_Mask           ((uint32_t)0xFFFFFF07)
+
+/* CFGR register bit mask */
+#ifndef STM32F10X_CL
+ #define CFGR_PLL_Mask            ((uint32_t)0xFFC0FFFF)
+#else
+ #define CFGR_PLL_Mask           ((uint32_t)0xFFC2FFFF)
+#endif /* STM32F10X_CL */ 
+
+#define CFGR_PLLMull_Mask         ((uint32_t)0x003C0000)
+#define CFGR_PLLSRC_Mask          ((uint32_t)0x00010000)
+#define CFGR_PLLXTPRE_Mask        ((uint32_t)0x00020000)
+#define CFGR_SWS_Mask             ((uint32_t)0x0000000C)
+#define CFGR_SW_Mask              ((uint32_t)0xFFFFFFFC)
+#define CFGR_HPRE_Reset_Mask      ((uint32_t)0xFFFFFF0F)
+#define CFGR_HPRE_Set_Mask        ((uint32_t)0x000000F0)
+#define CFGR_PPRE1_Reset_Mask     ((uint32_t)0xFFFFF8FF)
+#define CFGR_PPRE1_Set_Mask       ((uint32_t)0x00000700)
+#define CFGR_PPRE2_Reset_Mask     ((uint32_t)0xFFFFC7FF)
+#define CFGR_PPRE2_Set_Mask       ((uint32_t)0x00003800)
+#define CFGR_ADCPRE_Reset_Mask    ((uint32_t)0xFFFF3FFF)
+#define CFGR_ADCPRE_Set_Mask      ((uint32_t)0x0000C000)
+
+/* CSR register bit mask */
+#define CSR_RMVF_Set              ((uint32_t)0x01000000)
+
+#ifdef STM32F10X_CL
+/* CFGR2 register bit mask */
+ #define CFGR2_PREDIV1SRC         ((uint32_t)0x00010000)
+ #define CFGR2_PREDIV1            ((uint32_t)0x0000000F)
+ #define CFGR2_PREDIV2            ((uint32_t)0x000000F0)
+ #define CFGR2_PLL2MUL            ((uint32_t)0x00000F00)
+ #define CFGR2_PLL3MUL            ((uint32_t)0x0000F000)
+#endif /* STM32F10X_CL */ 
+
+/* RCC Flag Mask */
+#define FLAG_Mask                 ((uint8_t)0x1F)
+
+#ifndef HSI_Value
+/* Typical Value of the HSI in Hz */
+ #define HSI_Value                 ((uint32_t)8000000)
+#endif /* HSI_Value */
+
+/* CIR register byte 2 (Bits[15:8]) base address */
+#define CIR_BYTE2_ADDRESS         ((uint32_t)0x40021009)
+
+/* CIR register byte 3 (Bits[23:16]) base address */
+#define CIR_BYTE3_ADDRESS         ((uint32_t)0x4002100A)
+
+/* CFGR register byte 4 (Bits[31:24]) base address */
+#define CFGR_BYTE4_ADDRESS        ((uint32_t)0x40021007)
+
+/* BDCR register base address */
+#define BDCR_ADDRESS              (PERIPH_BASE + BDCR_OFFSET)
+
+#ifndef HSEStartUp_TimeOut
+/* Time out for HSE start up */
+ #define HSEStartUp_TimeOut        ((uint16_t)0x0500)
+#endif /* HSEStartUp_TimeOut */
+
+/**
+  * @}
+  */ 
+
+/** @defgroup RCC_Private_Macros
+  * @{
+  */ 
+
+/**
+  * @}
+  */ 
+
+/** @defgroup RCC_Private_Variables
+  * @{
+  */ 
+
+static __I uint8_t APBAHBPrescTable[16] = {0, 0, 0, 0, 1, 2, 3, 4, 1, 2, 3, 4, 6, 7, 8, 9};
+static __I uint8_t ADCPrescTable[4] = {2, 4, 6, 8};
+
+/**
+  * @}
+  */
+
+/** @defgroup RCC_Private_FunctionPrototypes
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup RCC_Private_Functions
+  * @{
+  */
+
+/**
+  * @brief  Resets the RCC clock configuration to the default reset state.
+  * @param  None
+  * @retval None
+  */
+void RCC_DeInit(void)
+{
+  /* Set HSION bit */
+  RCC-&gt;CR |= (uint32_t)0x00000001;
+
+  /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
+#ifndef STM32F10X_CL
+  RCC-&gt;CFGR &amp;= (uint32_t)0xF8FF0000;
+#else
+  RCC-&gt;CFGR &amp;= (uint32_t)0xF0FF0000;
+#endif /* STM32F10X_CL */   
+  
+  /* Reset HSEON, CSSON and PLLON bits */
+  RCC-&gt;CR &amp;= (uint32_t)0xFEF6FFFF;
+
+  /* Reset HSEBYP bit */
+  RCC-&gt;CR &amp;= (uint32_t)0xFFFBFFFF;
+
+  /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
+  RCC-&gt;CFGR &amp;= (uint32_t)0xFF80FFFF;
+
+#ifndef STM32F10X_CL
+  /* Disable all interrupts and clear pending bits  */
+  RCC-&gt;CIR = 0x009F0000;
+#else
+  /* Reset PLL2ON and PLL3ON bits */
+  RCC-&gt;CR &amp;= (uint32_t)0xEBFFFFFF;
+
+  /* Disable all interrupts and clear pending bits  */
+  RCC-&gt;CIR = 0x00FF0000;
+
+  /* Reset CFGR2 register */
+  RCC-&gt;CFGR2 = 0x00000000;
+#endif /* STM32F10X_CL */
+}
+
+/**
+  * @brief  Configures the External High Speed oscillator (HSE).
+  * @note   HSE can not be stopped if it is used directly or through the PLL as system clock.
+  * @param  RCC_HSE: specifies the new state of the HSE.
+  *   This parameter can be one of the following values:
+  *     @arg RCC_HSE_OFF: HSE oscillator OFF
+  *     @arg RCC_HSE_ON: HSE oscillator ON
+  *     @arg RCC_HSE_Bypass: HSE oscillator bypassed with external clock
+  * @retval None
+  */
+void RCC_HSEConfig(uint32_t RCC_HSE)
+{
+  /* Check the parameters */
+  assert_param(IS_RCC_HSE(RCC_HSE));
+  /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
+  /* Reset HSEON bit */
+  RCC-&gt;CR &amp;= CR_HSEON_Reset;
+  /* Reset HSEBYP bit */
+  RCC-&gt;CR &amp;= CR_HSEBYP_Reset;
+  /* Configure HSE (RCC_HSE_OFF is already covered by the code section above) */
+  switch(RCC_HSE)
+  {
+    case RCC_HSE_ON:
+      /* Set HSEON bit */
+      RCC-&gt;CR |= CR_HSEON_Set;
+      break;
+      
+    case RCC_HSE_Bypass:
+      /* Set HSEBYP and HSEON bits */
+      RCC-&gt;CR |= CR_HSEBYP_Set | CR_HSEON_Set;
+      break;
+      
+    default:
+      break;
+  }
+}
+
+/**
+  * @brief  Waits for HSE start-up.
+  * @param  None
+  * @retval An ErrorStatus enumuration value:
+  * - SUCCESS: HSE oscillator is stable and ready to use
+  * - ERROR: HSE oscillator not yet ready
+  */
+ErrorStatus RCC_WaitForHSEStartUp(void)
+{
+  __IO uint32_t StartUpCounter = 0;
+  ErrorStatus status = ERROR;
+  FlagStatus HSEStatus = RESET;
+  
+  /* Wait till HSE is ready and if Time out is reached exit */
+  do
+  {
+    HSEStatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
+    StartUpCounter++;  
+  } while((StartUpCounter != HSEStartUp_TimeOut) &amp;&amp; (HSEStatus == RESET));
+  
+  if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
+  {
+    status = SUCCESS;
+  }
+  else
+  {
+    status = ERROR;
+  }  
+  return (status);
+}
+
+/**
+  * @brief  Adjusts the Internal High Speed oscillator (HSI) calibration value.
+  * @param  HSICalibrationValue: specifies the calibration trimming value.
+  *   This parameter must be a number between 0 and 0x1F.
+  * @retval None
+  */
+void RCC_AdjustHSICalibrationValue(uint8_t HSICalibrationValue)
+{
+  uint32_t tmpreg = 0;
+  /* Check the parameters */
+  assert_param(IS_RCC_CALIBRATION_VALUE(HSICalibrationValue));
+  tmpreg = RCC-&gt;CR;
+  /* Clear HSITRIM[4:0] bits */
+  tmpreg &amp;= CR_HSITRIM_Mask;
+  /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
+  tmpreg |= (uint32_t)HSICalibrationValue &lt;&lt; 3;
+  /* Store the new value */
+  RCC-&gt;CR = tmpreg;
+}
+
+/**
+  * @brief  Enables or disables the Internal High Speed oscillator (HSI).
+  * @note   HSI can not be stopped if it is used directly or through the PLL as system clock.
+  * @param  NewState: new state of the HSI. This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void RCC_HSICmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  *(__IO uint32_t *) CR_HSION_BB = (uint32_t)NewState;
+}
+
+/**
+  * @brief  Configures the PLL clock source and multiplication factor.
+  * @note   This function must be used only when the PLL is disabled.
+  * @param  RCC_PLLSource: specifies the PLL entry clock source.
+  *   For @b STM32_Connectivity_line_devices, this parameter can be one of the
+  *   following values:
+  *     @arg RCC_PLLSource_HSI_Div2: HSI oscillator clock divided by 2 selected as PLL clock entry
+  *     @arg RCC_PLLSource_PREDIV1: PREDIV1 clock selected as PLL clock entry
+  *   For @b other_STM32_devices, this parameter can be one of the following values:
+  *     @arg RCC_PLLSource_HSI_Div2: HSI oscillator clock divided by 2 selected as PLL clock entry
+  *     @arg RCC_PLLSource_HSE_Div1: HSE oscillator clock selected as PLL clock entry
+  *     @arg RCC_PLLSource_HSE_Div2: HSE oscillator clock divided by 2 selected as PLL clock entry 
+  * @param  RCC_PLLMul: specifies the PLL multiplication factor.
+  *   For @b STM32_Connectivity_line_devices, this parameter can be RCC_PLLMul_x where x:{[4,9], 6_5}
+  *   For @b other_STM32_devices, this parameter can be RCC_PLLMul_x where x:[2,16]  
+  * @retval None
+  */
+void RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t RCC_PLLMul)
+{
+  uint32_t tmpreg = 0;
+
+  /* Check the parameters */
+  assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
+  assert_param(IS_RCC_PLL_MUL(RCC_PLLMul));
+
+  tmpreg = RCC-&gt;CFGR;
+  /* Clear PLLSRC, PLLXTPRE and PLLMUL[3:0] bits */
+  tmpreg &amp;= CFGR_PLL_Mask;
+  /* Set the PLL configuration bits */
+  tmpreg |= RCC_PLLSource | RCC_PLLMul;
+  /* Store the new value */
+  RCC-&gt;CFGR = tmpreg;
+}
+
+/**
+  * @brief  Enables or disables the PLL.
+  * @note   The PLL can not be disabled if it is used as system clock.
+  * @param  NewState: new state of the PLL. This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void RCC_PLLCmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
+}
+
+#ifdef STM32F10X_CL
+/**
+  * @brief  Configures the PREDIV1 division factor.
+  * @note 
+  *   - This function must be used only when the PLL is disabled.
+  *   - This function applies only to STM32 Connectivity line devices.
+  * @param  RCC_PREDIV1_Source: specifies the PREDIV1 clock source.
+  *   This parameter can be one of the following values:
+  *     @arg RCC_PREDIV1_Source_HSE: HSE selected as PREDIV1 clock
+  *     @arg RCC_PREDIV1_Source_PLL2: PLL2 selected as PREDIV1 clock
+  * @param  RCC_PREDIV1_Div: specifies the PREDIV1 clock division factor.
+  *   This parameter can be RCC_PREDIV1_Divx where x:[1,16]
+  * @retval None
+  */
+void RCC_PREDIV1Config(uint32_t RCC_PREDIV1_Source, uint32_t RCC_PREDIV1_Div)
+{
+  uint32_t tmpreg = 0;
+  
+  /* Check the parameters */
+  assert_param(IS_RCC_PREDIV1_SOURCE(RCC_PREDIV1_Source));
+  assert_param(IS_RCC_PREDIV1(RCC_PREDIV1_Div));
+
+  tmpreg = RCC-&gt;CFGR2;
+  /* Clear PREDIV1[3:0] and PREDIV1SRC bits */
+  tmpreg &amp;= ~(CFGR2_PREDIV1 | CFGR2_PREDIV1SRC);
+  /* Set the PREDIV1 clock source and division factor */
+  tmpreg |= RCC_PREDIV1_Source | RCC_PREDIV1_Div ;
+  /* Store the new value */
+  RCC-&gt;CFGR2 = tmpreg;
+}
+
+
+/**
+  * @brief  Configures the PREDIV2 division factor.
+  * @note 
+  *   - This function must be used only when both PLL2 and PLL3 are disabled.
+  *   - This function applies only to STM32 Connectivity line devices.
+  * @param  RCC_PREDIV2_Div: specifies the PREDIV2 clock division factor.
+  *   This parameter can be RCC_PREDIV2_Divx where x:[1,16]
+  * @retval None
+  */
+void RCC_PREDIV2Config(uint32_t RCC_PREDIV2_Div)
+{
+  uint32_t tmpreg = 0;
+
+  /* Check the parameters */
+  assert_param(IS_RCC_PREDIV2(RCC_PREDIV2_Div));
+
+  tmpreg = RCC-&gt;CFGR2;
+  /* Clear PREDIV2[3:0] bits */
+  tmpreg &amp;= ~CFGR2_PREDIV2;
+  /* Set the PREDIV2 division factor */
+  tmpreg |= RCC_PREDIV2_Div;
+  /* Store the new value */
+  RCC-&gt;CFGR2 = tmpreg;
+}
+
+/**
+  * @brief  Configures the PLL2 multiplication factor.
+  * @note
+  *   - This function must be used only when the PLL2 is disabled.
+  *   - This function applies only to STM32 Connectivity line devices.
+  * @param  RCC_PLL2Mul: specifies the PLL2 multiplication factor.
+  *   This parameter can be RCC_PLL2Mul_x where x:{[8,14], 16, 20}
+  * @retval None
+  */
+void RCC_PLL2Config(uint32_t RCC_PLL2Mul)
+{
+  uint32_t tmpreg = 0;
+
+  /* Check the parameters */
+  assert_param(IS_RCC_PLL2_MUL(RCC_PLL2Mul));
+
+  tmpreg = RCC-&gt;CFGR2;
+  /* Clear PLL2Mul[3:0] bits */
+  tmpreg &amp;= ~CFGR2_PLL2MUL;
+  /* Set the PLL2 configuration bits */
+  tmpreg |= RCC_PLL2Mul;
+  /* Store the new value */
+  RCC-&gt;CFGR2 = tmpreg;
+}
+
+
+/**
+  * @brief  Enables or disables the PLL2.
+  * @note 
+  *   - The PLL2 can not be disabled if it is used indirectly as system clock
+  *     (i.e. it is used as PLL clock entry that is used as System clock).
+  *   - This function applies only to STM32 Connectivity line devices.
+  * @param  NewState: new state of the PLL2. This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void RCC_PLL2Cmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  *(__IO uint32_t *) CR_PLL2ON_BB = (uint32_t)NewState;
+}
+
+
+/**
+  * @brief  Configures the PLL3 multiplication factor.
+  * @note 
+  *   - This function must be used only when the PLL3 is disabled.
+  *   - This function applies only to STM32 Connectivity line devices.
+  * @param  RCC_PLL3Mul: specifies the PLL3 multiplication factor.
+  *   This parameter can be RCC_PLL3Mul_x where x:{[8,14], 16, 20}
+  * @retval None
+  */
+void RCC_PLL3Config(uint32_t RCC_PLL3Mul)
+{
+  uint32_t tmpreg = 0;
+
+  /* Check the parameters */
+  assert_param(IS_RCC_PLL3_MUL(RCC_PLL3Mul));
+
+  tmpreg = RCC-&gt;CFGR2;
+  /* Clear PLL3Mul[3:0] bits */
+  tmpreg &amp;= ~CFGR2_PLL3MUL;
+  /* Set the PLL3 configuration bits */
+  tmpreg |= RCC_PLL3Mul;
+  /* Store the new value */
+  RCC-&gt;CFGR2 = tmpreg;
+}
+
+
+/**
+  * @brief  Enables or disables the PLL3.
+  * @note   This function applies only to STM32 Connectivity line devices.
+  * @param  NewState: new state of the PLL3. This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void RCC_PLL3Cmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  *(__IO uint32_t *) CR_PLL3ON_BB = (uint32_t)NewState;
+}
+#endif /* STM32F10X_CL */
+
+/**
+  * @brief  Configures the system clock (SYSCLK).
+  * @param  RCC_SYSCLKSource: specifies the clock source used as system clock.
+  *   This parameter can be one of the following values:
+  *     @arg RCC_SYSCLKSource_HSI: HSI selected as system clock
+  *     @arg RCC_SYSCLKSource_HSE: HSE selected as system clock
+  *     @arg RCC_SYSCLKSource_PLLCLK: PLL selected as system clock
+  * @retval None
+  */
+void RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource)
+{
+  uint32_t tmpreg = 0;
+  /* Check the parameters */
+  assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
+  tmpreg = RCC-&gt;CFGR;
+  /* Clear SW[1:0] bits */
+  tmpreg &amp;= CFGR_SW_Mask;
+  /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
+  tmpreg |= RCC_SYSCLKSource;
+  /* Store the new value */
+  RCC-&gt;CFGR = tmpreg;
+}
+
+/**
+  * @brief  Returns the clock source used as system clock.
+  * @param  None
+  * @retval The clock source used as system clock. The returned value can
+  *   be one of the following:
+  *     - 0x00: HSI used as system clock
+  *     - 0x04: HSE used as system clock
+  *     - 0x08: PLL used as system clock
+  */
+uint8_t RCC_GetSYSCLKSource(void)
+{
+  return ((uint8_t)(RCC-&gt;CFGR &amp; CFGR_SWS_Mask));
+}
+
+/**
+  * @brief  Configures the AHB clock (HCLK).
+  * @param  RCC_SYSCLK: defines the AHB clock divider. This clock is derived from 
+  *   the system clock (SYSCLK).
+  *   This parameter can be one of the following values:
+  *     @arg RCC_SYSCLK_Div1: AHB clock = SYSCLK
+  *     @arg RCC_SYSCLK_Div2: AHB clock = SYSCLK/2
+  *     @arg RCC_SYSCLK_Div4: AHB clock = SYSCLK/4
+  *     @arg RCC_SYSCLK_Div8: AHB clock = SYSCLK/8
+  *     @arg RCC_SYSCLK_Div16: AHB clock = SYSCLK/16
+  *     @arg RCC_SYSCLK_Div64: AHB clock = SYSCLK/64
+  *     @arg RCC_SYSCLK_Div128: AHB clock = SYSCLK/128
+  *     @arg RCC_SYSCLK_Div256: AHB clock = SYSCLK/256
+  *     @arg RCC_SYSCLK_Div512: AHB clock = SYSCLK/512
+  * @retval None
+  */
+void RCC_HCLKConfig(uint32_t RCC_SYSCLK)
+{
+  uint32_t tmpreg = 0;
+  /* Check the parameters */
+  assert_param(IS_RCC_HCLK(RCC_SYSCLK));
+  tmpreg = RCC-&gt;CFGR;
+  /* Clear HPRE[3:0] bits */
+  tmpreg &amp;= CFGR_HPRE_Reset_Mask;
+  /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
+  tmpreg |= RCC_SYSCLK;
+  /* Store the new value */
+  RCC-&gt;CFGR = tmpreg;
+}
+
+/**
+  * @brief  Configures the Low Speed APB clock (PCLK1).
+  * @param  RCC_HCLK: defines the APB1 clock divider. This clock is derived from 
+  *   the AHB clock (HCLK).
+  *   This parameter can be one of the following values:
+  *     @arg RCC_HCLK_Div1: APB1 clock = HCLK
+  *     @arg RCC_HCLK_Div2: APB1 clock = HCLK/2
+  *     @arg RCC_HCLK_Div4: APB1 clock = HCLK/4
+  *     @arg RCC_HCLK_Div8: APB1 clock = HCLK/8
+  *     @arg RCC_HCLK_Div16: APB1 clock = HCLK/16
+  * @retval None
+  */
+void RCC_PCLK1Config(uint32_t RCC_HCLK)
+{
+  uint32_t tmpreg = 0;
+  /* Check the parameters */
+  assert_param(IS_RCC_PCLK(RCC_HCLK));
+  tmpreg = RCC-&gt;CFGR;
+  /* Clear PPRE1[2:0] bits */
+  tmpreg &amp;= CFGR_PPRE1_Reset_Mask;
+  /* Set PPRE1[2:0] bits according to RCC_HCLK value */
+  tmpreg |= RCC_HCLK;
+  /* Store the new value */
+  RCC-&gt;CFGR = tmpreg;
+}
+
+/**
+  * @brief  Configures the High Speed APB clock (PCLK2).
+  * @param  RCC_HCLK: defines the APB2 clock divider. This clock is derived from 
+  *   the AHB clock (HCLK).
+  *   This parameter can be one of the following values:
+  *     @arg RCC_HCLK_Div1: APB2 clock = HCLK
+  *     @arg RCC_HCLK_Div2: APB2 clock = HCLK/2
+  *     @arg RCC_HCLK_Div4: APB2 clock = HCLK/4
+  *     @arg RCC_HCLK_Div8: APB2 clock = HCLK/8
+  *     @arg RCC_HCLK_Div16: APB2 clock = HCLK/16
+  * @retval None
+  */
+void RCC_PCLK2Config(uint32_t RCC_HCLK)
+{
+  uint32_t tmpreg = 0;
+  /* Check the parameters */
+  assert_param(IS_RCC_PCLK(RCC_HCLK));
+  tmpreg = RCC-&gt;CFGR;
+  /* Clear PPRE2[2:0] bits */
+  tmpreg &amp;= CFGR_PPRE2_Reset_Mask;
+  /* Set PPRE2[2:0] bits according to RCC_HCLK value */
+  tmpreg |= RCC_HCLK &lt;&lt; 3;
+  /* Store the new value */
+  RCC-&gt;CFGR = tmpreg;
+}
+
+/**
+  * @brief  Enables or disables the specified RCC interrupts.
+  * @param  RCC_IT: specifies the RCC interrupt sources to be enabled or disabled.
+  * 
+  *   For @b STM32_Connectivity_line_devices, this parameter can be any combination
+  *   of the following values        
+  *     @arg RCC_IT_LSIRDY: LSI ready interrupt
+  *     @arg RCC_IT_LSERDY: LSE ready interrupt
+  *     @arg RCC_IT_HSIRDY: HSI ready interrupt
+  *     @arg RCC_IT_HSERDY: HSE ready interrupt
+  *     @arg RCC_IT_PLLRDY: PLL ready interrupt
+  *     @arg RCC_IT_PLL2RDY: PLL2 ready interrupt
+  *     @arg RCC_IT_PLL3RDY: PLL3 ready interrupt
+  * 
+  *   For @b other_STM32_devices, this parameter can be any combination of the 
+  *   following values        
+  *     @arg RCC_IT_LSIRDY: LSI ready interrupt
+  *     @arg RCC_IT_LSERDY: LSE ready interrupt
+  *     @arg RCC_IT_HSIRDY: HSI ready interrupt
+  *     @arg RCC_IT_HSERDY: HSE ready interrupt
+  *     @arg RCC_IT_PLLRDY: PLL ready interrupt
+  *       
+  * @param  NewState: new state of the specified RCC interrupts.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_RCC_IT(RCC_IT));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Perform Byte access to RCC_CIR bits to enable the selected interrupts */
+    *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
+  }
+  else
+  {
+    /* Perform Byte access to RCC_CIR bits to disable the selected interrupts */
+    *(__IO uint8_t *) CIR_BYTE2_ADDRESS &amp;= (uint8_t)~RCC_IT;
+  }
+}
+
+#ifndef STM32F10X_CL
+/**
+  * @brief  Configures the USB clock (USBCLK).
+  * @param  RCC_USBCLKSource: specifies the USB clock source. This clock is 
+  *   derived from the PLL output.
+  *   This parameter can be one of the following values:
+  *     @arg RCC_USBCLKSource_PLLCLK_1Div5: PLL clock divided by 1,5 selected as USB 
+  *                                     clock source
+  *     @arg RCC_USBCLKSource_PLLCLK_Div1: PLL clock selected as USB clock source
+  * @retval None
+  */
+void RCC_USBCLKConfig(uint32_t RCC_USBCLKSource)
+{
+  /* Check the parameters */
+  assert_param(IS_RCC_USBCLK_SOURCE(RCC_USBCLKSource));
+
+  *(__IO uint32_t *) CFGR_USBPRE_BB = RCC_USBCLKSource;
+}
+#else
+/**
+  * @brief  Configures the USB OTG FS clock (OTGFSCLK).
+  *   This function applies only to STM32 Connectivity line devices.
+  * @param  RCC_OTGFSCLKSource: specifies the USB OTG FS clock source.
+  *   This clock is derived from the PLL output.
+  *   This parameter can be one of the following values:
+  *     @arg  RCC_OTGFSCLKSource_PLLVCO_Div3: PLL VCO clock divided by 2 selected as USB OTG FS clock source
+  *     @arg  RCC_OTGFSCLKSource_PLLVCO_Div2: PLL VCO clock divided by 2 selected as USB OTG FS clock source
+  * @retval None
+  */
+void RCC_OTGFSCLKConfig(uint32_t RCC_OTGFSCLKSource)
+{
+  /* Check the parameters */
+  assert_param(IS_RCC_OTGFSCLK_SOURCE(RCC_OTGFSCLKSource));
+
+  *(__IO uint32_t *) CFGR_OTGFSPRE_BB = RCC_OTGFSCLKSource;
+}
+#endif /* STM32F10X_CL */ 
+
+/**
+  * @brief  Configures the ADC clock (ADCCLK).
+  * @param  RCC_PCLK2: defines the ADC clock divider. This clock is derived from 
+  *   the APB2 clock (PCLK2).
+  *   This parameter can be one of the following values:
+  *     @arg RCC_PCLK2_Div2: ADC clock = PCLK2/2
+  *     @arg RCC_PCLK2_Div4: ADC clock = PCLK2/4
+  *     @arg RCC_PCLK2_Div6: ADC clock = PCLK2/6
+  *     @arg RCC_PCLK2_Div8: ADC clock = PCLK2/8
+  * @retval None
+  */
+void RCC_ADCCLKConfig(uint32_t RCC_PCLK2)
+{
+  uint32_t tmpreg = 0;
+  /* Check the parameters */
+  assert_param(IS_RCC_ADCCLK(RCC_PCLK2));
+  tmpreg = RCC-&gt;CFGR;
+  /* Clear ADCPRE[1:0] bits */
+  tmpreg &amp;= CFGR_ADCPRE_Reset_Mask;
+  /* Set ADCPRE[1:0] bits according to RCC_PCLK2 value */
+  tmpreg |= RCC_PCLK2;
+  /* Store the new value */
+  RCC-&gt;CFGR = tmpreg;
+}
+
+#ifdef STM32F10X_CL
+/**
+  * @brief  Configures the I2S2 clock source(I2S2CLK).
+  * @note
+  *   - This function must be called before enabling I2S2 APB clock.
+  *   - This function applies only to STM32 Connectivity line devices.
+  * @param  RCC_I2S2CLKSource: specifies the I2S2 clock source.
+  *   This parameter can be one of the following values:
+  *     @arg RCC_I2S2CLKSource_SYSCLK: system clock selected as I2S2 clock entry
+  *     @arg RCC_I2S2CLKSource_PLL3_VCO: PLL3 VCO clock selected as I2S2 clock entry
+  * @retval None
+  */
+void RCC_I2S2CLKConfig(uint32_t RCC_I2S2CLKSource)
+{
+  /* Check the parameters */
+  assert_param(IS_RCC_I2S2CLK_SOURCE(RCC_I2S2CLKSource));
+
+  *(__IO uint32_t *) CFGR2_I2S2SRC_BB = RCC_I2S2CLKSource;
+}
+
+/**
+  * @brief  Configures the I2S3 clock source(I2S2CLK).
+  * @note
+  *   - This function must be called before enabling I2S3 APB clock.
+  *   - This function applies only to STM32 Connectivity line devices.
+  * @param  RCC_I2S3CLKSource: specifies the I2S3 clock source.
+  *   This parameter can be one of the following values:
+  *     @arg RCC_I2S3CLKSource_SYSCLK: system clock selected as I2S3 clock entry
+  *     @arg RCC_I2S3CLKSource_PLL3_VCO: PLL3 VCO clock selected as I2S3 clock entry
+  * @retval None
+  */
+void RCC_I2S3CLKConfig(uint32_t RCC_I2S3CLKSource)
+{
+  /* Check the parameters */
+  assert_param(IS_RCC_I2S3CLK_SOURCE(RCC_I2S3CLKSource));
+
+  *(__IO uint32_t *) CFGR2_I2S3SRC_BB = RCC_I2S3CLKSource;
+}
+#endif /* STM32F10X_CL */
+
+/**
+  * @brief  Configures the External Low Speed oscillator (LSE).
+  * @param  RCC_LSE: specifies the new state of the LSE.
+  *   This parameter can be one of the following values:
+  *     @arg RCC_LSE_OFF: LSE oscillator OFF
+  *     @arg RCC_LSE_ON: LSE oscillator ON
+  *     @arg RCC_LSE_Bypass: LSE oscillator bypassed with external clock
+  * @retval None
+  */
+void RCC_LSEConfig(uint8_t RCC_LSE)
+{
+  /* Check the parameters */
+  assert_param(IS_RCC_LSE(RCC_LSE));
+  /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
+  /* Reset LSEON bit */
+  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
+  /* Reset LSEBYP bit */
+  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
+  /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
+  switch(RCC_LSE)
+  {
+    case RCC_LSE_ON:
+      /* Set LSEON bit */
+      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_ON;
+      break;
+      
+    case RCC_LSE_Bypass:
+      /* Set LSEBYP and LSEON bits */
+      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;
+      break;            
+      
+    default:
+      break;      
+  }
+}
+
+/**
+  * @brief  Enables or disables the Internal Low Speed oscillator (LSI).
+  * @note   LSI can not be disabled if the IWDG is running.
+  * @param  NewState: new state of the LSI. This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void RCC_LSICmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  *(__IO uint32_t *) CSR_LSION_BB = (uint32_t)NewState;
+}
+
+/**
+  * @brief  Configures the RTC clock (RTCCLK).
+  * @note   Once the RTC clock is selected it can&#146;t be changed unless the Backup domain is reset.
+  * @param  RCC_RTCCLKSource: specifies the RTC clock source.
+  *   This parameter can be one of the following values:
+  *     @arg RCC_RTCCLKSource_LSE: LSE selected as RTC clock
+  *     @arg RCC_RTCCLKSource_LSI: LSI selected as RTC clock
+  *     @arg RCC_RTCCLKSource_HSE_Div128: HSE clock divided by 128 selected as RTC clock
+  * @retval None
+  */
+void RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource)
+{
+  /* Check the parameters */
+  assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));
+  /* Select the RTC clock source */
+  RCC-&gt;BDCR |= RCC_RTCCLKSource;
+}
+
+/**
+  * @brief  Enables or disables the RTC clock.
+  * @note   This function must be used only after the RTC clock was selected using the RCC_RTCCLKConfig function.
+  * @param  NewState: new state of the RTC clock. This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void RCC_RTCCLKCmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  *(__IO uint32_t *) BDCR_RTCEN_BB = (uint32_t)NewState;
+}
+
+/**
+  * @brief  Returns the frequencies of different on chip clocks.
+  * @param  RCC_Clocks: pointer to a RCC_ClocksTypeDef structure which will hold
+  *   the clocks frequencies.
+  * @retval None
+  */
+void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
+{
+  uint32_t tmp = 0, pllmull = 0, pllsource = 0, presc = 0;
+
+#ifdef  STM32F10X_CL
+  uint32_t prediv1source = 0, prediv1factor = 0, prediv2factor = 0, pll2mull = 0;
+#endif /* STM32F10X_CL */
+    
+  /* Get SYSCLK source -------------------------------------------------------*/
+  tmp = RCC-&gt;CFGR &amp; CFGR_SWS_Mask;
+  
+  switch (tmp)
+  {
+    case 0x00:  /* HSI used as system clock */
+      RCC_Clocks-&gt;SYSCLK_Frequency = HSI_Value;
+      break;
+    case 0x04:  /* HSE used as system clock */
+      RCC_Clocks-&gt;SYSCLK_Frequency = HSE_Value;
+      break;
+    case 0x08:  /* PLL used as system clock */
+
+      /* Get PLL clock source and multiplication factor ----------------------*/
+      pllmull = RCC-&gt;CFGR &amp; CFGR_PLLMull_Mask;
+      pllsource = RCC-&gt;CFGR &amp; CFGR_PLLSRC_Mask;
+      
+#ifndef STM32F10X_CL      
+      pllmull = ( pllmull &gt;&gt; 18) + 2;
+      
+      if (pllsource == 0x00)
+      {/* HSI oscillator clock divided by 2 selected as PLL clock entry */
+        RCC_Clocks-&gt;SYSCLK_Frequency = (HSI_Value &gt;&gt; 1) * pllmull;
+      }
+      else
+      {/* HSE selected as PLL clock entry */
+        if ((RCC-&gt;CFGR &amp; CFGR_PLLXTPRE_Mask) != (uint32_t)RESET)
+        {/* HSE oscillator clock divided by 2 */
+          RCC_Clocks-&gt;SYSCLK_Frequency = (HSE_Value &gt;&gt; 1) * pllmull;
+        }
+        else
+        {
+          RCC_Clocks-&gt;SYSCLK_Frequency = HSE_Value * pllmull;
+        }
+      }
+#else
+      pllmull = pllmull &gt;&gt; 18;
+      
+      if (pllmull != 0x0D)
+      {
+         pllmull += 2;
+      }
+      else
+      { /* PLL multiplication factor = PLL input clock * 6.5 */
+        pllmull = 13 / 2; 
+      }
+            
+      if (pllsource == 0x00)
+      {/* HSI oscillator clock divided by 2 selected as PLL clock entry */
+        RCC_Clocks-&gt;SYSCLK_Frequency = (HSI_Value &gt;&gt; 1) * pllmull;
+      }
+      else
+      {/* PREDIV1 selected as PLL clock entry */
+        
+        /* Get PREDIV1 clock source and division factor */
+        prediv1source = RCC-&gt;CFGR2 &amp; CFGR2_PREDIV1SRC;
+        prediv1factor = (RCC-&gt;CFGR2 &amp; CFGR2_PREDIV1) + 1;
+        
+        if (prediv1source == 0)
+        { /* HSE oscillator clock selected as PREDIV1 clock entry */
+          RCC_Clocks-&gt;SYSCLK_Frequency = (HSE_Value / prediv1factor) * pllmull;          
+        }
+        else
+        {/* PLL2 clock selected as PREDIV1 clock entry */
+          
+          /* Get PREDIV2 division factor and PLL2 multiplication factor */
+          prediv2factor = ((RCC-&gt;CFGR2 &amp; CFGR2_PREDIV2) &gt;&gt; 4) + 1;
+          pll2mull = ((RCC-&gt;CFGR2 &amp; CFGR2_PLL2MUL) &gt;&gt; 8 ) + 2; 
+          RCC_Clocks-&gt;SYSCLK_Frequency = (((HSE_Value / prediv2factor) * pll2mull) / prediv1factor) * pllmull;                         
+        }
+      }
+#endif /* STM32F10X_CL */ 
+      break;
+
+    default:
+      RCC_Clocks-&gt;SYSCLK_Frequency = HSI_Value;
+      break;
+  }
+
+  /* Compute HCLK, PCLK1, PCLK2 and ADCCLK clocks frequencies ----------------*/
+  /* Get HCLK prescaler */
+  tmp = RCC-&gt;CFGR &amp; CFGR_HPRE_Set_Mask;
+  tmp = tmp &gt;&gt; 4;
+  presc = APBAHBPrescTable[tmp];
+  /* HCLK clock frequency */
+  RCC_Clocks-&gt;HCLK_Frequency = RCC_Clocks-&gt;SYSCLK_Frequency &gt;&gt; presc;
+  /* Get PCLK1 prescaler */
+  tmp = RCC-&gt;CFGR &amp; CFGR_PPRE1_Set_Mask;
+  tmp = tmp &gt;&gt; 8;
+  presc = APBAHBPrescTable[tmp];
+  /* PCLK1 clock frequency */
+  RCC_Clocks-&gt;PCLK1_Frequency = RCC_Clocks-&gt;HCLK_Frequency &gt;&gt; presc;
+  /* Get PCLK2 prescaler */
+  tmp = RCC-&gt;CFGR &amp; CFGR_PPRE2_Set_Mask;
+  tmp = tmp &gt;&gt; 11;
+  presc = APBAHBPrescTable[tmp];
+  /* PCLK2 clock frequency */
+  RCC_Clocks-&gt;PCLK2_Frequency = RCC_Clocks-&gt;HCLK_Frequency &gt;&gt; presc;
+  /* Get ADCCLK prescaler */
+  tmp = RCC-&gt;CFGR &amp; CFGR_ADCPRE_Set_Mask;
+  tmp = tmp &gt;&gt; 14;
+  presc = ADCPrescTable[tmp];
+  /* ADCCLK clock frequency */
+  RCC_Clocks-&gt;ADCCLK_Frequency = RCC_Clocks-&gt;PCLK2_Frequency / presc;
+}
+
+/**
+  * @brief  Enables or disables the AHB peripheral clock.
+  * @param  RCC_AHBPeriph: specifies the AHB peripheral to gates its clock.
+  *   
+  *   For @b STM32_Connectivity_line_devices, this parameter can be any combination
+  *   of the following values:        
+  *     @arg RCC_AHBPeriph_DMA1
+  *     @arg RCC_AHBPeriph_DMA2
+  *     @arg RCC_AHBPeriph_SRAM
+  *     @arg RCC_AHBPeriph_FLITF
+  *     @arg RCC_AHBPeriph_CRC
+  *     @arg RCC_AHBPeriph_OTG_FS    
+  *     @arg RCC_AHBPeriph_ETH_MAC   
+  *     @arg RCC_AHBPeriph_ETH_MAC_Tx
+  *     @arg RCC_AHBPeriph_ETH_MAC_Rx
+  * 
+  *   For @b other_STM32_devices, this parameter can be any combination of the 
+  *   following values:        
+  *     @arg RCC_AHBPeriph_DMA1
+  *     @arg RCC_AHBPeriph_DMA2
+  *     @arg RCC_AHBPeriph_SRAM
+  *     @arg RCC_AHBPeriph_FLITF
+  *     @arg RCC_AHBPeriph_CRC
+  *     @arg RCC_AHBPeriph_FSMC
+  *     @arg RCC_AHBPeriph_SDIO
+  *   
+  * @note SRAM and FLITF clock can be disabled only during sleep mode.
+  * @param  NewState: new state of the specified peripheral clock.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    RCC-&gt;AHBENR |= RCC_AHBPeriph;
+  }
+  else
+  {
+    RCC-&gt;AHBENR &amp;= ~RCC_AHBPeriph;
+  }
+}
+
+/**
+  * @brief  Enables or disables the High Speed APB (APB2) peripheral clock.
+  * @param  RCC_APB2Periph: specifies the APB2 peripheral to gates its clock.
+  *   This parameter can be any combination of the following values:
+  *     @arg RCC_APB2Periph_AFIO, RCC_APB2Periph_GPIOA, RCC_APB2Periph_GPIOB,
+  *          RCC_APB2Periph_GPIOC, RCC_APB2Periph_GPIOD, RCC_APB2Periph_GPIOE,
+  *          RCC_APB2Periph_GPIOF, RCC_APB2Periph_GPIOG, RCC_APB2Periph_ADC1,
+  *          RCC_APB2Periph_ADC2, RCC_APB2Periph_TIM1, RCC_APB2Periph_SPI1,
+  *          RCC_APB2Periph_TIM8, RCC_APB2Periph_USART1, RCC_APB2Periph_ADC3
+  * @param  NewState: new state of the specified peripheral clock.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    RCC-&gt;APB2ENR |= RCC_APB2Periph;
+  }
+  else
+  {
+    RCC-&gt;APB2ENR &amp;= ~RCC_APB2Periph;
+  }
+}
+
+/**
+  * @brief  Enables or disables the Low Speed APB (APB1) peripheral clock.
+  * @param  RCC_APB1Periph: specifies the APB1 peripheral to gates its clock.
+  *   This parameter can be any combination of the following values:
+  *     @arg RCC_APB1Periph_TIM2, RCC_APB1Periph_TIM3, RCC_APB1Periph_TIM4,
+  *          RCC_APB1Periph_TIM5, RCC_APB1Periph_TIM6, RCC_APB1Periph_TIM7,
+  *          RCC_APB1Periph_WWDG, RCC_APB1Periph_SPI2, RCC_APB1Periph_SPI3,
+  *          RCC_APB1Periph_USART2, RCC_APB1Periph_USART3, RCC_APB1Periph_USART4, 
+  *          RCC_APB1Periph_USART5, RCC_APB1Periph_I2C1, RCC_APB1Periph_I2C2,
+  *          RCC_APB1Periph_USB, RCC_APB1Periph_CAN1, RCC_APB1Periph_BKP,
+  *          RCC_APB1Periph_PWR, RCC_APB1Periph_DAC
+  * @param  NewState: new state of the specified peripheral clock.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    RCC-&gt;APB1ENR |= RCC_APB1Periph;
+  }
+  else
+  {
+    RCC-&gt;APB1ENR &amp;= ~RCC_APB1Periph;
+  }
+}
+
+#ifdef STM32F10X_CL
+/**
+  * @brief  Forces or releases AHB peripheral reset.
+  * @note   This function applies only to STM32 Connectivity line devices.
+  * @param  RCC_AHBPeriph: specifies the AHB peripheral to reset.
+  *   This parameter can be any combination of the following values:
+  *     @arg RCC_AHBPeriph_OTG_FS 
+  *     @arg RCC_AHBPeriph_ETH_MAC
+  * @param  NewState: new state of the specified peripheral reset.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void RCC_AHBPeriphResetCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_RCC_AHB_PERIPH_RESET(RCC_AHBPeriph));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    RCC-&gt;AHBRSTR |= RCC_AHBPeriph;
+  }
+  else
+  {
+    RCC-&gt;AHBRSTR &amp;= ~RCC_AHBPeriph;
+  }
+}
+#endif /* STM32F10X_CL */ 
+
+/**
+  * @brief  Forces or releases High Speed APB (APB2) peripheral reset.
+  * @param  RCC_APB2Periph: specifies the APB2 peripheral to reset.
+  *   This parameter can be any combination of the following values:
+  *     @arg RCC_APB2Periph_AFIO, RCC_APB2Periph_GPIOA, RCC_APB2Periph_GPIOB,
+  *          RCC_APB2Periph_GPIOC, RCC_APB2Periph_GPIOD, RCC_APB2Periph_GPIOE,
+  *          RCC_APB2Periph_GPIOF, RCC_APB2Periph_GPIOG, RCC_APB2Periph_ADC1,
+  *          RCC_APB2Periph_ADC2, RCC_APB2Periph_TIM1, RCC_APB2Periph_SPI1,
+  *          RCC_APB2Periph_TIM8, RCC_APB2Periph_USART1, RCC_APB2Periph_ADC3
+  * @param  NewState: new state of the specified peripheral reset.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    RCC-&gt;APB2RSTR |= RCC_APB2Periph;
+  }
+  else
+  {
+    RCC-&gt;APB2RSTR &amp;= ~RCC_APB2Periph;
+  }
+}
+
+/**
+  * @brief  Forces or releases Low Speed APB (APB1) peripheral reset.
+  * @param  RCC_APB1Periph: specifies the APB1 peripheral to reset.
+  *   This parameter can be any combination of the following values:
+  *     @arg RCC_APB1Periph_TIM2, RCC_APB1Periph_TIM3, RCC_APB1Periph_TIM4,
+  *          RCC_APB1Periph_TIM5, RCC_APB1Periph_TIM6, RCC_APB1Periph_TIM7,
+  *          RCC_APB1Periph_WWDG, RCC_APB1Periph_SPI2, RCC_APB1Periph_SPI3,
+  *          RCC_APB1Periph_USART2, RCC_APB1Periph_USART3, RCC_APB1Periph_USART4, 
+  *          RCC_APB1Periph_USART5, RCC_APB1Periph_I2C1, RCC_APB1Periph_I2C2,
+  *          RCC_APB1Periph_USB, RCC_APB1Periph_CAN1, RCC_APB1Periph_BKP,
+  *          RCC_APB1Periph_PWR, RCC_APB1Periph_DAC
+  * @param  NewState: new state of the specified peripheral clock.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    RCC-&gt;APB1RSTR |= RCC_APB1Periph;
+  }
+  else
+  {
+    RCC-&gt;APB1RSTR &amp;= ~RCC_APB1Periph;
+  }
+}
+
+/**
+  * @brief  Forces or releases the Backup domain reset.
+  * @param  NewState: new state of the Backup domain reset.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void RCC_BackupResetCmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  *(__IO uint32_t *) BDCR_BDRST_BB = (uint32_t)NewState;
+}
+
+/**
+  * @brief  Enables or disables the Clock Security System.
+  * @param  NewState: new state of the Clock Security System..
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  *(__IO uint32_t *) CR_CSSON_BB = (uint32_t)NewState;
+}
+
+/**
+  * @brief  Selects the clock source to output on MCO pin.
+  * @param  RCC_MCO: specifies the clock source to output.
+  *   
+  *   For @b STM32_Connectivity_line_devices, this parameter can be one of the
+  *   following values:       
+  *     @arg RCC_MCO_NoClock: No clock selected
+  *     @arg RCC_MCO_SYSCLK: System clock selected
+  *     @arg RCC_MCO_HSI: HSI oscillator clock selected
+  *     @arg RCC_MCO_HSE: HSE oscillator clock selected
+  *     @arg RCC_MCO_PLLCLK_Div2: PLL clock divided by 2 selected
+  *     @arg RCC_MCO_PLL2CLK: PLL2 clock selected                     
+  *     @arg RCC_MCO_PLL3CLK_Div2: PLL3 clock divided by 2 selected   
+  *     @arg RCC_MCO_XT1: External 3-25 MHz oscillator clock selected  
+  *     @arg RCC_MCO_PLL3CLK: PLL3 clock selected 
+  * 
+  *   For  @b other_STM32_devices, this parameter can be one of the following values:        
+  *     @arg RCC_MCO_NoClock: No clock selected
+  *     @arg RCC_MCO_SYSCLK: System clock selected
+  *     @arg RCC_MCO_HSI: HSI oscillator clock selected
+  *     @arg RCC_MCO_HSE: HSE oscillator clock selected
+  *     @arg RCC_MCO_PLLCLK_Div2: PLL clock divided by 2 selected
+  *   
+  * @retval None
+  */
+void RCC_MCOConfig(uint8_t RCC_MCO)
+{
+  /* Check the parameters */
+  assert_param(IS_RCC_MCO(RCC_MCO));
+
+  /* Perform Byte access to MCO bits to select the MCO source */
+  *(__IO uint8_t *) CFGR_BYTE4_ADDRESS = RCC_MCO;
+}
+
+/**
+  * @brief  Checks whether the specified RCC flag is set or not.
+  * @param  RCC_FLAG: specifies the flag to check.
+  *   
+  *   For @b STM32_Connectivity_line_devices, this parameter can be one of the
+  *   following values:
+  *     @arg RCC_FLAG_HSIRDY: HSI oscillator clock ready
+  *     @arg RCC_FLAG_HSERDY: HSE oscillator clock ready
+  *     @arg RCC_FLAG_PLLRDY: PLL clock ready
+  *     @arg RCC_FLAG_PLL2RDY: PLL2 clock ready      
+  *     @arg RCC_FLAG_PLL3RDY: PLL3 clock ready                           
+  *     @arg RCC_FLAG_LSERDY: LSE oscillator clock ready
+  *     @arg RCC_FLAG_LSIRDY: LSI oscillator clock ready
+  *     @arg RCC_FLAG_PINRST: Pin reset
+  *     @arg RCC_FLAG_PORRST: POR/PDR reset
+  *     @arg RCC_FLAG_SFTRST: Software reset
+  *     @arg RCC_FLAG_IWDGRST: Independent Watchdog reset
+  *     @arg RCC_FLAG_WWDGRST: Window Watchdog reset
+  *     @arg RCC_FLAG_LPWRRST: Low Power reset
+  * 
+  *   For @b other_STM32_devices, this parameter can be one of the following values:        
+  *     @arg RCC_FLAG_HSIRDY: HSI oscillator clock ready
+  *     @arg RCC_FLAG_HSERDY: HSE oscillator clock ready
+  *     @arg RCC_FLAG_PLLRDY: PLL clock ready
+  *     @arg RCC_FLAG_LSERDY: LSE oscillator clock ready
+  *     @arg RCC_FLAG_LSIRDY: LSI oscillator clock ready
+  *     @arg RCC_FLAG_PINRST: Pin reset
+  *     @arg RCC_FLAG_PORRST: POR/PDR reset
+  *     @arg RCC_FLAG_SFTRST: Software reset
+  *     @arg RCC_FLAG_IWDGRST: Independent Watchdog reset
+  *     @arg RCC_FLAG_WWDGRST: Window Watchdog reset
+  *     @arg RCC_FLAG_LPWRRST: Low Power reset
+  *   
+  * @retval The new state of RCC_FLAG (SET or RESET).
+  */
+FlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG)
+{
+  uint32_t tmp = 0;
+  uint32_t statusreg = 0;
+  FlagStatus bitstatus = RESET;
+  /* Check the parameters */
+  assert_param(IS_RCC_FLAG(RCC_FLAG));
+
+  /* Get the RCC register index */
+  tmp = RCC_FLAG &gt;&gt; 5;
+  if (tmp == 1)               /* The flag to check is in CR register */
+  {
+    statusreg = RCC-&gt;CR;
+  }
+  else if (tmp == 2)          /* The flag to check is in BDCR register */
+  {
+    statusreg = RCC-&gt;BDCR;
+  }
+  else                       /* The flag to check is in CSR register */
+  {
+    statusreg = RCC-&gt;CSR;
+  }
+
+  /* Get the flag position */
+  tmp = RCC_FLAG &amp; FLAG_Mask;
+  if ((statusreg &amp; ((uint32_t)1 &lt;&lt; tmp)) != (uint32_t)RESET)
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+
+  /* Return the flag status */
+  return bitstatus;
+}
+
+/**
+  * @brief  Clears the RCC reset flags.
+  * @note   The reset flags are: RCC_FLAG_PINRST, RCC_FLAG_PORRST, RCC_FLAG_SFTRST,
+  *   RCC_FLAG_IWDGRST, RCC_FLAG_WWDGRST, RCC_FLAG_LPWRRST
+  * @param  None
+  * @retval None
+  */
+void RCC_ClearFlag(void)
+{
+  /* Set RMVF bit to clear the reset flags */
+  RCC-&gt;CSR |= CSR_RMVF_Set;
+}
+
+/**
+  * @brief  Checks whether the specified RCC interrupt has occurred or not.
+  * @param  RCC_IT: specifies the RCC interrupt source to check.
+  *   
+  *   For @b STM32_Connectivity_line_devices, this parameter can be one of the
+  *   following values:
+  *     @arg RCC_IT_LSIRDY: LSI ready interrupt
+  *     @arg RCC_IT_LSERDY: LSE ready interrupt
+  *     @arg RCC_IT_HSIRDY: HSI ready interrupt
+  *     @arg RCC_IT_HSERDY: HSE ready interrupt
+  *     @arg RCC_IT_PLLRDY: PLL ready interrupt
+  *     @arg RCC_IT_PLL2RDY: PLL2 ready interrupt 
+  *     @arg RCC_IT_PLL3RDY: PLL3 ready interrupt                      
+  *     @arg RCC_IT_CSS: Clock Security System interrupt
+  * 
+  *   For @b other_STM32_devices, this parameter can be one of the following values:        
+  *     @arg RCC_IT_LSIRDY: LSI ready interrupt
+  *     @arg RCC_IT_LSERDY: LSE ready interrupt
+  *     @arg RCC_IT_HSIRDY: HSI ready interrupt
+  *     @arg RCC_IT_HSERDY: HSE ready interrupt
+  *     @arg RCC_IT_PLLRDY: PLL ready interrupt
+  *     @arg RCC_IT_CSS: Clock Security System interrupt
+  *   
+  * @retval The new state of RCC_IT (SET or RESET).
+  */
+ITStatus RCC_GetITStatus(uint8_t RCC_IT)
+{
+  ITStatus bitstatus = RESET;
+  /* Check the parameters */
+  assert_param(IS_RCC_GET_IT(RCC_IT));
+
+  /* Check the status of the specified RCC interrupt */
+  if ((RCC-&gt;CIR &amp; RCC_IT) != (uint32_t)RESET)
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+
+  /* Return the RCC_IT status */
+  return  bitstatus;
+}
+
+/**
+  * @brief  Clears the RCC&#146;s interrupt pending bits.
+  * @param  RCC_IT: specifies the interrupt pending bit to clear.
+  *   
+  *   For @b STM32_Connectivity_line_devices, this parameter can be any combination
+  *   of the following values:
+  *     @arg RCC_IT_LSIRDY: LSI ready interrupt
+  *     @arg RCC_IT_LSERDY: LSE ready interrupt
+  *     @arg RCC_IT_HSIRDY: HSI ready interrupt
+  *     @arg RCC_IT_HSERDY: HSE ready interrupt
+  *     @arg RCC_IT_PLLRDY: PLL ready interrupt
+  *     @arg RCC_IT_PLL2RDY: PLL2 ready interrupt 
+  *     @arg RCC_IT_PLL3RDY: PLL3 ready interrupt                      
+  *     @arg RCC_IT_CSS: Clock Security System interrupt
+  * 
+  *   For @b other_STM32_devices, this parameter can be any combination of the
+  *   following values:        
+  *     @arg RCC_IT_LSIRDY: LSI ready interrupt
+  *     @arg RCC_IT_LSERDY: LSE ready interrupt
+  *     @arg RCC_IT_HSIRDY: HSI ready interrupt
+  *     @arg RCC_IT_HSERDY: HSE ready interrupt
+  *     @arg RCC_IT_PLLRDY: PLL ready interrupt
+  *   
+  *     @arg RCC_IT_CSS: Clock Security System interrupt
+  * @retval None
+  */
+void RCC_ClearITPendingBit(uint8_t RCC_IT)
+{
+  /* Check the parameters */
+  assert_param(IS_RCC_CLEAR_IT(RCC_IT));
+
+  /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
+     pending bits */
+  *(__IO uint8_t *) CIR_BYTE3_ADDRESS = RCC_IT;
+}
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2009 STMicroelectronics *****END OF FILE****/

Added: trunk/src/platform/stm32/FWLib/library/src/stm32f10x_rcc.o
===================================================================
--- trunk/src/platform/stm32/FWLib/library/src/stm32f10x_rcc.o	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/src/stm32f10x_rcc.o	2009-07-08 23:39:34 UTC (rev 354)
@@ -0,0 +1,10 @@
+ELF
+@
+M	

+
+
+
+
+
+&#135;
+&#135;
\ No newline at end of file

Modified: trunk/src/platform/stm32/FWLib/library/src/stm32f10x_rtc.c
===================================================================
--- trunk/src/platform/stm32/FWLib/library/src/stm32f10x_rtc.c	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/src/stm32f10x_rtc.c	2009-07-08 23:39:34 UTC (rev 354)
@@ -1,320 +1,341 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_rtc.c
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file provides all the RTC firmware functions.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
-
-/* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_rtc.h&quot;
-
-/* Private typedef -----------------------------------------------------------*/
-/* Private define ------------------------------------------------------------*/
-#define CRL_CNF_Set      ((u16)0x0010)      /* Configuration Flag Enable Mask */
-#define CRL_CNF_Reset    ((u16)0xFFEF)      /* Configuration Flag Disable Mask */
-#define RTC_LSB_Mask     ((u32)0x0000FFFF)  /* RTC LSB Mask */
-#define PRLH_MSB_Mask    ((u32)0x000F0000)  /* RTC Prescaler MSB Mask */
-
-/* Private macro -------------------------------------------------------------*/
-/* Private variables ---------------------------------------------------------*/
-/* Private function prototypes -----------------------------------------------*/
-/* Private functions ---------------------------------------------------------*/
-
-/*******************************************************************************
-* Function Name  : RTC_ITConfig
-* Description    : Enables or disables the specified RTC interrupts.
-* Input          : - RTC_IT: specifies the RTC interrupts sources to be enabled
-*                    or disabled.
-*                    This parameter can be any combination of the following values:
-*                       - RTC_IT_OW: Overflow interrupt
-*                       - RTC_IT_ALR: Alarm interrupt
-*                       - RTC_IT_SEC: Second interrupt
-*                  - NewState: new state of the specified RTC interrupts.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RTC_ITConfig(u16 RTC_IT, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_RTC_IT(RTC_IT));  
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  
-  if (NewState != DISABLE)
-  {
-    RTC-&gt;CRH |= RTC_IT;
-  }
-  else
-  {
-    RTC-&gt;CRH &amp;= (u16)~RTC_IT;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : RTC_EnterConfigMode
-* Description    : Enters the RTC configuration mode.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RTC_EnterConfigMode(void)
-{
-  /* Set the CNF flag to enter in the Configuration Mode */
-  RTC-&gt;CRL |= CRL_CNF_Set;
-}
-
-/*******************************************************************************
-* Function Name  : RTC_ExitConfigMode
-* Description    : Exits from the RTC configuration mode.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RTC_ExitConfigMode(void)
-{
-  /* Reset the CNF flag to exit from the Configuration Mode */
-  RTC-&gt;CRL &amp;= CRL_CNF_Reset;
-}
-
-/*******************************************************************************
-* Function Name  : RTC_GetCounter
-* Description    : Gets the RTC counter value.
-* Input          : None
-* Output         : None
-* Return         : RTC counter value.
-*******************************************************************************/
-u32 RTC_GetCounter(void)
-{
-  u16 tmp = 0;
-  tmp = RTC-&gt;CNTL;
-
-  return (((u32)RTC-&gt;CNTH &lt;&lt; 16 ) | tmp) ;
-}
-
-/*******************************************************************************
-* Function Name  : RTC_SetCounter
-* Description    : Sets the RTC counter value.
-* Input          : - CounterValue: RTC counter new value.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RTC_SetCounter(u32 CounterValue)
-{ 
-  RTC_EnterConfigMode();
-
-  /* Set RTC COUNTER MSB word */
-  RTC-&gt;CNTH = CounterValue &gt;&gt; 16;
-  /* Set RTC COUNTER LSB word */
-  RTC-&gt;CNTL = (CounterValue &amp; RTC_LSB_Mask);
-
-  RTC_ExitConfigMode();
-}
-
-/*******************************************************************************
-* Function Name  : RTC_SetPrescaler
-* Description    : Sets the RTC prescaler value.
-* Input          : - PrescalerValue: RTC prescaler new value.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RTC_SetPrescaler(u32 PrescalerValue)
-{
-  /* Check the parameters */
-  assert_param(IS_RTC_PRESCALER(PrescalerValue));
-  
-  RTC_EnterConfigMode();
-
-  /* Set RTC PRESCALER MSB word */
-  RTC-&gt;PRLH = (PrescalerValue &amp; PRLH_MSB_Mask) &gt;&gt; 16;
-  /* Set RTC PRESCALER LSB word */
-  RTC-&gt;PRLL = (PrescalerValue &amp; RTC_LSB_Mask);
-
-  RTC_ExitConfigMode();
-}
-
-/*******************************************************************************
-* Function Name  : RTC_SetAlarm
-* Description    : Sets the RTC alarm value.
-* Input          : - AlarmValue: RTC alarm new value.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RTC_SetAlarm(u32 AlarmValue)
-{  
-  RTC_EnterConfigMode();
-
-  /* Set the ALARM MSB word */
-  RTC-&gt;ALRH = AlarmValue &gt;&gt; 16;
-  /* Set the ALARM LSB word */
-  RTC-&gt;ALRL = (AlarmValue &amp; RTC_LSB_Mask);
-
-  RTC_ExitConfigMode();
-}
-
-/*******************************************************************************
-* Function Name  : RTC_GetDivider
-* Description    : Gets the RTC divider value.
-* Input          : None
-* Output         : None
-* Return         : RTC Divider value.
-*******************************************************************************/
-u32 RTC_GetDivider(void)
-{
-  u32 tmp = 0x00;
-
-  tmp = ((u32)RTC-&gt;DIVH &amp; (u32)0x000F) &lt;&lt; 16;
-  tmp |= RTC-&gt;DIVL;
-
-  return tmp;
-}
-
-/*******************************************************************************
-* Function Name  : RTC_WaitForLastTask
-* Description    : Waits until last write operation on RTC registers has finished.
-*                  This function must be called before any write to RTC registers.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RTC_WaitForLastTask(void)
-{
-  /* Loop until RTOFF flag is set */
-  while ((RTC-&gt;CRL &amp; RTC_FLAG_RTOFF) == (u16)RESET)
-  {
-  }
-}
-
-/*******************************************************************************
-* Function Name  : RTC_WaitForSynchro
-* Description    : Waits until the RTC registers (RTC_CNT, RTC_ALR and RTC_PRL)
-*                  are synchronized with RTC APB clock.
-*                  This function must be called before any read operation after
-*                  an APB reset or an APB clock stop.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RTC_WaitForSynchro(void)
-{
-  /* Clear RSF flag */
-  RTC-&gt;CRL &amp;= (u16)~RTC_FLAG_RSF;
-
-  /* Loop until RSF flag is set */
-  while ((RTC-&gt;CRL &amp; RTC_FLAG_RSF) == (u16)RESET)
-  {
-  }
-}
-
-/*******************************************************************************
-* Function Name  : RTC_GetFlagStatus
-* Description    : Checks whether the specified RTC flag is set or not.
-* Input          : - RTC_FLAG: specifies the flag to check.
-*                    This parameter can be one the following values:
-*                       - RTC_FLAG_RTOFF: RTC Operation OFF flag
-*                       - RTC_FLAG_RSF: Registers Synchronized flag
-*                       - RTC_FLAG_OW: Overflow flag
-*                       - RTC_FLAG_ALR: Alarm flag
-*                       - RTC_FLAG_SEC: Second flag
-* Output         : None
-* Return         : The new state of RTC_FLAG (SET or RESET).
-*******************************************************************************/
-FlagStatus RTC_GetFlagStatus(u16 RTC_FLAG)
-{
-  FlagStatus bitstatus = RESET;
-  
-  /* Check the parameters */
-  assert_param(IS_RTC_GET_FLAG(RTC_FLAG)); 
-  
-  if ((RTC-&gt;CRL &amp; RTC_FLAG) != (u16)RESET)
-  {
-    bitstatus = SET;
-  }
-  else
-  {
-    bitstatus = RESET;
-  }
-  return bitstatus;
-}
-
-/*******************************************************************************
-* Function Name  : RTC_ClearFlag
-* Description    : Clears the RTC's pending flags.
-* Input          : - RTC_FLAG: specifies the flag to clear.
-*                    This parameter can be any combination of the following values:
-*                       - RTC_FLAG_RSF: Registers Synchronized flag. This flag
-*                         is cleared only after an APB reset or an APB Clock stop.
-*                       - RTC_FLAG_OW: Overflow flag
-*                       - RTC_FLAG_ALR: Alarm flag
-*                       - RTC_FLAG_SEC: Second flag
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RTC_ClearFlag(u16 RTC_FLAG)
-{
-  /* Check the parameters */
-  assert_param(IS_RTC_CLEAR_FLAG(RTC_FLAG)); 
-    
-  /* Clear the coressponding RTC flag */
-  RTC-&gt;CRL &amp;= (u16)~RTC_FLAG;
-}
-
-/*******************************************************************************
-* Function Name  : RTC_GetITStatus
-* Description    : Checks whether the specified RTC interrupt has occured or not.
-* Input          : - RTC_IT: specifies the RTC interrupts sources to check.
-*                    This parameter can be one of the following values:
-*                       - RTC_IT_OW: Overflow interrupt
-*                       - RTC_IT_ALR: Alarm interrupt
-*                       - RTC_IT_SEC: Second interrupt
-* Output         : None
-* Return         : The new state of the RTC_IT (SET or RESET).
-*******************************************************************************/
-ITStatus RTC_GetITStatus(u16 RTC_IT)
-{
-  ITStatus bitstatus = RESET;
-
-  /* Check the parameters */
-  assert_param(IS_RTC_GET_IT(RTC_IT)); 
-  
-  bitstatus = (ITStatus)(RTC-&gt;CRL &amp; RTC_IT);
-
-  if (((RTC-&gt;CRH &amp; RTC_IT) != (u16)RESET) &amp;&amp; (bitstatus != (u16)RESET))
-  {
-    bitstatus = SET;
-  }
-  else
-  {
-    bitstatus = RESET;
-  }
-  return bitstatus;
-}
-
-/*******************************************************************************
-* Function Name  : RTC_ClearITPendingBit
-* Description    : Clears the RTC's interrupt pending bits.
-* Input          : - RTC_IT: specifies the interrupt pending bit to clear.
-*                    This parameter can be any combination of the following values:
-*                       - RTC_IT_OW: Overflow interrupt
-*                       - RTC_IT_ALR: Alarm interrupt
-*                       - RTC_IT_SEC: Second interrupt
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RTC_ClearITPendingBit(u16 RTC_IT)
-{
-  /* Check the parameters */
-  assert_param(IS_RTC_IT(RTC_IT));  
-  
-  /* Clear the coressponding RTC pending bit */
-  RTC-&gt;CRL &amp;= (u16)~RTC_IT;
-}
-
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
+/**
+  ******************************************************************************
+  * @file    stm32f10x_rtc.c
+  * @author  MCD Application Team
+  * @version V3.1.0
+  * @date    06/19/2009
+  * @brief   This file provides all the RTC firmware functions.
+  ******************************************************************************
+  * @copy
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * &lt;h2&gt;&lt;center&gt;&copy; COPYRIGHT 2009 STMicroelectronics&lt;/center&gt;&lt;/h2&gt;
+  */ 
+
+/* Includes ------------------------------------------------------------------*/
+#include &quot;stm32f10x_rtc.h&quot;
+
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup RTC 
+  * @brief RTC driver modules
+  * @{
+  */
+
+/** @defgroup RTC_Private_TypesDefinitions
+  * @{
+  */ 
+/**
+  * @}
+  */
+
+/** @defgroup RTC_Private_Defines
+  * @{
+  */
+
+#define CRL_CNF_Set      ((uint16_t)0x0010)      /*!&lt; Configuration Flag Enable Mask */
+#define CRL_CNF_Reset    ((uint16_t)0xFFEF)      /*!&lt; Configuration Flag Disable Mask */
+#define RTC_LSB_Mask     ((uint32_t)0x0000FFFF)  /*!&lt; RTC LSB Mask */
+#define PRLH_MSB_Mask    ((uint32_t)0x000F0000)  /*!&lt; RTC Prescaler MSB Mask */
+
+/**
+  * @}
+  */
+
+/** @defgroup RTC_Private_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup RTC_Private_Variables
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup RTC_Private_FunctionPrototypes
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup RTC_Private_Functions
+  * @{
+  */
+
+/**
+  * @brief  Enables or disables the specified RTC interrupts.
+  * @param  RTC_IT: specifies the RTC interrupts sources to be enabled or disabled.
+  *   This parameter can be any combination of the following values:
+  *     @arg RTC_IT_OW: Overflow interrupt
+  *     @arg RTC_IT_ALR: Alarm interrupt
+  *     @arg RTC_IT_SEC: Second interrupt
+  * @param  NewState: new state of the specified RTC interrupts.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void RTC_ITConfig(uint16_t RTC_IT, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_RTC_IT(RTC_IT));  
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    RTC-&gt;CRH |= RTC_IT;
+  }
+  else
+  {
+    RTC-&gt;CRH &amp;= (uint16_t)~RTC_IT;
+  }
+}
+
+/**
+  * @brief  Enters the RTC configuration mode.
+  * @param  None
+  * @retval None
+  */
+void RTC_EnterConfigMode(void)
+{
+  /* Set the CNF flag to enter in the Configuration Mode */
+  RTC-&gt;CRL |= CRL_CNF_Set;
+}
+
+/**
+  * @brief  Exits from the RTC configuration mode.
+  * @param  None
+  * @retval None
+  */
+void RTC_ExitConfigMode(void)
+{
+  /* Reset the CNF flag to exit from the Configuration Mode */
+  RTC-&gt;CRL &amp;= CRL_CNF_Reset;
+}
+
+/**
+  * @brief  Gets the RTC counter value.
+  * @param  None
+  * @retval RTC counter value.
+  */
+uint32_t RTC_GetCounter(void)
+{
+  uint16_t tmp = 0;
+  tmp = RTC-&gt;CNTL;
+  return (((uint32_t)RTC-&gt;CNTH &lt;&lt; 16 ) | tmp) ;
+}
+
+/**
+  * @brief  Sets the RTC counter value.
+  * @param  CounterValue: RTC counter new value.
+  * @retval None
+  */
+void RTC_SetCounter(uint32_t CounterValue)
+{ 
+  RTC_EnterConfigMode();
+  /* Set RTC COUNTER MSB word */
+  RTC-&gt;CNTH = CounterValue &gt;&gt; 16;
+  /* Set RTC COUNTER LSB word */
+  RTC-&gt;CNTL = (CounterValue &amp; RTC_LSB_Mask);
+  RTC_ExitConfigMode();
+}
+
+/**
+  * @brief  Sets the RTC prescaler value.
+  * @param  PrescalerValue: RTC prescaler new value.
+  * @retval None
+  */
+void RTC_SetPrescaler(uint32_t PrescalerValue)
+{
+  /* Check the parameters */
+  assert_param(IS_RTC_PRESCALER(PrescalerValue));
+  
+  RTC_EnterConfigMode();
+  /* Set RTC PRESCALER MSB word */
+  RTC-&gt;PRLH = (PrescalerValue &amp; PRLH_MSB_Mask) &gt;&gt; 16;
+  /* Set RTC PRESCALER LSB word */
+  RTC-&gt;PRLL = (PrescalerValue &amp; RTC_LSB_Mask);
+  RTC_ExitConfigMode();
+}
+
+/**
+  * @brief  Sets the RTC alarm value.
+  * @param  AlarmValue: RTC alarm new value.
+  * @retval None
+  */
+void RTC_SetAlarm(uint32_t AlarmValue)
+{  
+  RTC_EnterConfigMode();
+  /* Set the ALARM MSB word */
+  RTC-&gt;ALRH = AlarmValue &gt;&gt; 16;
+  /* Set the ALARM LSB word */
+  RTC-&gt;ALRL = (AlarmValue &amp; RTC_LSB_Mask);
+  RTC_ExitConfigMode();
+}
+
+/**
+  * @brief  Gets the RTC divider value.
+  * @param  None
+  * @retval RTC Divider value.
+  */
+uint32_t RTC_GetDivider(void)
+{
+  uint32_t tmp = 0x00;
+  tmp = ((uint32_t)RTC-&gt;DIVH &amp; (uint32_t)0x000F) &lt;&lt; 16;
+  tmp |= RTC-&gt;DIVL;
+  return tmp;
+}
+
+/**
+  * @brief  Waits until last write operation on RTC registers has finished.
+  * @note   This function must be called before any write to RTC registers.
+  * @param  None
+  * @retval None
+  */
+void RTC_WaitForLastTask(void)
+{
+  /* Loop until RTOFF flag is set */
+  while ((RTC-&gt;CRL &amp; RTC_FLAG_RTOFF) == (uint16_t)RESET)
+  {
+  }
+}
+
+/**
+  * @brief  Waits until the RTC registers (RTC_CNT, RTC_ALR and RTC_PRL)
+  *   are synchronized with RTC APB clock.
+  * @note   This function must be called before any read operation after an APB reset
+  *   or an APB clock stop.
+  * @param  None
+  * @retval None
+  */
+void RTC_WaitForSynchro(void)
+{
+  /* Clear RSF flag */
+  RTC-&gt;CRL &amp;= (uint16_t)~RTC_FLAG_RSF;
+  /* Loop until RSF flag is set */
+  while ((RTC-&gt;CRL &amp; RTC_FLAG_RSF) == (uint16_t)RESET)
+  {
+  }
+}
+
+/**
+  * @brief  Checks whether the specified RTC flag is set or not.
+  * @param  RTC_FLAG: specifies the flag to check.
+  *   This parameter can be one the following values:
+  *     @arg RTC_FLAG_RTOFF: RTC Operation OFF flag
+  *     @arg RTC_FLAG_RSF: Registers Synchronized flag
+  *     @arg RTC_FLAG_OW: Overflow flag
+  *     @arg RTC_FLAG_ALR: Alarm flag
+  *     @arg RTC_FLAG_SEC: Second flag
+  * @retval The new state of RTC_FLAG (SET or RESET).
+  */
+FlagStatus RTC_GetFlagStatus(uint16_t RTC_FLAG)
+{
+  FlagStatus bitstatus = RESET;
+  
+  /* Check the parameters */
+  assert_param(IS_RTC_GET_FLAG(RTC_FLAG)); 
+  
+  if ((RTC-&gt;CRL &amp; RTC_FLAG) != (uint16_t)RESET)
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  return bitstatus;
+}
+
+/**
+  * @brief  Clears the RTC&#146;s pending flags.
+  * @param  RTC_FLAG: specifies the flag to clear.
+  *   This parameter can be any combination of the following values:
+  *     @arg RTC_FLAG_RSF: Registers Synchronized flag. This flag is cleared only after
+  *                        an APB reset or an APB Clock stop.
+  *     @arg RTC_FLAG_OW: Overflow flag
+  *     @arg RTC_FLAG_ALR: Alarm flag
+  *     @arg RTC_FLAG_SEC: Second flag
+  * @retval None
+  */
+void RTC_ClearFlag(uint16_t RTC_FLAG)
+{
+  /* Check the parameters */
+  assert_param(IS_RTC_CLEAR_FLAG(RTC_FLAG)); 
+    
+  /* Clear the coressponding RTC flag */
+  RTC-&gt;CRL &amp;= (uint16_t)~RTC_FLAG;
+}
+
+/**
+  * @brief  Checks whether the specified RTC interrupt has occured or not.
+  * @param  RTC_IT: specifies the RTC interrupts sources to check.
+  *   This parameter can be one of the following values:
+  *     @arg RTC_IT_OW: Overflow interrupt
+  *     @arg RTC_IT_ALR: Alarm interrupt
+  *     @arg RTC_IT_SEC: Second interrupt
+  * @retval The new state of the RTC_IT (SET or RESET).
+  */
+ITStatus RTC_GetITStatus(uint16_t RTC_IT)
+{
+  ITStatus bitstatus = RESET;
+  /* Check the parameters */
+  assert_param(IS_RTC_GET_IT(RTC_IT)); 
+  
+  bitstatus = (ITStatus)(RTC-&gt;CRL &amp; RTC_IT);
+  if (((RTC-&gt;CRH &amp; RTC_IT) != (uint16_t)RESET) &amp;&amp; (bitstatus != (uint16_t)RESET))
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  return bitstatus;
+}
+
+/**
+  * @brief  Clears the RTC&#146;s interrupt pending bits.
+  * @param  RTC_IT: specifies the interrupt pending bit to clear.
+  *   This parameter can be any combination of the following values:
+  *     @arg RTC_IT_OW: Overflow interrupt
+  *     @arg RTC_IT_ALR: Alarm interrupt
+  *     @arg RTC_IT_SEC: Second interrupt
+  * @retval None
+  */
+void RTC_ClearITPendingBit(uint16_t RTC_IT)
+{
+  /* Check the parameters */
+  assert_param(IS_RTC_IT(RTC_IT));  
+  
+  /* Clear the coressponding RTC pending bit */
+  RTC-&gt;CRL &amp;= (uint16_t)~RTC_IT;
+}
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2009 STMicroelectronics *****END OF FILE****/

Added: trunk/src/platform/stm32/FWLib/library/src/stm32f10x_rtc.o
===================================================================
--- trunk/src/platform/stm32/FWLib/library/src/stm32f10x_rtc.o	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/src/stm32f10x_rtc.o	2009-07-08 23:39:34 UTC (rev 354)
@@ -0,0 +1,13 @@
+ELF
+M	
+
+
+
+
+
+2
+3
+2
+3
+2
+3
\ No newline at end of file

Modified: trunk/src/platform/stm32/FWLib/library/src/stm32f10x_sdio.c
===================================================================
--- trunk/src/platform/stm32/FWLib/library/src/stm32f10x_sdio.c	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/src/stm32f10x_sdio.c	2009-07-08 23:39:34 UTC (rev 354)
@@ -1,832 +1,798 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_sdio.c
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file provides all the SDIO firmware functions.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
-
-/* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_sdio.h&quot;
-#include &quot;stm32f10x_rcc.h&quot;
-
-/* Private typedef -----------------------------------------------------------*/
-/* ------------ SDIO registers bit address in the alias region ----------- */
-#define SDIO_OFFSET                (SDIO_BASE - PERIPH_BASE)
-
-/* --- CLKCR Register ---*/
-/* Alias word address of CLKEN bit */
-#define CLKCR_OFFSET              (SDIO_OFFSET + 0x04)
-#define CLKEN_BitNumber           0x08
-#define CLKCR_CLKEN_BB            (PERIPH_BB_BASE + (CLKCR_OFFSET * 32) + (CLKEN_BitNumber * 4))
-
-/* --- CMD Register ---*/
-/* Alias word address of SDIOSUSPEND bit */
-#define CMD_OFFSET                (SDIO_OFFSET + 0x0C)
-#define SDIOSUSPEND_BitNumber     0x0B
-#define CMD_SDIOSUSPEND_BB        (PERIPH_BB_BASE + (CMD_OFFSET * 32) + (SDIOSUSPEND_BitNumber * 4))
-
-/* Alias word address of ENCMDCOMPL bit */
-#define ENCMDCOMPL_BitNumber      0x0C
-#define CMD_ENCMDCOMPL_BB         (PERIPH_BB_BASE + (CMD_OFFSET * 32) + (ENCMDCOMPL_BitNumber * 4))
-
-/* Alias word address of NIEN bit */
-#define NIEN_BitNumber            0x0D
-#define CMD_NIEN_BB               (PERIPH_BB_BASE + (CMD_OFFSET * 32) + (NIEN_BitNumber * 4))
-
-/* Alias word address of ATACMD bit */
-#define ATACMD_BitNumber          0x0E
-#define CMD_ATACMD_BB             (PERIPH_BB_BASE + (CMD_OFFSET * 32) + (ATACMD_BitNumber * 4))
-
-/* --- DCTRL Register ---*/
-/* Alias word address of DMAEN bit */
-#define DCTRL_OFFSET              (SDIO_OFFSET + 0x2C)
-#define DMAEN_BitNumber           0x03
-#define DCTRL_DMAEN_BB            (PERIPH_BB_BASE + (DCTRL_OFFSET * 32) + (DMAEN_BitNumber * 4))
-
-/* Alias word address of RWSTART bit */
-#define RWSTART_BitNumber         0x08
-#define DCTRL_RWSTART_BB          (PERIPH_BB_BASE + (DCTRL_OFFSET * 32) + (RWSTART_BitNumber * 4))
-
-/* Alias word address of RWSTOP bit */
-#define RWSTOP_BitNumber          0x09
-#define DCTRL_RWSTOP_BB           (PERIPH_BB_BASE + (DCTRL_OFFSET * 32) + (RWSTOP_BitNumber * 4))
-
-/* Alias word address of RWMOD bit */
-#define RWMOD_BitNumber           0x0A
-#define DCTRL_RWMOD_BB            (PERIPH_BB_BASE + (DCTRL_OFFSET * 32) + (RWMOD_BitNumber * 4))
-
-/* Alias word address of SDIOEN bit */
-#define SDIOEN_BitNumber          0x0B
-#define DCTRL_SDIOEN_BB           (PERIPH_BB_BASE + (DCTRL_OFFSET * 32) + (SDIOEN_BitNumber * 4))
-
-
-/* ---------------------- SDIO registers bit mask ------------------------ */
-/* --- CLKCR Register ---*/
-/* CLKCR register clear mask */
-#define CLKCR_CLEAR_MASK         ((u32)0xFFFF8100) 
-
-/* --- PWRCTRL Register ---*/
-/* SDIO PWRCTRL Mask */
-#define PWR_PWRCTRL_MASK         ((u32)0xFFFFFFFC)
-
-/* --- DCTRL Register ---*/
-/* SDIO DCTRL Clear Mask */
-#define DCTRL_CLEAR_MASK         ((u32)0xFFFFFF08)
-
-/* --- CMD Register ---*/
-/* CMD Register clear mask */
-#define CMD_CLEAR_MASK           ((u32)0xFFFFF800)
-
-/* SDIO RESP Registers Address */
-#define SDIO_RESP_ADDR           ((u32)(SDIO_BASE + 0x14))
-
-/* Private define ------------------------------------------------------------*/
-/* Private macro -------------------------------------------------------------*/
-/* Private variables ---------------------------------------------------------*/
-/* Private function prototypes -----------------------------------------------*/
-/* Private functions ---------------------------------------------------------*/
-
-/*******************************************************************************
-* Function Name  : SDIO_DeInit
-* Description    : Deinitializes the SDIO peripheral registers to their default
-*                  reset values.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SDIO_DeInit(void)
-{
-  SDIO-&gt;POWER = 0x00000000;
-  SDIO-&gt;CLKCR = 0x00000000;
-  SDIO-&gt;ARG = 0x00000000;
-  SDIO-&gt;CMD = 0x00000000;
-  SDIO-&gt;DTIMER = 0x00000000;
-  SDIO-&gt;DLEN = 0x00000000;
-  SDIO-&gt;DCTRL = 0x00000000;
-  SDIO-&gt;ICR = 0x00C007FF;
-  SDIO-&gt;MASK = 0x00000000;
-}
-
-/*******************************************************************************
-* Function Name  : SDIO_Init
-* Description    : Initializes the SDIO peripheral according to the specified 
-*                  parameters in the SDIO_InitStruct.
-* Input          : SDIO_InitStruct : pointer to a SDIO_InitTypeDef structure 
-*                  that contains the configuration information for the SDIO 
-*                  peripheral.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SDIO_Init(SDIO_InitTypeDef* SDIO_InitStruct)
-{
-  u32 tmpreg = 0;
-    
-  /* Check the parameters */
-  assert_param(IS_SDIO_CLOCK_EDGE(SDIO_InitStruct-&gt;SDIO_ClockEdge));
-  assert_param(IS_SDIO_CLOCK_BYPASS(SDIO_InitStruct-&gt;SDIO_ClockBypass));
-  assert_param(IS_SDIO_CLOCK_POWER_SAVE(SDIO_InitStruct-&gt;SDIO_ClockPowerSave));
-  assert_param(IS_SDIO_BUS_WIDE(SDIO_InitStruct-&gt;SDIO_BusWide));
-  assert_param(IS_SDIO_HARDWARE_FLOW_CONTROL(SDIO_InitStruct-&gt;SDIO_HardwareFlowControl)); 
-   
-/*---------------------------- SDIO CLKCR Configuration ------------------------*/  
-  /* Get the SDIO CLKCR value */
-  tmpreg = SDIO-&gt;CLKCR;
-  
-  /* Clear CLKDIV, PWRSAV, BYPASS, WIDBUS, NEGEDGE, HWFC_EN bits */
-  tmpreg &amp;= CLKCR_CLEAR_MASK;
-  
-  /* Set CLKDIV bits according to SDIO_ClockDiv value */
-  /* Set PWRSAV bit according to SDIO_ClockPowerSave value */
-  /* Set BYPASS bit according to SDIO_ClockBypass value */
-  /* Set WIDBUS bits according to SDIO_BusWide value */
-  /* Set NEGEDGE bits according to SDIO_ClockEdge value */
-  /* Set HWFC_EN bits according to SDIO_HardwareFlowControl value */
-  tmpreg |= (SDIO_InitStruct-&gt;SDIO_ClockDiv  | SDIO_InitStruct-&gt;SDIO_ClockPowerSave |
-             SDIO_InitStruct-&gt;SDIO_ClockBypass | SDIO_InitStruct-&gt;SDIO_BusWide |
-             SDIO_InitStruct-&gt;SDIO_ClockEdge | SDIO_InitStruct-&gt;SDIO_HardwareFlowControl); 
-  
-  /* Write to SDIO CLKCR */
-  SDIO-&gt;CLKCR = tmpreg;             
-}
-
-/*******************************************************************************
-* Function Name  : SDIO_StructInit
-* Description    : Fills each SDIO_InitStruct member with its default value.
-* Input          : SDIO_InitStruct: pointer to an SDIO_InitTypeDef structure which 
-*                  will be initialized.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SDIO_StructInit(SDIO_InitTypeDef* SDIO_InitStruct)
-{
-  /* SDIO_InitStruct members default value */
-  SDIO_InitStruct-&gt;SDIO_ClockDiv = 0x00;
-  SDIO_InitStruct-&gt;SDIO_ClockEdge = SDIO_ClockEdge_Rising;
-  SDIO_InitStruct-&gt;SDIO_ClockBypass = SDIO_ClockBypass_Disable;
-  SDIO_InitStruct-&gt;SDIO_ClockPowerSave = SDIO_ClockPowerSave_Disable;
-  SDIO_InitStruct-&gt;SDIO_BusWide = SDIO_BusWide_1b;
-  SDIO_InitStruct-&gt;SDIO_HardwareFlowControl = SDIO_HardwareFlowControl_Disable;
-}
-
-/*******************************************************************************
-* Function Name  : SDIO_ClockCmd
-* Description    : Enables or disables the SDIO Clock.
-* Input          : NewState: new state of the SDIO Clock.
-*                  This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SDIO_ClockCmd(FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  
-  *(vu32 *) CLKCR_CLKEN_BB = (u32)NewState;
-}
-
-/*******************************************************************************
-* Function Name  : SDIO_SetPowerState
-* Description    : Sets the power status of the controller.
-* Input          : SDIO_PowerState: new state of the Power state. 
-*                  This parameter can be one of the following values:
-*                   - SDIO_PowerState_OFF
-*                   - SDIO_PowerState_ON
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SDIO_SetPowerState(u32 SDIO_PowerState)
-{
-  /* Check the parameters */
-  assert_param(IS_SDIO_POWER_STATE(SDIO_PowerState));
-  
-  SDIO-&gt;POWER &amp;= PWR_PWRCTRL_MASK;
-  SDIO-&gt;POWER |= SDIO_PowerState;
-}
-
-/*******************************************************************************
-* Function Name  : SDIO_GetPowerState
-* Description    : Gets the power status of the controller.
-* Input          : None
-* Output         : None
-* Return         : Power status of the controller. The returned value can
-*                  be one of the following:
-*                       - 0x00: Power OFF
-*                       - 0x02: Power UP
-*                       - 0x03: Power ON 
-*******************************************************************************/
-u32 SDIO_GetPowerState(void)
-{
-  return (SDIO-&gt;POWER &amp; (~PWR_PWRCTRL_MASK));
-}
-
-/*******************************************************************************
-* Function Name  : SDIO_ITConfig
-* Description    : Enables or disables the SDIO interrupts.
-* Input          : - SDIO_IT: specifies the SDIO interrupt sources to be 
-*                    enabled or disabled.
-*                    This parameter can be one or a combination of the following
-*                    values:
-*                      - SDIO_IT_CCRCFAIL: Command response received (CRC check
-*                                          failed) interrupt    
-*                      - SDIO_IT_DCRCFAIL: Data block sent/received (CRC check 
-*                                          failed) interrupt    
-*                      - SDIO_IT_CTIMEOUT: Command response timeout interrupt    
-*                      - SDIO_IT_DTIMEOUT: Data timeout interrupt    
-*                      - SDIO_IT_TXUNDERR: Transmit FIFO underrun error interrupt    
-*                      - SDIO_IT_RXOVERR:  Received FIFO overrun error interrupt     
-*                      - SDIO_IT_CMDREND:  Command response received (CRC check 
-*                                          passed) interrupt     
-*                      - SDIO_IT_CMDSENT:  Command sent (no response required) 
-*                                          interrupt     
-*                      - SDIO_IT_DATAEND:  Data end (data counter, SDIDCOUNT, is 
-*                                          zero) interrupt     
-*                      - SDIO_IT_STBITERR: Start bit not detected on all data 
-*                                          signals in wide bus mode interrupt    
-*                      - SDIO_IT_DBCKEND:  Data block sent/received (CRC check 
-*                                          passed) interrupt    
-*                      - SDIO_IT_CMDACT:   Command transfer in progress interrupt     
-*                      - SDIO_IT_TXACT:    Data transmit in progress interrupt       
-*                      - SDIO_IT_RXACT:    Data receive in progress interrupt      
-*                      - SDIO_IT_TXFIFOHE: Transmit FIFO Half Empty interrupt    
-*                      - SDIO_IT_RXFIFOHF: Receive FIFO Half Full interrupt   
-*                      - SDIO_IT_TXFIFOF:  Transmit FIFO full interrupt     
-*                      - SDIO_IT_RXFIFOF:  Receive FIFO full interrupt     
-*                      - SDIO_IT_TXFIFOE:  Transmit FIFO empty interrupt      
-*                      - SDIO_IT_RXFIFOE:  Receive FIFO empty interrupt     
-*                      - SDIO_IT_TXDAVL:   Data available in transmit FIFO interrupt      
-*                      - SDIO_IT_RXDAVL:   Data available in receive FIFO interrupt      
-*                      - SDIO_IT_SDIOIT:   SD I/O interrupt received interrupt      
-*                      - SDIO_IT_CEATAEND: CE-ATA command completion signal 
-*                                          received for CMD61 interrupt
-*                  - NewState: new state of the specified SDIO interrupts.
-*                  This parameter can be: ENABLE or DISABLE.  
-* Output         : None
-* Return         : None 
-*******************************************************************************/
-void SDIO_ITConfig(u32 SDIO_IT, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_SDIO_IT(SDIO_IT));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  
-  if (NewState != DISABLE)
-  {
-    /* Enable the SDIO interrupts */
-    SDIO-&gt;MASK |= SDIO_IT;
-  }
-  else
-  {
-    /* Disable the SDIO interrupts */
-    SDIO-&gt;MASK &amp;= ~SDIO_IT;
-  } 
-}
-
-/*******************************************************************************
-* Function Name  : SDIO_DMACmd
-* Description    : Enables or disables the SDIO DMA request.
-* Input          : NewState: new state of the selected SDIO DMA request.
-*                  This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SDIO_DMACmd(FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  
-  *(vu32 *) DCTRL_DMAEN_BB = (u32)NewState;
-}
-
-/*******************************************************************************
-* Function Name  : SDIO_SendCommand
-* Description    : Initializes the SDIO Command according to the specified 
-*                  parameters in the SDIO_CmdInitStruct and send the command.
-* Input          : SDIO_CmdInitStruct : pointer to a SDIO_CmdInitTypeDef 
-*                  structure that contains the configuration information 
-*                  for the SDIO command.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SDIO_SendCommand(SDIO_CmdInitTypeDef *SDIO_CmdInitStruct)
-{
-  u32 tmpreg = 0;
-  
-  /* Check the parameters */
-  assert_param(IS_SDIO_CMD_INDEX(SDIO_CmdInitStruct-&gt;SDIO_CmdIndex));
-  assert_param(IS_SDIO_RESPONSE(SDIO_CmdInitStruct-&gt;SDIO_Response));
-  assert_param(IS_SDIO_WAIT(SDIO_CmdInitStruct-&gt;SDIO_Wait));
-  assert_param(IS_SDIO_CPSM(SDIO_CmdInitStruct-&gt;SDIO_CPSM));
-  
-/*---------------------------- SDIO ARG Configuration ------------------------*/
-  /* Set the SDIO Argument value */
-  SDIO-&gt;ARG = SDIO_CmdInitStruct-&gt;SDIO_Argument;
-  
-/*---------------------------- SDIO CMD Configuration ------------------------*/  
-  /* Get the SDIO CMD value */
-  tmpreg = SDIO-&gt;CMD;
-
-  /* Clear CMDINDEX, WAITRESP, WAITINT, WAITPEND, CPSMEN bits */
-  tmpreg &amp;= CMD_CLEAR_MASK;
-  /* Set CMDINDEX bits according to SDIO_CmdIndex value */
-  /* Set WAITRESP bits according to SDIO_Response value */
-  /* Set WAITINT and WAITPEND bits according to SDIO_Wait value */
-  /* Set CPSMEN bits according to SDIO_CPSM value */
-  tmpreg |= (u32)SDIO_CmdInitStruct-&gt;SDIO_CmdIndex | SDIO_CmdInitStruct-&gt;SDIO_Response
-           | SDIO_CmdInitStruct-&gt;SDIO_Wait | SDIO_CmdInitStruct-&gt;SDIO_CPSM;
-  
-  /* Write to SDIO CMD */
-  SDIO-&gt;CMD = tmpreg;
-}
-
-/*******************************************************************************
-* Function Name  : SDIO_CmdStructInit
-* Description    : Fills each SDIO_CmdInitStruct member with its default value.
-* Input          : SDIO_CmdInitStruct: pointer to an SDIO_CmdInitTypeDef 
-*                  structure which will be initialized.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SDIO_CmdStructInit(SDIO_CmdInitTypeDef* SDIO_CmdInitStruct)
-{
-  /* SDIO_CmdInitStruct members default value */
-  SDIO_CmdInitStruct-&gt;SDIO_Argument = 0x00;
-  SDIO_CmdInitStruct-&gt;SDIO_CmdIndex = 0x00;
-  SDIO_CmdInitStruct-&gt;SDIO_Response = SDIO_Response_No;
-  SDIO_CmdInitStruct-&gt;SDIO_Wait = SDIO_Wait_No;
-  SDIO_CmdInitStruct-&gt;SDIO_CPSM = SDIO_CPSM_Disable;
-}
-
-/*******************************************************************************
-* Function Name  : SDIO_GetCommandResponse
-* Description    : Returns command index of last command for which response 
-*                  received.
-* Input          : None
-* Output         : None
-* Return         : Returns the command index of the last command response received.
-*******************************************************************************/
-u8 SDIO_GetCommandResponse(void)
-{
-  return (u8)(SDIO-&gt;RESPCMD);
-}
-
-/*******************************************************************************
-* Function Name  : SDIO_GetResponse
-* Description    : Returns response received from the card for the last command.
-* Input          : - SDIO_RESP: Specifies the SDIO response register. 
-*                     This parameter can be one of the following values:
-*                       - SDIO_RESP1: Response Register 1
-*                       - SDIO_RESP2: Response Register 2
-*                       - SDIO_RESP3: Response Register 3
-*                       - SDIO_RESP4: Response Register 4                       
-* Output         : None
-* Return         : The Corresponding response register value.
-*******************************************************************************/
-u32 SDIO_GetResponse(u32 SDIO_RESP)
-{
-  /* Check the parameters */
-  assert_param(IS_SDIO_RESP(SDIO_RESP));
-  
-  return (*(vu32 *)(SDIO_RESP_ADDR + SDIO_RESP)); 
-}
-
-/*******************************************************************************
-* Function Name  : SDIO_DataConfig
-* Description    : Initializes the SDIO data path according to the specified 
-*                  parameters in the SDIO_DataInitStruct.
-* Input          : SDIO_DataInitStruct : pointer to a SDIO_DataInitTypeDef 
-*                  structure that contains the configuration information 
-*                  for the SDIO command.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SDIO_DataConfig(SDIO_DataInitTypeDef* SDIO_DataInitStruct)
-{
-  u32 tmpreg = 0;
-  
-  /* Check the parameters */
-  assert_param(IS_SDIO_DATA_LENGTH(SDIO_DataInitStruct-&gt;SDIO_DataLength));
-  assert_param(IS_SDIO_BLOCK_SIZE(SDIO_DataInitStruct-&gt;SDIO_DataBlockSize));
-  assert_param(IS_SDIO_TRANSFER_DIR(SDIO_DataInitStruct-&gt;SDIO_TransferDir));
-  assert_param(IS_SDIO_TRANSFER_MODE(SDIO_DataInitStruct-&gt;SDIO_TransferMode));
-  assert_param(IS_SDIO_DPSM(SDIO_DataInitStruct-&gt;SDIO_DPSM));
-
-/*---------------------------- SDIO DTIMER Configuration ---------------------*/
-  /* Set the SDIO Data TimeOut value */
-  SDIO-&gt;DTIMER = SDIO_DataInitStruct-&gt;SDIO_DataTimeOut;
-    
-/*---------------------------- SDIO DLEN Configuration -----------------------*/
-  /* Set the SDIO DataLength value */
-  SDIO-&gt;DLEN = SDIO_DataInitStruct-&gt;SDIO_DataLength;
-  
-/*---------------------------- SDIO DCTRL Configuration ----------------------*/  
-  /* Get the SDIO DCTRL value */
-  tmpreg = SDIO-&gt;DCTRL;
-
-  /* Clear DEN, DTMODE, DTDIR and DBCKSIZE bits */
-  tmpreg &amp;= DCTRL_CLEAR_MASK;
-  /* Set DEN bit according to SDIO_DPSM value */
-  /* Set DTMODE bit according to SDIO_TransferMode value */
-  /* Set DTDIR bit according to SDIO_TransferDir value */
-  /* Set DBCKSIZE bits according to SDIO_DataBlockSize value */
-  tmpreg |= (u32)SDIO_DataInitStruct-&gt;SDIO_DataBlockSize | SDIO_DataInitStruct-&gt;SDIO_TransferDir
-           | SDIO_DataInitStruct-&gt;SDIO_TransferMode | SDIO_DataInitStruct-&gt;SDIO_DPSM;
-  
-  /* Write to SDIO DCTRL */
-  SDIO-&gt;DCTRL = tmpreg;
-}
-
-/*******************************************************************************
-* Function Name  : SDIO_DataStructInit
-* Description    : Fills each SDIO_DataInitStruct member with its default value.
-* Input          : SDIO_DataInitStruct: pointer to an SDIO_DataInitTypeDef 
-*                  structure which will be initialized.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SDIO_DataStructInit(SDIO_DataInitTypeDef* SDIO_DataInitStruct)
-{
-  /* SDIO_DataInitStruct members default value */
-  SDIO_DataInitStruct-&gt;SDIO_DataTimeOut = 0xFFFFFFFF;
-  SDIO_DataInitStruct-&gt;SDIO_DataLength = 0x00;
-  SDIO_DataInitStruct-&gt;SDIO_DataBlockSize = SDIO_DataBlockSize_1b;
-  SDIO_DataInitStruct-&gt;SDIO_TransferDir = SDIO_TransferDir_ToCard;
-  SDIO_DataInitStruct-&gt;SDIO_TransferMode = SDIO_TransferMode_Block;  
-  SDIO_DataInitStruct-&gt;SDIO_DPSM = SDIO_DPSM_Disable;
-}
-
-/*******************************************************************************
-* Function Name  : SDIO_GetDataCounter
-* Description    : Returns number of remaining data bytes to be transferred.
-* Input          : None
-* Output         : None
-* Return         : Number of remaining data bytes to be transferred
-*******************************************************************************/
-u32 SDIO_GetDataCounter(void)
-{ 
-  return SDIO-&gt;DCOUNT;
-}
-
-/*******************************************************************************
-* Function Name  : SDIO_ReadData
-* Description    : Read one data word from Rx FIFO.
-* Input          : None
-* Output         : None
-* Return         : Data received
-*******************************************************************************/
-u32 SDIO_ReadData(void)
-{ 
-  return SDIO-&gt;FIFO;
-}
-
-/*******************************************************************************
-* Function Name  : SDIO_WriteData
-* Description    : Write one data word to Tx FIFO.
-* Input          : Data: 32-bit data word to write.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SDIO_WriteData(u32 Data)
-{ 
-  SDIO-&gt;FIFO = Data;
-}
-
-/*******************************************************************************
-* Function Name  : SDIO_GetFIFOCount
-* Description    : Returns the number of words left to be written to or read
-*                  from FIFO.	
-* Input          : None
-* Output         : None
-* Return         : Remaining number of words.
-*******************************************************************************/
-u32 SDIO_GetFIFOCount(void)
-{ 
-  return SDIO-&gt;FIFOCNT;
-}
-
-/*******************************************************************************
-* Function Name  : SDIO_StartSDIOReadWait
-* Description    : Starts the SD I/O Read Wait operation.	
-* Input          : NewState: new state of the Start SDIO Read Wait operation. 
-*                  This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SDIO_StartSDIOReadWait(FunctionalState NewState)
-{ 
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  
-  *(vu32 *) DCTRL_RWSTART_BB = (u32) NewState;
-}
-
-/*******************************************************************************
-* Function Name  : SDIO_StopSDIOReadWait
-* Description    : Stops the SD I/O Read Wait operation.	
-* Input          : NewState: new state of the Stop SDIO Read Wait operation. 
-*                  This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SDIO_StopSDIOReadWait(FunctionalState NewState)
-{ 
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  
-  *(vu32 *) DCTRL_RWSTOP_BB = (u32) NewState;
-}
-
-/*******************************************************************************
-* Function Name  : SDIO_SetSDIOReadWaitMode
-* Description    : Sets one of the two options of inserting read wait interval.	
-* Input          : SDIOReadWaitMode: SD I/O Read Wait operation mode.
-*                  This parametre can be:
-*                    - SDIO_ReadWaitMode_CLK: Read Wait control by stopping SDIOCLK
-*                    - SDIO_ReadWaitMode_DATA2: Read Wait control using SDIO_DATA2
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SDIO_SetSDIOReadWaitMode(u32 SDIO_ReadWaitMode)
-{
-  /* Check the parameters */
-  assert_param(IS_SDIO_READWAIT_MODE(SDIO_ReadWaitMode));
-  
-  *(vu32 *) DCTRL_RWMOD_BB = SDIO_ReadWaitMode;
-}
-
-/*******************************************************************************
-* Function Name  : SDIO_SetSDIOOperation
-* Description    : Enables or disables the SD I/O Mode Operation.	
-* Input          : NewState: new state of SDIO specific operation. 
-*                  This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SDIO_SetSDIOOperation(FunctionalState NewState)
-{ 
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  
-  *(vu32 *) DCTRL_SDIOEN_BB = (u32)NewState;
-}
-
-/*******************************************************************************
-* Function Name  : SDIO_SendSDIOSuspendCmd
-* Description    : Enables or disables the SD I/O Mode suspend command sending.
-* Input          : NewState: new state of the SD I/O Mode suspend command.
-*                  This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SDIO_SendSDIOSuspendCmd(FunctionalState NewState)
-{ 
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  
-  *(vu32 *) CMD_SDIOSUSPEND_BB = (u32)NewState;
-}
-
-/*******************************************************************************
-* Function Name  : SDIO_CommandCompletionCmd
-* Description    : Enables or disables the command completion signal.
-* Input          : NewState: new state of command completion signal. 
-*                  This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SDIO_CommandCompletionCmd(FunctionalState NewState)
-{ 
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  
-  *(vu32 *) CMD_ENCMDCOMPL_BB = (u32)NewState;
-}
-
-/*******************************************************************************
-* Function Name  : SDIO_CEATAITCmd
-* Description    : Enables or disables the CE-ATA interrupt.
-* Input          : NewState: new state of CE-ATA interrupt. 
-*                  This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SDIO_CEATAITCmd(FunctionalState NewState)
-{ 
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  
-  *(vu32 *) CMD_NIEN_BB = (u32)((~((u32)NewState)) &amp; ((u32)0x1));
-}
-
-/*******************************************************************************
-* Function Name  : SDIO_SendCEATACmd
-* Description    : Sends CE-ATA command (CMD61).
-* Input          : NewState: new state of CE-ATA command. 
-*                  This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SDIO_SendCEATACmd(FunctionalState NewState)
-{ 
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  
-  *(vu32 *) CMD_ATACMD_BB = (u32)NewState;
-}
-
-/*******************************************************************************
-* Function Name  : SDIO_GetFlagStatus
-* Description    : Checks whether the specified SDIO flag is set or not.	
-* Input          : SDIO_FLAG: specifies the flag to check. 
-*                  This parameter can be one of the following values:
-*                     - SDIO_FLAG_CCRCFAIL: Command response received (CRC check
-*                                           failed)    
-*                     - SDIO_FLAG_DCRCFAIL: Data block sent/received (CRC check 
-*                                           failed)    
-*                     - SDIO_FLAG_CTIMEOUT: Command response timeout    
-*                     - SDIO_FLAG_DTIMEOUT: Data timeou   
-*                     - SDIO_FLAG_TXUNDERR: Transmit FIFO underrun error   
-*                     - SDIO_FLAG_RXOVERR:  Received FIFO overrun error    
-*                     - SDIO_FLAG_CMDREND:  Command response received (CRC check 
-*                                           passed)    
-*                     - SDIO_FLAG_CMDSENT:  Command sent (no response required)    
-*                     - SDIO_FLAG_DATAEND:  Data end (data counter, SDIDCOUNT, is
-*                                           zero)    
-*                     - SDIO_FLAG_STBITERR: Start bit not detected on all data 
-*                                           signals in wide bus mode   
-*                     - SDIO_FLAG_DBCKEND:  Data block sent/received (CRC check 
-*                                           passed)    
-*                     - SDIO_FLAG_CMDACT:   Command transfer in progress     
-*                     - SDIO_FLAG_TXACT:    Data transmit in progress      
-*                     - SDIO_FLAG_RXACT:    Data receive in progress      
-*                     - SDIO_FLAG_TXFIFOHE: Transmit FIFO Half Empty   
-*                     - SDIO_FLAG_RXFIFOHF: Receive FIFO Half Full   
-*                     - SDIO_FLAG_TXFIFOF:  Transmit FIFO full    
-*                     - SDIO_FLAG_RXFIFOF:  Receive FIFO full     
-*                     - SDIO_FLAG_TXFIFOE:  Transmit FIFO empty    
-*                     - SDIO_FLAG_RXFIFOE:  Receive FIFO empty    
-*                     - SDIO_FLAG_TXDAVL:   Data available in transmit FIFO     
-*                     - SDIO_FLAG_RXDAVL:   Data available in receive FIFO     
-*                     - SDIO_FLAG_SDIOIT:   SD I/O interrupt received     
-*                     - SDIO_FLAG_CEATAEND: CE-ATA command completion signal 
-*                                           received for CMD61    
-* Output         : None
-* Return         : The new state of SDIO_FLAG (SET or RESET).
-*******************************************************************************/
-FlagStatus SDIO_GetFlagStatus(u32 SDIO_FLAG)
-{ 
-  FlagStatus bitstatus = RESET;
-  
-  /* Check the parameters */
-  assert_param(IS_SDIO_FLAG(SDIO_FLAG));
-  
-  if ((SDIO-&gt;STA &amp; SDIO_FLAG) != (u32)RESET)
-  {
-    bitstatus = SET;
-  }
-  else
-  {
-    bitstatus = RESET;
-  }
-  return bitstatus;
-}
-
-/*******************************************************************************
-* Function Name  : SDIO_ClearFlag
-* Description    : Clears the SDIO's pending flags.	
-* Input          : SDIO_FLAG: specifies the flag to clear.  
-*                  This parameter can be one or a combination of the following
-*                  values:
-*                     - SDIO_FLAG_CCRCFAIL: Command response received (CRC check
-*                                           failed)    
-*                     - SDIO_FLAG_DCRCFAIL: Data block sent/received (CRC check 
-*                                           failed)    
-*                     - SDIO_FLAG_CTIMEOUT: Command response timeout    
-*                     - SDIO_FLAG_DTIMEOUT: Data timeou   
-*                     - SDIO_FLAG_TXUNDERR: Transmit FIFO underrun error   
-*                     - SDIO_FLAG_RXOVERR:  Received FIFO overrun error    
-*                     - SDIO_FLAG_CMDREND:  Command response received (CRC check 
-*                                           passed)    
-*                     - SDIO_FLAG_CMDSENT:  Command sent (no response required)    
-*                     - SDIO_FLAG_DATAEND:  Data end (data counter, SDIDCOUNT, is
-*                                           zero)    
-*                     - SDIO_FLAG_STBITERR: Start bit not detected on all data 
-*                                           signals in wide bus mode   
-*                     - SDIO_FLAG_DBCKEND:  Data block sent/received (CRC check 
-*                                           passed)         
-*                     - SDIO_FLAG_SDIOIT:   SD I/O interrupt received     
-*                     - SDIO_FLAG_CEATAEND: CE-ATA command completion signal 
-*                                           received for CMD61    
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SDIO_ClearFlag(u32 SDIO_FLAG)
-{ 
-  /* Check the parameters */
-  assert_param(IS_SDIO_CLEAR_FLAG(SDIO_FLAG));
-   
-  SDIO-&gt;ICR = SDIO_FLAG;
-}
-
-/*******************************************************************************
-* Function Name  : SDIO_GetITStatus
-* Description    : Checks whether the specified SDIO interrupt has occurred or not.	
-* Input          : SDIO_IT: specifies the SDIO interrupt source to check. 
-*                  This parameter can be one of the following values:
-*                      - SDIO_IT_CCRCFAIL: Command response received (CRC check
-*                                          failed) interrupt    
-*                      - SDIO_IT_DCRCFAIL: Data block sent/received (CRC check 
-*                                          failed) interrupt    
-*                      - SDIO_IT_CTIMEOUT: Command response timeout interrupt    
-*                      - SDIO_IT_DTIMEOUT: Data timeout interrupt    
-*                      - SDIO_IT_TXUNDERR: Transmit FIFO underrun error interrupt    
-*                      - SDIO_IT_RXOVERR:  Received FIFO overrun error interrupt     
-*                      - SDIO_IT_CMDREND:  Command response received (CRC check 
-*                                          passed) interrupt     
-*                      - SDIO_IT_CMDSENT:  Command sent (no response required) 
-*                                          interrupt     
-*                      - SDIO_IT_DATAEND:  Data end (data counter, SDIDCOUNT, is 
-*                                          zero) interrupt     
-*                      - SDIO_IT_STBITERR: Start bit not detected on all data 
-*                                          signals in wide bus mode interrupt    
-*                      - SDIO_IT_DBCKEND:  Data block sent/received (CRC check 
-*                                          passed) interrupt    
-*                      - SDIO_IT_CMDACT:   Command transfer in progress interrupt     
-*                      - SDIO_IT_TXACT:    Data transmit in progress interrupt       
-*                      - SDIO_IT_RXACT:    Data receive in progress interrupt      
-*                      - SDIO_IT_TXFIFOHE: Transmit FIFO Half Empty interrupt    
-*                      - SDIO_IT_RXFIFOHF: Receive FIFO Half Full interrupt   
-*                      - SDIO_IT_TXFIFOF:  Transmit FIFO full interrupt     
-*                      - SDIO_IT_RXFIFOF:  Receive FIFO full interrupt     
-*                      - SDIO_IT_TXFIFOE:  Transmit FIFO empty interrupt      
-*                      - SDIO_IT_RXFIFOE:  Receive FIFO empty interrupt     
-*                      - SDIO_IT_TXDAVL:   Data available in transmit FIFO interrupt      
-*                      - SDIO_IT_RXDAVL:   Data available in receive FIFO interrupt      
-*                      - SDIO_IT_SDIOIT:   SD I/O interrupt received interrupt      
-*                      - SDIO_IT_CEATAEND: CE-ATA command completion signal 
-*                                          received for CMD61 interrupt
-* Output         : None
-* Return         : The new state of SDIO_IT (SET or RESET).
-*******************************************************************************/
-ITStatus SDIO_GetITStatus(u32 SDIO_IT)
-{ 
-  ITStatus bitstatus = RESET;
-  
-  /* Check the parameters */
-  assert_param(IS_SDIO_GET_IT(SDIO_IT));
-
-  if ((SDIO-&gt;STA &amp; SDIO_IT) != (u32)RESET)  
-  {
-    bitstatus = SET;
-  }
-  else
-  {
-    bitstatus = RESET;
-  }
-  return bitstatus;
-}
-
-/*******************************************************************************
-* Function Name  : SDIO_ClearITPendingBit
-* Description    : Clears the SDIO's interrupt pending bits.	
-* Input          : SDIO_IT: specifies the interrupt pending bit to clear. 
-*                   This parameter can be one or a combination of the following
-*                   values:
-*                      - SDIO_IT_CCRCFAIL: Command response received (CRC check
-*                                          failed) interrupt    
-*                      - SDIO_IT_DCRCFAIL: Data block sent/received (CRC check 
-*                                          failed) interrupt    
-*                      - SDIO_IT_CTIMEOUT: Command response timeout interrupt    
-*                      - SDIO_IT_DTIMEOUT: Data timeout interrupt    
-*                      - SDIO_IT_TXUNDERR: Transmit FIFO underrun error interrupt    
-*                      - SDIO_IT_RXOVERR:  Received FIFO overrun error interrupt     
-*                      - SDIO_IT_CMDREND:  Command response received (CRC check 
-*                                          passed) interrupt     
-*                      - SDIO_IT_CMDSENT:  Command sent (no response required) 
-*                                          interrupt     
-*                      - SDIO_IT_DATAEND:  Data end (data counter, SDIDCOUNT, is 
-*                                          zero) interrupt     
-*                      - SDIO_IT_STBITERR: Start bit not detected on all data 
-*                                          signals in wide bus mode interrupt          
-*                      - SDIO_IT_SDIOIT:   SD I/O interrupt received interrupt      
-*                      - SDIO_IT_CEATAEND: CE-ATA command completion signal 
-*                                          received for CMD61 
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SDIO_ClearITPendingBit(u32 SDIO_IT)
-{ 
-  /* Check the parameters */
-  assert_param(IS_SDIO_CLEAR_IT(SDIO_IT));
-   
-  SDIO-&gt;ICR = SDIO_IT;
-}
-
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
+/**
+  ******************************************************************************
+  * @file    stm32f10x_sdio.c
+  * @author  MCD Application Team
+  * @version V3.1.0
+  * @date    06/19/2009
+  * @brief   This file provides all the SDIO firmware functions.
+  ******************************************************************************
+  * @copy
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * &lt;h2&gt;&lt;center&gt;&copy; COPYRIGHT 2009 STMicroelectronics&lt;/center&gt;&lt;/h2&gt;
+  */ 
+
+/* Includes ------------------------------------------------------------------*/
+#include &quot;stm32f10x_sdio.h&quot;
+#include &quot;stm32f10x_rcc.h&quot;
+
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup SDIO 
+  * @brief SDIO driver modules
+  * @{
+  */ 
+
+/** @defgroup SDIO_Private_TypesDefinitions
+  * @{
+  */ 
+
+/* ------------ SDIO registers bit address in the alias region ----------- */
+#define SDIO_OFFSET                (SDIO_BASE - PERIPH_BASE)
+
+/* --- CLKCR Register ---*/
+
+/* Alias word address of CLKEN bit */
+#define CLKCR_OFFSET              (SDIO_OFFSET + 0x04)
+#define CLKEN_BitNumber           0x08
+#define CLKCR_CLKEN_BB            (PERIPH_BB_BASE + (CLKCR_OFFSET * 32) + (CLKEN_BitNumber * 4))
+
+/* --- CMD Register ---*/
+
+/* Alias word address of SDIOSUSPEND bit */
+#define CMD_OFFSET                (SDIO_OFFSET + 0x0C)
+#define SDIOSUSPEND_BitNumber     0x0B
+#define CMD_SDIOSUSPEND_BB        (PERIPH_BB_BASE + (CMD_OFFSET * 32) + (SDIOSUSPEND_BitNumber * 4))
+
+/* Alias word address of ENCMDCOMPL bit */
+#define ENCMDCOMPL_BitNumber      0x0C
+#define CMD_ENCMDCOMPL_BB         (PERIPH_BB_BASE + (CMD_OFFSET * 32) + (ENCMDCOMPL_BitNumber * 4))
+
+/* Alias word address of NIEN bit */
+#define NIEN_BitNumber            0x0D
+#define CMD_NIEN_BB               (PERIPH_BB_BASE + (CMD_OFFSET * 32) + (NIEN_BitNumber * 4))
+
+/* Alias word address of ATACMD bit */
+#define ATACMD_BitNumber          0x0E
+#define CMD_ATACMD_BB             (PERIPH_BB_BASE + (CMD_OFFSET * 32) + (ATACMD_BitNumber * 4))
+
+/* --- DCTRL Register ---*/
+
+/* Alias word address of DMAEN bit */
+#define DCTRL_OFFSET              (SDIO_OFFSET + 0x2C)
+#define DMAEN_BitNumber           0x03
+#define DCTRL_DMAEN_BB            (PERIPH_BB_BASE + (DCTRL_OFFSET * 32) + (DMAEN_BitNumber * 4))
+
+/* Alias word address of RWSTART bit */
+#define RWSTART_BitNumber         0x08
+#define DCTRL_RWSTART_BB          (PERIPH_BB_BASE + (DCTRL_OFFSET * 32) + (RWSTART_BitNumber * 4))
+
+/* Alias word address of RWSTOP bit */
+#define RWSTOP_BitNumber          0x09
+#define DCTRL_RWSTOP_BB           (PERIPH_BB_BASE + (DCTRL_OFFSET * 32) + (RWSTOP_BitNumber * 4))
+
+/* Alias word address of RWMOD bit */
+#define RWMOD_BitNumber           0x0A
+#define DCTRL_RWMOD_BB            (PERIPH_BB_BASE + (DCTRL_OFFSET * 32) + (RWMOD_BitNumber * 4))
+
+/* Alias word address of SDIOEN bit */
+#define SDIOEN_BitNumber          0x0B
+#define DCTRL_SDIOEN_BB           (PERIPH_BB_BASE + (DCTRL_OFFSET * 32) + (SDIOEN_BitNumber * 4))
+
+/* ---------------------- SDIO registers bit mask ------------------------ */
+
+/* --- CLKCR Register ---*/
+
+/* CLKCR register clear mask */
+#define CLKCR_CLEAR_MASK         ((uint32_t)0xFFFF8100) 
+
+/* --- PWRCTRL Register ---*/
+
+/* SDIO PWRCTRL Mask */
+#define PWR_PWRCTRL_MASK         ((uint32_t)0xFFFFFFFC)
+
+/* --- DCTRL Register ---*/
+
+/* SDIO DCTRL Clear Mask */
+#define DCTRL_CLEAR_MASK         ((uint32_t)0xFFFFFF08)
+
+/* --- CMD Register ---*/
+
+/* CMD Register clear mask */
+#define CMD_CLEAR_MASK           ((uint32_t)0xFFFFF800)
+
+/* SDIO RESP Registers Address */
+#define SDIO_RESP_ADDR           ((uint32_t)(SDIO_BASE + 0x14))
+
+/**
+  * @}
+  */
+
+/** @defgroup SDIO_Private_Defines
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup SDIO_Private_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup SDIO_Private_Variables
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup SDIO_Private_FunctionPrototypes
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup SDIO_Private_Functions
+  * @{
+  */
+
+/**
+  * @brief  Deinitializes the SDIO peripheral registers to their default reset values.
+  * @param  None
+  * @retval None
+  */
+void SDIO_DeInit(void)
+{
+  SDIO-&gt;POWER = 0x00000000;
+  SDIO-&gt;CLKCR = 0x00000000;
+  SDIO-&gt;ARG = 0x00000000;
+  SDIO-&gt;CMD = 0x00000000;
+  SDIO-&gt;DTIMER = 0x00000000;
+  SDIO-&gt;DLEN = 0x00000000;
+  SDIO-&gt;DCTRL = 0x00000000;
+  SDIO-&gt;ICR = 0x00C007FF;
+  SDIO-&gt;MASK = 0x00000000;
+}
+
+/**
+  * @brief  Initializes the SDIO peripheral according to the specified 
+  *   parameters in the SDIO_InitStruct.
+  * @param  SDIO_InitStruct : pointer to a SDIO_InitTypeDef structure 
+  *   that contains the configuration information for the SDIO peripheral.
+  * @retval None
+  */
+void SDIO_Init(SDIO_InitTypeDef* SDIO_InitStruct)
+{
+  uint32_t tmpreg = 0;
+    
+  /* Check the parameters */
+  assert_param(IS_SDIO_CLOCK_EDGE(SDIO_InitStruct-&gt;SDIO_ClockEdge));
+  assert_param(IS_SDIO_CLOCK_BYPASS(SDIO_InitStruct-&gt;SDIO_ClockBypass));
+  assert_param(IS_SDIO_CLOCK_POWER_SAVE(SDIO_InitStruct-&gt;SDIO_ClockPowerSave));
+  assert_param(IS_SDIO_BUS_WIDE(SDIO_InitStruct-&gt;SDIO_BusWide));
+  assert_param(IS_SDIO_HARDWARE_FLOW_CONTROL(SDIO_InitStruct-&gt;SDIO_HardwareFlowControl)); 
+   
+/*---------------------------- SDIO CLKCR Configuration ------------------------*/  
+  /* Get the SDIO CLKCR value */
+  tmpreg = SDIO-&gt;CLKCR;
+  
+  /* Clear CLKDIV, PWRSAV, BYPASS, WIDBUS, NEGEDGE, HWFC_EN bits */
+  tmpreg &amp;= CLKCR_CLEAR_MASK;
+  
+  /* Set CLKDIV bits according to SDIO_ClockDiv value */
+  /* Set PWRSAV bit according to SDIO_ClockPowerSave value */
+  /* Set BYPASS bit according to SDIO_ClockBypass value */
+  /* Set WIDBUS bits according to SDIO_BusWide value */
+  /* Set NEGEDGE bits according to SDIO_ClockEdge value */
+  /* Set HWFC_EN bits according to SDIO_HardwareFlowControl value */
+  tmpreg |= (SDIO_InitStruct-&gt;SDIO_ClockDiv  | SDIO_InitStruct-&gt;SDIO_ClockPowerSave |
+             SDIO_InitStruct-&gt;SDIO_ClockBypass | SDIO_InitStruct-&gt;SDIO_BusWide |
+             SDIO_InitStruct-&gt;SDIO_ClockEdge | SDIO_InitStruct-&gt;SDIO_HardwareFlowControl); 
+  
+  /* Write to SDIO CLKCR */
+  SDIO-&gt;CLKCR = tmpreg;
+}
+
+/**
+  * @brief  Fills each SDIO_InitStruct member with its default value.
+  * @param  SDIO_InitStruct: pointer to an SDIO_InitTypeDef structure which 
+  *   will be initialized.
+  * @retval None
+  */
+void SDIO_StructInit(SDIO_InitTypeDef* SDIO_InitStruct)
+{
+  /* SDIO_InitStruct members default value */
+  SDIO_InitStruct-&gt;SDIO_ClockDiv = 0x00;
+  SDIO_InitStruct-&gt;SDIO_ClockEdge = SDIO_ClockEdge_Rising;
+  SDIO_InitStruct-&gt;SDIO_ClockBypass = SDIO_ClockBypass_Disable;
+  SDIO_InitStruct-&gt;SDIO_ClockPowerSave = SDIO_ClockPowerSave_Disable;
+  SDIO_InitStruct-&gt;SDIO_BusWide = SDIO_BusWide_1b;
+  SDIO_InitStruct-&gt;SDIO_HardwareFlowControl = SDIO_HardwareFlowControl_Disable;
+}
+
+/**
+  * @brief  Enables or disables the SDIO Clock.
+  * @param  NewState: new state of the SDIO Clock. This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void SDIO_ClockCmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  *(__IO uint32_t *) CLKCR_CLKEN_BB = (uint32_t)NewState;
+}
+
+/**
+  * @brief  Sets the power status of the controller.
+  * @param  SDIO_PowerState: new state of the Power state. 
+  *   This parameter can be one of the following values:
+  *     @arg SDIO_PowerState_OFF
+  *     @arg SDIO_PowerState_ON
+  * @retval None
+  */
+void SDIO_SetPowerState(uint32_t SDIO_PowerState)
+{
+  /* Check the parameters */
+  assert_param(IS_SDIO_POWER_STATE(SDIO_PowerState));
+  
+  SDIO-&gt;POWER &amp;= PWR_PWRCTRL_MASK;
+  SDIO-&gt;POWER |= SDIO_PowerState;
+}
+
+/**
+  * @brief  Gets the power status of the controller.
+  * @param  None
+  * @retval Power status of the controller. The returned value can
+  *   be one of the following:
+  * - 0x00: Power OFF
+  * - 0x02: Power UP
+  * - 0x03: Power ON 
+  */
+uint32_t SDIO_GetPowerState(void)
+{
+  return (SDIO-&gt;POWER &amp; (~PWR_PWRCTRL_MASK));
+}
+
+/**
+  * @brief  Enables or disables the SDIO interrupts.
+  * @param  SDIO_IT: specifies the SDIO interrupt sources to be enabled or disabled.
+  *   This parameter can be one or a combination of the following values:
+  *     @arg SDIO_IT_CCRCFAIL: Command response received (CRC check failed) interrupt
+  *     @arg SDIO_IT_DCRCFAIL: Data block sent/received (CRC check failed) interrupt
+  *     @arg SDIO_IT_CTIMEOUT: Command response timeout interrupt
+  *     @arg SDIO_IT_DTIMEOUT: Data timeout interrupt
+  *     @arg SDIO_IT_TXUNDERR: Transmit FIFO underrun error interrupt
+  *     @arg SDIO_IT_RXOVERR:  Received FIFO overrun error interrupt
+  *     @arg SDIO_IT_CMDREND:  Command response received (CRC check passed) interrupt
+  *     @arg SDIO_IT_CMDSENT:  Command sent (no response required) interrupt
+  *     @arg SDIO_IT_DATAEND:  Data end (data counter, SDIDCOUNT, is zero) interrupt
+  *     @arg SDIO_IT_STBITERR: Start bit not detected on all data signals in wide 
+  *                            bus mode interrupt
+  *     @arg SDIO_IT_DBCKEND:  Data block sent/received (CRC check passed) interrupt
+  *     @arg SDIO_IT_CMDACT:   Command transfer in progress interrupt
+  *     @arg SDIO_IT_TXACT:    Data transmit in progress interrupt
+  *     @arg SDIO_IT_RXACT:    Data receive in progress interrupt
+  *     @arg SDIO_IT_TXFIFOHE: Transmit FIFO Half Empty interrupt
+  *     @arg SDIO_IT_RXFIFOHF: Receive FIFO Half Full interrupt
+  *     @arg SDIO_IT_TXFIFOF:  Transmit FIFO full interrupt
+  *     @arg SDIO_IT_RXFIFOF:  Receive FIFO full interrupt
+  *     @arg SDIO_IT_TXFIFOE:  Transmit FIFO empty interrupt
+  *     @arg SDIO_IT_RXFIFOE:  Receive FIFO empty interrupt
+  *     @arg SDIO_IT_TXDAVL:   Data available in transmit FIFO interrupt
+  *     @arg SDIO_IT_RXDAVL:   Data available in receive FIFO interrupt
+  *     @arg SDIO_IT_SDIOIT:   SD I/O interrupt received interrupt
+  *     @arg SDIO_IT_CEATAEND: CE-ATA command completion signal received for CMD61 interrupt
+  * @param  NewState: new state of the specified SDIO interrupts.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None 
+  */
+void SDIO_ITConfig(uint32_t SDIO_IT, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_SDIO_IT(SDIO_IT));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the SDIO interrupts */
+    SDIO-&gt;MASK |= SDIO_IT;
+  }
+  else
+  {
+    /* Disable the SDIO interrupts */
+    SDIO-&gt;MASK &amp;= ~SDIO_IT;
+  } 
+}
+
+/**
+  * @brief  Enables or disables the SDIO DMA request.
+  * @param  NewState: new state of the selected SDIO DMA request.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void SDIO_DMACmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  *(__IO uint32_t *) DCTRL_DMAEN_BB = (uint32_t)NewState;
+}
+
+/**
+  * @brief  Initializes the SDIO Command according to the specified 
+  *   parameters in the SDIO_CmdInitStruct and send the command.
+  * @param  SDIO_CmdInitStruct : pointer to a SDIO_CmdInitTypeDef 
+  *   structure that contains the configuration information for the SDIO command.
+  * @retval None
+  */
+void SDIO_SendCommand(SDIO_CmdInitTypeDef *SDIO_CmdInitStruct)
+{
+  uint32_t tmpreg = 0;
+  
+  /* Check the parameters */
+  assert_param(IS_SDIO_CMD_INDEX(SDIO_CmdInitStruct-&gt;SDIO_CmdIndex));
+  assert_param(IS_SDIO_RESPONSE(SDIO_CmdInitStruct-&gt;SDIO_Response));
+  assert_param(IS_SDIO_WAIT(SDIO_CmdInitStruct-&gt;SDIO_Wait));
+  assert_param(IS_SDIO_CPSM(SDIO_CmdInitStruct-&gt;SDIO_CPSM));
+  
+/*---------------------------- SDIO ARG Configuration ------------------------*/
+  /* Set the SDIO Argument value */
+  SDIO-&gt;ARG = SDIO_CmdInitStruct-&gt;SDIO_Argument;
+  
+/*---------------------------- SDIO CMD Configuration ------------------------*/  
+  /* Get the SDIO CMD value */
+  tmpreg = SDIO-&gt;CMD;
+  /* Clear CMDINDEX, WAITRESP, WAITINT, WAITPEND, CPSMEN bits */
+  tmpreg &amp;= CMD_CLEAR_MASK;
+  /* Set CMDINDEX bits according to SDIO_CmdIndex value */
+  /* Set WAITRESP bits according to SDIO_Response value */
+  /* Set WAITINT and WAITPEND bits according to SDIO_Wait value */
+  /* Set CPSMEN bits according to SDIO_CPSM value */
+  tmpreg |= (uint32_t)SDIO_CmdInitStruct-&gt;SDIO_CmdIndex | SDIO_CmdInitStruct-&gt;SDIO_Response
+           | SDIO_CmdInitStruct-&gt;SDIO_Wait | SDIO_CmdInitStruct-&gt;SDIO_CPSM;
+  
+  /* Write to SDIO CMD */
+  SDIO-&gt;CMD = tmpreg;
+}
+
+/**
+  * @brief  Fills each SDIO_CmdInitStruct member with its default value.
+  * @param  SDIO_CmdInitStruct: pointer to an SDIO_CmdInitTypeDef 
+  *   structure which will be initialized.
+  * @retval None
+  */
+void SDIO_CmdStructInit(SDIO_CmdInitTypeDef* SDIO_CmdInitStruct)
+{
+  /* SDIO_CmdInitStruct members default value */
+  SDIO_CmdInitStruct-&gt;SDIO_Argument = 0x00;
+  SDIO_CmdInitStruct-&gt;SDIO_CmdIndex = 0x00;
+  SDIO_CmdInitStruct-&gt;SDIO_Response = SDIO_Response_No;
+  SDIO_CmdInitStruct-&gt;SDIO_Wait = SDIO_Wait_No;
+  SDIO_CmdInitStruct-&gt;SDIO_CPSM = SDIO_CPSM_Disable;
+}
+
+/**
+  * @brief  Returns command index of last command for which response received.
+  * @param  None
+  * @retval Returns the command index of the last command response received.
+  */
+uint8_t SDIO_GetCommandResponse(void)
+{
+  return (uint8_t)(SDIO-&gt;RESPCMD);
+}
+
+/**
+  * @brief  Returns response received from the card for the last command.
+  * @param  SDIO_RESP: Specifies the SDIO response register. 
+  *   This parameter can be one of the following values:
+  *     @arg SDIO_RESP1: Response Register 1
+  *     @arg SDIO_RESP2: Response Register 2
+  *     @arg SDIO_RESP3: Response Register 3
+  *     @arg SDIO_RESP4: Response Register 4
+  * @retval The Corresponding response register value.
+  */
+uint32_t SDIO_GetResponse(uint32_t SDIO_RESP)
+{
+  __IO uint32_t tmp = 0;
+
+  /* Check the parameters */
+  assert_param(IS_SDIO_RESP(SDIO_RESP));
+
+  tmp = SDIO_RESP_ADDR + SDIO_RESP;
+  
+  return (*(__IO uint32_t *) tmp); 
+}
+
+/**
+  * @brief  Initializes the SDIO data path according to the specified 
+  *   parameters in the SDIO_DataInitStruct.
+  * @param  SDIO_DataInitStruct : pointer to a SDIO_DataInitTypeDef structure that
+  *   contains the configuration information for the SDIO command.
+  * @retval None
+  */
+void SDIO_DataConfig(SDIO_DataInitTypeDef* SDIO_DataInitStruct)
+{
+  uint32_t tmpreg = 0;
+  
+  /* Check the parameters */
+  assert_param(IS_SDIO_DATA_LENGTH(SDIO_DataInitStruct-&gt;SDIO_DataLength));
+  assert_param(IS_SDIO_BLOCK_SIZE(SDIO_DataInitStruct-&gt;SDIO_DataBlockSize));
+  assert_param(IS_SDIO_TRANSFER_DIR(SDIO_DataInitStruct-&gt;SDIO_TransferDir));
+  assert_param(IS_SDIO_TRANSFER_MODE(SDIO_DataInitStruct-&gt;SDIO_TransferMode));
+  assert_param(IS_SDIO_DPSM(SDIO_DataInitStruct-&gt;SDIO_DPSM));
+
+/*---------------------------- SDIO DTIMER Configuration ---------------------*/
+  /* Set the SDIO Data TimeOut value */
+  SDIO-&gt;DTIMER = SDIO_DataInitStruct-&gt;SDIO_DataTimeOut;
+
+/*---------------------------- SDIO DLEN Configuration -----------------------*/
+  /* Set the SDIO DataLength value */
+  SDIO-&gt;DLEN = SDIO_DataInitStruct-&gt;SDIO_DataLength;
+
+/*---------------------------- SDIO DCTRL Configuration ----------------------*/  
+  /* Get the SDIO DCTRL value */
+  tmpreg = SDIO-&gt;DCTRL;
+  /* Clear DEN, DTMODE, DTDIR and DBCKSIZE bits */
+  tmpreg &amp;= DCTRL_CLEAR_MASK;
+  /* Set DEN bit according to SDIO_DPSM value */
+  /* Set DTMODE bit according to SDIO_TransferMode value */
+  /* Set DTDIR bit according to SDIO_TransferDir value */
+  /* Set DBCKSIZE bits according to SDIO_DataBlockSize value */
+  tmpreg |= (uint32_t)SDIO_DataInitStruct-&gt;SDIO_DataBlockSize | SDIO_DataInitStruct-&gt;SDIO_TransferDir
+           | SDIO_DataInitStruct-&gt;SDIO_TransferMode | SDIO_DataInitStruct-&gt;SDIO_DPSM;
+
+  /* Write to SDIO DCTRL */
+  SDIO-&gt;DCTRL = tmpreg;
+}
+
+/**
+  * @brief  Fills each SDIO_DataInitStruct member with its default value.
+  * @param  SDIO_DataInitStruct: pointer to an SDIO_DataInitTypeDef structure which
+  *   will be initialized.
+  * @retval None
+  */
+void SDIO_DataStructInit(SDIO_DataInitTypeDef* SDIO_DataInitStruct)
+{
+  /* SDIO_DataInitStruct members default value */
+  SDIO_DataInitStruct-&gt;SDIO_DataTimeOut = 0xFFFFFFFF;
+  SDIO_DataInitStruct-&gt;SDIO_DataLength = 0x00;
+  SDIO_DataInitStruct-&gt;SDIO_DataBlockSize = SDIO_DataBlockSize_1b;
+  SDIO_DataInitStruct-&gt;SDIO_TransferDir = SDIO_TransferDir_ToCard;
+  SDIO_DataInitStruct-&gt;SDIO_TransferMode = SDIO_TransferMode_Block;  
+  SDIO_DataInitStruct-&gt;SDIO_DPSM = SDIO_DPSM_Disable;
+}
+
+/**
+  * @brief  Returns number of remaining data bytes to be transferred.
+  * @param  None
+  * @retval Number of remaining data bytes to be transferred
+  */
+uint32_t SDIO_GetDataCounter(void)
+{ 
+  return SDIO-&gt;DCOUNT;
+}
+
+/**
+  * @brief  Read one data word from Rx FIFO.
+  * @param  None
+  * @retval Data received
+  */
+uint32_t SDIO_ReadData(void)
+{ 
+  return SDIO-&gt;FIFO;
+}
+
+/**
+  * @brief  Write one data word to Tx FIFO.
+  * @param  Data: 32-bit data word to write.
+  * @retval None
+  */
+void SDIO_WriteData(uint32_t Data)
+{ 
+  SDIO-&gt;FIFO = Data;
+}
+
+/**
+  * @brief  Returns the number of words left to be written to or read from FIFO.	
+  * @param  None
+  * @retval Remaining number of words.
+  */
+uint32_t SDIO_GetFIFOCount(void)
+{ 
+  return SDIO-&gt;FIFOCNT;
+}
+
+/**
+  * @brief  Starts the SD I/O Read Wait operation.	
+  * @param  NewState: new state of the Start SDIO Read Wait operation. 
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void SDIO_StartSDIOReadWait(FunctionalState NewState)
+{ 
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  *(__IO uint32_t *) DCTRL_RWSTART_BB = (uint32_t) NewState;
+}
+
+/**
+  * @brief  Stops the SD I/O Read Wait operation.	
+  * @param  NewState: new state of the Stop SDIO Read Wait operation. 
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void SDIO_StopSDIOReadWait(FunctionalState NewState)
+{ 
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  *(__IO uint32_t *) DCTRL_RWSTOP_BB = (uint32_t) NewState;
+}
+
+/**
+  * @brief  Sets one of the two options of inserting read wait interval.
+  * @param  SDIO_ReadWaitMode: SD I/O Read Wait operation mode.
+  *   This parametre can be:
+  *     @arg SDIO_ReadWaitMode_CLK: Read Wait control by stopping SDIOCLK
+  *     @arg SDIO_ReadWaitMode_DATA2: Read Wait control using SDIO_DATA2
+  * @retval None
+  */
+void SDIO_SetSDIOReadWaitMode(uint32_t SDIO_ReadWaitMode)
+{
+  /* Check the parameters */
+  assert_param(IS_SDIO_READWAIT_MODE(SDIO_ReadWaitMode));
+  
+  *(__IO uint32_t *) DCTRL_RWMOD_BB = SDIO_ReadWaitMode;
+}
+
+/**
+  * @brief  Enables or disables the SD I/O Mode Operation.
+  * @param  NewState: new state of SDIO specific operation. 
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void SDIO_SetSDIOOperation(FunctionalState NewState)
+{ 
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  *(__IO uint32_t *) DCTRL_SDIOEN_BB = (uint32_t)NewState;
+}
+
+/**
+  * @brief  Enables or disables the SD I/O Mode suspend command sending.
+  * @param  NewState: new state of the SD I/O Mode suspend command.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void SDIO_SendSDIOSuspendCmd(FunctionalState NewState)
+{ 
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  *(__IO uint32_t *) CMD_SDIOSUSPEND_BB = (uint32_t)NewState;
+}
+
+/**
+  * @brief  Enables or disables the command completion signal.
+  * @param  NewState: new state of command completion signal. 
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void SDIO_CommandCompletionCmd(FunctionalState NewState)
+{ 
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  *(__IO uint32_t *) CMD_ENCMDCOMPL_BB = (uint32_t)NewState;
+}
+
+/**
+  * @brief  Enables or disables the CE-ATA interrupt.
+  * @param  NewState: new state of CE-ATA interrupt. This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void SDIO_CEATAITCmd(FunctionalState NewState)
+{ 
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  *(__IO uint32_t *) CMD_NIEN_BB = (uint32_t)((~((uint32_t)NewState)) &amp; ((uint32_t)0x1));
+}
+
+/**
+  * @brief  Sends CE-ATA command (CMD61).
+  * @param  NewState: new state of CE-ATA command. This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void SDIO_SendCEATACmd(FunctionalState NewState)
+{ 
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  *(__IO uint32_t *) CMD_ATACMD_BB = (uint32_t)NewState;
+}
+
+/**
+  * @brief  Checks whether the specified SDIO flag is set or not.
+  * @param  SDIO_FLAG: specifies the flag to check. 
+  *   This parameter can be one of the following values:
+  *     @arg SDIO_FLAG_CCRCFAIL: Command response received (CRC check failed)
+  *     @arg SDIO_FLAG_DCRCFAIL: Data block sent/received (CRC check failed)
+  *     @arg SDIO_FLAG_CTIMEOUT: Command response timeout
+  *     @arg SDIO_FLAG_DTIMEOUT: Data timeout
+  *     @arg SDIO_FLAG_TXUNDERR: Transmit FIFO underrun error
+  *     @arg SDIO_FLAG_RXOVERR:  Received FIFO overrun error
+  *     @arg SDIO_FLAG_CMDREND:  Command response received (CRC check passed)
+  *     @arg SDIO_FLAG_CMDSENT:  Command sent (no response required)
+  *     @arg SDIO_FLAG_DATAEND:  Data end (data counter, SDIDCOUNT, is zero)
+  *     @arg SDIO_FLAG_STBITERR: Start bit not detected on all data signals in wide 
+  *                              bus mode.
+  *     @arg SDIO_FLAG_DBCKEND:  Data block sent/received (CRC check passed)
+  *     @arg SDIO_FLAG_CMDACT:   Command transfer in progress
+  *     @arg SDIO_FLAG_TXACT:    Data transmit in progress
+  *     @arg SDIO_FLAG_RXACT:    Data receive in progress
+  *     @arg SDIO_FLAG_TXFIFOHE: Transmit FIFO Half Empty
+  *     @arg SDIO_FLAG_RXFIFOHF: Receive FIFO Half Full
+  *     @arg SDIO_FLAG_TXFIFOF:  Transmit FIFO full
+  *     @arg SDIO_FLAG_RXFIFOF:  Receive FIFO full
+  *     @arg SDIO_FLAG_TXFIFOE:  Transmit FIFO empty
+  *     @arg SDIO_FLAG_RXFIFOE:  Receive FIFO empty
+  *     @arg SDIO_FLAG_TXDAVL:   Data available in transmit FIFO
+  *     @arg SDIO_FLAG_RXDAVL:   Data available in receive FIFO
+  *     @arg SDIO_FLAG_SDIOIT:   SD I/O interrupt received
+  *     @arg SDIO_FLAG_CEATAEND: CE-ATA command completion signal received for CMD61
+  * @retval The new state of SDIO_FLAG (SET or RESET).
+  */
+FlagStatus SDIO_GetFlagStatus(uint32_t SDIO_FLAG)
+{ 
+  FlagStatus bitstatus = RESET;
+  
+  /* Check the parameters */
+  assert_param(IS_SDIO_FLAG(SDIO_FLAG));
+  
+  if ((SDIO-&gt;STA &amp; SDIO_FLAG) != (uint32_t)RESET)
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  return bitstatus;
+}
+
+/**
+  * @brief  Clears the SDIO's pending flags.
+  * @param  SDIO_FLAG: specifies the flag to clear.  
+  *   This parameter can be one or a combination of the following values:
+  *     @arg SDIO_FLAG_CCRCFAIL: Command response received (CRC check failed)
+  *     @arg SDIO_FLAG_DCRCFAIL: Data block sent/received (CRC check failed)
+  *     @arg SDIO_FLAG_CTIMEOUT: Command response timeout
+  *     @arg SDIO_FLAG_DTIMEOUT: Data timeout
+  *     @arg SDIO_FLAG_TXUNDERR: Transmit FIFO underrun error
+  *     @arg SDIO_FLAG_RXOVERR:  Received FIFO overrun error
+  *     @arg SDIO_FLAG_CMDREND:  Command response received (CRC check passed)
+  *     @arg SDIO_FLAG_CMDSENT:  Command sent (no response required)
+  *     @arg SDIO_FLAG_DATAEND:  Data end (data counter, SDIDCOUNT, is zero)
+  *     @arg SDIO_FLAG_STBITERR: Start bit not detected on all data signals in wide 
+  *                              bus mode
+  *     @arg SDIO_FLAG_DBCKEND:  Data block sent/received (CRC check passed)
+  *     @arg SDIO_FLAG_SDIOIT:   SD I/O interrupt received
+  *     @arg SDIO_FLAG_CEATAEND: CE-ATA command completion signal received for CMD61
+  * @retval None
+  */
+void SDIO_ClearFlag(uint32_t SDIO_FLAG)
+{ 
+  /* Check the parameters */
+  assert_param(IS_SDIO_CLEAR_FLAG(SDIO_FLAG));
+   
+  SDIO-&gt;ICR = SDIO_FLAG;
+}
+
+/**
+  * @brief  Checks whether the specified SDIO interrupt has occurred or not.
+  * @param  SDIO_IT: specifies the SDIO interrupt source to check. 
+  *   This parameter can be one of the following values:
+  *     @arg SDIO_IT_CCRCFAIL: Command response received (CRC check failed) interrupt
+  *     @arg SDIO_IT_DCRCFAIL: Data block sent/received (CRC check failed) interrupt
+  *     @arg SDIO_IT_CTIMEOUT: Command response timeout interrupt
+  *     @arg SDIO_IT_DTIMEOUT: Data timeout interrupt
+  *     @arg SDIO_IT_TXUNDERR: Transmit FIFO underrun error interrupt
+  *     @arg SDIO_IT_RXOVERR:  Received FIFO overrun error interrupt
+  *     @arg SDIO_IT_CMDREND:  Command response received (CRC check passed) interrupt
+  *     @arg SDIO_IT_CMDSENT:  Command sent (no response required) interrupt
+  *     @arg SDIO_IT_DATAEND:  Data end (data counter, SDIDCOUNT, is zero) interrupt
+  *     @arg SDIO_IT_STBITERR: Start bit not detected on all data signals in wide 
+  *                            bus mode interrupt
+  *     @arg SDIO_IT_DBCKEND:  Data block sent/received (CRC check passed) interrupt
+  *     @arg SDIO_IT_CMDACT:   Command transfer in progress interrupt
+  *     @arg SDIO_IT_TXACT:    Data transmit in progress interrupt
+  *     @arg SDIO_IT_RXACT:    Data receive in progress interrupt
+  *     @arg SDIO_IT_TXFIFOHE: Transmit FIFO Half Empty interrupt
+  *     @arg SDIO_IT_RXFIFOHF: Receive FIFO Half Full interrupt
+  *     @arg SDIO_IT_TXFIFOF:  Transmit FIFO full interrupt
+  *     @arg SDIO_IT_RXFIFOF:  Receive FIFO full interrupt
+  *     @arg SDIO_IT_TXFIFOE:  Transmit FIFO empty interrupt
+  *     @arg SDIO_IT_RXFIFOE:  Receive FIFO empty interrupt
+  *     @arg SDIO_IT_TXDAVL:   Data available in transmit FIFO interrupt
+  *     @arg SDIO_IT_RXDAVL:   Data available in receive FIFO interrupt
+  *     @arg SDIO_IT_SDIOIT:   SD I/O interrupt received interrupt
+  *     @arg SDIO_IT_CEATAEND: CE-ATA command completion signal received for CMD61 interrupt
+  * @retval The new state of SDIO_IT (SET or RESET).
+  */
+ITStatus SDIO_GetITStatus(uint32_t SDIO_IT)
+{ 
+  ITStatus bitstatus = RESET;
+  
+  /* Check the parameters */
+  assert_param(IS_SDIO_GET_IT(SDIO_IT));
+  if ((SDIO-&gt;STA &amp; SDIO_IT) != (uint32_t)RESET)  
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  return bitstatus;
+}
+
+/**
+  * @brief  Clears the SDIO&#146;s interrupt pending bits.
+  * @param  SDIO_IT: specifies the interrupt pending bit to clear. 
+  *   This parameter can be one or a combination of the following values:
+  *     @arg SDIO_IT_CCRCFAIL: Command response received (CRC check failed) interrupt
+  *     @arg SDIO_IT_DCRCFAIL: Data block sent/received (CRC check failed) interrupt
+  *     @arg SDIO_IT_CTIMEOUT: Command response timeout interrupt
+  *     @arg SDIO_IT_DTIMEOUT: Data timeout interrupt
+  *     @arg SDIO_IT_TXUNDERR: Transmit FIFO underrun error interrupt
+  *     @arg SDIO_IT_RXOVERR:  Received FIFO overrun error interrupt
+  *     @arg SDIO_IT_CMDREND:  Command response received (CRC check passed) interrupt
+  *     @arg SDIO_IT_CMDSENT:  Command sent (no response required) interrupt
+  *     @arg SDIO_IT_DATAEND:  Data end (data counter, SDIDCOUNT, is zero) interrupt
+  *     @arg SDIO_IT_STBITERR: Start bit not detected on all data signals in wide 
+  *                            bus mode interrupt
+  *     @arg SDIO_IT_SDIOIT:   SD I/O interrupt received interrupt
+  *     @arg SDIO_IT_CEATAEND: CE-ATA command completion signal received for CMD61
+  * @retval None
+  */
+void SDIO_ClearITPendingBit(uint32_t SDIO_IT)
+{ 
+  /* Check the parameters */
+  assert_param(IS_SDIO_CLEAR_IT(SDIO_IT));
+   
+  SDIO-&gt;ICR = SDIO_IT;
+}
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2009 STMicroelectronics *****END OF FILE****/

Added: trunk/src/platform/stm32/FWLib/library/src/stm32f10x_sdio.o
===================================================================
--- trunk/src/platform/stm32/FWLib/library/src/stm32f10x_sdio.o	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/src/stm32f10x_sdio.o	2009-07-08 23:39:34 UTC (rev 354)
@@ -0,0 +1,6 @@
+ELF
+M	

+
+
+
+
\ No newline at end of file

Modified: trunk/src/platform/stm32/FWLib/library/src/stm32f10x_spi.c
===================================================================
--- trunk/src/platform/stm32/FWLib/library/src/stm32f10x_spi.c	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/src/stm32f10x_spi.c	2009-07-08 23:39:34 UTC (rev 354)
@@ -1,863 +1,907 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_spi.c
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file provides all the SPI firmware functions.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
-
-/* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_spi.h&quot;
-#include &quot;stm32f10x_rcc.h&quot;
-
-/* Private typedef -----------------------------------------------------------*/
-/* Private define ------------------------------------------------------------*/
-/* SPI SPE mask */
-#define CR1_SPE_Set          ((u16)0x0040)
-#define CR1_SPE_Reset        ((u16)0xFFBF)
-
-/* I2S I2SE mask */
-#define I2SCFGR_I2SE_Set     ((u16)0x0400)
-#define I2SCFGR_I2SE_Reset   ((u16)0xFBFF)
-
-/* SPI CRCNext mask */
-#define CR1_CRCNext_Set      ((u16)0x1000)
-
-/* SPI CRCEN mask */
-#define CR1_CRCEN_Set        ((u16)0x2000)
-#define CR1_CRCEN_Reset      ((u16)0xDFFF)
-
-/* SPI SSOE mask */
-#define CR2_SSOE_Set         ((u16)0x0004)
-#define CR2_SSOE_Reset       ((u16)0xFFFB)
-
-/* SPI registers Masks */
-#define CR1_CLEAR_Mask       ((u16)0x3040)
-#define I2SCFGR_CLEAR_Mask   ((u16)0xF040)
-
-/* SPI or I2S mode selection masks */
-#define SPI_Mode_Select      ((u16)0xF7FF)
-#define I2S_Mode_Select      ((u16)0x0800) 
-
-/* Private macro -------------------------------------------------------------*/
-/* Private variables ---------------------------------------------------------*/
-/* Private function prototypes -----------------------------------------------*/
-/* Private functions ---------------------------------------------------------*/
-
-/*******************************************************************************
-* Function Name  : SPI_I2S_DeInit
-* Description    : Deinitializes the SPIx peripheral registers to their default
-*                  reset values (Affects also the I2Ss).
-* Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SPI_I2S_DeInit(SPI_TypeDef* SPIx)
-{
-  /* Check the parameters */
-  assert_param(IS_SPI_ALL_PERIPH(SPIx));
-  
-  switch (*(u32*)&amp;SPIx)
-  {
-    case SPI1_BASE:
-      /* Enable SPI1 reset state */
-      RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, ENABLE);
-      /* Release SPI1 from reset state */
-      RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, DISABLE);
-      break;
-
-    case SPI2_BASE:
-      /* Enable SPI2 reset state */
-      RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, ENABLE);
-      /* Release SPI2 from reset state */
-      RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, DISABLE);
-      break;
-
-    case SPI3_BASE:
-      /* Enable SPI3 reset state */
-      RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE);
-      /* Release SPI3 from reset state */
-      RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, DISABLE);
-      break;
-
-    default:
-      break;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : SPI_Init
-* Description    : Initializes the SPIx peripheral according to the specified 
-*                  parameters in the SPI_InitStruct.
-* Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
-*                  - SPI_InitStruct: pointer to a SPI_InitTypeDef structure that
-*                    contains the configuration information for the specified
-*                    SPI peripheral.
-* Output         : None
-* Return         : None
-******************************************************************************/
-void SPI_Init(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct)
-{
-  u16 tmpreg = 0;
-  
-  /* check the parameters */
-  assert_param(IS_SPI_ALL_PERIPH(SPIx));   
-  
-  /* Check the SPI parameters */
-  assert_param(IS_SPI_DIRECTION_MODE(SPI_InitStruct-&gt;SPI_Direction));
-  assert_param(IS_SPI_MODE(SPI_InitStruct-&gt;SPI_Mode));
-  assert_param(IS_SPI_DATASIZE(SPI_InitStruct-&gt;SPI_DataSize));
-  assert_param(IS_SPI_CPOL(SPI_InitStruct-&gt;SPI_CPOL));
-  assert_param(IS_SPI_CPHA(SPI_InitStruct-&gt;SPI_CPHA));
-  assert_param(IS_SPI_NSS(SPI_InitStruct-&gt;SPI_NSS));
-  assert_param(IS_SPI_BAUDRATE_PRESCALER(SPI_InitStruct-&gt;SPI_BaudRatePrescaler));
-  assert_param(IS_SPI_FIRST_BIT(SPI_InitStruct-&gt;SPI_FirstBit));
-  assert_param(IS_SPI_CRC_POLYNOMIAL(SPI_InitStruct-&gt;SPI_CRCPolynomial));
-
-/*---------------------------- SPIx CR1 Configuration ------------------------*/
-  /* Get the SPIx CR1 value */
-  tmpreg = SPIx-&gt;CR1;
-  /* Clear BIDIMode, BIDIOE, RxONLY, SSM, SSI, LSBFirst, BR, MSTR, CPOL and CPHA bits */
-  tmpreg &amp;= CR1_CLEAR_Mask;
-  /* Configure SPIx: direction, NSS management, first transmitted bit, BaudRate prescaler
-     master/salve mode, CPOL and CPHA */
-  /* Set BIDImode, BIDIOE and RxONLY bits according to SPI_Direction value */
-  /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
-  /* Set LSBFirst bit according to SPI_FirstBit value */
-  /* Set BR bits according to SPI_BaudRatePrescaler value */
-  /* Set CPOL bit according to SPI_CPOL value */
-  /* Set CPHA bit according to SPI_CPHA value */
-  tmpreg |= (u16)((u32)SPI_InitStruct-&gt;SPI_Direction | SPI_InitStruct-&gt;SPI_Mode |
-                  SPI_InitStruct-&gt;SPI_DataSize | SPI_InitStruct-&gt;SPI_CPOL |  
-                  SPI_InitStruct-&gt;SPI_CPHA | SPI_InitStruct-&gt;SPI_NSS |  
-                  SPI_InitStruct-&gt;SPI_BaudRatePrescaler | SPI_InitStruct-&gt;SPI_FirstBit);
-  /* Write to SPIx CR1 */
-  SPIx-&gt;CR1 = tmpreg;
-  
-  /* Activate the SPI mode (Reset I2SMOD bit in I2SCFGR register) */
-  SPIx-&gt;I2SCFGR &amp;= SPI_Mode_Select;		
-
-/*---------------------------- SPIx CRCPOLY Configuration --------------------*/
-  /* Write to SPIx CRCPOLY */
-  SPIx-&gt;CRCPR = SPI_InitStruct-&gt;SPI_CRCPolynomial;
-}
-
-/*******************************************************************************
-* Function Name  : I2S_Init
-* Description    : Initializes the SPIx peripheral according to the specified 
-*                  parameters in the I2S_InitStruct.
-* Input          : - SPIx: where x can be  2 or 3 to select the SPI peripheral
-*                     (configured in I2S mode).
-*                  - I2S_InitStruct: pointer to an I2S_InitTypeDef structure that
-*                    contains the configuration information for the specified
-*                    SPI peripheral configured in I2S mode.
-* Output         : None
-* Return         : None
-******************************************************************************/
-void I2S_Init(SPI_TypeDef* SPIx, I2S_InitTypeDef* I2S_InitStruct)
-{
-  u16 tmpreg = 0, i2sdiv = 2, i2sodd = 0, packetlength = 1;
-  u32 tmp = 0;
-  RCC_ClocksTypeDef RCC_Clocks;
-   
-  /* Check the I2S parameters */
-  assert_param(IS_SPI_23_PERIPH(SPIx));
-  assert_param(IS_I2S_MODE(I2S_InitStruct-&gt;I2S_Mode));
-  assert_param(IS_I2S_STANDARD(I2S_InitStruct-&gt;I2S_Standard));
-  assert_param(IS_I2S_DATA_FORMAT(I2S_InitStruct-&gt;I2S_DataFormat));
-  assert_param(IS_I2S_MCLK_OUTPUT(I2S_InitStruct-&gt;I2S_MCLKOutput));
-  assert_param(IS_I2S_AUDIO_FREQ(I2S_InitStruct-&gt;I2S_AudioFreq));
-  assert_param(IS_I2S_CPOL(I2S_InitStruct-&gt;I2S_CPOL));  
-
-/*----------------------- SPIx I2SCFGR &amp; I2SPR Configuration -----------------*/
-
-  /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
-  SPIx-&gt;I2SCFGR &amp;= I2SCFGR_CLEAR_Mask; 
-  SPIx-&gt;I2SPR = 0x0002;
-  
-  /* Get the I2SCFGR register value */
-  tmpreg = SPIx-&gt;I2SCFGR;
-  
-  /* If the default value has to be written, reinitialize i2sdiv and i2sodd*/
-  if(I2S_InitStruct-&gt;I2S_AudioFreq == I2S_AudioFreq_Default)
-  {
-    i2sodd = (u16)0;
-    i2sdiv = (u16)2;   
-  }
-  /* If the requested audio frequency is not the default, compute the prescaler */
-  else
-  {
-    /* Check the frame length (For the Prescaler computing) */
-    if(I2S_InitStruct-&gt;I2S_DataFormat == I2S_DataFormat_16b)
-    {
-      /* Packet length is 16 bits */
-      packetlength = 1;
-    }
-    else
-    {
-      /* Packet length is 32 bits */
-      packetlength = 2;
-    }
-    /* Get System Clock frequency */
-    RCC_GetClocksFreq(&amp;RCC_Clocks);
-    
-    /* Compute the Real divider depending on the MCLK output state with a flaoting point */
-    if(I2S_InitStruct-&gt;I2S_MCLKOutput == I2S_MCLKOutput_Enable)
-    {
-      /* MCLK output is enabled */
-      tmp = (u16)(((10 * RCC_Clocks.SYSCLK_Frequency) / (256 * I2S_InitStruct-&gt;I2S_AudioFreq)) + 5);
-    }
-    else
-    {
-      /* MCLK output is disabled */
-      tmp = (u16)(((10 * RCC_Clocks.SYSCLK_Frequency) / (32 * packetlength * I2S_InitStruct-&gt;I2S_AudioFreq)) + 5);
-    }
-    
-    /* Remove the flaoting point */
-    tmp = tmp/10;  
-      
-    /* Check the parity of the divider */
-    i2sodd = (u16)(tmp &amp; (u16)0x0001);
-   
-    /* Compute the i2sdiv prescaler */
-    i2sdiv = (u16)((tmp - i2sodd) / 2);
-   
-    /* Get the Mask for the Odd bit (SPI_I2SPR[8]) register */
-    i2sodd = (u16) (i2sodd &lt;&lt; 8);
-  }
-  
-  /* Test if the divider is 1 or 0 */
-  if ((i2sdiv &lt; 2) || (i2sdiv &gt; 0xFF))
-  {
-    /* Set the default values */
-    i2sdiv = 2;
-    i2sodd = 0;
-  }
-
-  /* Write to SPIx I2SPR register the computed value */
-  SPIx-&gt;I2SPR = (u16)(i2sdiv | i2sodd | I2S_InitStruct-&gt;I2S_MCLKOutput);  
- 
-  /* Configure the I2S with the SPI_InitStruct values */
-  tmpreg |= (u16)(I2S_Mode_Select | I2S_InitStruct-&gt;I2S_Mode | \
-                  I2S_InitStruct-&gt;I2S_Standard | I2S_InitStruct-&gt;I2S_DataFormat | \
-                  I2S_InitStruct-&gt;I2S_CPOL);
- 
-  /* Write to SPIx I2SCFGR */  
-  SPIx-&gt;I2SCFGR = tmpreg;                                    
-}
-
-/*******************************************************************************
-* Function Name  : SPI_StructInit
-* Description    : Fills each SPI_InitStruct member with its default value.
-* Input          : - SPI_InitStruct : pointer to a SPI_InitTypeDef structure
-*                    which will be initialized.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SPI_StructInit(SPI_InitTypeDef* SPI_InitStruct)
-{
-/*--------------- Reset SPI init structure parameters values -----------------*/
-  /* Initialize the SPI_Direction member */
-  SPI_InitStruct-&gt;SPI_Direction = SPI_Direction_2Lines_FullDuplex;
-
-  /* initialize the SPI_Mode member */
-  SPI_InitStruct-&gt;SPI_Mode = SPI_Mode_Slave;
-
-  /* initialize the SPI_DataSize member */
-  SPI_InitStruct-&gt;SPI_DataSize = SPI_DataSize_8b;
-
-  /* Initialize the SPI_CPOL member */
-  SPI_InitStruct-&gt;SPI_CPOL = SPI_CPOL_Low;
-
-  /* Initialize the SPI_CPHA member */
-  SPI_InitStruct-&gt;SPI_CPHA = SPI_CPHA_1Edge;
-
-  /* Initialize the SPI_NSS member */
-  SPI_InitStruct-&gt;SPI_NSS = SPI_NSS_Hard;
-
-  /* Initialize the SPI_BaudRatePrescaler member */
-  SPI_InitStruct-&gt;SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;
-
-  /* Initialize the SPI_FirstBit member */
-  SPI_InitStruct-&gt;SPI_FirstBit = SPI_FirstBit_MSB;
-
-  /* Initialize the SPI_CRCPolynomial member */
-  SPI_InitStruct-&gt;SPI_CRCPolynomial = 7;
-}
-
-/*******************************************************************************
-* Function Name  : I2S_StructInit
-* Description    : Fills each I2S_InitStruct member with its default value.
-* Input          : - I2S_InitStruct : pointer to a I2S_InitTypeDef structure
-*                    which will be initialized.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void I2S_StructInit(I2S_InitTypeDef* I2S_InitStruct)
-{
-/*--------------- Reset I2S init structure parameters values -----------------*/
-  /* Initialize the I2S_Mode member */
-  I2S_InitStruct-&gt;I2S_Mode = I2S_Mode_SlaveTx;
-  
-  /* Initialize the I2S_Standard member */
-  I2S_InitStruct-&gt;I2S_Standard = I2S_Standard_Phillips;
-  
-  /* Initialize the I2S_DataFormat member */
-  I2S_InitStruct-&gt;I2S_DataFormat = I2S_DataFormat_16b;
-  
-  /* Initialize the I2S_MCLKOutput member */
-  I2S_InitStruct-&gt;I2S_MCLKOutput = I2S_MCLKOutput_Disable;
-  
-  /* Initialize the I2S_AudioFreq member */
-  I2S_InitStruct-&gt;I2S_AudioFreq = I2S_AudioFreq_Default;
-  
-  /* Initialize the I2S_CPOL member */
-  I2S_InitStruct-&gt;I2S_CPOL = I2S_CPOL_Low;
-}
-
-/*******************************************************************************
-* Function Name  : SPI_Cmd
-* Description    : Enables or disables the specified SPI peripheral.
-* Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
-*                  - NewState: new state of the SPIx peripheral. 
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SPI_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_SPI_ALL_PERIPH(SPIx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected SPI peripheral */
-    SPIx-&gt;CR1 |= CR1_SPE_Set;
-  }
-  else
-  {
-    /* Disable the selected SPI peripheral */
-    SPIx-&gt;CR1 &amp;= CR1_SPE_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : I2S_Cmd
-* Description    : Enables or disables the specified SPI peripheral (in I2S mode).
-* Input          : - SPIx: where x can be 2 or 3 to select the SPI peripheral.
-*                  - NewState: new state of the SPIx peripheral. 
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void I2S_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_SPI_23_PERIPH(SPIx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected SPI peripheral (in I2S mode) */
-    SPIx-&gt;I2SCFGR |= I2SCFGR_I2SE_Set;
-  }
-  else
-  {
-    /* Disable the selected SPI peripheral (in I2S mode) */
-    SPIx-&gt;I2SCFGR &amp;= I2SCFGR_I2SE_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : SPI_I2S_ITConfig
-* Description    : Enables or disables the specified SPI/I2S interrupts.
-* Input          : - SPIx: where x can be :
-*                         - 1, 2 or 3 in SPI mode 
-*                         - 2 or 3 in I2S mode
-*                  - SPI_I2S_IT: specifies the SPI/I2S interrupt source to be 
-*                    enabled or disabled. 
-*                    This parameter can be one of the following values:
-*                       - SPI_I2S_IT_TXE: Tx buffer empty interrupt mask
-*                       - SPI_I2S_IT_RXNE: Rx buffer not empty interrupt mask
-*                       - SPI_I2S_IT_ERR: Error interrupt mask
-*                  - NewState: new state of the specified SPI/I2S interrupt.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SPI_I2S_ITConfig(SPI_TypeDef* SPIx, u8 SPI_I2S_IT, FunctionalState NewState)
-{
-  u16 itpos = 0, itmask = 0 ;
-
-  /* Check the parameters */
-  assert_param(IS_SPI_ALL_PERIPH(SPIx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  assert_param(IS_SPI_I2S_CONFIG_IT(SPI_I2S_IT));
-
-  /* Get the SPI/I2S IT index */
-  itpos = SPI_I2S_IT &gt;&gt; 4;
-  /* Set the IT mask */
-  itmask = (u16)((u16)1 &lt;&lt; itpos);
-
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected SPI/I2S interrupt */
-    SPIx-&gt;CR2 |= itmask;
-  }
-  else
-  {
-    /* Disable the selected SPI/I2S interrupt */
-    SPIx-&gt;CR2 &amp;= (u16)~itmask;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : SPI_I2S_DMACmd
-* Description    : Enables or disables the SPIx/I2Sx DMA interface.
-* Input          : - SPIx: where x can be :
-*                         - 1, 2 or 3 in SPI mode 
-*                         - 2 or 3 in I2S mode
-*                  - SPI_I2S_DMAReq: specifies the SPI/I2S DMA transfer request 
-*                    to be enabled or disabled. 
-*                    This parameter can be any combination of the following values:
-*                       - SPI_I2S_DMAReq_Tx: Tx buffer DMA transfer request
-*                       - SPI_I2S_DMAReq_Rx: Rx buffer DMA transfer request
-*                  - NewState: new state of the selected SPI/I2S DMA transfer 
-*                    request.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SPI_I2S_DMACmd(SPI_TypeDef* SPIx, u16 SPI_I2S_DMAReq, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_SPI_ALL_PERIPH(SPIx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  assert_param(IS_SPI_I2S_DMAREQ(SPI_I2S_DMAReq));
-
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected SPI/I2S DMA requests */
-    SPIx-&gt;CR2 |= SPI_I2S_DMAReq;
-  }
-  else
-  {
-    /* Disable the selected SPI/I2S DMA requests */
-    SPIx-&gt;CR2 &amp;= (u16)~SPI_I2S_DMAReq;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : SPI_I2S_SendData
-* Description    : Transmits a Data through the SPIx/I2Sx peripheral.
-* Input          : - SPIx: where x can be :
-*                         - 1, 2 or 3 in SPI mode 
-*                         - 2 or 3 in I2S mode
-*                  - Data : Data to be transmitted..
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SPI_I2S_SendData(SPI_TypeDef* SPIx, u16 Data)
-{
-  /* Check the parameters */
-  assert_param(IS_SPI_ALL_PERIPH(SPIx));
-  
-  /* Write in the DR register the data to be sent */
-  SPIx-&gt;DR = Data;
-}
-
-/*******************************************************************************
-* Function Name  : SPI_I2S_ReceiveData
-* Description    : Returns the most recent received data by the SPIx/I2Sx peripheral. 
-* Input          : - SPIx: where x can be :
-*                         - 1, 2 or 3 in SPI mode 
-*                         - 2 or 3 in I2S mode
-* Output         : None
-* Return         : The value of the received data.
-*******************************************************************************/
-u16 SPI_I2S_ReceiveData(SPI_TypeDef* SPIx)
-{
-  /* Check the parameters */
-  assert_param(IS_SPI_ALL_PERIPH(SPIx));
-  
-  /* Return the data in the DR register */
-  return SPIx-&gt;DR;
-}
-
-/*******************************************************************************
-* Function Name  : SPI_NSSInternalSoftwareConfig
-* Description    : Configures internally by software the NSS pin for the selected 
-*                  SPI.
-* Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
-*                  - SPI_NSSInternalSoft: specifies the SPI NSS internal state.
-*                    This parameter can be one of the following values:
-*                       - SPI_NSSInternalSoft_Set: Set NSS pin internally
-*                       - SPI_NSSInternalSoft_Reset: Reset NSS pin internally
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SPI_NSSInternalSoftwareConfig(SPI_TypeDef* SPIx, u16 SPI_NSSInternalSoft)
-{
-  /* Check the parameters */
-  assert_param(IS_SPI_ALL_PERIPH(SPIx));
-  assert_param(IS_SPI_NSS_INTERNAL(SPI_NSSInternalSoft));
-
-  if (SPI_NSSInternalSoft != SPI_NSSInternalSoft_Reset)
-  {
-    /* Set NSS pin internally by software */
-    SPIx-&gt;CR1 |= SPI_NSSInternalSoft_Set;
-  }
-  else
-  {
-    /* Reset NSS pin internally by software */
-    SPIx-&gt;CR1 &amp;= SPI_NSSInternalSoft_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : SPI_SSOutputCmd
-* Description    : Enables or disables the SS output for the selected SPI.
-* Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
-*                  - NewState: new state of the SPIx SS output. 
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SPI_SSOutputCmd(SPI_TypeDef* SPIx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_SPI_ALL_PERIPH(SPIx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected SPI SS output */
-    SPIx-&gt;CR2 |= CR2_SSOE_Set;
-  }
-  else
-  {
-    /* Disable the selected SPI SS output */
-    SPIx-&gt;CR2 &amp;= CR2_SSOE_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : SPI_DataSizeConfig
-* Description    : Configures the data size for the selected SPI.
-* Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
-*                  - SPI_DataSize: specifies the SPI data size.
-*                    This parameter can be one of the following values:
-*                       - SPI_DataSize_16b: Set data frame format to 16bit
-*                       - SPI_DataSize_8b: Set data frame format to 8bit
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SPI_DataSizeConfig(SPI_TypeDef* SPIx, u16 SPI_DataSize)
-{
-  /* Check the parameters */
-  assert_param(IS_SPI_ALL_PERIPH(SPIx));
-  assert_param(IS_SPI_DATASIZE(SPI_DataSize));
-
-  /* Clear DFF bit */
-  SPIx-&gt;CR1 &amp;= (u16)~SPI_DataSize_16b;
-  /* Set new DFF bit value */
-  SPIx-&gt;CR1 |= SPI_DataSize;
-}
-
-/*******************************************************************************
-* Function Name  : SPI_TransmitCRC
-* Description    : Transmit the SPIx CRC value.
-* Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SPI_TransmitCRC(SPI_TypeDef* SPIx)
-{
-  /* Check the parameters */
-  assert_param(IS_SPI_ALL_PERIPH(SPIx));
-  
-  /* Enable the selected SPI CRC transmission */
-  SPIx-&gt;CR1 |= CR1_CRCNext_Set;
-}
-
-/*******************************************************************************
-* Function Name  : SPI_CalculateCRC
-* Description    : Enables or disables the CRC value calculation of the
-*                  transfered bytes.
-* Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
-*                  - NewState: new state of the SPIx CRC value calculation.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SPI_CalculateCRC(SPI_TypeDef* SPIx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_SPI_ALL_PERIPH(SPIx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected SPI CRC calculation */
-    SPIx-&gt;CR1 |= CR1_CRCEN_Set;
-  }
-  else
-  {
-    /* Disable the selected SPI CRC calculation */
-    SPIx-&gt;CR1 &amp;= CR1_CRCEN_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : SPI_GetCRC
-* Description    : Returns the transmit or the receive CRC register value for
-*                  the specified SPI.
-* Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
-*                  - SPI_CRC: specifies the CRC register to be read.
-*                    This parameter can be one of the following values:
-*                       - SPI_CRC_Tx: Selects Tx CRC register
-*                       - SPI_CRC_Rx: Selects Rx CRC register
-* Output         : None
-* Return         : The selected CRC register value..
-*******************************************************************************/
-u16 SPI_GetCRC(SPI_TypeDef* SPIx, u8 SPI_CRC)
-{
-  u16 crcreg = 0;
-
-  /* Check the parameters */
-  assert_param(IS_SPI_ALL_PERIPH(SPIx));
-  assert_param(IS_SPI_CRC(SPI_CRC));
-
-  if (SPI_CRC != SPI_CRC_Rx)
-  {
-    /* Get the Tx CRC register */
-    crcreg = SPIx-&gt;TXCRCR;
-  }
-  else
-  {
-    /* Get the Rx CRC register */
-    crcreg = SPIx-&gt;RXCRCR;
-  }
-
-  /* Return the selected CRC register */
-  return crcreg;
-}
-
-/*******************************************************************************
-* Function Name  : SPI_GetCRCPolynomial
-* Description    : Returns the CRC Polynomial register value for the specified SPI.
-* Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
-* Output         : None
-* Return         : The CRC Polynomial register value.
-*******************************************************************************/
-u16 SPI_GetCRCPolynomial(SPI_TypeDef* SPIx)
-{
-  /* Check the parameters */
-  assert_param(IS_SPI_ALL_PERIPH(SPIx));
-  
-  /* Return the CRC polynomial register */
-  return SPIx-&gt;CRCPR;
-}
-
-/*******************************************************************************
-* Function Name  : SPI_BiDirectionalLineConfig
-* Description    : Selects the data transfer direction in bi-directional mode
-*                  for the specified SPI.
-* Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
-*                  - SPI_Direction: specifies the data transfer direction in
-*                    bi-directional mode. 
-*                    This parameter can be one of the following values:
-*                       - SPI_Direction_Tx: Selects Tx transmission direction
-*                       - SPI_Direction_Rx: Selects Rx receive direction
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SPI_BiDirectionalLineConfig(SPI_TypeDef* SPIx, u16 SPI_Direction)
-{
-  /* Check the parameters */
-  assert_param(IS_SPI_ALL_PERIPH(SPIx));
-  assert_param(IS_SPI_DIRECTION(SPI_Direction));
-
-  if (SPI_Direction == SPI_Direction_Tx)
-  {
-    /* Set the Tx only mode */
-    SPIx-&gt;CR1 |= SPI_Direction_Tx;
-  }
-  else
-  {
-    /* Set the Rx only mode */
-    SPIx-&gt;CR1 &amp;= SPI_Direction_Rx;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : SPI_I2S_GetFlagStatus
-* Description    : Checks whether the specified SPI/I2S flag is set or not.
-* Input          : - SPIx: where x can be :
-*                         - 1, 2 or 3 in SPI mode 
-*                         - 2 or 3 in I2S mode
-*                  - SPI_I2S_FLAG: specifies the SPI/I2S flag to check. 
-*                    This parameter can be one of the following values:
-*                       - SPI_I2S_FLAG_TXE: Transmit buffer empty flag.
-*                       - SPI_I2S_FLAG_RXNE: Receive buffer not empty flag.
-*                       - SPI_I2S_FLAG_BSY: Busy flag.
-*                       - SPI_I2S_FLAG_OVR: Overrun flag.
-*                       - SPI_FLAG_MODF: Mode Fault flag.
-*                       - SPI_FLAG_CRCERR: CRC Error flag.
-*                       - I2S_FLAG_UDR: Underrun Error flag.
-*                       - I2S_FLAG_CHSIDE: Channel Side flag.
-* Output         : None
-* Return         : The new state of SPI_I2S_FLAG (SET or RESET).
-*******************************************************************************/
-FlagStatus SPI_I2S_GetFlagStatus(SPI_TypeDef* SPIx, u16 SPI_I2S_FLAG)
-{
-  FlagStatus bitstatus = RESET;
-
-  /* Check the parameters */
-  assert_param(IS_SPI_ALL_PERIPH(SPIx));
-  assert_param(IS_SPI_I2S_GET_FLAG(SPI_I2S_FLAG));
-
-  /* Check the status of the specified SPI/I2S flag */
-  if ((SPIx-&gt;SR &amp; SPI_I2S_FLAG) != (u16)RESET)
-  {
-    /* SPI_I2S_FLAG is set */
-    bitstatus = SET;
-  }
-  else
-  {
-    /* SPI_I2S_FLAG is reset */
-    bitstatus = RESET;
-  }
-  /* Return the SPI_I2S_FLAG status */
-  return  bitstatus;
-}
-
-/*******************************************************************************
-* Function Name  : SPI_I2S_ClearFlag
-* Description    : Clears the SPIx CRC Error (CRCERR) flag.
-* Input          : - SPIx: where x can be :
-*                         - 1, 2 or 3 in SPI mode 
-*                  - SPI_I2S_FLAG: specifies the SPI flag to clear. 
-*                    This function clears only CRCERR flag.                                           
-*                  Notes:
-*                       - OVR (OverRun error) flag is cleared by software 
-*                         sequence: a read operation to SPI_DR register 
-*                         (SPI_I2S_ReceiveData()) followed by a read operation 
-*                         to SPI_SR register (SPI_I2S_GetFlagStatus()).                           
-*                       - UDR (UnderRun error) flag is cleared by a read 
-*                         operation to SPI_SR register (SPI_I2S_GetFlagStatus()).                             
-*                       - MODF (Mode Fault) flag is cleared by software sequence: 
-*                         a read/write operation to SPI_SR register 
-*                         (SPI_I2S_GetFlagStatus()) followed by a write 
-*                         operation to SPI_CR1 register (SPI_Cmd() to enable 
-*                         the SPI).   
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SPI_I2S_ClearFlag(SPI_TypeDef* SPIx, u16 SPI_I2S_FLAG)
-{
-  /* Check the parameters */
-  assert_param(IS_SPI_ALL_PERIPH(SPIx));
-  assert_param(IS_SPI_I2S_CLEAR_FLAG(SPI_I2S_FLAG));
-    
-    /* Clear the selected SPI CRC Error (CRCERR) flag */
-    SPIx-&gt;SR = (u16)~SPI_I2S_FLAG;
-}
-
-/*******************************************************************************
-* Function Name  : SPI_I2S_GetITStatus
-* Description    : Checks whether the specified SPI/I2S interrupt has occurred or not.
-* Input          : - SPIx: where x can be :
-*                         - 1, 2 or 3 in SPI mode 
-*                         - 2 or 3 in I2S mode
-*                  - SPI_I2S_IT: specifies the SPI/I2S interrupt source to check. 
-*                    This parameter can be one of the following values:
-*                       - SPI_I2S_IT_TXE: Transmit buffer empty interrupt.
-*                       - SPI_I2S_IT_RXNE: Receive buffer not empty interrupt.
-*                       - SPI_I2S_IT_OVR: Overrun interrupt.
-*                       - SPI_IT_MODF: Mode Fault interrupt.
-*                       - SPI_IT_CRCERR: CRC Error interrupt.
-*                       - I2S_IT_UDR: Underrun Error interrupt.
-* Output         : None
-* Return         : The new state of SPI_I2S_IT (SET or RESET).
-*******************************************************************************/
-ITStatus SPI_I2S_GetITStatus(SPI_TypeDef* SPIx, u8 SPI_I2S_IT)
-{
-  ITStatus bitstatus = RESET;
-  u16 itpos = 0, itmask = 0, enablestatus = 0;
-
-  /* Check the parameters */
-  assert_param(IS_SPI_ALL_PERIPH(SPIx));
-  assert_param(IS_SPI_I2S_GET_IT(SPI_I2S_IT));
-
-  /* Get the SPI/I2S IT index */
-  itpos = (u16)((u16)0x01 &lt;&lt; (SPI_I2S_IT &amp; (u8)0x0F));
-
-  /* Get the SPI/I2S IT mask */
-  itmask = SPI_I2S_IT &gt;&gt; 4;
-  /* Set the IT mask */
-  itmask = (u16)((u16)0x01 &lt;&lt; itmask);
-  /* Get the SPI_I2S_IT enable bit status */
-  enablestatus = (SPIx-&gt;CR2 &amp; itmask) ;
-
-  /* Check the status of the specified SPI/I2S interrupt */
-  if (((SPIx-&gt;SR &amp; itpos) != (u16)RESET) &amp;&amp; enablestatus)
-  {
-    /* SPI_I2S_IT is set */
-    bitstatus = SET;
-  }
-  else
-  {
-    /* SPI_I2S_IT is reset */
-    bitstatus = RESET;
-  }
-  /* Return the SPI_I2S_IT status */
-  return bitstatus;
-}
-
-/*******************************************************************************
-* Function Name  : SPI_I2S_ClearITPendingBit
-* Description    : Clears the SPIx CRC Error (CRCERR) interrupt pending bit.
-* Input          : - SPIx: where x can be :
-*                         - 1, 2 or 3 in SPI mode 
-*                  - SPI_I2S_IT: specifies the SPI interrupt pending bit to clear.
-*                    This function clears only CRCERR intetrrupt pending bit.   
-*                  Notes:
-*                       - OVR (OverRun Error) interrupt pending bit is cleared 
-*                         by software sequence: a read operation to SPI_DR 
-*                         register (SPI_I2S_ReceiveData()) followed by a read 
-*                         operation to SPI_SR register (SPI_I2S_GetITStatus()).
-*                       - UDR (UnderRun Error) interrupt pending bit is cleared 
-*                         by a read operation to SPI_SR register 
-*                         (SPI_I2S_GetITStatus()).                           
-*                       - MODF (Mode Fault) interrupt pending bit is cleared by 
-*                         software sequence: a read/write operation to SPI_SR 
-*                         register (SPI_I2S_GetITStatus()) followed by a write 
-*                         operation to SPI_CR1 register (SPI_Cmd() to enable the 
-*                         SPI).   
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SPI_I2S_ClearITPendingBit(SPI_TypeDef* SPIx, u8 SPI_I2S_IT)
-{
-  u16 itpos = 0;
-
-  /* Check the parameters */
-  assert_param(IS_SPI_ALL_PERIPH(SPIx));
-  assert_param(IS_SPI_I2S_CLEAR_IT(SPI_I2S_IT));
-
-  /* Get the SPI IT index */
-  itpos = (u16)((u16)0x01 &lt;&lt; (SPI_I2S_IT &amp; (u8)0x0F));
-  /* Clear the selected SPI CRC Error (CRCERR) interrupt pending bit */
-  SPIx-&gt;SR = (u16)~itpos;
-}
-
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
+/**
+  ******************************************************************************
+  * @file    stm32f10x_spi.c
+  * @author  MCD Application Team
+  * @version V3.1.0
+  * @date    06/19/2009
+  * @brief   This file provides all the SPI firmware functions.
+  ******************************************************************************
+  * @copy
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * &lt;h2&gt;&lt;center&gt;&copy; COPYRIGHT 2009 STMicroelectronics&lt;/center&gt;&lt;/h2&gt;
+  */ 
+
+/* Includes ------------------------------------------------------------------*/
+#include &quot;stm32f10x_spi.h&quot;
+#include &quot;stm32f10x_rcc.h&quot;
+
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup SPI 
+  * @brief SPI driver modules
+  * @{
+  */ 
+
+/** @defgroup SPI_Private_TypesDefinitions
+  * @{
+  */
+
+/**
+  * @}
+  */ 
+
+
+/** @defgroup SPI_Private_Defines
+  * @{
+  */
+
+/* SPI SPE mask */
+#define CR1_SPE_Set          ((uint16_t)0x0040)
+#define CR1_SPE_Reset        ((uint16_t)0xFFBF)
+
+/* I2S I2SE mask */
+#define I2SCFGR_I2SE_Set     ((uint16_t)0x0400)
+#define I2SCFGR_I2SE_Reset   ((uint16_t)0xFBFF)
+
+/* SPI CRCNext mask */
+#define CR1_CRCNext_Set      ((uint16_t)0x1000)
+
+/* SPI CRCEN mask */
+#define CR1_CRCEN_Set        ((uint16_t)0x2000)
+#define CR1_CRCEN_Reset      ((uint16_t)0xDFFF)
+
+/* SPI SSOE mask */
+#define CR2_SSOE_Set         ((uint16_t)0x0004)
+#define CR2_SSOE_Reset       ((uint16_t)0xFFFB)
+
+/* SPI registers Masks */
+#define CR1_CLEAR_Mask       ((uint16_t)0x3040)
+#define I2SCFGR_CLEAR_Mask   ((uint16_t)0xF040)
+
+/* SPI or I2S mode selection masks */
+#define SPI_Mode_Select      ((uint16_t)0xF7FF)
+#define I2S_Mode_Select      ((uint16_t)0x0800) 
+
+/* I2S clock source selection masks */
+#define I2S2_CLOCK_SRC       ((u32)(0x00020000))
+#define I2S3_CLOCK_SRC       ((u32)(0x00040000))
+#define I2S_MUL_MASK         ((u32)(0x0000F000))
+#define I2S_DIV_MASK         ((u32)(0x000000F0))
+
+/**
+  * @}
+  */
+
+/** @defgroup SPI_Private_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup SPI_Private_Variables
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup SPI_Private_FunctionPrototypes
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup SPI_Private_Functions
+  * @{
+  */
+
+/**
+  * @brief  Deinitializes the SPIx peripheral registers to their default
+  *   reset values (Affects also the I2Ss).
+  * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
+  * @retval None
+  */
+void SPI_I2S_DeInit(SPI_TypeDef* SPIx)
+{
+  /* Check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH(SPIx));
+
+  if (SPIx == SPI1)
+  {
+    /* Enable SPI1 reset state */
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, ENABLE);
+    /* Release SPI1 from reset state */
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, DISABLE);
+  }
+  else if (SPIx == SPI2)
+  {
+    /* Enable SPI2 reset state */
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, ENABLE);
+    /* Release SPI2 from reset state */
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, DISABLE);
+  }
+  else
+  {
+    if (SPIx == SPI3)
+    {
+      /* Enable SPI3 reset state */
+      RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE);
+      /* Release SPI3 from reset state */
+      RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, DISABLE);
+    }
+  }
+}
+
+/**
+  * @brief  Initializes the SPIx peripheral according to the specified 
+  *   parameters in the SPI_InitStruct.
+  * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
+  * @param  SPI_InitStruct: pointer to a SPI_InitTypeDef structure that
+  *   contains the configuration information for the specified SPI peripheral.
+  * @retval None
+  */
+void SPI_Init(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct)
+{
+  uint16_t tmpreg = 0;
+  
+  /* check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH(SPIx));   
+  
+  /* Check the SPI parameters */
+  assert_param(IS_SPI_DIRECTION_MODE(SPI_InitStruct-&gt;SPI_Direction));
+  assert_param(IS_SPI_MODE(SPI_InitStruct-&gt;SPI_Mode));
+  assert_param(IS_SPI_DATASIZE(SPI_InitStruct-&gt;SPI_DataSize));
+  assert_param(IS_SPI_CPOL(SPI_InitStruct-&gt;SPI_CPOL));
+  assert_param(IS_SPI_CPHA(SPI_InitStruct-&gt;SPI_CPHA));
+  assert_param(IS_SPI_NSS(SPI_InitStruct-&gt;SPI_NSS));
+  assert_param(IS_SPI_BAUDRATE_PRESCALER(SPI_InitStruct-&gt;SPI_BaudRatePrescaler));
+  assert_param(IS_SPI_FIRST_BIT(SPI_InitStruct-&gt;SPI_FirstBit));
+  assert_param(IS_SPI_CRC_POLYNOMIAL(SPI_InitStruct-&gt;SPI_CRCPolynomial));
+
+/*---------------------------- SPIx CR1 Configuration ------------------------*/
+  /* Get the SPIx CR1 value */
+  tmpreg = SPIx-&gt;CR1;
+  /* Clear BIDIMode, BIDIOE, RxONLY, SSM, SSI, LSBFirst, BR, MSTR, CPOL and CPHA bits */
+  tmpreg &amp;= CR1_CLEAR_Mask;
+  /* Configure SPIx: direction, NSS management, first transmitted bit, BaudRate prescaler
+     master/salve mode, CPOL and CPHA */
+  /* Set BIDImode, BIDIOE and RxONLY bits according to SPI_Direction value */
+  /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
+  /* Set LSBFirst bit according to SPI_FirstBit value */
+  /* Set BR bits according to SPI_BaudRatePrescaler value */
+  /* Set CPOL bit according to SPI_CPOL value */
+  /* Set CPHA bit according to SPI_CPHA value */
+  tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct-&gt;SPI_Direction | SPI_InitStruct-&gt;SPI_Mode |
+                  SPI_InitStruct-&gt;SPI_DataSize | SPI_InitStruct-&gt;SPI_CPOL |  
+                  SPI_InitStruct-&gt;SPI_CPHA | SPI_InitStruct-&gt;SPI_NSS |  
+                  SPI_InitStruct-&gt;SPI_BaudRatePrescaler | SPI_InitStruct-&gt;SPI_FirstBit);
+  /* Write to SPIx CR1 */
+  SPIx-&gt;CR1 = tmpreg;
+  
+  /* Activate the SPI mode (Reset I2SMOD bit in I2SCFGR register) */
+  SPIx-&gt;I2SCFGR &amp;= SPI_Mode_Select;		
+
+/*---------------------------- SPIx CRCPOLY Configuration --------------------*/
+  /* Write to SPIx CRCPOLY */
+  SPIx-&gt;CRCPR = SPI_InitStruct-&gt;SPI_CRCPolynomial;
+}
+
+/**
+  * @brief  Initializes the SPIx peripheral according to the specified 
+  *   parameters in the I2S_InitStruct.
+  * @param  SPIx: where x can be  2 or 3 to select the SPI peripheral
+  *   (configured in I2S mode).
+  * @param  I2S_InitStruct: pointer to an I2S_InitTypeDef structure that
+  *   contains the configuration information for the specified SPI peripheral
+  *   configured in I2S mode.
+  * @note
+  *  The function calculates the optimal prescaler needed to obtain the most 
+  *  accurate audio frequency (depending on the I2S clock source, the PLL values 
+  *  and the product configuration). But in case the prescaler value is greater 
+  *  than 511, the default value (0x02) will be configured instead.  *   
+  * @retval None
+  */
+void I2S_Init(SPI_TypeDef* SPIx, I2S_InitTypeDef* I2S_InitStruct)
+{
+  uint16_t tmpreg = 0, i2sdiv = 2, i2sodd = 0, packetlength = 1;
+  uint32_t tmp = 0;
+  RCC_ClocksTypeDef RCC_Clocks;
+  uint32_t sourceclock = 0;
+  
+  /* Check the I2S parameters */
+  assert_param(IS_SPI_23_PERIPH(SPIx));
+  assert_param(IS_I2S_MODE(I2S_InitStruct-&gt;I2S_Mode));
+  assert_param(IS_I2S_STANDARD(I2S_InitStruct-&gt;I2S_Standard));
+  assert_param(IS_I2S_DATA_FORMAT(I2S_InitStruct-&gt;I2S_DataFormat));
+  assert_param(IS_I2S_MCLK_OUTPUT(I2S_InitStruct-&gt;I2S_MCLKOutput));
+  assert_param(IS_I2S_AUDIO_FREQ(I2S_InitStruct-&gt;I2S_AudioFreq));
+  assert_param(IS_I2S_CPOL(I2S_InitStruct-&gt;I2S_CPOL));  
+
+/*----------------------- SPIx I2SCFGR &amp; I2SPR Configuration -----------------*/
+  /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
+  SPIx-&gt;I2SCFGR &amp;= I2SCFGR_CLEAR_Mask; 
+  SPIx-&gt;I2SPR = 0x0002;
+  
+  /* Get the I2SCFGR register value */
+  tmpreg = SPIx-&gt;I2SCFGR;
+  
+  /* If the default value has to be written, reinitialize i2sdiv and i2sodd*/
+  if(I2S_InitStruct-&gt;I2S_AudioFreq == I2S_AudioFreq_Default)
+  {
+    i2sodd = (uint16_t)0;
+    i2sdiv = (uint16_t)2;   
+  }
+  /* If the requested audio frequency is not the default, compute the prescaler */
+  else
+  {
+    /* Check the frame length (For the Prescaler computing) */
+    if(I2S_InitStruct-&gt;I2S_DataFormat == I2S_DataFormat_16b)
+    {
+      /* Packet length is 16 bits */
+      packetlength = 1;
+    }
+    else
+    {
+      /* Packet length is 32 bits */
+      packetlength = 2;
+    }
+
+    /* Get the I2S clock source mask depending on the peripheral number */
+    if(((uint32_t)SPIx) == SPI2_BASE)
+    {
+      /* The mask is relative to I2S2 */
+      tmp = I2S2_CLOCK_SRC;
+    }
+    else 
+    {
+      /* The mask is relative to I2S3 */      
+      tmp = I2S3_CLOCK_SRC;
+    }
+
+    /* Check the I2S clock source configuration depending on the Device:
+       Only Connectivity line devices have the PLL3 VCO clock */
+#ifdef STM32F10X_CL
+    if((RCC-&gt;CFGR2 &amp; tmp) != 0)
+    {
+      /* Get the configuration bits of RCC PLL3 multiplier */
+      tmp = (uint32_t)((RCC-&gt;CFGR2 &amp; I2S_MUL_MASK) &gt;&gt; 12);
+
+      /* Get the value of the PLL3 multiplier */      
+      if((tmp &gt; 5) &amp;&amp; (tmp &lt; 15))
+      {
+        /* Multplier is between 8 and 14 (value 15 is forbidden) */
+        tmp += 2;
+      }
+      else
+      {
+        if (tmp == 15)
+        {
+          /* Multiplier is 20 */
+          tmp = 20;
+        }
+      }      
+      /* Get the PREDIV2 value */
+      sourceclock = (uint32_t)(((RCC-&gt;CFGR2 &amp; I2S_DIV_MASK) &gt;&gt; 4) + 1);
+      
+      /* Calculate the Source Clock frequency based on PLL3 and PREDIV2 values */
+      sourceclock = (uint32_t) ((HSE_Value / sourceclock) * tmp * 2); 
+    }
+    else
+    {
+      /* I2S Clock source is System clock: Get System Clock frequency */
+      RCC_GetClocksFreq(&amp;RCC_Clocks);      
+      
+      /* Get the source clock value: based on System Clock value */
+      sourceclock = RCC_Clocks.SYSCLK_Frequency;
+    }        
+#else /* STM32F10X_HD */
+    /* I2S Clock source is System clock: Get System Clock frequency */
+    RCC_GetClocksFreq(&amp;RCC_Clocks);      
+      
+    /* Get the source clock value: based on System Clock value */
+    sourceclock = RCC_Clocks.SYSCLK_Frequency;    
+#endif /* STM32F10X_CL */    
+
+    /* Compute the Real divider depending on the MCLK output state with a flaoting point */
+    if(I2S_InitStruct-&gt;I2S_MCLKOutput == I2S_MCLKOutput_Enable)
+    {
+      /* MCLK output is enabled */
+      tmp = (uint16_t)(((((sourceclock / 256) * 10) / I2S_InitStruct-&gt;I2S_AudioFreq)) + 5);
+    }
+    else
+    {
+      /* MCLK output is disabled */
+      tmp = (uint16_t)(((((sourceclock / (32 * packetlength)) *10 ) / I2S_InitStruct-&gt;I2S_AudioFreq)) + 5);
+    }
+    
+    /* Remove the flaoting point */
+    tmp = tmp / 10;  
+      
+    /* Check the parity of the divider */
+    i2sodd = (uint16_t)(tmp &amp; (u16)0x0001);
+   
+    /* Compute the i2sdiv prescaler */
+    i2sdiv = (uint16_t)((tmp - i2sodd) / 2);
+   
+    /* Get the Mask for the Odd bit (SPI_I2SPR[8]) register */
+    i2sodd = (uint16_t) (i2sodd &lt;&lt; 8);
+  }
+  
+  /* Test if the divider is 1 or 0 or greater than 0xFF */
+  if ((i2sdiv &lt; 2) || (i2sdiv &gt; 0xFF))
+  {
+    /* Set the default values */
+    i2sdiv = 2;
+    i2sodd = 0;
+  }
+
+  /* Write to SPIx I2SPR register the computed value */
+  SPIx-&gt;I2SPR = (uint16_t)(i2sdiv | (uint16_t)(i2sodd | (uint16_t)I2S_InitStruct-&gt;I2S_MCLKOutput));  
+ 
+  /* Configure the I2S with the SPI_InitStruct values */
+  tmpreg |= (uint16_t)(I2S_Mode_Select | (uint16_t)(I2S_InitStruct-&gt;I2S_Mode | \
+                  (uint16_t)(I2S_InitStruct-&gt;I2S_Standard | (uint16_t)(I2S_InitStruct-&gt;I2S_DataFormat | \
+                  (uint16_t)I2S_InitStruct-&gt;I2S_CPOL))));
+ 
+  /* Write to SPIx I2SCFGR */  
+  SPIx-&gt;I2SCFGR = tmpreg;   
+}
+
+/**
+  * @brief  Fills each SPI_InitStruct member with its default value.
+  * @param  SPI_InitStruct : pointer to a SPI_InitTypeDef structure which will be initialized.
+  * @retval None
+  */
+void SPI_StructInit(SPI_InitTypeDef* SPI_InitStruct)
+{
+/*--------------- Reset SPI init structure parameters values -----------------*/
+  /* Initialize the SPI_Direction member */
+  SPI_InitStruct-&gt;SPI_Direction = SPI_Direction_2Lines_FullDuplex;
+  /* initialize the SPI_Mode member */
+  SPI_InitStruct-&gt;SPI_Mode = SPI_Mode_Slave;
+  /* initialize the SPI_DataSize member */
+  SPI_InitStruct-&gt;SPI_DataSize = SPI_DataSize_8b;
+  /* Initialize the SPI_CPOL member */
+  SPI_InitStruct-&gt;SPI_CPOL = SPI_CPOL_Low;
+  /* Initialize the SPI_CPHA member */
+  SPI_InitStruct-&gt;SPI_CPHA = SPI_CPHA_1Edge;
+  /* Initialize the SPI_NSS member */
+  SPI_InitStruct-&gt;SPI_NSS = SPI_NSS_Hard;
+  /* Initialize the SPI_BaudRatePrescaler member */
+  SPI_InitStruct-&gt;SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;
+  /* Initialize the SPI_FirstBit member */
+  SPI_InitStruct-&gt;SPI_FirstBit = SPI_FirstBit_MSB;
+  /* Initialize the SPI_CRCPolynomial member */
+  SPI_InitStruct-&gt;SPI_CRCPolynomial = 7;
+}
+
+/**
+  * @brief  Fills each I2S_InitStruct member with its default value.
+  * @param  I2S_InitStruct : pointer to a I2S_InitTypeDef structure which will be initialized.
+  * @retval None
+  */
+void I2S_StructInit(I2S_InitTypeDef* I2S_InitStruct)
+{
+/*--------------- Reset I2S init structure parameters values -----------------*/
+  /* Initialize the I2S_Mode member */
+  I2S_InitStruct-&gt;I2S_Mode = I2S_Mode_SlaveTx;
+  
+  /* Initialize the I2S_Standard member */
+  I2S_InitStruct-&gt;I2S_Standard = I2S_Standard_Phillips;
+  
+  /* Initialize the I2S_DataFormat member */
+  I2S_InitStruct-&gt;I2S_DataFormat = I2S_DataFormat_16b;
+  
+  /* Initialize the I2S_MCLKOutput member */
+  I2S_InitStruct-&gt;I2S_MCLKOutput = I2S_MCLKOutput_Disable;
+  
+  /* Initialize the I2S_AudioFreq member */
+  I2S_InitStruct-&gt;I2S_AudioFreq = I2S_AudioFreq_Default;
+  
+  /* Initialize the I2S_CPOL member */
+  I2S_InitStruct-&gt;I2S_CPOL = I2S_CPOL_Low;
+}
+
+/**
+  * @brief  Enables or disables the specified SPI peripheral.
+  * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
+  * @param  NewState: new state of the SPIx peripheral. 
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void SPI_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH(SPIx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected SPI peripheral */
+    SPIx-&gt;CR1 |= CR1_SPE_Set;
+  }
+  else
+  {
+    /* Disable the selected SPI peripheral */
+    SPIx-&gt;CR1 &amp;= CR1_SPE_Reset;
+  }
+}
+
+/**
+  * @brief  Enables or disables the specified SPI peripheral (in I2S mode).
+  * @param  SPIx: where x can be 2 or 3 to select the SPI peripheral.
+  * @param  NewState: new state of the SPIx peripheral. 
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void I2S_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_SPI_23_PERIPH(SPIx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected SPI peripheral (in I2S mode) */
+    SPIx-&gt;I2SCFGR |= I2SCFGR_I2SE_Set;
+  }
+  else
+  {
+    /* Disable the selected SPI peripheral (in I2S mode) */
+    SPIx-&gt;I2SCFGR &amp;= I2SCFGR_I2SE_Reset;
+  }
+}
+
+/**
+  * @brief  Enables or disables the specified SPI/I2S interrupts.
+  * @param  SPIx: where x can be
+  *   - 1, 2 or 3 in SPI mode 
+  *   - 2 or 3 in I2S mode
+  * @param  SPI_I2S_IT: specifies the SPI/I2S interrupt source to be enabled or disabled. 
+  *   This parameter can be one of the following values:
+  *     @arg SPI_I2S_IT_TXE: Tx buffer empty interrupt mask
+  *     @arg SPI_I2S_IT_RXNE: Rx buffer not empty interrupt mask
+  *     @arg SPI_I2S_IT_ERR: Error interrupt mask
+  * @param  NewState: new state of the specified SPI/I2S interrupt.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void SPI_I2S_ITConfig(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT, FunctionalState NewState)
+{
+  uint16_t itpos = 0, itmask = 0 ;
+  /* Check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH(SPIx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  assert_param(IS_SPI_I2S_CONFIG_IT(SPI_I2S_IT));
+
+  /* Get the SPI/I2S IT index */
+  itpos = SPI_I2S_IT &gt;&gt; 4;
+
+  /* Set the IT mask */
+  itmask = (uint16_t)1 &lt;&lt; (uint16_t)itpos;
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected SPI/I2S interrupt */
+    SPIx-&gt;CR2 |= itmask;
+  }
+  else
+  {
+    /* Disable the selected SPI/I2S interrupt */
+    SPIx-&gt;CR2 &amp;= (uint16_t)~itmask;
+  }
+}
+
+/**
+  * @brief  Enables or disables the SPIx/I2Sx DMA interface.
+  * @param  SPIx: where x can be
+  *   - 1, 2 or 3 in SPI mode 
+  *   - 2 or 3 in I2S mode
+  * @param  SPI_I2S_DMAReq: specifies the SPI/I2S DMA transfer request to be enabled or disabled. 
+  *   This parameter can be any combination of the following values:
+  *     @arg SPI_I2S_DMAReq_Tx: Tx buffer DMA transfer request
+  *     @arg SPI_I2S_DMAReq_Rx: Rx buffer DMA transfer request
+  * @param  NewState: new state of the selected SPI/I2S DMA transfer request.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void SPI_I2S_DMACmd(SPI_TypeDef* SPIx, uint16_t SPI_I2S_DMAReq, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH(SPIx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  assert_param(IS_SPI_I2S_DMAREQ(SPI_I2S_DMAReq));
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected SPI/I2S DMA requests */
+    SPIx-&gt;CR2 |= SPI_I2S_DMAReq;
+  }
+  else
+  {
+    /* Disable the selected SPI/I2S DMA requests */
+    SPIx-&gt;CR2 &amp;= (uint16_t)~SPI_I2S_DMAReq;
+  }
+}
+
+/**
+  * @brief  Transmits a Data through the SPIx/I2Sx peripheral.
+  * @param  SPIx: where x can be
+  *   - 1, 2 or 3 in SPI mode 
+  *   - 2 or 3 in I2S mode
+  * @param  Data : Data to be transmitted.
+  * @retval None
+  */
+void SPI_I2S_SendData(SPI_TypeDef* SPIx, uint16_t Data)
+{
+  /* Check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH(SPIx));
+  
+  /* Write in the DR register the data to be sent */
+  SPIx-&gt;DR = Data;
+}
+
+/**
+  * @brief  Returns the most recent received data by the SPIx/I2Sx peripheral. 
+  * @param  SPIx: where x can be
+  *   - 1, 2 or 3 in SPI mode 
+  *   - 2 or 3 in I2S mode
+  * @retval The value of the received data.
+  */
+uint16_t SPI_I2S_ReceiveData(SPI_TypeDef* SPIx)
+{
+  /* Check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH(SPIx));
+  
+  /* Return the data in the DR register */
+  return SPIx-&gt;DR;
+}
+
+/**
+  * @brief  Configures internally by software the NSS pin for the selected SPI.
+  * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
+  * @param  SPI_NSSInternalSoft: specifies the SPI NSS internal state.
+  *   This parameter can be one of the following values:
+  *     @arg SPI_NSSInternalSoft_Set: Set NSS pin internally
+  *     @arg SPI_NSSInternalSoft_Reset: Reset NSS pin internally
+  * @retval None
+  */
+void SPI_NSSInternalSoftwareConfig(SPI_TypeDef* SPIx, uint16_t SPI_NSSInternalSoft)
+{
+  /* Check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH(SPIx));
+  assert_param(IS_SPI_NSS_INTERNAL(SPI_NSSInternalSoft));
+  if (SPI_NSSInternalSoft != SPI_NSSInternalSoft_Reset)
+  {
+    /* Set NSS pin internally by software */
+    SPIx-&gt;CR1 |= SPI_NSSInternalSoft_Set;
+  }
+  else
+  {
+    /* Reset NSS pin internally by software */
+    SPIx-&gt;CR1 &amp;= SPI_NSSInternalSoft_Reset;
+  }
+}
+
+/**
+  * @brief  Enables or disables the SS output for the selected SPI.
+  * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
+  * @param  NewState: new state of the SPIx SS output. 
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void SPI_SSOutputCmd(SPI_TypeDef* SPIx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH(SPIx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected SPI SS output */
+    SPIx-&gt;CR2 |= CR2_SSOE_Set;
+  }
+  else
+  {
+    /* Disable the selected SPI SS output */
+    SPIx-&gt;CR2 &amp;= CR2_SSOE_Reset;
+  }
+}
+
+/**
+  * @brief  Configures the data size for the selected SPI.
+  * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
+  * @param  SPI_DataSize: specifies the SPI data size.
+  *   This parameter can be one of the following values:
+  *     @arg SPI_DataSize_16b: Set data frame format to 16bit
+  *     @arg SPI_DataSize_8b: Set data frame format to 8bit
+  * @retval None
+  */
+void SPI_DataSizeConfig(SPI_TypeDef* SPIx, uint16_t SPI_DataSize)
+{
+  /* Check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH(SPIx));
+  assert_param(IS_SPI_DATASIZE(SPI_DataSize));
+  /* Clear DFF bit */
+  SPIx-&gt;CR1 &amp;= (uint16_t)~SPI_DataSize_16b;
+  /* Set new DFF bit value */
+  SPIx-&gt;CR1 |= SPI_DataSize;
+}
+
+/**
+  * @brief  Transmit the SPIx CRC value.
+  * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
+  * @retval None
+  */
+void SPI_TransmitCRC(SPI_TypeDef* SPIx)
+{
+  /* Check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH(SPIx));
+  
+  /* Enable the selected SPI CRC transmission */
+  SPIx-&gt;CR1 |= CR1_CRCNext_Set;
+}
+
+/**
+  * @brief  Enables or disables the CRC value calculation of the transfered bytes.
+  * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
+  * @param  NewState: new state of the SPIx CRC value calculation.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void SPI_CalculateCRC(SPI_TypeDef* SPIx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH(SPIx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected SPI CRC calculation */
+    SPIx-&gt;CR1 |= CR1_CRCEN_Set;
+  }
+  else
+  {
+    /* Disable the selected SPI CRC calculation */
+    SPIx-&gt;CR1 &amp;= CR1_CRCEN_Reset;
+  }
+}
+
+/**
+  * @brief  Returns the transmit or the receive CRC register value for the specified SPI.
+  * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
+  * @param  SPI_CRC: specifies the CRC register to be read.
+  *   This parameter can be one of the following values:
+  *     @arg SPI_CRC_Tx: Selects Tx CRC register
+  *     @arg SPI_CRC_Rx: Selects Rx CRC register
+  * @retval The selected CRC register value..
+  */
+uint16_t SPI_GetCRC(SPI_TypeDef* SPIx, uint8_t SPI_CRC)
+{
+  uint16_t crcreg = 0;
+  /* Check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH(SPIx));
+  assert_param(IS_SPI_CRC(SPI_CRC));
+  if (SPI_CRC != SPI_CRC_Rx)
+  {
+    /* Get the Tx CRC register */
+    crcreg = SPIx-&gt;TXCRCR;
+  }
+  else
+  {
+    /* Get the Rx CRC register */
+    crcreg = SPIx-&gt;RXCRCR;
+  }
+  /* Return the selected CRC register */
+  return crcreg;
+}
+
+/**
+  * @brief  Returns the CRC Polynomial register value for the specified SPI.
+  * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
+  * @retval The CRC Polynomial register value.
+  */
+uint16_t SPI_GetCRCPolynomial(SPI_TypeDef* SPIx)
+{
+  /* Check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH(SPIx));
+  
+  /* Return the CRC polynomial register */
+  return SPIx-&gt;CRCPR;
+}
+
+/**
+  * @brief  Selects the data transfer direction in bi-directional mode for the specified SPI.
+  * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
+  * @param  SPI_Direction: specifies the data transfer direction in bi-directional mode. 
+  *   This parameter can be one of the following values:
+  *     @arg SPI_Direction_Tx: Selects Tx transmission direction
+  *     @arg SPI_Direction_Rx: Selects Rx receive direction
+  * @retval None
+  */
+void SPI_BiDirectionalLineConfig(SPI_TypeDef* SPIx, uint16_t SPI_Direction)
+{
+  /* Check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH(SPIx));
+  assert_param(IS_SPI_DIRECTION(SPI_Direction));
+  if (SPI_Direction == SPI_Direction_Tx)
+  {
+    /* Set the Tx only mode */
+    SPIx-&gt;CR1 |= SPI_Direction_Tx;
+  }
+  else
+  {
+    /* Set the Rx only mode */
+    SPIx-&gt;CR1 &amp;= SPI_Direction_Rx;
+  }
+}
+
+/**
+  * @brief  Checks whether the specified SPI/I2S flag is set or not.
+  * @param  SPIx: where x can be
+  *   - 1, 2 or 3 in SPI mode 
+  *   - 2 or 3 in I2S mode
+  * @param  SPI_I2S_FLAG: specifies the SPI/I2S flag to check. 
+  *   This parameter can be one of the following values:
+  *     @arg SPI_I2S_FLAG_TXE: Transmit buffer empty flag.
+  *     @arg SPI_I2S_FLAG_RXNE: Receive buffer not empty flag.
+  *     @arg SPI_I2S_FLAG_BSY: Busy flag.
+  *     @arg SPI_I2S_FLAG_OVR: Overrun flag.
+  *     @arg SPI_FLAG_MODF: Mode Fault flag.
+  *     @arg SPI_FLAG_CRCERR: CRC Error flag.
+  *     @arg I2S_FLAG_UDR: Underrun Error flag.
+  *     @arg I2S_FLAG_CHSIDE: Channel Side flag.
+  * @retval The new state of SPI_I2S_FLAG (SET or RESET).
+  */
+FlagStatus SPI_I2S_GetFlagStatus(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG)
+{
+  FlagStatus bitstatus = RESET;
+  /* Check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH(SPIx));
+  assert_param(IS_SPI_I2S_GET_FLAG(SPI_I2S_FLAG));
+  /* Check the status of the specified SPI/I2S flag */
+  if ((SPIx-&gt;SR &amp; SPI_I2S_FLAG) != (uint16_t)RESET)
+  {
+    /* SPI_I2S_FLAG is set */
+    bitstatus = SET;
+  }
+  else
+  {
+    /* SPI_I2S_FLAG is reset */
+    bitstatus = RESET;
+  }
+  /* Return the SPI_I2S_FLAG status */
+  return  bitstatus;
+}
+
+/**
+  * @brief  Clears the SPIx CRC Error (CRCERR) flag.
+  * @param  SPIx: where x can be
+  *   - 1, 2 or 3 in SPI mode 
+  * @param  SPI_I2S_FLAG: specifies the SPI flag to clear. 
+  *   This function clears only CRCERR flag.
+  * @note
+  *   - OVR (OverRun error) flag is cleared by software sequence: a read 
+  *     operation to SPI_DR register (SPI_I2S_ReceiveData()) followed by a read 
+  *     operation to SPI_SR register (SPI_I2S_GetFlagStatus()).
+  *   - UDR (UnderRun error) flag is cleared by a read operation to 
+  *     SPI_SR register (SPI_I2S_GetFlagStatus()).
+  *   - MODF (Mode Fault) flag is cleared by software sequence: a read/write 
+  *     operation to SPI_SR register (SPI_I2S_GetFlagStatus()) followed by a 
+  *     write operation to SPI_CR1 register (SPI_Cmd() to enable the SPI).
+  * @retval None
+  */
+void SPI_I2S_ClearFlag(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG)
+{
+  /* Check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH(SPIx));
+  assert_param(IS_SPI_I2S_CLEAR_FLAG(SPI_I2S_FLAG));
+    
+    /* Clear the selected SPI CRC Error (CRCERR) flag */
+    SPIx-&gt;SR = (uint16_t)~SPI_I2S_FLAG;
+}
+
+/**
+  * @brief  Checks whether the specified SPI/I2S interrupt has occurred or not.
+  * @param  SPIx: where x can be
+  *   - 1, 2 or 3 in SPI mode 
+  *   - 2 or 3 in I2S mode
+  * @param  SPI_I2S_IT: specifies the SPI/I2S interrupt source to check. 
+  *   This parameter can be one of the following values:
+  *     @arg SPI_I2S_IT_TXE: Transmit buffer empty interrupt.
+  *     @arg SPI_I2S_IT_RXNE: Receive buffer not empty interrupt.
+  *     @arg SPI_I2S_IT_OVR: Overrun interrupt.
+  *     @arg SPI_IT_MODF: Mode Fault interrupt.
+  *     @arg SPI_IT_CRCERR: CRC Error interrupt.
+  *     @arg I2S_IT_UDR: Underrun Error interrupt.
+  * @retval The new state of SPI_I2S_IT (SET or RESET).
+  */
+ITStatus SPI_I2S_GetITStatus(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT)
+{
+  ITStatus bitstatus = RESET;
+  uint16_t itpos = 0, itmask = 0, enablestatus = 0;
+
+  /* Check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH(SPIx));
+  assert_param(IS_SPI_I2S_GET_IT(SPI_I2S_IT));
+
+  /* Get the SPI/I2S IT index */
+  itpos = 0x01 &lt;&lt; (SPI_I2S_IT &amp; 0x0F);
+
+  /* Get the SPI/I2S IT mask */
+  itmask = SPI_I2S_IT &gt;&gt; 4;
+
+  /* Set the IT mask */
+  itmask = 0x01 &lt;&lt; itmask;
+
+  /* Get the SPI_I2S_IT enable bit status */
+  enablestatus = (SPIx-&gt;CR2 &amp; itmask) ;
+
+  /* Check the status of the specified SPI/I2S interrupt */
+  if (((SPIx-&gt;SR &amp; itpos) != (uint16_t)RESET) &amp;&amp; enablestatus)
+  {
+    /* SPI_I2S_IT is set */
+    bitstatus = SET;
+  }
+  else
+  {
+    /* SPI_I2S_IT is reset */
+    bitstatus = RESET;
+  }
+  /* Return the SPI_I2S_IT status */
+  return bitstatus;
+}
+
+/**
+  * @brief  Clears the SPIx CRC Error (CRCERR) interrupt pending bit.
+  * @param  SPIx: where x can be
+  *   - 1, 2 or 3 in SPI mode 
+  * @param  SPI_I2S_IT: specifies the SPI interrupt pending bit to clear.
+  *   This function clears only CRCERR intetrrupt pending bit.   
+  * @note
+  *   - OVR (OverRun Error) interrupt pending bit is cleared by software 
+  *     sequence: a read operation to SPI_DR register (SPI_I2S_ReceiveData()) 
+  *     followed by a read operation to SPI_SR register (SPI_I2S_GetITStatus()).
+  *   - UDR (UnderRun Error) interrupt pending bit is cleared by a read 
+  *     operation to SPI_SR register (SPI_I2S_GetITStatus()).
+  *   - MODF (Mode Fault) interrupt pending bit is cleared by software sequence:
+  *     a read/write operation to SPI_SR register (SPI_I2S_GetITStatus()) 
+  *     followed by a write operation to SPI_CR1 register (SPI_Cmd() to enable 
+  *     the SPI).
+  * @retval None
+  */
+void SPI_I2S_ClearITPendingBit(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT)
+{
+  uint16_t itpos = 0;
+  /* Check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH(SPIx));
+  assert_param(IS_SPI_I2S_CLEAR_IT(SPI_I2S_IT));
+
+  /* Get the SPI IT index */
+  itpos = 0x01 &lt;&lt; (SPI_I2S_IT &amp; 0x0F);
+
+  /* Clear the selected SPI CRC Error (CRCERR) interrupt pending bit */
+  SPIx-&gt;SR = (uint16_t)~itpos;
+}
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/******************* (C) COPYRIGHT 2009 STMicroelectronics *****END OF FILE****/

Added: trunk/src/platform/stm32/FWLib/library/src/stm32f10x_spi.o
===================================================================
--- trunk/src/platform/stm32/FWLib/library/src/stm32f10x_spi.o	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/src/stm32f10x_spi.o	2009-07-08 23:39:34 UTC (rev 354)
@@ -0,0 +1,18 @@
+ELF
+&#136;K&#136;&#181;C&#138;&#136;&#136;C&#202;&#136;&#244;ATC
+&#137;CJ&#137;C&#138;&#137;C&#202;&#137;CC&#164;&#178;&#128;&#131;&#139;#&#244;
+
+&#163;&#245;&#251;s&#224;j&#177;&#251;&#242;&#242;
+#SC&#179;&#251;&#240;&#243;3&#154;&#178;
+#&#178;&#251;&#243;&#243;&#240;&#195;&#243;O&#146;&#178;&#139;&#155;&#178;&#254;+(&#191;
+&#209;!O&#244;&#128;P&#255;&#247;&#254;&#255;O&#244;&#128;P
+M	

+
+
+
+M
+O
+O
+P
+P
+P
\ No newline at end of file

Deleted: trunk/src/platform/stm32/FWLib/library/src/stm32f10x_systick.c
===================================================================
--- trunk/src/platform/stm32/FWLib/library/src/stm32f10x_systick.c	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/src/stm32f10x_systick.c	2009-07-08 23:39:34 UTC (rev 354)
@@ -1,181 +0,0 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_systick.c
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file provides all the SysTick firmware functions.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
-
-/* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_systick.h&quot;
-
-/* Private typedef -----------------------------------------------------------*/
-/* Private define ------------------------------------------------------------*/
-/* ---------------------- SysTick registers bit mask -------------------- */
-/* CTRL TICKINT Mask */
-#define CTRL_TICKINT_Set      ((u32)0x00000002)
-#define CTRL_TICKINT_Reset    ((u32)0xFFFFFFFD)
-
-/* Private macro -------------------------------------------------------------*/
-/* Private variables ---------------------------------------------------------*/
-/* Private function prototypes -----------------------------------------------*/
-/* Private functions ---------------------------------------------------------*/
-
-/*******************************************************************************
-* Function Name  : SysTick_CLKSourceConfig
-* Description    : Configures the SysTick clock source.
-* Input          : - SysTick_CLKSource: specifies the SysTick clock source.
-*                    This parameter can be one of the following values:
-*                       - SysTick_CLKSource_HCLK_Div8: AHB clock divided by 8
-*                         selected as SysTick clock source.
-*                       - SysTick_CLKSource_HCLK: AHB clock selected as
-*                         SysTick clock source.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SysTick_CLKSourceConfig(u32 SysTick_CLKSource)
-{
-  /* Check the parameters */
-  assert_param(IS_SYSTICK_CLK_SOURCE(SysTick_CLKSource));
-
-  if (SysTick_CLKSource == SysTick_CLKSource_HCLK)
-  {
-    SysTick-&gt;CTRL |= SysTick_CLKSource_HCLK;
-  }
-  else
-  {
-    SysTick-&gt;CTRL &amp;= SysTick_CLKSource_HCLK_Div8;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : SysTick_SetReload
-* Description    : Sets SysTick Reload value.
-* Input          : - Reload: SysTick Reload new value.
-*                    This parameter must be a number between 1 and 0xFFFFFF.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SysTick_SetReload(u32 Reload)
-{
-  /* Check the parameters */
-  assert_param(IS_SYSTICK_RELOAD(Reload));
-
-  SysTick-&gt;LOAD = Reload;
-}
-
-/*******************************************************************************
-* Function Name  : SysTick_CounterCmd
-* Description    : Enables or disables the SysTick counter.
-* Input          : - SysTick_Counter: new state of the SysTick counter.
-*                    This parameter can be one of the following values:
-*                       - SysTick_Counter_Disable: Disable counter
-*                       - SysTick_Counter_Enable: Enable counter
-*                       - SysTick_Counter_Clear: Clear counter value to 0
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SysTick_CounterCmd(u32 SysTick_Counter)
-{
-  /* Check the parameters */
-  assert_param(IS_SYSTICK_COUNTER(SysTick_Counter));
-
-  if (SysTick_Counter == SysTick_Counter_Enable)
-  {
-    SysTick-&gt;CTRL |= SysTick_Counter_Enable;
-  }
-  else if (SysTick_Counter == SysTick_Counter_Disable) 
-  {
-    SysTick-&gt;CTRL &amp;= SysTick_Counter_Disable;
-  }
-  else /* SysTick_Counter == SysTick_Counter_Clear */
-  {
-    SysTick-&gt;VAL = SysTick_Counter_Clear;
-  }    
-}
-
-/*******************************************************************************
-* Function Name  : SysTick_ITConfig
-* Description    : Enables or disables the SysTick Interrupt.
-* Input          : - NewState: new state of the SysTick Interrupt.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SysTick_ITConfig(FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    SysTick-&gt;CTRL |= CTRL_TICKINT_Set;
-  }
-  else
-  {
-    SysTick-&gt;CTRL &amp;= CTRL_TICKINT_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : SysTick_GetCounter
-* Description    : Gets SysTick counter value.
-* Input          : None
-* Output         : None
-* Return         : SysTick current value
-*******************************************************************************/
-u32 SysTick_GetCounter(void)
-{
-  return(SysTick-&gt;VAL);
-}
-
-/*******************************************************************************
-* Function Name  : SysTick_GetFlagStatus
-* Description    : Checks whether the specified SysTick flag is set or not.
-* Input          : - SysTick_FLAG: specifies the flag to check.
-*                    This parameter can be one of the following values:
-*                       - SysTick_FLAG_COUNT
-*                       - SysTick_FLAG_SKEW
-*                       - SysTick_FLAG_NOREF
-* Output         : None
-* Return         : None
-*******************************************************************************/
-FlagStatus SysTick_GetFlagStatus(u8 SysTick_FLAG)
-{
-  u32 statusreg = 0, tmp = 0 ;
-  FlagStatus bitstatus = RESET;
-
-  /* Check the parameters */
-  assert_param(IS_SYSTICK_FLAG(SysTick_FLAG));
-
-  /* Get the SysTick register index */
-  tmp = SysTick_FLAG &gt;&gt; 3;
-
-  if (tmp == 2) /* The flag to check is in CTRL register */
-  {
-    statusreg = SysTick-&gt;CTRL;
-  }
-  else          /* The flag to check is in CALIB register */
-  {
-    statusreg = SysTick-&gt;CALIB;
-  }
-
-  if ((statusreg &amp; ((u32)1 &lt;&lt; SysTick_FLAG)) != (u32)RESET)
-  {
-    bitstatus = SET;
-  }
-  else
-  {
-    bitstatus = RESET;
-  }
-  return bitstatus;
-}
-
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/

Modified: trunk/src/platform/stm32/FWLib/library/src/stm32f10x_tim.c
===================================================================
--- trunk/src/platform/stm32/FWLib/library/src/stm32f10x_tim.c	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/src/stm32f10x_tim.c	2009-07-08 23:39:34 UTC (rev 354)
@@ -1,3219 +1,2799 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_tim.c
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file provides all the TIM firmware functions.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
-
-/* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_tim.h&quot;
-#include &quot;stm32f10x_rcc.h&quot;
-
-/* Private typedef -----------------------------------------------------------*/
-/* Private define ------------------------------------------------------------*/
-/* ---------------------- TIM registers bit mask ------------------------ */
-#define CR1_CEN_Set                 ((u16)0x0001)
-#define CR1_CEN_Reset               ((u16)0x03FE)
-#define CR1_UDIS_Set                ((u16)0x0002)
-#define CR1_UDIS_Reset              ((u16)0x03FD)
-#define CR1_URS_Set                 ((u16)0x0004)
-#define CR1_URS_Reset               ((u16)0x03FB)
-#define CR1_OPM_Reset               ((u16)0x03F7)
-#define CR1_CounterMode_Mask        ((u16)0x038F)
-#define CR1_ARPE_Set                ((u16)0x0080)
-#define CR1_ARPE_Reset              ((u16)0x037F)
-#define CR1_CKD_Mask                ((u16)0x00FF)
-
-#define CR2_CCPC_Set                ((u16)0x0001)
-#define CR2_CCPC_Reset              ((u16)0xFFFE)
-#define CR2_CCUS_Set                ((u16)0x0004)
-#define CR2_CCUS_Reset              ((u16)0xFFFB)
-#define CR2_CCDS_Set                ((u16)0x0008)
-#define CR2_CCDS_Reset              ((u16)0xFFF7)
-#define CR2_MMS_Mask                ((u16)0xFF8F)
-#define CR2_TI1S_Set                ((u16)0x0080)
-#define CR2_TI1S_Reset              ((u16)0xFF7F)
-#define CR2_OIS1_Reset              ((u16)0x7EFF)
-#define CR2_OIS1N_Reset             ((u16)0x7DFF)
-#define CR2_OIS2_Reset              ((u16)0x7BFF)
-#define CR2_OIS2N_Reset             ((u16)0x77FF)
-#define CR2_OIS3_Reset              ((u16)0x6FFF)
-#define CR2_OIS3N_Reset             ((u16)0x5FFF)
-#define CR2_OIS4_Reset              ((u16)0x3FFF)
-
-#define SMCR_SMS_Mask               ((u16)0xFFF8)
-#define SMCR_ETR_Mask               ((u16)0x00FF)
-#define SMCR_TS_Mask                ((u16)0xFF8F)
-#define SMCR_MSM_Reset              ((u16)0xFF7F)
-#define SMCR_ECE_Set                ((u16)0x4000)
-
-#define CCMR_CC13S_Mask             ((u16)0xFFFC)
-#define CCMR_CC24S_Mask             ((u16)0xFCFF)
-#define CCMR_TI13Direct_Set         ((u16)0x0001)
-#define CCMR_TI24Direct_Set         ((u16)0x0100)
-#define CCMR_OC13FE_Reset           ((u16)0xFFFB)
-#define CCMR_OC24FE_Reset           ((u16)0xFBFF)
-#define CCMR_OC13PE_Reset           ((u16)0xFFF7)
-#define CCMR_OC24PE_Reset           ((u16)0xF7FF)
-#define CCMR_OC13M_Mask             ((u16)0xFF8F)
-#define CCMR_OC24M_Mask             ((u16)0x8FFF) 
-
-#define CCMR_OC13CE_Reset           ((u16)0xFF7F)
-#define CCMR_OC24CE_Reset           ((u16)0x7FFF)
-
-#define CCMR_IC13PSC_Mask           ((u16)0xFFF3)
-#define CCMR_IC24PSC_Mask           ((u16)0xF3FF)
-#define CCMR_IC13F_Mask             ((u16)0xFF0F)
-#define CCMR_IC24F_Mask             ((u16)0x0FFF)
-
-#define CCMR_Offset                 ((u16)0x0018)
-#define CCER_CCE_Set                ((u16)0x0001)
-#define	CCER_CCNE_Set               ((u16)0x0004)
-
-#define CCER_CC1P_Reset             ((u16)0xFFFD)
-#define CCER_CC2P_Reset             ((u16)0xFFDF)
-#define CCER_CC3P_Reset             ((u16)0xFDFF)
-#define CCER_CC4P_Reset             ((u16)0xDFFF)
-
-#define CCER_CC1NP_Reset            ((u16)0xFFF7)
-#define CCER_CC2NP_Reset            ((u16)0xFF7F)
-#define CCER_CC3NP_Reset            ((u16)0xF7FF)
-
-#define CCER_CC1E_Set               ((u16)0x0001)
-#define CCER_CC1E_Reset             ((u16)0xFFFE)
-
-#define CCER_CC1NE_Reset            ((u16)0xFFFB)
-
-#define CCER_CC2E_Set               ((u16)0x0010)
-#define CCER_CC2E_Reset             ((u16)0xFFEF)
-
-#define CCER_CC2NE_Reset            ((u16)0xFFBF)
-
-#define CCER_CC3E_Set               ((u16)0x0100)
-#define CCER_CC3E_Reset             ((u16)0xFEFF)
-
-#define CCER_CC3NE_Reset            ((u16)0xFBFF)
-
-#define CCER_CC4E_Set               ((u16)0x1000)
-#define CCER_CC4E_Reset             ((u16)0xEFFF)
-
-#define BDTR_MOE_Set                ((u16)0x8000)
-#define BDTR_MOE_Reset              ((u16)0x7FFF)
-
-/* Private macro -------------------------------------------------------------*/
-/* Private variables ---------------------------------------------------------*/
-/* Private function prototypes -----------------------------------------------*/
-static void TI1_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
-                       u16 TIM_ICFilter);
-static void TI2_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
-                       u16 TIM_ICFilter);
-static void TI3_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
-                       u16 TIM_ICFilter);
-static void TI4_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
-                       u16 TIM_ICFilter);
-/* Private macro -------------------------------------------------------------*/
-/* Private variables ---------------------------------------------------------*/
-/* Private function prototypes -----------------------------------------------*/
-/* Private functions ---------------------------------------------------------*/
-/*******************************************************************************
-* Function Name  : TIM_DeInit
-* Description    : Deinitializes the TIMx peripheral registers to their default
-*                  reset values.
-* Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_DeInit(TIM_TypeDef* TIMx)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
- 
-  switch (*(u32*)&amp;TIMx)
-  {
-    case TIM1_BASE:
-      RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, ENABLE);
-      RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, DISABLE);  
-      break; 
-      
-    case TIM2_BASE:
-      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, ENABLE);
-      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
-      break;
- 
-    case TIM3_BASE:
-      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
-      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
-      break;
- 
-    case TIM4_BASE:
-      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, ENABLE);
-      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, DISABLE);
-      break;
-      
-    case TIM5_BASE:
-      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, ENABLE);
-      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, DISABLE);
-      break;
-      
-    case TIM6_BASE:
-      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, ENABLE);
-      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, DISABLE);
-      break;
-      
-    case TIM7_BASE:
-      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, ENABLE);
-      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, DISABLE);
-      break;
-      
-    case TIM8_BASE:
-      RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, ENABLE);
-      RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, DISABLE);  
-      break; 
-      
-    default:
-      break;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : TIM_TimeBaseInit
-* Description    : Initializes the TIMx Time Base Unit peripheral according to 
-*                  the specified parameters in the TIM_TimeBaseInitStruct.
-* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_TimeBaseInitStruct: pointer to a TIM_TimeBaseInitTypeDef
-*                   structure that contains the configuration information for
-*                   the specified TIM peripheral.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx)); 
-  assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct-&gt;TIM_CounterMode));
-  assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct-&gt;TIM_ClockDivision));
-
-  /* Select the Counter Mode and set the clock division */
-  TIMx-&gt;CR1 &amp;= CR1_CKD_Mask &amp; CR1_CounterMode_Mask;
-  TIMx-&gt;CR1 |= (u32)TIM_TimeBaseInitStruct-&gt;TIM_ClockDivision |
-                TIM_TimeBaseInitStruct-&gt;TIM_CounterMode;
-  /* Set the Autoreload value */
-  TIMx-&gt;ARR = TIM_TimeBaseInitStruct-&gt;TIM_Period ;
-
-  /* Set the Prescaler value */
-  TIMx-&gt;PSC = TIM_TimeBaseInitStruct-&gt;TIM_Prescaler;
-
-  /* Generate an update event to reload the Prescaler value immediatly */
-  TIMx-&gt;EGR = TIM_PSCReloadMode_Immediate;
-    
-  if (((*(u32*)&amp;TIMx) == TIM1_BASE) || ((*(u32*)&amp;TIMx) == TIM8_BASE))  
-  {
-    /* Set the Repetition Counter value */
-    TIMx-&gt;RCR = TIM_TimeBaseInitStruct-&gt;TIM_RepetitionCounter;
-  }        
-}
-
-/*******************************************************************************
-* Function Name  : TIM_OC1Init
-* Description    : Initializes the TIMx Channel1 according to the specified
-*                  parameters in the TIM_OCInitStruct.
-* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
-*                    that contains the configuration information for the specified
-*                    TIM peripheral.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
-{
-  u16 tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
-   
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx)); 
-  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct-&gt;TIM_OCMode));
-  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct-&gt;TIM_OutputState));
-  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct-&gt;TIM_OCPolarity));   
-
-  /* Disable the Channel 1: Reset the CC1E Bit */
-  TIMx-&gt;CCER &amp;= CCER_CC1E_Reset;
-  
-  /* Get the TIMx CCER register value */
-  tmpccer = TIMx-&gt;CCER;
-
-  /* Get the TIMx CR2 register value */
-  tmpcr2 =  TIMx-&gt;CR2;
-  
-  /* Get the TIMx CCMR1 register value */
-  tmpccmrx = TIMx-&gt;CCMR1;
-    
-  /* Reset the Output Compare Mode Bits */
-  tmpccmrx &amp;= CCMR_OC13M_Mask;
-  
-  /* Select the Output Compare Mode */
-  tmpccmrx |= TIM_OCInitStruct-&gt;TIM_OCMode;
-  
-  /* Reset the Output Polarity level */
-  tmpccer &amp;= CCER_CC1P_Reset;
-
-  /* Set the Output Compare Polarity */
-  tmpccer |= TIM_OCInitStruct-&gt;TIM_OCPolarity;
-  
-  /* Set the Output State */
-  tmpccer |= TIM_OCInitStruct-&gt;TIM_OutputState;
-  
-  /* Set the Capture Compare Register value */
-  TIMx-&gt;CCR1 = TIM_OCInitStruct-&gt;TIM_Pulse;
-  
-  if((*(u32*)&amp;TIMx == TIM1_BASE) || (*(u32*)&amp;TIMx == TIM8_BASE))
-  {
-    assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct-&gt;TIM_OutputNState));
-    assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct-&gt;TIM_OCNPolarity));
-    assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct-&gt;TIM_OCNIdleState));
-    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct-&gt;TIM_OCIdleState));
-    
-    /* Reset the Output N Polarity level */
-    tmpccer &amp;= CCER_CC1NP_Reset;
-
-    /* Set the Output N Polarity */
-    tmpccer |= TIM_OCInitStruct-&gt;TIM_OCNPolarity;
-
-    /* Reset the Output N State */
-    tmpccer &amp;= CCER_CC1NE_Reset;
-    
-    /* Set the Output N State */
-    tmpccer |= TIM_OCInitStruct-&gt;TIM_OutputNState;
-
-    /* Reset the Ouput Compare and Output Compare N IDLE State */
-    tmpcr2 &amp;= CR2_OIS1_Reset;
-    tmpcr2 &amp;= CR2_OIS1N_Reset;
-
-    /* Set the Output Idle state */
-    tmpcr2 |= TIM_OCInitStruct-&gt;TIM_OCIdleState;
-
-    /* Set the Output N Idle state */
-    tmpcr2 |= TIM_OCInitStruct-&gt;TIM_OCNIdleState;
-  }
-  /* Write to TIMx CR2 */
-  TIMx-&gt;CR2 = tmpcr2;
-  
-  /* Write to TIMx CCMR1 */
-  TIMx-&gt;CCMR1 = tmpccmrx;
-  
-  /* Write to TIMx CCER */
-  TIMx-&gt;CCER = tmpccer;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_OC2Init
-* Description    : Initializes the TIMx Channel2 according to the specified
-*                  parameters in the TIM_OCInitStruct.
-* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
-*                    that contains the configuration information for the specified
-*                    TIM peripheral.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
-{
-  u16 tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
-   
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx)); 
-  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct-&gt;TIM_OCMode));
-  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct-&gt;TIM_OutputState));
-  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct-&gt;TIM_OCPolarity));   
-
-  /* Disable the Channel 2: Reset the CC2E Bit */
-  TIMx-&gt;CCER &amp;= CCER_CC2E_Reset;
-  
-  /* Get the TIMx CCER register value */  
-  tmpccer = TIMx-&gt;CCER;
-
-  /* Get the TIMx CR2 register value */
-  tmpcr2 =  TIMx-&gt;CR2;
-  
-  /* Get the TIMx CCMR1 register value */
-  tmpccmrx = TIMx-&gt;CCMR1;
-    
-  /* Reset the Output Compare Mode Bits */
-  tmpccmrx &amp;= CCMR_OC24M_Mask;
-  
-  /* Select the Output Compare Mode */
-  tmpccmrx |= (u16)(TIM_OCInitStruct-&gt;TIM_OCMode &lt;&lt; 8);
-  
-  /* Reset the Output Polarity level */
-  tmpccer &amp;= CCER_CC2P_Reset;
-
-  /* Set the Output Compare Polarity */
-  tmpccer |= (u16)(TIM_OCInitStruct-&gt;TIM_OCPolarity &lt;&lt; 4);
-  
-  /* Set the Output State */
-  tmpccer |= (u16)(TIM_OCInitStruct-&gt;TIM_OutputState &lt;&lt; 4);
-  
-  /* Set the Capture Compare Register value */
-  TIMx-&gt;CCR2 = TIM_OCInitStruct-&gt;TIM_Pulse;
-  
-  if((*(u32*)&amp;TIMx == TIM1_BASE) || (*(u32*)&amp;TIMx == TIM8_BASE))
-  {
-    assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct-&gt;TIM_OutputNState));
-    assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct-&gt;TIM_OCNPolarity));
-    assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct-&gt;TIM_OCNIdleState));
-    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct-&gt;TIM_OCIdleState));
-    
-    /* Reset the Output N Polarity level */
-    tmpccer &amp;= CCER_CC2NP_Reset;
-
-    /* Set the Output N Polarity */
-    tmpccer |= (u16)(TIM_OCInitStruct-&gt;TIM_OCNPolarity &lt;&lt; 4);
-
-    /* Reset the Output N State */
-    tmpccer &amp;= CCER_CC2NE_Reset;
-    
-    /* Set the Output N State */
-    tmpccer |= (u16)(TIM_OCInitStruct-&gt;TIM_OutputNState &lt;&lt; 4);
-
-    /* Reset the Ouput Compare and Output Compare N IDLE State */
-    tmpcr2 &amp;= CR2_OIS2_Reset;
-    tmpcr2 &amp;= CR2_OIS2N_Reset;
-
-    /* Set the Output Idle state */
-    tmpcr2 |= (u16)(TIM_OCInitStruct-&gt;TIM_OCIdleState &lt;&lt; 2);
-
-    /* Set the Output N Idle state */
-    tmpcr2 |= (u16)(TIM_OCInitStruct-&gt;TIM_OCNIdleState &lt;&lt; 2);
-  }
-
-  /* Write to TIMx CR2 */
-  TIMx-&gt;CR2 = tmpcr2;
-  
-  /* Write to TIMx CCMR1 */
-  TIMx-&gt;CCMR1 = tmpccmrx;
-  
-  /* Write to TIMx CCER */
-  TIMx-&gt;CCER = tmpccer;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_OC3Init
-* Description    : Initializes the TIMx Channel3 according to the specified
-*                  parameters in the TIM_OCInitStruct.
-* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
-*                    that contains the configuration information for the specified
-*                    TIM peripheral.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
-{
-  u16 tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
-   
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx)); 
-  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct-&gt;TIM_OCMode));
-  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct-&gt;TIM_OutputState));
-  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct-&gt;TIM_OCPolarity));   
-
-  /* Disable the Channel 2: Reset the CC2E Bit */
-  TIMx-&gt;CCER &amp;= CCER_CC3E_Reset;
-  
-  /* Get the TIMx CCER register value */
-  tmpccer = TIMx-&gt;CCER;
-
-  /* Get the TIMx CR2 register value */
-  tmpcr2 =  TIMx-&gt;CR2;
-  
-  /* Get the TIMx CCMR2 register value */
-  tmpccmrx = TIMx-&gt;CCMR2;
-    
-  /* Reset the Output Compare Mode Bits */
-  tmpccmrx &amp;= CCMR_OC13M_Mask;
-  
-  /* Select the Output Compare Mode */
-  tmpccmrx |= TIM_OCInitStruct-&gt;TIM_OCMode;
-  
-  /* Reset the Output Polarity level */
-  tmpccer &amp;= CCER_CC3P_Reset;
-
-  /* Set the Output Compare Polarity */
-  tmpccer |= (u16)(TIM_OCInitStruct-&gt;TIM_OCPolarity &lt;&lt; 8);
-  
-  /* Set the Output State */
-  tmpccer |= (u16)(TIM_OCInitStruct-&gt;TIM_OutputState &lt;&lt; 8);
-  
-  /* Set the Capture Compare Register value */
-  TIMx-&gt;CCR3 = TIM_OCInitStruct-&gt;TIM_Pulse;
-  
-  if((*(u32*)&amp;TIMx == TIM1_BASE) || (*(u32*)&amp;TIMx == TIM8_BASE))
-  {
-    assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct-&gt;TIM_OutputNState));
-    assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct-&gt;TIM_OCNPolarity));
-    assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct-&gt;TIM_OCNIdleState));
-    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct-&gt;TIM_OCIdleState));
-    
-    /* Reset the Output N Polarity level */
-    tmpccer &amp;= CCER_CC3NP_Reset;
-
-    /* Set the Output N Polarity */
-    tmpccer |= (u16)(TIM_OCInitStruct-&gt;TIM_OCNPolarity &lt;&lt; 8);
-
-    /* Reset the Output N State */
-    tmpccer &amp;= CCER_CC3NE_Reset;
-    
-    /* Set the Output N State */
-    tmpccer |= (u16)(TIM_OCInitStruct-&gt;TIM_OutputNState &lt;&lt; 8);
-
-    /* Reset the Ouput Compare and Output Compare N IDLE State */
-    tmpcr2 &amp;= CR2_OIS3_Reset;
-    tmpcr2 &amp;= CR2_OIS3N_Reset;
-
-    /* Set the Output Idle state */
-    tmpcr2 |= (u16)(TIM_OCInitStruct-&gt;TIM_OCIdleState &lt;&lt; 4);
-
-    /* Set the Output N Idle state */
-    tmpcr2 |= (u16)(TIM_OCInitStruct-&gt;TIM_OCNIdleState &lt;&lt; 4);
-  }
-
-  /* Write to TIMx CR2 */
-  TIMx-&gt;CR2 = tmpcr2;
-  
-  /* Write to TIMx CCMR2 */
-  TIMx-&gt;CCMR2 = tmpccmrx;
-  
-  /* Write to TIMx CCER */
-  TIMx-&gt;CCER = tmpccer;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_OC4Init
-* Description    : Initializes the TIMx Channel4 according to the specified
-*                  parameters in the TIM_OCInitStruct.
-* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
-*                    that contains the configuration information for the specified
-*                    TIM peripheral.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
-{
-  u16 tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
-   
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx)); 
-  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct-&gt;TIM_OCMode));
-  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct-&gt;TIM_OutputState));
-  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct-&gt;TIM_OCPolarity));   
-
-  /* Disable the Channel 2: Reset the CC4E Bit */
-  TIMx-&gt;CCER &amp;= CCER_CC4E_Reset;
-  
-  /* Get the TIMx CCER register value */
-  tmpccer = TIMx-&gt;CCER;
-
-  /* Get the TIMx CR2 register value */
-  tmpcr2 =  TIMx-&gt;CR2;
-  
-  /* Get the TIMx CCMR2 register value */
-  tmpccmrx = TIMx-&gt;CCMR2;
-    
-  /* Reset the Output Compare Mode Bits */
-  tmpccmrx &amp;= CCMR_OC24M_Mask;
-  
-  /* Select the Output Compare Mode */
-  tmpccmrx |= (u16)(TIM_OCInitStruct-&gt;TIM_OCMode &lt;&lt; 8);
-  
-  /* Reset the Output Polarity level */
-  tmpccer &amp;= CCER_CC4P_Reset;
-
-  /* Set the Output Compare Polarity */
-  tmpccer |= (u16)(TIM_OCInitStruct-&gt;TIM_OCPolarity &lt;&lt; 12);
-  
-  /* Set the Output State */
-  tmpccer |= (u16)(TIM_OCInitStruct-&gt;TIM_OutputState &lt;&lt; 12);
-  
-  /* Set the Capture Compare Register value */
-  TIMx-&gt;CCR4 = TIM_OCInitStruct-&gt;TIM_Pulse;
-  
-  if((*(u32*)&amp;TIMx == TIM1_BASE) || (*(u32*)&amp;TIMx == TIM8_BASE))
-  {
-    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct-&gt;TIM_OCIdleState));
-
-    /* Reset the Ouput Compare IDLE State */
-    tmpcr2 &amp;= CR2_OIS4_Reset;
-
-    /* Set the Output Idle state */
-    tmpcr2 |= (u16)(TIM_OCInitStruct-&gt;TIM_OCIdleState &lt;&lt; 6);
-  }
-
-  /* Write to TIMx CR2 */
-  TIMx-&gt;CR2 = tmpcr2;
-  
-  /* Write to TIMx CCMR2 */  
-  TIMx-&gt;CCMR2 = tmpccmrx;
-  
-  /* Write to TIMx CCER */
-  TIMx-&gt;CCER = tmpccer;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_ICInit
-* Description    : Initializes the TIM peripheral according to the specified
-*                  parameters in the TIM_ICInitStruct.
-* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure
-*                    that contains the configuration information for the specified
-*                    TIM peripheral.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_CHANNEL(TIM_ICInitStruct-&gt;TIM_Channel));
-  assert_param(IS_TIM_IC_POLARITY(TIM_ICInitStruct-&gt;TIM_ICPolarity));
-  assert_param(IS_TIM_IC_SELECTION(TIM_ICInitStruct-&gt;TIM_ICSelection));
-  assert_param(IS_TIM_IC_PRESCALER(TIM_ICInitStruct-&gt;TIM_ICPrescaler));
-  assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct-&gt;TIM_ICFilter));
-  
-  if (TIM_ICInitStruct-&gt;TIM_Channel == TIM_Channel_1)
-  {
-    /* TI1 Configuration */
-    TI1_Config(TIMx, TIM_ICInitStruct-&gt;TIM_ICPolarity,
-               TIM_ICInitStruct-&gt;TIM_ICSelection,
-               TIM_ICInitStruct-&gt;TIM_ICFilter);
-
-    /* Set the Input Capture Prescaler value */
-    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct-&gt;TIM_ICPrescaler);
-  }
-  else if (TIM_ICInitStruct-&gt;TIM_Channel == TIM_Channel_2)
-  {
-    /* TI2 Configuration */
-    TI2_Config(TIMx, TIM_ICInitStruct-&gt;TIM_ICPolarity,
-               TIM_ICInitStruct-&gt;TIM_ICSelection,
-               TIM_ICInitStruct-&gt;TIM_ICFilter);
-
-    /* Set the Input Capture Prescaler value */
-    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct-&gt;TIM_ICPrescaler);
-  }
-  else if (TIM_ICInitStruct-&gt;TIM_Channel == TIM_Channel_3)
-  {
-    /* TI3 Configuration */
-    TI3_Config(TIMx,  TIM_ICInitStruct-&gt;TIM_ICPolarity,
-               TIM_ICInitStruct-&gt;TIM_ICSelection,
-               TIM_ICInitStruct-&gt;TIM_ICFilter);
-
-    /* Set the Input Capture Prescaler value */
-    TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct-&gt;TIM_ICPrescaler);
-  }
-  else
-  {
-    /* TI4 Configuration */
-    TI4_Config(TIMx, TIM_ICInitStruct-&gt;TIM_ICPolarity,
-               TIM_ICInitStruct-&gt;TIM_ICSelection,
-               TIM_ICInitStruct-&gt;TIM_ICFilter);
-
-    /* Set the Input Capture Prescaler value */
-    TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct-&gt;TIM_ICPrescaler);
-  }
-}
-
-/*******************************************************************************
-* Function Name  : TIM_PWMIConfig
-* Description    : Configures the TIM peripheral according to the specified
-*                  parameters in the TIM_ICInitStruct to measure an external PWM
-*                  signal.
-* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure
-*                    that contains the configuration information for the specified
-*                    TIM peripheral.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
-{
-  u16 icoppositepolarity = TIM_ICPolarity_Rising;
-  u16 icoppositeselection = TIM_ICSelection_DirectTI;
-
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-
-  /* Select the Opposite Input Polarity */
-  if (TIM_ICInitStruct-&gt;TIM_ICPolarity == TIM_ICPolarity_Rising)
-  {
-    icoppositepolarity = TIM_ICPolarity_Falling;
-  }
-  else
-  {
-    icoppositepolarity = TIM_ICPolarity_Rising;
-  }
-
-  /* Select the Opposite Input */
-  if (TIM_ICInitStruct-&gt;TIM_ICSelection == TIM_ICSelection_DirectTI)
-  {
-    icoppositeselection = TIM_ICSelection_IndirectTI;
-  }
-  else
-  {
-    icoppositeselection = TIM_ICSelection_DirectTI;
-  }
-
-  if (TIM_ICInitStruct-&gt;TIM_Channel == TIM_Channel_1)
-  {
-    /* TI1 Configuration */
-    TI1_Config(TIMx, TIM_ICInitStruct-&gt;TIM_ICPolarity, TIM_ICInitStruct-&gt;TIM_ICSelection,
-               TIM_ICInitStruct-&gt;TIM_ICFilter);
-
-    /* Set the Input Capture Prescaler value */
-    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct-&gt;TIM_ICPrescaler);
-
-    /* TI2 Configuration */
-    TI2_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct-&gt;TIM_ICFilter);
-
-    /* Set the Input Capture Prescaler value */
-    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct-&gt;TIM_ICPrescaler);
-  }
-  else
-  { 
-    /* TI2 Configuration */
-    TI2_Config(TIMx, TIM_ICInitStruct-&gt;TIM_ICPolarity, TIM_ICInitStruct-&gt;TIM_ICSelection,
-               TIM_ICInitStruct-&gt;TIM_ICFilter);
-
-    /* Set the Input Capture Prescaler value */
-    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct-&gt;TIM_ICPrescaler);
-
-    /* TI1 Configuration */
-    TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct-&gt;TIM_ICFilter);
-
-    /* Set the Input Capture Prescaler value */
-    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct-&gt;TIM_ICPrescaler);
-  }
-}
-
-/*******************************************************************************
-* Function Name  : TIM_BDTRConfig
-* Description    : Configures the: Break feature, dead time, Lock level, the OSSI,
-*                  the OSSR State and the AOE(automatic output enable).
-* Input          :- TIMx: where x can be  1 or 8 to select the TIM 
-*                 - TIM_BDTRInitStruct: pointer to a TIM_BDTRInitTypeDef
-*                    structure that contains the BDTR Register configuration
-*                    information for the TIM peripheral.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_BDTRConfig(TIM_TypeDef* TIMx, TIM_BDTRInitTypeDef *TIM_BDTRInitStruct)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_18_PERIPH(TIMx));
-  assert_param(IS_TIM_OSSR_STATE(TIM_BDTRInitStruct-&gt;TIM_OSSRState));
-  assert_param(IS_TIM_OSSI_STATE(TIM_BDTRInitStruct-&gt;TIM_OSSIState));
-  assert_param(IS_TIM_LOCK_LEVEL(TIM_BDTRInitStruct-&gt;TIM_LOCKLevel));
-  assert_param(IS_TIM_BREAK_STATE(TIM_BDTRInitStruct-&gt;TIM_Break));
-  assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct-&gt;TIM_BreakPolarity));
-  assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct-&gt;TIM_AutomaticOutput));
-
-  /* Set the Lock level, the Break enable Bit and the Ploarity, the OSSR State,
-     the OSSI State, the dead time value and the Automatic Output Enable Bit */
-
-  TIMx-&gt;BDTR = (u32)TIM_BDTRInitStruct-&gt;TIM_OSSRState | TIM_BDTRInitStruct-&gt;TIM_OSSIState |
-             TIM_BDTRInitStruct-&gt;TIM_LOCKLevel | TIM_BDTRInitStruct-&gt;TIM_DeadTime |
-             TIM_BDTRInitStruct-&gt;TIM_Break | TIM_BDTRInitStruct-&gt;TIM_BreakPolarity |
-             TIM_BDTRInitStruct-&gt;TIM_AutomaticOutput;
-
-}
-
-/*******************************************************************************
-* Function Name  : TIM_TimeBaseStructInit
-* Description    : Fills each TIM_TimeBaseInitStruct member with its default value.
-* Input          : - TIM_TimeBaseInitStruct : pointer to a TIM_TimeBaseInitTypeDef
-*                    structure which will be initialized.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
-{
-  /* Set the default configuration */
-  TIM_TimeBaseInitStruct-&gt;TIM_Period = 0xFFFF;
-  TIM_TimeBaseInitStruct-&gt;TIM_Prescaler = 0x0000;
-  TIM_TimeBaseInitStruct-&gt;TIM_ClockDivision = TIM_CKD_DIV1;
-  TIM_TimeBaseInitStruct-&gt;TIM_CounterMode = TIM_CounterMode_Up;
-  TIM_TimeBaseInitStruct-&gt;TIM_RepetitionCounter = 0x0000;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_OCStructInit
-* Description    : Fills each TIM_OCInitStruct member with its default value.
-* Input          : - TIM_OCInitStruct : pointer to a TIM_OCInitTypeDef structure
-*                    which will be initialized.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct)
-{
-  /* Set the default configuration */
-  TIM_OCInitStruct-&gt;TIM_OCMode = TIM_OCMode_Timing;
-  TIM_OCInitStruct-&gt;TIM_OutputState = TIM_OutputState_Disable;
-  TIM_OCInitStruct-&gt;TIM_OutputNState = TIM_OutputNState_Disable;
-  TIM_OCInitStruct-&gt;TIM_Pulse = 0x0000;
-  TIM_OCInitStruct-&gt;TIM_OCPolarity = TIM_OCPolarity_High;
-  TIM_OCInitStruct-&gt;TIM_OCNPolarity = TIM_OCPolarity_High;
-  TIM_OCInitStruct-&gt;TIM_OCIdleState = TIM_OCIdleState_Reset;
-  TIM_OCInitStruct-&gt;TIM_OCNIdleState = TIM_OCNIdleState_Reset;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_ICStructInit
-* Description    : Fills each TIM_ICInitStruct member with its default value.
-* Input          : - TIM_ICInitStruct : pointer to a TIM_ICInitTypeDef structure
-*                    which will be initialized.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct)
-{
-  /* Set the default configuration */
-  TIM_ICInitStruct-&gt;TIM_Channel = TIM_Channel_1;
-  TIM_ICInitStruct-&gt;TIM_ICPolarity = TIM_ICPolarity_Rising;
-  TIM_ICInitStruct-&gt;TIM_ICSelection = TIM_ICSelection_DirectTI;
-  TIM_ICInitStruct-&gt;TIM_ICPrescaler = TIM_ICPSC_DIV1;
-  TIM_ICInitStruct-&gt;TIM_ICFilter = 0x00;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_BDTRStructInit
-* Description    : Fills each TIM_BDTRInitStruct member with its default value.
-* Input          : - TIM_BDTRInitStruct : pointer to a TIM_BDTRInitTypeDef
-*                    structure which will be initialized.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_BDTRStructInit(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct)
-{
-  /* Set the default configuration */
-  TIM_BDTRInitStruct-&gt;TIM_OSSRState = TIM_OSSRState_Disable;
-  TIM_BDTRInitStruct-&gt;TIM_OSSIState = TIM_OSSIState_Disable;
-  TIM_BDTRInitStruct-&gt;TIM_LOCKLevel = TIM_LOCKLevel_OFF;
-  TIM_BDTRInitStruct-&gt;TIM_DeadTime = 0x00;
-  TIM_BDTRInitStruct-&gt;TIM_Break = TIM_Break_Disable;
-  TIM_BDTRInitStruct-&gt;TIM_BreakPolarity = TIM_BreakPolarity_Low;
-  TIM_BDTRInitStruct-&gt;TIM_AutomaticOutput = TIM_AutomaticOutput_Disable;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_Cmd
-* Description    : Enables or disables the specified TIM peripheral.
-* Input          : - TIMx: where x can be 1 to 8 to select the TIMx peripheral.
-*                  - NewState: new state of the TIMx peripheral.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_ALL_PERIPH(TIMx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  
-  if (NewState != DISABLE)
-  {
-    /* Enable the TIM Counter */
-    TIMx-&gt;CR1 |= CR1_CEN_Set;
-  }
-  else
-  {
-    /* Disable the TIM Counter */
-    TIMx-&gt;CR1 &amp;= CR1_CEN_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : TIM_CtrlPWMOutputs
-* Description    : Enables or disables the TIM peripheral Main Outputs.
-* Input          :- TIMx: where x can be 1 or 8 to select the TIMx peripheral.
-*                 - NewState: new state of the TIM peripheral Main Outputs.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_18_PERIPH(TIMx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Enable the TIM Main Output */
-    TIMx-&gt;BDTR |= BDTR_MOE_Set;
-  }
-  else
-  {
-    /* Disable the TIM Main Output */
-    TIMx-&gt;BDTR &amp;= BDTR_MOE_Reset;
-  }  
-}
-
-/*******************************************************************************
-* Function Name  : TIM_ITConfig
-* Description    : Enables or disables the specified TIM interrupts.
-* Input          : - TIMx: where x can be 1 to 8 to select the TIMx peripheral.
-*                  - TIM_IT: specifies the TIM interrupts sources to be enabled
-*                    or disabled.
-*                    This parameter can be any combination of the following values:
-*                       - TIM_IT_Update: TIM update Interrupt source
-*                       - TIM_IT_CC1: TIM Capture Compare 1 Interrupt source
-*                       - TIM_IT_CC2: TIM Capture Compare 2 Interrupt source
-*                       - TIM_IT_CC3: TIM Capture Compare 3 Interrupt source
-*                       - TIM_IT_CC4: TIM Capture Compare 4 Interrupt source
-*                       - TIM_IT_COM: TIM Commutation Interrupt source
-*                       - TIM_IT_Trigger: TIM Trigger Interrupt source
-*                       - TIM_IT_Break: TIM Break Interrupt source
-*                  - NewState: new state of the TIM interrupts.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_ITConfig(TIM_TypeDef* TIMx, u16 TIM_IT, FunctionalState NewState)
-{  
-  /* Check the parameters */
-  assert_param(IS_TIM_ALL_PERIPH(TIMx));
-  assert_param(IS_TIM_IT(TIM_IT));
-  assert_param(IS_TIM_PERIPH_IT((TIMx), (TIM_IT)));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  
-  if (NewState != DISABLE)
-  {
-    /* Enable the Interrupt sources */
-    TIMx-&gt;DIER |= TIM_IT;
-  }
-  else
-  {
-    /* Disable the Interrupt sources */
-    TIMx-&gt;DIER &amp;= (u16)~TIM_IT;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : TIM_GenerateEvent
-* Description    : Configures the TIMx event to be generate by software.
-* Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
-*                  - TIM_EventSource: specifies the event source.
-*                    This parameter can be one or more of the following values:	   
-*                       - TIM_EventSource_Update: Timer update Event source
-*                       - TIM_EventSource_CC1: Timer Capture Compare 1 Event source
-*                       - TIM_EventSource_CC2: Timer Capture Compare 2 Event source
-*                       - TIM_EventSource_CC3: Timer Capture Compare 3 Event source
-*                       - TIM_EventSource_CC4: Timer Capture Compare 4 Event source
-*                       - TIM_EventSource_Trigger: Timer Trigger Event source
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_GenerateEvent(TIM_TypeDef* TIMx, u16 TIM_EventSource)
-{ 
-  /* Check the parameters */
-  assert_param(IS_TIM_ALL_PERIPH(TIMx));
-  assert_param(IS_TIM_EVENT_SOURCE(TIM_EventSource));
-  assert_param(IS_TIM_PERIPH_EVENT((TIMx), (TIM_EventSource)));
-
-  /* Set the event sources */
-  TIMx-&gt;EGR = TIM_EventSource;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_DMAConfig
-* Description    : Configures the TIMx's DMA interface.
-* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_DMABase: DMA Base address.
-*                    This parameter can be one of the following values:
-*                       - TIM_DMABase_CR, TIM_DMABase_CR2, TIM_DMABase_SMCR,
-*                         TIM_DMABase_DIER, TIM1_DMABase_SR, TIM_DMABase_EGR,
-*                         TIM_DMABase_CCMR1, TIM_DMABase_CCMR2, TIM_DMABase_CCER,
-*                         TIM_DMABase_CNT, TIM_DMABase_PSC, TIM_DMABase_ARR,
-*                         TIM_DMABase_RCR, TIM_DMABase_CCR1, TIM_DMABase_CCR2,
-*                         TIM_DMABase_CCR3, TIM_DMABase_CCR4, TIM_DMABase_BDTR,
-*                         TIM_DMABase_DCR.
-*                   - TIM_DMABurstLength: DMA Burst length.
-*                     This parameter can be one value between:
-*                     TIM_DMABurstLength_1Byte and TIM_DMABurstLength_18Bytes.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_DMAConfig(TIM_TypeDef* TIMx, u16 TIM_DMABase, u16 TIM_DMABurstLength)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_DMA_BASE(TIM_DMABase));
-  assert_param(IS_TIM_DMA_LENGTH(TIM_DMABurstLength));
-
-  /* Set the DMA Base and the DMA Burst Length */
-  TIMx-&gt;DCR = TIM_DMABase | TIM_DMABurstLength;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_DMACmd
-* Description    : Enables or disables the TIMx's DMA Requests.
-* Input          : - TIMx: where x can be  1 to 8 to select the TIM peripheral. 
-*                  - TIM_DMASources: specifies the DMA Request sources.
-*                    This parameter can be any combination of the following values:
-*                       - TIM_DMA_Update: TIM update Interrupt source
-*                       - TIM_DMA_CC1: TIM Capture Compare 1 DMA source
-*                       - TIM_DMA_CC2: TIM Capture Compare 2 DMA source
-*                       - TIM_DMA_CC3: TIM Capture Compare 3 DMA source
-*                       - TIM_DMA_CC4: TIM Capture Compare 4 DMA source
-*                       - TIM_DMA_COM: TIM Commutation DMA source
-*                       - TIM_DMA_Trigger: TIM Trigger DMA source
-*                  - NewState: new state of the DMA Request sources.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_DMACmd(TIM_TypeDef* TIMx, u16 TIM_DMASource, FunctionalState NewState)
-{ 
-  /* Check the parameters */
-  assert_param(IS_TIM_ALL_PERIPH(TIMx));
-  assert_param(IS_TIM_DMA_SOURCE(TIM_DMASource));
-  assert_param(IS_TIM_PERIPH_DMA(TIMx, TIM_DMASource));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  
-  if (NewState != DISABLE)
-  {
-    /* Enable the DMA sources */
-    TIMx-&gt;DIER |= TIM_DMASource; 
-  }
-  else
-  {
-    /* Disable the DMA sources */
-    TIMx-&gt;DIER &amp;= (u16)~TIM_DMASource;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : TIM_InternalClockConfig
-* Description    : Configures the TIMx interrnal Clock
-* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_InternalClockConfig(TIM_TypeDef* TIMx)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-
-  /* Disable slave mode to clock the prescaler directly with the internal clock */
-  TIMx-&gt;SMCR &amp;=  SMCR_SMS_Mask;
-}
-/*******************************************************************************
-* Function Name  : TIM_ITRxExternalClockConfig
-* Description    : Configures the TIMx Internal Trigger as External Clock
-* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_ITRSource: Trigger source.
-*                    This parameter can be one of the following values:
-*                       - TIM_TS_ITR0: Internal Trigger 0
-*                       - TIM_TS_ITR1: Internal Trigger 1
-*                       - TIM_TS_ITR2: Internal Trigger 2
-*                       - TIM_TS_ITR3: Internal Trigger 3
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, u16 TIM_InputTriggerSource)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_INTERNAL_TRIGGER_SELECTION(TIM_InputTriggerSource));
-
-  /* Select the Internal Trigger */
-  TIM_SelectInputTrigger(TIMx, TIM_InputTriggerSource);
-
-  /* Select the External clock mode1 */
-  TIMx-&gt;SMCR |= TIM_SlaveMode_External1;
-}
-/*******************************************************************************
-* Function Name  : TIM_TIxExternalClockConfig
-* Description    : Configures the TIMx Trigger as External Clock
-* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_TIxExternalCLKSource: Trigger source.
-*                    This parameter can be one of the following values:
-*                       - TIM_TIxExternalCLK1Source_TI1ED: TI1 Edge Detector
-*                       - TIM_TIxExternalCLK1Source_TI1: Filtered Timer Input 1
-*                       - TIM_TIxExternalCLK1Source_TI2: Filtered Timer Input 2
-*                  - TIM_ICPolarity: specifies the TIx Polarity.
-*                    This parameter can be:
-*                       - TIM_ICPolarity_Rising
-*                       - TIM_ICPolarity_Falling
-*                   - ICFilter : specifies the filter value.
-*                     This parameter must be a value between 0x0 and 0xF.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, u16 TIM_TIxExternalCLKSource,
-                                u16 TIM_ICPolarity, u16 ICFilter)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_TIXCLK_SOURCE(TIM_TIxExternalCLKSource));
-  assert_param(IS_TIM_IC_POLARITY(TIM_ICPolarity));
-  assert_param(IS_TIM_IC_FILTER(ICFilter));
-
-  /* Configure the Timer Input Clock Source */
-  if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
-  {
-    TI2_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
-  }
-  else
-  {
-    TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
-  }
-
-  /* Select the Trigger source */
-  TIM_SelectInputTrigger(TIMx, TIM_TIxExternalCLKSource);
-
-  /* Select the External clock mode1 */
-  TIMx-&gt;SMCR |= TIM_SlaveMode_External1;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_ETRClockMode1Config
-* Description    : Configures the External clock Mode1
-* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_ExtTRGPrescaler: The external Trigger Prescaler.
-*                    It can be one of the following values:
-*                       - TIM_ExtTRGPSC_OFF
-*                       - TIM_ExtTRGPSC_DIV2
-*                       - TIM_ExtTRGPSC_DIV4
-*                       - TIM_ExtTRGPSC_DIV8.
-*                  - TIM_ExtTRGPolarity: The external Trigger Polarity.
-*                    It can be one of the following values:
-*                       - TIM_ExtTRGPolarity_Inverted
-*                       - TIM_ExtTRGPolarity_NonInverted
-*                  - ExtTRGFilter: External Trigger Filter.
-*                    This parameter must be a value between 0x00 and 0x0F
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, u16 TIM_ExtTRGPrescaler, u16 TIM_ExtTRGPolarity,
-                             u16 ExtTRGFilter)
-{
-  u16 tmpsmcr = 0;
-
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
-  assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
-  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
-
-  /* Configure the ETR Clock source */
-  TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
-  
-  /* Get the TIMx SMCR register value */
-  tmpsmcr = TIMx-&gt;SMCR;
-
-  /* Reset the SMS Bits */
-  tmpsmcr &amp;= SMCR_SMS_Mask;
-  /* Select the External clock mode1 */
-  tmpsmcr |= TIM_SlaveMode_External1;
-
-  /* Select the Trigger selection : ETRF */
-  tmpsmcr &amp;= SMCR_TS_Mask;
-  tmpsmcr |= TIM_TS_ETRF;
-
-  /* Write to TIMx SMCR */
-  TIMx-&gt;SMCR = tmpsmcr;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_ETRClockMode2Config
-* Description    : Configures the External clock Mode2
-* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_ExtTRGPrescaler: The external Trigger Prescaler.
-*                    It can be one of the following values:
-*                       - TIM_ExtTRGPSC_OFF
-*                       - TIM_ExtTRGPSC_DIV2
-*                       - TIM_ExtTRGPSC_DIV4
-*                       - TIM_ExtTRGPSC_DIV8
-*                  - TIM_ExtTRGPolarity: The external Trigger Polarity.
-*                    It can be one of the following values:
-*                       - TIM_ExtTRGPolarity_Inverted
-*                       - TIM_ExtTRGPolarity_NonInverted
-*                  - ExtTRGFilter: External Trigger Filter.
-*                    This parameter must be a value between 0x00 and 0x0F
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, u16 TIM_ExtTRGPrescaler, 
-                             u16 TIM_ExtTRGPolarity, u16 ExtTRGFilter)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
-  assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
-  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
-
-  /* Configure the ETR Clock source */
-  TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
-
-  /* Enable the External clock mode2 */
-  TIMx-&gt;SMCR |= SMCR_ECE_Set;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_ETRConfig
-* Description    : Configures the TIMx External Trigger (ETR).
-* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_ExtTRGPrescaler: The external Trigger Prescaler.
-*                    This parameter can be one of the following values:
-*                       - TIM_ExtTRGPSC_OFF
-*                       - TIM_ExtTRGPSC_DIV2
-*                       - TIM_ExtTRGPSC_DIV4
-*                       - TIM_ExtTRGPSC_DIV8
-*                  - TIM_ExtTRGPolarity: The external Trigger Polarity.
-*                    This parameter can be one of the following values:
-*                       - TIM_ExtTRGPolarity_Inverted
-*                       - TIM_ExtTRGPolarity_NonInverted
-*                  - ExtTRGFilter: External Trigger Filter.
-*                    This parameter must be a value between 0x00 and 0x0F.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_ETRConfig(TIM_TypeDef* TIMx, u16 TIM_ExtTRGPrescaler, u16 TIM_ExtTRGPolarity,
-                   u16 ExtTRGFilter)
-{
-  u16 tmpsmcr = 0;
-
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
-  assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
-  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
-
-  tmpsmcr = TIMx-&gt;SMCR;
-
-  /* Reset the ETR Bits */
-  tmpsmcr &amp;= SMCR_ETR_Mask;
-
-  /* Set the Prescaler, the Filter value and the Polarity */
-  tmpsmcr |= TIM_ExtTRGPrescaler | TIM_ExtTRGPolarity | (u16)(ExtTRGFilter &lt;&lt; 8);
-
-  /* Write to TIMx SMCR */
-  TIMx-&gt;SMCR = tmpsmcr;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_PrescalerConfig
-* Description    : Configures the TIMx Prescaler.
-* Input          : - TIMx: where x can be  1 to 8 to select the TIM peripheral.
-*                  - Prescaler: specifies the Prescaler Register value
-*                  - TIM_PSCReloadMode: specifies the TIM Prescaler Reload mode
-*                    This parameter can be one of the following values:
-*                       - TIM_PSCReloadMode_Update: The Prescaler is loaded at
-*                         the update event.
-*                       - TIM_PSCReloadMode_Immediate: The Prescaler is loaded
-*                         immediatly.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_PrescalerConfig(TIM_TypeDef* TIMx, u16 Prescaler, u16 TIM_PSCReloadMode)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_ALL_PERIPH(TIMx));
-  assert_param(IS_TIM_PRESCALER_RELOAD(TIM_PSCReloadMode));
-
-  /* Set the Prescaler value */
-  TIMx-&gt;PSC = Prescaler;
-
-  /* Set or reset the UG Bit */
-  TIMx-&gt;EGR = TIM_PSCReloadMode;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_CounterModeConfig
-* Description    : Specifies the TIMx Counter Mode to be used.
-* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_CounterMode: specifies the Counter Mode to be used
-*                    This parameter can be one of the following values:
-*                       - TIM_CounterMode_Up: TIM Up Counting Mode
-*                       - TIM_CounterMode_Down: TIM Down Counting Mode
-*                       - TIM_CounterMode_CenterAligned1: TIM Center Aligned Mode1
-*                       - TIM_CounterMode_CenterAligned2: TIM Center Aligned Mode2
-*                       - TIM_CounterMode_CenterAligned3: TIM Center Aligned Mode3
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_CounterModeConfig(TIM_TypeDef* TIMx, u16 TIM_CounterMode)
-{
-  u16 tmpcr1 = 0;
-
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_COUNTER_MODE(TIM_CounterMode));
-
-  tmpcr1 = TIMx-&gt;CR1;
-
-  /* Reset the CMS and DIR Bits */
-  tmpcr1 &amp;= CR1_CounterMode_Mask;
-
-  /* Set the Counter Mode */
-  tmpcr1 |= TIM_CounterMode;
-
-  /* Write to TIMx CR1 register */
-  TIMx-&gt;CR1 = tmpcr1;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_SelectInputTrigger
-* Description    : Selects the Input Trigger source
-* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_InputTriggerSource: The Input Trigger source.
-*                    This parameter can be one of the following values:
-*                       - TIM_TS_ITR0: Internal Trigger 0
-*                       - TIM_TS_ITR1: Internal Trigger 1
-*                       - TIM_TS_ITR2: Internal Trigger 2
-*                       - TIM_TS_ITR3: Internal Trigger 3
-*                       - TIM_TS_TI1F_ED: TI1 Edge Detector
-*                       - TIM_TS_TI1FP1: Filtered Timer Input 1
-*                       - TIM_TS_TI2FP2: Filtered Timer Input 2
-*                       - TIM_TS_ETRF: External Trigger input
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, u16 TIM_InputTriggerSource)
-{
-  u16 tmpsmcr = 0;
-
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));
-
-  /* Get the TIMx SMCR register value */
-  tmpsmcr = TIMx-&gt;SMCR;
-
-  /* Reset the TS Bits */
-  tmpsmcr &amp;= SMCR_TS_Mask;
-
-  /* Set the Input Trigger source */
-  tmpsmcr |= TIM_InputTriggerSource;
-
-  /* Write to TIMx SMCR */
-  TIMx-&gt;SMCR = tmpsmcr;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_EncoderInterfaceConfig
-* Description    : Configures the TIMx Encoder Interface.
-* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_EncoderMode: specifies the TIMx Encoder Mode.
-*                    This parameter can be one of the following values:
-*                       - TIM_EncoderMode_TI1: Counter counts on TI1FP1 edge
-*                         depending on TI2FP2 level.
-*                       - TIM_EncoderMode_TI2: Counter counts on TI2FP2 edge
-*                         depending on TI1FP1 level.
-*                       - TIM_EncoderMode_TI12: Counter counts on both TI1FP1 and
-*                         TI2FP2 edges depending on the level of the other input.
-*                  - TIM_IC1Polarity: specifies the IC1 Polarity
-*                    This parmeter can be one of the following values:
-*                        - TIM_ICPolarity_Falling: IC Falling edge.
-*                        - TIM_ICPolarity_Rising: IC Rising edge.
-*                  - TIM_IC2Polarity: specifies the IC2 Polarity
-*                    This parmeter can be one of the following values:
-*                        - TIM_ICPolarity_Falling: IC Falling edge.
-*                        - TIM_ICPolarity_Rising: IC Rising edge.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, u16 TIM_EncoderMode,
-                                u16 TIM_IC1Polarity, u16 TIM_IC2Polarity)
-{
-  u16 tmpsmcr = 0;
-  u16 tmpccmr1 = 0;
-  u16 tmpccer = 0;
-    
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_ENCODER_MODE(TIM_EncoderMode));
-  assert_param(IS_TIM_IC_POLARITY(TIM_IC1Polarity));
-  assert_param(IS_TIM_IC_POLARITY(TIM_IC2Polarity));
-
-  /* Get the TIMx SMCR register value */
-  tmpsmcr = TIMx-&gt;SMCR;
-
-  /* Get the TIMx CCMR1 register value */
-  tmpccmr1 = TIMx-&gt;CCMR1;
-
-  /* Get the TIMx CCER register value */
-  tmpccer = TIMx-&gt;CCER;
-
-  /* Set the encoder Mode */
-  tmpsmcr &amp;= SMCR_SMS_Mask;
-  tmpsmcr |= TIM_EncoderMode;
-
-  /* Select the Capture Compare 1 and the Capture Compare 2 as input */
-  tmpccmr1 &amp;= CCMR_CC13S_Mask &amp; CCMR_CC24S_Mask;
-  tmpccmr1 |= CCMR_TI13Direct_Set | CCMR_TI24Direct_Set;
-
-  /* Set the TI1 and the TI2 Polarities */
-  tmpccer &amp;= CCER_CC1P_Reset &amp; CCER_CC2P_Reset;
-  tmpccer |= (TIM_IC1Polarity | (u16)(TIM_IC2Polarity &lt;&lt; 4));
-
-  /* Write to TIMx SMCR */
-  TIMx-&gt;SMCR = tmpsmcr;
-
-  /* Write to TIMx CCMR1 */
-  TIMx-&gt;CCMR1 = tmpccmr1;
-
-  /* Write to TIMx CCER */
-  TIMx-&gt;CCER = tmpccer;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_ForcedOC1Config
-* Description    : Forces the TIMx output 1 waveform to active or inactive level.
-* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_ForcedAction: specifies the forced Action to be set to
-*                    the output waveform.
-*                    This parameter can be one of the following values:
-*                       - TIM_ForcedAction_Active: Force active level on OC1REF
-*                       - TIM_ForcedAction_InActive: Force inactive level on
-*                         OC1REF.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_ForcedOC1Config(TIM_TypeDef* TIMx, u16 TIM_ForcedAction)
-{
-  u16 tmpccmr1 = 0;
-
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
-
-  tmpccmr1 = TIMx-&gt;CCMR1;
-
-  /* Reset the OC1M Bits */
-  tmpccmr1 &amp;= CCMR_OC13M_Mask;
-
-  /* Configure The Forced output Mode */
-  tmpccmr1 |= TIM_ForcedAction;
-
-  /* Write to TIMx CCMR1 register */
-  TIMx-&gt;CCMR1 = tmpccmr1;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_ForcedOC2Config
-* Description    : Forces the TIMx output 2 waveform to active or inactive level.
-* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_ForcedAction: specifies the forced Action to be set to
-*                    the output waveform.
-*                    This parameter can be one of the following values:
-*                       - TIM_ForcedAction_Active: Force active level on OC2REF
-*                       - TIM_ForcedAction_InActive: Force inactive level on
-*                         OC2REF.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_ForcedOC2Config(TIM_TypeDef* TIMx, u16 TIM_ForcedAction)
-{
-  u16 tmpccmr1 = 0;
-
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
-
-  tmpccmr1 = TIMx-&gt;CCMR1;
-
-  /* Reset the OC2M Bits */
-  tmpccmr1 &amp;= CCMR_OC24M_Mask;
-
-  /* Configure The Forced output Mode */
-  tmpccmr1 |= (u16)(TIM_ForcedAction &lt;&lt; 8);
-
-  /* Write to TIMx CCMR1 register */
-  TIMx-&gt;CCMR1 = tmpccmr1;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_ForcedOC3Config
-* Description    : Forces the TIMx output 3 waveform to active or inactive level.
-* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_ForcedAction: specifies the forced Action to be set to
-*                    the output waveform.
-*                    This parameter can be one of the following values:
-*                       - TIM_ForcedAction_Active: Force active level on OC3REF
-*                       - TIM_ForcedAction_InActive: Force inactive level on
-*                         OC3REF.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_ForcedOC3Config(TIM_TypeDef* TIMx, u16 TIM_ForcedAction)
-{
-  u16 tmpccmr2 = 0;
-
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
-
-  tmpccmr2 = TIMx-&gt;CCMR2;
-
-  /* Reset the OC1M Bits */
-  tmpccmr2 &amp;= CCMR_OC13M_Mask;
-
-  /* Configure The Forced output Mode */
-  tmpccmr2 |= TIM_ForcedAction;
-
-  /* Write to TIMx CCMR2 register */
-  TIMx-&gt;CCMR2 = tmpccmr2;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_ForcedOC4Config
-* Description    : Forces the TIMx output 4 waveform to active or inactive level.
-* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_ForcedAction: specifies the forced Action to be set to
-*                    the output waveform.
-*                    This parameter can be one of the following values:
-*                       - TIM_ForcedAction_Active: Force active level on OC4REF
-*                       - TIM_ForcedAction_InActive: Force inactive level on
-*                         OC4REF.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_ForcedOC4Config(TIM_TypeDef* TIMx, u16 TIM_ForcedAction)
-{
-  u16 tmpccmr2 = 0;
-
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
-  tmpccmr2 = TIMx-&gt;CCMR2;
-
-  /* Reset the OC2M Bits */
-  tmpccmr2 &amp;= CCMR_OC24M_Mask;
-
-  /* Configure The Forced output Mode */
-  tmpccmr2 |= (u16)(TIM_ForcedAction &lt;&lt; 8);
-
-  /* Write to TIMx CCMR2 register */
-  TIMx-&gt;CCMR2 = tmpccmr2;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_ARRPreloadConfig
-* Description    : Enables or disables TIMx peripheral Preload register on ARR.
-* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - NewState: new state of the TIMx peripheral Preload register
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_ALL_PERIPH(TIMx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Set the ARR Preload Bit */
-    TIMx-&gt;CR1 |= CR1_ARPE_Set;
-  }
-  else
-  {
-    /* Reset the ARR Preload Bit */
-    TIMx-&gt;CR1 &amp;= CR1_ARPE_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : TIM_SelectCOM
-* Description    : Selects the TIM peripheral Commutation event.
-* Input          :- TIMx: where x can be  1 or 8 to select the TIMx peripheral
-*                 - NewState: new state of the Commutation event.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_SelectCOM(TIM_TypeDef* TIMx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_18_PERIPH(TIMx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Set the COM Bit */
-    TIMx-&gt;CR2 |= CR2_CCUS_Set;
-  }
-  else
-  {
-    /* Reset the COM Bit */
-    TIMx-&gt;CR2 &amp;= CR2_CCUS_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : TIM_SelectCCDMA
-* Description    : Selects the TIMx peripheral Capture Compare DMA source.
-* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - NewState: new state of the Capture Compare DMA source
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Set the CCDS Bit */
-    TIMx-&gt;CR2 |= CR2_CCDS_Set;
-  }
-  else
-  {
-    /* Reset the CCDS Bit */
-    TIMx-&gt;CR2 &amp;= CR2_CCDS_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : TIM_CCPreloadControl
-* Description    : Sets or Resets the TIM peripheral Capture Compare Preload 
-*                  Control bit.
-* Input          :- TIMx: where x can be  1 or 8 to select the TIMx peripheral
-*                 - NewState: new state of the Capture Compare Preload Control bit
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_CCPreloadControl(TIM_TypeDef* TIMx, FunctionalState NewState)
-{ 
-  /* Check the parameters */
-  assert_param(IS_TIM_18_PERIPH(TIMx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Set the CCPC Bit */
-    TIMx-&gt;CR2 |= CR2_CCPC_Set;
-  }
-  else
-  {
-    /* Reset the CCPC Bit */
-    TIMx-&gt;CR2 &amp;= CR2_CCPC_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : TIM_OC1PreloadConfig
-* Description    : Enables or disables the TIMx peripheral Preload register on CCR1.
-* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_OCPreload: new state of the TIMx peripheral Preload
-*                    register
-*                    This parameter can be one of the following values:
-*                       - TIM_OCPreload_Enable
-*                       - TIM_OCPreload_Disable
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, u16 TIM_OCPreload)
-{
-  u16 tmpccmr1 = 0;
-
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
-
-  tmpccmr1 = TIMx-&gt;CCMR1;
-
-  /* Reset the OC1PE Bit */
-  tmpccmr1 &amp;= CCMR_OC13PE_Reset;
-
-  /* Enable or Disable the Output Compare Preload feature */
-  tmpccmr1 |= TIM_OCPreload;
-
-  /* Write to TIMx CCMR1 register */
-  TIMx-&gt;CCMR1 = tmpccmr1;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_OC2PreloadConfig
-* Description    : Enables or disables the TIMx peripheral Preload register on CCR2.
-* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_OCPreload: new state of the TIMx peripheral Preload
-*                    register
-*                    This parameter can be one of the following values:
-*                       - TIM_OCPreload_Enable
-*                       - TIM_OCPreload_Disable
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, u16 TIM_OCPreload)
-{
-  u16 tmpccmr1 = 0;
-
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
-
-  tmpccmr1 = TIMx-&gt;CCMR1;
-
-  /* Reset the OC2PE Bit */
-  tmpccmr1 &amp;= CCMR_OC24PE_Reset;
-
-  /* Enable or Disable the Output Compare Preload feature */
-  tmpccmr1 |= (u16)(TIM_OCPreload &lt;&lt; 8);
-
-  /* Write to TIMx CCMR1 register */
-  TIMx-&gt;CCMR1 = tmpccmr1;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_OC3PreloadConfig
-* Description    : Enables or disables the TIMx peripheral Preload register on CCR3.
-* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_OCPreload: new state of the TIMx peripheral Preload
-*                    register
-*                    This parameter can be one of the following values:
-*                       - TIM_OCPreload_Enable
-*                       - TIM_OCPreload_Disable
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, u16 TIM_OCPreload)
-{
-  u16 tmpccmr2 = 0;
-
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
-
-  tmpccmr2 = TIMx-&gt;CCMR2;
-
-  /* Reset the OC3PE Bit */
-  tmpccmr2 &amp;= CCMR_OC13PE_Reset;
-
-  /* Enable or Disable the Output Compare Preload feature */
-  tmpccmr2 |= TIM_OCPreload;
-
-  /* Write to TIMx CCMR2 register */
-  TIMx-&gt;CCMR2 = tmpccmr2;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_OC4PreloadConfig
-* Description    : Enables or disables the TIMx peripheral Preload register on CCR4.
-* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_OCPreload: new state of the TIMx peripheral Preload
-*                    register
-*                    This parameter can be one of the following values:
-*                       - TIM_OCPreload_Enable
-*                       - TIM_OCPreload_Disable
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, u16 TIM_OCPreload)
-{
-  u16 tmpccmr2 = 0;
-
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
-
-  tmpccmr2 = TIMx-&gt;CCMR2;
-
-  /* Reset the OC4PE Bit */
-  tmpccmr2 &amp;= CCMR_OC24PE_Reset;
-
-  /* Enable or Disable the Output Compare Preload feature */
-  tmpccmr2 |= (u16)(TIM_OCPreload &lt;&lt; 8);
-
-  /* Write to TIMx CCMR2 register */
-  TIMx-&gt;CCMR2 = tmpccmr2;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_OC1FastConfig
-* Description    : Configures the TIMx Output Compare 1 Fast feature.
-* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_OCFast: new state of the Output Compare Fast Enable Bit.
-*                    This parameter can be one of the following values:
-*                       - TIM_OCFast_Enable: TIM output compare fast enable
-*                       - TIM_OCFast_Disable: TIM output compare fast disable
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_OC1FastConfig(TIM_TypeDef* TIMx, u16 TIM_OCFast)
-{
-  u16 tmpccmr1 = 0;
-
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
-
-  /* Get the TIMx CCMR1 register value */
-  tmpccmr1 = TIMx-&gt;CCMR1;
-
-  /* Reset the OC1FE Bit */
-  tmpccmr1 &amp;= CCMR_OC13FE_Reset;
-
-  /* Enable or Disable the Output Compare Fast Bit */
-  tmpccmr1 |= TIM_OCFast;
-
-  /* Write to TIMx CCMR1 */
-  TIMx-&gt;CCMR1 = tmpccmr1;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_OC2FastConfig
-* Description    : Configures the TIMx Output Compare 2 Fast feature.
-* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_OCFast: new state of the Output Compare Fast Enable Bit.
-*                    This parameter can be one of the following values:
-*                       - TIM_OCFast_Enable: TIM output compare fast enable
-*                       - TIM_OCFast_Disable: TIM output compare fast disable
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_OC2FastConfig(TIM_TypeDef* TIMx, u16 TIM_OCFast)
-{
-  u16 tmpccmr1 = 0;
-
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
-
-  /* Get the TIMx CCMR1 register value */
-  tmpccmr1 = TIMx-&gt;CCMR1;
-
-  /* Reset the OC2FE Bit */
-  tmpccmr1 &amp;= CCMR_OC24FE_Reset;
-
-  /* Enable or Disable the Output Compare Fast Bit */
-  tmpccmr1 |= (u16)(TIM_OCFast &lt;&lt; 8);
-
-  /* Write to TIMx CCMR1 */
-  TIMx-&gt;CCMR1 = tmpccmr1;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_OC3FastConfig
-* Description    : Configures the TIMx Output Compare 3 Fast feature.
-* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_OCFast: new state of the Output Compare Fast Enable Bit.
-*                    This parameter can be one of the following values:
-*                       - TIM_OCFast_Enable: TIM output compare fast enable
-*                       - TIM_OCFast_Disable: TIM output compare fast disable
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_OC3FastConfig(TIM_TypeDef* TIMx, u16 TIM_OCFast)
-{
-  u16 tmpccmr2 = 0;
-
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
-
-  /* Get the TIMx CCMR2 register value */
-  tmpccmr2 = TIMx-&gt;CCMR2;
-
-  /* Reset the OC3FE Bit */
-  tmpccmr2 &amp;= CCMR_OC13FE_Reset;
-
-  /* Enable or Disable the Output Compare Fast Bit */
-  tmpccmr2 |= TIM_OCFast;
-
-  /* Write to TIMx CCMR2 */
-  TIMx-&gt;CCMR2 = tmpccmr2;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_OC4FastConfig
-* Description    : Configures the TIMx Output Compare 4 Fast feature.
-* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_OCFast: new state of the Output Compare Fast Enable Bit.
-*                    This parameter can be one of the following values:
-*                       - TIM_OCFast_Enable: TIM output compare fast enable
-*                       - TIM_OCFast_Disable: TIM output compare fast disable
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_OC4FastConfig(TIM_TypeDef* TIMx, u16 TIM_OCFast)
-{
-  u16 tmpccmr2 = 0;
-
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
-
-  /* Get the TIMx CCMR2 register value */
-  tmpccmr2 = TIMx-&gt;CCMR2;
-
-  /* Reset the OC4FE Bit */
-  tmpccmr2 &amp;= CCMR_OC24FE_Reset;
-
-  /* Enable or Disable the Output Compare Fast Bit */
-  tmpccmr2 |= (u16)(TIM_OCFast &lt;&lt; 8);
-
-  /* Write to TIMx CCMR2 */
-  TIMx-&gt;CCMR2 = tmpccmr2;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_ClearOC1Ref
-* Description    : Clears or safeguards the OCREF1 signal on an external event
-* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_OCClear: new state of the Output Compare Clear Enable Bit.
-*                    This parameter can be one of the following values:
-*                       - TIM_OCClear_Enable: TIM Output clear enable
-*                       - TIM_OCClear_Disable: TIM Output clear disable
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_ClearOC1Ref(TIM_TypeDef* TIMx, u16 TIM_OCClear)
-{
-  u16 tmpccmr1 = 0;
-
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
-
-  tmpccmr1 = TIMx-&gt;CCMR1;
-
-  /* Reset the OC1CE Bit */
-  tmpccmr1 &amp;= CCMR_OC13CE_Reset;
-
-  /* Enable or Disable the Output Compare Clear Bit */
-  tmpccmr1 |= TIM_OCClear;
-
-  /* Write to TIMx CCMR1 register */
-  TIMx-&gt;CCMR1 = tmpccmr1;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_ClearOC2Ref
-* Description    : Clears or safeguards the OCREF2 signal on an external event
-* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_OCClear: new state of the Output Compare Clear Enable Bit.
-*                    This parameter can be one of the following values:
-*                       - TIM_OCClear_Enable: TIM Output clear enable
-*                       - TIM_OCClear_Disable: TIM Output clear disable
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_ClearOC2Ref(TIM_TypeDef* TIMx, u16 TIM_OCClear)
-{
-  u16 tmpccmr1 = 0;
-
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
-
-  tmpccmr1 = TIMx-&gt;CCMR1;
-
-  /* Reset the OC2CE Bit */
-  tmpccmr1 &amp;= CCMR_OC24CE_Reset;
-
-  /* Enable or Disable the Output Compare Clear Bit */
-  tmpccmr1 |= (u16)(TIM_OCClear &lt;&lt; 8);
-
-  /* Write to TIMx CCMR1 register */
-  TIMx-&gt;CCMR1 = tmpccmr1;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_ClearOC3Ref
-* Description    : Clears or safeguards the OCREF3 signal on an external event
-* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_OCClear: new state of the Output Compare Clear Enable Bit.
-*                    This parameter can be one of the following values:
-*                       - TIM_OCClear_Enable: TIM Output clear enable
-*                       - TIM_OCClear_Disable: TIM Output clear disable
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_ClearOC3Ref(TIM_TypeDef* TIMx, u16 TIM_OCClear)
-{
-  u16 tmpccmr2 = 0;
-
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
-
-  tmpccmr2 = TIMx-&gt;CCMR2;
-
-  /* Reset the OC3CE Bit */
-  tmpccmr2 &amp;= CCMR_OC13CE_Reset;
-
-  /* Enable or Disable the Output Compare Clear Bit */
-  tmpccmr2 |= TIM_OCClear;
-
-  /* Write to TIMx CCMR2 register */
-  TIMx-&gt;CCMR2 = tmpccmr2;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_ClearOC4Ref
-* Description    : Clears or safeguards the OCREF4 signal on an external event
-* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_OCClear: new state of the Output Compare Clear Enable Bit.
-*                    This parameter can be one of the following values:
-*                       - TIM_OCClear_Enable: TIM Output clear enable
-*                       - TIM_OCClear_Disable: TIM Output clear disable
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_ClearOC4Ref(TIM_TypeDef* TIMx, u16 TIM_OCClear)
-{
-  u16 tmpccmr2 = 0;
-
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
-
-  tmpccmr2 = TIMx-&gt;CCMR2;
-
-  /* Reset the OC4CE Bit */
-  tmpccmr2 &amp;= CCMR_OC24CE_Reset;
-
-  /* Enable or Disable the Output Compare Clear Bit */
-  tmpccmr2 |= (u16)(TIM_OCClear &lt;&lt; 8);
-
-  /* Write to TIMx CCMR2 register */
-  TIMx-&gt;CCMR2 = tmpccmr2;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_OC1PolarityConfig
-* Description    : Configures the TIMx channel 1 polarity.
-* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_OCPolarity: specifies the OC1 Polarity
-*                    This parmeter can be one of the following values:
-*                       - TIM_OCPolarity_High: Output Compare active high
-*                       - TIM_OCPolarity_Low: Output Compare active low
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCPolarity)
-{
-  u16 tmpccer = 0;
-
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
-
-  tmpccer = TIMx-&gt;CCER;
-
-  /* Set or Reset the CC1P Bit */
-  tmpccer &amp;= CCER_CC1P_Reset;
-  tmpccer |= TIM_OCPolarity;
-
-  /* Write to TIMx CCER register */
-  TIMx-&gt;CCER = tmpccer;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_OC1NPolarityConfig
-* Description    : Configures the TIMx Channel 1N polarity.
-* Input          : - TIMx: where x can be 1 or 8 to select the TIM peripheral.
-*                  - TIM_OCNPolarity: specifies the OC1N Polarity
-*                    This parmeter can be one of the following values:
-*                       - TIM_OCNPolarity_High: Output Compare active high
-*                       - TIM_OCNPolarity_Low: Output Compare active low
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCNPolarity)
-{
-  u16 tmpccer = 0;
-
-  /* Check the parameters */
-  assert_param(IS_TIM_18_PERIPH(TIMx));
-  assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
-   
-  tmpccer = TIMx-&gt;CCER;
-
-  /* Set or Reset the CC1NP Bit */
-  tmpccer &amp;= CCER_CC1NP_Reset;
-  tmpccer |= TIM_OCNPolarity;
-
-  /* Write to TIMx CCER register */
-  TIMx-&gt;CCER = tmpccer;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_OC2PolarityConfig
-* Description    : Configures the TIMx channel 2 polarity.
-* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_OCPolarity: specifies the OC2 Polarity
-*                    This parmeter can be one of the following values:
-*                       - TIM_OCPolarity_High: Output Compare active high
-*                       - TIM_OCPolarity_Low: Output Compare active low
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCPolarity)
-{
-  u16 tmpccer = 0;
-
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
-
-  tmpccer = TIMx-&gt;CCER;
-
-  /* Set or Reset the CC2P Bit */
-  tmpccer &amp;= CCER_CC2P_Reset;
-  tmpccer |= (u16)(TIM_OCPolarity &lt;&lt; 4);
-
-  /* Write to TIMx CCER register */
-  TIMx-&gt;CCER = tmpccer;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_OC2NPolarityConfig
-* Description    : Configures the TIMx Channel 2N polarity.
-* Input          : - TIMx: where x can be 1 or 8 to select the TIM peripheral.
-*                  - TIM_OCNPolarity: specifies the OC2N Polarity
-*                    This parmeter can be one of the following values:
-*                       - TIM_OCNPolarity_High: Output Compare active high
-*                       - TIM_OCNPolarity_Low: Output Compare active low
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_OC2NPolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCNPolarity)
-{
-  u16 tmpccer = 0;
-
-  /* Check the parameters */
-  assert_param(IS_TIM_18_PERIPH(TIMx));
-  assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
-  
-  tmpccer = TIMx-&gt;CCER;
-
-  /* Set or Reset the CC2NP Bit */
-  tmpccer &amp;= CCER_CC2NP_Reset;
-  tmpccer |= (u16)(TIM_OCNPolarity &lt;&lt; 4);
-
-  /* Write to TIMx CCER register */
-  TIMx-&gt;CCER = tmpccer;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_OC3PolarityConfig
-* Description    : Configures the TIMx channel 3 polarity.
-* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_OCPolarity: specifies the OC3 Polarity
-*                    This parmeter can be one of the following values:
-*                       - TIM_OCPolarity_High: Output Compare active high
-*                       - TIM_OCPolarity_Low: Output Compare active low
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCPolarity)
-{
-  u16 tmpccer = 0;
-
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
-
-  tmpccer = TIMx-&gt;CCER;
-
-  /* Set or Reset the CC3P Bit */
-  tmpccer &amp;= CCER_CC3P_Reset;
-  tmpccer |= (u16)(TIM_OCPolarity &lt;&lt; 8);
-
-  /* Write to TIMx CCER register */
-  TIMx-&gt;CCER = tmpccer;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_OC3NPolarityConfig
-* Description    : Configures the TIMx Channel 3N polarity.
-* Input          : - TIMx: where x can be 1 or 8 to select the TIM peripheral.
-*                  - TIM_OCNPolarity: specifies the OC3N Polarity
-*                    This parmeter can be one of the following values:
-*                       - TIM_OCNPolarity_High: Output Compare active high
-*                       - TIM_OCNPolarity_Low: Output Compare active low
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_OC3NPolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCNPolarity)
-{
-  u16 tmpccer = 0;
- 
-  /* Check the parameters */
-  assert_param(IS_TIM_18_PERIPH(TIMx));
-  assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
-    
-  tmpccer = TIMx-&gt;CCER;
-
-  /* Set or Reset the CC3NP Bit */
-  tmpccer &amp;= CCER_CC3NP_Reset;
-  tmpccer |= (u16)(TIM_OCNPolarity &lt;&lt; 8);
-
-  /* Write to TIMx CCER register */
-  TIMx-&gt;CCER = tmpccer;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_OC4PolarityConfig
-* Description    : Configures the TIMx channel 4 polarity.
-* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_OCPolarity: specifies the OC4 Polarity
-*                    This parmeter can be one of the following values:
-*                       - TIM_OCPolarity_High: Output Compare active high
-*                       - TIM_OCPolarity_Low: Output Compare active low
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCPolarity)
-{
-  u16 tmpccer = 0;
-
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
-
-  tmpccer = TIMx-&gt;CCER;
-
-  /* Set or Reset the CC4P Bit */
-  tmpccer &amp;= CCER_CC4P_Reset;
-  tmpccer |= (u16)(TIM_OCPolarity &lt;&lt; 12);
-
-  /* Write to TIMx CCER register */
-  TIMx-&gt;CCER = tmpccer;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_CCxCmd
-* Description    : Enables or disables the TIM Capture Compare Channel x.
-* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM
-*                    peripheral.
-*                  - TIM_Channel: specifies the TIM Channel
-*                    This parmeter can be one of the following values:
-*                       - TIM_Channel_1: TIM Channel 1
-*                       - TIM_Channel_2: TIM Channel 2
-*                       - TIM_Channel_3: TIM Channel 3
-*                       - TIM_Channel_4: TIM Channel 4
-*                 - TIM_CCx: specifies the TIM Channel CCxE bit new state.
-*                   This parameter can be: TIM_CCx_Enable or TIM_CCx_Disable. 
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_CCxCmd(TIM_TypeDef* TIMx, u16 TIM_Channel, u16 TIM_CCx)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_CHANNEL(TIM_Channel));
-  assert_param(IS_TIM_CCX(TIM_CCx));
-
-  /* Reset the CCxE Bit */
-  TIMx-&gt;CCER &amp;= (u16)(~((u16)(CCER_CCE_Set &lt;&lt; TIM_Channel)));
-
-  /* Set or reset the CCxE Bit */ 
-  TIMx-&gt;CCER |=  (u16)(TIM_CCx &lt;&lt; TIM_Channel);
-}
-
-/*******************************************************************************
-* Function Name  : TIM_CCxNCmd
-* Description    : Enables or disables the TIM Capture Compare Channel xN.
-* Input          :- TIMx: where x can be 1 or 8 to select the TIM peripheral.
-*                 - TIM_Channel: specifies the TIM Channel
-*                    This parmeter can be one of the following values:
-*                       - TIM_Channel_1: TIM Channel 1
-*                       - TIM_Channel_2: TIM Channel 2
-*                       - TIM_Channel_3: TIM Channel 3
-*                 - TIM_CCx: specifies the TIM Channel CCxNE bit new state.
-*                   This parameter can be: TIM_CCxN_Enable or TIM_CCxN_Disable. 
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_CCxNCmd(TIM_TypeDef* TIMx, u16 TIM_Channel, u16 TIM_CCxN)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_18_PERIPH(TIMx));
-  assert_param(IS_TIM_COMPLEMENTARY_CHANNEL(TIM_Channel));
-  assert_param(IS_TIM_CCXN(TIM_CCxN));
-
-  /* Reset the CCxNE Bit */
-  TIMx-&gt;CCER &amp;= (u16)(~((u16)(CCER_CCNE_Set &lt;&lt; TIM_Channel)));
-
-  /* Set or reset the CCxNE Bit */ 
-  TIMx-&gt;CCER |=  (u16)(TIM_CCxN &lt;&lt; TIM_Channel);
-}
-
-/*******************************************************************************
-* Function Name  : TIM_SelectOCxM
-* Description    : Selects the TIM Ouput Compare Mode.
-*                  This function disables the selected channel before changing 
-*                  the Ouput Compare Mode. User has to enable this channel using
-*                  TIM_CCxCmd and TIM_CCxNCmd functions.
-* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM
-*                    peripheral.
-*                  - TIM_Channel: specifies the TIM Channel
-*                    This parmeter can be one of the following values:
-*                       - TIM_Channel_1: TIM Channel 1
-*                       - TIM_Channel_2: TIM Channel 2
-*                       - TIM_Channel_3: TIM Channel 3
-*                       - TIM_Channel_4: TIM Channel 4
-*                  - TIM_OCMode: specifies the TIM Output Compare Mode.
-*                    This paramter can be one of the following values:
-*                       - TIM_OCMode_Timing
-*                       - TIM_OCMode_Active
-*                       - TIM_OCMode_Toggle
-*                       - TIM_OCMode_PWM1
-*                       - TIM_OCMode_PWM2
-*                       - TIM_ForcedAction_Active
-*                       - TIM_ForcedAction_InActive
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_SelectOCxM(TIM_TypeDef* TIMx, u16 TIM_Channel, u16 TIM_OCMode)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_CHANNEL(TIM_Channel));
-  assert_param(IS_TIM_OCM(TIM_OCMode));
-  
-  /* Disable the Channel: Reset the CCxE Bit */
-  TIMx-&gt;CCER &amp;= (u16)(~((u16)(CCER_CCE_Set &lt;&lt; TIM_Channel)));
-
-  if((TIM_Channel == TIM_Channel_1) ||(TIM_Channel == TIM_Channel_3))
-  {
-    /* Reset the OCxM bits in the CCMRx register */
-    *((vu32 *)((*(u32*)&amp;TIMx) + CCMR_Offset + (TIM_Channel&gt;&gt;1))) &amp;= CCMR_OC13M_Mask;
-   
-    /* Configure the OCxM bits in the CCMRx register */
-    *((vu32 *)((*(u32*)&amp;TIMx) + CCMR_Offset + (TIM_Channel&gt;&gt;1))) |= TIM_OCMode;
-
-  }
-  else
-  {
-    /* Reset the OCxM bits in the CCMRx register */
-    *((vu32 *)((*(u32*)&amp;TIMx) + CCMR_Offset + ((u16)(TIM_Channel - 4)&gt;&gt; 1))) &amp;= CCMR_OC24M_Mask;
-    
-    /* Configure the OCxM bits in the CCMRx register */
-    *((vu32 *)((*(u32*)&amp;TIMx) + CCMR_Offset + ((u16)(TIM_Channel - 4)&gt;&gt; 1))) |= (u16)(TIM_OCMode &lt;&lt; 8);
-  }
-}
-
-/*******************************************************************************
-* Function Name  : TIM_UpdateDisableConfig
-* Description    : Enables or Disables the TIMx Update event.
-* Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
-*                  - NewState: new state of the TIMx UDIS bit
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_ALL_PERIPH(TIMx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Set the Update Disable Bit */
-    TIMx-&gt;CR1 |= CR1_UDIS_Set;
-  }
-  else
-  {
-    /* Reset the Update Disable Bit */
-    TIMx-&gt;CR1 &amp;= CR1_UDIS_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : TIM_UpdateRequestConfig
-* Description    : Configures the TIMx Update Request Interrupt source.
-* Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
-*                  - TIM_UpdateSource: specifies the Update source.
-*                    This parameter can be one of the following values:
-*                       - TIM_UpdateSource_Regular
-*                       - TIM_UpdateSource_Global
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, u16 TIM_UpdateSource)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_ALL_PERIPH(TIMx));
-  assert_param(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));
-
-  if (TIM_UpdateSource != TIM_UpdateSource_Global)
-  {
-    /* Set the URS Bit */
-    TIMx-&gt;CR1 |= CR1_URS_Set;
-  }
-  else
-  {
-    /* Reset the URS Bit */
-    TIMx-&gt;CR1 &amp;= CR1_URS_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : TIM_SelectHallSensor
-* Description    : Enables or disables the TIMx's Hall sensor interface.
-* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
-*                  - NewState: new state of the TIMx Hall sensor interface.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Set the TI1S Bit */
-    TIMx-&gt;CR2 |= CR2_TI1S_Set;
-  }
-  else
-  {
-    /* Reset the TI1S Bit */
-    TIMx-&gt;CR2 &amp;= CR2_TI1S_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : TIM_SelectOnePulseMode
-* Description    : Selects the TIMx's One Pulse Mode.
-* Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
-*                  - TIM_OPMode: specifies the OPM Mode to be used.
-*                    This parameter can be one of the following values:
-*                       - TIM_OPMode_Single
-*                       - TIM_OPMode_Repetitive
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, u16 TIM_OPMode)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_ALL_PERIPH(TIMx));
-  assert_param(IS_TIM_OPM_MODE(TIM_OPMode));
-
-  /* Reset the OPM Bit */
-  TIMx-&gt;CR1 &amp;= CR1_OPM_Reset;
-
-  /* Configure the OPM Mode */
-  TIMx-&gt;CR1 |= TIM_OPMode;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_SelectOutputTrigger
-* Description    : Selects the TIMx Trigger Output Mode.
-* Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
-*                  - TIM_TRGOSource: specifies the Trigger Output source.
-*                    This paramter can be as follow:
-*                      1/ For TIM1 to TIM8:
-*                       - TIM_TRGOSource_Reset 
-*                       - TIM_TRGOSource_Enable
-*                       - TIM_TRGOSource_Update
-*                      2/ These parameters are available for all TIMx except 
-*                         TIM6 and TIM7:
-*                       - TIM_TRGOSource_OC1
-*                       - TIM_TRGOSource_OC1Ref
-*                       - TIM_TRGOSource_OC2Ref
-*                       - TIM_TRGOSource_OC3Ref
-*                       - TIM_TRGOSource_OC4Ref
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, u16 TIM_TRGOSource)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_ALL_PERIPH(TIMx));
-  assert_param(IS_TIM_TRGO_SOURCE(TIM_TRGOSource));
-  assert_param(IS_TIM_PERIPH_TRGO(TIMx, TIM_TRGOSource));
-
-  /* Reset the MMS Bits */
-  TIMx-&gt;CR2 &amp;= CR2_MMS_Mask;
-
-  /* Select the TRGO source */
-  TIMx-&gt;CR2 |=  TIM_TRGOSource;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_SelectSlaveMode
-* Description    : Selects the TIMx Slave Mode.
-* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_SlaveMode: specifies the Timer Slave Mode.
-*                    This paramter can be one of the following values:
-*                       - TIM_SlaveMode_Reset
-*                       - TIM_SlaveMode_Gated
-*                       - TIM_SlaveMode_Trigger
-*                       - TIM_SlaveMode_External1
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, u16 TIM_SlaveMode)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_SLAVE_MODE(TIM_SlaveMode));
-
-  /* Reset the SMS Bits */
-  TIMx-&gt;SMCR &amp;= SMCR_SMS_Mask;
-
-  /* Select the Slave Mode */
-  TIMx-&gt;SMCR |= TIM_SlaveMode;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_SelectMasterSlaveMode
-* Description    : Sets or Resets the TIMx Master/Slave Mode.
-* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_MasterSlaveMode: specifies the Timer Master Slave Mode.
-*                    This paramter can be one of the following values:
-*                       - TIM_MasterSlaveMode_Enable: synchronization between the
-*                         current timer and its slaves (through TRGO).
-*                       - TIM_MasterSlaveMode_Disable: No action
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, u16 TIM_MasterSlaveMode)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_MSM_STATE(TIM_MasterSlaveMode));
-
-  /* Reset the MSM Bit */
-  TIMx-&gt;SMCR &amp;= SMCR_MSM_Reset;
-  
-  /* Set or Reset the MSM Bit */
-  TIMx-&gt;SMCR |= TIM_MasterSlaveMode;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_SetCounter
-* Description    : Sets the TIMx Counter Register value
-* Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
-*                  - Counter: specifies the Counter register new value.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_SetCounter(TIM_TypeDef* TIMx, u16 Counter)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_ALL_PERIPH(TIMx));
-
-  /* Set the Counter Register value */
-  TIMx-&gt;CNT = Counter;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_SetAutoreload
-* Description    : Sets the TIMx Autoreload Register value
-* Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
-*                  - Autoreload: specifies the Autoreload register new value.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_SetAutoreload(TIM_TypeDef* TIMx, u16 Autoreload)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_ALL_PERIPH(TIMx));
-
-  /* Set the Autoreload Register value */
-  TIMx-&gt;ARR = Autoreload;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_SetCompare1
-* Description    : Sets the TIMx Capture Compare1 Register value
-* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - Compare1: specifies the Capture Compare1 register new value.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_SetCompare1(TIM_TypeDef* TIMx, u16 Compare1)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-
-  /* Set the Capture Compare1 Register value */
-  TIMx-&gt;CCR1 = Compare1;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_SetCompare2
-* Description    : Sets the TIMx Capture Compare2 Register value
-* Input          :  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
-*                   peripheral.
-*                  - Compare2: specifies the Capture Compare2 register new value.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_SetCompare2(TIM_TypeDef* TIMx, u16 Compare2)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-
-  /* Set the Capture Compare2 Register value */
-  TIMx-&gt;CCR2 = Compare2;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_SetCompare3
-* Description    : Sets the TIMx Capture Compare3 Register value
-* Input          :  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
-*                   peripheral.
-*                  - Compare3: specifies the Capture Compare3 register new value.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_SetCompare3(TIM_TypeDef* TIMx, u16 Compare3)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-
-  /* Set the Capture Compare3 Register value */
-  TIMx-&gt;CCR3 = Compare3;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_SetCompare4
-* Description    : Sets the TIMx Capture Compare4 Register value
-* Input          :  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
-*                   peripheral.
-*                  - Compare4: specifies the Capture Compare4 register new value.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_SetCompare4(TIM_TypeDef* TIMx, u16 Compare4)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-
-  /* Set the Capture Compare4 Register value */
-  TIMx-&gt;CCR4 = Compare4;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_SetIC1Prescaler
-* Description    : Sets the TIMx Input Capture 1 prescaler.
-* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_ICPSC: specifies the Input Capture1 prescaler
-*                    new value.
-*                    This parameter can be one of the following values:
-*                       - TIM_ICPSC_DIV1: no prescaler
-*                       - TIM_ICPSC_DIV2: capture is done once every 2 events
-*                       - TIM_ICPSC_DIV4: capture is done once every 4 events
-*                       - TIM_ICPSC_DIV8: capture is done once every 8 events
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, u16 TIM_ICPSC)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
-
-  /* Reset the IC1PSC Bits */
-  TIMx-&gt;CCMR1 &amp;= CCMR_IC13PSC_Mask;
-
-  /* Set the IC1PSC value */
-  TIMx-&gt;CCMR1 |= TIM_ICPSC;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_SetIC2Prescaler
-* Description    : Sets the TIMx Input Capture 2 prescaler.
-* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_ICPSC: specifies the Input Capture2 prescaler
-*                    new value.
-*                    This parameter can be one of the following values:
-*                       - TIM_ICPSC_DIV1: no prescaler
-*                       - TIM_ICPSC_DIV2: capture is done once every 2 events
-*                       - TIM_ICPSC_DIV4: capture is done once every 4 events
-*                       - TIM_ICPSC_DIV8: capture is done once every 8 events
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, u16 TIM_ICPSC)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
-
-  /* Reset the IC2PSC Bits */
-  TIMx-&gt;CCMR1 &amp;= CCMR_IC24PSC_Mask;
-
-  /* Set the IC2PSC value */
-  TIMx-&gt;CCMR1 |= (u16)(TIM_ICPSC &lt;&lt; 8);
-}
-
-/*******************************************************************************
-* Function Name  : TIM_SetIC3Prescaler
-* Description    : Sets the TIMx Input Capture 3 prescaler.
-* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_ICPSC: specifies the Input Capture3 prescaler
-*                    new value.
-*                    This parameter can be one of the following values:
-*                       - TIM_ICPSC_DIV1: no prescaler
-*                       - TIM_ICPSC_DIV2: capture is done once every 2 events
-*                       - TIM_ICPSC_DIV4: capture is done once every 4 events
-*                       - TIM_ICPSC_DIV8: capture is done once every 8 events
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, u16 TIM_ICPSC)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
-
-  /* Reset the IC3PSC Bits */
-  TIMx-&gt;CCMR2 &amp;= CCMR_IC13PSC_Mask;
-
-  /* Set the IC3PSC value */
-  TIMx-&gt;CCMR2 |= TIM_ICPSC;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_SetIC4Prescaler
-* Description    : Sets the TIMx Input Capture 4 prescaler.
-* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_ICPSC: specifies the Input Capture4 prescaler
-*                    new value.
-*                    This parameter can be one of the following values:
-*                      - TIM_ICPSC_DIV1: no prescaler
-*                      - TIM_ICPSC_DIV2: capture is done once every 2 events
-*                      - TIM_ICPSC_DIV4: capture is done once every 4 events
-*                      - TIM_ICPSC_DIV8: capture is done once every 8 events
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, u16 TIM_ICPSC)
-{  
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
-
-  /* Reset the IC4PSC Bits */
-  TIMx-&gt;CCMR2 &amp;= CCMR_IC24PSC_Mask;
-
-  /* Set the IC4PSC value */
-  TIMx-&gt;CCMR2 |= (u16)(TIM_ICPSC &lt;&lt; 8);
-}
-
-/*******************************************************************************
-* Function Name  : TIM_SetClockDivision
-* Description    : Sets the TIMx Clock Division value.
-* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_CKD: specifies the clock division value.
-*                    This parameter can be one of the following value:
-*                       - TIM_CKD_DIV1: TDTS = Tck_tim
-*                       - TIM_CKD_DIV2: TDTS = 2*Tck_tim
-*                       - TIM_CKD_DIV4: TDTS = 4*Tck_tim
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_SetClockDivision(TIM_TypeDef* TIMx, u16 TIM_CKD)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_CKD_DIV(TIM_CKD));
-
-  /* Reset the CKD Bits */
-  TIMx-&gt;CR1 &amp;= CR1_CKD_Mask;
-
-  /* Set the CKD value */
-  TIMx-&gt;CR1 |= TIM_CKD;
-}
-/*******************************************************************************
-* Function Name  : TIM_GetCapture1
-* Description    : Gets the TIMx Input Capture 1 value.
-* Input          :  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
-*                   peripheral.
-* Output         : None
-* Return         : Capture Compare 1 Register value.
-*******************************************************************************/
-u16 TIM_GetCapture1(TIM_TypeDef* TIMx)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-
-  /* Get the Capture 1 Register value */
-  return TIMx-&gt;CCR1;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_GetCapture2
-* Description    : Gets the TIMx Input Capture 2 value.
-* Input          :  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
-*                   peripheral.
-* Output         : None
-* Return         : Capture Compare 2 Register value.
-*******************************************************************************/
-u16 TIM_GetCapture2(TIM_TypeDef* TIMx)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-
-  /* Get the Capture 2 Register value */
-  return TIMx-&gt;CCR2;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_GetCapture3
-* Description    : Gets the TIMx Input Capture 3 value.
-* Input          :  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
-*                   peripheral.
-* Output         : None
-* Return         : Capture Compare 3 Register value.
-*******************************************************************************/
-u16 TIM_GetCapture3(TIM_TypeDef* TIMx)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx)); 
-
-  /* Get the Capture 3 Register value */
-  return TIMx-&gt;CCR3;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_GetCapture4
-* Description    : Gets the TIMx Input Capture 4 value.
-* Input          :  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
-*                   peripheral.
-* Output         : None
-* Return         : Capture Compare 4 Register value.
-*******************************************************************************/
-u16 TIM_GetCapture4(TIM_TypeDef* TIMx)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-
-  /* Get the Capture 4 Register value */
-  return TIMx-&gt;CCR4;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_GetCounter
-* Description    : Gets the TIMx Counter value.
-* Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
-* Output         : None
-* Return         : Counter Register value.
-*******************************************************************************/
-u16 TIM_GetCounter(TIM_TypeDef* TIMx)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_ALL_PERIPH(TIMx));
-
-  /* Get the Counter Register value */
-  return TIMx-&gt;CNT;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_GetPrescaler
-* Description    : Gets the TIMx Prescaler value.
-* Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
-* Output         : None
-* Return         : Prescaler Register value.
-*******************************************************************************/
-u16 TIM_GetPrescaler(TIM_TypeDef* TIMx)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_ALL_PERIPH(TIMx));
-
-  /* Get the Prescaler Register value */
-  return TIMx-&gt;PSC;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_GetFlagStatus
-* Description    : Checks whether the specified TIM flag is set or not.
-* Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
-*                  - TIM_FLAG: specifies the flag to check.
-*                    This parameter can be one of the following values:
-*                       - TIM_FLAG_Update: TIM update Flag
-*                       - TIM_FLAG_CC1: TIM Capture Compare 1 Flag
-*                       - TIM_FLAG_CC2: TIM Capture Compare 2 Flag
-*                       - TIM_FLAG_CC3: TIM Capture Compare 3 Flag
-*                       - TIM_FLAG_CC4: TIM Capture Compare 4 Flag
-*                       - TIM_FLAG_COM: TIM Commutation Flag
-*                       - TIM_FLAG_Trigger: TIM Trigger Flag
-*                       - TIM_FLAG_Break: TIM Break Flag
-*                       - TIM_FLAG_CC1OF: TIM Capture Compare 1 overcapture Flag
-*                       - TIM_FLAG_CC2OF: TIM Capture Compare 2 overcapture Flag
-*                       - TIM_FLAG_CC3OF: TIM Capture Compare 3 overcapture Flag
-*                       - TIM_FLAG_CC4OF: TIM Capture Compare 4 overcapture Flag
-* Output         : None
-* Return         : The new state of TIM_FLAG (SET or RESET).
-*******************************************************************************/
-FlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, u16 TIM_FLAG)
-{ 
-  ITStatus bitstatus = RESET;  
-
-  /* Check the parameters */
-  assert_param(IS_TIM_ALL_PERIPH(TIMx));
-  assert_param(IS_TIM_GET_FLAG(TIM_FLAG));
-  assert_param(IS_TIM_PERIPH_FLAG(TIMx, TIM_FLAG));
-  
-  if ((TIMx-&gt;SR &amp; TIM_FLAG) != (u16)RESET)
-  {
-    bitstatus = SET;
-  }
-  else
-  {
-    bitstatus = RESET;
-  }
-  return bitstatus;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_ClearFlag
-* Description    : Clears the TIMx's pending flags.
-* Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
-*                  - TIM_FLAG: specifies the flag bit to clear.
-*                    This parameter can be any combination of the following values:
-*                       - TIM_FLAG_Update: TIM update Flag
-*                       - TIM_FLAG_CC1: TIM Capture Compare 1 Flag
-*                       - TIM_FLAG_CC2: TIM Capture Compare 2 Flag
-*                       - TIM_FLAG_CC3: TIM Capture Compare 3 Flag
-*                       - TIM_FLAG_CC4: TIM Capture Compare 4 Flag
-*                       - TIM_FLAG_COM: TIM Commutation Flag
-*                       - TIM_FLAG_Trigger: TIM Trigger Flag
-*                       - TIM_FLAG_Break: TIM Break Flag
-*                       - TIM_FLAG_CC1OF: TIM Capture Compare 1 overcapture Flag
-*                       - TIM_FLAG_CC2OF: TIM Capture Compare 2 overcapture Flag
-*                       - TIM_FLAG_CC3OF: TIM Capture Compare 3 overcapture Flag
-*                       - TIM_FLAG_CC4OF: TIM Capture Compare 4 overcapture Flag
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_ClearFlag(TIM_TypeDef* TIMx, u16 TIM_FLAG)
-{  
-  /* Check the parameters */
-  assert_param(IS_TIM_ALL_PERIPH(TIMx));
-  assert_param(IS_TIM_CLEAR_FLAG(TIMx, TIM_FLAG));
-   
-  /* Clear the flags */
-  TIMx-&gt;SR = (u16)~TIM_FLAG;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_GetITStatus
-* Description    : Checks whether the TIM interrupt has occurred or not.
-* Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
-*                  - TIM_IT: specifies the TIM interrupt source to check.
-*                    This parameter can be one of the following values:
-*                       - TIM_IT_Update: TIM update Interrupt source
-*                       - TIM_IT_CC1: TIM Capture Compare 1 Interrupt source
-*                       - TIM_IT_CC2: TIM Capture Compare 2 Interrupt source
-*                       - TIM_IT_CC3: TIM Capture Compare 3 Interrupt source
-*                       - TIM_IT_CC4: TIM Capture Compare 4 Interrupt source
-*                       - TIM_IT_COM: TIM Commutation Interrupt
-*                         source
-*                       - TIM_IT_Trigger: TIM Trigger Interrupt source
-*                       - TIM_IT_Break: TIM Break Interrupt source
-* Output         : None
-* Return         : The new state of the TIM_IT(SET or RESET).
-*******************************************************************************/
-ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, u16 TIM_IT)
-{
-  ITStatus bitstatus = RESET;  
-  u16 itstatus = 0x0, itenable = 0x0;
-
-  /* Check the parameters */
-  assert_param(IS_TIM_ALL_PERIPH(TIMx));
-  assert_param(IS_TIM_GET_IT(TIM_IT));
-  assert_param(IS_TIM_PERIPH_IT(TIMx, TIM_IT));
-   
-  itstatus = TIMx-&gt;SR &amp; TIM_IT;
-  
-  itenable = TIMx-&gt;DIER &amp; TIM_IT;
-
-  if ((itstatus != (u16)RESET) &amp;&amp; (itenable != (u16)RESET))
-  {
-    bitstatus = SET;
-  }
-  else
-  {
-    bitstatus = RESET;
-  }
-  return bitstatus;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_ClearITPendingBit
-* Description    : Clears the TIMx's interrupt pending bits.
-* Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
-*                  - TIM_IT: specifies the pending bit to clear.
-*                    This parameter can be any combination of the following values:
-*                       - TIM_IT_Update: TIM1 update Interrupt source
-*                       - TIM_IT_CC1: TIM Capture Compare 1 Interrupt source
-*                       - TIM_IT_CC2: TIM Capture Compare 2 Interrupt source
-*                       - TIM_IT_CC3: TIM Capture Compare 3 Interrupt source
-*                       - TIM_IT_CC4: TIM Capture Compare 4 Interrupt source
-*                       - TIM_IT_COM: TIM Commutation Interrupt
-*                         source
-*                       - TIM_IT_Trigger: TIM Trigger Interrupt source
-*                       - TIM_IT_Break: TIM Break Interrupt source
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, u16 TIM_IT)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_ALL_PERIPH(TIMx));
-  assert_param(IS_TIM_PERIPH_IT(TIMx, TIM_IT));
-
-  /* Clear the IT pending Bit */
-  TIMx-&gt;SR = (u16)~TIM_IT;
-}
-
-/*******************************************************************************
-* Function Name  : TI1_Config
-* Description    : Configure the TI1 as Input.
-* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_ICPolarity : The Input Polarity.
-*                    This parameter can be one of the following values:
-*                       - TIM_ICPolarity_Rising
-*                       - TIM_ICPolarity_Falling
-*                  - TIM_ICSelection: specifies the input to be used.
-*                    This parameter can be one of the following values:
-*                       - TIM_ICSelection_DirectTI: TIM Input 1 is selected to
-*                         be connected to IC1.
-*                       - TIM_ICSelection_IndirectTI: TIM Input 1 is selected to
-*                         be connected to IC2.
-*                       - TIM_ICSelection_TRC: TIM Input 1 is selected to be
-*                         connected to TRC.
-*                  - TIM_ICFilter: Specifies the Input Capture Filter.
-*                    This parameter must be a value between 0x00 and 0x0F.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-static void TI1_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
-                       u16 TIM_ICFilter)
-{
-  u16 tmpccmr1 = 0, tmpccer = 0;
-
-  /* Disable the Channel 1: Reset the CC1E Bit */
-  TIMx-&gt;CCER &amp;= CCER_CC1E_Reset;
-
-  tmpccmr1 = TIMx-&gt;CCMR1;
-  tmpccer = TIMx-&gt;CCER;
-
-  /* Select the Input and set the filter */
-  tmpccmr1 &amp;= CCMR_CC13S_Mask &amp; CCMR_IC13F_Mask;
-  tmpccmr1 |= TIM_ICSelection | (u16)(TIM_ICFilter &lt;&lt; 4);
-
-  /* Select the Polarity and set the CC1E Bit */
-  tmpccer &amp;= CCER_CC1P_Reset;
-  tmpccer |= TIM_ICPolarity | CCER_CC1E_Set;
-
-  /* Write to TIMx CCMR1 and CCER registers */
-  TIMx-&gt;CCMR1 = tmpccmr1;
-  TIMx-&gt;CCER = tmpccer;
-}
-
-/*******************************************************************************
-* Function Name  : TI2_Config
-* Description    : Configure the TI2 as Input.
-* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_ICPolarity : The Input Polarity.
-*                    This parameter can be one of the following values:
-*                       - TIM_ICPolarity_Rising
-*                       - TIM_ICPolarity_Falling
-*                  - TIM_ICSelection: specifies the input to be used.
-*                    This parameter can be one of the following values:
-*                       - TIM_ICSelection_DirectTI: TIM Input 2 is selected to
-*                         be connected to IC2.
-*                       - TIM_ICSelection_IndirectTI: TIM Input 2 is selected to
-*                         be connected to IC1.
-*                       - TIM_ICSelection_TRC: TIM Input 2 is selected to be
-*                         connected to TRC.
-*                  - TIM_ICFilter: Specifies the Input Capture Filter.
-*                    This parameter must be a value between 0x00 and 0x0F.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-static void TI2_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
-                       u16 TIM_ICFilter)
-{
-  u16 tmpccmr1 = 0, tmpccer = 0, tmp = 0;
-
-  /* Disable the Channel 2: Reset the CC2E Bit */
-  TIMx-&gt;CCER &amp;= CCER_CC2E_Reset;
-
-  tmpccmr1 = TIMx-&gt;CCMR1;
-  tmpccer = TIMx-&gt;CCER;
-  tmp = (u16)(TIM_ICPolarity &lt;&lt; 4);
-
-  /* Select the Input and set the filter */
-  tmpccmr1 &amp;= CCMR_CC24S_Mask &amp; CCMR_IC24F_Mask;
-  tmpccmr1 |= (u16)(TIM_ICFilter &lt;&lt; 12);
-  tmpccmr1 |= (u16)(TIM_ICSelection &lt;&lt; 8);
-
-  /* Select the Polarity and set the CC2E Bit */
-  tmpccer &amp;= CCER_CC2P_Reset;
-  tmpccer |=  tmp | CCER_CC2E_Set;
-
-  /* Write to TIMx CCMR1 and CCER registers */
-  TIMx-&gt;CCMR1 = tmpccmr1 ;
-  TIMx-&gt;CCER = tmpccer;
-}
-
-/*******************************************************************************
-* Function Name  : TI3_Config
-* Description    : Configure the TI3 as Input.
-* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_ICPolarity : The Input Polarity.
-*                    This parameter can be one of the following values:
-*                       - TIM_ICPolarity_Rising
-*                       - TIM_ICPolarity_Falling
-*                  - TIM_ICSelection: specifies the input to be used.
-*                    This parameter can be one of the following values:
-*                       - TIM_ICSelection_DirectTI: TIM Input 3 is selected to
-*                         be connected to IC3.
-*                       - TIM_ICSelection_IndirectTI: TIM Input 3 is selected to
-*                         be connected to IC4.
-*                       - TIM_ICSelection_TRC: TIM Input 3 is selected to be
-*                         connected to TRC.
-*                  - TIM_ICFilter: Specifies the Input Capture Filter.
-*                    This parameter must be a value between 0x00 and 0x0F.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-static void TI3_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
-                       u16 TIM_ICFilter)
-{
-  u16 tmpccmr2 = 0, tmpccer = 0, tmp = 0;
-
-  /* Disable the Channel 3: Reset the CC3E Bit */
-  TIMx-&gt;CCER &amp;= CCER_CC3E_Reset;
-
-  tmpccmr2 = TIMx-&gt;CCMR2;
-  tmpccer = TIMx-&gt;CCER;
-  tmp = (u16)(TIM_ICPolarity &lt;&lt; 8);
-
-  /* Select the Input and set the filter */
-  tmpccmr2 &amp;= CCMR_CC13S_Mask &amp; CCMR_IC13F_Mask;
-  tmpccmr2 |= TIM_ICSelection | (u16)(TIM_ICFilter &lt;&lt; 4);
-
-  /* Select the Polarity and set the CC3E Bit */
-  tmpccer &amp;= CCER_CC3P_Reset;
-  tmpccer |= tmp | CCER_CC3E_Set;
-
-  /* Write to TIMx CCMR2 and CCER registers */
-  TIMx-&gt;CCMR2 = tmpccmr2;
-  TIMx-&gt;CCER = tmpccer;
-}
-
-/*******************************************************************************
-* Function Name  : TI4_Config
-* Description    : Configure the TI1 as Input.
-* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_ICPolarity : The Input Polarity.
-*                    This parameter can be one of the following values:
-*                       - TIM_ICPolarity_Rising
-*                       - TIM_ICPolarity_Falling
-*                  - TIM_ICSelection: specifies the input to be used.
-*                    This parameter can be one of the following values:
-*                       - TIM_ICSelection_DirectTI: TIM Input 4 is selected to
-*                         be connected to IC4.
-*                       - TIM_ICSelection_IndirectTI: TIM Input 4 is selected to
-*                         be connected to IC3.
-*                       - TIM_ICSelection_TRC: TIM Input 4 is selected to be
-*                         connected to TRC.
-*                  - TIM_ICFilter: Specifies the Input Capture Filter.
-*                    This parameter must be a value between 0x00 and 0x0F.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-static void TI4_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
-                       u16 TIM_ICFilter)
-{
-  u16 tmpccmr2 = 0, tmpccer = 0, tmp = 0;
-
-  /* Disable the Channel 4: Reset the CC4E Bit */
-  TIMx-&gt;CCER &amp;= CCER_CC4E_Reset;
-
-  tmpccmr2 = TIMx-&gt;CCMR2;
-  tmpccer = TIMx-&gt;CCER;
-  tmp = (u16)(TIM_ICPolarity &lt;&lt; 12);
-
-  /* Select the Input and set the filter */
-  tmpccmr2 &amp;= CCMR_CC24S_Mask &amp; CCMR_IC24F_Mask;
-  tmpccmr2 |= (u16)(TIM_ICSelection &lt;&lt; 8) | (u16)(TIM_ICFilter &lt;&lt; 12);
-
-  /* Select the Polarity and set the CC4E Bit */
-  tmpccer &amp;= CCER_CC4P_Reset;
-  tmpccer |= tmp | CCER_CC4E_Set;
-
-  /* Write to TIMx CCMR2 and CCER registers */
-  TIMx-&gt;CCMR2 = tmpccmr2;
-  TIMx-&gt;CCER = tmpccer ;
-}
-
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
+/**
+  ******************************************************************************
+  * @file    stm32f10x_tim.c
+  * @author  MCD Application Team
+  * @version V3.1.0
+  * @date    06/19/2009
+  * @brief   This file provides all the TIM firmware functions.
+  ******************************************************************************
+  * @copy
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * &lt;h2&gt;&lt;center&gt;&copy; COPYRIGHT 2009 STMicroelectronics&lt;/center&gt;&lt;/h2&gt;
+  */ 
+
+/* Includes ------------------------------------------------------------------*/
+#include &quot;stm32f10x_tim.h&quot;
+#include &quot;stm32f10x_rcc.h&quot;
+
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup TIM 
+  * @brief TIM driver modules
+  * @{
+  */
+
+/** @defgroup TIM_Private_TypesDefinitions
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup TIM_Private_Defines
+  * @{
+  */
+
+/* ---------------------- TIM registers bit mask ------------------------ */
+#define CR1_CEN_Set                 ((uint16_t)0x0001)
+#define CR1_CEN_Reset               ((uint16_t)0x03FE)
+#define CR1_UDIS_Set                ((uint16_t)0x0002)
+#define CR1_UDIS_Reset              ((uint16_t)0x03FD)
+#define CR1_URS_Set                 ((uint16_t)0x0004)
+#define CR1_URS_Reset               ((uint16_t)0x03FB)
+#define CR1_OPM_Reset               ((uint16_t)0x03F7)
+#define CR1_CounterMode_Mask        ((uint16_t)0x038F)
+#define CR1_ARPE_Set                ((uint16_t)0x0080)
+#define CR1_ARPE_Reset              ((uint16_t)0x037F)
+#define CR1_CKD_Mask                ((uint16_t)0x00FF)
+#define CR2_CCPC_Set                ((uint16_t)0x0001)
+#define CR2_CCPC_Reset              ((uint16_t)0xFFFE)
+#define CR2_CCUS_Set                ((uint16_t)0x0004)
+#define CR2_CCUS_Reset              ((uint16_t)0xFFFB)
+#define CR2_CCDS_Set                ((uint16_t)0x0008)
+#define CR2_CCDS_Reset              ((uint16_t)0xFFF7)
+#define CR2_MMS_Mask                ((uint16_t)0xFF8F)
+#define CR2_TI1S_Set                ((uint16_t)0x0080)
+#define CR2_TI1S_Reset              ((uint16_t)0xFF7F)
+#define CR2_OIS1_Reset              ((uint16_t)0x7EFF)
+#define CR2_OIS1N_Reset             ((uint16_t)0x7DFF)
+#define CR2_OIS2_Reset              ((uint16_t)0x7BFF)
+#define CR2_OIS2N_Reset             ((uint16_t)0x77FF)
+#define CR2_OIS3_Reset              ((uint16_t)0x6FFF)
+#define CR2_OIS3N_Reset             ((uint16_t)0x5FFF)
+#define CR2_OIS4_Reset              ((uint16_t)0x3FFF)
+#define SMCR_SMS_Mask               ((uint16_t)0xFFF8)
+#define SMCR_ETR_Mask               ((uint16_t)0x00FF)
+#define SMCR_TS_Mask                ((uint16_t)0xFF8F)
+#define SMCR_MSM_Reset              ((uint16_t)0xFF7F)
+#define SMCR_ECE_Set                ((uint16_t)0x4000)
+#define CCMR_CC13S_Mask             ((uint16_t)0xFFFC)
+#define CCMR_CC24S_Mask             ((uint16_t)0xFCFF)
+#define CCMR_TI13Direct_Set         ((uint16_t)0x0001)
+#define CCMR_TI24Direct_Set         ((uint16_t)0x0100)
+#define CCMR_OC13FE_Reset           ((uint16_t)0xFFFB)
+#define CCMR_OC24FE_Reset           ((uint16_t)0xFBFF)
+#define CCMR_OC13PE_Reset           ((uint16_t)0xFFF7)
+#define CCMR_OC24PE_Reset           ((uint16_t)0xF7FF)
+#define CCMR_OC13M_Mask             ((uint16_t)0xFF8F)
+#define CCMR_OC24M_Mask             ((uint16_t)0x8FFF) 
+#define CCMR_OC13CE_Reset           ((uint16_t)0xFF7F)
+#define CCMR_OC24CE_Reset           ((uint16_t)0x7FFF)
+#define CCMR_IC13PSC_Mask           ((uint16_t)0xFFF3)
+#define CCMR_IC24PSC_Mask           ((uint16_t)0xF3FF)
+#define CCMR_IC13F_Mask             ((uint16_t)0xFF0F)
+#define CCMR_IC24F_Mask             ((uint16_t)0x0FFF)
+#define CCMR_Offset                 ((uint16_t)0x0018)
+#define CCER_CCE_Set                ((uint16_t)0x0001)
+#define	CCER_CCNE_Set               ((uint16_t)0x0004)
+#define CCER_CC1P_Reset             ((uint16_t)0xFFFD)
+#define CCER_CC2P_Reset             ((uint16_t)0xFFDF)
+#define CCER_CC3P_Reset             ((uint16_t)0xFDFF)
+#define CCER_CC4P_Reset             ((uint16_t)0xDFFF)
+#define CCER_CC1NP_Reset            ((uint16_t)0xFFF7)
+#define CCER_CC2NP_Reset            ((uint16_t)0xFF7F)
+#define CCER_CC3NP_Reset            ((uint16_t)0xF7FF)
+#define CCER_CC1E_Set               ((uint16_t)0x0001)
+#define CCER_CC1E_Reset             ((uint16_t)0xFFFE)
+#define CCER_CC1NE_Reset            ((uint16_t)0xFFFB)
+#define CCER_CC2E_Set               ((uint16_t)0x0010)
+#define CCER_CC2E_Reset             ((uint16_t)0xFFEF)
+#define CCER_CC2NE_Reset            ((uint16_t)0xFFBF)
+#define CCER_CC3E_Set               ((uint16_t)0x0100)
+#define CCER_CC3E_Reset             ((uint16_t)0xFEFF)
+#define CCER_CC3NE_Reset            ((uint16_t)0xFBFF)
+#define CCER_CC4E_Set               ((uint16_t)0x1000)
+#define CCER_CC4E_Reset             ((uint16_t)0xEFFF)
+#define BDTR_MOE_Set                ((uint16_t)0x8000)
+#define BDTR_MOE_Reset              ((uint16_t)0x7FFF)
+/**
+  * @}
+  */
+
+/** @defgroup TIM_Private_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup TIM_Private_Variables
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup TIM_Private_FunctionPrototypes
+  * @{
+  */
+
+static void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
+                       uint16_t TIM_ICFilter);
+static void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
+                       uint16_t TIM_ICFilter);
+static void TI3_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
+                       uint16_t TIM_ICFilter);
+static void TI4_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
+                       uint16_t TIM_ICFilter);
+/**
+  * @}
+  */
+
+/** @defgroup TIM_Private_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup TIM_Private_Variables
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup TIM_Private_FunctionPrototypes
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup TIM_Private_Functions
+  * @{
+  */
+
+/**
+  * @brief  Deinitializes the TIMx peripheral registers to their default reset values.
+  * @param  TIMx: where x can be 1 to 8 to select the TIM peripheral.
+  * @retval None
+  */
+void TIM_DeInit(TIM_TypeDef* TIMx)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
+ 
+  if (TIMx == TIM1)
+  {
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, ENABLE);
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, DISABLE);  
+  }     
+  else if (TIMx == TIM2)
+  {
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, ENABLE);
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
+  }
+  else if (TIMx == TIM3)
+  {
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
+  }
+  else if (TIMx == TIM4)
+  {
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, ENABLE);
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, DISABLE);
+  } 
+  else if (TIMx == TIM5)
+  {
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, ENABLE);
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, DISABLE);
+  } 
+  else if (TIMx == TIM6)
+  {
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, ENABLE);
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, DISABLE);
+  } 
+  else if (TIMx == TIM7)
+  {
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, ENABLE);
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, DISABLE);
+  } 
+  else
+  {
+    if (TIMx == TIM8)
+    {
+      RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, ENABLE);
+      RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, DISABLE);
+    }  
+  }
+}
+
+/**
+  * @brief  Initializes the TIMx Time Base Unit peripheral according to 
+  *   the specified parameters in the TIM_TimeBaseInitStruct.
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_TimeBaseInitStruct: pointer to a TIM_TimeBaseInitTypeDef
+  *   structure that contains the configuration information for the specified TIM peripheral.
+  * @retval None
+  */
+void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx)); 
+  assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct-&gt;TIM_CounterMode));
+  assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct-&gt;TIM_ClockDivision));
+  /* Select the Counter Mode and set the clock division */
+  TIMx-&gt;CR1 &amp;= CR1_CKD_Mask &amp; CR1_CounterMode_Mask;
+  TIMx-&gt;CR1 |= (uint32_t)TIM_TimeBaseInitStruct-&gt;TIM_ClockDivision |
+                TIM_TimeBaseInitStruct-&gt;TIM_CounterMode;
+  
+  /* Set the Autoreload value */
+  TIMx-&gt;ARR = TIM_TimeBaseInitStruct-&gt;TIM_Period ;
+ 
+  /* Set the Prescaler value */
+  TIMx-&gt;PSC = TIM_TimeBaseInitStruct-&gt;TIM_Prescaler;
+    
+  if ((((uint32_t) TIMx) == TIM1_BASE) || (((uint32_t) TIMx) == TIM8_BASE))  
+  {
+    /* Set the Repetition Counter value */
+    TIMx-&gt;RCR = TIM_TimeBaseInitStruct-&gt;TIM_RepetitionCounter;
+  }
+
+  /* Generate an update event to reload the Prescaler value immediatly */
+  TIMx-&gt;EGR = TIM_PSCReloadMode_Immediate;          
+}
+
+/**
+  * @brief  Initializes the TIMx Channel1 according to the specified
+  *   parameters in the TIM_OCInitStruct.
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
+  *   that contains the configuration information for the specified TIM peripheral.
+  * @retval None
+  */
+void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
+{
+  uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
+   
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx)); 
+  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct-&gt;TIM_OCMode));
+  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct-&gt;TIM_OutputState));
+  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct-&gt;TIM_OCPolarity));   
+  /* Disable the Channel 1: Reset the CC1E Bit */
+  TIMx-&gt;CCER &amp;= CCER_CC1E_Reset;
+  
+  /* Get the TIMx CCER register value */
+  tmpccer = TIMx-&gt;CCER;
+  /* Get the TIMx CR2 register value */
+  tmpcr2 =  TIMx-&gt;CR2;
+  
+  /* Get the TIMx CCMR1 register value */
+  tmpccmrx = TIMx-&gt;CCMR1;
+    
+  /* Reset the Output Compare Mode Bits */
+  tmpccmrx &amp;= CCMR_OC13M_Mask;
+  
+  /* Select the Output Compare Mode */
+  tmpccmrx |= TIM_OCInitStruct-&gt;TIM_OCMode;
+  
+  /* Reset the Output Polarity level */
+  tmpccer &amp;= CCER_CC1P_Reset;
+  /* Set the Output Compare Polarity */
+  tmpccer |= TIM_OCInitStruct-&gt;TIM_OCPolarity;
+  
+  /* Set the Output State */
+  tmpccer |= TIM_OCInitStruct-&gt;TIM_OutputState;
+  
+  /* Set the Capture Compare Register value */
+  TIMx-&gt;CCR1 = TIM_OCInitStruct-&gt;TIM_Pulse;
+  
+  if(((uint32_t) TIMx == TIM1_BASE) || ((uint32_t) TIMx == TIM8_BASE))
+  {
+    assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct-&gt;TIM_OutputNState));
+    assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct-&gt;TIM_OCNPolarity));
+    assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct-&gt;TIM_OCNIdleState));
+    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct-&gt;TIM_OCIdleState));
+    
+    /* Reset the Output N Polarity level */
+    tmpccer &amp;= CCER_CC1NP_Reset;
+    /* Set the Output N Polarity */
+    tmpccer |= TIM_OCInitStruct-&gt;TIM_OCNPolarity;
+    /* Reset the Output N State */
+    tmpccer &amp;= CCER_CC1NE_Reset;
+    
+    /* Set the Output N State */
+    tmpccer |= TIM_OCInitStruct-&gt;TIM_OutputNState;
+    /* Reset the Ouput Compare and Output Compare N IDLE State */
+    tmpcr2 &amp;= CR2_OIS1_Reset;
+    tmpcr2 &amp;= CR2_OIS1N_Reset;
+    /* Set the Output Idle state */
+    tmpcr2 |= TIM_OCInitStruct-&gt;TIM_OCIdleState;
+    /* Set the Output N Idle state */
+    tmpcr2 |= TIM_OCInitStruct-&gt;TIM_OCNIdleState;
+  }
+  /* Write to TIMx CR2 */
+  TIMx-&gt;CR2 = tmpcr2;
+  
+  /* Write to TIMx CCMR1 */
+  TIMx-&gt;CCMR1 = tmpccmrx;
+  
+  /* Write to TIMx CCER */
+  TIMx-&gt;CCER = tmpccer;
+}
+
+/**
+  * @brief  Initializes the TIMx Channel2 according to the specified
+  *   parameters in the TIM_OCInitStruct.
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
+  *   that contains the configuration information for the specified TIM peripheral.
+  * @retval None
+  */
+void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
+{
+  uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
+   
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx)); 
+  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct-&gt;TIM_OCMode));
+  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct-&gt;TIM_OutputState));
+  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct-&gt;TIM_OCPolarity));   
+  /* Disable the Channel 2: Reset the CC2E Bit */
+  TIMx-&gt;CCER &amp;= CCER_CC2E_Reset;
+  
+  /* Get the TIMx CCER register value */  
+  tmpccer = TIMx-&gt;CCER;
+  /* Get the TIMx CR2 register value */
+  tmpcr2 =  TIMx-&gt;CR2;
+  
+  /* Get the TIMx CCMR1 register value */
+  tmpccmrx = TIMx-&gt;CCMR1;
+    
+  /* Reset the Output Compare Mode Bits */
+  tmpccmrx &amp;= CCMR_OC24M_Mask;
+  
+  /* Select the Output Compare Mode */
+  tmpccmrx |= (uint16_t)(TIM_OCInitStruct-&gt;TIM_OCMode &lt;&lt; 8);
+  
+  /* Reset the Output Polarity level */
+  tmpccer &amp;= CCER_CC2P_Reset;
+  /* Set the Output Compare Polarity */
+  tmpccer |= (uint16_t)(TIM_OCInitStruct-&gt;TIM_OCPolarity &lt;&lt; 4);
+  
+  /* Set the Output State */
+  tmpccer |= (uint16_t)(TIM_OCInitStruct-&gt;TIM_OutputState &lt;&lt; 4);
+  
+  /* Set the Capture Compare Register value */
+  TIMx-&gt;CCR2 = TIM_OCInitStruct-&gt;TIM_Pulse;
+  
+  if(((uint32_t) TIMx == TIM1_BASE) || ((uint32_t) TIMx == TIM8_BASE))
+  {
+    assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct-&gt;TIM_OutputNState));
+    assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct-&gt;TIM_OCNPolarity));
+    assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct-&gt;TIM_OCNIdleState));
+    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct-&gt;TIM_OCIdleState));
+    
+    /* Reset the Output N Polarity level */
+    tmpccer &amp;= CCER_CC2NP_Reset;
+    /* Set the Output N Polarity */
+    tmpccer |= (uint16_t)(TIM_OCInitStruct-&gt;TIM_OCNPolarity &lt;&lt; 4);
+    /* Reset the Output N State */
+    tmpccer &amp;= CCER_CC2NE_Reset;
+    
+    /* Set the Output N State */
+    tmpccer |= (uint16_t)(TIM_OCInitStruct-&gt;TIM_OutputNState &lt;&lt; 4);
+    /* Reset the Ouput Compare and Output Compare N IDLE State */
+    tmpcr2 &amp;= CR2_OIS2_Reset;
+    tmpcr2 &amp;= CR2_OIS2N_Reset;
+    /* Set the Output Idle state */
+    tmpcr2 |= (uint16_t)(TIM_OCInitStruct-&gt;TIM_OCIdleState &lt;&lt; 2);
+    /* Set the Output N Idle state */
+    tmpcr2 |= (uint16_t)(TIM_OCInitStruct-&gt;TIM_OCNIdleState &lt;&lt; 2);
+  }
+  /* Write to TIMx CR2 */
+  TIMx-&gt;CR2 = tmpcr2;
+  
+  /* Write to TIMx CCMR1 */
+  TIMx-&gt;CCMR1 = tmpccmrx;
+  
+  /* Write to TIMx CCER */
+  TIMx-&gt;CCER = tmpccer;
+}
+
+/**
+  * @brief  Initializes the TIMx Channel3 according to the specified
+  *   parameters in the TIM_OCInitStruct.
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
+  *   that contains the configuration information for the specified TIM peripheral.
+  * @retval None
+  */
+void TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
+{
+  uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
+   
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx)); 
+  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct-&gt;TIM_OCMode));
+  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct-&gt;TIM_OutputState));
+  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct-&gt;TIM_OCPolarity));   
+  /* Disable the Channel 2: Reset the CC2E Bit */
+  TIMx-&gt;CCER &amp;= CCER_CC3E_Reset;
+  
+  /* Get the TIMx CCER register value */
+  tmpccer = TIMx-&gt;CCER;
+  /* Get the TIMx CR2 register value */
+  tmpcr2 =  TIMx-&gt;CR2;
+  
+  /* Get the TIMx CCMR2 register value */
+  tmpccmrx = TIMx-&gt;CCMR2;
+    
+  /* Reset the Output Compare Mode Bits */
+  tmpccmrx &amp;= CCMR_OC13M_Mask;
+  
+  /* Select the Output Compare Mode */
+  tmpccmrx |= TIM_OCInitStruct-&gt;TIM_OCMode;
+  
+  /* Reset the Output Polarity level */
+  tmpccer &amp;= CCER_CC3P_Reset;
+  /* Set the Output Compare Polarity */
+  tmpccer |= (uint16_t)(TIM_OCInitStruct-&gt;TIM_OCPolarity &lt;&lt; 8);
+  
+  /* Set the Output State */
+  tmpccer |= (uint16_t)(TIM_OCInitStruct-&gt;TIM_OutputState &lt;&lt; 8);
+  
+  /* Set the Capture Compare Register value */
+  TIMx-&gt;CCR3 = TIM_OCInitStruct-&gt;TIM_Pulse;
+  
+  if(((uint32_t) TIMx == TIM1_BASE) || ((uint32_t) TIMx == TIM8_BASE))
+  {
+    assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct-&gt;TIM_OutputNState));
+    assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct-&gt;TIM_OCNPolarity));
+    assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct-&gt;TIM_OCNIdleState));
+    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct-&gt;TIM_OCIdleState));
+    
+    /* Reset the Output N Polarity level */
+    tmpccer &amp;= CCER_CC3NP_Reset;
+    /* Set the Output N Polarity */
+    tmpccer |= (uint16_t)(TIM_OCInitStruct-&gt;TIM_OCNPolarity &lt;&lt; 8);
+    /* Reset the Output N State */
+    tmpccer &amp;= CCER_CC3NE_Reset;
+    
+    /* Set the Output N State */
+    tmpccer |= (uint16_t)(TIM_OCInitStruct-&gt;TIM_OutputNState &lt;&lt; 8);
+    /* Reset the Ouput Compare and Output Compare N IDLE State */
+    tmpcr2 &amp;= CR2_OIS3_Reset;
+    tmpcr2 &amp;= CR2_OIS3N_Reset;
+    /* Set the Output Idle state */
+    tmpcr2 |= (uint16_t)(TIM_OCInitStruct-&gt;TIM_OCIdleState &lt;&lt; 4);
+    /* Set the Output N Idle state */
+    tmpcr2 |= (uint16_t)(TIM_OCInitStruct-&gt;TIM_OCNIdleState &lt;&lt; 4);
+  }
+  /* Write to TIMx CR2 */
+  TIMx-&gt;CR2 = tmpcr2;
+  
+  /* Write to TIMx CCMR2 */
+  TIMx-&gt;CCMR2 = tmpccmrx;
+  
+  /* Write to TIMx CCER */
+  TIMx-&gt;CCER = tmpccer;
+}
+
+/**
+  * @brief  Initializes the TIMx Channel4 according to the specified
+  *   parameters in the TIM_OCInitStruct.
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
+  *   that contains the configuration information for the specified TIM peripheral.
+  * @retval None
+  */
+void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
+{
+  uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
+   
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx)); 
+  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct-&gt;TIM_OCMode));
+  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct-&gt;TIM_OutputState));
+  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct-&gt;TIM_OCPolarity));   
+  /* Disable the Channel 2: Reset the CC4E Bit */
+  TIMx-&gt;CCER &amp;= CCER_CC4E_Reset;
+  
+  /* Get the TIMx CCER register value */
+  tmpccer = TIMx-&gt;CCER;
+  /* Get the TIMx CR2 register value */
+  tmpcr2 =  TIMx-&gt;CR2;
+  
+  /* Get the TIMx CCMR2 register value */
+  tmpccmrx = TIMx-&gt;CCMR2;
+    
+  /* Reset the Output Compare Mode Bits */
+  tmpccmrx &amp;= CCMR_OC24M_Mask;
+  
+  /* Select the Output Compare Mode */
+  tmpccmrx |= (uint16_t)(TIM_OCInitStruct-&gt;TIM_OCMode &lt;&lt; 8);
+  
+  /* Reset the Output Polarity level */
+  tmpccer &amp;= CCER_CC4P_Reset;
+  /* Set the Output Compare Polarity */
+  tmpccer |= (uint16_t)(TIM_OCInitStruct-&gt;TIM_OCPolarity &lt;&lt; 12);
+  
+  /* Set the Output State */
+  tmpccer |= (uint16_t)(TIM_OCInitStruct-&gt;TIM_OutputState &lt;&lt; 12);
+  
+  /* Set the Capture Compare Register value */
+  TIMx-&gt;CCR4 = TIM_OCInitStruct-&gt;TIM_Pulse;
+  
+  if(((uint32_t) TIMx == TIM1_BASE) || ((uint32_t) TIMx == TIM8_BASE))
+  {
+    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct-&gt;TIM_OCIdleState));
+    /* Reset the Ouput Compare IDLE State */
+    tmpcr2 &amp;= CR2_OIS4_Reset;
+    /* Set the Output Idle state */
+    tmpcr2 |= (uint16_t)(TIM_OCInitStruct-&gt;TIM_OCIdleState &lt;&lt; 6);
+  }
+  /* Write to TIMx CR2 */
+  TIMx-&gt;CR2 = tmpcr2;
+  
+  /* Write to TIMx CCMR2 */  
+  TIMx-&gt;CCMR2 = tmpccmrx;
+  
+  /* Write to TIMx CCER */
+  TIMx-&gt;CCER = tmpccer;
+}
+
+/**
+  * @brief  Initializes the TIM peripheral according to the specified
+  *   parameters in the TIM_ICInitStruct.
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure
+  *   that contains the configuration information for the specified TIM peripheral.
+  * @retval None
+  */
+void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_CHANNEL(TIM_ICInitStruct-&gt;TIM_Channel));
+  assert_param(IS_TIM_IC_POLARITY(TIM_ICInitStruct-&gt;TIM_ICPolarity));
+  assert_param(IS_TIM_IC_SELECTION(TIM_ICInitStruct-&gt;TIM_ICSelection));
+  assert_param(IS_TIM_IC_PRESCALER(TIM_ICInitStruct-&gt;TIM_ICPrescaler));
+  assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct-&gt;TIM_ICFilter));
+  
+  if (TIM_ICInitStruct-&gt;TIM_Channel == TIM_Channel_1)
+  {
+    /* TI1 Configuration */
+    TI1_Config(TIMx, TIM_ICInitStruct-&gt;TIM_ICPolarity,
+               TIM_ICInitStruct-&gt;TIM_ICSelection,
+               TIM_ICInitStruct-&gt;TIM_ICFilter);
+    /* Set the Input Capture Prescaler value */
+    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct-&gt;TIM_ICPrescaler);
+  }
+  else if (TIM_ICInitStruct-&gt;TIM_Channel == TIM_Channel_2)
+  {
+    /* TI2 Configuration */
+    TI2_Config(TIMx, TIM_ICInitStruct-&gt;TIM_ICPolarity,
+               TIM_ICInitStruct-&gt;TIM_ICSelection,
+               TIM_ICInitStruct-&gt;TIM_ICFilter);
+    /* Set the Input Capture Prescaler value */
+    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct-&gt;TIM_ICPrescaler);
+  }
+  else if (TIM_ICInitStruct-&gt;TIM_Channel == TIM_Channel_3)
+  {
+    /* TI3 Configuration */
+    TI3_Config(TIMx,  TIM_ICInitStruct-&gt;TIM_ICPolarity,
+               TIM_ICInitStruct-&gt;TIM_ICSelection,
+               TIM_ICInitStruct-&gt;TIM_ICFilter);
+    /* Set the Input Capture Prescaler value */
+    TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct-&gt;TIM_ICPrescaler);
+  }
+  else
+  {
+    /* TI4 Configuration */
+    TI4_Config(TIMx, TIM_ICInitStruct-&gt;TIM_ICPolarity,
+               TIM_ICInitStruct-&gt;TIM_ICSelection,
+               TIM_ICInitStruct-&gt;TIM_ICFilter);
+    /* Set the Input Capture Prescaler value */
+    TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct-&gt;TIM_ICPrescaler);
+  }
+}
+
+/**
+  * @brief  Configures the TIM peripheral according to the specified
+  *   parameters in the TIM_ICInitStruct to measure an external PWM signal.
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure
+  *   that contains the configuration information for the specified TIM peripheral.
+  * @retval None
+  */
+void TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
+{
+  uint16_t icoppositepolarity = TIM_ICPolarity_Rising;
+  uint16_t icoppositeselection = TIM_ICSelection_DirectTI;
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  /* Select the Opposite Input Polarity */
+  if (TIM_ICInitStruct-&gt;TIM_ICPolarity == TIM_ICPolarity_Rising)
+  {
+    icoppositepolarity = TIM_ICPolarity_Falling;
+  }
+  else
+  {
+    icoppositepolarity = TIM_ICPolarity_Rising;
+  }
+  /* Select the Opposite Input */
+  if (TIM_ICInitStruct-&gt;TIM_ICSelection == TIM_ICSelection_DirectTI)
+  {
+    icoppositeselection = TIM_ICSelection_IndirectTI;
+  }
+  else
+  {
+    icoppositeselection = TIM_ICSelection_DirectTI;
+  }
+  if (TIM_ICInitStruct-&gt;TIM_Channel == TIM_Channel_1)
+  {
+    /* TI1 Configuration */
+    TI1_Config(TIMx, TIM_ICInitStruct-&gt;TIM_ICPolarity, TIM_ICInitStruct-&gt;TIM_ICSelection,
+               TIM_ICInitStruct-&gt;TIM_ICFilter);
+    /* Set the Input Capture Prescaler value */
+    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct-&gt;TIM_ICPrescaler);
+    /* TI2 Configuration */
+    TI2_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct-&gt;TIM_ICFilter);
+    /* Set the Input Capture Prescaler value */
+    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct-&gt;TIM_ICPrescaler);
+  }
+  else
+  { 
+    /* TI2 Configuration */
+    TI2_Config(TIMx, TIM_ICInitStruct-&gt;TIM_ICPolarity, TIM_ICInitStruct-&gt;TIM_ICSelection,
+               TIM_ICInitStruct-&gt;TIM_ICFilter);
+    /* Set the Input Capture Prescaler value */
+    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct-&gt;TIM_ICPrescaler);
+    /* TI1 Configuration */
+    TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct-&gt;TIM_ICFilter);
+    /* Set the Input Capture Prescaler value */
+    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct-&gt;TIM_ICPrescaler);
+  }
+}
+
+/**
+  * @brief  Configures the: Break feature, dead time, Lock level, the OSSI,
+  *   the OSSR State and the AOE(automatic output enable).
+  * @param  TIMx: where x can be  1 or 8 to select the TIM 
+  * @param  TIM_BDTRInitStruct: pointer to a TIM_BDTRInitTypeDef structure that
+  *   contains the BDTR Register configuration  information for the TIM peripheral.
+  * @retval None
+  */
+void TIM_BDTRConfig(TIM_TypeDef* TIMx, TIM_BDTRInitTypeDef *TIM_BDTRInitStruct)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_18_PERIPH(TIMx));
+  assert_param(IS_TIM_OSSR_STATE(TIM_BDTRInitStruct-&gt;TIM_OSSRState));
+  assert_param(IS_TIM_OSSI_STATE(TIM_BDTRInitStruct-&gt;TIM_OSSIState));
+  assert_param(IS_TIM_LOCK_LEVEL(TIM_BDTRInitStruct-&gt;TIM_LOCKLevel));
+  assert_param(IS_TIM_BREAK_STATE(TIM_BDTRInitStruct-&gt;TIM_Break));
+  assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct-&gt;TIM_BreakPolarity));
+  assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct-&gt;TIM_AutomaticOutput));
+  /* Set the Lock level, the Break enable Bit and the Ploarity, the OSSR State,
+     the OSSI State, the dead time value and the Automatic Output Enable Bit */
+  TIMx-&gt;BDTR = (uint32_t)TIM_BDTRInitStruct-&gt;TIM_OSSRState | TIM_BDTRInitStruct-&gt;TIM_OSSIState |
+             TIM_BDTRInitStruct-&gt;TIM_LOCKLevel | TIM_BDTRInitStruct-&gt;TIM_DeadTime |
+             TIM_BDTRInitStruct-&gt;TIM_Break | TIM_BDTRInitStruct-&gt;TIM_BreakPolarity |
+             TIM_BDTRInitStruct-&gt;TIM_AutomaticOutput;
+}
+
+/**
+  * @brief  Fills each TIM_TimeBaseInitStruct member with its default value.
+  * @param  TIM_TimeBaseInitStruct : pointer to a TIM_TimeBaseInitTypeDef
+  *   structure which will be initialized.
+  * @retval None
+  */
+void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
+{
+  /* Set the default configuration */
+  TIM_TimeBaseInitStruct-&gt;TIM_Period = 0xFFFF;
+  TIM_TimeBaseInitStruct-&gt;TIM_Prescaler = 0x0000;
+  TIM_TimeBaseInitStruct-&gt;TIM_ClockDivision = TIM_CKD_DIV1;
+  TIM_TimeBaseInitStruct-&gt;TIM_CounterMode = TIM_CounterMode_Up;
+  TIM_TimeBaseInitStruct-&gt;TIM_RepetitionCounter = 0x0000;
+}
+
+/**
+  * @brief  Fills each TIM_OCInitStruct member with its default value.
+  * @param  TIM_OCInitStruct : pointer to a TIM_OCInitTypeDef structure which will
+  *   be initialized.
+  * @retval None
+  */
+void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct)
+{
+  /* Set the default configuration */
+  TIM_OCInitStruct-&gt;TIM_OCMode = TIM_OCMode_Timing;
+  TIM_OCInitStruct-&gt;TIM_OutputState = TIM_OutputState_Disable;
+  TIM_OCInitStruct-&gt;TIM_OutputNState = TIM_OutputNState_Disable;
+  TIM_OCInitStruct-&gt;TIM_Pulse = 0x0000;
+  TIM_OCInitStruct-&gt;TIM_OCPolarity = TIM_OCPolarity_High;
+  TIM_OCInitStruct-&gt;TIM_OCNPolarity = TIM_OCPolarity_High;
+  TIM_OCInitStruct-&gt;TIM_OCIdleState = TIM_OCIdleState_Reset;
+  TIM_OCInitStruct-&gt;TIM_OCNIdleState = TIM_OCNIdleState_Reset;
+}
+
+/**
+  * @brief  Fills each TIM_ICInitStruct member with its default value.
+  * @param  TIM_ICInitStruct : pointer to a TIM_ICInitTypeDef structure which will
+  *   be initialized.
+  * @retval None
+  */
+void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct)
+{
+  /* Set the default configuration */
+  TIM_ICInitStruct-&gt;TIM_Channel = TIM_Channel_1;
+  TIM_ICInitStruct-&gt;TIM_ICPolarity = TIM_ICPolarity_Rising;
+  TIM_ICInitStruct-&gt;TIM_ICSelection = TIM_ICSelection_DirectTI;
+  TIM_ICInitStruct-&gt;TIM_ICPrescaler = TIM_ICPSC_DIV1;
+  TIM_ICInitStruct-&gt;TIM_ICFilter = 0x00;
+}
+
+/**
+  * @brief  Fills each TIM_BDTRInitStruct member with its default value.
+  * @param  TIM_BDTRInitStruct: pointer to a TIM_BDTRInitTypeDef structure which
+  *   will be initialized.
+  * @retval None
+  */
+void TIM_BDTRStructInit(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct)
+{
+  /* Set the default configuration */
+  TIM_BDTRInitStruct-&gt;TIM_OSSRState = TIM_OSSRState_Disable;
+  TIM_BDTRInitStruct-&gt;TIM_OSSIState = TIM_OSSIState_Disable;
+  TIM_BDTRInitStruct-&gt;TIM_LOCKLevel = TIM_LOCKLevel_OFF;
+  TIM_BDTRInitStruct-&gt;TIM_DeadTime = 0x00;
+  TIM_BDTRInitStruct-&gt;TIM_Break = TIM_Break_Disable;
+  TIM_BDTRInitStruct-&gt;TIM_BreakPolarity = TIM_BreakPolarity_Low;
+  TIM_BDTRInitStruct-&gt;TIM_AutomaticOutput = TIM_AutomaticOutput_Disable;
+}
+
+/**
+  * @brief  Enables or disables the specified TIM peripheral.
+  * @param  TIMx: where x can be 1 to 8 to select the TIMx peripheral.
+  * @param  NewState: new state of the TIMx peripheral.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_ALL_PERIPH(TIMx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the TIM Counter */
+    TIMx-&gt;CR1 |= CR1_CEN_Set;
+  }
+  else
+  {
+    /* Disable the TIM Counter */
+    TIMx-&gt;CR1 &amp;= CR1_CEN_Reset;
+  }
+}
+
+/**
+  * @brief  Enables or disables the TIM peripheral Main Outputs.
+  * @param  TIMx: where x can be 1 or 8 to select the TIMx peripheral.
+  * @param  NewState: new state of the TIM peripheral Main Outputs.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_18_PERIPH(TIMx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the TIM Main Output */
+    TIMx-&gt;BDTR |= BDTR_MOE_Set;
+  }
+  else
+  {
+    /* Disable the TIM Main Output */
+    TIMx-&gt;BDTR &amp;= BDTR_MOE_Reset;
+  }  
+}
+
+/**
+  * @brief  Enables or disables the specified TIM interrupts.
+  * @param  TIMx: where x can be 1 to 8 to select the TIMx peripheral.
+  * @param  TIM_IT: specifies the TIM interrupts sources to be enabled or disabled.
+  *   This parameter can be any combination of the following values:
+  *     @arg TIM_IT_Update: TIM update Interrupt source
+  *     @arg TIM_IT_CC1: TIM Capture Compare 1 Interrupt source
+  *     @arg TIM_IT_CC2: TIM Capture Compare 2 Interrupt source
+  *     @arg TIM_IT_CC3: TIM Capture Compare 3 Interrupt source
+  *     @arg TIM_IT_CC4: TIM Capture Compare 4 Interrupt source
+  *     @arg TIM_IT_COM: TIM Commutation Interrupt source
+  *     @arg TIM_IT_Trigger: TIM Trigger Interrupt source
+  *     @arg TIM_IT_Break: TIM Break Interrupt source
+  * @note 
+  *   - TIM6 and TIM7 can only generate an update interrupt. 
+  *   - TIM_IT_COM and TIM_IT_Break are used only with TIM1 and TIM8.  
+  * @param  NewState: new state of the TIM interrupts.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState)
+{  
+  /* Check the parameters */
+  assert_param(IS_TIM_ALL_PERIPH(TIMx));
+  assert_param(IS_TIM_IT(TIM_IT));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the Interrupt sources */
+    TIMx-&gt;DIER |= TIM_IT;
+  }
+  else
+  {
+    /* Disable the Interrupt sources */
+    TIMx-&gt;DIER &amp;= (uint16_t)~TIM_IT;
+  }
+}
+
+/**
+  * @brief  Configures the TIMx event to be generate by software.
+  * @param  TIMx: where x can be 1 to 8 to select the TIM peripheral.
+  * @param  TIM_EventSource: specifies the event source.
+  *   This parameter can be one or more of the following values:	   
+  *     @arg TIM_EventSource_Update: Timer update Event source
+  *     @arg TIM_EventSource_CC1: Timer Capture Compare 1 Event source
+  *     @arg TIM_EventSource_CC2: Timer Capture Compare 2 Event source
+  *     @arg TIM_EventSource_CC3: Timer Capture Compare 3 Event source
+  *     @arg TIM_EventSource_CC4: Timer Capture Compare 4 Event source
+  *     @arg TIM_EventSource_COM: Timer COM event source  
+  *     @arg TIM_EventSource_Trigger: Timer Trigger Event source
+  *     @arg TIM_EventSource_Break: Timer Break event source
+  * @note 
+  *   - TIM6 and TIM7 can only generate an update event. 
+  *   - TIM_EventSource_COM and TIM_EventSource_Break are used only with TIM1 and TIM8.      
+  * @retval None
+  */
+void TIM_GenerateEvent(TIM_TypeDef* TIMx, uint16_t TIM_EventSource)
+{ 
+  /* Check the parameters */
+  assert_param(IS_TIM_ALL_PERIPH(TIMx));
+  assert_param(IS_TIM_EVENT_SOURCE(TIM_EventSource));
+  
+  /* Set the event sources */
+  TIMx-&gt;EGR = TIM_EventSource;
+}
+
+/**
+  * @brief  Configures the TIMx&#146;s DMA interface.
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_DMABase: DMA Base address.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_DMABase_CR, TIM_DMABase_CR2, TIM_DMABase_SMCR,
+  *   TIM_DMABase_DIER, TIM1_DMABase_SR, TIM_DMABase_EGR,
+  *   TIM_DMABase_CCMR1, TIM_DMABase_CCMR2, TIM_DMABase_CCER,
+  *   TIM_DMABase_CNT, TIM_DMABase_PSC, TIM_DMABase_ARR,
+  *   TIM_DMABase_RCR, TIM_DMABase_CCR1, TIM_DMABase_CCR2,
+  *   TIM_DMABase_CCR3, TIM_DMABase_CCR4, TIM_DMABase_BDTR,
+  *   TIM_DMABase_DCR.
+  * @param  TIM_DMABurstLength: DMA Burst length.
+  *   This parameter can be one value between:
+  *   TIM_DMABurstLength_1Byte and TIM_DMABurstLength_18Bytes.
+  * @retval None
+  */
+void TIM_DMAConfig(TIM_TypeDef* TIMx, uint16_t TIM_DMABase, uint16_t TIM_DMABurstLength)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_DMA_BASE(TIM_DMABase));
+  assert_param(IS_TIM_DMA_LENGTH(TIM_DMABurstLength));
+  /* Set the DMA Base and the DMA Burst Length */
+  TIMx-&gt;DCR = TIM_DMABase | TIM_DMABurstLength;
+}
+
+/**
+  * @brief  Enables or disables the TIMx&#146;s DMA Requests.
+  * @param  TIMx: where x can be  1 to 8 to select the TIM peripheral. 
+  * @param  TIM_DMASource: specifies the DMA Request sources.
+  *   This parameter can be any combination of the following values:
+  *     @arg TIM_DMA_Update: TIM update Interrupt source
+  *     @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source
+  *     @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source
+  *     @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source
+  *     @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source
+  *     @arg TIM_DMA_COM: TIM Commutation DMA source
+  *     @arg TIM_DMA_Trigger: TIM Trigger DMA source
+  * @param  NewState: new state of the DMA Request sources.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void TIM_DMACmd(TIM_TypeDef* TIMx, uint16_t TIM_DMASource, FunctionalState NewState)
+{ 
+  /* Check the parameters */
+  assert_param(IS_TIM_ALL_PERIPH(TIMx));
+  assert_param(IS_TIM_DMA_SOURCE(TIM_DMASource));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the DMA sources */
+    TIMx-&gt;DIER |= TIM_DMASource; 
+  }
+  else
+  {
+    /* Disable the DMA sources */
+    TIMx-&gt;DIER &amp;= (uint16_t)~TIM_DMASource;
+  }
+}
+
+/**
+  * @brief  Configures the TIMx interrnal Clock
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @retval None
+  */
+void TIM_InternalClockConfig(TIM_TypeDef* TIMx)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  /* Disable slave mode to clock the prescaler directly with the internal clock */
+  TIMx-&gt;SMCR &amp;=  SMCR_SMS_Mask;
+}
+
+/**
+  * @brief  Configures the TIMx Internal Trigger as External Clock
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_ITRSource: Trigger source.
+  *   This parameter can be one of the following values:
+  * @param  TIM_TS_ITR0: Internal Trigger 0
+  * @param  TIM_TS_ITR1: Internal Trigger 1
+  * @param  TIM_TS_ITR2: Internal Trigger 2
+  * @param  TIM_TS_ITR3: Internal Trigger 3
+  * @retval None
+  */
+void TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_INTERNAL_TRIGGER_SELECTION(TIM_InputTriggerSource));
+  /* Select the Internal Trigger */
+  TIM_SelectInputTrigger(TIMx, TIM_InputTriggerSource);
+  /* Select the External clock mode1 */
+  TIMx-&gt;SMCR |= TIM_SlaveMode_External1;
+}
+
+/**
+  * @brief  Configures the TIMx Trigger as External Clock
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_TIxExternalCLKSource: Trigger source.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_TIxExternalCLK1Source_TI1ED: TI1 Edge Detector
+  *     @arg TIM_TIxExternalCLK1Source_TI1: Filtered Timer Input 1
+  *     @arg TIM_TIxExternalCLK1Source_TI2: Filtered Timer Input 2
+  * @param  TIM_ICPolarity: specifies the TIx Polarity.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_ICPolarity_Rising
+  *     @arg TIM_ICPolarity_Falling
+  * @param  ICFilter : specifies the filter value.
+  *   This parameter must be a value between 0x0 and 0xF.
+  * @retval None
+  */
+void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource,
+                                uint16_t TIM_ICPolarity, uint16_t ICFilter)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_TIXCLK_SOURCE(TIM_TIxExternalCLKSource));
+  assert_param(IS_TIM_IC_POLARITY(TIM_ICPolarity));
+  assert_param(IS_TIM_IC_FILTER(ICFilter));
+  /* Configure the Timer Input Clock Source */
+  if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
+  {
+    TI2_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
+  }
+  else
+  {
+    TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
+  }
+  /* Select the Trigger source */
+  TIM_SelectInputTrigger(TIMx, TIM_TIxExternalCLKSource);
+  /* Select the External clock mode1 */
+  TIMx-&gt;SMCR |= TIM_SlaveMode_External1;
+}
+
+/**
+  * @brief  Configures the External clock Mode1
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_ExtTRGPrescaler: The external Trigger Prescaler.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_ExtTRGPSC_OFF: ETRP Prescaler OFF.
+  *     @arg TIM_ExtTRGPSC_DIV2: ETRP frequency divided by 2.
+  *     @arg TIM_ExtTRGPSC_DIV4: ETRP frequency divided by 4.
+  *     @arg TIM_ExtTRGPSC_DIV8: ETRP frequency divided by 8.
+  * @param  TIM_ExtTRGPolarity: The external Trigger Polarity.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_ExtTRGPolarity_Inverted: active low or falling edge active.
+  *     @arg TIM_ExtTRGPolarity_NonInverted: active high or rising edge active.
+  * @param  ExtTRGFilter: External Trigger Filter.
+  *   This parameter must be a value between 0x00 and 0x0F
+  * @retval None
+  */
+void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
+                             uint16_t ExtTRGFilter)
+{
+  uint16_t tmpsmcr = 0;
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
+  assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
+  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
+  /* Configure the ETR Clock source */
+  TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
+  
+  /* Get the TIMx SMCR register value */
+  tmpsmcr = TIMx-&gt;SMCR;
+  /* Reset the SMS Bits */
+  tmpsmcr &amp;= SMCR_SMS_Mask;
+  /* Select the External clock mode1 */
+  tmpsmcr |= TIM_SlaveMode_External1;
+  /* Select the Trigger selection : ETRF */
+  tmpsmcr &amp;= SMCR_TS_Mask;
+  tmpsmcr |= TIM_TS_ETRF;
+  /* Write to TIMx SMCR */
+  TIMx-&gt;SMCR = tmpsmcr;
+}
+
+/**
+  * @brief  Configures the External clock Mode2
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_ExtTRGPrescaler: The external Trigger Prescaler.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_ExtTRGPSC_OFF: ETRP Prescaler OFF.
+  *     @arg TIM_ExtTRGPSC_DIV2: ETRP frequency divided by 2.
+  *     @arg TIM_ExtTRGPSC_DIV4: ETRP frequency divided by 4.
+  *     @arg TIM_ExtTRGPSC_DIV8: ETRP frequency divided by 8.
+  * @param  TIM_ExtTRGPolarity: The external Trigger Polarity.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_ExtTRGPolarity_Inverted: active low or falling edge active.
+  *     @arg TIM_ExtTRGPolarity_NonInverted: active high or rising edge active.
+  * @param  ExtTRGFilter: External Trigger Filter.
+  *   This parameter must be a value between 0x00 and 0x0F
+  * @retval None
+  */
+void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, 
+                             uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
+  assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
+  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
+  /* Configure the ETR Clock source */
+  TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
+  /* Enable the External clock mode2 */
+  TIMx-&gt;SMCR |= SMCR_ECE_Set;
+}
+
+/**
+  * @brief  Configures the TIMx External Trigger (ETR).
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_ExtTRGPrescaler: The external Trigger Prescaler.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_ExtTRGPSC_OFF: ETRP Prescaler OFF.
+  *     @arg TIM_ExtTRGPSC_DIV2: ETRP frequency divided by 2.
+  *     @arg TIM_ExtTRGPSC_DIV4: ETRP frequency divided by 4.
+  *     @arg TIM_ExtTRGPSC_DIV8: ETRP frequency divided by 8.
+  * @param  TIM_ExtTRGPolarity: The external Trigger Polarity.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_ExtTRGPolarity_Inverted: active low or falling edge active.
+  *     @arg TIM_ExtTRGPolarity_NonInverted: active high or rising edge active.
+  * @param  ExtTRGFilter: External Trigger Filter.
+  *   This parameter must be a value between 0x00 and 0x0F
+  * @retval None
+  */
+void TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
+                   uint16_t ExtTRGFilter)
+{
+  uint16_t tmpsmcr = 0;
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
+  assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
+  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
+  tmpsmcr = TIMx-&gt;SMCR;
+  /* Reset the ETR Bits */
+  tmpsmcr &amp;= SMCR_ETR_Mask;
+  /* Set the Prescaler, the Filter value and the Polarity */
+  tmpsmcr |= (uint16_t)(TIM_ExtTRGPrescaler | (uint16_t)(TIM_ExtTRGPolarity | (uint16_t)(ExtTRGFilter &lt;&lt; (uint16_t)8)));
+  /* Write to TIMx SMCR */
+  TIMx-&gt;SMCR = tmpsmcr;
+}
+
+/**
+  * @brief  Configures the TIMx Prescaler.
+  * @param  TIMx: where x can be 1 to 8 to select the TIM peripheral.
+  * @param  Prescaler: specifies the Prescaler Register value
+  * @param  TIM_PSCReloadMode: specifies the TIM Prescaler Reload mode
+  *   This parameter can be one of the following values:
+  *     @arg TIM_PSCReloadMode_Update: The Prescaler is loaded at the update event.
+  *     @arg TIM_PSCReloadMode_Immediate: The Prescaler is loaded immediatly.
+  * @retval None
+  */
+void TIM_PrescalerConfig(TIM_TypeDef* TIMx, uint16_t Prescaler, uint16_t TIM_PSCReloadMode)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_ALL_PERIPH(TIMx));
+  assert_param(IS_TIM_PRESCALER_RELOAD(TIM_PSCReloadMode));
+  /* Set the Prescaler value */
+  TIMx-&gt;PSC = Prescaler;
+  /* Set or reset the UG Bit */
+  TIMx-&gt;EGR = TIM_PSCReloadMode;
+}
+
+/**
+  * @brief  Specifies the TIMx Counter Mode to be used.
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_CounterMode: specifies the Counter Mode to be used
+  *   This parameter can be one of the following values:
+  *     @arg TIM_CounterMode_Up: TIM Up Counting Mode
+  *     @arg TIM_CounterMode_Down: TIM Down Counting Mode
+  *     @arg TIM_CounterMode_CenterAligned1: TIM Center Aligned Mode1
+  *     @arg TIM_CounterMode_CenterAligned2: TIM Center Aligned Mode2
+  *     @arg TIM_CounterMode_CenterAligned3: TIM Center Aligned Mode3
+  * @retval None
+  */
+void TIM_CounterModeConfig(TIM_TypeDef* TIMx, uint16_t TIM_CounterMode)
+{
+  uint16_t tmpcr1 = 0;
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_COUNTER_MODE(TIM_CounterMode));
+  tmpcr1 = TIMx-&gt;CR1;
+  /* Reset the CMS and DIR Bits */
+  tmpcr1 &amp;= CR1_CounterMode_Mask;
+  /* Set the Counter Mode */
+  tmpcr1 |= TIM_CounterMode;
+  /* Write to TIMx CR1 register */
+  TIMx-&gt;CR1 = tmpcr1;
+}
+
+/**
+  * @brief  Selects the Input Trigger source
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_InputTriggerSource: The Input Trigger source.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_TS_ITR0: Internal Trigger 0
+  *     @arg TIM_TS_ITR1: Internal Trigger 1
+  *     @arg TIM_TS_ITR2: Internal Trigger 2
+  *     @arg TIM_TS_ITR3: Internal Trigger 3
+  *     @arg TIM_TS_TI1F_ED: TI1 Edge Detector
+  *     @arg TIM_TS_TI1FP1: Filtered Timer Input 1
+  *     @arg TIM_TS_TI2FP2: Filtered Timer Input 2
+  *     @arg TIM_TS_ETRF: External Trigger input
+  * @retval None
+  */
+void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
+{
+  uint16_t tmpsmcr = 0;
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));
+  /* Get the TIMx SMCR register value */
+  tmpsmcr = TIMx-&gt;SMCR;
+  /* Reset the TS Bits */
+  tmpsmcr &amp;= SMCR_TS_Mask;
+  /* Set the Input Trigger source */
+  tmpsmcr |= TIM_InputTriggerSource;
+  /* Write to TIMx SMCR */
+  TIMx-&gt;SMCR = tmpsmcr;
+}
+
+/**
+  * @brief  Configures the TIMx Encoder Interface.
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_EncoderMode: specifies the TIMx Encoder Mode.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_EncoderMode_TI1: Counter counts on TI1FP1 edge depending on TI2FP2 level.
+  *     @arg TIM_EncoderMode_TI2: Counter counts on TI2FP2 edge depending on TI1FP1 level.
+  *     @arg TIM_EncoderMode_TI12: Counter counts on both TI1FP1 and TI2FP2 edges depending
+  *                                on the level of the other input.
+  * @param  TIM_IC1Polarity: specifies the IC1 Polarity
+  *   This parmeter can be one of the following values:
+  *     @arg TIM_ICPolarity_Falling: IC Falling edge.
+  *     @arg TIM_ICPolarity_Rising: IC Rising edge.
+  * @param  TIM_IC2Polarity: specifies the IC2 Polarity
+  *   This parmeter can be one of the following values:
+  *     @arg TIM_ICPolarity_Falling: IC Falling edge.
+  *     @arg TIM_ICPolarity_Rising: IC Rising edge.
+  * @retval None
+  */
+void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t TIM_EncoderMode,
+                                uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity)
+{
+  uint16_t tmpsmcr = 0;
+  uint16_t tmpccmr1 = 0;
+  uint16_t tmpccer = 0;
+    
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_ENCODER_MODE(TIM_EncoderMode));
+  assert_param(IS_TIM_IC_POLARITY(TIM_IC1Polarity));
+  assert_param(IS_TIM_IC_POLARITY(TIM_IC2Polarity));
+
+  /* Get the TIMx SMCR register value */
+  tmpsmcr = TIMx-&gt;SMCR;
+
+  /* Get the TIMx CCMR1 register value */
+  tmpccmr1 = TIMx-&gt;CCMR1;
+
+  /* Get the TIMx CCER register value */
+  tmpccer = TIMx-&gt;CCER;
+
+  /* Set the encoder Mode */
+  tmpsmcr &amp;= SMCR_SMS_Mask;
+  tmpsmcr |= TIM_EncoderMode;
+
+  /* Select the Capture Compare 1 and the Capture Compare 2 as input */
+  tmpccmr1 &amp;= CCMR_CC13S_Mask &amp; CCMR_CC24S_Mask;
+  tmpccmr1 |= CCMR_TI13Direct_Set | CCMR_TI24Direct_Set;
+
+  /* Set the TI1 and the TI2 Polarities */
+  tmpccer &amp;= CCER_CC1P_Reset &amp; CCER_CC2P_Reset;
+  tmpccer |= (uint16_t)(TIM_IC1Polarity | (uint16_t)(TIM_IC2Polarity &lt;&lt; (uint16_t)4));
+
+  /* Write to TIMx SMCR */
+  TIMx-&gt;SMCR = tmpsmcr;
+
+  /* Write to TIMx CCMR1 */
+  TIMx-&gt;CCMR1 = tmpccmr1;
+
+  /* Write to TIMx CCER */
+  TIMx-&gt;CCER = tmpccer;
+}
+
+/**
+  * @brief  Forces the TIMx output 1 waveform to active or inactive level.
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_ForcedAction: specifies the forced Action to be set to the output waveform.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_ForcedAction_Active: Force active level on OC1REF
+  *     @arg TIM_ForcedAction_InActive: Force inactive level on OC1REF.
+  * @retval None
+  */
+void TIM_ForcedOC1Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
+{
+  uint16_t tmpccmr1 = 0;
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
+  tmpccmr1 = TIMx-&gt;CCMR1;
+  /* Reset the OC1M Bits */
+  tmpccmr1 &amp;= CCMR_OC13M_Mask;
+  /* Configure The Forced output Mode */
+  tmpccmr1 |= TIM_ForcedAction;
+  /* Write to TIMx CCMR1 register */
+  TIMx-&gt;CCMR1 = tmpccmr1;
+}
+
+/**
+  * @brief  Forces the TIMx output 2 waveform to active or inactive level.
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_ForcedAction: specifies the forced Action to be set to the output waveform.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_ForcedAction_Active: Force active level on OC2REF
+  *     @arg TIM_ForcedAction_InActive: Force inactive level on OC2REF.
+  * @retval None
+  */
+void TIM_ForcedOC2Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
+{
+  uint16_t tmpccmr1 = 0;
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
+  tmpccmr1 = TIMx-&gt;CCMR1;
+  /* Reset the OC2M Bits */
+  tmpccmr1 &amp;= CCMR_OC24M_Mask;
+  /* Configure The Forced output Mode */
+  tmpccmr1 |= (uint16_t)(TIM_ForcedAction &lt;&lt; 8);
+  /* Write to TIMx CCMR1 register */
+  TIMx-&gt;CCMR1 = tmpccmr1;
+}
+
+/**
+  * @brief  Forces the TIMx output 3 waveform to active or inactive level.
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_ForcedAction: specifies the forced Action to be set to the output waveform.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_ForcedAction_Active: Force active level on OC3REF
+  *     @arg TIM_ForcedAction_InActive: Force inactive level on OC3REF.
+  * @retval None
+  */
+void TIM_ForcedOC3Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
+{
+  uint16_t tmpccmr2 = 0;
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
+  tmpccmr2 = TIMx-&gt;CCMR2;
+  /* Reset the OC1M Bits */
+  tmpccmr2 &amp;= CCMR_OC13M_Mask;
+  /* Configure The Forced output Mode */
+  tmpccmr2 |= TIM_ForcedAction;
+  /* Write to TIMx CCMR2 register */
+  TIMx-&gt;CCMR2 = tmpccmr2;
+}
+
+/**
+  * @brief  Forces the TIMx output 4 waveform to active or inactive level.
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_ForcedAction: specifies the forced Action to be set to the output waveform.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_ForcedAction_Active: Force active level on OC4REF
+  *     @arg TIM_ForcedAction_InActive: Force inactive level on OC4REF.
+  * @retval None
+  */
+void TIM_ForcedOC4Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
+{
+  uint16_t tmpccmr2 = 0;
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
+  tmpccmr2 = TIMx-&gt;CCMR2;
+  /* Reset the OC2M Bits */
+  tmpccmr2 &amp;= CCMR_OC24M_Mask;
+  /* Configure The Forced output Mode */
+  tmpccmr2 |= (uint16_t)(TIM_ForcedAction &lt;&lt; 8);
+  /* Write to TIMx CCMR2 register */
+  TIMx-&gt;CCMR2 = tmpccmr2;
+}
+
+/**
+  * @brief  Enables or disables TIMx peripheral Preload register on ARR.
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  NewState: new state of the TIMx peripheral Preload register
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_ALL_PERIPH(TIMx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Set the ARR Preload Bit */
+    TIMx-&gt;CR1 |= CR1_ARPE_Set;
+  }
+  else
+  {
+    /* Reset the ARR Preload Bit */
+    TIMx-&gt;CR1 &amp;= CR1_ARPE_Reset;
+  }
+}
+
+/**
+  * @brief  Selects the TIM peripheral Commutation event.
+  * @param  TIMx: where x can be  1 or 8 to select the TIMx peripheral
+  * @param  NewState: new state of the Commutation event.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void TIM_SelectCOM(TIM_TypeDef* TIMx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_18_PERIPH(TIMx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Set the COM Bit */
+    TIMx-&gt;CR2 |= CR2_CCUS_Set;
+  }
+  else
+  {
+    /* Reset the COM Bit */
+    TIMx-&gt;CR2 &amp;= CR2_CCUS_Reset;
+  }
+}
+
+/**
+  * @brief  Selects the TIMx peripheral Capture Compare DMA source.
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  NewState: new state of the Capture Compare DMA source
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Set the CCDS Bit */
+    TIMx-&gt;CR2 |= CR2_CCDS_Set;
+  }
+  else
+  {
+    /* Reset the CCDS Bit */
+    TIMx-&gt;CR2 &amp;= CR2_CCDS_Reset;
+  }
+}
+
+/**
+  * @brief  Sets or Resets the TIM peripheral Capture Compare Preload Control bit.
+  * @param  TIMx: where x can be  1 or 8 to select the TIMx peripheral
+  * @param  NewState: new state of the Capture Compare Preload Control bit
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void TIM_CCPreloadControl(TIM_TypeDef* TIMx, FunctionalState NewState)
+{ 
+  /* Check the parameters */
+  assert_param(IS_TIM_18_PERIPH(TIMx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Set the CCPC Bit */
+    TIMx-&gt;CR2 |= CR2_CCPC_Set;
+  }
+  else
+  {
+    /* Reset the CCPC Bit */
+    TIMx-&gt;CR2 &amp;= CR2_CCPC_Reset;
+  }
+}
+
+/**
+  * @brief  Enables or disables the TIMx peripheral Preload register on CCR1.
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_OCPreload: new state of the TIMx peripheral Preload register
+  *   This parameter can be one of the following values:
+  *     @arg TIM_OCPreload_Enable
+  *     @arg TIM_OCPreload_Disable
+  * @retval None
+  */
+void TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
+{
+  uint16_t tmpccmr1 = 0;
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
+  tmpccmr1 = TIMx-&gt;CCMR1;
+  /* Reset the OC1PE Bit */
+  tmpccmr1 &amp;= CCMR_OC13PE_Reset;
+  /* Enable or Disable the Output Compare Preload feature */
+  tmpccmr1 |= TIM_OCPreload;
+  /* Write to TIMx CCMR1 register */
+  TIMx-&gt;CCMR1 = tmpccmr1;
+}
+
+/**
+  * @brief  Enables or disables the TIMx peripheral Preload register on CCR2.
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_OCPreload: new state of the TIMx peripheral Preload register
+  *   This parameter can be one of the following values:
+  *     @arg TIM_OCPreload_Enable
+  *     @arg TIM_OCPreload_Disable
+  * @retval None
+  */
+void TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
+{
+  uint16_t tmpccmr1 = 0;
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
+  tmpccmr1 = TIMx-&gt;CCMR1;
+  /* Reset the OC2PE Bit */
+  tmpccmr1 &amp;= CCMR_OC24PE_Reset;
+  /* Enable or Disable the Output Compare Preload feature */
+  tmpccmr1 |= (uint16_t)(TIM_OCPreload &lt;&lt; 8);
+  /* Write to TIMx CCMR1 register */
+  TIMx-&gt;CCMR1 = tmpccmr1;
+}
+
+/**
+  * @brief  Enables or disables the TIMx peripheral Preload register on CCR3.
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_OCPreload: new state of the TIMx peripheral Preload register
+  *   This parameter can be one of the following values:
+  *     @arg TIM_OCPreload_Enable
+  *     @arg TIM_OCPreload_Disable
+  * @retval None
+  */
+void TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
+{
+  uint16_t tmpccmr2 = 0;
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
+  tmpccmr2 = TIMx-&gt;CCMR2;
+  /* Reset the OC3PE Bit */
+  tmpccmr2 &amp;= CCMR_OC13PE_Reset;
+  /* Enable or Disable the Output Compare Preload feature */
+  tmpccmr2 |= TIM_OCPreload;
+  /* Write to TIMx CCMR2 register */
+  TIMx-&gt;CCMR2 = tmpccmr2;
+}
+
+/**
+  * @brief  Enables or disables the TIMx peripheral Preload register on CCR4.
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_OCPreload: new state of the TIMx peripheral Preload register
+  *   This parameter can be one of the following values:
+  *     @arg TIM_OCPreload_Enable
+  *     @arg TIM_OCPreload_Disable
+  * @retval None
+  */
+void TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
+{
+  uint16_t tmpccmr2 = 0;
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
+  tmpccmr2 = TIMx-&gt;CCMR2;
+  /* Reset the OC4PE Bit */
+  tmpccmr2 &amp;= CCMR_OC24PE_Reset;
+  /* Enable or Disable the Output Compare Preload feature */
+  tmpccmr2 |= (uint16_t)(TIM_OCPreload &lt;&lt; 8);
+  /* Write to TIMx CCMR2 register */
+  TIMx-&gt;CCMR2 = tmpccmr2;
+}
+
+/**
+  * @brief  Configures the TIMx Output Compare 1 Fast feature.
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_OCFast: new state of the Output Compare Fast Enable Bit.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_OCFast_Enable: TIM output compare fast enable
+  *     @arg TIM_OCFast_Disable: TIM output compare fast disable
+  * @retval None
+  */
+void TIM_OC1FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
+{
+  uint16_t tmpccmr1 = 0;
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
+  /* Get the TIMx CCMR1 register value */
+  tmpccmr1 = TIMx-&gt;CCMR1;
+  /* Reset the OC1FE Bit */
+  tmpccmr1 &amp;= CCMR_OC13FE_Reset;
+  /* Enable or Disable the Output Compare Fast Bit */
+  tmpccmr1 |= TIM_OCFast;
+  /* Write to TIMx CCMR1 */
+  TIMx-&gt;CCMR1 = tmpccmr1;
+}
+
+/**
+  * @brief  Configures the TIMx Output Compare 2 Fast feature.
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_OCFast: new state of the Output Compare Fast Enable Bit.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_OCFast_Enable: TIM output compare fast enable
+  *     @arg TIM_OCFast_Disable: TIM output compare fast disable
+  * @retval None
+  */
+void TIM_OC2FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
+{
+  uint16_t tmpccmr1 = 0;
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
+  /* Get the TIMx CCMR1 register value */
+  tmpccmr1 = TIMx-&gt;CCMR1;
+  /* Reset the OC2FE Bit */
+  tmpccmr1 &amp;= CCMR_OC24FE_Reset;
+  /* Enable or Disable the Output Compare Fast Bit */
+  tmpccmr1 |= (uint16_t)(TIM_OCFast &lt;&lt; 8);
+  /* Write to TIMx CCMR1 */
+  TIMx-&gt;CCMR1 = tmpccmr1;
+}
+
+/**
+  * @brief  Configures the TIMx Output Compare 3 Fast feature.
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_OCFast: new state of the Output Compare Fast Enable Bit.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_OCFast_Enable: TIM output compare fast enable
+  *     @arg TIM_OCFast_Disable: TIM output compare fast disable
+  * @retval None
+  */
+void TIM_OC3FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
+{
+  uint16_t tmpccmr2 = 0;
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
+  /* Get the TIMx CCMR2 register value */
+  tmpccmr2 = TIMx-&gt;CCMR2;
+  /* Reset the OC3FE Bit */
+  tmpccmr2 &amp;= CCMR_OC13FE_Reset;
+  /* Enable or Disable the Output Compare Fast Bit */
+  tmpccmr2 |= TIM_OCFast;
+  /* Write to TIMx CCMR2 */
+  TIMx-&gt;CCMR2 = tmpccmr2;
+}
+
+/**
+  * @brief  Configures the TIMx Output Compare 4 Fast feature.
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_OCFast: new state of the Output Compare Fast Enable Bit.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_OCFast_Enable: TIM output compare fast enable
+  *     @arg TIM_OCFast_Disable: TIM output compare fast disable
+  * @retval None
+  */
+void TIM_OC4FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
+{
+  uint16_t tmpccmr2 = 0;
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
+  /* Get the TIMx CCMR2 register value */
+  tmpccmr2 = TIMx-&gt;CCMR2;
+  /* Reset the OC4FE Bit */
+  tmpccmr2 &amp;= CCMR_OC24FE_Reset;
+  /* Enable or Disable the Output Compare Fast Bit */
+  tmpccmr2 |= (uint16_t)(TIM_OCFast &lt;&lt; 8);
+  /* Write to TIMx CCMR2 */
+  TIMx-&gt;CCMR2 = tmpccmr2;
+}
+
+/**
+  * @brief  Clears or safeguards the OCREF1 signal on an external event
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_OCClear: new state of the Output Compare Clear Enable Bit.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_OCClear_Enable: TIM Output clear enable
+  *     @arg TIM_OCClear_Disable: TIM Output clear disable
+  * @retval None
+  */
+void TIM_ClearOC1Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
+{
+  uint16_t tmpccmr1 = 0;
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
+  tmpccmr1 = TIMx-&gt;CCMR1;
+  /* Reset the OC1CE Bit */
+  tmpccmr1 &amp;= CCMR_OC13CE_Reset;
+  /* Enable or Disable the Output Compare Clear Bit */
+  tmpccmr1 |= TIM_OCClear;
+  /* Write to TIMx CCMR1 register */
+  TIMx-&gt;CCMR1 = tmpccmr1;
+}
+
+/**
+  * @brief  Clears or safeguards the OCREF2 signal on an external event
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_OCClear: new state of the Output Compare Clear Enable Bit.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_OCClear_Enable: TIM Output clear enable
+  *     @arg TIM_OCClear_Disable: TIM Output clear disable
+  * @retval None
+  */
+void TIM_ClearOC2Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
+{
+  uint16_t tmpccmr1 = 0;
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
+  tmpccmr1 = TIMx-&gt;CCMR1;
+  /* Reset the OC2CE Bit */
+  tmpccmr1 &amp;= CCMR_OC24CE_Reset;
+  /* Enable or Disable the Output Compare Clear Bit */
+  tmpccmr1 |= (uint16_t)(TIM_OCClear &lt;&lt; 8);
+  /* Write to TIMx CCMR1 register */
+  TIMx-&gt;CCMR1 = tmpccmr1;
+}
+
+/**
+  * @brief  Clears or safeguards the OCREF3 signal on an external event
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_OCClear: new state of the Output Compare Clear Enable Bit.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_OCClear_Enable: TIM Output clear enable
+  *     @arg TIM_OCClear_Disable: TIM Output clear disable
+  * @retval None
+  */
+void TIM_ClearOC3Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
+{
+  uint16_t tmpccmr2 = 0;
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
+  tmpccmr2 = TIMx-&gt;CCMR2;
+  /* Reset the OC3CE Bit */
+  tmpccmr2 &amp;= CCMR_OC13CE_Reset;
+  /* Enable or Disable the Output Compare Clear Bit */
+  tmpccmr2 |= TIM_OCClear;
+  /* Write to TIMx CCMR2 register */
+  TIMx-&gt;CCMR2 = tmpccmr2;
+}
+
+/**
+  * @brief  Clears or safeguards the OCREF4 signal on an external event
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_OCClear: new state of the Output Compare Clear Enable Bit.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_OCClear_Enable: TIM Output clear enable
+  *     @arg TIM_OCClear_Disable: TIM Output clear disable
+  * @retval None
+  */
+void TIM_ClearOC4Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
+{
+  uint16_t tmpccmr2 = 0;
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
+  tmpccmr2 = TIMx-&gt;CCMR2;
+  /* Reset the OC4CE Bit */
+  tmpccmr2 &amp;= CCMR_OC24CE_Reset;
+  /* Enable or Disable the Output Compare Clear Bit */
+  tmpccmr2 |= (uint16_t)(TIM_OCClear &lt;&lt; 8);
+  /* Write to TIMx CCMR2 register */
+  TIMx-&gt;CCMR2 = tmpccmr2;
+}
+
+/**
+  * @brief  Configures the TIMx channel 1 polarity.
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_OCPolarity: specifies the OC1 Polarity
+  *   This parmeter can be one of the following values:
+  *     @arg TIM_OCPolarity_High: Output Compare active high
+  *     @arg TIM_OCPolarity_Low: Output Compare active low
+  * @retval None
+  */
+void TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
+{
+  uint16_t tmpccer = 0;
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
+  tmpccer = TIMx-&gt;CCER;
+  /* Set or Reset the CC1P Bit */
+  tmpccer &amp;= CCER_CC1P_Reset;
+  tmpccer |= TIM_OCPolarity;
+  /* Write to TIMx CCER register */
+  TIMx-&gt;CCER = tmpccer;
+}
+
+/**
+  * @brief  Configures the TIMx Channel 1N polarity.
+  * @param  TIMx: where x can be 1 or 8 to select the TIM peripheral.
+  * @param  TIM_OCNPolarity: specifies the OC1N Polarity
+  *   This parmeter can be one of the following values:
+  *     @arg TIM_OCNPolarity_High: Output Compare active high
+  *     @arg TIM_OCNPolarity_Low: Output Compare active low
+  * @retval None
+  */
+void TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
+{
+  uint16_t tmpccer = 0;
+  /* Check the parameters */
+  assert_param(IS_TIM_18_PERIPH(TIMx));
+  assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
+   
+  tmpccer = TIMx-&gt;CCER;
+  /* Set or Reset the CC1NP Bit */
+  tmpccer &amp;= CCER_CC1NP_Reset;
+  tmpccer |= TIM_OCNPolarity;
+  /* Write to TIMx CCER register */
+  TIMx-&gt;CCER = tmpccer;
+}
+
+/**
+  * @brief  Configures the TIMx channel 2 polarity.
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_OCPolarity: specifies the OC2 Polarity
+  *   This parmeter can be one of the following values:
+  *     @arg TIM_OCPolarity_High: Output Compare active high
+  *     @arg TIM_OCPolarity_Low: Output Compare active low
+  * @retval None
+  */
+void TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
+{
+  uint16_t tmpccer = 0;
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
+  tmpccer = TIMx-&gt;CCER;
+  /* Set or Reset the CC2P Bit */
+  tmpccer &amp;= CCER_CC2P_Reset;
+  tmpccer |= (uint16_t)(TIM_OCPolarity &lt;&lt; 4);
+  /* Write to TIMx CCER register */
+  TIMx-&gt;CCER = tmpccer;
+}
+
+/**
+  * @brief  Configures the TIMx Channel 2N polarity.
+  * @param  TIMx: where x can be 1 or 8 to select the TIM peripheral.
+  * @param  TIM_OCNPolarity: specifies the OC2N Polarity
+  *   This parmeter can be one of the following values:
+  *     @arg TIM_OCNPolarity_High: Output Compare active high
+  *     @arg TIM_OCNPolarity_Low: Output Compare active low
+  * @retval None
+  */
+void TIM_OC2NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
+{
+  uint16_t tmpccer = 0;
+  /* Check the parameters */
+  assert_param(IS_TIM_18_PERIPH(TIMx));
+  assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
+  
+  tmpccer = TIMx-&gt;CCER;
+  /* Set or Reset the CC2NP Bit */
+  tmpccer &amp;= CCER_CC2NP_Reset;
+  tmpccer |= (uint16_t)(TIM_OCNPolarity &lt;&lt; 4);
+  /* Write to TIMx CCER register */
+  TIMx-&gt;CCER = tmpccer;
+}
+
+/**
+  * @brief  Configures the TIMx channel 3 polarity.
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_OCPolarity: specifies the OC3 Polarity
+  *   This parmeter can be one of the following values:
+  *     @arg TIM_OCPolarity_High: Output Compare active high
+  *     @arg TIM_OCPolarity_Low: Output Compare active low
+  * @retval None
+  */
+void TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
+{
+  uint16_t tmpccer = 0;
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
+  tmpccer = TIMx-&gt;CCER;
+  /* Set or Reset the CC3P Bit */
+  tmpccer &amp;= CCER_CC3P_Reset;
+  tmpccer |= (uint16_t)(TIM_OCPolarity &lt;&lt; 8);
+  /* Write to TIMx CCER register */
+  TIMx-&gt;CCER = tmpccer;
+}
+
+/**
+  * @brief  Configures the TIMx Channel 3N polarity.
+  * @param  TIMx: where x can be 1 or 8 to select the TIM peripheral.
+  * @param  TIM_OCNPolarity: specifies the OC3N Polarity
+  *   This parmeter can be one of the following values:
+  *     @arg TIM_OCNPolarity_High: Output Compare active high
+  *     @arg TIM_OCNPolarity_Low: Output Compare active low
+  * @retval None
+  */
+void TIM_OC3NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
+{
+  uint16_t tmpccer = 0;
+ 
+  /* Check the parameters */
+  assert_param(IS_TIM_18_PERIPH(TIMx));
+  assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
+    
+  tmpccer = TIMx-&gt;CCER;
+  /* Set or Reset the CC3NP Bit */
+  tmpccer &amp;= CCER_CC3NP_Reset;
+  tmpccer |= (uint16_t)(TIM_OCNPolarity &lt;&lt; 8);
+  /* Write to TIMx CCER register */
+  TIMx-&gt;CCER = tmpccer;
+}
+
+/**
+  * @brief  Configures the TIMx channel 4 polarity.
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_OCPolarity: specifies the OC4 Polarity
+  *   This parmeter can be one of the following values:
+  *     @arg TIM_OCPolarity_High: Output Compare active high
+  *     @arg TIM_OCPolarity_Low: Output Compare active low
+  * @retval None
+  */
+void TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
+{
+  uint16_t tmpccer = 0;
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
+  tmpccer = TIMx-&gt;CCER;
+  /* Set or Reset the CC4P Bit */
+  tmpccer &amp;= CCER_CC4P_Reset;
+  tmpccer |= (uint16_t)(TIM_OCPolarity &lt;&lt; 12);
+  /* Write to TIMx CCER register */
+  TIMx-&gt;CCER = tmpccer;
+}
+
+/**
+  * @brief  Enables or disables the TIM Capture Compare Channel x.
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_Channel: specifies the TIM Channel
+  *   This parmeter can be one of the following values:
+  *     @arg TIM_Channel_1: TIM Channel 1
+  *     @arg TIM_Channel_2: TIM Channel 2
+  *     @arg TIM_Channel_3: TIM Channel 3
+  *     @arg TIM_Channel_4: TIM Channel 4
+  * @param  TIM_CCx: specifies the TIM Channel CCxE bit new state.
+  *   This parameter can be: TIM_CCx_Enable or TIM_CCx_Disable. 
+  * @retval None
+  */
+void TIM_CCxCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCx)
+{
+  uint16_t tmp = 0;
+
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_CHANNEL(TIM_Channel));
+  assert_param(IS_TIM_CCX(TIM_CCx));
+
+  tmp = CCER_CCE_Set &lt;&lt; TIM_Channel;
+
+  /* Reset the CCxE Bit */
+  TIMx-&gt;CCER &amp;= (uint16_t)~ tmp;
+
+  /* Set or reset the CCxE Bit */ 
+  TIMx-&gt;CCER |=  (uint16_t)(TIM_CCx &lt;&lt; TIM_Channel);
+}
+
+/**
+  * @brief  Enables or disables the TIM Capture Compare Channel xN.
+  * @param  TIMx: where x can be 1 or 8 to select the TIM peripheral.
+  * @param  TIM_Channel: specifies the TIM Channel
+  *   This parmeter can be one of the following values:
+  *     @arg TIM_Channel_1: TIM Channel 1
+  *     @arg TIM_Channel_2: TIM Channel 2
+  *     @arg TIM_Channel_3: TIM Channel 3
+  * @param  TIM_CCxN: specifies the TIM Channel CCxNE bit new state.
+  *   This parameter can be: TIM_CCxN_Enable or TIM_CCxN_Disable. 
+  * @retval None
+  */
+void TIM_CCxNCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCxN)
+{
+  uint16_t tmp = 0;
+
+  /* Check the parameters */
+  assert_param(IS_TIM_18_PERIPH(TIMx));
+  assert_param(IS_TIM_COMPLEMENTARY_CHANNEL(TIM_Channel));
+  assert_param(IS_TIM_CCXN(TIM_CCxN));
+
+  tmp = CCER_CCNE_Set &lt;&lt; TIM_Channel;
+
+  /* Reset the CCxNE Bit */
+  TIMx-&gt;CCER &amp;= (uint16_t) ~tmp;
+
+  /* Set or reset the CCxNE Bit */ 
+  TIMx-&gt;CCER |=  (uint16_t)(TIM_CCxN &lt;&lt; TIM_Channel);
+}
+
+/**
+  * @brief  Selects the TIM Ouput Compare Mode.
+  * @note   This function disables the selected channel before changing the Ouput
+  *         Compare Mode.
+  *         User has to enable this channel using TIM_CCxCmd and TIM_CCxNCmd functions.
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_Channel: specifies the TIM Channel
+  *   This parmeter can be one of the following values:
+  *     @arg TIM_Channel_1: TIM Channel 1
+  *     @arg TIM_Channel_2: TIM Channel 2
+  *     @arg TIM_Channel_3: TIM Channel 3
+  *     @arg TIM_Channel_4: TIM Channel 4
+  * @param  TIM_OCMode: specifies the TIM Output Compare Mode.
+  *   This paramter can be one of the following values:
+  *     @arg TIM_OCMode_Timing
+  *     @arg TIM_OCMode_Active
+  *     @arg TIM_OCMode_Toggle
+  *     @arg TIM_OCMode_PWM1
+  *     @arg TIM_OCMode_PWM2
+  *     @arg TIM_ForcedAction_Active
+  *     @arg TIM_ForcedAction_InActive
+  * @retval None
+  */
+void TIM_SelectOCxM(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_OCMode)
+{
+  uint32_t tmp = 0;
+  uint16_t tmp1 = 0;
+
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_CHANNEL(TIM_Channel));
+  assert_param(IS_TIM_OCM(TIM_OCMode));
+
+  tmp = (uint32_t) TIMx;
+  tmp += CCMR_Offset;
+
+  tmp1 = CCER_CCE_Set &lt;&lt; (uint16_t)TIM_Channel;
+
+  /* Disable the Channel: Reset the CCxE Bit */
+  TIMx-&gt;CCER &amp;= (uint16_t) ~tmp1;
+
+  if((TIM_Channel == TIM_Channel_1) ||(TIM_Channel == TIM_Channel_3))
+  {
+    tmp += (TIM_Channel&gt;&gt;1);
+
+    /* Reset the OCxM bits in the CCMRx register */
+    *(__IO uint32_t *) tmp &amp;= CCMR_OC13M_Mask;
+   
+    /* Configure the OCxM bits in the CCMRx register */
+    *(__IO uint32_t *) tmp |= TIM_OCMode;
+  }
+  else
+  {
+    tmp += (uint16_t)(TIM_Channel - (uint16_t)4)&gt;&gt; (uint16_t)1;
+
+    /* Reset the OCxM bits in the CCMRx register */
+    *(__IO uint32_t *) tmp &amp;= CCMR_OC24M_Mask;
+    
+    /* Configure the OCxM bits in the CCMRx register */
+    *(__IO uint32_t *) tmp |= (uint16_t)(TIM_OCMode &lt;&lt; 8);
+  }
+}
+
+/**
+  * @brief  Enables or Disables the TIMx Update event.
+  * @param  TIMx: where x can be 1 to 8 to select the TIM peripheral.
+  * @param  NewState: new state of the TIMx UDIS bit
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_ALL_PERIPH(TIMx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Set the Update Disable Bit */
+    TIMx-&gt;CR1 |= CR1_UDIS_Set;
+  }
+  else
+  {
+    /* Reset the Update Disable Bit */
+    TIMx-&gt;CR1 &amp;= CR1_UDIS_Reset;
+  }
+}
+
+/**
+  * @brief  Configures the TIMx Update Request Interrupt source.
+  * @param  TIMx: where x can be 1 to 8 to select the TIM peripheral.
+  * @param  TIM_UpdateSource: specifies the Update source.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_UpdateSource_Regular: Source of update is the counter overflow/underflow
+                                       or the setting of UG bit, or an update generation
+                                       through the slave mode controller.
+  *     @arg TIM_UpdateSource_Global: Source of update is counter overflow/underflow.
+  * @retval None
+  */
+void TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, uint16_t TIM_UpdateSource)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_ALL_PERIPH(TIMx));
+  assert_param(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));
+  if (TIM_UpdateSource != TIM_UpdateSource_Global)
+  {
+    /* Set the URS Bit */
+    TIMx-&gt;CR1 |= CR1_URS_Set;
+  }
+  else
+  {
+    /* Reset the URS Bit */
+    TIMx-&gt;CR1 &amp;= CR1_URS_Reset;
+  }
+}
+
+/**
+  * @brief  Enables or disables the TIMx&#146;s Hall sensor interface.
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  NewState: new state of the TIMx Hall sensor interface.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Set the TI1S Bit */
+    TIMx-&gt;CR2 |= CR2_TI1S_Set;
+  }
+  else
+  {
+    /* Reset the TI1S Bit */
+    TIMx-&gt;CR2 &amp;= CR2_TI1S_Reset;
+  }
+}
+
+/**
+  * @brief  Selects the TIMx&#146;s One Pulse Mode.
+  * @param  TIMx: where x can be 1 to 8 to select the TIM peripheral.
+  * @param  TIM_OPMode: specifies the OPM Mode to be used.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_OPMode_Single
+  *     @arg TIM_OPMode_Repetitive
+  * @retval None
+  */
+void TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, uint16_t TIM_OPMode)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_ALL_PERIPH(TIMx));
+  assert_param(IS_TIM_OPM_MODE(TIM_OPMode));
+  /* Reset the OPM Bit */
+  TIMx-&gt;CR1 &amp;= CR1_OPM_Reset;
+  /* Configure the OPM Mode */
+  TIMx-&gt;CR1 |= TIM_OPMode;
+}
+
+/**
+  * @brief  Selects the TIMx Trigger Output Mode.
+  * @param  TIMx: where x can be 1 to 8 to select the TIM peripheral.
+  * @param  TIM_TRGOSource: specifies the Trigger Output source.
+  *   This paramter can be one of the following values:
+  *
+  *  - For all TIMx
+  *     @arg TIM_TRGOSource_Reset:  The UG bit in the TIM_EGR register is used as the trigger output (TRGO).
+  *     @arg TIM_TRGOSource_Enable: The Counter Enable CEN is used as the trigger output (TRGO).
+  *     @arg TIM_TRGOSource_Update: The update event is selected as the trigger output (TRGO).
+  *
+  *  - For all TIMx except TIM6 and TIM7
+  *     @arg TIM_TRGOSource_OC1: The trigger output sends a positive pulse when the CC1IF flag
+  *                              is to be set, as soon as a capture or compare match occurs (TRGO).
+  *     @arg TIM_TRGOSource_OC1Ref: OC1REF signal is used as the trigger output (TRGO).
+  *     @arg TIM_TRGOSource_OC2Ref: OC2REF signal is used as the trigger output (TRGO).
+  *     @arg TIM_TRGOSource_OC3Ref: OC3REF signal is used as the trigger output (TRGO).
+  *     @arg TIM_TRGOSource_OC4Ref: OC4REF signal is used as the trigger output (TRGO).
+  *
+  * @retval None
+  */
+void TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_TRGOSource)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_ALL_PERIPH(TIMx));
+  assert_param(IS_TIM_TRGO_SOURCE(TIM_TRGOSource));
+  /* Reset the MMS Bits */
+  TIMx-&gt;CR2 &amp;= CR2_MMS_Mask;
+  /* Select the TRGO source */
+  TIMx-&gt;CR2 |=  TIM_TRGOSource;
+}
+
+/**
+  * @brief  Selects the TIMx Slave Mode.
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_SlaveMode: specifies the Timer Slave Mode.
+  *   This paramter can be one of the following values:
+  *     @arg TIM_SlaveMode_Reset: Rising edge of the selected trigger signal (TRGI) re-initializes
+  *                               the counter and triggers an update of the registers.
+  *     @arg TIM_SlaveMode_Gated:     The counter clock is enabled when the trigger signal (TRGI) is high.
+  *     @arg TIM_SlaveMode_Trigger:   The counter starts at a rising edge of the trigger TRGI.
+  *     @arg TIM_SlaveMode_External1: Rising edges of the selected trigger (TRGI) clock the counter.
+  * @retval None
+  */
+void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_SLAVE_MODE(TIM_SlaveMode));
+  /* Reset the SMS Bits */
+  TIMx-&gt;SMCR &amp;= SMCR_SMS_Mask;
+  /* Select the Slave Mode */
+  TIMx-&gt;SMCR |= TIM_SlaveMode;
+}
+
+/**
+  * @brief  Sets or Resets the TIMx Master/Slave Mode.
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_MasterSlaveMode: specifies the Timer Master Slave Mode.
+  *   This paramter can be one of the following values:
+  *     @arg TIM_MasterSlaveMode_Enable: synchronization between the current timer
+  *                                      and its slaves (through TRGO).
+  *     @arg TIM_MasterSlaveMode_Disable: No action
+  * @retval None
+  */
+void TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_MasterSlaveMode)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_MSM_STATE(TIM_MasterSlaveMode));
+  /* Reset the MSM Bit */
+  TIMx-&gt;SMCR &amp;= SMCR_MSM_Reset;
+  
+  /* Set or Reset the MSM Bit */
+  TIMx-&gt;SMCR |= TIM_MasterSlaveMode;
+}
+
+/**
+  * @brief  Sets the TIMx Counter Register value
+  * @param  TIMx: where x can be 1 to 8 to select the TIM peripheral.
+  * @param  Counter: specifies the Counter register new value.
+  * @retval None
+  */
+void TIM_SetCounter(TIM_TypeDef* TIMx, uint16_t Counter)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_ALL_PERIPH(TIMx));
+  /* Set the Counter Register value */
+  TIMx-&gt;CNT = Counter;
+}
+
+/**
+  * @brief  Sets the TIMx Autoreload Register value
+  * @param  TIMx: where x can be 1 to 8 to select the TIM peripheral.
+  * @param  Autoreload: specifies the Autoreload register new value.
+  * @retval None
+  */
+void TIM_SetAutoreload(TIM_TypeDef* TIMx, uint16_t Autoreload)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_ALL_PERIPH(TIMx));
+  /* Set the Autoreload Register value */
+  TIMx-&gt;ARR = Autoreload;
+}
+
+/**
+  * @brief  Sets the TIMx Capture Compare1 Register value
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  Compare1: specifies the Capture Compare1 register new value.
+  * @retval None
+  */
+void TIM_SetCompare1(TIM_TypeDef* TIMx, uint16_t Compare1)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  /* Set the Capture Compare1 Register value */
+  TIMx-&gt;CCR1 = Compare1;
+}
+
+/**
+  * @brief  Sets the TIMx Capture Compare2 Register value
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  Compare2: specifies the Capture Compare2 register new value.
+  * @retval None
+  */
+void TIM_SetCompare2(TIM_TypeDef* TIMx, uint16_t Compare2)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  /* Set the Capture Compare2 Register value */
+  TIMx-&gt;CCR2 = Compare2;
+}
+
+/**
+  * @brief  Sets the TIMx Capture Compare3 Register value
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  Compare3: specifies the Capture Compare3 register new value.
+  * @retval None
+  */
+void TIM_SetCompare3(TIM_TypeDef* TIMx, uint16_t Compare3)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  /* Set the Capture Compare3 Register value */
+  TIMx-&gt;CCR3 = Compare3;
+}
+
+/**
+  * @brief  Sets the TIMx Capture Compare4 Register value
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  Compare4: specifies the Capture Compare4 register new value.
+  * @retval None
+  */
+void TIM_SetCompare4(TIM_TypeDef* TIMx, uint16_t Compare4)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  /* Set the Capture Compare4 Register value */
+  TIMx-&gt;CCR4 = Compare4;
+}
+
+/**
+  * @brief  Sets the TIMx Input Capture 1 prescaler.
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_ICPSC: specifies the Input Capture1 prescaler new value.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_ICPSC_DIV1: no prescaler
+  *     @arg TIM_ICPSC_DIV2: capture is done once every 2 events
+  *     @arg TIM_ICPSC_DIV4: capture is done once every 4 events
+  *     @arg TIM_ICPSC_DIV8: capture is done once every 8 events
+  * @retval None
+  */
+void TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
+  /* Reset the IC1PSC Bits */
+  TIMx-&gt;CCMR1 &amp;= CCMR_IC13PSC_Mask;
+  /* Set the IC1PSC value */
+  TIMx-&gt;CCMR1 |= TIM_ICPSC;
+}
+
+/**
+  * @brief  Sets the TIMx Input Capture 2 prescaler.
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_ICPSC: specifies the Input Capture2 prescaler new value.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_ICPSC_DIV1: no prescaler
+  *     @arg TIM_ICPSC_DIV2: capture is done once every 2 events
+  *     @arg TIM_ICPSC_DIV4: capture is done once every 4 events
+  *     @arg TIM_ICPSC_DIV8: capture is done once every 8 events
+  * @retval None
+  */
+void TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
+  /* Reset the IC2PSC Bits */
+  TIMx-&gt;CCMR1 &amp;= CCMR_IC24PSC_Mask;
+  /* Set the IC2PSC value */
+  TIMx-&gt;CCMR1 |= (uint16_t)(TIM_ICPSC &lt;&lt; 8);
+}
+
+/**
+  * @brief  Sets the TIMx Input Capture 3 prescaler.
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_ICPSC: specifies the Input Capture3 prescaler new value.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_ICPSC_DIV1: no prescaler
+  *     @arg TIM_ICPSC_DIV2: capture is done once every 2 events
+  *     @arg TIM_ICPSC_DIV4: capture is done once every 4 events
+  *     @arg TIM_ICPSC_DIV8: capture is done once every 8 events
+  * @retval None
+  */
+void TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
+  /* Reset the IC3PSC Bits */
+  TIMx-&gt;CCMR2 &amp;= CCMR_IC13PSC_Mask;
+  /* Set the IC3PSC value */
+  TIMx-&gt;CCMR2 |= TIM_ICPSC;
+}
+
+/**
+  * @brief  Sets the TIMx Input Capture 4 prescaler.
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_ICPSC: specifies the Input Capture4 prescaler new value.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_ICPSC_DIV1: no prescaler
+  *     @arg TIM_ICPSC_DIV2: capture is done once every 2 events
+  *     @arg TIM_ICPSC_DIV4: capture is done once every 4 events
+  *     @arg TIM_ICPSC_DIV8: capture is done once every 8 events
+  * @retval None
+  */
+void TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
+{  
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
+  /* Reset the IC4PSC Bits */
+  TIMx-&gt;CCMR2 &amp;= CCMR_IC24PSC_Mask;
+  /* Set the IC4PSC value */
+  TIMx-&gt;CCMR2 |= (uint16_t)(TIM_ICPSC &lt;&lt; 8);
+}
+
+/**
+  * @brief  Sets the TIMx Clock Division value.
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_CKD: specifies the clock division value.
+  *   This parameter can be one of the following value:
+  *     @arg TIM_CKD_DIV1: TDTS = Tck_tim
+  *     @arg TIM_CKD_DIV2: TDTS = 2*Tck_tim
+  *     @arg TIM_CKD_DIV4: TDTS = 4*Tck_tim
+  * @retval None
+  */
+void TIM_SetClockDivision(TIM_TypeDef* TIMx, uint16_t TIM_CKD)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_CKD_DIV(TIM_CKD));
+  /* Reset the CKD Bits */
+  TIMx-&gt;CR1 &amp;= CR1_CKD_Mask;
+  /* Set the CKD value */
+  TIMx-&gt;CR1 |= TIM_CKD;
+}
+
+/**
+  * @brief  Gets the TIMx Input Capture 1 value.
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @retval Capture Compare 1 Register value.
+  */
+uint16_t TIM_GetCapture1(TIM_TypeDef* TIMx)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  /* Get the Capture 1 Register value */
+  return TIMx-&gt;CCR1;
+}
+
+/**
+  * @brief  Gets the TIMx Input Capture 2 value.
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @retval Capture Compare 2 Register value.
+  */
+uint16_t TIM_GetCapture2(TIM_TypeDef* TIMx)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  /* Get the Capture 2 Register value */
+  return TIMx-&gt;CCR2;
+}
+
+/**
+  * @brief  Gets the TIMx Input Capture 3 value.
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @retval Capture Compare 3 Register value.
+  */
+uint16_t TIM_GetCapture3(TIM_TypeDef* TIMx)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx)); 
+  /* Get the Capture 3 Register value */
+  return TIMx-&gt;CCR3;
+}
+
+/**
+  * @brief  Gets the TIMx Input Capture 4 value.
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @retval Capture Compare 4 Register value.
+  */
+uint16_t TIM_GetCapture4(TIM_TypeDef* TIMx)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  /* Get the Capture 4 Register value */
+  return TIMx-&gt;CCR4;
+}
+
+/**
+  * @brief  Gets the TIMx Counter value.
+  * @param  TIMx: where x can be 1 to 8 to select the TIM peripheral.
+  * @retval Counter Register value.
+  */
+uint16_t TIM_GetCounter(TIM_TypeDef* TIMx)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_ALL_PERIPH(TIMx));
+  /* Get the Counter Register value */
+  return TIMx-&gt;CNT;
+}
+
+/**
+  * @brief  Gets the TIMx Prescaler value.
+  * @param  TIMx: where x can be 1 to 8 to select the TIM peripheral.
+  * @retval Prescaler Register value.
+  */
+uint16_t TIM_GetPrescaler(TIM_TypeDef* TIMx)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_ALL_PERIPH(TIMx));
+  /* Get the Prescaler Register value */
+  return TIMx-&gt;PSC;
+}
+
+/**
+  * @brief  Checks whether the specified TIM flag is set or not.
+  * @param  TIMx: where x can be 1 to 8 to select the TIM peripheral.
+  * @param  TIM_FLAG: specifies the flag to check.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_FLAG_Update: TIM update Flag
+  *     @arg TIM_FLAG_CC1: TIM Capture Compare 1 Flag
+  *     @arg TIM_FLAG_CC2: TIM Capture Compare 2 Flag
+  *     @arg TIM_FLAG_CC3: TIM Capture Compare 3 Flag
+  *     @arg TIM_FLAG_CC4: TIM Capture Compare 4 Flag
+  *     @arg TIM_FLAG_COM: TIM Commutation Flag
+  *     @arg TIM_FLAG_Trigger: TIM Trigger Flag
+  *     @arg TIM_FLAG_Break: TIM Break Flag
+  *     @arg TIM_FLAG_CC1OF: TIM Capture Compare 1 overcapture Flag
+  *     @arg TIM_FLAG_CC2OF: TIM Capture Compare 2 overcapture Flag
+  *     @arg TIM_FLAG_CC3OF: TIM Capture Compare 3 overcapture Flag
+  *     @arg TIM_FLAG_CC4OF: TIM Capture Compare 4 overcapture Flag
+  * @note
+  *   - TIM6 and TIM7 can have only one update flag. 
+  *   - TIM_FLAG_COM and TIM_FLAG_Break are used only with TIM1 and TIM8.    
+  * @retval The new state of TIM_FLAG (SET or RESET).
+  */
+FlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
+{ 
+  ITStatus bitstatus = RESET;  
+  /* Check the parameters */
+  assert_param(IS_TIM_ALL_PERIPH(TIMx));
+  assert_param(IS_TIM_GET_FLAG(TIM_FLAG));
+  
+  if ((TIMx-&gt;SR &amp; TIM_FLAG) != (uint16_t)RESET)
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  return bitstatus;
+}
+
+/**
+  * @brief  Clears the TIMx's pending flags.
+  * @param  TIMx: where x can be 1 to 8 to select the TIM peripheral.
+  * @param  TIM_FLAG: specifies the flag bit to clear.
+  *   This parameter can be any combination of the following values:
+  *     @arg TIM_FLAG_Update: TIM update Flag
+  *     @arg TIM_FLAG_CC1: TIM Capture Compare 1 Flag
+  *     @arg TIM_FLAG_CC2: TIM Capture Compare 2 Flag
+  *     @arg TIM_FLAG_CC3: TIM Capture Compare 3 Flag
+  *     @arg TIM_FLAG_CC4: TIM Capture Compare 4 Flag
+  *     @arg TIM_FLAG_COM: TIM Commutation Flag
+  *     @arg TIM_FLAG_Trigger: TIM Trigger Flag
+  *     @arg TIM_FLAG_Break: TIM Break Flag
+  *     @arg TIM_FLAG_CC1OF: TIM Capture Compare 1 overcapture Flag
+  *     @arg TIM_FLAG_CC2OF: TIM Capture Compare 2 overcapture Flag
+  *     @arg TIM_FLAG_CC3OF: TIM Capture Compare 3 overcapture Flag
+  *     @arg TIM_FLAG_CC4OF: TIM Capture Compare 4 overcapture Flag
+  * @note
+  *   - TIM6 and TIM7 can have only one update flag. 
+  *   - TIM_FLAG_COM and TIM_FLAG_Break are used only with TIM1 and TIM8.  
+  * @retval None
+  */
+void TIM_ClearFlag(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
+{  
+  /* Check the parameters */
+  assert_param(IS_TIM_ALL_PERIPH(TIMx));
+  assert_param(IS_TIM_CLEAR_FLAG(TIM_FLAG));
+   
+  /* Clear the flags */
+  TIMx-&gt;SR = (uint16_t)~TIM_FLAG;
+}
+
+/**
+  * @brief  Checks whether the TIM interrupt has occurred or not.
+  * @param  TIMx: where x can be 1 to 8 to select the TIM peripheral.
+  * @param  TIM_IT: specifies the TIM interrupt source to check.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_IT_Update: TIM update Interrupt source
+  *     @arg TIM_IT_CC1: TIM Capture Compare 1 Interrupt source
+  *     @arg TIM_IT_CC2: TIM Capture Compare 2 Interrupt source
+  *     @arg TIM_IT_CC3: TIM Capture Compare 3 Interrupt source
+  *     @arg TIM_IT_CC4: TIM Capture Compare 4 Interrupt source
+  *     @arg TIM_IT_COM: TIM Commutation Interrupt source
+  *     @arg TIM_IT_Trigger: TIM Trigger Interrupt source
+  *     @arg TIM_IT_Break: TIM Break Interrupt source
+  * @note
+  *   - TIM6 and TIM7 can generate only an update interrupt.
+  *   - TIM_IT_COM and TIM_IT_Break are used only with TIM1 and TIM8.  
+  * @retval The new state of the TIM_IT(SET or RESET).
+  */
+ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, uint16_t TIM_IT)
+{
+  ITStatus bitstatus = RESET;  
+  uint16_t itstatus = 0x0, itenable = 0x0;
+  /* Check the parameters */
+  assert_param(IS_TIM_ALL_PERIPH(TIMx));
+  assert_param(IS_TIM_GET_IT(TIM_IT));
+   
+  itstatus = TIMx-&gt;SR &amp; TIM_IT;
+  
+  itenable = TIMx-&gt;DIER &amp; TIM_IT;
+  if ((itstatus != (uint16_t)RESET) &amp;&amp; (itenable != (uint16_t)RESET))
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  return bitstatus;
+}
+
+/**
+  * @brief  Clears the TIMx's interrupt pending bits.
+  * @param  TIMx: where x can be 1 to 8 to select the TIM peripheral.
+  * @param  TIM_IT: specifies the pending bit to clear.
+  *   This parameter can be any combination of the following values:
+  *     @arg TIM_IT_Update: TIM1 update Interrupt source
+  *     @arg TIM_IT_CC1: TIM Capture Compare 1 Interrupt source
+  *     @arg TIM_IT_CC2: TIM Capture Compare 2 Interrupt source
+  *     @arg TIM_IT_CC3: TIM Capture Compare 3 Interrupt source
+  *     @arg TIM_IT_CC4: TIM Capture Compare 4 Interrupt source
+  *     @arg TIM_IT_COM: TIM Commutation Interrupt source
+  *     @arg TIM_IT_Trigger: TIM Trigger Interrupt source
+  *     @arg TIM_IT_Break: TIM Break Interrupt source
+  * @note
+  *   - TIM6 and TIM7 can generate only an update interrupt.
+  *   - TIM_IT_COM and TIM_IT_Break are used only with TIM1 and TIM8.    
+  * @retval None
+  */
+void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_ALL_PERIPH(TIMx));
+  assert_param(IS_TIM_IT(TIM_IT));
+  /* Clear the IT pending Bit */
+  TIMx-&gt;SR = (uint16_t)~TIM_IT;
+}
+
+/**
+  * @brief  Configure the TI1 as Input.
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_ICPolarity : The Input Polarity.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_ICPolarity_Rising
+  *     @arg TIM_ICPolarity_Falling
+  * @param  TIM_ICSelection: specifies the input to be used.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_ICSelection_DirectTI: TIM Input 1 is selected to be connected to IC1.
+  *     @arg TIM_ICSelection_IndirectTI: TIM Input 1 is selected to be connected to IC2.
+  *     @arg TIM_ICSelection_TRC: TIM Input 1 is selected to be connected to TRC.
+  * @param  TIM_ICFilter: Specifies the Input Capture Filter.
+  *   This parameter must be a value between 0x00 and 0x0F.
+  * @retval None
+  */
+static void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
+                       uint16_t TIM_ICFilter)
+{
+  uint16_t tmpccmr1 = 0, tmpccer = 0;
+  /* Disable the Channel 1: Reset the CC1E Bit */
+  TIMx-&gt;CCER &amp;= CCER_CC1E_Reset;
+  tmpccmr1 = TIMx-&gt;CCMR1;
+  tmpccer = TIMx-&gt;CCER;
+  /* Select the Input and set the filter */
+  tmpccmr1 &amp;= CCMR_CC13S_Mask &amp; CCMR_IC13F_Mask;
+  tmpccmr1 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter &lt;&lt; (uint16_t)4));
+  /* Select the Polarity and set the CC1E Bit */
+  tmpccer &amp;= CCER_CC1P_Reset;
+  tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)CCER_CC1E_Set);
+  /* Write to TIMx CCMR1 and CCER registers */
+  TIMx-&gt;CCMR1 = tmpccmr1;
+  TIMx-&gt;CCER = tmpccer;
+}
+
+/**
+  * @brief  Configure the TI2 as Input.
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_ICPolarity : The Input Polarity.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_ICPolarity_Rising
+  *     @arg TIM_ICPolarity_Falling
+  * @param  TIM_ICSelection: specifies the input to be used.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_ICSelection_DirectTI: TIM Input 2 is selected to be connected to IC2.
+  *     @arg TIM_ICSelection_IndirectTI: TIM Input 2 is selected to be connected to IC1.
+  *     @arg TIM_ICSelection_TRC: TIM Input 2 is selected to be connected to TRC.
+  * @param  TIM_ICFilter: Specifies the Input Capture Filter.
+  *   This parameter must be a value between 0x00 and 0x0F.
+  * @retval None
+  */
+static void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
+                       uint16_t TIM_ICFilter)
+{
+  uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;
+  /* Disable the Channel 2: Reset the CC2E Bit */
+  TIMx-&gt;CCER &amp;= CCER_CC2E_Reset;
+  tmpccmr1 = TIMx-&gt;CCMR1;
+  tmpccer = TIMx-&gt;CCER;
+  tmp = (uint16_t)(TIM_ICPolarity &lt;&lt; 4);
+  /* Select the Input and set the filter */
+  tmpccmr1 &amp;= CCMR_CC24S_Mask &amp; CCMR_IC24F_Mask;
+  tmpccmr1 |= (uint16_t)(TIM_ICFilter &lt;&lt; 12);
+  tmpccmr1 |= (uint16_t)(TIM_ICSelection &lt;&lt; 8);
+  /* Select the Polarity and set the CC2E Bit */
+  tmpccer &amp;= CCER_CC2P_Reset;
+  tmpccer |=  (uint16_t)(tmp | (uint16_t)CCER_CC2E_Set);
+  /* Write to TIMx CCMR1 and CCER registers */
+  TIMx-&gt;CCMR1 = tmpccmr1 ;
+  TIMx-&gt;CCER = tmpccer;
+}
+
+/**
+  * @brief  Configure the TI3 as Input.
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_ICPolarity : The Input Polarity.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_ICPolarity_Rising
+  *     @arg TIM_ICPolarity_Falling
+  * @param  TIM_ICSelection: specifies the input to be used.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_ICSelection_DirectTI: TIM Input 3 is selected to be connected to IC3.
+  *     @arg TIM_ICSelection_IndirectTI: TIM Input 3 is selected to be connected to IC4.
+  *     @arg TIM_ICSelection_TRC: TIM Input 3 is selected to be connected to TRC.
+  * @param  TIM_ICFilter: Specifies the Input Capture Filter.
+  *   This parameter must be a value between 0x00 and 0x0F.
+  * @retval None
+  */
+static void TI3_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
+                       uint16_t TIM_ICFilter)
+{
+  uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
+  /* Disable the Channel 3: Reset the CC3E Bit */
+  TIMx-&gt;CCER &amp;= CCER_CC3E_Reset;
+  tmpccmr2 = TIMx-&gt;CCMR2;
+  tmpccer = TIMx-&gt;CCER;
+  tmp = (uint16_t)(TIM_ICPolarity &lt;&lt; 8);
+  /* Select the Input and set the filter */
+  tmpccmr2 &amp;= CCMR_CC13S_Mask &amp; CCMR_IC13F_Mask;
+  tmpccmr2 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter &lt;&lt; (uint16_t)4));
+  /* Select the Polarity and set the CC3E Bit */
+  tmpccer &amp;= CCER_CC3P_Reset;
+  tmpccer |= (uint16_t)(tmp | (uint16_t)CCER_CC3E_Set);
+  /* Write to TIMx CCMR2 and CCER registers */
+  TIMx-&gt;CCMR2 = tmpccmr2;
+  TIMx-&gt;CCER = tmpccer;
+}
+
+/**
+  * @brief  Configure the TI1 as Input.
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_ICPolarity : The Input Polarity.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_ICPolarity_Rising
+  *     @arg TIM_ICPolarity_Falling
+  * @param  TIM_ICSelection: specifies the input to be used.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_ICSelection_DirectTI: TIM Input 4 is selected to be connected to IC4.
+  *     @arg TIM_ICSelection_IndirectTI: TIM Input 4 is selected to be connected to IC3.
+  *     @arg TIM_ICSelection_TRC: TIM Input 4 is selected to be connected to TRC.
+  * @param  TIM_ICFilter: Specifies the Input Capture Filter.
+  *   This parameter must be a value between 0x00 and 0x0F.
+  * @retval None
+  */
+static void TI4_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
+                       uint16_t TIM_ICFilter)
+{
+  uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
+
+  /* Disable the Channel 4: Reset the CC4E Bit */
+  TIMx-&gt;CCER &amp;= CCER_CC4E_Reset;
+  tmpccmr2 = TIMx-&gt;CCMR2;
+  tmpccer = TIMx-&gt;CCER;
+  tmp = (uint16_t)(TIM_ICPolarity &lt;&lt; 12);
+
+  /* Select the Input and set the filter */
+  tmpccmr2 &amp;= CCMR_CC24S_Mask &amp; CCMR_IC24F_Mask;
+  tmpccmr2 |= (uint16_t)(TIM_ICSelection &lt;&lt; 8);
+  tmpccmr2 |= (uint16_t)(TIM_ICFilter &lt;&lt; 12);
+
+  /* Select the Polarity and set the CC4E Bit */
+  tmpccer &amp;= CCER_CC4P_Reset;
+  tmpccer |= (uint16_t)(tmp | (uint16_t)CCER_CC4E_Set);
+  /* Write to TIMx CCMR2 and CCER registers */
+  TIMx-&gt;CCMR2 = tmpccmr2;
+  TIMx-&gt;CCER = tmpccer ;
+}
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2009 STMicroelectronics *****END OF FILE****/

Added: trunk/src/platform/stm32/FWLib/library/src/stm32f10x_tim.o
===================================================================
--- trunk/src/platform/stm32/FWLib/library/src/stm32f10x_tim.o	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/src/stm32f10x_tim.o	2009-07-08 23:39:34 UTC (rev 354)
@@ -0,0 +1,43 @@
+ELF
+&#137;C&#234;J&#136;&#155;&#178;C&#234;&#250;&#131;&#252;&#203;&#136;&#136;&#135;K&#152;B&#208;&#245;
+&#137;C&#234;#J&#136;&#155;&#178;C&#234;#&#250;&#131;&#252;&#203;&#136;&#136;&#131;&#135;K&#152;B&#208;&#245;
+F&#159;&#178;&#131;&#136;&#136;&#153;&#178;&#131;&#139;&#137;&#250;&#131;&#252;&#211;&#136;V&#136;&#160;&#248;@0K&#152;B&#208;&#245;
+&#136;K&#136;C&#138;&#136;C&#202;&#136;C
+&#137;CJ&#137;C&#138;&#137;C&#155;&#178;&#160;&#248;D0pG
+C&#160;&#248;H pG&quot;&#177;&#131;&#137;&#155;&#178;A&#234;&#224;&#131;&#137;&#155;&#178;#&#234;&#131;&#129;pG&#137;#&#240;&#129;pG
+CB&#234;&quot;&#146;&#178;&#129;&#189;&#181;F&#255;&#247;&#254;&#255;#&#137;&#155;&#178;C&#244;&#128;C#&#129;&#189;&#181;F&#255;&#247;&#254;&#255;#&#137;#&#240;wC&#240;w#&#129;&#189;
+M	
t.TIM_ClearFlag
l

+
+
+

+
FastConfig
+&#210;
+&#210;
+&#215;
+&#181;
+&#178;
+&#215;
+&#178;
+
+&#181;
+
+&#181;
+
+&#178;
+
+&#178;
+
+&#181;
+
+
+
+
+
+
+
+
+
+
+
+
+
\ No newline at end of file

Modified: trunk/src/platform/stm32/FWLib/library/src/stm32f10x_usart.c
===================================================================
--- trunk/src/platform/stm32/FWLib/library/src/stm32f10x_usart.c	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/src/stm32f10x_usart.c	2009-07-08 23:39:34 UTC (rev 354)
@@ -1,1001 +1,967 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_usart.c
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file provides all the USART firmware functions.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
-
-/* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_usart.h&quot;
-#include &quot;stm32f10x_rcc.h&quot;
-
-/* Private typedef -----------------------------------------------------------*/
-/* Private define ------------------------------------------------------------*/
-/* USART UE Mask */
-#define CR1_UE_Set                ((u16)0x2000)  /* USART Enable Mask */
-#define CR1_UE_Reset              ((u16)0xDFFF)  /* USART Disable Mask */
-
-/* USART WakeUp Method  */
-#define CR1_WAKE_Mask             ((u16)0xF7FF)  /* USART WakeUp Method Mask */
-
-/* USART RWU Mask */
-#define CR1_RWU_Set               ((u16)0x0002)  /* USART mute mode Enable Mask */
-#define CR1_RWU_Reset             ((u16)0xFFFD)  /* USART mute mode Enable Mask */
-
-#define CR1_SBK_Set               ((u16)0x0001)  /* USART Break Character send Mask */
-
-#define CR1_CLEAR_Mask            ((u16)0xE9F3)  /* USART CR1 Mask */
-
-#define CR2_Address_Mask          ((u16)0xFFF0)  /* USART address Mask */
-
-/* USART LIN Mask */
-#define CR2_LINEN_Set              ((u16)0x4000)  /* USART LIN Enable Mask */
-#define CR2_LINEN_Reset            ((u16)0xBFFF)  /* USART LIN Disable Mask */
-
-/* USART LIN Break detection */
-#define CR2_LBDL_Mask             ((u16)0xFFDF)  /* USART LIN Break detection Mask */
-
-#define CR2_STOP_CLEAR_Mask       ((u16)0xCFFF)  /* USART CR2 STOP Bits Mask */
-#define CR2_CLOCK_CLEAR_Mask      ((u16)0xF0FF)  /* USART CR2 Clock Mask */
-
-/* USART SC Mask */
-#define CR3_SCEN_Set              ((u16)0x0020)  /* USART SC Enable Mask */
-#define CR3_SCEN_Reset            ((u16)0xFFDF)  /* USART SC Disable Mask */
-
-/* USART SC NACK Mask */
-#define CR3_NACK_Set              ((u16)0x0010)  /* USART SC NACK Enable Mask */
-#define CR3_NACK_Reset            ((u16)0xFFEF)  /* USART SC NACK Disable Mask */
-
-/* USART Half-Duplex Mask */
-#define CR3_HDSEL_Set             ((u16)0x0008)  /* USART Half-Duplex Enable Mask */
-#define CR3_HDSEL_Reset           ((u16)0xFFF7)  /* USART Half-Duplex Disable Mask */
-
-/* USART IrDA Mask */
-#define CR3_IRLP_Mask             ((u16)0xFFFB)  /* USART IrDA LowPower mode Mask */
-
-#define CR3_CLEAR_Mask            ((u16)0xFCFF)  /* USART CR3 Mask */
-
-/* USART IrDA Mask */
-#define CR3_IREN_Set              ((u16)0x0002)  /* USART IrDA Enable Mask */
-#define CR3_IREN_Reset            ((u16)0xFFFD)  /* USART IrDA Disable Mask */
-
-#define GTPR_LSB_Mask             ((u16)0x00FF)  /* Guard Time Register LSB Mask */
-#define GTPR_MSB_Mask             ((u16)0xFF00)  /* Guard Time Register MSB Mask */
-
-#define IT_Mask                   ((u16)0x001F)  /* USART Interrupt Mask */
-
-/* Private macro -------------------------------------------------------------*/
-/* Private variables ---------------------------------------------------------*/
-/* Private function prototypes -----------------------------------------------*/
-/* Private functions ---------------------------------------------------------*/
-
-/*******************************************************************************
-* Function Name  : USART_DeInit
-* Description    : Deinitializes the USARTx peripheral registers to their
-*                  default reset values.
-* Input          : - USARTx: Select the USART or the UART peripheral. 
-*                    This parameter can be one of the following values:
-*                     - USART1, USART2, USART3, UART4 or UART5.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void USART_DeInit(USART_TypeDef* USARTx)
-{
-  /* Check the parameters */
-  assert_param(IS_USART_ALL_PERIPH(USARTx));
-
-  switch (*(u32*)&amp;USARTx)
-  {
-    case USART1_BASE:
-      RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
-      RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
-      break;
-
-    case USART2_BASE:
-      RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, ENABLE);
-      RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);
-      break;
-
-    case USART3_BASE:
-      RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, ENABLE);
-      RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);
-      break;
-    
-    case UART4_BASE:
-      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, ENABLE);
-      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, DISABLE);
-      break;
-    
-    case UART5_BASE:
-      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
-      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
-      break;            
-
-    default:
-      break;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : USART_Init
-* Description    : Initializes the USARTx peripheral according to the specified
-*                  parameters in the USART_InitStruct .
-* Input          : - USARTx: Select the USART or the UART peripheral. 
-*                    This parameter can be one of the following values:
-*                     - USART1, USART2, USART3, UART4 or UART5.
-*                  - USART_InitStruct: pointer to a USART_InitTypeDef structure
-*                    that contains the configuration information for the
-*                    specified USART peripheral.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
-{
-  u32 tmpreg = 0x00, apbclock = 0x00;
-  u32 integerdivider = 0x00;
-  u32 fractionaldivider = 0x00;
-  u32 usartxbase = 0;
-  RCC_ClocksTypeDef RCC_ClocksStatus;
-
-  /* Check the parameters */
-  assert_param(IS_USART_ALL_PERIPH(USARTx));
-  assert_param(IS_USART_BAUDRATE(USART_InitStruct-&gt;USART_BaudRate));  
-  assert_param(IS_USART_WORD_LENGTH(USART_InitStruct-&gt;USART_WordLength));
-  assert_param(IS_USART_STOPBITS(USART_InitStruct-&gt;USART_StopBits));
-  assert_param(IS_USART_PARITY(USART_InitStruct-&gt;USART_Parity));
-  assert_param(IS_USART_MODE(USART_InitStruct-&gt;USART_Mode));
-  assert_param(IS_USART_HARDWARE_FLOW_CONTROL(USART_InitStruct-&gt;USART_HardwareFlowControl));
-  /* The hardware flow control is available only for USART1, USART2 and USART3 */          
-  assert_param(IS_USART_PERIPH_HFC(USARTx, USART_InitStruct-&gt;USART_HardwareFlowControl));
-  
-  usartxbase = (*(u32*)&amp;USARTx);
-
-/*---------------------------- USART CR2 Configuration -----------------------*/
-  tmpreg = USARTx-&gt;CR2;
-  /* Clear STOP[13:12] bits */
-  tmpreg &amp;= CR2_STOP_CLEAR_Mask;
-
-  /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit ------------*/
-  /* Set STOP[13:12] bits according to USART_StopBits value */
-  tmpreg |= (u32)USART_InitStruct-&gt;USART_StopBits;
-  
-  /* Write to USART CR2 */
-  USARTx-&gt;CR2 = (u16)tmpreg;
-
-/*---------------------------- USART CR1 Configuration -----------------------*/
-  tmpreg = USARTx-&gt;CR1;
-  /* Clear M, PCE, PS, TE and RE bits */
-  tmpreg &amp;= CR1_CLEAR_Mask;
-
-  /* Configure the USART Word Length, Parity and mode ----------------------- */
-  /* Set the M bits according to USART_WordLength value */
-  /* Set PCE and PS bits according to USART_Parity value */
-  /* Set TE and RE bits according to USART_Mode value */
-  tmpreg |= (u32)USART_InitStruct-&gt;USART_WordLength | USART_InitStruct-&gt;USART_Parity |
-            USART_InitStruct-&gt;USART_Mode;
-
-  /* Write to USART CR1 */
-  USARTx-&gt;CR1 = (u16)tmpreg;
-
-/*---------------------------- USART CR3 Configuration -----------------------*/  
-  tmpreg = USARTx-&gt;CR3;
-  /* Clear CTSE and RTSE bits */
-  tmpreg &amp;= CR3_CLEAR_Mask;
-
-  /* Configure the USART HFC -------------------------------------------------*/
-  /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
-  tmpreg |= USART_InitStruct-&gt;USART_HardwareFlowControl;
-
-  /* Write to USART CR3 */
-  USARTx-&gt;CR3 = (u16)tmpreg;
-
-/*---------------------------- USART BRR Configuration -----------------------*/
-  /* Configure the USART Baud Rate -------------------------------------------*/
-  RCC_GetClocksFreq(&amp;RCC_ClocksStatus);
-  if (usartxbase == USART1_BASE)
-  {
-    apbclock = RCC_ClocksStatus.PCLK2_Frequency;
-  }
-  else
-  {
-    apbclock = RCC_ClocksStatus.PCLK1_Frequency;
-  }
-
-  /* Determine the integer part */
-  integerdivider = ((0x19 * apbclock) / (0x04 * (USART_InitStruct-&gt;USART_BaudRate)));
-  tmpreg = (integerdivider / 0x64) &lt;&lt; 0x04;
-
-  /* Determine the fractional part */
-  fractionaldivider = integerdivider - (0x64 * (tmpreg &gt;&gt; 0x04));
-  tmpreg |= ((((fractionaldivider * 0x10) + 0x32) / 0x64)) &amp; ((u8)0x0F);
-
-  /* Write to USART BRR */
-  USARTx-&gt;BRR = (u16)tmpreg;
-}
-
-/*******************************************************************************
-* Function Name  : USART_StructInit
-* Description    : Fills each USART_InitStruct member with its default value.
-* Input          : - USART_InitStruct: pointer to a USART_InitTypeDef structure
-*                    which will be initialized.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
-{
-  /* USART_InitStruct members default value */
-  USART_InitStruct-&gt;USART_BaudRate = 9600;
-  USART_InitStruct-&gt;USART_WordLength = USART_WordLength_8b;
-  USART_InitStruct-&gt;USART_StopBits = USART_StopBits_1;
-  USART_InitStruct-&gt;USART_Parity = USART_Parity_No ;
-  USART_InitStruct-&gt;USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
-  USART_InitStruct-&gt;USART_HardwareFlowControl = USART_HardwareFlowControl_None;  
-}
-
-/*******************************************************************************
-* Function Name  : USART_ClockInit
-* Description    : Initializes the USARTx peripheral Clock according to the 
-*                  specified parameters in the USART_ClockInitStruct .
-* Input          : - USARTx: where x can be 1, 2, 3 to select the USART peripheral.
-*                    Note: The Smart Card mode is not available for UART4 and UART5.
-*                  - USART_ClockInitStruct: pointer to a USART_ClockInitTypeDef
-*                    structure that contains the configuration information for 
-*                    the specified USART peripheral.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct)
-{
-  u32 tmpreg = 0x00;
-
-  /* Check the parameters */
-  assert_param(IS_USART_123_PERIPH(USARTx));
-  assert_param(IS_USART_CLOCK(USART_ClockInitStruct-&gt;USART_Clock));
-  assert_param(IS_USART_CPOL(USART_ClockInitStruct-&gt;USART_CPOL));
-  assert_param(IS_USART_CPHA(USART_ClockInitStruct-&gt;USART_CPHA));
-  assert_param(IS_USART_LASTBIT(USART_ClockInitStruct-&gt;USART_LastBit));              
-  
-/*---------------------------- USART CR2 Configuration -----------------------*/
-  tmpreg = USARTx-&gt;CR2;
-  /* Clear CLKEN, CPOL, CPHA and LBCL bits */
-  tmpreg &amp;= CR2_CLOCK_CLEAR_Mask;
-
-  /* Configure the USART Clock, CPOL, CPHA and LastBit ------------*/
-  /* Set CLKEN bit according to USART_Clock value */
-  /* Set CPOL bit according to USART_CPOL value */
-  /* Set CPHA bit according to USART_CPHA value */
-  /* Set LBCL bit according to USART_LastBit value */
-  tmpreg |= (u32)USART_ClockInitStruct-&gt;USART_Clock | USART_ClockInitStruct-&gt;USART_CPOL | 
-                 USART_ClockInitStruct-&gt;USART_CPHA | USART_ClockInitStruct-&gt;USART_LastBit;
-
-  /* Write to USART CR2 */
-  USARTx-&gt;CR2 = (u16)tmpreg;
-}
-
-/*******************************************************************************
-* Function Name  : USART_ClockStructInit
-* Description    : Fills each USART_ClockInitStruct member with its default value.
-* Input          : - USART_ClockInitStruct: pointer to a USART_ClockInitTypeDef
-*                    structure which will be initialized.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct)
-{
-  /* USART_ClockInitStruct members default value */
-  USART_ClockInitStruct-&gt;USART_Clock = USART_Clock_Disable;
-  USART_ClockInitStruct-&gt;USART_CPOL = USART_CPOL_Low;
-  USART_ClockInitStruct-&gt;USART_CPHA = USART_CPHA_1Edge;
-  USART_ClockInitStruct-&gt;USART_LastBit = USART_LastBit_Disable;
-}
-
-/*******************************************************************************
-* Function Name  : USART_Cmd
-* Description    : Enables or disables the specified USART peripheral.
-* Input          : - USARTx: Select the USART or the UART peripheral. 
-*                    This parameter can be one of the following values:
-*                     - USART1, USART2, USART3, UART4 or UART5.
-*                : - NewState: new state of the USARTx peripheral.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_USART_ALL_PERIPH(USARTx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected USART by setting the UE bit in the CR1 register */
-    USARTx-&gt;CR1 |= CR1_UE_Set;
-  }
-  else
-  {
-    /* Disable the selected USART by clearing the UE bit in the CR1 register */
-    USARTx-&gt;CR1 &amp;= CR1_UE_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : USART_ITConfig
-* Description    : Enables or disables the specified USART interrupts.
-* Input          : - USARTx: Select the USART or the UART peripheral. 
-*                    This parameter can be one of the following values:
-*                     - USART1, USART2, USART3, UART4 or UART5.
-*                  - USART_IT: specifies the USART interrupt sources to be
-*                    enabled or disabled.
-*                    This parameter can be one of the following values:
-*                       - USART_IT_CTS:  CTS change interrupt (not available for
-*                                        UART4 and UART5)
-*                       - USART_IT_LBD:  LIN Break detection interrupt
-*                       - USART_IT_TXE:  Tansmit Data Register empty interrupt
-*                       - USART_IT_TC:   Transmission complete interrupt
-*                       - USART_IT_RXNE: Receive Data register not empty 
-*                                        interrupt
-*                       - USART_IT_IDLE: Idle line detection interrupt
-*                       - USART_IT_PE:   Parity Error interrupt
-*                       - USART_IT_ERR:  Error interrupt(Frame error, noise
-*                                        error, overrun error)
-*                  - NewState: new state of the specified USARTx interrupts.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void USART_ITConfig(USART_TypeDef* USARTx, u16 USART_IT, FunctionalState NewState)
-{
-  u32 usartreg = 0x00, itpos = 0x00, itmask = 0x00;
-  u32 usartxbase = 0x00;
-
-  /* Check the parameters */
-  assert_param(IS_USART_ALL_PERIPH(USARTx));
-  assert_param(IS_USART_CONFIG_IT(USART_IT));
-  assert_param(IS_USART_PERIPH_IT(USARTx, USART_IT)); /* The CTS interrupt is not available for UART4 and UART5 */     
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  usartxbase = (*(u32*)&amp;(USARTx));
-
-  /* Get the USART register index */
-  usartreg = (((u8)USART_IT) &gt;&gt; 0x05);
-
-  /* Get the interrupt position */
-  itpos = USART_IT &amp; IT_Mask;
-
-  itmask = (((u32)0x01) &lt;&lt; itpos);
-    
-  if (usartreg == 0x01) /* The IT is in CR1 register */
-  {
-    usartxbase += 0x0C;
-  }
-  else if (usartreg == 0x02) /* The IT is in CR2 register */
-  {
-    usartxbase += 0x10;
-  }
-  else /* The IT is in CR3 register */
-  {
-    usartxbase += 0x14; 
-  }
-  if (NewState != DISABLE)
-  {
-    *(vu32*)usartxbase  |= itmask;
-  }
-  else
-  {
-    *(vu32*)usartxbase &amp;= ~itmask;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : USART_DMACmd
-* Description    : Enables or disables the USART's DMA interface.
-* Input          : - USARTx: Select the USART or the UART peripheral. 
-*                    This parameter can be one of the following values:
-*                     - USART1, USART2, USART3 or UART4.
-*                    Note: The DMA mode is not available for UART5.
-*                  - USART_DMAReq: specifies the DMA request.
-*                    This parameter can be any combination of the following values:
-*                       - USART_DMAReq_Tx: USART DMA transmit request
-*                       - USART_DMAReq_Rx: USART DMA receive request
-*                  - NewState: new state of the DMA Request sources.
-*                   This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void USART_DMACmd(USART_TypeDef* USARTx, u16 USART_DMAReq, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_USART_1234_PERIPH(USARTx));
-  assert_param(IS_USART_DMAREQ(USART_DMAReq));  
-  assert_param(IS_FUNCTIONAL_STATE(NewState)); 
-
-  if (NewState != DISABLE)
-  {
-    /* Enable the DMA transfer for selected requests by setting the DMAT and/or
-       DMAR bits in the USART CR3 register */
-    USARTx-&gt;CR3 |= USART_DMAReq;
-  }
-  else
-  {
-    /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
-       DMAR bits in the USART CR3 register */
-    USARTx-&gt;CR3 &amp;= (u16)~USART_DMAReq;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : USART_SetAddress
-* Description    : Sets the address of the USART node.
-* Input          : - USARTx: Select the USART or the UART peripheral. 
-*                    This parameter can be one of the following values:
-*                     - USART1, USART2, USART3, UART4 or UART5.
-*                  - USART_Address: Indicates the address of the USART node.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void USART_SetAddress(USART_TypeDef* USARTx, u8 USART_Address)
-{
-  /* Check the parameters */
-  assert_param(IS_USART_ALL_PERIPH(USARTx));
-  assert_param(IS_USART_ADDRESS(USART_Address)); 
-    
-  /* Clear the USART address */
-  USARTx-&gt;CR2 &amp;= CR2_Address_Mask;
-  /* Set the USART address node */
-  USARTx-&gt;CR2 |= USART_Address;
-}
-
-/*******************************************************************************
-* Function Name  : USART_WakeUpConfig
-* Description    : Selects the USART WakeUp method.
-* Input          : - USARTx: Select the USART or the UART peripheral. 
-*                    This parameter can be one of the following values:
-*                     - USART1, USART2, USART3, UART4 or UART5.
-*                  - USART_WakeUp: specifies the USART wakeup method.
-*                    This parameter can be one of the following values:
-*                        - USART_WakeUp_IdleLine: WakeUp by an idle line detection
-*                        - USART_WakeUp_AddressMark: WakeUp by an address mark
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void USART_WakeUpConfig(USART_TypeDef* USARTx, u16 USART_WakeUp)
-{
-  /* Check the parameters */
-  assert_param(IS_USART_ALL_PERIPH(USARTx));
-  assert_param(IS_USART_WAKEUP(USART_WakeUp));
-  
-  USARTx-&gt;CR1 &amp;= CR1_WAKE_Mask;
-  USARTx-&gt;CR1 |= USART_WakeUp;
-}
-
-/*******************************************************************************
-* Function Name  : USART_ReceiverWakeUpCmd
-* Description    : Determines if the USART is in mute mode or not.
-* Input          : - USARTx: Select the USART or the UART peripheral. 
-*                    This parameter can be one of the following values:
-*                     - USART1, USART2, USART3, UART4 or UART5.
-*                  - NewState: new state of the USART mute mode.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void USART_ReceiverWakeUpCmd(USART_TypeDef* USARTx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_USART_ALL_PERIPH(USARTx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState)); 
-  
-  if (NewState != DISABLE)
-  {
-    /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
-    USARTx-&gt;CR1 |= CR1_RWU_Set;
-  }
-  else
-  {
-    /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
-    USARTx-&gt;CR1 &amp;= CR1_RWU_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : USART_LINBreakDetectLengthConfig
-* Description    : Sets the USART LIN Break detection length.
-* Input          : - USARTx: Select the USART or the UART peripheral. 
-*                    This parameter can be one of the following values:
-*                     - USART1, USART2, USART3, UART4 or UART5.
-*                  - USART_LINBreakDetectLength: specifies the LIN break
-*                    detection length.
-*                    This parameter can be one of the following values:
-*                       - USART_LINBreakDetectLength_10b: 10-bit break detection
-*                       - USART_LINBreakDetectLength_11b: 11-bit break detection
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void USART_LINBreakDetectLengthConfig(USART_TypeDef* USARTx, u16 USART_LINBreakDetectLength)
-{
-  /* Check the parameters */
-  assert_param(IS_USART_ALL_PERIPH(USARTx));
-  assert_param(IS_USART_LIN_BREAK_DETECT_LENGTH(USART_LINBreakDetectLength));
-  
-  USARTx-&gt;CR2 &amp;= CR2_LBDL_Mask;
-  USARTx-&gt;CR2 |= USART_LINBreakDetectLength;  
-}
-
-/*******************************************************************************
-* Function Name  : USART_LINCmd
-* Description    : Enables or disables the USART's LIN mode.
-* Input          : - USARTx: Select the USART or the UART peripheral. 
-*                    This parameter can be one of the following values:
-*                     - USART1, USART2, USART3, UART4 or UART5.
-*                  - NewState: new state of the USART LIN mode.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void USART_LINCmd(USART_TypeDef* USARTx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_USART_ALL_PERIPH(USARTx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  
-  if (NewState != DISABLE)
-  {
-    /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
-    USARTx-&gt;CR2 |= CR2_LINEN_Set;
-  }
-  else
-  {
-    /* Disable the LIN mode by clearing the LINEN bit in the CR2 register */
-    USARTx-&gt;CR2 &amp;= CR2_LINEN_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : USART_SendData
-* Description    : Transmits single data through the USARTx peripheral.
-* Input          : - USARTx: Select the USART or the UART peripheral. 
-*                    This parameter can be one of the following values:
-*                     - USART1, USART2, USART3, UART4 or UART5.
-*                  - Data: the data to transmit.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void USART_SendData(USART_TypeDef* USARTx, u16 Data)
-{
-  /* Check the parameters */
-  assert_param(IS_USART_ALL_PERIPH(USARTx));
-  assert_param(IS_USART_DATA(Data)); 
-    
-  /* Transmit Data */
-  USARTx-&gt;DR = (Data &amp; (u16)0x01FF);
-}
-
-/*******************************************************************************
-* Function Name  : USART_ReceiveData
-* Description    : Returns the most recent received data by the USARTx peripheral.
-* Input          : - USARTx: Select the USART or the UART peripheral. 
-*                    This parameter can be one of the following values:
-*                     - USART1, USART2, USART3, UART4 or UART5.
-* Output         : None
-* Return         : The received data.
-*******************************************************************************/
-u16 USART_ReceiveData(USART_TypeDef* USARTx)
-{
-  /* Check the parameters */
-  assert_param(IS_USART_ALL_PERIPH(USARTx));
-  
-  /* Receive Data */
-  return (u16)(USARTx-&gt;DR &amp; (u16)0x01FF);
-}
-
-/*******************************************************************************
-* Function Name  : USART_SendBreak
-* Description    : Transmits break characters.
-* Input          : - USARTx: Select the USART or the UART peripheral. 
-*                    This parameter can be one of the following values:
-*                     - USART1, USART2, USART3, UART4 or UART5.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void USART_SendBreak(USART_TypeDef* USARTx)
-{
-  /* Check the parameters */
-  assert_param(IS_USART_ALL_PERIPH(USARTx));
-  
-  /* Send break characters */
-  USARTx-&gt;CR1 |= CR1_SBK_Set;
-}
-
-/*******************************************************************************
-* Function Name  : USART_SetGuardTime
-* Description    : Sets the specified USART guard time.
-* Input          : - USARTx: where x can be 1, 2 or 3 to select the USART
-*                    peripheral.
-*                  Note: The guard time bits are not available for UART4 and UART5.
-*                  - USART_GuardTime: specifies the guard time.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void USART_SetGuardTime(USART_TypeDef* USARTx, u8 USART_GuardTime)
-{    
-  /* Check the parameters */
-  assert_param(IS_USART_123_PERIPH(USARTx));
-  
-  /* Clear the USART Guard time */
-  USARTx-&gt;GTPR &amp;= GTPR_LSB_Mask;
-  /* Set the USART guard time */
-  USARTx-&gt;GTPR |= (u16)((u16)USART_GuardTime &lt;&lt; 0x08);
-}
-
-/*******************************************************************************
-* Function Name  : USART_SetPrescaler
-* Description    : Sets the system clock prescaler.
-* Input          : - USARTx: Select the USART or the UART peripheral. 
-*                    This parameter can be one of the following values:
-*                     - USART1, USART2, USART3, UART4 or UART5.
-*                  Note: The function is used for IrDA mode with UART4 and UART5.
-*                  - USART_Prescaler: specifies the prescaler clock.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void USART_SetPrescaler(USART_TypeDef* USARTx, u8 USART_Prescaler)
-{ 
-  /* Check the parameters */
-  assert_param(IS_USART_ALL_PERIPH(USARTx));
-  
-  /* Clear the USART prescaler */
-  USARTx-&gt;GTPR &amp;= GTPR_MSB_Mask;
-  /* Set the USART prescaler */
-  USARTx-&gt;GTPR |= USART_Prescaler;
-}
-
-/*******************************************************************************
-* Function Name  : USART_SmartCardCmd
-* Description    : Enables or disables the USART's Smart Card mode.
-* Input          : - USARTx: where x can be 1, 2 or 3 to select the USART
-*                    peripheral. 
-*                    Note: The Smart Card mode is not available for UART4 and UART5.
-*                  - NewState: new state of the Smart Card mode.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_USART_123_PERIPH(USARTx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Enable the SC mode by setting the SCEN bit in the CR3 register */
-    USARTx-&gt;CR3 |= CR3_SCEN_Set;
-  }
-  else
-  {
-    /* Disable the SC mode by clearing the SCEN bit in the CR3 register */
-    USARTx-&gt;CR3 &amp;= CR3_SCEN_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : USART_SmartCardNACKCmd
-* Description    : Enables or disables NACK transmission.
-* Input          : - USARTx: where x can be 1, 2 or 3 to select the USART
-*                    peripheral. 
-*                    Note: The Smart Card mode is not available for UART4 and UART5.
-*                  - NewState: new state of the NACK transmission.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_USART_123_PERIPH(USARTx));  
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Enable the NACK transmission by setting the NACK bit in the CR3 register */
-    USARTx-&gt;CR3 |= CR3_NACK_Set;
-  }
-  else
-  {
-    /* Disable the NACK transmission by clearing the NACK bit in the CR3 register */
-    USARTx-&gt;CR3 &amp;= CR3_NACK_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : USART_HalfDuplexCmd
-* Description    : Enables or disables the USART's Half Duplex communication.
-* Input          : - USARTx: Select the USART or the UART peripheral. 
-*                    This parameter can be one of the following values:
-*                     - USART1, USART2, USART3, UART4 or UART5.
-*                  - NewState: new state of the USART Communication.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void USART_HalfDuplexCmd(USART_TypeDef* USARTx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_USART_ALL_PERIPH(USARTx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  
-  if (NewState != DISABLE)
-  {
-    /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
-    USARTx-&gt;CR3 |= CR3_HDSEL_Set;
-  }
-  else
-  {
-    /* Disable the Half-Duplex mode by clearing the HDSEL bit in the CR3 register */
-    USARTx-&gt;CR3 &amp;= CR3_HDSEL_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : USART_IrDAConfig
-* Description    : Configures the USART's IrDA interface.
-* Input          : - USARTx: Select the USART or the UART peripheral. 
-*                    This parameter can be one of the following values:
-*                     - USART1, USART2, USART3, UART4 or UART5.
-*                  - USART_IrDAMode: specifies the IrDA mode.
-*                    This parameter can be one of the following values:
-*                       - USART_IrDAMode_LowPower
-*                       - USART_IrDAMode_Normal
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void USART_IrDAConfig(USART_TypeDef* USARTx, u16 USART_IrDAMode)
-{
-  /* Check the parameters */
-  assert_param(IS_USART_ALL_PERIPH(USARTx));
-  assert_param(IS_USART_IRDA_MODE(USART_IrDAMode));
-    
-  USARTx-&gt;CR3 &amp;= CR3_IRLP_Mask;
-  USARTx-&gt;CR3 |= USART_IrDAMode;
-}
-
-/*******************************************************************************
-* Function Name  : USART_IrDACmd
-* Description    : Enables or disables the USART's IrDA interface.
-* Input          : - USARTx: Select the USART or the UART peripheral. 
-*                    This parameter can be one of the following values:
-*                     - USART1, USART2, USART3, UART4 or UART5.
-*                  - NewState: new state of the IrDA mode.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void USART_IrDACmd(USART_TypeDef* USARTx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_USART_ALL_PERIPH(USARTx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-    
-  if (NewState != DISABLE)
-  {
-    /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
-    USARTx-&gt;CR3 |= CR3_IREN_Set;
-  }
-  else
-  {
-    /* Disable the IrDA mode by clearing the IREN bit in the CR3 register */
-    USARTx-&gt;CR3 &amp;= CR3_IREN_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : USART_GetFlagStatus
-* Description    : Checks whether the specified USART flag is set or not.
-* Input          : - USARTx: Select the USART or the UART peripheral. 
-*                    This parameter can be one of the following values:
-*                     - USART1, USART2, USART3, UART4 or UART5.
-*                  - USART_FLAG: specifies the flag to check.
-*                    This parameter can be one of the following values:
-*                       - USART_FLAG_CTS:  CTS Change flag (not available for 
-*                                          UART4 and UART5)
-*                       - USART_FLAG_LBD:  LIN Break detection flag
-*                       - USART_FLAG_TXE:  Transmit data register empty flag
-*                       - USART_FLAG_TC:   Transmission Complete flag
-*                       - USART_FLAG_RXNE: Receive data register not empty flag
-*                       - USART_FLAG_IDLE: Idle Line detection flag
-*                       - USART_FLAG_ORE:  OverRun Error flag
-*                       - USART_FLAG_NE:   Noise Error flag
-*                       - USART_FLAG_FE:   Framing Error flag
-*                       - USART_FLAG_PE:   Parity Error flag
-* Output         : None
-* Return         : The new state of USART_FLAG (SET or RESET).
-*******************************************************************************/
-FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, u16 USART_FLAG)
-{
-  FlagStatus bitstatus = RESET;
-
-  /* Check the parameters */
-  assert_param(IS_USART_ALL_PERIPH(USARTx));
-  assert_param(IS_USART_FLAG(USART_FLAG));
-  assert_param(IS_USART_PERIPH_FLAG(USARTx, USART_FLAG)); /* The CTS flag is not available for UART4 and UART5 */   
-
-  if ((USARTx-&gt;SR &amp; USART_FLAG) != (u16)RESET)
-  {
-    bitstatus = SET;
-  }
-  else
-  {
-    bitstatus = RESET;
-  }
-  return bitstatus;
-}
-
-/*******************************************************************************
-* Function Name  : USART_ClearFlag
-* Description    : Clears the USARTx's pending flags.
-* Input          : - USARTx: Select the USART or the UART peripheral. 
-*                    This parameter can be one of the following values:
-*                     - USART1, USART2, USART3, UART4 or UART5.
-*                  - USART_FLAG: specifies the flag to clear.
-*                    This parameter can be any combination of the following values:
-*                       - USART_FLAG_CTS:  CTS Change flag (not available for
-*                                          UART4 and UART5).
-*                       - USART_FLAG_LBD:  LIN Break detection flag.
-*                       - USART_FLAG_TC:   Transmission Complete flag.
-*                       - USART_FLAG_RXNE: Receive data register not empty flag.
-*
-*                  Notes:
-*                        - PE (Parity error), FE (Framing error), NE (Noise error),
-*                          ORE (OverRun error) and IDLE (Idle line detected) 
-*                          flags are cleared by software sequence: a read 
-*                          operation to USART_SR register (USART_GetFlagStatus()) 
-*                          followed by a read operation to USART_DR register 
-*                          (USART_ReceiveData()).
-*                        - RXNE flag can be also cleared by a read to the 
-*                          USART_DR register (USART_ReceiveData()).
-*                        - TC flag can be also cleared by software sequence: a 
-*                          read operation to USART_SR register 
-*                          (USART_GetFlagStatus()) followed by a write operation
-*                          to USART_DR register (USART_SendData()).                                                      
-*                        - TXE flag is cleared only by a write to the USART_DR 
-*                          register (USART_SendData()).                        
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void USART_ClearFlag(USART_TypeDef* USARTx, u16 USART_FLAG)
-{
-  /* Check the parameters */
-  assert_param(IS_USART_ALL_PERIPH(USARTx));
-  assert_param(IS_USART_CLEAR_FLAG(USART_FLAG));
-  assert_param(IS_USART_PERIPH_FLAG(USARTx, USART_FLAG)); /* The CTS flag is not available for UART4 and UART5 */   
-   
-  USARTx-&gt;SR = (u16)~USART_FLAG;
-}
-
-/*******************************************************************************
-* Function Name  : USART_GetITStatus
-* Description    : Checks whether the specified USART interrupt has occurred or not.
-* Input          : - USARTx: Select the USART or the UART peripheral. 
-*                    This parameter can be one of the following values:
-*                     - USART1, USART2, USART3, UART4 or UART5.
-*                  - USART_IT: specifies the USART interrupt source to check.
-*                    This parameter can be one of the following values:
-*                       - USART_IT_CTS:  CTS change interrupt (not available for 
-*                                        UART4 and UART5)
-*                       - USART_IT_LBD:  LIN Break detection interrupt
-*                       - USART_IT_TXE:  Tansmit Data Register empty interrupt
-*                       - USART_IT_TC:   Transmission complete interrupt
-*                       - USART_IT_RXNE: Receive Data register not empty 
-*                                        interrupt
-*                       - USART_IT_IDLE: Idle line detection interrupt
-*                       - USART_IT_ORE:  OverRun Error interrupt
-*                       - USART_IT_NE:   Noise Error interrupt
-*                       - USART_IT_FE:   Framing Error interrupt
-*                       - USART_IT_PE:   Parity Error interrupt
-* Output         : None
-* Return         : The new state of USART_IT (SET or RESET).
-*******************************************************************************/
-ITStatus USART_GetITStatus(USART_TypeDef* USARTx, u16 USART_IT)
-{
-  u32 bitpos = 0x00, itmask = 0x00, usartreg = 0x00;
-  ITStatus bitstatus = RESET;
-
-  /* Check the parameters */
-  assert_param(IS_USART_ALL_PERIPH(USARTx));
-  assert_param(IS_USART_GET_IT(USART_IT));
-  assert_param(IS_USART_PERIPH_IT(USARTx, USART_IT)); /* The CTS interrupt is not available for UART4 and UART5 */  
-  
-  /* Get the USART register index */
-  usartreg = (((u8)USART_IT) &gt;&gt; 0x05);
-
-  /* Get the interrupt position */
-  itmask = USART_IT &amp; IT_Mask;
-
-  itmask = (u32)0x01 &lt;&lt; itmask;
-  
-  if (usartreg == 0x01) /* The IT  is in CR1 register */
-  {
-    itmask &amp;= USARTx-&gt;CR1;
-  }
-  else if (usartreg == 0x02) /* The IT  is in CR2 register */
-  {
-    itmask &amp;= USARTx-&gt;CR2;
-  }
-  else /* The IT  is in CR3 register */
-  {
-    itmask &amp;= USARTx-&gt;CR3;
-  }
-  
-  bitpos = USART_IT &gt;&gt; 0x08;
-
-  bitpos = (u32)0x01 &lt;&lt; bitpos;
-  bitpos &amp;= USARTx-&gt;SR;
-
-  if ((itmask != (u16)RESET)&amp;&amp;(bitpos != (u16)RESET))
-  {
-    bitstatus = SET;
-  }
-  else
-  {
-    bitstatus = RESET;
-  }
-  
-  return bitstatus;  
-}
-
-/*******************************************************************************
-* Function Name  : USART_ClearITPendingBit
-* Description    : Clears the USARTx's interrupt pending bits.
-* Input          : - USARTx: Select the USART or the UART peripheral. 
-*                    This parameter can be one of the following values:
-*                     - USART1, USART2, USART3, UART4 or UART5.
-*                  - USART_IT: specifies the interrupt pending bit to clear.
-*                    This parameter can be one of the following values:
-*                       - USART_IT_CTS:  CTS change interrupt (not available for 
-*                                        UART4 and UART5)
-*                       - USART_IT_LBD:  LIN Break detection interrupt
-*                       - USART_IT_TC:   Transmission complete interrupt. 
-*                       - USART_IT_RXNE: Receive Data register not empty interrupt.
-*                    
-*                  Notes:
-*                        - PE (Parity error), FE (Framing error), NE (Noise error),
-*                          ORE (OverRun error) and IDLE (Idle line detected) 
-*                          pending bits are cleared by software sequence: a read 
-*                          operation to USART_SR register (USART_GetITStatus()) 
-*                          followed by a read operation to USART_DR register 
-*                          (USART_ReceiveData()).
-*                        - RXNE pending bit can be also cleared by a read to the 
-*                          USART_DR register (USART_ReceiveData()).
-*                        - TC pending bit can be also cleared by software 
-*                          sequence: a read operation to USART_SR register 
-*                          (USART_GetITStatus()) followed by a write operation
-*                          to USART_DR register (USART_SendData()).                                                      
-*                        - TXE pending bit is cleared only by a write to the 
-*                          USART_DR register (USART_SendData()).  
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void USART_ClearITPendingBit(USART_TypeDef* USARTx, u16 USART_IT)
-{
-  u16 bitpos = 0x00, itmask = 0x00;
-
-  /* Check the parameters */
-  assert_param(IS_USART_ALL_PERIPH(USARTx));
-  assert_param(IS_USART_CLEAR_IT(USART_IT));
-  assert_param(IS_USART_PERIPH_IT(USARTx, USART_IT)); /* The CTS interrupt is not available for UART4 and UART5 */
-  
-  bitpos = USART_IT &gt;&gt; 0x08;
-
-  itmask = (u16)((u16)0x01 &lt;&lt; bitpos);
-  USARTx-&gt;SR = (u16)~itmask;
-}
-
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
+/**
+  ******************************************************************************
+  * @file    stm32f10x_usart.c
+  * @author  MCD Application Team
+  * @version V3.1.0
+  * @date    06/19/2009
+  * @brief   This file provides all the USART firmware functions.
+  ******************************************************************************
+  * @copy
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * &lt;h2&gt;&lt;center&gt;&copy; COPYRIGHT 2009 STMicroelectronics&lt;/center&gt;&lt;/h2&gt;
+  */ 
+
+/* Includes ------------------------------------------------------------------*/
+#include &quot;stm32f10x_usart.h&quot;
+#include &quot;stm32f10x_rcc.h&quot;
+
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup USART 
+  * @brief USART driver modules
+  * @{
+  */
+
+/** @defgroup USART_Private_TypesDefinitions
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup USART_Private_Defines
+  * @{
+  */
+
+#define CR1_UE_Set                ((uint16_t)0x2000)  /*!&lt; USART Enable Mask */
+#define CR1_UE_Reset              ((uint16_t)0xDFFF)  /*!&lt; USART Disable Mask */
+
+#define CR1_WAKE_Mask             ((uint16_t)0xF7FF)  /*!&lt; USART WakeUp Method Mask */
+
+#define CR1_RWU_Set               ((uint16_t)0x0002)  /*!&lt; USART mute mode Enable Mask */
+#define CR1_RWU_Reset             ((uint16_t)0xFFFD)  /*!&lt; USART mute mode Enable Mask */
+#define CR1_SBK_Set               ((uint16_t)0x0001)  /*!&lt; USART Break Character send Mask */
+#define CR1_CLEAR_Mask            ((uint16_t)0xE9F3)  /*!&lt; USART CR1 Mask */
+#define CR2_Address_Mask          ((uint16_t)0xFFF0)  /*!&lt; USART address Mask */
+
+#define CR2_LINEN_Set              ((uint16_t)0x4000)  /*!&lt; USART LIN Enable Mask */
+#define CR2_LINEN_Reset            ((uint16_t)0xBFFF)  /*!&lt; USART LIN Disable Mask */
+
+#define CR2_LBDL_Mask             ((uint16_t)0xFFDF)  /*!&lt; USART LIN Break detection Mask */
+#define CR2_STOP_CLEAR_Mask       ((uint16_t)0xCFFF)  /*!&lt; USART CR2 STOP Bits Mask */
+#define CR2_CLOCK_CLEAR_Mask      ((uint16_t)0xF0FF)  /*!&lt; USART CR2 Clock Mask */
+
+#define CR3_SCEN_Set              ((uint16_t)0x0020)  /*!&lt; USART SC Enable Mask */
+#define CR3_SCEN_Reset            ((uint16_t)0xFFDF)  /*!&lt; USART SC Disable Mask */
+
+#define CR3_NACK_Set              ((uint16_t)0x0010)  /*!&lt; USART SC NACK Enable Mask */
+#define CR3_NACK_Reset            ((uint16_t)0xFFEF)  /*!&lt; USART SC NACK Disable Mask */
+
+#define CR3_HDSEL_Set             ((uint16_t)0x0008)  /*!&lt; USART Half-Duplex Enable Mask */
+#define CR3_HDSEL_Reset           ((uint16_t)0xFFF7)  /*!&lt; USART Half-Duplex Disable Mask */
+
+#define CR3_IRLP_Mask             ((uint16_t)0xFFFB)  /*!&lt; USART IrDA LowPower mode Mask */
+#define CR3_CLEAR_Mask            ((uint16_t)0xFCFF)  /*!&lt; USART CR3 Mask */
+
+#define CR3_IREN_Set              ((uint16_t)0x0002)  /*!&lt; USART IrDA Enable Mask */
+#define CR3_IREN_Reset            ((uint16_t)0xFFFD)  /*!&lt; USART IrDA Disable Mask */
+#define GTPR_LSB_Mask             ((uint16_t)0x00FF)  /*!&lt; Guard Time Register LSB Mask */
+#define GTPR_MSB_Mask             ((uint16_t)0xFF00)  /*!&lt; Guard Time Register MSB Mask */
+#define IT_Mask                   ((uint16_t)0x001F)  /*!&lt; USART Interrupt Mask */
+
+/**
+  * @}
+  */
+
+/** @defgroup USART_Private_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup USART_Private_Variables
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup USART_Private_FunctionPrototypes
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup USART_Private_Functions
+  * @{
+  */
+
+/**
+  * @brief  Deinitializes the USARTx peripheral registers to their default reset values.
+  * @param  USARTx: Select the USART or the UART peripheral. 
+  *   This parameter can be one of the following values: USART1, USART2, USART3, UART4 or UART5.
+  * @retval None
+  */
+void USART_DeInit(USART_TypeDef* USARTx)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+
+  if (USARTx == USART1)
+  {
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
+  }
+  else if (USARTx == USART2)
+  {
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, ENABLE);
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);
+  }
+  else if (USARTx == USART3)
+  {
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, ENABLE);
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);
+  }    
+  else if (USARTx == UART4)
+  {
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, ENABLE);
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, DISABLE);
+  }    
+  else
+  {
+    if (USARTx == UART5)
+    { 
+      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
+      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
+    }
+  }
+}
+
+/**
+  * @brief  Initializes the USARTx peripheral according to the specified
+  *   parameters in the USART_InitStruct .
+  * @param  USARTx: Select the USART or the UART peripheral. 
+  *   This parameter can be one of the following values:
+  *   USART1, USART2, USART3, UART4 or UART5.
+  * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure
+  *   that contains the configuration information for the specified USART peripheral.
+  * @retval None
+  */
+void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
+{
+  uint32_t tmpreg = 0x00, apbclock = 0x00;
+  uint32_t integerdivider = 0x00;
+  uint32_t fractionaldivider = 0x00;
+  uint32_t usartxbase = 0;
+  RCC_ClocksTypeDef RCC_ClocksStatus;
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  assert_param(IS_USART_BAUDRATE(USART_InitStruct-&gt;USART_BaudRate));  
+  assert_param(IS_USART_WORD_LENGTH(USART_InitStruct-&gt;USART_WordLength));
+  assert_param(IS_USART_STOPBITS(USART_InitStruct-&gt;USART_StopBits));
+  assert_param(IS_USART_PARITY(USART_InitStruct-&gt;USART_Parity));
+  assert_param(IS_USART_MODE(USART_InitStruct-&gt;USART_Mode));
+  assert_param(IS_USART_HARDWARE_FLOW_CONTROL(USART_InitStruct-&gt;USART_HardwareFlowControl));
+  /* The hardware flow control is available only for USART1, USART2 and USART3 */
+  if (USART_InitStruct-&gt;USART_HardwareFlowControl != USART_HardwareFlowControl_None)
+  {
+    assert_param(IS_USART_123_PERIPH(USARTx));
+  }
+
+  usartxbase = (uint32_t)USARTx;
+
+/*---------------------------- USART CR2 Configuration -----------------------*/
+  tmpreg = USARTx-&gt;CR2;
+  /* Clear STOP[13:12] bits */
+  tmpreg &amp;= CR2_STOP_CLEAR_Mask;
+  /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit ------------*/
+  /* Set STOP[13:12] bits according to USART_StopBits value */
+  tmpreg |= (uint32_t)USART_InitStruct-&gt;USART_StopBits;
+  
+  /* Write to USART CR2 */
+  USARTx-&gt;CR2 = (uint16_t)tmpreg;
+
+/*---------------------------- USART CR1 Configuration -----------------------*/
+  tmpreg = USARTx-&gt;CR1;
+  /* Clear M, PCE, PS, TE and RE bits */
+  tmpreg &amp;= CR1_CLEAR_Mask;
+  /* Configure the USART Word Length, Parity and mode ----------------------- */
+  /* Set the M bits according to USART_WordLength value */
+  /* Set PCE and PS bits according to USART_Parity value */
+  /* Set TE and RE bits according to USART_Mode value */
+  tmpreg |= (uint32_t)USART_InitStruct-&gt;USART_WordLength | USART_InitStruct-&gt;USART_Parity |
+            USART_InitStruct-&gt;USART_Mode;
+  /* Write to USART CR1 */
+  USARTx-&gt;CR1 = (uint16_t)tmpreg;
+
+/*---------------------------- USART CR3 Configuration -----------------------*/  
+  tmpreg = USARTx-&gt;CR3;
+  /* Clear CTSE and RTSE bits */
+  tmpreg &amp;= CR3_CLEAR_Mask;
+  /* Configure the USART HFC -------------------------------------------------*/
+  /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
+  tmpreg |= USART_InitStruct-&gt;USART_HardwareFlowControl;
+  /* Write to USART CR3 */
+  USARTx-&gt;CR3 = (uint16_t)tmpreg;
+
+/*---------------------------- USART BRR Configuration -----------------------*/
+  /* Configure the USART Baud Rate -------------------------------------------*/
+  RCC_GetClocksFreq(&amp;RCC_ClocksStatus);
+  if (usartxbase == USART1_BASE)
+  {
+    apbclock = RCC_ClocksStatus.PCLK2_Frequency;
+  }
+  else
+  {
+    apbclock = RCC_ClocksStatus.PCLK1_Frequency;
+  }
+  /* Determine the integer part */
+  integerdivider = ((0x19 * apbclock) / (0x04 * (USART_InitStruct-&gt;USART_BaudRate)));
+  tmpreg = (integerdivider / 0x64) &lt;&lt; 0x04;
+  /* Determine the fractional part */
+  fractionaldivider = integerdivider - (0x64 * (tmpreg &gt;&gt; 0x04));
+  tmpreg |= ((((fractionaldivider * 0x10) + 0x32) / 0x64)) &amp; ((uint8_t)0x0F);
+  /* Write to USART BRR */
+  USARTx-&gt;BRR = (uint16_t)tmpreg;
+}
+
+/**
+  * @brief  Fills each USART_InitStruct member with its default value.
+  * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure
+  *   which will be initialized.
+  * @retval None
+  */
+void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
+{
+  /* USART_InitStruct members default value */
+  USART_InitStruct-&gt;USART_BaudRate = 9600;
+  USART_InitStruct-&gt;USART_WordLength = USART_WordLength_8b;
+  USART_InitStruct-&gt;USART_StopBits = USART_StopBits_1;
+  USART_InitStruct-&gt;USART_Parity = USART_Parity_No ;
+  USART_InitStruct-&gt;USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
+  USART_InitStruct-&gt;USART_HardwareFlowControl = USART_HardwareFlowControl_None;  
+}
+
+/**
+  * @brief  Initializes the USARTx peripheral Clock according to the 
+  *   specified parameters in the USART_ClockInitStruct .
+  * @param  USARTx: where x can be 1, 2, 3 to select the USART peripheral.
+  * @param  USART_ClockInitStruct: pointer to a USART_ClockInitTypeDef
+  *   structure that contains the configuration information for the specified 
+  *   USART peripheral.  
+  * @note The Smart Card mode is not available for UART4 and UART5.
+  * @retval None
+  */
+void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct)
+{
+  uint32_t tmpreg = 0x00;
+  /* Check the parameters */
+  assert_param(IS_USART_123_PERIPH(USARTx));
+  assert_param(IS_USART_CLOCK(USART_ClockInitStruct-&gt;USART_Clock));
+  assert_param(IS_USART_CPOL(USART_ClockInitStruct-&gt;USART_CPOL));
+  assert_param(IS_USART_CPHA(USART_ClockInitStruct-&gt;USART_CPHA));
+  assert_param(IS_USART_LASTBIT(USART_ClockInitStruct-&gt;USART_LastBit));
+  
+/*---------------------------- USART CR2 Configuration -----------------------*/
+  tmpreg = USARTx-&gt;CR2;
+  /* Clear CLKEN, CPOL, CPHA and LBCL bits */
+  tmpreg &amp;= CR2_CLOCK_CLEAR_Mask;
+  /* Configure the USART Clock, CPOL, CPHA and LastBit ------------*/
+  /* Set CLKEN bit according to USART_Clock value */
+  /* Set CPOL bit according to USART_CPOL value */
+  /* Set CPHA bit according to USART_CPHA value */
+  /* Set LBCL bit according to USART_LastBit value */
+  tmpreg |= (uint32_t)USART_ClockInitStruct-&gt;USART_Clock | USART_ClockInitStruct-&gt;USART_CPOL | 
+                 USART_ClockInitStruct-&gt;USART_CPHA | USART_ClockInitStruct-&gt;USART_LastBit;
+  /* Write to USART CR2 */
+  USARTx-&gt;CR2 = (uint16_t)tmpreg;
+}
+
+/**
+  * @brief  Fills each USART_ClockInitStruct member with its default value.
+  * @param  USART_ClockInitStruct: pointer to a USART_ClockInitTypeDef
+  *   structure which will be initialized.
+  * @retval None
+  */
+void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct)
+{
+  /* USART_ClockInitStruct members default value */
+  USART_ClockInitStruct-&gt;USART_Clock = USART_Clock_Disable;
+  USART_ClockInitStruct-&gt;USART_CPOL = USART_CPOL_Low;
+  USART_ClockInitStruct-&gt;USART_CPHA = USART_CPHA_1Edge;
+  USART_ClockInitStruct-&gt;USART_LastBit = USART_LastBit_Disable;
+}
+
+/**
+  * @brief  Enables or disables the specified USART peripheral.
+  * @param  USARTx: Select the USART or the UART peripheral. 
+  *   This parameter can be one of the following values:
+  *   USART1, USART2, USART3, UART4 or UART5.
+  * @param  NewState: new state of the USARTx peripheral.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected USART by setting the UE bit in the CR1 register */
+    USARTx-&gt;CR1 |= CR1_UE_Set;
+  }
+  else
+  {
+    /* Disable the selected USART by clearing the UE bit in the CR1 register */
+    USARTx-&gt;CR1 &amp;= CR1_UE_Reset;
+  }
+}
+
+/**
+  * @brief  Enables or disables the specified USART interrupts.
+  * @param  USARTx: Select the USART or the UART peripheral. 
+  *   This parameter can be one of the following values:
+  *   USART1, USART2, USART3, UART4 or UART5.
+  * @param  USART_IT: specifies the USART interrupt sources to be enabled or disabled.
+  *   This parameter can be one of the following values:
+  *     @arg USART_IT_CTS:  CTS change interrupt (not available for UART4 and UART5)
+  *     @arg USART_IT_LBD:  LIN Break detection interrupt
+  *     @arg USART_IT_TXE:  Tansmit Data Register empty interrupt
+  *     @arg USART_IT_TC:   Transmission complete interrupt
+  *     @arg USART_IT_RXNE: Receive Data register not empty interrupt
+  *     @arg USART_IT_IDLE: Idle line detection interrupt
+  *     @arg USART_IT_PE:   Parity Error interrupt
+  *     @arg USART_IT_ERR:  Error interrupt(Frame error, noise error, overrun error)
+  * @param  NewState: new state of the specified USARTx interrupts.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState)
+{
+  uint32_t usartreg = 0x00, itpos = 0x00, itmask = 0x00;
+  uint32_t usartxbase = 0x00;
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  assert_param(IS_USART_CONFIG_IT(USART_IT));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  /* The CTS interrupt is not available for UART4 and UART5 */
+  if (USART_IT == USART_IT_CTS)
+  {
+    assert_param(IS_USART_123_PERIPH(USARTx));
+  }   
+  
+  usartxbase = (uint32_t)USARTx;
+
+  /* Get the USART register index */
+  usartreg = (((uint8_t)USART_IT) &gt;&gt; 0x05);
+
+  /* Get the interrupt position */
+  itpos = USART_IT &amp; IT_Mask;
+  itmask = (((uint32_t)0x01) &lt;&lt; itpos);
+    
+  if (usartreg == 0x01) /* The IT is in CR1 register */
+  {
+    usartxbase += 0x0C;
+  }
+  else if (usartreg == 0x02) /* The IT is in CR2 register */
+  {
+    usartxbase += 0x10;
+  }
+  else /* The IT is in CR3 register */
+  {
+    usartxbase += 0x14; 
+  }
+  if (NewState != DISABLE)
+  {
+    *(__IO uint32_t*)usartxbase  |= itmask;
+  }
+  else
+  {
+    *(__IO uint32_t*)usartxbase &amp;= ~itmask;
+  }
+}
+
+/**
+  * @brief  Enables or disables the USART&#146;s DMA interface.
+  * @param  USARTx: Select the USART or the UART peripheral. 
+  *   This parameter can be one of the following values:
+  *   USART1, USART2, USART3 or UART4.  
+  * @param  USART_DMAReq: specifies the DMA request.
+  *   This parameter can be any combination of the following values:
+  *     @arg USART_DMAReq_Tx: USART DMA transmit request
+  *     @arg USART_DMAReq_Rx: USART DMA receive request
+  * @param  NewState: new state of the DMA Request sources.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @note The DMA mode is not available for UART5.  
+  * @retval None
+  */
+void USART_DMACmd(USART_TypeDef* USARTx, uint16_t USART_DMAReq, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_1234_PERIPH(USARTx));
+  assert_param(IS_USART_DMAREQ(USART_DMAReq));  
+  assert_param(IS_FUNCTIONAL_STATE(NewState)); 
+  if (NewState != DISABLE)
+  {
+    /* Enable the DMA transfer for selected requests by setting the DMAT and/or
+       DMAR bits in the USART CR3 register */
+    USARTx-&gt;CR3 |= USART_DMAReq;
+  }
+  else
+  {
+    /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
+       DMAR bits in the USART CR3 register */
+    USARTx-&gt;CR3 &amp;= (uint16_t)~USART_DMAReq;
+  }
+}
+
+/**
+  * @brief  Sets the address of the USART node.
+  * @param  USARTx: Select the USART or the UART peripheral. 
+  *   This parameter can be one of the following values:
+  *   USART1, USART2, USART3, UART4 or UART5.
+  * @param  USART_Address: Indicates the address of the USART node.
+  * @retval None
+  */
+void USART_SetAddress(USART_TypeDef* USARTx, uint8_t USART_Address)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  assert_param(IS_USART_ADDRESS(USART_Address)); 
+    
+  /* Clear the USART address */
+  USARTx-&gt;CR2 &amp;= CR2_Address_Mask;
+  /* Set the USART address node */
+  USARTx-&gt;CR2 |= USART_Address;
+}
+
+/**
+  * @brief  Selects the USART WakeUp method.
+  * @param  USARTx: Select the USART or the UART peripheral. 
+  *   This parameter can be one of the following values:
+  *   USART1, USART2, USART3, UART4 or UART5.
+  * @param  USART_WakeUp: specifies the USART wakeup method.
+  *   This parameter can be one of the following values:
+  *     @arg USART_WakeUp_IdleLine: WakeUp by an idle line detection
+  *     @arg USART_WakeUp_AddressMark: WakeUp by an address mark
+  * @retval None
+  */
+void USART_WakeUpConfig(USART_TypeDef* USARTx, uint16_t USART_WakeUp)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  assert_param(IS_USART_WAKEUP(USART_WakeUp));
+  
+  USARTx-&gt;CR1 &amp;= CR1_WAKE_Mask;
+  USARTx-&gt;CR1 |= USART_WakeUp;
+}
+
+/**
+  * @brief  Determines if the USART is in mute mode or not.
+  * @param  USARTx: Select the USART or the UART peripheral. 
+  *   This parameter can be one of the following values:
+  *   USART1, USART2, USART3, UART4 or UART5.
+  * @param  NewState: new state of the USART mute mode.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void USART_ReceiverWakeUpCmd(USART_TypeDef* USARTx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState)); 
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
+    USARTx-&gt;CR1 |= CR1_RWU_Set;
+  }
+  else
+  {
+    /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
+    USARTx-&gt;CR1 &amp;= CR1_RWU_Reset;
+  }
+}
+
+/**
+  * @brief  Sets the USART LIN Break detection length.
+  * @param  USARTx: Select the USART or the UART peripheral. 
+  *   This parameter can be one of the following values:
+  *   USART1, USART2, USART3, UART4 or UART5.
+  * @param  USART_LINBreakDetectLength: specifies the LIN break detection length.
+  *   This parameter can be one of the following values:
+  *     @arg USART_LINBreakDetectLength_10b: 10-bit break detection
+  *     @arg USART_LINBreakDetectLength_11b: 11-bit break detection
+  * @retval None
+  */
+void USART_LINBreakDetectLengthConfig(USART_TypeDef* USARTx, uint16_t USART_LINBreakDetectLength)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  assert_param(IS_USART_LIN_BREAK_DETECT_LENGTH(USART_LINBreakDetectLength));
+  
+  USARTx-&gt;CR2 &amp;= CR2_LBDL_Mask;
+  USARTx-&gt;CR2 |= USART_LINBreakDetectLength;  
+}
+
+/**
+  * @brief  Enables or disables the USART&#146;s LIN mode.
+  * @param  USARTx: Select the USART or the UART peripheral. 
+  *   This parameter can be one of the following values:
+  *   USART1, USART2, USART3, UART4 or UART5.
+  * @param  NewState: new state of the USART LIN mode.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void USART_LINCmd(USART_TypeDef* USARTx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
+    USARTx-&gt;CR2 |= CR2_LINEN_Set;
+  }
+  else
+  {
+    /* Disable the LIN mode by clearing the LINEN bit in the CR2 register */
+    USARTx-&gt;CR2 &amp;= CR2_LINEN_Reset;
+  }
+}
+
+/**
+  * @brief  Transmits single data through the USARTx peripheral.
+  * @param  USARTx: Select the USART or the UART peripheral. 
+  *   This parameter can be one of the following values:
+  *   USART1, USART2, USART3, UART4 or UART5.
+  * @param  Data: the data to transmit.
+  * @retval None
+  */
+void USART_SendData(USART_TypeDef* USARTx, uint16_t Data)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  assert_param(IS_USART_DATA(Data)); 
+    
+  /* Transmit Data */
+  USARTx-&gt;DR = (Data &amp; (uint16_t)0x01FF);
+}
+
+/**
+  * @brief  Returns the most recent received data by the USARTx peripheral.
+  * @param  USARTx: Select the USART or the UART peripheral. 
+  *   This parameter can be one of the following values:
+  *   USART1, USART2, USART3, UART4 or UART5.
+  * @retval The received data.
+  */
+uint16_t USART_ReceiveData(USART_TypeDef* USARTx)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  
+  /* Receive Data */
+  return (uint16_t)(USARTx-&gt;DR &amp; (uint16_t)0x01FF);
+}
+
+/**
+  * @brief  Transmits break characters.
+  * @param  USARTx: Select the USART or the UART peripheral. 
+  *   This parameter can be one of the following values:
+  *   USART1, USART2, USART3, UART4 or UART5.
+  * @retval None
+  */
+void USART_SendBreak(USART_TypeDef* USARTx)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  
+  /* Send break characters */
+  USARTx-&gt;CR1 |= CR1_SBK_Set;
+}
+
+/**
+  * @brief  Sets the specified USART guard time.
+  * @param  USARTx: where x can be 1, 2 or 3 to select the USART peripheral.
+  * @param  USART_GuardTime: specifies the guard time.
+  * @note The guard time bits are not available for UART4 and UART5.   
+  * @retval None
+  */
+void USART_SetGuardTime(USART_TypeDef* USARTx, uint8_t USART_GuardTime)
+{    
+  /* Check the parameters */
+  assert_param(IS_USART_123_PERIPH(USARTx));
+  
+  /* Clear the USART Guard time */
+  USARTx-&gt;GTPR &amp;= GTPR_LSB_Mask;
+  /* Set the USART guard time */
+  USARTx-&gt;GTPR |= (uint16_t)((uint16_t)USART_GuardTime &lt;&lt; 0x08);
+}
+
+/**
+  * @brief  Sets the system clock prescaler.
+  * @param  USARTx: Select the USART or the UART peripheral. 
+  *   This parameter can be one of the following values:
+  *   USART1, USART2, USART3, UART4 or UART5.
+  * @param  USART_Prescaler: specifies the prescaler clock.  
+  * @note   The function is used for IrDA mode with UART4 and UART5.
+  * @retval None
+  */
+void USART_SetPrescaler(USART_TypeDef* USARTx, uint8_t USART_Prescaler)
+{ 
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  
+  /* Clear the USART prescaler */
+  USARTx-&gt;GTPR &amp;= GTPR_MSB_Mask;
+  /* Set the USART prescaler */
+  USARTx-&gt;GTPR |= USART_Prescaler;
+}
+
+/**
+  * @brief  Enables or disables the USART&#146;s Smart Card mode.
+  * @param  USARTx: where x can be 1, 2 or 3 to select the USART peripheral.
+  * @param  NewState: new state of the Smart Card mode.
+  *   This parameter can be: ENABLE or DISABLE.     
+  * @note The Smart Card mode is not available for UART4 and UART5. 
+  * @retval None
+  */
+void USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_123_PERIPH(USARTx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the SC mode by setting the SCEN bit in the CR3 register */
+    USARTx-&gt;CR3 |= CR3_SCEN_Set;
+  }
+  else
+  {
+    /* Disable the SC mode by clearing the SCEN bit in the CR3 register */
+    USARTx-&gt;CR3 &amp;= CR3_SCEN_Reset;
+  }
+}
+
+/**
+  * @brief  Enables or disables NACK transmission.
+  * @param  USARTx: where x can be 1, 2 or 3 to select the USART peripheral. 
+  * @param  NewState: new state of the NACK transmission.
+  *   This parameter can be: ENABLE or DISABLE.  
+  * @note The Smart Card mode is not available for UART4 and UART5.
+  * @retval None
+  */
+void USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_123_PERIPH(USARTx));  
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the NACK transmission by setting the NACK bit in the CR3 register */
+    USARTx-&gt;CR3 |= CR3_NACK_Set;
+  }
+  else
+  {
+    /* Disable the NACK transmission by clearing the NACK bit in the CR3 register */
+    USARTx-&gt;CR3 &amp;= CR3_NACK_Reset;
+  }
+}
+
+/**
+  * @brief  Enables or disables the USART&#146;s Half Duplex communication.
+  * @param  USARTx: Select the USART or the UART peripheral. 
+  *   This parameter can be one of the following values:
+  *   USART1, USART2, USART3, UART4 or UART5.
+  * @param  NewState: new state of the USART Communication.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void USART_HalfDuplexCmd(USART_TypeDef* USARTx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
+    USARTx-&gt;CR3 |= CR3_HDSEL_Set;
+  }
+  else
+  {
+    /* Disable the Half-Duplex mode by clearing the HDSEL bit in the CR3 register */
+    USARTx-&gt;CR3 &amp;= CR3_HDSEL_Reset;
+  }
+}
+
+/**
+  * @brief  Configures the USART&#146;s IrDA interface.
+  * @param  USARTx: Select the USART or the UART peripheral. 
+  *   This parameter can be one of the following values:
+  *   USART1, USART2, USART3, UART4 or UART5.
+  * @param  USART_IrDAMode: specifies the IrDA mode.
+  *   This parameter can be one of the following values:
+  *     @arg USART_IrDAMode_LowPower
+  *     @arg USART_IrDAMode_Normal
+  * @retval None
+  */
+void USART_IrDAConfig(USART_TypeDef* USARTx, uint16_t USART_IrDAMode)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  assert_param(IS_USART_IRDA_MODE(USART_IrDAMode));
+    
+  USARTx-&gt;CR3 &amp;= CR3_IRLP_Mask;
+  USARTx-&gt;CR3 |= USART_IrDAMode;
+}
+
+/**
+  * @brief  Enables or disables the USART&#146;s IrDA interface.
+  * @param  USARTx: Select the USART or the UART peripheral. 
+  *   This parameter can be one of the following values:
+  *   USART1, USART2, USART3, UART4 or UART5.
+  * @param  NewState: new state of the IrDA mode.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void USART_IrDACmd(USART_TypeDef* USARTx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+    
+  if (NewState != DISABLE)
+  {
+    /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
+    USARTx-&gt;CR3 |= CR3_IREN_Set;
+  }
+  else
+  {
+    /* Disable the IrDA mode by clearing the IREN bit in the CR3 register */
+    USARTx-&gt;CR3 &amp;= CR3_IREN_Reset;
+  }
+}
+
+/**
+  * @brief  Checks whether the specified USART flag is set or not.
+  * @param  USARTx: Select the USART or the UART peripheral. 
+  *   This parameter can be one of the following values:
+  *   USART1, USART2, USART3, UART4 or UART5.
+  * @param  USART_FLAG: specifies the flag to check.
+  *   This parameter can be one of the following values:
+  *     @arg USART_FLAG_CTS:  CTS Change flag (not available for UART4 and UART5)
+  *     @arg USART_FLAG_LBD:  LIN Break detection flag
+  *     @arg USART_FLAG_TXE:  Transmit data register empty flag
+  *     @arg USART_FLAG_TC:   Transmission Complete flag
+  *     @arg USART_FLAG_RXNE: Receive data register not empty flag
+  *     @arg USART_FLAG_IDLE: Idle Line detection flag
+  *     @arg USART_FLAG_ORE:  OverRun Error flag
+  *     @arg USART_FLAG_NE:   Noise Error flag
+  *     @arg USART_FLAG_FE:   Framing Error flag
+  *     @arg USART_FLAG_PE:   Parity Error flag
+  * @retval The new state of USART_FLAG (SET or RESET).
+  */
+FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG)
+{
+  FlagStatus bitstatus = RESET;
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  assert_param(IS_USART_FLAG(USART_FLAG));
+  /* The CTS flag is not available for UART4 and UART5 */
+  if (USART_FLAG == USART_FLAG_CTS)
+  {
+    assert_param(IS_USART_123_PERIPH(USARTx));
+  }  
+  
+  if ((USARTx-&gt;SR &amp; USART_FLAG) != (uint16_t)RESET)
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  return bitstatus;
+}
+
+/**
+  * @brief  Clears the USARTx's pending flags.
+  * @param  USARTx: Select the USART or the UART peripheral. 
+  *   This parameter can be one of the following values:
+  *   USART1, USART2, USART3, UART4 or UART5.
+  * @param  USART_FLAG: specifies the flag to clear.
+  *   This parameter can be any combination of the following values:
+  *     @arg USART_FLAG_CTS:  CTS Change flag (not available for UART4 and UART5).
+  *     @arg USART_FLAG_LBD:  LIN Break detection flag.
+  *     @arg USART_FLAG_TC:   Transmission Complete flag.
+  *     @arg USART_FLAG_RXNE: Receive data register not empty flag.
+  *   
+  * @note
+  *   - PE (Parity error), FE (Framing error), NE (Noise error), ORE (OverRun 
+  *     error) and IDLE (Idle line detected) flags are cleared by software 
+  *     sequence: a read operation to USART_SR register (USART_GetFlagStatus()) 
+  *     followed by a read operation to USART_DR register (USART_ReceiveData()).
+  *   - RXNE flag can be also cleared by a read to the USART_DR register 
+  *     (USART_ReceiveData()).
+  *   - TC flag can be also cleared by software sequence: a read operation to 
+  *     USART_SR register (USART_GetFlagStatus()) followed by a write operation
+  *     to USART_DR register (USART_SendData()).
+  *   - TXE flag is cleared only by a write to the USART_DR register 
+  *     (USART_SendData()).
+  * @retval None
+  */
+void USART_ClearFlag(USART_TypeDef* USARTx, uint16_t USART_FLAG)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  assert_param(IS_USART_CLEAR_FLAG(USART_FLAG));
+  /* The CTS flag is not available for UART4 and UART5 */
+  if ((USART_FLAG &amp; USART_FLAG_CTS) == USART_FLAG_CTS)
+  {
+    assert_param(IS_USART_123_PERIPH(USARTx));
+  } 
+   
+  USARTx-&gt;SR = (uint16_t)~USART_FLAG;
+}
+
+/**
+  * @brief  Checks whether the specified USART interrupt has occurred or not.
+  * @param  USARTx: Select the USART or the UART peripheral. 
+  *   This parameter can be one of the following values:
+  *   USART1, USART2, USART3, UART4 or UART5.
+  * @param  USART_IT: specifies the USART interrupt source to check.
+  *   This parameter can be one of the following values:
+  *     @arg USART_IT_CTS:  CTS change interrupt (not available for UART4 and UART5)
+  *     @arg USART_IT_LBD:  LIN Break detection interrupt
+  *     @arg USART_IT_TXE:  Tansmit Data Register empty interrupt
+  *     @arg USART_IT_TC:   Transmission complete interrupt
+  *     @arg USART_IT_RXNE: Receive Data register not empty interrupt
+  *     @arg USART_IT_IDLE: Idle line detection interrupt
+  *     @arg USART_IT_ORE:  OverRun Error interrupt
+  *     @arg USART_IT_NE:   Noise Error interrupt
+  *     @arg USART_IT_FE:   Framing Error interrupt
+  *     @arg USART_IT_PE:   Parity Error interrupt
+  * @retval The new state of USART_IT (SET or RESET).
+  */
+ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT)
+{
+  uint32_t bitpos = 0x00, itmask = 0x00, usartreg = 0x00;
+  ITStatus bitstatus = RESET;
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  assert_param(IS_USART_GET_IT(USART_IT));
+  /* The CTS interrupt is not available for UART4 and UART5 */ 
+  if (USART_IT == USART_IT_CTS)
+  {
+    assert_param(IS_USART_123_PERIPH(USARTx));
+  }   
+  
+  /* Get the USART register index */
+  usartreg = (((uint8_t)USART_IT) &gt;&gt; 0x05);
+  /* Get the interrupt position */
+  itmask = USART_IT &amp; IT_Mask;
+  itmask = (uint32_t)0x01 &lt;&lt; itmask;
+  
+  if (usartreg == 0x01) /* The IT  is in CR1 register */
+  {
+    itmask &amp;= USARTx-&gt;CR1;
+  }
+  else if (usartreg == 0x02) /* The IT  is in CR2 register */
+  {
+    itmask &amp;= USARTx-&gt;CR2;
+  }
+  else /* The IT  is in CR3 register */
+  {
+    itmask &amp;= USARTx-&gt;CR3;
+  }
+  
+  bitpos = USART_IT &gt;&gt; 0x08;
+  bitpos = (uint32_t)0x01 &lt;&lt; bitpos;
+  bitpos &amp;= USARTx-&gt;SR;
+  if ((itmask != (uint16_t)RESET)&amp;&amp;(bitpos != (uint16_t)RESET))
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  
+  return bitstatus;  
+}
+
+/**
+  * @brief  Clears the USARTx&#146;s interrupt pending bits.
+  * @param  USARTx: Select the USART or the UART peripheral. 
+  *   This parameter can be one of the following values:
+  *   USART1, USART2, USART3, UART4 or UART5.
+  * @param  USART_IT: specifies the interrupt pending bit to clear.
+  *   This parameter can be one of the following values:
+  *     @arg USART_IT_CTS:  CTS change interrupt (not available for UART4 and UART5)
+  *     @arg USART_IT_LBD:  LIN Break detection interrupt
+  *     @arg USART_IT_TC:   Transmission complete interrupt. 
+  *     @arg USART_IT_RXNE: Receive Data register not empty interrupt.
+  *   
+  * @note
+  *   - PE (Parity error), FE (Framing error), NE (Noise error), ORE (OverRun 
+  *     error) and IDLE (Idle line detected) pending bits are cleared by 
+  *     software sequence: a read operation to USART_SR register 
+  *     (USART_GetITStatus()) followed by a read operation to USART_DR register 
+  *     (USART_ReceiveData()).
+  *   - RXNE pending bit can be also cleared by a read to the USART_DR register 
+  *     (USART_ReceiveData()).
+  *   - TC pending bit can be also cleared by software sequence: a read 
+  *     operation to USART_SR register (USART_GetITStatus()) followed by a write 
+  *     operation to USART_DR register (USART_SendData()).
+  *   - TXE pending bit is cleared only by a write to the USART_DR register 
+  *     (USART_SendData()).
+  * @retval None
+  */
+void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT)
+{
+  uint16_t bitpos = 0x00, itmask = 0x00;
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  assert_param(IS_USART_CLEAR_IT(USART_IT));
+  /* The CTS interrupt is not available for UART4 and UART5 */
+  if (USART_IT == USART_IT_CTS)
+  {
+    assert_param(IS_USART_123_PERIPH(USARTx));
+  }   
+  
+  bitpos = USART_IT &gt;&gt; 0x08;
+  itmask = ((uint16_t)0x01 &lt;&lt; (uint16_t)bitpos);
+  USARTx-&gt;SR = (uint16_t)~itmask;
+}
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2009 STMicroelectronics *****END OF FILE****/

Added: trunk/src/platform/stm32/FWLib/library/src/stm32f10x_usart.o
===================================================================
--- trunk/src/platform/stm32/FWLib/library/src/stm32f10x_usart.o	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/src/stm32f10x_usart.o	2009-07-08 23:39:34 UTC (rev 354)
@@ -0,0 +1,18 @@
+ELF
+
+#&#147;@#B&#191;
+#&#139;@&#219;C&#155;&#178;&#128;pG
+&#209;!O&#244;&#128;@&#255;&#247;&#254;&#255;O&#244;&#128;@
+K&#152;B	&#209;O&#244;&#128;!&#255;&#247;&#254;&#255;O&#244;&#128;
+M	

+
+
+
+Z
+\
+\
+]
+]
+]
+]
+]
\ No newline at end of file

Modified: trunk/src/platform/stm32/FWLib/library/src/stm32f10x_wwdg.c
===================================================================
--- trunk/src/platform/stm32/FWLib/library/src/stm32f10x_wwdg.c	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/src/stm32f10x_wwdg.c	2009-07-08 23:39:34 UTC (rev 354)
@@ -1,185 +1,223 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_wwdg.c
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file provides all the WWDG firmware functions.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
-
-/* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_wwdg.h&quot;
-#include &quot;stm32f10x_rcc.h&quot;
-
-/* Private typedef -----------------------------------------------------------*/
-/* Private define ------------------------------------------------------------*/
-/* ----------- WWDG registers bit address in the alias region ----------- */
-#define WWDG_OFFSET       (WWDG_BASE - PERIPH_BASE)
-
-/* Alias word address of EWI bit */
-#define CFR_OFFSET        (WWDG_OFFSET + 0x04)
-#define EWI_BitNumber     0x09
-#define CFR_EWI_BB        (PERIPH_BB_BASE + (CFR_OFFSET * 32) + (EWI_BitNumber * 4))
-
-/* --------------------- WWDG registers bit mask ------------------------ */
-/* CR register bit mask */
-#define CR_WDGA_Set       ((u32)0x00000080)
-
-/* CFR register bit mask */
-#define CFR_WDGTB_Mask    ((u32)0xFFFFFE7F)
-#define CFR_W_Mask        ((u32)0xFFFFFF80)
-
-#define BIT_Mask          ((u8)0x7F)
-
-/* Private macro -------------------------------------------------------------*/
-/* Private variables ---------------------------------------------------------*/
-/* Private function prototypes -----------------------------------------------*/
-/* Private functions ---------------------------------------------------------*/
-
-/*******************************************************************************
-* Function Name  : WWDG_DeInit
-* Description    : Deinitializes the WWDG  peripheral registers to their default
-*                  reset values.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void WWDG_DeInit(void)
-{
-  RCC_APB1PeriphResetCmd(RCC_APB1Periph_WWDG, ENABLE);
-  RCC_APB1PeriphResetCmd(RCC_APB1Periph_WWDG, DISABLE);
-}
-
-/*******************************************************************************
-* Function Name  : WWDG_SetPrescaler
-* Description    : Sets the WWDG Prescaler.
-* Input          : - WWDG_Prescaler: specifies the WWDG Prescaler.
-*                    This parameter can be one of the following values:
-*                       - WWDG_Prescaler_1: WWDG counter clock = (PCLK1/4096)/1
-*                       - WWDG_Prescaler_2: WWDG counter clock = (PCLK1/4096)/2
-*                       - WWDG_Prescaler_4: WWDG counter clock = (PCLK1/4096)/4
-*                       - WWDG_Prescaler_8: WWDG counter clock = (PCLK1/4096)/8
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void WWDG_SetPrescaler(u32 WWDG_Prescaler)
-{
-  u32 tmpreg = 0;
-
-  /* Check the parameters */
-  assert_param(IS_WWDG_PRESCALER(WWDG_Prescaler));
-
-  /* Clear WDGTB[1:0] bits */
-  tmpreg = WWDG-&gt;CFR &amp; CFR_WDGTB_Mask;
-
-  /* Set WDGTB[1:0] bits according to WWDG_Prescaler value */
-  tmpreg |= WWDG_Prescaler;
-
-  /* Store the new value */
-  WWDG-&gt;CFR = tmpreg;
-}
-
-/*******************************************************************************
-* Function Name  : WWDG_SetWindowValue
-* Description    : Sets the WWDG window value.
-* Input          : - WindowValue: specifies the window value to be compared to
-*                    the downcounter.
-*                    This parameter value must be lower than 0x80.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void WWDG_SetWindowValue(u8 WindowValue)
-{
-  u32 tmpreg = 0;
-
-  /* Check the parameters */
-  assert_param(IS_WWDG_WINDOW_VALUE(WindowValue));
-
-  /* Clear W[6:0] bits */
-  tmpreg = WWDG-&gt;CFR &amp; CFR_W_Mask;
-
-  /* Set W[6:0] bits according to WindowValue value */
-  tmpreg |= WindowValue &amp; BIT_Mask;
-
-  /* Store the new value */
-  WWDG-&gt;CFR = tmpreg;
-}
-
-/*******************************************************************************
-* Function Name  : WWDG_EnableIT
-* Description    : Enables the WWDG Early Wakeup interrupt(EWI).
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void WWDG_EnableIT(void)
-{
-  *(vu32 *) CFR_EWI_BB = (u32)ENABLE;
-}
-
-/*******************************************************************************
-* Function Name  : WWDG_SetCounter
-* Description    : Sets the WWDG counter value.
-* Input          : - Counter: specifies the watchdog counter value.
-*                    This parameter must be a number between 0x40 and 0x7F.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void WWDG_SetCounter(u8 Counter)
-{
-  /* Check the parameters */
-  assert_param(IS_WWDG_COUNTER(Counter));
-
-  /* Write to T[6:0] bits to configure the counter value, no need to do
-     a read-modify-write; writing a 0 to WDGA bit does nothing */
-  WWDG-&gt;CR = Counter &amp; BIT_Mask;
-}
-
-/*******************************************************************************
-* Function Name  : WWDG_Enable
-* Description    : Enables WWDG and load the counter value.
-*                  - Counter: specifies the watchdog counter value.
-*                    This parameter must be a number between 0x40 and 0x7F.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void WWDG_Enable(u8 Counter)
-{
-  /* Check the parameters */
-  assert_param(IS_WWDG_COUNTER(Counter));
-
-  WWDG-&gt;CR = CR_WDGA_Set | Counter;
-}
-
-/*******************************************************************************
-* Function Name  : WWDG_GetFlagStatus
-* Description    : Checks whether the Early Wakeup interrupt flag is set or not.
-* Input          : None
-* Output         : None
-* Return         : The new state of the Early Wakeup interrupt flag (SET or RESET)
-*******************************************************************************/
-FlagStatus WWDG_GetFlagStatus(void)
-{
-  return (FlagStatus)(WWDG-&gt;SR);
-}
-
-/*******************************************************************************
-* Function Name  : WWDG_ClearFlag
-* Description    : Clears Early Wakeup interrupt flag.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void WWDG_ClearFlag(void)
-{
-  WWDG-&gt;SR = (u32)RESET;
-}
-
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
+/**
+  ******************************************************************************
+  * @file    stm32f10x_wwdg.c
+  * @author  MCD Application Team
+  * @version V3.1.0
+  * @date    06/19/2009
+  * @brief   This file provides all the WWDG firmware functions.
+  ******************************************************************************
+  * @copy
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * &lt;h2&gt;&lt;center&gt;&copy; COPYRIGHT 2009 STMicroelectronics&lt;/center&gt;&lt;/h2&gt;
+  */ 
+
+/* Includes ------------------------------------------------------------------*/
+#include &quot;stm32f10x_wwdg.h&quot;
+#include &quot;stm32f10x_rcc.h&quot;
+
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup WWDG 
+  * @brief WWDG driver modules
+  * @{
+  */
+
+/** @defgroup WWDG_Private_TypesDefinitions
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup WWDG_Private_Defines
+  * @{
+  */
+
+/* ----------- WWDG registers bit address in the alias region ----------- */
+#define WWDG_OFFSET       (WWDG_BASE - PERIPH_BASE)
+
+/* Alias word address of EWI bit */
+#define CFR_OFFSET        (WWDG_OFFSET + 0x04)
+#define EWI_BitNumber     0x09
+#define CFR_EWI_BB        (PERIPH_BB_BASE + (CFR_OFFSET * 32) + (EWI_BitNumber * 4))
+
+/* --------------------- WWDG registers bit mask ------------------------ */
+
+/* CR register bit mask */
+#define CR_WDGA_Set       ((uint32_t)0x00000080)
+
+/* CFR register bit mask */
+#define CFR_WDGTB_Mask    ((uint32_t)0xFFFFFE7F)
+#define CFR_W_Mask        ((uint32_t)0xFFFFFF80)
+#define BIT_Mask          ((uint8_t)0x7F)
+
+/**
+  * @}
+  */
+
+/** @defgroup WWDG_Private_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup WWDG_Private_Variables
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup WWDG_Private_FunctionPrototypes
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup WWDG_Private_Functions
+  * @{
+  */
+
+/**
+  * @brief  Deinitializes the WWDG peripheral registers to their default reset values.
+  * @param  None
+  * @retval None
+  */
+void WWDG_DeInit(void)
+{
+  RCC_APB1PeriphResetCmd(RCC_APB1Periph_WWDG, ENABLE);
+  RCC_APB1PeriphResetCmd(RCC_APB1Periph_WWDG, DISABLE);
+}
+
+/**
+  * @brief  Sets the WWDG Prescaler.
+  * @param  WWDG_Prescaler: specifies the WWDG Prescaler.
+  *   This parameter can be one of the following values:
+  *     @arg WWDG_Prescaler_1: WWDG counter clock = (PCLK1/4096)/1
+  *     @arg WWDG_Prescaler_2: WWDG counter clock = (PCLK1/4096)/2
+  *     @arg WWDG_Prescaler_4: WWDG counter clock = (PCLK1/4096)/4
+  *     @arg WWDG_Prescaler_8: WWDG counter clock = (PCLK1/4096)/8
+  * @retval None
+  */
+void WWDG_SetPrescaler(uint32_t WWDG_Prescaler)
+{
+  uint32_t tmpreg = 0;
+  /* Check the parameters */
+  assert_param(IS_WWDG_PRESCALER(WWDG_Prescaler));
+  /* Clear WDGTB[1:0] bits */
+  tmpreg = WWDG-&gt;CFR &amp; CFR_WDGTB_Mask;
+  /* Set WDGTB[1:0] bits according to WWDG_Prescaler value */
+  tmpreg |= WWDG_Prescaler;
+  /* Store the new value */
+  WWDG-&gt;CFR = tmpreg;
+}
+
+/**
+  * @brief  Sets the WWDG window value.
+  * @param  WindowValue: specifies the window value to be compared to the downcounter.
+  *   This parameter value must be lower than 0x80.
+  * @retval None
+  */
+void WWDG_SetWindowValue(uint8_t WindowValue)
+{
+  __IO uint32_t tmpreg = 0;
+
+  /* Check the parameters */
+  assert_param(IS_WWDG_WINDOW_VALUE(WindowValue));
+  /* Clear W[6:0] bits */
+
+  tmpreg = WWDG-&gt;CFR &amp; CFR_W_Mask;
+
+  /* Set W[6:0] bits according to WindowValue value */
+  tmpreg |= WindowValue &amp; (uint32_t) BIT_Mask;
+
+  /* Store the new value */
+  WWDG-&gt;CFR = tmpreg;
+}
+
+/**
+  * @brief  Enables the WWDG Early Wakeup interrupt(EWI).
+  * @param  None
+  * @retval None
+  */
+void WWDG_EnableIT(void)
+{
+  *(__IO uint32_t *) CFR_EWI_BB = (uint32_t)ENABLE;
+}
+
+/**
+  * @brief  Sets the WWDG counter value.
+  * @param  Counter: specifies the watchdog counter value.
+  *   This parameter must be a number between 0x40 and 0x7F.
+  * @retval None
+  */
+void WWDG_SetCounter(uint8_t Counter)
+{
+  /* Check the parameters */
+  assert_param(IS_WWDG_COUNTER(Counter));
+  /* Write to T[6:0] bits to configure the counter value, no need to do
+     a read-modify-write; writing a 0 to WDGA bit does nothing */
+  WWDG-&gt;CR = Counter &amp; BIT_Mask;
+}
+
+/**
+  * @brief  Enables WWDG and load the counter value.                  
+  * @param  Counter: specifies the watchdog counter value.
+  *   This parameter must be a number between 0x40 and 0x7F.
+  * @retval None
+  */
+void WWDG_Enable(uint8_t Counter)
+{
+  /* Check the parameters */
+  assert_param(IS_WWDG_COUNTER(Counter));
+  WWDG-&gt;CR = CR_WDGA_Set | Counter;
+}
+
+/**
+  * @brief  Checks whether the Early Wakeup interrupt flag is set or not.
+  * @param  None
+  * @retval The new state of the Early Wakeup interrupt flag (SET or RESET)
+  */
+FlagStatus WWDG_GetFlagStatus(void)
+{
+  return (FlagStatus)(WWDG-&gt;SR);
+}
+
+/**
+  * @brief  Clears Early Wakeup interrupt flag.
+  * @param  None
+  * @retval None
+  */
+void WWDG_ClearFlag(void)
+{
+  WWDG-&gt;SR = (uint32_t)RESET;
+}
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2009 STMicroelectronics *****END OF FILE****/

Added: trunk/src/platform/stm32/FWLib/library/src/stm32f10x_wwdg.o
===================================================================
--- trunk/src/platform/stm32/FWLib/library/src/stm32f10x_wwdg.o	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/FWLib/library/src/stm32f10x_wwdg.o	2009-07-08 23:39:34 UTC (rev 354)
@@ -0,0 +1,8 @@
+ELF
+M	
+
+
+
+
+'
+'
\ No newline at end of file

Modified: trunk/src/platform/stm32/conf.py
===================================================================
--- trunk/src/platform/stm32/conf.py	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/conf.py	2009-07-08 23:39:34 UTC (rev 354)
@@ -8,7 +8,7 @@
 fwlib_files = &quot; &quot;.join(glob.glob(&quot;src/platform/%s/FWLib/library/src/*.c&quot; % platform))
 #print &quot;FWLib: %s &quot; % fwlib_files 
 
-specific_files = &quot;cortexm3_macro.s stm32f10x_vector.c systick.c platform.c stm32f10x_it.c lcd.c lua_lcd.c&quot;
+specific_files = &quot;core_cm3.c systick.c system_stm32f10x.c startup_stm32f10x_hd.s platform.c stm32f10x_it.c lcd.c lua_lcd.c&quot;
 
 ldscript = &quot;stm32.ld&quot;
   

Added: trunk/src/platform/stm32/core_cm3.c
===================================================================
--- trunk/src/platform/stm32/core_cm3.c	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/core_cm3.c	2009-07-08 23:39:34 UTC (rev 354)
@@ -0,0 +1,829 @@
+/******************************************************************************
+ * @file:    core_cm3.c
+ * @purpose: CMSIS Cortex-M3 Core Peripheral Access Layer Source File
+ * @version: V1.20
+ * @date:    22. May 2009
+ *----------------------------------------------------------------------------
+ *
+ * Copyright (C) 2009 ARM Limited. All rights reserved.
+ *
+ * ARM Limited (ARM) is supplying this software for use with Cortex-Mx 
+ * processor based microcontrollers.  This file can be freely distributed 
+ * within development tools that are supporting such ARM based processors. 
+ *
+ * THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+ * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+ * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+ * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+ *
+ ******************************************************************************/
+
+
+
+#include &lt;stdint.h&gt;
+
+
+/* define compiler specific symbols */
+#if defined   ( __CC_ARM   )
+  #define __ASM            __asm           /*!&lt; asm keyword for armcc           */
+  #define __INLINE         __inline        /*!&lt; inline keyword for armcc        */
+
+#elif defined ( __ICCARM__ )
+  #define __ASM           __asm            /*!&lt; asm keyword for iarcc           */
+  #define __INLINE        inline           /*!&lt; inline keyword for iarcc. Only avaiable in High optimization mode! */
+
+#elif defined (  __GNUC__  )
+  #define __ASM             __asm          /*!&lt; asm keyword for gcc            */
+  #define __INLINE          inline         /*!&lt; inline keyword for gcc         */
+
+#elif defined   (  __TASKING__  )
+  #define __ASM            __asm           /*!&lt; asm keyword for TASKING Compiler          */
+  #define __INLINE         inline          /*!&lt; inline keyword for TASKING Compiler       */
+
+#endif
+
+
+
+#if defined ( __CC_ARM   ) /*------------------RealView Compiler -----------------*/
+
+/**
+ * @brief  Return the Process Stack Pointer
+ *
+ * @param  none
+ * @return uint32_t ProcessStackPointer
+ *
+ * Return the actual process stack pointer
+ */
+__ASM uint32_t __get_PSP(void)
+{
+  mrs r0, psp
+  bx lr
+}
+
+/**
+ * @brief  Set the Process Stack Pointer
+ *
+ * @param  uint32_t Process Stack Pointer
+ * @return none
+ *
+ * Assign the value ProcessStackPointer to the MSP 
+ * (process stack pointer) Cortex processor register
+ */
+__ASM void __set_PSP(uint32_t topOfProcStack)
+{
+  msr psp, r0
+  bx lr
+}
+
+/**
+ * @brief  Return the Main Stack Pointer
+ *
+ * @param  none
+ * @return uint32_t Main Stack Pointer
+ *
+ * Return the current value of the MSP (main stack pointer)
+ * Cortex processor register
+ */
+__ASM uint32_t __get_MSP(void)
+{
+  mrs r0, msp
+  bx lr
+}
+
+/**
+ * @brief  Set the Main Stack Pointer
+ *
+ * @param  uint32_t Main Stack Pointer
+ * @return none
+ *
+ * Assign the value mainStackPointer to the MSP 
+ * (main stack pointer) Cortex processor register
+ */
+__ASM void __set_MSP(uint32_t mainStackPointer)
+{
+  msr msp, r0
+  bx lr
+}
+
+/**
+ * @brief  Reverse byte order in unsigned short value
+ *
+ * @param  uint16_t value to reverse
+ * @return uint32_t reversed value
+ *
+ * Reverse byte order in unsigned short value
+ */
+__ASM uint32_t __REV16(uint16_t value)
+{
+  rev16 r0, r0
+  bx lr
+}
+
+/**
+ * @brief  Reverse byte order in signed short value with sign extension to integer
+ *
+ * @param  int16_t value to reverse
+ * @return int32_t reversed value
+ *
+ * Reverse byte order in signed short value with sign extension to integer
+ */
+__ASM int32_t __REVSH(int16_t value)
+{
+  revsh r0, r0
+  bx lr
+}
+
+
+#if (__ARMCC_VERSION &lt; 400000)
+
+/**
+ * @brief  Remove the exclusive lock created by ldrex
+ *
+ * @param  none
+ * @return none
+ *
+ * Removes the exclusive lock which is created by ldrex.
+ */
+__ASM void __CLREX(void)
+{
+  clrex
+}
+
+/**
+ * @brief  Return the Base Priority value
+ *
+ * @param  none
+ * @return uint32_t BasePriority
+ *
+ * Return the content of the base priority register
+ */
+__ASM uint32_t  __get_BASEPRI(void)
+{
+  mrs r0, basepri
+  bx lr
+}
+
+/**
+ * @brief  Set the Base Priority value
+ *
+ * @param  uint32_t BasePriority
+ * @return none
+ *
+ * Set the base priority register
+ */
+__ASM void __set_BASEPRI(uint32_t basePri)
+{
+  msr basepri, r0
+  bx lr
+}
+
+/**
+ * @brief  Return the Priority Mask value
+ *
+ * @param  none
+ * @return uint32_t PriMask
+ *
+ * Return the state of the priority mask bit from the priority mask
+ * register
+ */
+__ASM uint32_t __get_PRIMASK(void)
+{
+  mrs r0, primask
+  bx lr
+}
+
+/**
+ * @brief  Set the Priority Mask value
+ *
+ * @param  uint32_t PriMask
+ * @return none
+ *
+ * Set the priority mask bit in the priority mask register
+ */
+__ASM void __set_PRIMASK(uint32_t priMask)
+{
+  msr primask, r0
+  bx lr
+}
+
+/**
+ * @brief  Return the Fault Mask value
+ *
+ * @param  none
+ * @return uint32_t FaultMask
+ *
+ * Return the content of the fault mask register
+ */
+__ASM uint32_t  __get_FAULTMASK(void)
+{
+  mrs r0, faultmask
+  bx lr
+}
+
+/**
+ * @brief  Set the Fault Mask value
+ *
+ * @param  uint32_t faultMask value
+ * @return none
+ *
+ * Set the fault mask register
+ */
+__ASM void __set_FAULTMASK(uint32_t faultMask)
+{
+  msr faultmask, r0
+  bx lr
+}
+
+/**
+ * @brief  Return the Control Register value
+ * 
+ * @param  none
+ * @return uint32_t Control value
+ *
+ * Return the content of the control register
+ */
+__ASM uint32_t  __get_CONTROL(void)
+{
+  mrs r0, control
+  bx lr
+}
+
+/**
+ * @brief  Set the Control Register value
+ *
+ * @param  uint32_t Control value
+ * @return none
+ *
+ * Set the control register
+ */
+__ASM void __set_CONTROL(uint32_t control)
+{
+  msr control, r0
+  bx lr
+}
+
+#endif /* __ARMCC_VERSION  */ 
+
+
+#elif (defined (__ICCARM__)) /*------------------ ICC Compiler -------------------*/
+#pragma diag_suppress=Pe940
+
+/**
+ * @brief  Return the Process Stack Pointer
+ *
+ * @param  none
+ * @return uint32_t ProcessStackPointer
+ *
+ * Return the actual process stack pointer
+ */
+uint32_t __get_PSP(void)
+{
+  __ASM(&quot;mrs r0, psp&quot;);
+  __ASM(&quot;bx lr&quot;);
+}
+
+/**
+ * @brief  Set the Process Stack Pointer
+ *
+ * @param  uint32_t Process Stack Pointer
+ * @return none
+ *
+ * Assign the value ProcessStackPointer to the MSP 
+ * (process stack pointer) Cortex processor register
+ */
+void __set_PSP(uint32_t topOfProcStack)
+{
+  __ASM(&quot;msr psp, r0&quot;);
+  __ASM(&quot;bx lr&quot;);
+}
+
+/**
+ * @brief  Return the Main Stack Pointer
+ *
+ * @param  none
+ * @return uint32_t Main Stack Pointer
+ *
+ * Return the current value of the MSP (main stack pointer)
+ * Cortex processor register
+ */
+uint32_t __get_MSP(void)
+{
+  __ASM(&quot;mrs r0, msp&quot;);
+  __ASM(&quot;bx lr&quot;);
+}
+
+/**
+ * @brief  Set the Main Stack Pointer
+ *
+ * @param  uint32_t Main Stack Pointer
+ * @return none
+ *
+ * Assign the value mainStackPointer to the MSP 
+ * (main stack pointer) Cortex processor register
+ */
+void __set_MSP(uint32_t topOfMainStack)
+{
+  __ASM(&quot;msr msp, r0&quot;);
+  __ASM(&quot;bx lr&quot;);
+}
+
+/**
+ * @brief  Reverse byte order in unsigned short value
+ *
+ * @param  uint16_t value to reverse
+ * @return uint32_t reversed value
+ *
+ * Reverse byte order in unsigned short value
+ */
+uint32_t __REV16(uint16_t value)
+{
+  __ASM(&quot;rev16 r0, r0&quot;);
+  __ASM(&quot;bx lr&quot;);
+}
+
+/**
+ * @brief  Reverse bit order of value
+ *
+ * @param  uint32_t value to reverse
+ * @return uint32_t reversed value
+ *
+ * Reverse bit order of value
+ */
+uint32_t __RBIT(uint32_t value)
+{
+  __ASM(&quot;rbit r0, r0&quot;);
+  __ASM(&quot;bx lr&quot;);
+}
+
+/**
+ * @brief  LDR Exclusive
+ *
+ * @param  uint8_t* address
+ * @return uint8_t value of (*address)
+ *
+ * Exclusive LDR command
+ */
+uint8_t __LDREXB(uint8_t *addr)
+{
+  __ASM(&quot;ldrexb r0, [r0]&quot;);
+  __ASM(&quot;bx lr&quot;); 
+}
+
+/**
+ * @brief  LDR Exclusive
+ *
+ * @param  uint16_t* address
+ * @return uint16_t value of (*address)
+ *
+ * Exclusive LDR command
+ */
+uint16_t __LDREXH(uint16_t *addr)
+{
+  __ASM(&quot;ldrexh r0, [r0]&quot;);
+  __ASM(&quot;bx lr&quot;);
+}
+
+/**
+ * @brief  LDR Exclusive
+ *
+ * @param  uint32_t* address
+ * @return uint32_t value of (*address)
+ *
+ * Exclusive LDR command
+ */
+uint32_t __LDREXW(uint32_t *addr)
+{
+  __ASM(&quot;ldrex r0, [r0]&quot;);
+  __ASM(&quot;bx lr&quot;);
+}
+
+/**
+ * @brief  STR Exclusive
+ *
+ * @param  uint8_t *address
+ * @param  uint8_t value to store
+ * @return uint32_t successful / failed
+ *
+ * Exclusive STR command
+ */
+uint32_t __STREXB(uint8_t value, uint8_t *addr)
+{
+  __ASM(&quot;strexb r0, r0, [r1]&quot;);
+  __ASM(&quot;bx lr&quot;);
+}
+
+/**
+ * @brief  STR Exclusive
+ *
+ * @param  uint16_t *address
+ * @param  uint16_t value to store
+ * @return uint32_t successful / failed
+ *
+ * Exclusive STR command
+ */
+uint32_t __STREXH(uint16_t value, uint16_t *addr)
+{
+  __ASM(&quot;strexh r0, r0, [r1]&quot;);
+  __ASM(&quot;bx lr&quot;);
+}
+
+/**
+ * @brief  STR Exclusive
+ *
+ * @param  uint32_t *address
+ * @param  uint32_t value to store
+ * @return uint32_t successful / failed
+ *
+ * Exclusive STR command
+ */
+uint32_t __STREXW(uint32_t value, uint32_t *addr)
+{
+  __ASM(&quot;strex r0, r0, [r1]&quot;);
+  __ASM(&quot;bx lr&quot;);
+}
+
+#pragma diag_default=Pe940
+
+
+#elif (defined (__GNUC__)) /*------------------ GNU Compiler ---------------------*/
+
+/**
+ * @brief  Return the Process Stack Pointer
+ *
+ * @param  none
+ * @return uint32_t ProcessStackPointer
+ *
+ * Return the actual process stack pointer
+ */
+uint32_t __get_PSP(void) __attribute__( ( naked ) );
+uint32_t __get_PSP(void)
+{
+  uint32_t result=0;
+
+  __ASM volatile (&quot;MRS %0, psp\n\t&quot; 
+                  &quot;MOV r0, %0 \n\t&quot;
+                  &quot;BX  lr     \n\t&quot;  : &quot;=r&quot; (result) );
+  return(result);
+}
+
+
+/**
+ * @brief  Set the Process Stack Pointer
+ *
+ * @param  uint32_t Process Stack Pointer
+ * @return none
+ *
+ * Assign the value ProcessStackPointer to the MSP 
+ * (process stack pointer) Cortex processor register
+ */
+void __set_PSP(uint32_t topOfProcStack) __attribute__( ( naked ) );
+void __set_PSP(uint32_t topOfProcStack)
+{
+  __ASM volatile (&quot;MSR psp, %0\n\t&quot;
+                  &quot;BX  lr     \n\t&quot; : : &quot;r&quot; (topOfProcStack) );
+}
+
+/**
+ * @brief  Return the Main Stack Pointer
+ *
+ * @param  none
+ * @return uint32_t Main Stack Pointer
+ *
+ * Return the current value of the MSP (main stack pointer)
+ * Cortex processor register
+ */
+uint32_t __get_MSP(void) __attribute__( ( naked ) );
+uint32_t __get_MSP(void)
+{
+  uint32_t result=0;
+
+  __ASM volatile (&quot;MRS %0, msp\n\t&quot; 
+                  &quot;MOV r0, %0 \n\t&quot;
+                  &quot;BX  lr     \n\t&quot;  : &quot;=r&quot; (result) );
+  return(result);
+}
+
+/**
+ * @brief  Set the Main Stack Pointer
+ *
+ * @param  uint32_t Main Stack Pointer
+ * @return none
+ *
+ * Assign the value mainStackPointer to the MSP 
+ * (main stack pointer) Cortex processor register
+ */
+void __set_MSP(uint32_t topOfMainStack) __attribute__( ( naked ) );
+void __set_MSP(uint32_t topOfMainStack)
+{
+  __ASM volatile (&quot;MSR msp, %0\n\t&quot;
+                  &quot;BX  lr     \n\t&quot; : : &quot;r&quot; (topOfMainStack) );
+}
+
+/**
+ * @brief  Return the Base Priority value
+ *
+ * @param  none
+ * @return uint32_t BasePriority
+ *
+ * Return the content of the base priority register
+ */
+uint32_t __get_BASEPRI(void)
+{
+  uint32_t result=0;
+  
+  __ASM volatile (&quot;MRS %0, basepri_max&quot; : &quot;=r&quot; (result) );
+  return(result);
+}
+
+/**
+ * @brief  Set the Base Priority value
+ *
+ * @param  uint32_t BasePriority
+ * @return none
+ *
+ * Set the base priority register
+ */
+void __set_BASEPRI(uint32_t value)
+{
+  __ASM volatile (&quot;MSR basepri, %0&quot; : : &quot;r&quot; (value) );
+}
+
+/**
+ * @brief  Return the Priority Mask value
+ *
+ * @param  none
+ * @return uint32_t PriMask
+ *
+ * Return the state of the priority mask bit from the priority mask
+ * register
+ */
+uint32_t __get_PRIMASK(void)
+{
+  uint32_t result=0;
+
+  __ASM volatile (&quot;MRS %0, primask&quot; : &quot;=r&quot; (result) );
+  return(result);
+}
+
+/**
+ * @brief  Set the Priority Mask value
+ *
+ * @param  uint32_t PriMask
+ * @return none
+ *
+ * Set the priority mask bit in the priority mask register
+ */
+void __set_PRIMASK(uint32_t priMask)
+{
+  __ASM volatile (&quot;MSR primask, %0&quot; : : &quot;r&quot; (priMask) );
+}
+
+/**
+ * @brief  Return the Fault Mask value
+ *
+ * @param  none
+ * @return uint32_t FaultMask
+ *
+ * Return the content of the fault mask register
+ */
+uint32_t __get_FAULTMASK(void)
+{
+  uint32_t result=0;
+  
+  __ASM volatile (&quot;MRS %0, faultmask&quot; : &quot;=r&quot; (result) );
+  return(result);
+}
+
+/**
+ * @brief  Set the Fault Mask value
+ *
+ * @param  uint32_t faultMask value
+ * @return none
+ *
+ * Set the fault mask register
+ */
+void __set_FAULTMASK(uint32_t faultMask)
+{
+  __ASM volatile (&quot;MSR faultmask, %0&quot; : : &quot;r&quot; (faultMask) );
+}
+
+/**
+ * @brief  Reverse byte order in integer value
+ *
+ * @param  uint32_t value to reverse
+ * @return uint32_t reversed value
+ *
+ * Reverse byte order in integer value
+ */
+uint32_t __REV(uint32_t value)
+{
+  uint32_t result=0;
+  
+  __ASM volatile (&quot;rev %0, %1&quot; : &quot;=r&quot; (result) : &quot;r&quot; (value) );
+  return(result);
+}
+
+/**
+ * @brief  Reverse byte order in unsigned short value
+ *
+ * @param  uint16_t value to reverse
+ * @return uint32_t reversed value
+ *
+ * Reverse byte order in unsigned short value
+ */
+uint32_t __REV16(uint16_t value)
+{
+  uint32_t result=0;
+  
+  __ASM volatile (&quot;rev16 %0, %1&quot; : &quot;=r&quot; (result) : &quot;r&quot; (value) );
+  return(result);
+}
+
+/**
+ * @brief  Reverse byte order in signed short value with sign extension to integer
+ *
+ * @param  int32_t value to reverse
+ * @return int32_t reversed value
+ *
+ * Reverse byte order in signed short value with sign extension to integer
+ */
+int32_t __REVSH(int16_t value)
+{
+  uint32_t result=0;
+  
+  __ASM volatile (&quot;revsh %0, %1&quot; : &quot;=r&quot; (result) : &quot;r&quot; (value) );
+  return(result);
+}
+
+/**
+ * @brief  Reverse bit order of value
+ *
+ * @param  uint32_t value to reverse
+ * @return uint32_t reversed value
+ *
+ * Reverse bit order of value
+ */
+uint32_t __RBIT(uint32_t value)
+{
+  uint32_t result=0;
+  
+   __ASM volatile (&quot;rbit %0, %1&quot; : &quot;=r&quot; (result) : &quot;r&quot; (value) );
+   return(result);
+}
+
+/**
+ * @brief  LDR Exclusive
+ *
+ * @param  uint8_t* address
+ * @return uint8_t value of (*address)
+ *
+ * Exclusive LDR command
+ */
+uint8_t __LDREXB(uint8_t *addr)
+{
+    uint8_t result=0;
+  
+   __ASM volatile (&quot;ldrexb %0, [%1]&quot; : &quot;=r&quot; (result) : &quot;r&quot; (addr) );
+   return(result);
+}
+
+/**
+ * @brief  LDR Exclusive
+ *
+ * @param  uint16_t* address
+ * @return uint16_t value of (*address)
+ *
+ * Exclusive LDR command
+ */
+uint16_t __LDREXH(uint16_t *addr)
+{
+    uint16_t result=0;
+  
+   __ASM volatile (&quot;ldrexh %0, [%1]&quot; : &quot;=r&quot; (result) : &quot;r&quot; (addr) );
+   return(result);
+}
+
+/**
+ * @brief  LDR Exclusive
+ *
+ * @param  uint32_t* address
+ * @return uint32_t value of (*address)
+ *
+ * Exclusive LDR command
+ */
+uint32_t __LDREXW(uint32_t *addr)
+{
+    uint32_t result=0;
+  
+   __ASM volatile (&quot;ldrex %0, [%1]&quot; : &quot;=r&quot; (result) : &quot;r&quot; (addr) );
+   return(result);
+}
+
+/**
+ * @brief  STR Exclusive
+ *
+ * @param  uint8_t *address
+ * @param  uint8_t value to store
+ * @return uint32_t successful / failed
+ *
+ * Exclusive STR command
+ */
+uint32_t __STREXB(uint8_t value, uint8_t *addr)
+{
+   uint32_t result=0;
+  
+   __ASM volatile (&quot;strexb %0, %2, [%1]&quot; : &quot;=r&quot; (result) : &quot;r&quot; (addr), &quot;r&quot; (value) );
+   return(result);
+}
+
+/**
+ * @brief  STR Exclusive
+ *
+ * @param  uint16_t *address
+ * @param  uint16_t value to store
+ * @return uint32_t successful / failed
+ *
+ * Exclusive STR command
+ */
+uint32_t __STREXH(uint16_t value, uint16_t *addr)
+{
+   uint32_t result=0;
+  
+   __ASM volatile (&quot;strexh %0, %2, [%1]&quot; : &quot;=r&quot; (result) : &quot;r&quot; (addr), &quot;r&quot; (value) );
+   return(result);
+}
+
+/**
+ * @brief  STR Exclusive
+ *
+ * @param  uint32_t *address
+ * @param  uint32_t value to store
+ * @return uint32_t successful / failed
+ *
+ * Exclusive STR command
+ */
+uint32_t __STREXW(uint32_t value, uint32_t *addr)
+{
+   uint32_t result=0;
+  
+   __ASM volatile (&quot;strex %0, %2, [%1]&quot; : &quot;=r&quot; (result) : &quot;r&quot; (addr), &quot;r&quot; (value) );
+   return(result);
+}
+
+/**
+ * @brief  Return the Control Register value
+ * 
+ * @param  none
+ * @return uint32_t Control value
+ *
+ * Return the content of the control register
+ */
+uint32_t __get_CONTROL(void)
+{
+  uint32_t result=0;
+
+  __ASM volatile (&quot;MRS %0, control&quot; : &quot;=r&quot; (result) );
+  return(result);
+}
+
+/**
+ * @brief  Set the Control Register value
+ *
+ * @param  uint32_t Control value
+ * @return none
+ *
+ * Set the control register
+ */
+void __set_CONTROL(uint32_t control)
+{
+  __ASM volatile (&quot;MSR control, %0&quot; : : &quot;r&quot; (control) );
+}
+
+#elif (defined (__TASKING__)) /*------------------ TASKING Compiler ---------------------*/
+/* TASKING carm specific functions */
+
+/*
+ * The CMSIS functions have been implemented as intrinsics in the compiler.
+ * Please use &quot;carm -?i&quot; to get an up to date list of all instrinsics,
+ * Including the CMSIS ones.
+ */
+
+#endif
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+


Property changes on: trunk/src/platform/stm32/core_cm3.c
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/platform/stm32/core_cm3.h
===================================================================
--- trunk/src/platform/stm32/core_cm3.h	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/core_cm3.h	2009-07-08 23:39:34 UTC (rev 354)
@@ -0,0 +1,1367 @@
+/******************************************************************************
+ * @file:    core_cm3.h
+ * @purpose: CMSIS Cortex-M3 Core Peripheral Access Layer Header File
+ * @version: V1.20
+ * @date:    22. May 2009
+ *----------------------------------------------------------------------------
+ *
+ * Copyright (C) 2009 ARM Limited. All rights reserved.
+ *
+ * ARM Limited (ARM) is supplying this software for use with Cortex-Mx 
+ * processor based microcontrollers.  This file can be freely distributed 
+ * within development tools that are supporting such ARM based processors. 
+ *
+ * THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+ * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+ * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+ * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+ *
+ ******************************************************************************/
+
+#ifndef __CM3_CORE_H__
+#define __CM3_CORE_H__
+
+#ifdef __cplusplus
+ extern &quot;C&quot; {
+#endif 
+
+#define __CM3_CMSIS_VERSION_MAIN  (0x01)                                                       /*!&lt; [31:16] CMSIS HAL main version */
+#define __CM3_CMSIS_VERSION_SUB   (0x20)                                                       /*!&lt; [15:0]  CMSIS HAL sub version  */
+#define __CM3_CMSIS_VERSION       ((__CM3_CMSIS_VERSION_MAIN &lt;&lt; 16) | __CM3_CMSIS_VERSION_SUB) /*!&lt; CMSIS HAL version number       */
+
+#define __CORTEX_M                (0x03)                                                       /*!&lt; Cortex core                    */
+
+/**
+ *  Lint configuration \n
+ *  ----------------------- \n
+ *
+ *  The following Lint messages will be suppressed and not shown: \n
+ *  \n
+ *    --- Error 10: --- \n
+ *    register uint32_t __regBasePri         __asm(&quot;basepri&quot;); \n
+ *    Error 10: Expecting ';' \n
+ *     \n
+ *    --- Error 530: --- \n
+ *    return(__regBasePri); \n
+ *    Warning 530: Symbol '__regBasePri' (line 264) not initialized \n
+ *     \n
+ *    --- Error 550: --- \n
+ *      __regBasePri = (basePri &amp; 0x1ff); \n
+ *    } \n
+ *    Warning 550: Symbol '__regBasePri' (line 271) not accessed \n
+ *     \n
+ *    --- Error 754: --- \n
+ *    uint32_t RESERVED0[24]; \n
+ *    Info 754: local structure member '&lt;some, not used in the HAL&gt;' (line 109, file ./cm3_core.h) not referenced \n
+ *     \n
+ *    --- Error 750: --- \n
+ *    #define __CM3_CORE_H__ \n
+ *    Info 750: local macro '__CM3_CORE_H__' (line 43, file./cm3_core.h) not referenced \n
+ *     \n
+ *    --- Error 528: --- \n
+ *    static __INLINE void NVIC_DisableIRQ(uint32_t IRQn) \n
+ *    Warning 528: Symbol 'NVIC_DisableIRQ(unsigned int)' (line 419, file ./cm3_core.h) not referenced \n
+ *     \n
+ *    --- Error 751: --- \n
+ *    } InterruptType_Type; \n
+ *    Info 751: local typedef 'InterruptType_Type' (line 170, file ./cm3_core.h) not referenced \n
+ * \n
+ * \n
+ *    Note:  To re-enable a Message, insert a space before 'lint' * \n
+ *
+ */
+
+/*lint -save */
+/*lint -e10  */
+/*lint -e530 */
+/*lint -e550 */
+/*lint -e754 */
+/*lint -e750 */
+/*lint -e528 */
+/*lint -e751 */
+
+
+#include &lt;stdint.h&gt;                           /* Include standard types */
+
+#if defined (__ICCARM__)
+  #include &lt;intrinsics.h&gt;                     /* IAR Intrinsics   */
+#endif
+
+
+#ifndef __NVIC_PRIO_BITS
+  #define __NVIC_PRIO_BITS    4               /*!&lt; standard definition for NVIC Priority Bits */
+#endif
+
+
+
+
+/**
+ * IO definitions
+ *
+ * define access restrictions to peripheral registers
+ */
+
+#ifdef __cplusplus
+#define     __I     volatile                  /*!&lt; defines 'read only' permissions      */
+#else
+#define     __I     volatile const            /*!&lt; defines 'read only' permissions      */
+#endif
+#define     __O     volatile                  /*!&lt; defines 'write only' permissions     */
+#define     __IO    volatile                  /*!&lt; defines 'read / write' permissions   */
+
+
+
+/*******************************************************************************
+ *                 Register Abstraction
+ ******************************************************************************/
+
+
+/* System Reset */
+#define NVIC_VECTRESET              0         /*!&lt; Vector Reset Bit             */
+#define NVIC_SYSRESETREQ            2         /*!&lt; System Reset Request         */
+#define NVIC_AIRCR_VECTKEY    (0x5FA &lt;&lt; 16)   /*!&lt; AIRCR Key for write access   */
+#define NVIC_AIRCR_ENDIANESS        15        /*!&lt; Endianess                    */
+
+/* Core Debug */
+#define CoreDebug_DEMCR_TRCENA (1 &lt;&lt; 24)      /*!&lt; DEMCR TRCENA enable          */
+#define ITM_TCR_ITMENA              1         /*!&lt; ITM enable                   */
+
+
+
+
+/* memory mapping struct for Nested Vectored Interrupt Controller (NVIC) */
+typedef struct
+{
+  __IO uint32_t ISER[8];                      /*!&lt; Interrupt Set Enable Register            */
+       uint32_t RESERVED0[24];
+  __IO uint32_t ICER[8];                      /*!&lt; Interrupt Clear Enable Register          */
+       uint32_t RSERVED1[24];
+  __IO uint32_t ISPR[8];                      /*!&lt; Interrupt Set Pending Register           */
+       uint32_t RESERVED2[24];
+  __IO uint32_t ICPR[8];                      /*!&lt; Interrupt Clear Pending Register         */
+       uint32_t RESERVED3[24];
+  __IO uint32_t IABR[8];                      /*!&lt; Interrupt Active bit Register            */
+       uint32_t RESERVED4[56];
+  __IO uint8_t  IP[240];                      /*!&lt; Interrupt Priority Register, 8Bit wide   */
+       uint32_t RESERVED5[644];
+  __O  uint32_t STIR;                         /*!&lt; Software Trigger Interrupt Register      */
+}  NVIC_Type;
+
+
+/* memory mapping struct for System Control Block */
+typedef struct
+{
+  __I  uint32_t CPUID;                        /*!&lt; CPU ID Base Register                                     */
+  __IO uint32_t ICSR;                         /*!&lt; Interrupt Control State Register                         */
+  __IO uint32_t VTOR;                         /*!&lt; Vector Table Offset Register                             */
+  __IO uint32_t AIRCR;                        /*!&lt; Application Interrupt / Reset Control Register           */
+  __IO uint32_t SCR;                          /*!&lt; System Control Register                                  */
+  __IO uint32_t CCR;                          /*!&lt; Configuration Control Register                           */
+  __IO uint8_t  SHP[12];                      /*!&lt; System Handlers Priority Registers (4-7, 8-11, 12-15)    */
+  __IO uint32_t SHCSR;                        /*!&lt; System Handler Control and State Register                */
+  __IO uint32_t CFSR;                         /*!&lt; Configurable Fault Status Register                       */
+  __IO uint32_t HFSR;                         /*!&lt; Hard Fault Status Register                               */
+  __IO uint32_t DFSR;                         /*!&lt; Debug Fault Status Register                              */
+  __IO uint32_t MMFAR;                        /*!&lt; Mem Manage Address Register                              */
+  __IO uint32_t BFAR;                         /*!&lt; Bus Fault Address Register                               */
+  __IO uint32_t AFSR;                         /*!&lt; Auxiliary Fault Status Register                          */
+  __I  uint32_t PFR[2];                       /*!&lt; Processor Feature Register                               */
+  __I  uint32_t DFR;                          /*!&lt; Debug Feature Register                                   */
+  __I  uint32_t ADR;                          /*!&lt; Auxiliary Feature Register                               */
+  __I  uint32_t MMFR[4];                      /*!&lt; Memory Model Feature Register                            */
+  __I  uint32_t ISAR[5];                      /*!&lt; ISA Feature Register                                     */
+} SCB_Type;
+
+
+/* memory mapping struct for SysTick */
+typedef struct
+{
+  __IO uint32_t CTRL;                         /*!&lt; SysTick Control and Status Register */
+  __IO uint32_t LOAD;                         /*!&lt; SysTick Reload Value Register       */
+  __IO uint32_t VAL;                          /*!&lt; SysTick Current Value Register      */
+  __I  uint32_t CALIB;                        /*!&lt; SysTick Calibration Register        */
+} SysTick_Type;
+
+
+/* memory mapping structur for ITM */
+typedef struct
+{
+  __O  union  
+  {
+    __O  uint8_t    u8;                       /*!&lt; ITM Stimulus Port 8-bit               */
+    __O  uint16_t   u16;                      /*!&lt; ITM Stimulus Port 16-bit              */
+    __O  uint32_t   u32;                      /*!&lt; ITM Stimulus Port 32-bit              */
+  }  PORT [32];                               /*!&lt; ITM Stimulus Port Registers           */
+       uint32_t RESERVED0[864];
+  __IO uint32_t TER;                          /*!&lt; ITM Trace Enable Register             */
+       uint32_t RESERVED1[15];
+  __IO uint32_t TPR;                          /*!&lt; ITM Trace Privilege Register          */
+       uint32_t RESERVED2[15];
+  __IO uint32_t TCR;                          /*!&lt; ITM Trace Control Register            */
+       uint32_t RESERVED3[29];
+  __IO uint32_t IWR;                          /*!&lt; ITM Integration Write Register        */
+  __IO uint32_t IRR;                          /*!&lt; ITM Integration Read Register         */
+  __IO uint32_t IMCR;                         /*!&lt; ITM Integration Mode Control Register */
+       uint32_t RESERVED4[43];
+  __IO uint32_t LAR;                          /*!&lt; ITM Lock Access Register              */
+  __IO uint32_t LSR;                          /*!&lt; ITM Lock Status Register              */
+       uint32_t RESERVED5[6];
+  __I  uint32_t PID4;                         /*!&lt; ITM Product ID Registers              */
+  __I  uint32_t PID5;
+  __I  uint32_t PID6;
+  __I  uint32_t PID7;
+  __I  uint32_t PID0;
+  __I  uint32_t PID1;
+  __I  uint32_t PID2;
+  __I  uint32_t PID3;
+  __I  uint32_t CID0;
+  __I  uint32_t CID1;
+  __I  uint32_t CID2;
+  __I  uint32_t CID3;
+} ITM_Type;
+
+
+/* memory mapped struct for Interrupt Type */
+typedef struct
+{
+       uint32_t RESERVED0;
+  __I  uint32_t ICTR;                         /*!&lt; Interrupt Control Type Register  */
+#if ((defined __CM3_REV) &amp;&amp; (__CM3_REV &gt;= 0x200))
+  __IO uint32_t ACTLR;                        /*!&lt; Auxiliary Control Register       */
+#else
+       uint32_t RESERVED1;
+#endif
+} InterruptType_Type;
+
+
+/* Memory Protection Unit */
+#if defined (__MPU_PRESENT) &amp;&amp; (__MPU_PRESENT == 1)
+typedef struct
+{
+  __I  uint32_t TYPE;                         /*!&lt; MPU Type Register                               */
+  __IO uint32_t CTRL;                         /*!&lt; MPU Control Register                            */
+  __IO uint32_t RNR;                          /*!&lt; MPU Region RNRber Register                      */
+  __IO uint32_t RBAR;                         /*!&lt; MPU Region Base Address Register                */
+  __IO uint32_t RASR;                         /*!&lt; MPU Region Attribute and Size Register          */
+  __IO uint32_t RBAR_A1;                      /*!&lt; MPU Alias 1 Region Base Address Register        */
+  __IO uint32_t RASR_A1;                      /*!&lt; MPU Alias 1 Region Attribute and Size Register  */
+  __IO uint32_t RBAR_A2;                      /*!&lt; MPU Alias 2 Region Base Address Register        */
+  __IO uint32_t RASR_A2;                      /*!&lt; MPU Alias 2 Region Attribute and Size Register  */
+  __IO uint32_t RBAR_A3;                      /*!&lt; MPU Alias 3 Region Base Address Register        */
+  __IO uint32_t RASR_A3;                      /*!&lt; MPU Alias 3 Region Attribute and Size Register  */
+} MPU_Type;
+#endif
+
+
+/* Core Debug Register */
+typedef struct
+{
+  __IO uint32_t DHCSR;                        /*!&lt; Debug Halting Control and Status Register       */
+  __O  uint32_t DCRSR;                        /*!&lt; Debug Core Register Selector Register           */
+  __IO uint32_t DCRDR;                        /*!&lt; Debug Core Register Data Register               */
+  __IO uint32_t DEMCR;                        /*!&lt; Debug Exception and Monitor Control Register    */
+} CoreDebug_Type;
+
+
+/* Memory mapping of Cortex-M3 Hardware */
+#define SCS_BASE            (0xE000E000)                              /*!&lt; System Control Space Base Address    */
+#define ITM_BASE            (0xE0000000)                              /*!&lt; ITM Base Address                     */
+#define CoreDebug_BASE      (0xE000EDF0)                              /*!&lt; Core Debug Base Address              */
+#define SysTick_BASE        (SCS_BASE +  0x0010)                      /*!&lt; SysTick Base Address                 */
+#define NVIC_BASE           (SCS_BASE +  0x0100)                      /*!&lt; NVIC Base Address                    */
+#define SCB_BASE            (SCS_BASE +  0x0D00)                      /*!&lt; System Control Block Base Address    */
+
+#define InterruptType       ((InterruptType_Type *) SCS_BASE)         /*!&lt; Interrupt Type Register              */
+#define SCB                 ((SCB_Type *)           SCB_BASE)         /*!&lt; SCB configuration struct             */
+#define SysTick             ((SysTick_Type *)       SysTick_BASE)     /*!&lt; SysTick configuration struct         */
+#define NVIC                ((NVIC_Type *)          NVIC_BASE)        /*!&lt; NVIC configuration struct            */
+#define ITM                 ((ITM_Type *)           ITM_BASE)         /*!&lt; ITM configuration struct             */
+#define CoreDebug           ((CoreDebug_Type *)     CoreDebug_BASE)   /*!&lt; Core Debug configuration struct      */
+
+#if defined (__MPU_PRESENT) &amp;&amp; (__MPU_PRESENT == 1)
+  #define MPU_BASE          (SCS_BASE +  0x0D90)                      /*!&lt; Memory Protection Unit               */
+  #define MPU               ((MPU_Type*)            MPU_BASE)         /*!&lt; Memory Protection Unit               */
+#endif
+
+
+
+/*******************************************************************************
+ *                Hardware Abstraction Layer
+ ******************************************************************************/
+
+
+#if defined ( __CC_ARM   )
+  #define __ASM            __asm                                      /*!&lt; asm keyword for ARM Compiler          */
+  #define __INLINE         __inline                                   /*!&lt; inline keyword for ARM Compiler       */
+
+#elif defined ( __ICCARM__ )
+  #define __ASM           __asm                                       /*!&lt; asm keyword for IAR Compiler           */
+  #define __INLINE        inline                                      /*!&lt; inline keyword for IAR Compiler. Only avaiable in High optimization mode! */
+
+#elif defined   (  __GNUC__  )
+  #define __ASM            __asm                                      /*!&lt; asm keyword for GNU Compiler          */
+  #define __INLINE         inline                                     /*!&lt; inline keyword for GNU Compiler       */
+
+#elif defined   (  __TASKING__  )
+  #define __ASM            __asm                                      /*!&lt; asm keyword for TASKING Compiler          */
+  #define __INLINE         inline                                     /*!&lt; inline keyword for TASKING Compiler       */
+
+#endif
+
+
+/* ###################  Compiler specific Intrinsics  ########################### */
+
+#if defined ( __CC_ARM   ) /*------------------RealView Compiler -----------------*/
+/* ARM armcc specific functions */
+
+#define __enable_fault_irq                __enable_fiq
+#define __disable_fault_irq               __disable_fiq
+
+#define __NOP                             __nop
+#define __WFI                             __wfi
+#define __WFE                             __wfe
+#define __SEV                             __sev
+#define __ISB()                           __isb(0)
+#define __DSB()                           __dsb(0)
+#define __DMB()                           __dmb(0)
+#define __REV                             __rev
+#define __RBIT                            __rbit
+#define __LDREXB(ptr)                     ((unsigned char ) __ldrex(ptr))
+#define __LDREXH(ptr)                     ((unsigned short) __ldrex(ptr))
+#define __LDREXW(ptr)                     ((unsigned int  ) __ldrex(ptr))
+#define __STREXB(value, ptr)              __strex(value, ptr)
+#define __STREXH(value, ptr)              __strex(value, ptr)
+#define __STREXW(value, ptr)              __strex(value, ptr)
+
+
+/* intrinsic unsigned long long __ldrexd(volatile void *ptr) */
+/* intrinsic int __strexd(unsigned long long val, volatile void *ptr) */
+/* intrinsic void __enable_irq();     */
+/* intrinsic void __disable_irq();    */
+
+
+/**
+ * @brief  Return the Process Stack Pointer
+ *
+ * @param  none
+ * @return uint32_t ProcessStackPointer
+ *
+ * Return the actual process stack pointer
+ */
+extern uint32_t __get_PSP(void);
+
+/**
+ * @brief  Set the Process Stack Pointer
+ *
+ * @param  uint32_t Process Stack Pointer
+ * @return none
+ *
+ * Assign the value ProcessStackPointer to the MSP 
+ * (process stack pointer) Cortex processor register
+ */
+extern void __set_PSP(uint32_t topOfProcStack);
+
+/**
+ * @brief  Return the Main Stack Pointer
+ *
+ * @param  none
+ * @return uint32_t Main Stack Pointer
+ *
+ * Return the current value of the MSP (main stack pointer)
+ * Cortex processor register
+ */
+extern uint32_t __get_MSP(void);
+
+/**
+ * @brief  Set the Main Stack Pointer
+ *
+ * @param  uint32_t Main Stack Pointer
+ * @return none
+ *
+ * Assign the value mainStackPointer to the MSP 
+ * (main stack pointer) Cortex processor register
+ */
+extern void __set_MSP(uint32_t topOfMainStack);
+
+/**
+ * @brief  Reverse byte order in unsigned short value
+ *
+ * @param  uint16_t value to reverse
+ * @return uint32_t reversed value
+ *
+ * Reverse byte order in unsigned short value
+ */
+extern uint32_t __REV16(uint16_t value);
+
+/*
+ * @brief  Reverse byte order in signed short value with sign extension to integer
+ *
+ * @param  int16_t value to reverse
+ * @return int32_t reversed value
+ *
+ * Reverse byte order in signed short value with sign extension to integer
+ */
+extern int32_t __REVSH(int16_t value);
+
+
+#if (__ARMCC_VERSION &lt; 400000)
+
+/**
+ * @brief  Remove the exclusive lock created by ldrex
+ *
+ * @param  none
+ * @return none
+ *
+ * Removes the exclusive lock which is created by ldrex.
+ */
+extern void __CLREX(void);
+
+/**
+ * @brief  Return the Base Priority value
+ *
+ * @param  none
+ * @return uint32_t BasePriority
+ *
+ * Return the content of the base priority register
+ */
+extern uint32_t __get_BASEPRI(void);
+
+/**
+ * @brief  Set the Base Priority value
+ *
+ * @param  uint32_t BasePriority
+ * @return none
+ *
+ * Set the base priority register
+ */
+extern void __set_BASEPRI(uint32_t basePri);
+
+/**
+ * @brief  Return the Priority Mask value
+ *
+ * @param  none
+ * @return uint32_t PriMask
+ *
+ * Return the state of the priority mask bit from the priority mask
+ * register
+ */
+extern uint32_t __get_PRIMASK(void);
+
+/**
+ * @brief  Set the Priority Mask value
+ *
+ * @param  uint32_t PriMask
+ * @return none
+ *
+ * Set the priority mask bit in the priority mask register
+ */
+extern void __set_PRIMASK(uint32_t priMask);
+
+/**
+ * @brief  Return the Fault Mask value
+ *
+ * @param  none
+ * @return uint32_t FaultMask
+ *
+ * Return the content of the fault mask register
+ */
+extern uint32_t __get_FAULTMASK(void);
+
+/**
+ * @brief  Set the Fault Mask value
+ *
+ * @param  uint32_t faultMask value
+ * @return none
+ *
+ * Set the fault mask register
+ */
+extern void __set_FAULTMASK(uint32_t faultMask);
+
+/**
+ * @brief  Return the Control Register value
+ * 
+ * @param  none
+ * @return uint32_t Control value
+ *
+ * Return the content of the control register
+ */
+extern uint32_t __get_CONTROL(void);
+
+/**
+ * @brief  Set the Control Register value
+ *
+ * @param  uint32_t Control value
+ * @return none
+ *
+ * Set the control register
+ */
+extern void __set_CONTROL(uint32_t control);
+
+#else  /* (__ARMCC_VERSION &gt;= 400000)  */
+
+
+/**
+ * @brief  Remove the exclusive lock created by ldrex
+ *
+ * @param  none
+ * @return none
+ *
+ * Removes the exclusive lock which is created by ldrex.
+ */
+#define __CLREX                           __clrex
+
+/**
+ * @brief  Return the Base Priority value
+ *
+ * @param  none
+ * @return uint32_t BasePriority
+ *
+ * Return the content of the base priority register
+ */
+static __INLINE uint32_t  __get_BASEPRI(void)
+{
+  register uint32_t __regBasePri         __ASM(&quot;basepri&quot;);
+  return(__regBasePri);
+}
+
+/**
+ * @brief  Set the Base Priority value
+ *
+ * @param  uint32_t BasePriority
+ * @return none
+ *
+ * Set the base priority register
+ */
+static __INLINE void __set_BASEPRI(uint32_t basePri)
+{
+  register uint32_t __regBasePri         __ASM(&quot;basepri&quot;);
+  __regBasePri = (basePri &amp; 0x1ff);
+}
+
+/**
+ * @brief  Return the Priority Mask value
+ *
+ * @param  none
+ * @return uint32_t PriMask
+ *
+ * Return the state of the priority mask bit from the priority mask
+ * register
+ */
+static __INLINE uint32_t __get_PRIMASK(void)
+{
+  register uint32_t __regPriMask         __ASM(&quot;primask&quot;);
+  return(__regPriMask);
+}
+
+/**
+ * @brief  Set the Priority Mask value
+ *
+ * @param  uint32_t PriMask
+ * @return none
+ *
+ * Set the priority mask bit in the priority mask register
+ */
+static __INLINE void __set_PRIMASK(uint32_t priMask)
+{
+  register uint32_t __regPriMask         __ASM(&quot;primask&quot;);
+  __regPriMask = (priMask);
+}
+
+/**
+ * @brief  Return the Fault Mask value
+ *
+ * @param  none
+ * @return uint32_t FaultMask
+ *
+ * Return the content of the fault mask register
+ */
+static __INLINE uint32_t __get_FAULTMASK(void)
+{
+  register uint32_t __regFaultMask       __ASM(&quot;faultmask&quot;);
+  return(__regFaultMask);
+}
+
+/**
+ * @brief  Set the Fault Mask value
+ *
+ * @param  uint32_t faultMask value
+ * @return none
+ *
+ * Set the fault mask register
+ */
+static __INLINE void __set_FAULTMASK(uint32_t faultMask)
+{
+  register uint32_t __regFaultMask       __ASM(&quot;faultmask&quot;);
+  __regFaultMask = (faultMask &amp; 1);
+}
+
+/**
+ * @brief  Return the Control Register value
+ * 
+ * @param  none
+ * @return uint32_t Control value
+ *
+ * Return the content of the control register
+ */
+static __INLINE uint32_t __get_CONTROL(void)
+{
+  register uint32_t __regControl         __ASM(&quot;control&quot;);
+  return(__regControl);
+}
+
+/**
+ * @brief  Set the Control Register value
+ *
+ * @param  uint32_t Control value
+ * @return none
+ *
+ * Set the control register
+ */
+static __INLINE void __set_CONTROL(uint32_t control)
+{
+  register uint32_t __regControl         __ASM(&quot;control&quot;);
+  __regControl = control;
+}
+
+#endif /* __ARMCC_VERSION  */ 
+
+
+
+#elif (defined (__ICCARM__)) /*------------------ ICC Compiler -------------------*/
+/* IAR iccarm specific functions */
+
+#define __enable_irq                              __enable_interrupt        /*!&lt; global Interrupt enable */
+#define __disable_irq                             __disable_interrupt       /*!&lt; global Interrupt disable */
+
+static __INLINE void __enable_fault_irq()         { __ASM (&quot;cpsie f&quot;); }
+static __INLINE void __disable_fault_irq()        { __ASM (&quot;cpsid f&quot;); }
+
+#define __NOP                                     __no_operation()          /*!&lt; no operation intrinsic in IAR Compiler */ 
+static __INLINE  void __WFI()                     { __ASM (&quot;wfi&quot;); }
+static __INLINE  void __WFE()                     { __ASM (&quot;wfe&quot;); }
+static __INLINE  void __SEV()                     { __ASM (&quot;sev&quot;); }
+static __INLINE  void __CLREX()                   { __ASM (&quot;clrex&quot;); }
+
+/* intrinsic void __ISB(void)                                     */
+/* intrinsic void __DSB(void)                                     */
+/* intrinsic void __DMB(void)                                     */
+/* intrinsic void __set_PRIMASK();                                */
+/* intrinsic void __get_PRIMASK();                                */
+/* intrinsic void __set_FAULTMASK();                              */
+/* intrinsic void __get_FAULTMASK();                              */
+/* intrinsic uint32_t __REV(uint32_t value);                      */
+/* intrinsic uint32_t __REVSH(uint32_t value);                    */
+/* intrinsic unsigned long __STREX(unsigned long, unsigned long); */
+/* intrinsic unsigned long __LDREX(unsigned long *);              */
+
+
+/**
+ * @brief  Return the Process Stack Pointer
+ *
+ * @param  none
+ * @return uint32_t ProcessStackPointer
+ *
+ * Return the actual process stack pointer
+ */
+extern uint32_t __get_PSP(void);
+
+/**
+ * @brief  Set the Process Stack Pointer
+ *
+ * @param  uint32_t Process Stack Pointer
+ * @return none
+ *
+ * Assign the value ProcessStackPointer to the MSP 
+ * (process stack pointer) Cortex processor register
+ */
+extern void __set_PSP(uint32_t topOfProcStack);
+
+/**
+ * @brief  Return the Main Stack Pointer
+ *
+ * @param  none
+ * @return uint32_t Main Stack Pointer
+ *
+ * Return the current value of the MSP (main stack pointer)
+ * Cortex processor register
+ */
+extern uint32_t __get_MSP(void);
+
+/**
+ * @brief  Set the Main Stack Pointer
+ *
+ * @param  uint32_t Main Stack Pointer
+ * @return none
+ *
+ * Assign the value mainStackPointer to the MSP 
+ * (main stack pointer) Cortex processor register
+ */
+extern void __set_MSP(uint32_t topOfMainStack);
+
+/**
+ * @brief  Reverse byte order in unsigned short value
+ *
+ * @param  uint16_t value to reverse
+ * @return uint32_t reversed value
+ *
+ * Reverse byte order in unsigned short value
+ */
+extern uint32_t __REV16(uint16_t value);
+
+/**
+ * @brief  Reverse bit order of value
+ *
+ * @param  uint32_t value to reverse
+ * @return uint32_t reversed value
+ *
+ * Reverse bit order of value
+ */
+extern uint32_t __RBIT(uint32_t value);
+
+/**
+ * @brief  LDR Exclusive
+ *
+ * @param  uint8_t* address
+ * @return uint8_t value of (*address)
+ *
+ * Exclusive LDR command
+ */
+extern uint8_t __LDREXB(uint8_t *addr);
+
+/**
+ * @brief  LDR Exclusive
+ *
+ * @param  uint16_t* address
+ * @return uint16_t value of (*address)
+ *
+ * Exclusive LDR command
+ */
+extern uint16_t __LDREXH(uint16_t *addr);
+
+/**
+ * @brief  LDR Exclusive
+ *
+ * @param  uint32_t* address
+ * @return uint32_t value of (*address)
+ *
+ * Exclusive LDR command
+ */
+extern uint32_t __LDREXW(uint32_t *addr);
+
+/**
+ * @brief  STR Exclusive
+ *
+ * @param  uint8_t *address
+ * @param  uint8_t value to store
+ * @return uint32_t successful / failed
+ *
+ * Exclusive STR command
+ */
+extern uint32_t __STREXB(uint8_t value, uint8_t *addr);
+
+/**
+ * @brief  STR Exclusive
+ *
+ * @param  uint16_t *address
+ * @param  uint16_t value to store
+ * @return uint32_t successful / failed
+ *
+ * Exclusive STR command
+ */
+extern uint32_t __STREXH(uint16_t value, uint16_t *addr);
+
+/**
+ * @brief  STR Exclusive
+ *
+ * @param  uint32_t *address
+ * @param  uint32_t value to store
+ * @return uint32_t successful / failed
+ *
+ * Exclusive STR command
+ */
+extern uint32_t __STREXW(uint32_t value, uint32_t *addr);
+
+
+
+#elif (defined (__GNUC__)) /*------------------ GNU Compiler ---------------------*/
+/* GNU gcc specific functions */
+
+static __INLINE void __enable_irq()               { __ASM volatile (&quot;cpsie i&quot;); }
+static __INLINE void __disable_irq()              { __ASM volatile (&quot;cpsid i&quot;); }
+
+static __INLINE void __enable_fault_irq()         { __ASM volatile (&quot;cpsie f&quot;); }
+static __INLINE void __disable_fault_irq()        { __ASM volatile (&quot;cpsid f&quot;); }
+
+static __INLINE void __NOP()                      { __ASM volatile (&quot;nop&quot;); }
+static __INLINE void __WFI()                      { __ASM volatile (&quot;wfi&quot;); }
+static __INLINE void __WFE()                      { __ASM volatile (&quot;wfe&quot;); }
+static __INLINE void __SEV()                      { __ASM volatile (&quot;sev&quot;); }
+static __INLINE void __ISB()                      { __ASM volatile (&quot;isb&quot;); }
+static __INLINE void __DSB()                      { __ASM volatile (&quot;dsb&quot;); }
+static __INLINE void __DMB()                      { __ASM volatile (&quot;dmb&quot;); }
+static __INLINE void __CLREX()                    { __ASM volatile (&quot;clrex&quot;); }
+
+
+/**
+ * @brief  Return the Process Stack Pointer
+ *
+ * @param  none
+ * @return uint32_t ProcessStackPointer
+ *
+ * Return the actual process stack pointer
+ */
+extern uint32_t __get_PSP(void);
+
+/**
+ * @brief  Set the Process Stack Pointer
+ *
+ * @param  uint32_t Process Stack Pointer
+ * @return none
+ *
+ * Assign the value ProcessStackPointer to the MSP 
+ * (process stack pointer) Cortex processor register
+ */
+extern void __set_PSP(uint32_t topOfProcStack);
+
+/**
+ * @brief  Return the Main Stack Pointer
+ *
+ * @param  none
+ * @return uint32_t Main Stack Pointer
+ *
+ * Return the current value of the MSP (main stack pointer)
+ * Cortex processor register
+ */
+extern uint32_t __get_MSP(void);
+
+/**
+ * @brief  Set the Main Stack Pointer
+ *
+ * @param  uint32_t Main Stack Pointer
+ * @return none
+ *
+ * Assign the value mainStackPointer to the MSP 
+ * (main stack pointer) Cortex processor register
+ */
+extern void __set_MSP(uint32_t topOfMainStack);
+
+/**
+ * @brief  Return the Base Priority value
+ *
+ * @param  none
+ * @return uint32_t BasePriority
+ *
+ * Return the content of the base priority register
+ */
+extern uint32_t __get_BASEPRI(void);
+
+/**
+ * @brief  Set the Base Priority value
+ *
+ * @param  uint32_t BasePriority
+ * @return none
+ *
+ * Set the base priority register
+ */
+extern void __set_BASEPRI(uint32_t basePri);
+
+/**
+ * @brief  Return the Priority Mask value
+ *
+ * @param  none
+ * @return uint32_t PriMask
+ *
+ * Return the state of the priority mask bit from the priority mask
+ * register
+ */
+extern uint32_t  __get_PRIMASK(void);
+
+/**
+ * @brief  Set the Priority Mask value
+ *
+ * @param  uint32_t PriMask
+ * @return none
+ *
+ * Set the priority mask bit in the priority mask register
+ */
+extern void __set_PRIMASK(uint32_t priMask);
+
+/**
+ * @brief  Return the Fault Mask value
+ *
+ * @param  none
+ * @return uint32_t FaultMask
+ *
+ * Return the content of the fault mask register
+ */
+extern uint32_t __get_FAULTMASK(void);
+
+/**
+ * @brief  Set the Fault Mask value
+ *
+ * @param  uint32_t faultMask value
+ * @return none
+ *
+ * Set the fault mask register
+ */
+extern void __set_FAULTMASK(uint32_t faultMask);
+
+/**
+ * @brief  Return the Control Register value
+* 
+*  @param  none
+*  @return uint32_t Control value
+ *
+ * Return the content of the control register
+ */
+extern uint32_t __get_CONTROL(void);
+
+/**
+ * @brief  Set the Control Register value
+ *
+ * @param  uint32_t Control value
+ * @return none
+ *
+ * Set the control register
+ */
+extern void __set_CONTROL(uint32_t control);
+
+/**
+ * @brief  Reverse byte order in integer value
+ *
+ * @param  uint32_t value to reverse
+ * @return uint32_t reversed value
+ *
+ * Reverse byte order in integer value
+ */
+extern uint32_t __REV(uint32_t value);
+
+/**
+ * @brief  Reverse byte order in unsigned short value
+ *
+ * @param  uint16_t value to reverse
+ * @return uint32_t reversed value
+ *
+ * Reverse byte order in unsigned short value
+ */
+extern uint32_t __REV16(uint16_t value);
+
+/*
+ * Reverse byte order in signed short value with sign extension to integer
+ *
+ * @param  int16_t value to reverse
+ * @return int32_t reversed value
+ *
+ * @brief  Reverse byte order in signed short value with sign extension to integer
+ */
+extern int32_t __REVSH(int16_t value);
+
+/**
+ * @brief  Reverse bit order of value
+ *
+ * @param  uint32_t value to reverse
+ * @return uint32_t reversed value
+ *
+ * Reverse bit order of value
+ */
+extern uint32_t __RBIT(uint32_t value);
+
+/**
+ * @brief  LDR Exclusive
+ *
+ * @param  uint8_t* address
+ * @return uint8_t value of (*address)
+ *
+ * Exclusive LDR command
+ */
+extern uint8_t __LDREXB(uint8_t *addr);
+
+/**
+ * @brief  LDR Exclusive
+ *
+ * @param  uint16_t* address
+ * @return uint16_t value of (*address)
+ *
+ * Exclusive LDR command
+ */
+extern uint16_t __LDREXH(uint16_t *addr);
+
+/**
+ * @brief  LDR Exclusive
+ *
+ * @param  uint32_t* address
+ * @return uint32_t value of (*address)
+ *
+ * Exclusive LDR command
+ */
+extern uint32_t __LDREXW(uint32_t *addr);
+
+/**
+ * @brief  STR Exclusive
+ *
+ * @param  uint8_t *address
+ * @param  uint8_t value to store
+ * @return uint32_t successful / failed
+ *
+ * Exclusive STR command
+ */
+extern uint32_t __STREXB(uint8_t value, uint8_t *addr);
+
+/**
+ * @brief  STR Exclusive
+ *
+ * @param  uint16_t *address
+ * @param  uint16_t value to store
+ * @return uint32_t successful / failed
+ *
+ * Exclusive STR command
+ */
+extern uint32_t __STREXH(uint16_t value, uint16_t *addr);
+
+/**
+ * @brief  STR Exclusive
+ *
+ * @param  uint32_t *address
+ * @param  uint32_t value to store
+ * @return uint32_t successful / failed
+ *
+ * Exclusive STR command
+ */
+extern uint32_t __STREXW(uint32_t value, uint32_t *addr);
+
+
+#elif (defined (__TASKING__)) /*------------------ TASKING Compiler ---------------------*/
+/* TASKING carm specific functions */
+
+/*
+ * The CMSIS functions have been implemented as intrinsics in the compiler.
+ * Please use &quot;carm -?i&quot; to get an up to date list of all instrinsics,
+ * Including the CMSIS ones.
+ */
+
+#endif
+
+
+
+/* ##########################   NVIC functions  #################################### */
+
+
+/**
+ * @brief  Set the Priority Grouping in NVIC Interrupt Controller
+ *
+ * @param  uint32_t priority_grouping is priority grouping field
+ * @return none 
+ *
+ * Set the priority grouping field using the required unlock sequence.
+ * The parameter priority_grouping is assigned to the field 
+ * SCB-&gt;AIRCR [10:8] PRIGROUP field. Only values from 0..7 are used.
+ * In case of a conflict between priority grouping and available
+ * priority bits (__NVIC_PRIO_BITS) the smallest possible priority group is set.
+ */
+static __INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
+{
+  uint32_t reg_value;
+  uint32_t PriorityGroupTmp = (PriorityGroup &amp; 0x07);                         /* only values 0..7 are used          */
+  
+  reg_value  = SCB-&gt;AIRCR;                                                    /* read old register configuration    */
+  reg_value &amp;= ~((0xFFFFU &lt;&lt; 16) | (0x0F &lt;&lt; 8));                              /* clear bits to change               */
+  reg_value  = ((reg_value | NVIC_AIRCR_VECTKEY | (PriorityGroupTmp &lt;&lt; 8)));  /* Insert write key and priorty group */
+  SCB-&gt;AIRCR = reg_value;
+}
+
+/**
+ * @brief  Get the Priority Grouping from NVIC Interrupt Controller
+ *
+ * @param  none
+ * @return uint32_t   priority grouping field 
+ *
+ * Get the priority grouping from NVIC Interrupt Controller.
+ * priority grouping is SCB-&gt;AIRCR [10:8] PRIGROUP field.
+ */
+static __INLINE uint32_t NVIC_GetPriorityGrouping(void)
+{
+  return ((SCB-&gt;AIRCR &gt;&gt; 8) &amp; 0x07);                                          /* read priority grouping field */
+}
+
+/**
+ * @brief  Enable Interrupt in NVIC Interrupt Controller
+ *
+ * @param  IRQn_Type IRQn specifies the interrupt number
+ * @return none 
+ *
+ * Enable a device specific interupt in the NVIC interrupt controller.
+ * The interrupt number cannot be a negative value.
+ */
+static __INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
+{
+  NVIC-&gt;ISER[((uint32_t)(IRQn) &gt;&gt; 5)] = (1 &lt;&lt; ((uint32_t)(IRQn) &amp; 0x1F)); /* enable interrupt */
+}
+
+/**
+ * @brief  Disable the interrupt line for external interrupt specified
+ * 
+ * @param  IRQn_Type IRQn is the positive number of the external interrupt
+ * @return none
+ * 
+ * Disable a device specific interupt in the NVIC interrupt controller.
+ * The interrupt number cannot be a negative value.
+ */
+static __INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
+{
+  NVIC-&gt;ICER[((uint32_t)(IRQn) &gt;&gt; 5)] = (1 &lt;&lt; ((uint32_t)(IRQn) &amp; 0x1F)); /* disable interrupt */
+}
+
+/**
+ * @brief  Read the interrupt pending bit for a device specific interrupt source
+ * 
+ * @param  IRQn_Type IRQn is the number of the device specifc interrupt
+ * @return uint32_t 1 if pending interrupt else 0
+ *
+ * Read the pending register in NVIC and return 1 if its status is pending, 
+ * otherwise it returns 0
+ */
+static __INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
+{
+  return((uint32_t) ((NVIC-&gt;ISPR[(uint32_t)(IRQn) &gt;&gt; 5] &amp; (1 &lt;&lt; ((uint32_t)(IRQn) &amp; 0x1F)))?1:0)); /* Return 1 if pending else 0 */
+}
+
+/**
+ * @brief  Set the pending bit for an external interrupt
+ * 
+ * @param  IRQn_Type IRQn is the Number of the interrupt
+ * @return none
+ *
+ * Set the pending bit for the specified interrupt.
+ * The interrupt number cannot be a negative value.
+ */
+static __INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
+{
+  NVIC-&gt;ISPR[((uint32_t)(IRQn) &gt;&gt; 5)] = (1 &lt;&lt; ((uint32_t)(IRQn) &amp; 0x1F)); /* set interrupt pending */
+}
+
+/**
+ * @brief  Clear the pending bit for an external interrupt
+ *
+ * @param  IRQn_Type IRQn is the Number of the interrupt
+ * @return none
+ *
+ * Clear the pending bit for the specified interrupt. 
+ * The interrupt number cannot be a negative value.
+ */
+static __INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
+{
+  NVIC-&gt;ICPR[((uint32_t)(IRQn) &gt;&gt; 5)] = (1 &lt;&lt; ((uint32_t)(IRQn) &amp; 0x1F)); /* Clear pending interrupt */
+}
+
+/**
+ * @brief  Read the active bit for an external interrupt
+ *
+ * @param  IRQn_Type  IRQn is the Number of the interrupt
+ * @return uint32_t   1 if active else 0
+ *
+ * Read the active register in NVIC and returns 1 if its status is active, 
+ * otherwise it returns 0.
+ */
+static __INLINE uint32_t NVIC_GetActive(IRQn_Type IRQn)
+{
+  return((uint32_t)((NVIC-&gt;IABR[(uint32_t)(IRQn) &gt;&gt; 5] &amp; (1 &lt;&lt; ((uint32_t)(IRQn) &amp; 0x1F)))?1:0)); /* Return 1 if active else 0 */
+}
+
+/**
+ * @brief  Set the priority for an interrupt
+ *
+ * @param  IRQn_Type IRQn is the Number of the interrupt
+ * @param  priority is the priority for the interrupt
+ * @return none
+ *
+ * Set the priority for the specified interrupt. The interrupt 
+ * number can be positive to specify an external (device specific) 
+ * interrupt, or negative to specify an internal (core) interrupt. \n
+ *
+ * Note: The priority cannot be set for every core interrupt.
+ */
+static __INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
+{
+  if(IRQn &lt; 0) {
+    SCB-&gt;SHP[((uint32_t)(IRQn) &amp; 0xF)-4] = ((priority &lt;&lt; (8 - __NVIC_PRIO_BITS)) &amp; 0xff); } /* set Priority for Cortex-M3 System Interrupts */
+  else {
+    NVIC-&gt;IP[(uint32_t)(IRQn)] = ((priority &lt;&lt; (8 - __NVIC_PRIO_BITS)) &amp; 0xff);    }        /* set Priority for device specific Interrupts      */
+}
+
+/**
+ * @brief  Read the priority for an interrupt
+ *
+ * @param  IRQn_Type IRQn is the Number of the interrupt
+ * @return uint32_t  priority is the priority for the interrupt
+ *
+ * Read the priority for the specified interrupt. The interrupt 
+ * number can be positive to specify an external (device specific) 
+ * interrupt, or negative to specify an internal (core) interrupt.
+ *
+ * The returned priority value is automatically aligned to the implemented
+ * priority bits of the microcontroller.
+ *
+ * Note: The priority cannot be set for every core interrupt.
+ */
+static __INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
+{
+
+  if(IRQn &lt; 0) {
+    return((uint32_t)(SCB-&gt;SHP[((uint32_t)(IRQn) &amp; 0xF)-4] &gt;&gt; (8 - __NVIC_PRIO_BITS)));  } /* get priority for Cortex-M3 system interrupts */
+  else {
+    return((uint32_t)(NVIC-&gt;IP[(uint32_t)(IRQn)]           &gt;&gt; (8 - __NVIC_PRIO_BITS)));  } /* get priority for device specific interrupts  */
+}
+
+
+/**
+ * @brief  Encode the priority for an interrupt
+ *
+ * @param  uint32_t PriorityGroup   is the used priority group
+ * @param  uint32_t PreemptPriority is the preemptive priority value (starting from 0)
+ * @param  uint32_t SubPriority     is the sub priority value (starting from 0)
+ * @return uint32_t                    the priority for the interrupt
+ *
+ * Encode the priority for an interrupt with the given priority group,
+ * preemptive priority value and sub priority value.
+ * In case of a conflict between priority grouping and available
+ * priority bits (__NVIC_PRIO_BITS) the samllest possible priority group is set.
+ *
+ * The returned priority value can be used for NVIC_SetPriority(...) function
+ */
+static __INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
+{
+  uint32_t PriorityGroupTmp = (PriorityGroup &amp; 0x07);                         /* only values 0..7 are used          */
+  uint32_t PreemptPriorityBits;
+  uint32_t SubPriorityBits;
+
+  PreemptPriorityBits = ((7 - PriorityGroupTmp) &gt; __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;
+  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) &lt; 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;
+ 
+  return (
+           ((PreemptPriority &amp; ((1 &lt;&lt; (PreemptPriorityBits)) - 1)) &lt;&lt; SubPriorityBits) |
+           ((SubPriority     &amp; ((1 &lt;&lt; (SubPriorityBits    )) - 1)))
+         );
+}
+
+
+/**
+ * @brief  Decode the priority of an interrupt
+ *
+ * @param  uint32_t   Priority       the priority for the interrupt
+ * @param  uint32_t   PrioGroup   is the used priority group
+ * @param  uint32_t* pPreemptPrio is the preemptive priority value (starting from 0)
+ * @param  uint32_t* pSubPrio     is the sub priority value (starting from 0)
+ * @return none
+ *
+ * Decode an interrupt priority value with the given priority group to 
+ * preemptive priority value and sub priority value.
+ * In case of a conflict between priority grouping and available
+ * priority bits (__NVIC_PRIO_BITS) the samllest possible priority group is set.
+ *
+ * The priority value can be retrieved with NVIC_GetPriority(...) function
+ */
+static __INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* pPreemptPriority, uint32_t* pSubPriority)
+{
+  uint32_t PriorityGroupTmp = (PriorityGroup &amp; 0x07);                         /* only values 0..7 are used          */
+  uint32_t PreemptPriorityBits;
+  uint32_t SubPriorityBits;
+
+  PreemptPriorityBits = ((7 - PriorityGroupTmp) &gt; __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;
+  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) &lt; 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;
+  
+  *pPreemptPriority = (Priority &gt;&gt; SubPriorityBits) &amp; ((1 &lt;&lt; (PreemptPriorityBits)) - 1);
+  *pSubPriority     = (Priority                   ) &amp; ((1 &lt;&lt; (SubPriorityBits    )) - 1);
+}
+
+
+
+/* ##################################    SysTick function  ############################################ */
+
+#if (!defined (__Vendor_SysTickConfig)) || (__Vendor_SysTickConfig == 0)
+
+/* SysTick constants */
+#define SYSTICK_ENABLE              0                                          /* Config-Bit to start or stop the SysTick Timer                         */
+#define SYSTICK_TICKINT             1                                          /* Config-Bit to enable or disable the SysTick interrupt                 */
+#define SYSTICK_CLKSOURCE           2                                          /* Clocksource has the offset 2 in SysTick Control and Status Register   */
+#define SYSTICK_MAXCOUNT       ((1&lt;&lt;24) -1)                                    /* SysTick MaxCount                                                      */
+
+/**
+ * @brief  Initialize and start the SysTick counter and its interrupt.
+ *
+ * @param  uint32_t ticks is the number of ticks between two interrupts
+ * @return  none
+ *
+ * Initialise the system tick timer and its interrupt and start the
+ * system tick timer / counter in free running mode to generate 
+ * periodical interrupts.
+ */
+static __INLINE uint32_t SysTick_Config(uint32_t ticks)
+{ 
+  if (ticks &gt; SYSTICK_MAXCOUNT)  return (1);                                             /* Reload value impossible */
+
+  SysTick-&gt;LOAD  =  (ticks &amp; SYSTICK_MAXCOUNT) - 1;                                      /* set reload register */
+  NVIC_SetPriority (SysTick_IRQn, (1&lt;&lt;__NVIC_PRIO_BITS) - 1);                            /* set Priority for Cortex-M0 System Interrupts */
+  SysTick-&gt;VAL   =  (0x00);                                                              /* Load the SysTick Counter Value */
+  SysTick-&gt;CTRL = (1 &lt;&lt; SYSTICK_CLKSOURCE) | (1&lt;&lt;SYSTICK_ENABLE) | (1&lt;&lt;SYSTICK_TICKINT); /* Enable SysTick IRQ and SysTick Timer */
+  return (0);                                                                            /* Function successful */
+}
+
+#endif
+
+
+
+
+
+/* ##################################    Reset function  ############################################ */
+
+/**
+ * @brief  Initiate a system reset request.
+ *
+ * @param   none
+ * @return  none
+ *
+ * Initialize a system reset request to reset the MCU
+ */
+static __INLINE void NVIC_SystemReset(void)
+{
+  SCB-&gt;AIRCR  = (NVIC_AIRCR_VECTKEY | (SCB-&gt;AIRCR &amp; (0x700)) | (1&lt;&lt;NVIC_SYSRESETREQ)); /* Keep priority group unchanged */
+  __DSB();                                                                             /* Ensure completion of memory access */              
+  while(1);                                                                            /* wait until reset */
+}
+
+
+/* ##################################    Debug Output  function  ############################################ */
+
+
+/**
+ * @brief  Outputs a character via the ITM channel 0
+ *
+ * @param   uint32_t character to output
+ * @return  uint32_t input character
+ *
+ * The function outputs a character via the ITM channel 0. 
+ * The function returns when no debugger is connected that has booked the output.  
+ * It is blocking when a debugger is connected, but the previous character send is not transmitted. 
+ */
+static __INLINE uint32_t ITM_SendChar (uint32_t ch)
+{
+  if (ch == '\n') ITM_SendChar('\r');
+  
+  if ((CoreDebug-&gt;DEMCR &amp; CoreDebug_DEMCR_TRCENA)  &amp;&amp;
+      (ITM-&gt;TCR &amp; ITM_TCR_ITMENA)                  &amp;&amp;
+      (ITM-&gt;TER &amp; (1UL &lt;&lt; 0))  ) 
+  {
+    while (ITM-&gt;PORT[0].u32 == 0);
+    ITM-&gt;PORT[0].u8 = (uint8_t) ch;
+  }  
+  return (ch);
+}
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __CM3_CORE_H__ */
+
+/*lint -restore */


Property changes on: trunk/src/platform/stm32/core_cm3.h
___________________________________________________________________
Name: svn:executable
   + *

Modified: trunk/src/platform/stm32/fonts.h
===================================================================
--- trunk/src/platform/stm32/fonts.h	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/fonts.h	2009-07-08 23:39:34 UTC (rev 354)
@@ -18,7 +18,7 @@
 #define __FONTS_H
 
 /* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_lib.h&quot;
+#include &quot;stm32f10x.h&quot;
 
 /* Exported types ------------------------------------------------------------*/
      /* ASCII Table: each character is 16 column (16dots large) 

Modified: trunk/src/platform/stm32/lcd.h
===================================================================
--- trunk/src/platform/stm32/lcd.h	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/lcd.h	2009-07-08 23:39:34 UTC (rev 354)
@@ -19,7 +19,7 @@
 #define __LCD_H
 
 /* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_lib.h&quot;
+#include &quot;stm32f10x.h&quot;
 
 extern void Delay(u32 nCount);
 

Modified: trunk/src/platform/stm32/platform.c
===================================================================
--- trunk/src/platform/stm32/platform.c	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/platform.c	2009-07-08 23:39:34 UTC (rev 354)
@@ -19,22 +19,7 @@
 #include &quot;utils.h&quot;
 
 // Platform specific includes
-#include &quot;stm32f10x_lib.h&quot;
-#include &quot;stm32f10x_map.h&quot;
-#include &quot;stm32f10x_type.h&quot;
-#include &quot;stm32f10x_tim.h&quot;
-#include &quot;stm32f10x_rcc.h&quot;
-#include &quot;stm32f10x_nvic.h&quot;
-#include &quot;stm32f10x_dbgmcu.h&quot;
-#include &quot;stm32f10x_gpio.h&quot;
-#include &quot;stm32f10x_adc.h&quot;
-#include &quot;stm32f10x_pwr.h&quot;
-#include &quot;stm32f10x_usart.h&quot;
-#include &quot;stm32f10x_spi.h&quot;
-#include &quot;stm32f10x_systick.h&quot;
-#include &quot;stm32f10x_flash.h&quot;
-#include &quot;stm32f10x_conf.h&quot;
-#include &quot;systick.h&quot;
+#include &quot;stm32f10x.h&quot;
 
 // Clock data
 // IMPORTANT: if you change these, make sure to modify RCC_Configuration() too!
@@ -50,6 +35,7 @@
 static void NVIC_Configuration(void);
 
 static void timers_init();
+static void pwms_init();
 static void uarts_init();
 static void spis_init();
 static void pios_init();
@@ -65,7 +51,7 @@
   NVIC_Configuration();
 
   // Enable SysTick timer.
-  SysTick_Config();
+  SysTick_Config(720000);
 
   // Setup PIO
   pios_init();
@@ -79,6 +65,9 @@
   // Setup timers
   timers_init();
   
+  // Setup PWMs
+  pwms_init();
+  
   // Setup ADCs
   adcs_init();
   
@@ -105,53 +94,8 @@
 *******************************************************************************/
 static void RCC_Configuration(void)
 {
-  ErrorStatus HSEStartUpStatus;
-  /* RCC system reset(for debug purpose) */
-  RCC_DeInit();
+  SystemInit();
 
-  /* Enable HSE */
-  RCC_HSEConfig(RCC_HSE_ON);
-
-  /* Wait till HSE is ready */
-  HSEStartUpStatus = RCC_WaitForHSEStartUp();
-
-  if(HSEStartUpStatus == SUCCESS)
-  {
-    /* Enable Prefetch Buffer */
-    FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);
-
-    /* Flash 2 wait state */
-    FLASH_SetLatency(FLASH_Latency_2);
-
-    /* HCLK = SYSCLK */
-    RCC_HCLKConfig(RCC_SYSCLK_Div1);
-
-    /* PCLK2 = HCLK */
-    RCC_PCLK2Config(RCC_HCLK_Div1);
-
-    /* PCLK1 = HCLK/2 */
-    RCC_PCLK1Config(RCC_HCLK_Div2);
-
-    /* PLLCLK = 8MHz * 9 = 72 MHz */
-    RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_9);
-
-    /* Enable PLL */
-    RCC_PLLCmd(ENABLE);
-
-    /* Wait till PLL is ready */
-    while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET)
-    {
-    }
-
-    /* Select PLL as system clock source */
-    RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);
-
-    /* Wait till PLL is used as system clock source */
-    while(RCC_GetSYSCLKSource() != 0x08)
-    {
-    }
-  }
-
   RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);
 }
 
@@ -173,7 +117,6 @@
 {
   NVIC_InitTypeDef nvic_init_structure;
   
-  NVIC_DeInit();
 
 #ifdef  VECT_TAB_RAM
   /* Set the Vector Table base location at 0x20000000 */
@@ -186,11 +129,8 @@
   /* Configure the NVIC Preemption Priority Bits */
   NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
 
-  /* Configure the SysTick handler priority */
-  NVIC_SystemHandlerPriorityConfig(SystemHandler_SysTick, 0, 0);
-
 #ifdef BUILD_ADC  
-  nvic_init_structure_adc.NVIC_IRQChannel = DMA1_Channel1_IRQChannel; 
+  nvic_init_structure_adc.NVIC_IRQChannel = DMA1_Channel1_IRQn; 
   nvic_init_structure_adc.NVIC_IRQChannelPreemptionPriority = 1; 
   nvic_init_structure_adc.NVIC_IRQChannelSubPriority = 3; 
   nvic_init_structure_adc.NVIC_IRQChannelCmd = DISABLE; 
@@ -199,7 +139,7 @@
 
 #if defined( BUF_ENABLE_UART ) &amp;&amp; defined( CON_BUF_SIZE )
   /* Enable the USART1 Interrupt */
-  nvic_init_structure.NVIC_IRQChannel = USART1_IRQChannel;
+  nvic_init_structure.NVIC_IRQChannel = USART1_IRQn;
   nvic_init_structure.NVIC_IRQChannelSubPriority = 0;
   nvic_init_structure.NVIC_IRQChannelCmd = ENABLE;
   NVIC_Init(&amp;nvic_init_structure);
@@ -313,7 +253,7 @@
 void cans_init( void )
 {
   /* CAN Periph clock enable */
-  RCC_APB1PeriphClockCmd(RCC_APB1Periph_CAN, ENABLE);
+  RCC_APB1PeriphClockCmd(RCC_APB1Periph_CAN1, ENABLE);
 }
 
 /*       BS1 BS2 SJW Pre
@@ -347,7 +287,7 @@
   GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   GPIO_Init( GPIOB, &amp;GPIO_InitStructure );
   
-  GPIO_PinRemapConfig( GPIO_Remap1_CAN, ENABLE );
+  GPIO_PinRemapConfig( GPIO_Remap1_CAN1, ENABLE );
 
   // Select baud rate up to requested rate, except for below min, where min is selected
   if ( clock &gt;= can_baud_rate[ CAN_BAUD_COUNT - 1 ] ) // round down to peak rate if &gt;= peak rate
@@ -362,8 +302,8 @@
   }
 
   /* Deinitialize CAN Peripheral */
-  CAN_DeInit();
-  CAN_StructInit(&amp;CAN_InitStructure);
+  CAN_DeInit( CAN1 );
+  CAN_StructInit( &amp;CAN_InitStructure );
 
   /* CAN cell init */
   CAN_InitStructure.CAN_TTCM=DISABLE;
@@ -377,7 +317,7 @@
   CAN_InitStructure.CAN_BS1=can_baud_bs1[ cbaudidx ];
   CAN_InitStructure.CAN_BS2=can_baud_bs2[ cbaudidx ];
   CAN_InitStructure.CAN_Prescaler=can_baud_pre[ cbaudidx ];
-  CAN_Init( &amp;CAN_InitStructure );
+  CAN_Init( CAN1, &amp;CAN_InitStructure );
 
   /* CAN filter init */
   CAN_FilterInitStructure.CAN_FilterNumber=0;
@@ -435,7 +375,7 @@
   d = ( char * )TxMessage.Data;
   DUFF_DEVICE_8( len,  *d++ = *s++ );
   
-  CAN_Transmit( &amp;TxMessage );
+  CAN_Transmit( CAN1, &amp;TxMessage );
 }
 
 void USB_LP_CAN_RX0_IRQHandler(void)
@@ -472,14 +412,14 @@
   u32 i = 0;
   
   // Check up to 256 times for message
-  while( ( CAN_MessagePending(CAN_FIFO0) &lt; 1 ) &amp;&amp; ( i++ != 0xFF ) );
+  while( ( CAN_MessagePending(CAN1, CAN_FIFO0) &lt; 1 ) &amp;&amp; ( i++ != 0xFF ) );
     
   RxMessage.StdId=0x00;
   RxMessage.IDE=CAN_ID_STD;
   RxMessage.DLC=0;
   RxMessage.Data[0]=0x00;
   RxMessage.Data[1]=0x00;
-  CAN_Receive(CAN_FIFO0, &amp;RxMessage);
+  CAN_Receive(CAN1, CAN_FIFO0, &amp;RxMessage);
   
   if( RxMessage.IDE == CAN_ID_STD )
   {
@@ -759,7 +699,6 @@
     TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
     TIM_TimeBaseStructure.TIM_RepetitionCounter = 0x0000;
     TIM_TimeBaseInit( timer[ i ], &amp;TIM_TimeBaseStructure );
-    TIM_Cmd( timer[ i ], ENABLE );
   }
 }
 
@@ -811,6 +750,7 @@
   {
     case PLATFORM_TIMER_OP_START:
       TIM_SetCounter( ptimer, 0 );
+      TIM_Cmd( ptimer, ENABLE );
       for( dummy = 0; dummy &lt; 200; dummy ++ );
       break;
 
@@ -838,6 +778,133 @@
   return res;
 }
 
+
+// ****************************************************************************
+// PWMs
+// Using Timer 8 (5 in eLua)
+
+#define PWM_TIMER_ID 5
+
+static const u16 pwm_gpio_pins[] = { GPIO_Pin_6, GPIO_Pin_7, GPIO_Pin_8, GPIO_Pin_9 };
+
+static void pwms_init()
+{
+  // 
+}
+
+// Helper function: return the PWM clock
+// NOTE: Can't find a function to query for the period set for the timer, therefore using the struct.
+//       This may require adjustment if driver libraries are updated.
+static u32 platform_pwm_get_clock()
+{
+  return ( platform_s_timer_op( PWM_TIMER_ID, PLATFORM_TIMER_OP_GET_CLOCK, 0 ) / ( timer[ PWM_TIMER_ID ]-&gt;ARR + 1 ) );
+}
+
+// Helper function: set the PWM clock
+static u32 platform_pwm_set_clock( u32 clock )
+{
+  TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
+  TIM_TypeDef* ptimer = timer[ PWM_TIMER_ID ];
+  
+  /* Time base configuration */
+  TIM_TimeBaseStructure.TIM_Period = 999;  //(TIM_GET_BASE_CLK( PWM_TIMER_ID ) / clock) - 1;
+  TIM_TimeBaseStructure.TIM_Prescaler = 0;
+  TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1;
+  TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Down;
+  TIM_TimeBaseStructure.TIM_RepetitionCounter = 0x0000;
+  TIM_TimeBaseInit( ptimer, &amp;TIM_TimeBaseStructure );
+    
+  return ( TIM_GET_BASE_CLK( PWM_TIMER_ID ) / ( TIM_TimeBaseStructure.TIM_Period + 1 ) ) ;
+}
+
+u32 platform_pwm_setup( unsigned id, u32 frequency, unsigned duty )
+{
+  TIM_OCInitTypeDef  TIM_OCInitStructure;
+  TIM_TypeDef* ptimer = timer[ PWM_TIMER_ID ];
+  TIM_BDTRInitTypeDef TIM_BDTRInitStructure;
+  u32 clock;
+  
+  TIM_Cmd(ptimer, DISABLE);
+  
+  clock = platform_pwm_set_clock( frequency );
+  
+  TIM_Cmd( ptimer, ENABLE );
+  
+  // Set up PIO for output
+  platform_pio_op( 2, pwm_gpio_pins[ id ], PLATFORM_IO_PIN_DIR_OUTPUT );
+  
+  /* PWM Mode configuration */  
+  TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;
+  TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
+  TIM_OCInitStructure.TIM_OutputNState = TIM_OutputNState_Disable;
+  TIM_OCInitStructure.TIM_Pulse = 125; //( u16 )( duty / 100 * ( timer[ PWM_TIMER_ID ]-&gt;ARR + 1 ) )
+  TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
+  TIM_OCInitStructure.TIM_OCIdleState = TIM_OCIdleState_Set;
+  
+  switch ( id )
+  {
+    case 0:
+      TIM_OC1Init( ptimer, &amp;TIM_OCInitStructure );
+      TIM_OC1PreloadConfig( ptimer, TIM_OCPreload_Enable );
+      clock = 0;
+      break;
+    case 1:
+      TIM_OC2Init( ptimer, &amp;TIM_OCInitStructure );
+      TIM_OC2PreloadConfig( ptimer, TIM_OCPreload_Enable );
+      clock = 1;
+      break;
+    case 2:
+      TIM_OC3Init( ptimer, &amp;TIM_OCInitStructure );
+      TIM_OC3PreloadConfig( ptimer, TIM_OCPreload_Enable );
+      clock = 2;
+      break;
+    case 3:
+      TIM_OC4Init( ptimer, &amp;TIM_OCInitStructure );
+      TIM_OC4PreloadConfig( ptimer, TIM_OCPreload_Enable ) ;
+      clock = 3;
+      break;
+    default:
+      return 4;
+  }
+    
+  TIM_ARRPreloadConfig( ptimer, ENABLE );
+
+  TIM_SelectOCxM( ptimer, TIM_Channel_1, TIM_OCMode_PWM1 );
+
+  TIM_CtrlPWMOutputs(ptimer, ENABLE);  
+  ptimer-&gt;EGR |= TIM_EventSource_Update;
+      
+  return clock;
+}
+
+u32 platform_pwm_op( unsigned id, int op, u32 data )
+{
+  u32 res = 0;
+
+  switch( op )
+  {
+    case PLATFORM_PWM_OP_SET_CLOCK:
+      res = platform_pwm_set_clock( data );
+      break;
+
+    case PLATFORM_PWM_OP_GET_CLOCK:
+      res = platform_pwm_get_clock();
+      break;
+
+    case PLATFORM_PWM_OP_START:
+      timer[ PWM_TIMER_ID ]-&gt;CCER |= ( ( u16 )1 &lt;&lt; 4*id );
+      break;
+
+    case PLATFORM_PWM_OP_STOP:
+      timer[ PWM_TIMER_ID ]-&gt;CCER &amp;= ~( ( u16 )1 &lt;&lt; 4*id );
+      break;
+  }
+
+  return res;
+}
+
+
+
 // *****************************************************************************
 // CPU specific functions
  

Modified: trunk/src/platform/stm32/platform_conf.h
===================================================================
--- trunk/src/platform/stm32/platform_conf.h	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/platform_conf.h	2009-07-08 23:39:34 UTC (rev 354)
@@ -6,7 +6,7 @@
 #include &quot;auxmods.h&quot;
 #include &quot;type.h&quot;
 #include &quot;stacks.h&quot;
-#include &quot;stm32f10x_lib.h&quot;
+#include &quot;stm32f10x.h&quot;
 
 // *****************************************************************************
 // Define here what components you want for this platform
@@ -55,6 +55,7 @@
   _ROM( AUXLIB_TMR, luaopen_tmr, tmr_map )\
   _ROM( AUXLIB_ADC, luaopen_adc, adc_map )\
   _ROM( AUXLIB_CAN, luaopen_can, can_map )\
+  _ROM( AUXLIB_PWM, luaopen_pwm, pwm_map )\
 	_ROM( AUXLIB_LUARPC, luaopen_luarpc, rpc_map )\
   LCDLINE\
   _ROM( LUA_MATHLIBNAME, luaopen_math, math_map )
@@ -95,7 +96,7 @@
 #define NUM_SPI               2
 #define NUM_UART              5
 #define NUM_TIMER             6
-#define NUM_PWM               0
+#define NUM_PWM               4
 #define NUM_ADC               16
 #define NUM_CAN               1
 

Modified: trunk/src/platform/stm32/stm32.ld
===================================================================
--- trunk/src/platform/stm32/stm32.ld	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/stm32.ld	2009-07-08 23:39:34 UTC (rev 354)
@@ -22,6 +22,7 @@
         *(.gnu.linkonce.r.*)
         . = ALIGN(4);
         _etext = .;
+		_sidata = _etext;
         PROVIDE(etext = .);   
      		_fini = . ;
 				*(.fini)
@@ -31,7 +32,7 @@
     .data : AT (_etext)
     {
         . = ALIGN(4);
-        _data = .;
+        _sdata = .;
         *(.ramfunc .ramfunc.* .fastrun .fastrun.*)
         *(.data .data.*)
         *(.gnu.linkonce.d.*)
@@ -52,7 +53,9 @@
 		__exidx_end = .;
 		
     .bss (NOLOAD) : {
-        _bss = .;
+		. = ALIGN(4);
+        /* This is used by the startup in order to initialize the .bss secion */
+        _sbss = .;
         *(.bss .bss.*)
         *(.gnu.linkonce.b.*)
         *(COMMON)

Modified: trunk/src/platform/stm32/stm32f10x_conf.h
===================================================================
--- trunk/src/platform/stm32/stm32f10x_conf.h	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/stm32f10x_conf.h	2009-07-08 23:39:34 UTC (rev 354)
@@ -1,174 +1,76 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_conf.h
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : Library configuration file.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
+/**
+  ******************************************************************************
+  * @file    Project/Template/stm32f10x_conf.h 
+  * @author  MCD Application Team
+  * @version V3.1.0
+  * @date    06/19/2009
+  * @brief   Library configuration file.
+  ******************************************************************************
+  * @copy
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * &lt;h2&gt;&lt;center&gt;&copy; COPYRIGHT 2009 STMicroelectronics&lt;/center&gt;&lt;/h2&gt;
+  */ 
 
 /* Define to prevent recursive inclusion -------------------------------------*/
 #ifndef __STM32F10x_CONF_H
 #define __STM32F10x_CONF_H
 
 /* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_type.h&quot;
+/* Uncomment the line below to enable peripheral header file inclusion */
+#include &quot;stm32f10x_adc.h&quot; 
+/* #include &quot;stm32f10x_bkp.h&quot; */
+#include &quot;stm32f10x_can.h&quot; 
+/* #include &quot;stm32f10x_crc.h&quot; */
+/* #include &quot;stm32f10x_dac.h&quot; */
+/* #include &quot;stm32f10x_dbgmcu.h&quot; */
+#include &quot;stm32f10x_dma.h&quot; 
+// #include &quot;stm32f10x_exti.h&quot;
+#include &quot;stm32f10x_flash.h&quot;
+#include &quot;stm32f10x_fsmc.h&quot;
+#include &quot;stm32f10x_gpio.h&quot;
+/* #include &quot;stm32f10x_i2c.h&quot; */
+/* #include &quot;stm32f10x_iwdg.h&quot; */
+/* #include &quot;stm32f10x_pwr.h&quot; */
+#include &quot;stm32f10x_rcc.h&quot;
+/* #include &quot;stm32f10x_rtc.h&quot; */
+/* #include &quot;stm32f10x_sdio.h&quot; */
+#include &quot;stm32f10x_spi.h&quot;
+#include &quot;stm32f10x_tim.h&quot; 
+#include &quot;stm32f10x_usart.h&quot;
+/* #include &quot;stm32f10x_wwdg.h&quot; */
+#include &quot;misc.h&quot; /* High level functions for NVIC and SysTick (add-on to CMSIS functions) */
 
 /* Exported types ------------------------------------------------------------*/
 /* Exported constants --------------------------------------------------------*/
-/* Uncomment the line below to compile the library in DEBUG mode, this will expanse
-   the &quot;assert_param&quot; macro in the firmware library code (see &quot;Exported macro&quot;
-   section below) */
-/* #define DEBUG    1*/
+/* Uncomment the line below to expanse the &quot;assert_param&quot; macro in the 
+   Standard Peripheral Library drivers code */
+/* #define USE_FULL_ASSERT    1 */
 
-/* Comment the line below to disable the specific peripheral inclusion */
-/************************************* ADC ************************************/
-#define _ADC
-#define _ADC1
-#define _ADC2
-#define _ADC3
-
-/************************************* BKP ************************************/
-#define _BKP 
-
-/************************************* CAN ************************************/
-#define _CAN
-
-/************************************* CRC ************************************/
-#define _CRC
-
-/************************************* DAC ************************************/
-#define _DAC
-
-/************************************* DBGMCU *********************************/
-#define _DBGMCU
-
-/************************************* DMA ************************************/
-#define _DMA
-#define _DMA1_Channel1
-#define _DMA1_Channel2
-#define _DMA1_Channel3
-#define _DMA1_Channel4
-#define _DMA1_Channel5
-#define _DMA1_Channel6
-#define _DMA1_Channel7
-#define _DMA2_Channel1
-#define _DMA2_Channel2
-#define _DMA2_Channel3
-#define _DMA2_Channel4
-#define _DMA2_Channel5
-
-/************************************* EXTI ***********************************/
-#define _EXTI
-
-/************************************* FLASH and Option Bytes *****************/
-#define _FLASH
-/* Uncomment the line below to enable FLASH program/erase/protections functions,
-   otherwise only FLASH configuration (latency, prefetch, half cycle) functions
-   are enabled */
-/* #define _FLASH_PROG */
-
-/************************************* FSMC ***********************************/
-#define _FSMC
-
-/************************************* GPIO ***********************************/
-#define _GPIO
-#define _GPIOA
-#define _GPIOB
-#define _GPIOC
-#define _GPIOD
-#define _GPIOE
-#define _GPIOF
-#define _GPIOG
-#define _AFIO
-
-/************************************* I2C ************************************/
-#define _I2C
-#define _I2C1
-#define _I2C2
-
-/************************************* IWDG ***********************************/
-#define _IWDG
-
-/************************************* NVIC ***********************************/
-#define _NVIC
-
-/************************************* PWR ************************************/
-#define _PWR
-
-/************************************* RCC ************************************/
-#define _RCC
-
-/************************************* RTC ************************************/
-#define _RTC
-
-/************************************* SDIO ***********************************/
-#define _SDIO
-
-/************************************* SPI ************************************/
-#define _SPI
-#define _SPI1
-#define _SPI2
-#define _SPI3
-
-/************************************* SysTick ********************************/
-#define _SysTick
-
-/************************************* TIM ************************************/
-#define _TIM
-#define _TIM1
-#define _TIM2
-#define _TIM3
-#define _TIM4
-#define _TIM5
-#define _TIM6
-#define _TIM7
-#define _TIM8
-
-/************************************* USART **********************************/
-#define _USART
-#define _USART1
-#define _USART2
-#define _USART3
-#define _UART4
-#define _UART5
-
-/************************************* WWDG ***********************************/
-#define _WWDG
-
-/* In the following line adjust the value of External High Speed oscillator (HSE)
-   used in your application */
-#define HSE_Value    ((u32)8000000) /* Value of the External oscillator in Hz*/
-
-/* In the following line adjust the External High Speed oscillator (HSE) Startup 
-   Timeout value */
-#define HSEStartUp_TimeOut    ((u16)0x0500) /* Time out for HSE start up */
-
 /* Exported macro ------------------------------------------------------------*/
-#ifdef  DEBUG
-/*******************************************************************************
-* Macro Name     : assert_param
-* Description    : The assert_param macro is used for function's parameters check.
-*                  It is used only if the library is compiled in DEBUG mode. 
-* Input          : - expr: If expr is false, it calls assert_failed function
-*                    which reports the name of the source file and the source
-*                    line number of the call that failed. 
-*                    If expr is true, it returns no value.
-* Return         : None
-*******************************************************************************/ 
-  #define assert_param(expr) ((expr) ? (void)0 : assert_failed((u8 *)__FILE__, __LINE__))
+#ifdef  USE_FULL_ASSERT
+
+/**
+  * @brief  The assert_param macro is used for function's parameters check.
+  * @param  expr: If expr is false, it calls assert_failed function
+  *   which reports the name of the source file and the source
+  *   line number of the call that failed. 
+  *   If expr is true, it returns no value.
+  * @retval None
+  */
+  #define assert_param(expr) ((expr) ? (void)0 : assert_failed((uint8_t *)__FILE__, __LINE__))
 /* Exported functions ------------------------------------------------------- */
-  void assert_failed(u8* file, u32 line);
+  void assert_failed(uint8_t* file, uint32_t line);
 #else
   #define assert_param(expr) ((void)0)
-#endif /* DEBUG */
+#endif /* USE_FULL_ASSERT */
 
 #endif /* __STM32F10x_CONF_H */
 
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
+/******************* (C) COPYRIGHT 2009 STMicroelectronics *****END OF FILE****/

Modified: trunk/src/platform/stm32/stm32f10x_it.c
===================================================================
--- trunk/src/platform/stm32/stm32f10x_it.c	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/stm32f10x_it.c	2009-07-08 23:39:34 UTC (rev 354)
@@ -1,24 +1,31 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_it.c
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : Main Interrupt Service Routines.
-*                      This file provides template for all exceptions handler
-*                      and peripherals interrupt service routine.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
+/**
+  ******************************************************************************
+  * @file    Project/Template/stm32f10x_it.c 
+  * @author  MCD Application Team
+  * @version V3.1.0
+  * @date    06/19/2009
+  * @brief   Main Interrupt Service Routines.
+  *          This file provides template for all exceptions handler and 
+  *          peripherals interrupt service routine.
+  ******************************************************************************
+  * @copy
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * &lt;h2&gt;&lt;center&gt;&copy; COPYRIGHT 2009 STMicroelectronics&lt;/center&gt;&lt;/h2&gt;
+  */ 
 
 /* Includes ------------------------------------------------------------------*/
 #include &quot;stm32f10x_it.h&quot;
-#include &quot;platform.h&quot;
 #include &quot;systick.h&quot;
+/** @addtogroup Template_Project
+  * @{
+  */
 
 /* Private typedef -----------------------------------------------------------*/
 /* Private define ------------------------------------------------------------*/
@@ -27,801 +34,145 @@
 /* Private function prototypes -----------------------------------------------*/
 /* Private functions ---------------------------------------------------------*/
 
-/*******************************************************************************
-* Function Name  : NMIException
-* Description    : This function handles NMI exception.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void NMIException(void)
-{
-}
+/******************************************************************************/
+/*            Cortex-M3 Processor Exceptions Handlers                         */
+/******************************************************************************/
 
-/*******************************************************************************
-* Function Name  : HardFaultException
-* Description    : This function handles Hard Fault exception.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void HardFaultException(void)
+/**
+  * @brief   This function handles NMI exception.
+  * @param  None
+  * @retval None
+  */
+void NMI_Handler(void)
 {
-  /* Go to infinite loop when Hard Fault exception occurs */
-  while (1)
-  {
-    platform_uart_send(0, ' ');
-    platform_uart_send(0, 'H');
-    platform_uart_send(0, 'F');
-    platform_uart_send(0, '!');
-  }
 }
 
-/*******************************************************************************
-* Function Name  : MemManageException
-* Description    : This function handles Memory Manage exception.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void MemManageException(void)
+/**
+  * @brief  This function handles Hard Fault exception.
+  * @param  None
+  * @retval None
+  */
+void HardFault_Handler(void)
 {
-  /* Go to infinite loop when Memory Manage exception occurs */
-  while (1)
-  {
-    platform_uart_send(0, ' ');
-    platform_uart_send(0, 'M');
-    platform_uart_send(0, 'M');
-    platform_uart_send(0, '!');
-  }
-}
-
-/*******************************************************************************
-* Function Name  : BusFaultException
-* Description    : This function handles Bus Fault exception.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void BusFaultException(void)
+/* Go to infinite loop when Hard Fault exception occurs */
+while (1)
 {
-  /* Go to infinite loop when Bus Fault exception occurs */
-  while (1)
-  {
-    platform_uart_send(0, ' ');
-    platform_uart_send(0, 'B');
-    platform_uart_send(0, 'F');
-    platform_uart_send(0, '!');
-  }
+  platform_uart_send(0, ' ');
+  platform_uart_send(0, 'H');
+  platform_uart_send(0, 'F');
+  platform_uart_send(0, '!');
 }
-
-/*******************************************************************************
-* Function Name  : UsageFaultException
-* Description    : This function handles Usage Fault exception.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void UsageFaultException(void)
-{
-  /* Go to infinite loop when Usage Fault exception occurs */
-  while (1)
-  {
-    platform_uart_send(0, ' ');
-    platform_uart_send(0, 'U');
-    platform_uart_send(0, 'F');
-    platform_uart_send(0, '!');
-  }
 }
 
-/*******************************************************************************
-* Function Name  : DebugMonitor
-* Description    : This function handles Debug Monitor exception.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void DebugMonitor(void)
+/**
+  * @brief  This function handles Memory Manage exception.
+  * @param  None
+  * @retval None
+  */
+void MemManage_Handler(void)
 {
-}
-
-/*******************************************************************************
-* Function Name  : SVCHandler
-* Description    : This function handles SVCall exception.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SVCHandler(void)
+/* Go to infinite loop when Memory Manage exception occurs */
+while (1)
 {
+  platform_uart_send(0, ' ');
+  platform_uart_send(0, 'M');
+  platform_uart_send(0, 'M');
+  platform_uart_send(0, '!');
 }
-
-/*******************************************************************************
-* Function Name  : PendSVC
-* Description    : This function handles PendSVC exception.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void PendSVC(void)
-{
 }
 
-/*******************************************************************************
-* Function Name  : SysTickHandler
-* Description    : This function handles SysTick Handler.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SysTickHandler(void)
+/**
+  * @brief  This function handles Bus Fault exception.
+  * @param  None
+  * @retval None
+  */
+void BusFault_Handler(void)
 {
-  /* Decrement the TimingDelay variable */
-  Decrement_TimingDelay();
-}
-
-/*******************************************************************************
-* Function Name  : WWDG_IRQHandler
-* Description    : This function handles WWDG interrupt request.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void WWDG_IRQHandler(void)
+/* Go to infinite loop when Bus Fault exception occurs */
+while (1)
 {
+  platform_uart_send(0, ' ');
+  platform_uart_send(0, 'B');
+  platform_uart_send(0, 'F');
+  platform_uart_send(0, '!');
 }
-
-/*******************************************************************************
-* Function Name  : PVD_IRQHandler
-* Description    : This function handles PVD interrupt request.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void PVD_IRQHandler(void)
-{
 }
 
-/*******************************************************************************
-* Function Name  : TAMPER_IRQHandler
-* Description    : This function handles Tamper interrupt request. 
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TAMPER_IRQHandler(void)
+/**
+  * @brief  This function handles Usage Fault exception.
+  * @param  None
+  * @retval None
+  */
+void UsageFault_Handler(void)
 {
-}
-
-/*******************************************************************************
-* Function Name  : RTC_IRQHandler
-* Description    : This function handles RTC global interrupt request.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RTC_IRQHandler(void)
+/* Go to infinite loop when Usage Fault exception occurs */
+while (1)
 {
+  platform_uart_send(0, ' ');
+  platform_uart_send(0, 'U');
+  platform_uart_send(0, 'F');
+  platform_uart_send(0, '!');
 }
-
-/*******************************************************************************
-* Function Name  : FLASH_IRQHandler
-* Description    : This function handles Flash interrupt request.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void FLASH_IRQHandler(void)
-{
 }
 
-/*******************************************************************************
-* Function Name  : RCC_IRQHandler
-* Description    : This function handles RCC interrupt request. 
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RCC_IRQHandler(void)
+/**
+  * @brief  This function handles SVCall exception.
+  * @param  None
+  * @retval None
+  */
+void SVC_Handler(void)
 {
 }
 
-/*******************************************************************************
-* Function Name  : EXTI0_IRQHandler
-* Description    : This function handles External interrupt Line 0 request.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void EXTI0_IRQHandler(void)
+/**
+  * @brief  This function handles Debug Monitor exception.
+  * @param  None
+  * @retval None
+  */
+void DebugMon_Handler(void)
 {
 }
 
-/*******************************************************************************
-* Function Name  : EXTI1_IRQHandler
-* Description    : This function handles External interrupt Line 1 request.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void EXTI1_IRQHandler(void)
+/**
+  * @brief  This function handles PendSVC exception.
+  * @param  None
+  * @retval None
+  */
+void PendSV_Handler(void)
 {
 }
 
-/*******************************************************************************
-* Function Name  : EXTI2_IRQHandler
-* Description    : This function handles External interrupt Line 2 request.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void EXTI2_IRQHandler(void)
+/**
+  * @brief  This function handles SysTick Handler.
+  * @param  None
+  * @retval None
+  */
+void SysTick_Handler(void)
 {
+	/* Decrement the TimingDelay variable */
+	Decrement_TimingDelay();
 }
 
-/*******************************************************************************
-* Function Name  : EXTI3_IRQHandler
-* Description    : This function handles External interrupt Line 3 request.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void EXTI3_IRQHandler(void)
-{
-}
+/******************************************************************************/
+/*                 STM32F10x Peripherals Interrupt Handlers                   */
+/*  Add here the Interrupt Handler for the used peripheral(s) (PPP), for the  */
+/*  available peripheral interrupt handler's name please refer to the startup */
+/*  file (startup_stm32f10x_xx.s).                                            */
+/******************************************************************************/
 
-/*******************************************************************************
-* Function Name  : EXTI4_IRQHandler
-* Description    : This function handles External interrupt Line 4 request.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void EXTI4_IRQHandler(void)
+/**
+  * @brief  This function handles PPP interrupt request.
+  * @param  None
+  * @retval None
+  */
+/*void PPP_IRQHandler(void)
 {
-}
+}*/
 
-/*******************************************************************************
-* Function Name  : DMA1_Channel1_IRQHandler
-* Description    : This function handles DMA1 Channel 1 interrupt request.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
+/**
+  * @}
+  */ 
 extern void DMA1_Channel1_IRQHandler(void);
-
-/*******************************************************************************
-* Function Name  : DMA1_Channel2_IRQHandler
-* Description    : This function handles DMA1 Channel 2 interrupt request.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void DMA1_Channel2_IRQHandler(void)
-{
-}
-
-/*******************************************************************************
-* Function Name  : DMA1_Channel3_IRQHandler
-* Description    : This function handles DMA1 Channel 3 interrupt request.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void DMA1_Channel3_IRQHandler(void)
-{
-}
-
-/*******************************************************************************
-* Function Name  : DMA1_Channel4_IRQHandler
-* Description    : This function handles DMA1 Channel 4 interrupt request.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void DMA1_Channel4_IRQHandler(void)
-{
-}
-
-/*******************************************************************************
-* Function Name  : DMA1_Channel5_IRQHandler
-* Description    : This function handles DMA1 Channel 5 interrupt request.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void DMA1_Channel5_IRQHandler(void)
-{
-}
-
-/*******************************************************************************
-* Function Name  : DMA1_Channel6_IRQHandler
-* Description    : This function handles DMA1 Channel 6 interrupt request.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void DMA1_Channel6_IRQHandler(void)
-{
-}
-
-/*******************************************************************************
-* Function Name  : DMA1_Channel7_IRQHandler
-* Description    : This function handles DMA1 Channel 7 interrupt request.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void DMA1_Channel7_IRQHandler(void)
-{
-}
-
-/*******************************************************************************
-* Function Name  : ADC1_2_IRQHandler
-* Description    : This function handles ADC1 and ADC2 global interrupts requests.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void ADC1_2_IRQHandler(void)
-{
-}
-
-/*******************************************************************************
-* Function Name  : USB_HP_CAN_TX_IRQHandler
-* Description    : This function handles USB High Priority or CAN TX interrupts 
-*                  requests.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void USB_HP_CAN_TX_IRQHandler(void)
-{
-}
-
-/*******************************************************************************
-* Function Name  : USB_LP_CAN_RX0_IRQHandler
-* Description    : This function handles USB Low Priority or CAN RX0 interrupts 
-*                  requests.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void USB_LP_CAN_RX0_IRQHandler(void)
-{
-}
-
-/*******************************************************************************
-* Function Name  : CAN_RX1_IRQHandler
-* Description    : This function handles CAN RX1 interrupt request.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void CAN_RX1_IRQHandler(void)
-{
-}
-
-/*******************************************************************************
-* Function Name  : CAN_SCE_IRQHandler
-* Description    : This function handles CAN SCE interrupt request.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void CAN_SCE_IRQHandler(void)
-{
-}
-
-/*******************************************************************************
-* Function Name  : EXTI9_5_IRQHandler
-* Description    : This function handles External lines 9 to 5 interrupt request.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void EXTI9_5_IRQHandler(void)
-{
-}
-
-/*******************************************************************************
-* Function Name  : TIM1_BRK_IRQHandler
-* Description    : This function handles TIM1 Break interrupt request.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM1_BRK_IRQHandler(void)
-{
-}
-
-/*******************************************************************************
-* Function Name  : TIM1_UP_IRQHandler
-* Description    : This function handles TIM1 overflow and update interrupt 
-*                  request.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM1_UP_IRQHandler(void)
-{
-}
-
-/*******************************************************************************
-* Function Name  : TIM1_TRG_COM_IRQHandler
-* Description    : This function handles TIM1 Trigger and commutation interrupts 
-*                  requests.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM1_TRG_COM_IRQHandler(void)
-{
-}
-
-/*******************************************************************************
-* Function Name  : TIM1_CC_IRQHandler
-* Description    : This function handles TIM1 capture compare interrupt request.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM1_CC_IRQHandler(void)
-{
-}
-
-/*******************************************************************************
-* Function Name  : TIM2_IRQHandler
-* Description    : This function handles TIM2 global interrupt request.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM2_IRQHandler(void)
-{
-}
-
-/*******************************************************************************
-* Function Name  : TIM3_IRQHandler
-* Description    : This function handles TIM3 global interrupt request.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM3_IRQHandler(void)
-{
-}
-
-/*******************************************************************************
-* Function Name  : TIM4_IRQHandler
-* Description    : This function handles TIM4 global interrupt request.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM4_IRQHandler(void)
-{
-}
-
-/*******************************************************************************
-* Function Name  : I2C1_EV_IRQHandler
-* Description    : This function handles I2C1 Event interrupt request.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void I2C1_EV_IRQHandler(void)
-{
-}
-
-/*******************************************************************************
-* Function Name  : I2C1_ER_IRQHandler
-* Description    : This function handles I2C1 Error interrupt request.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void I2C1_ER_IRQHandler(void)
-{
-}
-
-/*******************************************************************************
-* Function Name  : I2C2_EV_IRQHandler
-* Description    : This function handles I2C2 Event interrupt request.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void I2C2_EV_IRQHandler(void)
-{
-}
-
-/*******************************************************************************
-* Function Name  : I2C2_ER_IRQHandler
-* Description    : This function handles I2C2 Error interrupt request.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void I2C2_ER_IRQHandler(void)
-{
-}
-
-/*******************************************************************************
-* Function Name  : SPI1_IRQHandler
-* Description    : This function handles SPI1 global interrupt request.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SPI1_IRQHandler(void)
-{
-}
-
-/*******************************************************************************
-* Function Name  : SPI2_IRQHandler
-* Description    : This function handles SPI2 global interrupt request.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SPI2_IRQHandler(void)
-{
-}
-
-/*******************************************************************************
-* Function Name  : USART1_IRQHandler
-* Description    : This function handles USART1 global interrupt request.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
 extern void USART1_IRQHandler(void);
 
-
-/*******************************************************************************
-* Function Name  : USART2_IRQHandler
-* Description    : This function handles USART2 global interrupt request.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void USART2_IRQHandler(void)
-{
-}
-
-/*******************************************************************************
-* Function Name  : USART3_IRQHandler
-* Description    : This function handles USART3 global interrupt request.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void USART3_IRQHandler(void)
-{
-}
-
-/*******************************************************************************
-* Function Name  : EXTI15_10_IRQHandler
-* Description    : This function handles External lines 15 to 10 interrupt request.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void EXTI15_10_IRQHandler(void)
-{
-}
-
-/*******************************************************************************
-* Function Name  : RTCAlarm_IRQHandler
-* Description    : This function handles RTC Alarm interrupt request.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RTCAlarm_IRQHandler(void)
-{
-}
-
-/*******************************************************************************
-* Function Name  : USBWakeUp_IRQHandler
-* Description    : This function handles USB WakeUp interrupt request.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void USBWakeUp_IRQHandler(void)
-{
-}
-
-/*******************************************************************************
-* Function Name  : TIM8_BRK_IRQHandler
-* Description    : This function handles TIM8 Break interrupt request.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM8_BRK_IRQHandler(void)
-{
-}
-
-/*******************************************************************************
-* Function Name  : TIM8_UP_IRQHandler
-* Description    : This function handles TIM8 overflow and update interrupt 
-*                  request.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM8_UP_IRQHandler(void)
-{
-}
-
-/*******************************************************************************
-* Function Name  : TIM8_TRG_COM_IRQHandler
-* Description    : This function handles TIM8 Trigger and commutation interrupts 
-*                  requests.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM8_TRG_COM_IRQHandler(void)
-{
-}
-
-/*******************************************************************************
-* Function Name  : TIM8_CC_IRQHandler
-* Description    : This function handles TIM8 capture compare interrupt request.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM8_CC_IRQHandler(void)
-{
-}
-
-/*******************************************************************************
-* Function Name  : ADC3_IRQHandler
-* Description    : This function handles ADC3 global interrupt request.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void ADC3_IRQHandler(void)
-{
-}
-
-/*******************************************************************************
-* Function Name  : FSMC_IRQHandler
-* Description    : This function handles FSMC global interrupt request.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void FSMC_IRQHandler(void)
-{
-}
-
-/*******************************************************************************
-* Function Name  : SDIO_IRQHandler
-* Description    : This function handles SDIO global interrupt request.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SDIO_IRQHandler(void)
-{
-}
-
-/*******************************************************************************
-* Function Name  : TIM5_IRQHandler
-* Description    : This function handles TIM5 global interrupt request.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM5_IRQHandler(void)
-{
-}
-
-/*******************************************************************************
-* Function Name  : SPI3_IRQHandler
-* Description    : This function handles SPI3 global interrupt request.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SPI3_IRQHandler(void)
-{
-}
-
-/*******************************************************************************
-* Function Name  : UART4_IRQHandler
-* Description    : This function handles UART4 global interrupt request.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void UART4_IRQHandler(void)
-{
-}
-
-/*******************************************************************************
-* Function Name  : UART5_IRQHandler
-* Description    : This function handles UART5 global interrupt request.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void UART5_IRQHandler(void)
-{
-}
-
-/*******************************************************************************
-* Function Name  : TIM6_IRQHandler
-* Description    : This function handles TIM6 global interrupt request.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM6_IRQHandler(void)
-{
-}
-
-/*******************************************************************************
-* Function Name  : TIM7_IRQHandler
-* Description    : This function handles TIM7 global interrupt request.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM7_IRQHandler(void)
-{
-}
-
-/*******************************************************************************
-* Function Name  : DMA2_Channel1_IRQHandler
-* Description    : This function handles DMA2 Channel 1 interrupt request.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void DMA2_Channel1_IRQHandler(void)
-{
-}
-
-/*******************************************************************************
-* Function Name  : DMA2_Channel2_IRQHandler
-* Description    : This function handles DMA2 Channel 2 interrupt request.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void DMA2_Channel2_IRQHandler(void)
-{
-}
-
-/*******************************************************************************
-* Function Name  : DMA2_Channel3_IRQHandler
-* Description    : This function handles DMA2 Channel 3 interrupt request.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void DMA2_Channel3_IRQHandler(void)
-{
-}
-
-/*******************************************************************************
-* Function Name  : DMA2_Channel4_5_IRQHandler
-* Description    : This function handles DMA2 Channel 4 and DMA2 Channel 5
-*                  interrupt request.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void DMA2_Channel4_5_IRQHandler(void)
-{
-}
-
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
+/******************* (C) COPYRIGHT 2009 STMicroelectronics *****END OF FILE****/

Modified: trunk/src/platform/stm32/stm32f10x_it.h
===================================================================
--- trunk/src/platform/stm32/stm32f10x_it.h	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/stm32f10x_it.h	2009-07-08 23:39:34 UTC (rev 354)
@@ -1,100 +1,47 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_it.h
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file contains the headers of the interrupt handlers.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
+/**
+  ******************************************************************************
+  * @file    ADC/3ADCs_DMA/stm32f10x_it.h 
+  * @author  MCD Application Team
+  * @version V3.1.0
+  * @date    06/19/2009
+  * @brief   This file contains the headers of the interrupt handlers.
+  ******************************************************************************
+  * @copy
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * &lt;h2&gt;&lt;center&gt;&copy; COPYRIGHT 2009 STMicroelectronics&lt;/center&gt;&lt;/h2&gt;
+  */ 
 
 /* Define to prevent recursive inclusion -------------------------------------*/
 #ifndef __STM32F10x_IT_H
 #define __STM32F10x_IT_H
 
 /* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_lib.h&quot;
+#include &quot;stm32f10x.h&quot;
 
 /* Exported types ------------------------------------------------------------*/
 /* Exported constants --------------------------------------------------------*/
 /* Exported macro ------------------------------------------------------------*/
 /* Exported functions ------------------------------------------------------- */
 
-void NMIException(void);
-void HardFaultException(void);
-void MemManageException(void);
-void BusFaultException(void);
-void UsageFaultException(void);
-void DebugMonitor(void);
-void SVCHandler(void);
-void PendSVC(void);
-void SysTickHandler(void);
-void WWDG_IRQHandler(void);
-void PVD_IRQHandler(void);
-void TAMPER_IRQHandler(void);
-void RTC_IRQHandler(void);
-void FLASH_IRQHandler(void);
-void RCC_IRQHandler(void);
-void EXTI0_IRQHandler(void);
-void EXTI1_IRQHandler(void);
-void EXTI2_IRQHandler(void);
-void EXTI3_IRQHandler(void);
-void EXTI4_IRQHandler(void);
-void DMA1_Channel1_IRQHandler(void);
-void DMA1_Channel2_IRQHandler(void);
-void DMA1_Channel3_IRQHandler(void);
-void DMA1_Channel4_IRQHandler(void);
-void DMA1_Channel5_IRQHandler(void);
-void DMA1_Channel6_IRQHandler(void);
-void DMA1_Channel7_IRQHandler(void);
+void NMI_Handler(void);
+void HardFault_Handler(void);
+void MemManage_Handler(void);
+void BusFault_Handler(void);
+void UsageFault_Handler(void);
+void SVC_Handler(void);
+void DebugMon_Handler(void);
+void PendSV_Handler(void);
+void SysTick_Handler(void);
 void ADC1_2_IRQHandler(void);
-void USB_HP_CAN_TX_IRQHandler(void);
-void USB_LP_CAN_RX0_IRQHandler(void);
-void CAN_RX1_IRQHandler(void);
-void CAN_SCE_IRQHandler(void);
-void EXTI9_5_IRQHandler(void);
-void TIM1_BRK_IRQHandler(void);
-void TIM1_UP_IRQHandler(void);
-void TIM1_TRG_COM_IRQHandler(void);
-void TIM1_CC_IRQHandler(void);
-void TIM2_IRQHandler(void);
-void TIM3_IRQHandler(void);
-void TIM4_IRQHandler(void);
-void I2C1_EV_IRQHandler(void);
-void I2C1_ER_IRQHandler(void);
-void I2C2_EV_IRQHandler(void);
-void I2C2_ER_IRQHandler(void);
-void SPI1_IRQHandler(void);
-void SPI2_IRQHandler(void);
-void USART1_IRQHandler(void);
-void USART2_IRQHandler(void);
-void USART3_IRQHandler(void);
-void EXTI15_10_IRQHandler(void);
-void RTCAlarm_IRQHandler(void);
-void USBWakeUp_IRQHandler(void);
-void TIM8_BRK_IRQHandler(void);
-void TIM8_UP_IRQHandler(void);
-void TIM8_TRG_COM_IRQHandler(void);
-void TIM8_CC_IRQHandler(void);
-void ADC3_IRQHandler(void);
-void FSMC_IRQHandler(void);
-void SDIO_IRQHandler(void);
-void TIM5_IRQHandler(void);
-void SPI3_IRQHandler(void);
-void UART4_IRQHandler(void);
-void UART5_IRQHandler(void);
-void TIM6_IRQHandler(void);
-void TIM7_IRQHandler(void);
-void DMA2_Channel1_IRQHandler(void);
-void DMA2_Channel2_IRQHandler(void);
-void DMA2_Channel3_IRQHandler(void);
-void DMA2_Channel4_5_IRQHandler(void);
-					 
+void DMA1_Channel1_IRQHandler(void);
+void USART1_IRQHandler(void);					 
 #endif /* __STM32F10x_IT_H */
 
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
+/******************* (C) COPYRIGHT 2009 STMicroelectronics *****END OF FILE****/

Deleted: trunk/src/platform/stm32/stm32f10x_vector.c
===================================================================
--- trunk/src/platform/stm32/stm32f10x_vector.c	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/stm32f10x_vector.c	2009-07-08 23:39:34 UTC (rev 354)
@@ -1,214 +0,0 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_vector.c
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : STM32F10x vector table for RIDE7 toolchain.
-*                      This module performs:
-*                      - Set the initial SP
-*                      - Set the initial PC == Reset_Handler,
-*                      - Set the vector table entries with the exceptions ISR address,
-*                      - Configure external SRAM mounted on STM3210E-EVAL board
-*                       to be used as data memory (optional, to be enabled by user)
-*                      - Branches to main in the C library (which eventually
-*                        calls main()).
-*                      After Reset the Cortex-M3 processor is in Thread mode,
-*                      priority is Privileged, and the Stack is set to Main.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
-/* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_lib.h&quot;
-#include &quot;stm32f10x_it.h&quot;
-
-/* Private typedef -----------------------------------------------------------*/
-typedef void( *intfunc )( void );
-typedef union { intfunc __fun; void * __ptr; } intvec_elem;
-
-/* Private define ------------------------------------------------------------*/
-/* Uncomment the following line if you need to use external SRAM mounted on
-   STM3210E-EVAL board as data memory */
-   
-/* #define DATA_IN_ExtSRAM */ 
-
-/* Private macro -------------------------------------------------------------*/
-extern unsigned long _etext;
-/* start address for the initialization values of the .data section. 
-defined in linker script */
-
-/* start address for the .data section. defined in linker script */		
-extern unsigned long _data;
-
-/* end address for the .data section. defined in linker script */		
-extern unsigned long _edata;
-		
-/* start address for the .bss section. defined in linker script */
-extern unsigned long _bss;
-
-/* end address for the .bss section. defined in linker script */			
-extern unsigned long _ebss;	
-		
-/* init value for the stack pointer. defined in linker script */
-extern void _estack;	
-	
-/* Private variables ---------------------------------------------------------*/
-/* Private function prototypes -----------------------------------------------*/
-void Reset_Handler(void) __attribute__((__interrupt__));
-extern int main(void);
-/* Private functions ---------------------------------------------------------*/
-
-__attribute__ ((section(&quot;.isr_vector&quot;)))
-void (* const g_pfnVectors[])(void) =
-{
-  &amp;_estack,            /* The initial stack pointer*/
-  Reset_Handler,             /* The reset handler*/
-  NMIException,
-  HardFaultException,
-  MemManageException,
-  BusFaultException,
-  UsageFaultException,
-  0, 0, 0, 0,            /* Reserved */ 
-  SVCHandler,
-  DebugMonitor,
-  0,                      /* Reserved */
-  PendSVC,
-  SysTickHandler,
-  WWDG_IRQHandler,
-  PVD_IRQHandler,
-  TAMPER_IRQHandler,
-  RTC_IRQHandler,
-  FLASH_IRQHandler,
-  RCC_IRQHandler,
-  EXTI0_IRQHandler,
-  EXTI1_IRQHandler,
-  EXTI2_IRQHandler,
-  EXTI3_IRQHandler,
-  EXTI4_IRQHandler,
-  DMA1_Channel1_IRQHandler,
-  DMA1_Channel2_IRQHandler,
-  DMA1_Channel3_IRQHandler,
-  DMA1_Channel4_IRQHandler,
-  DMA1_Channel5_IRQHandler,
-  DMA1_Channel6_IRQHandler,
-  DMA1_Channel7_IRQHandler,
-  ADC1_2_IRQHandler,
-  USB_HP_CAN_TX_IRQHandler,
-  USB_LP_CAN_RX0_IRQHandler,
-  CAN_RX1_IRQHandler,
-  CAN_SCE_IRQHandler,
-  EXTI9_5_IRQHandler,
-  TIM1_BRK_IRQHandler,
-  TIM1_UP_IRQHandler,
-  TIM1_TRG_COM_IRQHandler,
-  TIM1_CC_IRQHandler,
-  TIM2_IRQHandler,
-  TIM3_IRQHandler,
-  TIM4_IRQHandler,
-  I2C1_EV_IRQHandler,
-  I2C1_ER_IRQHandler,
-  I2C2_EV_IRQHandler,
-  I2C2_ER_IRQHandler,
-  SPI1_IRQHandler,
-  SPI2_IRQHandler,
-  USART1_IRQHandler,
-  USART2_IRQHandler,
-  USART3_IRQHandler,
-  EXTI15_10_IRQHandler,
-  RTCAlarm_IRQHandler,
-  USBWakeUp_IRQHandler,
-  TIM8_BRK_IRQHandler,
-  TIM8_UP_IRQHandler,
-  TIM8_TRG_COM_IRQHandler,
-  TIM8_CC_IRQHandler,
-  ADC3_IRQHandler,
-  FSMC_IRQHandler,
-  SDIO_IRQHandler,
-  TIM5_IRQHandler,
-  SPI3_IRQHandler,
-  UART4_IRQHandler,
-  UART5_IRQHandler,
-  TIM6_IRQHandler,
-  TIM7_IRQHandler,
-  DMA2_Channel1_IRQHandler,
-  DMA2_Channel2_IRQHandler,
-  DMA2_Channel3_IRQHandler,
-  DMA2_Channel4_5_IRQHandler,  
-};
-
-/*******************************************************************************
-* Function Name  : Reset_Handler
-* Description    : This is the code that gets called when the processor first
-*                  starts execution following a reset event. Only the absolutely
-*                  necessary set is performed, after which the application
-*                  supplied main() routine is called. 
-* Input          :
-* Output         :
-* Return         :
-*******************************************************************************/
-void Reset_Handler(void)
-{
-unsigned long *pulSrc, *pulDest;
-
-#ifdef DATA_IN_ExtSRAM
-
-/* FSMC Bank1 NOR/SRAM3 is used for the STM3210E-EVAL, if another Bank is 
-  required, then adjust the Register Addresses*/
-
-  /* Enable FSMC clock */
-  *(vu32 *)0x40021014 = 0x00000114;
-  
-  /* Enable GPIOD, GPIOE, GPIOF and GPIOG clocks */  
-  *(vu32 *)0x40021018 = 0x000001E0;
-  
-/* ---------------  SRAM Data lines, NOE and NWE configuration ---------------*/
-/*----------------  SRAM Address lines configuration -------------------------*/
-/*----------------  NOE and NWE configuration --------------------------------*/  
-/*----------------  NE3 configuration ----------------------------------------*/
-/*----------------  NBL0, NBL1 configuration ---------------------------------*/
-  
-  *(vu32 *)0x40011400 = 0x44BB44BB;
-  *(vu32 *)0x40011404 = 0xBBBBBBBB;
-  
-  *(vu32 *)0x40011800 = 0xB44444BB;
-  *(vu32 *)0x40011804 = 0xBBBBBBBB;
-   
-  *(vu32 *)0x40011C00 = 0x44BBBBBB;
-  *(vu32 *)0x40011C04 = 0xBBBB4444;  
-
-  *(vu32 *)0x40012000 = 0x44BBBBBB;
-  *(vu32 *)0x40012004 = 0x44444B44;
-  
-/*----------------  FSMC Configuration ---------------------------------------*/  
-/*----------------  Enable FSMC Bank1_SRAM Bank ------------------------------*/
-  
-  *(vu32 *)0xA0000010 = 0x00001011;
-  *(vu32 *)0xA0000014 = 0x00000200;
-    
-#endif /*DATA_IN_ExtSRAM*/
-
-
-/* Copy the data segment initializers from flash to SRAM */
-    pulSrc = &amp;_etext;
-    for(pulDest = &amp;_data; pulDest &lt; &amp;_edata; )
-    {
-        *(pulDest++) = *(pulSrc++);
-    }
-/* Zero fill the bss segment.  */
-    for(pulDest = &amp;_bss; pulDest &lt; &amp;_ebss; )
-    {
-        *(pulDest++) = 0;
-    }
-
-/* Call the application's entry point.*/
-    main();
-}
-
-
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
-
-

Added: trunk/src/platform/stm32/system_stm32f10x.c
===================================================================
--- trunk/src/platform/stm32/system_stm32f10x.c	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/system_stm32f10x.c	2009-07-08 23:39:34 UTC (rev 354)
@@ -0,0 +1,930 @@
+/**
+  ******************************************************************************
+  * @file    system_stm32f10x.c
+  * @author  MCD Application Team
+  * @version V3.1.0
+  * @date    06/19/2009
+  * @brief   CMSIS Cortex-M3 Device Peripheral Access Layer System Source File.
+  ******************************************************************************  
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * &lt;h2&gt;&lt;center&gt;&copy; COPYRIGHT 2009 STMicroelectronics&lt;/center&gt;&lt;/h2&gt;
+  ******************************************************************************
+  */
+
+/** @addtogroup CMSIS
+  * @{
+  */
+
+/** @addtogroup stm32f10x_system
+  * @{
+  */  
+  
+/** @addtogroup STM32F10x_System_Private_Includes
+  * @{
+  */
+
+#include &quot;stm32f10x.h&quot;
+
+/**
+  * @}
+  */
+
+/** @addtogroup STM32F10x_System_Private_TypesDefinitions
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @addtogroup STM32F10x_System_Private_Defines
+  * @{
+  */
+
+/*!&lt; Uncomment the line corresponding to the desired System clock (SYSCLK)
+   frequency (after reset the HSI is used as SYSCLK source)
+   
+   IMPORTANT NOTE:
+   ============== 
+   1. After each device reset the HSI is used as System clock source.
+
+   2. Please make sure that the selected System clock doesn't exceed your device's
+      maximum frequency.
+      
+   3. If none of the define below is enabled, the HSI is used as System clock
+    source.
+
+   4. The System clock configuration functions provided within this file assume that:
+        - For Low, Medium and High density devices an external 8MHz crystal is
+          used to drive the System clock.
+        - For Connectivity line devices an external 25MHz crystal is used to drive
+          the System clock.
+     If you are using different crystal you have to adapt those functions accordingly.
+    */
+    
+/* #define SYSCLK_FREQ_HSE    HSE_Value */
+/* #define SYSCLK_FREQ_24MHz  24000000 */
+/* #define SYSCLK_FREQ_36MHz  36000000 */
+/* #define SYSCLK_FREQ_48MHz  48000000 */
+/* #define SYSCLK_FREQ_56MHz  56000000 */
+#define SYSCLK_FREQ_72MHz  72000000
+
+/*!&lt; Uncomment the following line if you need to use external SRAM mounted
+     on STM3210E-EVAL board (STM32 High density devices) as data memory  */ 
+#ifdef STM32F10X_HD
+/* #define DATA_IN_ExtSRAM */
+#endif /* STM32F10X_HD */
+
+/**
+  * @}
+  */
+
+/** @addtogroup STM32F10x_System_Private_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @addtogroup STM32F10x_System_Private_Variables
+  * @{
+  */
+
+/*******************************************************************************
+*  Clock Definitions
+*******************************************************************************/
+#ifdef SYSCLK_FREQ_HSE
+  const uint32_t SystemFrequency         = SYSCLK_FREQ_HSE;        /*!&lt; System Clock Frequency (Core Clock) */
+  const uint32_t SystemFrequency_SysClk  = SYSCLK_FREQ_HSE;        /*!&lt; System clock                        */
+  const uint32_t SystemFrequency_AHBClk  = SYSCLK_FREQ_HSE;        /*!&lt; AHB System bus speed                */
+  const uint32_t SystemFrequency_APB1Clk = SYSCLK_FREQ_HSE;        /*!&lt; APB Peripheral bus 1 (low)  speed   */
+  const uint32_t SystemFrequency_APB2Clk = SYSCLK_FREQ_HSE;        /*!&lt; APB Peripheral bus 2 (high) speed   */
+#elif defined SYSCLK_FREQ_24MHz
+  const uint32_t SystemFrequency         = SYSCLK_FREQ_24MHz;      /*!&lt; System Clock Frequency (Core Clock) */
+  const uint32_t SystemFrequency_SysClk  = SYSCLK_FREQ_24MHz;      /*!&lt; System clock                        */
+  const uint32_t SystemFrequency_AHBClk  = SYSCLK_FREQ_24MHz;      /*!&lt; AHB System bus speed                */
+  const uint32_t SystemFrequency_APB1Clk = SYSCLK_FREQ_24MHz;      /*!&lt; APB Peripheral bus 1 (low)  speed   */
+  const uint32_t SystemFrequency_APB2Clk = SYSCLK_FREQ_24MHz;      /*!&lt; APB Peripheral bus 2 (high) speed   */
+#elif defined SYSCLK_FREQ_36MHz
+  const uint32_t SystemFrequency         = SYSCLK_FREQ_36MHz;      /*!&lt; System Clock Frequency (Core Clock) */
+  const uint32_t SystemFrequency_SysClk  = SYSCLK_FREQ_36MHz;      /*!&lt; System clock                        */
+  const uint32_t SystemFrequency_AHBClk  = SYSCLK_FREQ_36MHz;      /*!&lt; AHB System bus speed                */
+  const uint32_t SystemFrequency_APB1Clk = SYSCLK_FREQ_36MHz;      /*!&lt; APB Peripheral bus 1 (low)  speed   */
+  const uint32_t SystemFrequency_APB2Clk = SYSCLK_FREQ_36MHz;      /*!&lt; APB Peripheral bus 2 (high) speed   */
+#elif defined SYSCLK_FREQ_48MHz
+  const uint32_t SystemFrequency         = SYSCLK_FREQ_48MHz;      /*!&lt; System Clock Frequency (Core Clock) */
+  const uint32_t SystemFrequency_SysClk  = SYSCLK_FREQ_48MHz;      /*!&lt; System clock                        */
+  const uint32_t SystemFrequency_AHBClk  = SYSCLK_FREQ_48MHz;      /*!&lt; AHB System bus speed                */
+  const uint32_t SystemFrequency_APB1Clk = (SYSCLK_FREQ_48MHz/2);  /*!&lt; APB Peripheral bus 1 (low)  speed   */
+  const uint32_t SystemFrequency_APB2Clk = SYSCLK_FREQ_48MHz;      /*!&lt; APB Peripheral bus 2 (high) speed   */
+#elif defined SYSCLK_FREQ_56MHz
+  const uint32_t SystemFrequency         = SYSCLK_FREQ_56MHz;      /*!&lt; System Clock Frequency (Core Clock) */
+  const uint32_t SystemFrequency_SysClk  = SYSCLK_FREQ_56MHz;      /*!&lt; System clock                        */
+  const uint32_t SystemFrequency_AHBClk  = SYSCLK_FREQ_56MHz;      /*!&lt; AHB System bus speed                */
+  const uint32_t SystemFrequency_APB1Clk = (SYSCLK_FREQ_56MHz/2);  /*!&lt; APB Peripheral bus 1 (low)  speed   */
+  const uint32_t SystemFrequency_APB2Clk = SYSCLK_FREQ_56MHz;      /*!&lt; APB Peripheral bus 2 (high) speed   */  
+#elif defined SYSCLK_FREQ_72MHz
+  const uint32_t SystemFrequency         = SYSCLK_FREQ_72MHz;      /*!&lt; System Clock Frequency (Core Clock) */
+  const uint32_t SystemFrequency_SysClk  = SYSCLK_FREQ_72MHz;      /*!&lt; System clock                        */
+  const uint32_t SystemFrequency_AHBClk  = SYSCLK_FREQ_72MHz;      /*!&lt; AHB System bus speed                */
+  const uint32_t SystemFrequency_APB1Clk = (SYSCLK_FREQ_72MHz/2);  /*!&lt; APB Peripheral bus 1 (low)  speed   */
+  const uint32_t SystemFrequency_APB2Clk = SYSCLK_FREQ_72MHz;      /*!&lt; APB Peripheral bus 2 (high) speed   */
+#else /*!&lt; HSI Selected as System Clock source */
+  const uint32_t SystemFrequency         = HSI_Value;              /*!&lt; System Clock Frequency (Core Clock) */
+  const uint32_t SystemFrequency_SysClk  = HSI_Value;              /*!&lt; System clock                        */
+  const uint32_t SystemFrequency_AHBClk  = HSI_Value;              /*!&lt; AHB System bus speed                */
+  const uint32_t SystemFrequency_APB1Clk = HSI_Value;              /*!&lt; APB Peripheral bus 1 (low)  speed   */
+  const uint32_t SystemFrequency_APB2Clk = HSI_Value;              /*!&lt; APB Peripheral bus 2 (high) speed   */
+#endif
+
+/**
+  * @}
+  */
+
+/** @addtogroup STM32F10x_System_Private_FunctionPrototypes
+  * @{
+  */
+
+static void SetSysClock(void);
+
+#ifdef SYSCLK_FREQ_HSE
+  static void SetSysClockToHSE(void);
+#elif defined SYSCLK_FREQ_24MHz
+  static void SetSysClockTo24(void);
+#elif defined SYSCLK_FREQ_36MHz
+  static void SetSysClockTo36(void);
+#elif defined SYSCLK_FREQ_48MHz
+  static void SetSysClockTo48(void);
+#elif defined SYSCLK_FREQ_56MHz
+  static void SetSysClockTo56(void);  
+#elif defined SYSCLK_FREQ_72MHz
+  static void SetSysClockTo72(void);
+#endif
+
+/**
+  * @}
+  */
+
+/** @addtogroup STM32F10x_System_Private_Functions
+  * @{
+  */
+
+/**
+  * @brief  Setup the microcontroller system
+  *         Initialize the Embedded Flash Interface, the PLL and update the SystemFrequency variable.
+  * @note   This function should be used only after reset.
+  * @param  None
+  * @retval None
+  */
+void SystemInit (void)
+{
+  /* Reset the RCC clock configuration to the default reset state(for debug purpose) */
+  /* Set HSION bit */
+  RCC-&gt;CR |= (uint32_t)0x00000001;
+
+  /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
+#ifndef STM32F10X_CL
+  RCC-&gt;CFGR &amp;= (uint32_t)0xF8FF0000;
+#else
+  RCC-&gt;CFGR &amp;= (uint32_t)0xF0FF0000;
+#endif /* STM32F10X_CL */   
+  
+  /* Reset HSEON, CSSON and PLLON bits */
+  RCC-&gt;CR &amp;= (uint32_t)0xFEF6FFFF;
+
+  /* Reset HSEBYP bit */
+  RCC-&gt;CR &amp;= (uint32_t)0xFFFBFFFF;
+
+  /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
+  RCC-&gt;CFGR &amp;= (uint32_t)0xFF80FFFF;
+
+#ifndef STM32F10X_CL
+  /* Disable all interrupts and clear pending bits  */
+  RCC-&gt;CIR = 0x009F0000;
+#else
+  /* Reset PLL2ON and PLL3ON bits */
+  RCC-&gt;CR &amp;= (uint32_t)0xEBFFFFFF;
+
+  /* Disable all interrupts and clear pending bits  */
+  RCC-&gt;CIR = 0x00FF0000;
+
+  /* Reset CFGR2 register */
+  RCC-&gt;CFGR2 = 0x00000000;
+#endif /* STM32F10X_CL */
+    
+  /* Configure the System clock frequency, HCLK, PCLK2 and PCLK1 prescalers */
+  /* Configure the Flash Latency cycles and enable prefetch buffer */
+  SetSysClock();
+
+}
+
+/**
+  * @brief  Configures the System clock frequency, HCLK, PCLK2 and PCLK1 prescalers.
+  * @param  None
+  * @retval None
+  */
+static void SetSysClock(void)
+{
+#ifdef SYSCLK_FREQ_HSE
+  SetSysClockToHSE();
+#elif defined SYSCLK_FREQ_24MHz
+  SetSysClockTo24();
+#elif defined SYSCLK_FREQ_36MHz
+  SetSysClockTo36();
+#elif defined SYSCLK_FREQ_48MHz
+  SetSysClockTo48();
+#elif defined SYSCLK_FREQ_56MHz
+  SetSysClockTo56();  
+#elif defined SYSCLK_FREQ_72MHz
+  SetSysClockTo72();
+#endif
+ 
+ /* If none of the define above is enabled, the HSI is used as System clock
+    source (default after reset) */ 
+}
+
+/**
+  * @brief  Setup the external memory controller. Called in startup_stm32f10x.s 
+  *          before jump to __main
+  * @param  None
+  * @retval None
+  */ 
+#ifdef DATA_IN_ExtSRAM
+/**
+  * @brief  Setup the external memory controller. 
+  *         Called in startup_stm32f10x_xx.s/.c before jump to main.
+  * 	      This function configures the external SRAM mounted on STM3210E-EVAL
+  *         board (STM32 High density devices). This SRAM will be used as program
+  *         data memory (including heap and stack).
+  * @param  None
+  * @retval None
+  */ 
+void SystemInit_ExtMemCtl(void) 
+{
+/*!&lt; FSMC Bank1 NOR/SRAM3 is used for the STM3210E-EVAL, if another Bank is 
+  required, then adjust the Register Addresses */
+
+  /* Enable FSMC clock */
+  RCC-&gt;AHBENR = 0x00000114;
+  
+  /* Enable GPIOD, GPIOE, GPIOF and GPIOG clocks */  
+  RCC-&gt;APB2ENR = 0x000001E0;
+  
+/* ---------------  SRAM Data lines, NOE and NWE configuration ---------------*/
+/*----------------  SRAM Address lines configuration -------------------------*/
+/*----------------  NOE and NWE configuration --------------------------------*/  
+/*----------------  NE3 configuration ----------------------------------------*/
+/*----------------  NBL0, NBL1 configuration ---------------------------------*/
+  
+  GPIOD-&gt;CRL = 0x44BB44BB;  
+  GPIOD-&gt;CRH = 0xBBBBBBBB;
+
+  GPIOE-&gt;CRL = 0xB44444BB;  
+  GPIOE-&gt;CRH = 0xBBBBBBBB;
+
+  GPIOF-&gt;CRL = 0x44BBBBBB;  
+  GPIOF-&gt;CRH = 0xBBBB4444;
+
+  GPIOG-&gt;CRL = 0x44BBBBBB;  
+  GPIOG-&gt;CRH = 0x44444B44;
+   
+/*----------------  FSMC Configuration ---------------------------------------*/  
+/*----------------  Enable FSMC Bank1_SRAM Bank ------------------------------*/
+  
+  FSMC_Bank1-&gt;BTCR[4] = 0x00001011;
+  FSMC_Bank1-&gt;BTCR[5] = 0x00000200;
+}
+#endif /* DATA_IN_ExtSRAM */
+
+#ifdef SYSCLK_FREQ_HSE
+/**
+  * @brief  Selects HSE as System clock source and configure HCLK, PCLK2
+  *          and PCLK1 prescalers.
+  * @note   This function should be used only after reset.
+  * @param  None
+  * @retval None
+  */
+static void SetSysClockToHSE(void)
+{
+  __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
+  
+  /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/    
+  /* Enable HSE */    
+  RCC-&gt;CR |= ((uint32_t)RCC_CR_HSEON);
+ 
+  /* Wait till HSE is ready and if Time out is reached exit */
+  do
+  {
+    HSEStatus = RCC-&gt;CR &amp; RCC_CR_HSERDY;
+    StartUpCounter++;  
+  } while((HSEStatus == 0) &amp;&amp; (StartUpCounter != HSEStartUp_TimeOut));
+
+  if ((RCC-&gt;CR &amp; RCC_CR_HSERDY) != RESET)
+  {
+    HSEStatus = (uint32_t)0x01;
+  }
+  else
+  {
+    HSEStatus = (uint32_t)0x00;
+  }  
+
+  if (HSEStatus == (uint32_t)0x01)
+  {
+    /* Enable Prefetch Buffer */
+    FLASH-&gt;ACR |= FLASH_ACR_PRFTBE;
+
+    /* Flash 0 wait state */
+    FLASH-&gt;ACR &amp;= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);
+
+#ifndef STM32F10X_CL
+    FLASH-&gt;ACR |= (uint32_t)FLASH_ACR_LATENCY_0;
+#else
+    if (HSE_Value &lt;= 24000000)
+	{
+      FLASH-&gt;ACR |= (uint32_t)FLASH_ACR_LATENCY_0;
+	}
+	else
+	{
+      FLASH-&gt;ACR |= (uint32_t)FLASH_ACR_LATENCY_1;
+	}
+#endif /* STM32F10X_CL */
+ 
+    /* HCLK = SYSCLK */
+    RCC-&gt;CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;
+      
+    /* PCLK2 = HCLK */
+    RCC-&gt;CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;
+    
+    /* PCLK1 = HCLK */
+    RCC-&gt;CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV1;
+    
+    /* Select HSE as system clock source */
+    RCC-&gt;CFGR &amp;= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
+    RCC-&gt;CFGR |= (uint32_t)RCC_CFGR_SW_HSE;    
+
+    /* Wait till HSE is used as system clock source */
+    while ((RCC-&gt;CFGR &amp; (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x04)
+    {
+    }
+  }
+  else
+  { /* If HSE fails to start-up, the application will have wrong clock 
+         configuration. User can add here some code to deal with this error */    
+
+    /* Go to infinite loop */
+    while (1)
+    {
+    }
+  }  
+}
+#elif defined SYSCLK_FREQ_24MHz
+/**
+  * @brief  Sets System clock frequency to 24MHz and configure HCLK, PCLK2 
+  *          and PCLK1 prescalers.
+  * @note   This function should be used only after reset.
+  * @param  None
+  * @retval None
+  */
+static void SetSysClockTo24(void)
+{
+  __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
+  
+  /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/    
+  /* Enable HSE */    
+  RCC-&gt;CR |= ((uint32_t)RCC_CR_HSEON);
+ 
+  /* Wait till HSE is ready and if Time out is reached exit */
+  do
+  {
+    HSEStatus = RCC-&gt;CR &amp; RCC_CR_HSERDY;
+    StartUpCounter++;  
+  } while((HSEStatus == 0) &amp;&amp; (StartUpCounter != HSEStartUp_TimeOut));
+
+  if ((RCC-&gt;CR &amp; RCC_CR_HSERDY) != RESET)
+  {
+    HSEStatus = (uint32_t)0x01;
+  }
+  else
+  {
+    HSEStatus = (uint32_t)0x00;
+  }  
+
+  if (HSEStatus == (uint32_t)0x01)
+  {
+    /* Enable Prefetch Buffer */
+    FLASH-&gt;ACR |= FLASH_ACR_PRFTBE;
+
+    /* Flash 0 wait state */
+    FLASH-&gt;ACR &amp;= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);
+    FLASH-&gt;ACR |= (uint32_t)FLASH_ACR_LATENCY_0;    
+ 
+    /* HCLK = SYSCLK */
+    RCC-&gt;CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;
+      
+    /* PCLK2 = HCLK */
+    RCC-&gt;CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;
+    
+    /* PCLK1 = HCLK */
+    RCC-&gt;CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV1;
+    
+#ifdef STM32F10X_CL
+    /* Configure PLLs ------------------------------------------------------*/
+    /* PLL configuration: PLLCLK = PREDIV1 * 6 = 24 MHz */ 
+    RCC-&gt;CFGR &amp;= (uint32_t)~(RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL);
+    RCC-&gt;CFGR |= (uint32_t)(RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLSRC_PREDIV1 | 
+                            RCC_CFGR_PLLMULL6); 
+
+    /* PLL2 configuration: PLL2CLK = (HSE / 5) * 8 = 40 MHz */
+    /* PREDIV1 configuration: PREDIV1CLK = PLL2 / 10 = 4 MHz */       
+    RCC-&gt;CFGR2 &amp;= (uint32_t)~(RCC_CFGR2_PREDIV2 | RCC_CFGR2_PLL2MUL |
+                              RCC_CFGR2_PREDIV1 | RCC_CFGR2_PREDIV1SRC);
+    RCC-&gt;CFGR2 |= (uint32_t)(RCC_CFGR2_PREDIV2_DIV5 | RCC_CFGR2_PLL2MUL8 |
+                             RCC_CFGR2_PREDIV1SRC_PLL2 | RCC_CFGR2_PREDIV1_DIV10);
+  
+    /* Enable PLL2 */
+    RCC-&gt;CR |= RCC_CR_PLL2ON;
+    /* Wait till PLL2 is ready */
+    while((RCC-&gt;CR &amp; RCC_CR_PLL2RDY) == 0)
+    {
+    }   
+#else    
+    /*  PLL configuration:  = (HSE / 2) * 6 = 24 MHz */
+    RCC-&gt;CFGR &amp;= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLMULL));
+    RCC-&gt;CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_HSE | RCC_CFGR_PLLXTPRE_HSE_Div2 | RCC_CFGR_PLLMULL6);
+#endif /* STM32F10X_CL */
+
+    /* Enable PLL */
+    RCC-&gt;CR |= RCC_CR_PLLON;
+
+    /* Wait till PLL is ready */
+    while((RCC-&gt;CR &amp; RCC_CR_PLLRDY) == 0)
+    {
+    }
+
+    /* Select PLL as system clock source */
+    RCC-&gt;CFGR &amp;= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
+    RCC-&gt;CFGR |= (uint32_t)RCC_CFGR_SW_PLL;    
+
+    /* Wait till PLL is used as system clock source */
+    while ((RCC-&gt;CFGR &amp; (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08)
+    {
+    }
+  }
+  else
+  { /* If HSE fails to start-up, the application will have wrong clock 
+         configuration. User can add here some code to deal with this error */    
+
+    /* Go to infinite loop */
+    while (1)
+    {
+    }
+  } 
+}
+#elif defined SYSCLK_FREQ_36MHz
+/**
+  * @brief  Sets System clock frequency to 36MHz and configure HCLK, PCLK2 
+  *          and PCLK1 prescalers. 
+  * @note   This function should be used only after reset.
+  * @param  None
+  * @retval None
+  */
+static void SetSysClockTo36(void)
+{
+  __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
+  
+  /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/    
+  /* Enable HSE */    
+  RCC-&gt;CR |= ((uint32_t)RCC_CR_HSEON);
+ 
+  /* Wait till HSE is ready and if Time out is reached exit */
+  do
+  {
+    HSEStatus = RCC-&gt;CR &amp; RCC_CR_HSERDY;
+    StartUpCounter++;  
+  } while((HSEStatus == 0) &amp;&amp; (StartUpCounter != HSEStartUp_TimeOut));
+
+  if ((RCC-&gt;CR &amp; RCC_CR_HSERDY) != RESET)
+  {
+    HSEStatus = (uint32_t)0x01;
+  }
+  else
+  {
+    HSEStatus = (uint32_t)0x00;
+  }  
+
+  if (HSEStatus == (uint32_t)0x01)
+  {
+    /* Enable Prefetch Buffer */
+    FLASH-&gt;ACR |= FLASH_ACR_PRFTBE;
+
+    /* Flash 1 wait state */
+    FLASH-&gt;ACR &amp;= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);
+    FLASH-&gt;ACR |= (uint32_t)FLASH_ACR_LATENCY_1;    
+ 
+    /* HCLK = SYSCLK */
+    RCC-&gt;CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;
+      
+    /* PCLK2 = HCLK */
+    RCC-&gt;CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;
+    
+    /* PCLK1 = HCLK */
+    RCC-&gt;CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV1;
+    
+#ifdef STM32F10X_CL
+    /* Configure PLLs ------------------------------------------------------*/
+    
+    /* PLL configuration: PLLCLK = PREDIV1 * 9 = 36 MHz */ 
+    RCC-&gt;CFGR &amp;= (uint32_t)~(RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL);
+    RCC-&gt;CFGR |= (uint32_t)(RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLSRC_PREDIV1 | 
+                            RCC_CFGR_PLLMULL9); 
+
+	/*!&lt; PLL2 configuration: PLL2CLK = (HSE / 5) * 8 = 40 MHz */
+    /* PREDIV1 configuration: PREDIV1CLK = PLL2 / 10 = 4 MHz */
+        
+    RCC-&gt;CFGR2 &amp;= (uint32_t)~(RCC_CFGR2_PREDIV2 | RCC_CFGR2_PLL2MUL |
+                              RCC_CFGR2_PREDIV1 | RCC_CFGR2_PREDIV1SRC);
+    RCC-&gt;CFGR2 |= (uint32_t)(RCC_CFGR2_PREDIV2_DIV5 | RCC_CFGR2_PLL2MUL8 |
+                             RCC_CFGR2_PREDIV1SRC_PLL2 | RCC_CFGR2_PREDIV1_DIV10);
+  
+    /* Enable PLL2 */
+    RCC-&gt;CR |= RCC_CR_PLL2ON;
+    /* Wait till PLL2 is ready */
+    while((RCC-&gt;CR &amp; RCC_CR_PLL2RDY) == 0)
+    {
+    }
+    
+#else    
+    /*  PLL configuration: PLLCLK = (HSE / 2) * 9 = 36 MHz */
+    RCC-&gt;CFGR &amp;= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLMULL));
+    RCC-&gt;CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_HSE | RCC_CFGR_PLLXTPRE_HSE_Div2 | RCC_CFGR_PLLMULL9);
+#endif /* STM32F10X_CL */
+
+    /* Enable PLL */
+    RCC-&gt;CR |= RCC_CR_PLLON;
+
+    /* Wait till PLL is ready */
+    while((RCC-&gt;CR &amp; RCC_CR_PLLRDY) == 0)
+    {
+    }
+
+    /* Select PLL as system clock source */
+    RCC-&gt;CFGR &amp;= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
+    RCC-&gt;CFGR |= (uint32_t)RCC_CFGR_SW_PLL;    
+
+    /* Wait till PLL is used as system clock source */
+    while ((RCC-&gt;CFGR &amp; (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08)
+    {
+    }
+  }
+  else
+  { /* If HSE fails to start-up, the application will have wrong clock 
+         configuration. User can add here some code to deal with this error */    
+
+    /* Go to infinite loop */
+    while (1)
+    {
+    }
+  } 
+}
+#elif defined SYSCLK_FREQ_48MHz
+/**
+  * @brief  Sets System clock frequency to 48MHz and configure HCLK, PCLK2 
+  *          and PCLK1 prescalers. 
+  * @note   This function should be used only after reset.
+  * @param  None
+  * @retval None
+  */
+static void SetSysClockTo48(void)
+{
+  __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
+  
+  /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/    
+  /* Enable HSE */    
+  RCC-&gt;CR |= ((uint32_t)RCC_CR_HSEON);
+ 
+  /* Wait till HSE is ready and if Time out is reached exit */
+  do
+  {
+    HSEStatus = RCC-&gt;CR &amp; RCC_CR_HSERDY;
+    StartUpCounter++;  
+  } while((HSEStatus == 0) &amp;&amp; (StartUpCounter != HSEStartUp_TimeOut));
+
+  if ((RCC-&gt;CR &amp; RCC_CR_HSERDY) != RESET)
+  {
+    HSEStatus = (uint32_t)0x01;
+  }
+  else
+  {
+    HSEStatus = (uint32_t)0x00;
+  }  
+
+  if (HSEStatus == (uint32_t)0x01)
+  {
+    /* Enable Prefetch Buffer */
+    FLASH-&gt;ACR |= FLASH_ACR_PRFTBE;
+
+    /* Flash 1 wait state */
+    FLASH-&gt;ACR &amp;= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);
+    FLASH-&gt;ACR |= (uint32_t)FLASH_ACR_LATENCY_1;    
+ 
+    /* HCLK = SYSCLK */
+    RCC-&gt;CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;
+      
+    /* PCLK2 = HCLK */
+    RCC-&gt;CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;
+    
+    /* PCLK1 = HCLK */
+    RCC-&gt;CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV2;
+    
+#ifdef STM32F10X_CL
+    /* Configure PLLs ------------------------------------------------------*/
+    /* PLL2 configuration: PLL2CLK = (HSE / 5) * 8 = 40 MHz */
+    /* PREDIV1 configuration: PREDIV1CLK = PLL2 / 5 = 8 MHz */
+        
+    RCC-&gt;CFGR2 &amp;= (uint32_t)~(RCC_CFGR2_PREDIV2 | RCC_CFGR2_PLL2MUL |
+                              RCC_CFGR2_PREDIV1 | RCC_CFGR2_PREDIV1SRC);
+    RCC-&gt;CFGR2 |= (uint32_t)(RCC_CFGR2_PREDIV2_DIV5 | RCC_CFGR2_PLL2MUL8 |
+                             RCC_CFGR2_PREDIV1SRC_PLL2 | RCC_CFGR2_PREDIV1_DIV5);
+  
+    /* Enable PLL2 */
+    RCC-&gt;CR |= RCC_CR_PLL2ON;
+    /* Wait till PLL2 is ready */
+    while((RCC-&gt;CR &amp; RCC_CR_PLL2RDY) == 0)
+    {
+    }
+    
+   
+    /* PLL configuration: PLLCLK = PREDIV1 * 6 = 48 MHz */ 
+    RCC-&gt;CFGR &amp;= (uint32_t)~(RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL);
+    RCC-&gt;CFGR |= (uint32_t)(RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLSRC_PREDIV1 | 
+                            RCC_CFGR_PLLMULL6); 
+#else    
+    /*  PLL configuration: PLLCLK = HSE * 6 = 48 MHz */
+    RCC-&gt;CFGR &amp;= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLMULL));
+    RCC-&gt;CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_HSE | RCC_CFGR_PLLMULL6);
+#endif /* STM32F10X_CL */
+
+    /* Enable PLL */
+    RCC-&gt;CR |= RCC_CR_PLLON;
+
+    /* Wait till PLL is ready */
+    while((RCC-&gt;CR &amp; RCC_CR_PLLRDY) == 0)
+    {
+    }
+
+    /* Select PLL as system clock source */
+    RCC-&gt;CFGR &amp;= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
+    RCC-&gt;CFGR |= (uint32_t)RCC_CFGR_SW_PLL;    
+
+    /* Wait till PLL is used as system clock source */
+    while ((RCC-&gt;CFGR &amp; (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08)
+    {
+    }
+  }
+  else
+  { /* If HSE fails to start-up, the application will have wrong clock 
+         configuration. User can add here some code to deal with this error */    
+
+    /* Go to infinite loop */
+    while (1)
+    {
+    }
+  } 
+}
+
+#elif defined SYSCLK_FREQ_56MHz
+/**
+  * @brief  Sets System clock frequency to 56MHz and configure HCLK, PCLK2 
+  *          and PCLK1 prescalers. 
+  * @note   This function should be used only after reset.
+  * @param  None
+  * @retval None
+  */
+static void SetSysClockTo56(void)
+{
+  __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
+  
+  /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/   
+  /* Enable HSE */    
+  RCC-&gt;CR |= ((uint32_t)RCC_CR_HSEON);
+ 
+  /* Wait till HSE is ready and if Time out is reached exit */
+  do
+  {
+    HSEStatus = RCC-&gt;CR &amp; RCC_CR_HSERDY;
+    StartUpCounter++;  
+  } while((HSEStatus == 0) &amp;&amp; (StartUpCounter != HSEStartUp_TimeOut));
+
+  if ((RCC-&gt;CR &amp; RCC_CR_HSERDY) != RESET)
+  {
+    HSEStatus = (uint32_t)0x01;
+  }
+  else
+  {
+    HSEStatus = (uint32_t)0x00;
+  }  
+
+  if (HSEStatus == (uint32_t)0x01)
+  {
+    /* Enable Prefetch Buffer */
+    FLASH-&gt;ACR |= FLASH_ACR_PRFTBE;
+
+    /* Flash 1 wait state */
+    FLASH-&gt;ACR &amp;= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);
+    FLASH-&gt;ACR |= (uint32_t)FLASH_ACR_LATENCY_1;    
+ 
+    /* HCLK = SYSCLK */
+    RCC-&gt;CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;
+      
+    /* PCLK2 = HCLK */
+    RCC-&gt;CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;
+    
+    /* PCLK1 = HCLK */
+    RCC-&gt;CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV2;
+
+#ifdef STM32F10X_CL
+    /* Configure PLLs ------------------------------------------------------*/
+    /* PLL2 configuration: PLL2CLK = (HSE / 5) * 8 = 40 MHz */
+    /* PREDIV1 configuration: PREDIV1CLK = PLL2 / 5 = 8 MHz */
+        
+    RCC-&gt;CFGR2 &amp;= (uint32_t)~(RCC_CFGR2_PREDIV2 | RCC_CFGR2_PLL2MUL |
+                              RCC_CFGR2_PREDIV1 | RCC_CFGR2_PREDIV1SRC);
+    RCC-&gt;CFGR2 |= (uint32_t)(RCC_CFGR2_PREDIV2_DIV5 | RCC_CFGR2_PLL2MUL8 |
+                             RCC_CFGR2_PREDIV1SRC_PLL2 | RCC_CFGR2_PREDIV1_DIV5);
+  
+    /* Enable PLL2 */
+    RCC-&gt;CR |= RCC_CR_PLL2ON;
+    /* Wait till PLL2 is ready */
+    while((RCC-&gt;CR &amp; RCC_CR_PLL2RDY) == 0)
+    {
+    }
+    
+   
+    /* PLL configuration: PLLCLK = PREDIV1 * 7 = 56 MHz */ 
+    RCC-&gt;CFGR &amp;= (uint32_t)~(RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL);
+    RCC-&gt;CFGR |= (uint32_t)(RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLSRC_PREDIV1 | 
+                            RCC_CFGR_PLLMULL7); 
+#else     
+    /* PLL configuration: PLLCLK = HSE * 7 = 56 MHz */
+    RCC-&gt;CFGR &amp;= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLMULL));
+    RCC-&gt;CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_HSE | RCC_CFGR_PLLMULL7);
+
+#endif /* STM32F10X_CL */
+
+    /* Enable PLL */
+    RCC-&gt;CR |= RCC_CR_PLLON;
+
+    /* Wait till PLL is ready */
+    while((RCC-&gt;CR &amp; RCC_CR_PLLRDY) == 0)
+    {
+    }
+
+    /* Select PLL as system clock source */
+    RCC-&gt;CFGR &amp;= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
+    RCC-&gt;CFGR |= (uint32_t)RCC_CFGR_SW_PLL;    
+
+    /* Wait till PLL is used as system clock source */
+    while ((RCC-&gt;CFGR &amp; (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08)
+    {
+    }
+  }
+  else
+  { /* If HSE fails to start-up, the application will have wrong clock 
+         configuration. User can add here some code to deal with this error */    
+
+    /* Go to infinite loop */
+    while (1)
+    {
+    }
+  } 
+}
+
+#elif defined SYSCLK_FREQ_72MHz
+/**
+  * @brief  Sets System clock frequency to 72MHz and configure HCLK, PCLK2 
+  *          and PCLK1 prescalers. 
+  * @note   This function should be used only after reset.
+  * @param  None
+  * @retval None
+  */
+static void SetSysClockTo72(void)
+{
+  __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
+  
+  /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/    
+  /* Enable HSE */    
+  RCC-&gt;CR |= ((uint32_t)RCC_CR_HSEON);
+ 
+  /* Wait till HSE is ready and if Time out is reached exit */
+  do
+  {
+    HSEStatus = RCC-&gt;CR &amp; RCC_CR_HSERDY;
+    StartUpCounter++;  
+  } while((HSEStatus == 0) &amp;&amp; (StartUpCounter != HSEStartUp_TimeOut));
+
+  if ((RCC-&gt;CR &amp; RCC_CR_HSERDY) != RESET)
+  {
+    HSEStatus = (uint32_t)0x01;
+  }
+  else
+  {
+    HSEStatus = (uint32_t)0x00;
+  }  
+
+  if (HSEStatus == (uint32_t)0x01)
+  {
+    /* Enable Prefetch Buffer */
+    FLASH-&gt;ACR |= FLASH_ACR_PRFTBE;
+
+    /* Flash 2 wait state */
+    FLASH-&gt;ACR &amp;= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);
+    FLASH-&gt;ACR |= (uint32_t)FLASH_ACR_LATENCY_2;    
+
+ 
+    /* HCLK = SYSCLK */
+    RCC-&gt;CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;
+      
+    /* PCLK2 = HCLK */
+    RCC-&gt;CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;
+    
+    /* PCLK1 = HCLK */
+    RCC-&gt;CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV2;
+
+#ifdef STM32F10X_CL
+    /* Configure PLLs ------------------------------------------------------*/
+    /* PLL2 configuration: PLL2CLK = (HSE / 5) * 8 = 40 MHz */
+    /* PREDIV1 configuration: PREDIV1CLK = PLL2 / 5 = 8 MHz */
+        
+    RCC-&gt;CFGR2 &amp;= (uint32_t)~(RCC_CFGR2_PREDIV2 | RCC_CFGR2_PLL2MUL |
+                              RCC_CFGR2_PREDIV1 | RCC_CFGR2_PREDIV1SRC);
+    RCC-&gt;CFGR2 |= (uint32_t)(RCC_CFGR2_PREDIV2_DIV5 | RCC_CFGR2_PLL2MUL8 |
+                             RCC_CFGR2_PREDIV1SRC_PLL2 | RCC_CFGR2_PREDIV1_DIV5);
+  
+    /* Enable PLL2 */
+    RCC-&gt;CR |= RCC_CR_PLL2ON;
+    /* Wait till PLL2 is ready */
+    while((RCC-&gt;CR &amp; RCC_CR_PLL2RDY) == 0)
+    {
+    }
+    
+   
+    /* PLL configuration: PLLCLK = PREDIV1 * 9 = 72 MHz */ 
+    RCC-&gt;CFGR &amp;= (uint32_t)~(RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL);
+    RCC-&gt;CFGR |= (uint32_t)(RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLSRC_PREDIV1 | 
+                            RCC_CFGR_PLLMULL9); 
+#else    
+    /*  PLL configuration: PLLCLK = HSE * 9 = 72 MHz */
+    RCC-&gt;CFGR &amp;= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE |
+                                        RCC_CFGR_PLLMULL));
+    RCC-&gt;CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_HSE | RCC_CFGR_PLLMULL9);
+#endif /* STM32F10X_CL */
+
+    /* Enable PLL */
+    RCC-&gt;CR |= RCC_CR_PLLON;
+
+    /* Wait till PLL is ready */
+    while((RCC-&gt;CR &amp; RCC_CR_PLLRDY) == 0)
+    {
+    }
+    
+    /* Select PLL as system clock source */
+    RCC-&gt;CFGR &amp;= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
+    RCC-&gt;CFGR |= (uint32_t)RCC_CFGR_SW_PLL;    
+
+    /* Wait till PLL is used as system clock source */
+    while ((RCC-&gt;CFGR &amp; (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08)
+    {
+    }
+  }
+  else
+  { /* If HSE fails to start-up, the application will have wrong clock 
+         configuration. User can add here some code to deal with this error */    
+
+    /* Go to infinite loop */
+    while (1)
+    {
+    }
+  }
+}
+#endif
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+  
+/**
+  * @}
+  */    
+/******************* (C) COPYRIGHT 2009 STMicroelectronics *****END OF FILE****/


Property changes on: trunk/src/platform/stm32/system_stm32f10x.c
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/platform/stm32/system_stm32f10x.h
===================================================================
--- trunk/src/platform/stm32/system_stm32f10x.h	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/system_stm32f10x.h	2009-07-08 23:39:34 UTC (rev 354)
@@ -0,0 +1,100 @@
+/**
+  ******************************************************************************
+  * @file    system_stm32f10x.h
+  * @author  MCD Application Team
+  * @version V3.1.0
+  * @date    06/19/2009
+  * @brief   CMSIS Cortex-M3 Device Peripheral Access Layer System Header File.
+  ******************************************************************************  
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * &lt;h2&gt;&lt;center&gt;&copy; COPYRIGHT 2009 STMicroelectronics&lt;/center&gt;&lt;/h2&gt;
+  ******************************************************************************
+  */
+
+/** @addtogroup CMSIS
+  * @{
+  */
+
+/** @addtogroup stm32f10x_system
+  * @{
+  */  
+  
+/**
+  * @brief Define to prevent recursive inclusion
+  */
+#ifndef __SYSTEM_STM32F10X_H
+#define __SYSTEM_STM32F10X_H
+
+#ifdef __cplusplus
+ extern &quot;C&quot; {
+#endif 
+
+/** @addtogroup STM32F10x_System_Includes
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+
+/** @addtogroup STM32F10x_System_Exported_types
+  * @{
+  */
+
+extern const uint32_t SystemFrequency;          /*!&lt; System Clock Frequency (Core Clock) */
+extern const uint32_t SystemFrequency_SysClk;   /*!&lt; System clock                        */
+extern const uint32_t SystemFrequency_AHBClk;   /*!&lt; AHB System bus speed                */
+extern const uint32_t SystemFrequency_APB1Clk;  /*!&lt; APB Peripheral Bus 1 (low)  speed   */
+extern const uint32_t SystemFrequency_APB2Clk;  /*!&lt; APB Peripheral Bus 2 (high) speed   */
+
+/**
+  * @}
+  */
+
+/** @addtogroup STM32F10x_System_Exported_Constants
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @addtogroup STM32F10x_System_Exported_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @addtogroup STM32F10x_System_Exported_Functions
+  * @{
+  */
+  
+extern void SystemInit(void);
+/**
+  * @}
+  */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /*__SYSTEM_STM32F10X_H */
+
+/**
+  * @}
+  */
+  
+/**
+  * @}
+  */  
+/******************* (C) COPYRIGHT 2009 STMicroelectronics *****END OF FILE****/


Property changes on: trunk/src/platform/stm32/system_stm32f10x.h
___________________________________________________________________
Name: svn:executable
   + *

Modified: trunk/src/platform/stm32/systick.c
===================================================================
--- trunk/src/platform/stm32/systick.c	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/systick.c	2009-07-08 23:39:34 UTC (rev 354)
@@ -1,56 +1,10 @@
 #include &lt;stdio.h&gt;
 
-#include &quot;stm32f10x_lib.h&quot;
-#include &quot;stm32f10x_systick.h&quot;
+#include &quot;stm32f10x.h&quot;
 
 static vu32 TimingDelay = 0;
 
 /*******************************************************************************
-* Function Name  : SysTick_Config
-* Description    : Configure a SysTick Base time to 10 ms.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SysTick_Config(void)
-{
-  /* Configure HCLK clock as SysTick clock source */
-  SysTick_CLKSourceConfig(SysTick_CLKSource_HCLK);
- 
-  /* SysTick interrupt each 100 Hz with HCLK equal to 72MHz */
-  SysTick_SetReload(720000);
-
-  /* Enable the SysTick Interrupt */
-  SysTick_ITConfig(ENABLE);
-}
-
-/*******************************************************************************
-* Function Name  : Delay
-* Description    : Inserts a delay time.
-* Input          : nCount: specifies the delay time length (time base 10 ms).
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void Delay(u32 nCount)
-{
-  printf(&quot;Delay(%u)\n&quot;, (unsigned)nCount);
-  TimingDelay = nCount;
-
-  /* Enable the SysTick Counter */
-  SysTick_CounterCmd(SysTick_Counter_Enable);
-  
-  while(TimingDelay != 0)
-  {
-  }
-
-  /* Disable the SysTick Counter */
-  SysTick_CounterCmd(SysTick_Counter_Disable);
-
-  /* Clear the SysTick Counter */
-  SysTick_CounterCmd(SysTick_Counter_Clear);
-}
-
-/*******************************************************************************
 * Function Name  : Decrement_TimingDelay
 * Description    : Decrements the TimingDelay variable.
 * Input          : None

Modified: trunk/src/platform/stm32/systick.h
===================================================================
--- trunk/src/platform/stm32/systick.h	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/systick.h	2009-07-08 23:39:34 UTC (rev 354)
@@ -1,8 +1,7 @@
 #ifndef __SYSTICK_H__
 #define __SYSTICK_H__
 
-void SysTick_Config(void);
-void Delay(u32 nCount);
+/* void Delay(u32 nCount);*/
 void Decrement_TimingDelay(void);
 
 #endif
\ No newline at end of file

Modified: trunk/src/platform/stm32/type.h
===================================================================
--- trunk/src/platform/stm32/type.h	2009-07-04 17:10:41 UTC (rev 353)
+++ trunk/src/platform/stm32/type.h	2009-07-08 23:39:34 UTC (rev 354)
@@ -1,7 +1,7 @@
 #ifndef __TYPE_H__
 #define __TYPE_H__
 
-#include &quot;stm32f10x_type.h&quot;
+#include &quot;stm32f10x.h&quot;
 
 #ifndef NULL
 #define NULL    ((void *)0)


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000309.html">[Elua-svn] r353 - trunk/src/modules
</A></li>
	<LI>Next message: <A HREF="000310.html">[Elua-svn] r355 - trunk/src/platform/stm32/FWLib/library/src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#317">[ date ]</a>
              <a href="thread.html#317">[ thread ]</a>
              <a href="subject.html#317">[ subject ]</a>
              <a href="author.html#317">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/elua-svn">More information about the eLua-svn
mailing list</a><br>
</body></html>
