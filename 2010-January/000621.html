<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Elua-svn] r665 - in branches/pre0.7: . doc/eluadoc doc/en doc/pt
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/elua-svn/2010-January/index.html" >
   <LINK REL="made" HREF="mailto:elua-svn%40lists.berlios.de?Subject=Re%3A%20%5BElua-svn%5D%20r665%20-%20in%20branches/pre0.7%3A%20.%20doc/eluadoc%20doc/en%20doc/pt&In-Reply-To=%3C201001161447.o0GElTVJ032462%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000620.html">
   <LINK REL="Next"  HREF="000622.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Elua-svn] r665 - in branches/pre0.7: . doc/eluadoc doc/en doc/pt</H1>
    <B>dadosutter at BerliOS</B> 
    <A HREF="mailto:elua-svn%40lists.berlios.de?Subject=Re%3A%20%5BElua-svn%5D%20r665%20-%20in%20branches/pre0.7%3A%20.%20doc/eluadoc%20doc/en%20doc/pt&In-Reply-To=%3C201001161447.o0GElTVJ032462%40sheep.berlios.de%3E"
       TITLE="[Elua-svn] r665 - in branches/pre0.7: . doc/eluadoc doc/en doc/pt">dadosutter at mail.berlios.de
       </A><BR>
    <I>Sat Jan 16 15:47:29 CET 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="000620.html">[Elua-svn] r664 - branches/pre0.7/doc/en
</A></li>
        <LI>Next message: <A HREF="000622.html">[Elua-svn] r666 - in branches/pre0.7: . doc doc/eluadoc doc/en	doc/pt
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#621">[ date ]</a>
              <a href="thread.html#621">[ thread ]</a>
              <a href="subject.html#621">[ subject ]</a>
              <a href="author.html#621">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: dadosutter
Date: 2010-01-16 15:47:22 +0100 (Sat, 16 Jan 2010)
New Revision: 665

Added:
   branches/pre0.7/doc/pt/building_unix.html
   branches/pre0.7/doc/pt/building_win.html
   branches/pre0.7/doc/pt/elua_egc.html
   branches/pre0.7/doc/pt/fatfs.html
   branches/pre0.7/doc/pt/filesystems.html
   branches/pre0.7/doc/pt/installing_lpc2468.html
   branches/pre0.7/doc/pt/modules_str9.html
Modified:
   branches/pre0.7/LICENSE
   branches/pre0.7/doc/eluadoc/refman_gen_adc.lua
   branches/pre0.7/doc/eluadoc/refman_gen_bit.lua
   branches/pre0.7/doc/eluadoc/refman_gen_cpu.lua
   branches/pre0.7/doc/eluadoc/refman_gen_elua.lua
   branches/pre0.7/doc/eluadoc/refman_gen_net.lua
   branches/pre0.7/doc/eluadoc/refman_gen_pack.lua
   branches/pre0.7/doc/eluadoc/refman_gen_pd.lua
   branches/pre0.7/doc/eluadoc/refman_gen_pio.lua
   branches/pre0.7/doc/eluadoc/refman_gen_pwm.lua
   branches/pre0.7/doc/eluadoc/refman_gen_spi.lua
   branches/pre0.7/doc/eluadoc/refman_gen_term.lua
   branches/pre0.7/doc/eluadoc/refman_gen_tmr.lua
   branches/pre0.7/doc/eluadoc/refman_gen_uart.lua
   branches/pre0.7/doc/eluadoc/refman_ps_lm3s_disp.lua
   branches/pre0.7/doc/eluadoc/refman_ps_str9_pio.lua
   branches/pre0.7/doc/en/news.html
   branches/pre0.7/doc/en/overview.html
   branches/pre0.7/doc/pt/news.html
   branches/pre0.7/doc/pt/overview.html
Log:
- PT-BR Doc updated to reflect v0.7 work.
- Added (translated) critical files: LICENSE, lib licenses...
- Added (translated) critical pages: Credits, News, Version History, (maybe others)
- New EN docs copied to PT (not translated yet) to keep the integrity of the doc/site.
- Links added to the v0.7 news entry. Direct access to new features' doc.
- LICENCE notes copied to the License section on the doc/site
- Added (translated) PT-BR Licence section
- Added missing PT-BR sections in Refman pages
- Main Menu revised to keep PT version's integrity, even with missing translations
- General doc revision fixes



Modified: branches/pre0.7/LICENSE
===================================================================
--- branches/pre0.7/LICENSE	2010-01-16 00:10:06 UTC (rev 664)
+++ branches/pre0.7/LICENSE	2010-01-16 14:47:22 UTC (rev 665)
@@ -10,7 +10,7 @@
 The &quot;bit&quot; module is adapted from the &quot;bitlib&quot; library by Reuben Thomas which
 is distributed under a MIT license.
 
-The &quot;integer only lua&quot; is based on the &quot;Go Long Lua!&quot; patch by John D.
+The &quot;integer only Lua&quot; is based on the &quot;Go Long Lua!&quot; patch by John D.
 Ramsdell (from the Lua Power Patches page) and is placed in the public
 domain.
 
@@ -33,7 +33,7 @@
 
 The rest of the eLua code is licensed under MIT, listed below.
 
-================================================================================
+
 The MIT License
 
 Copyright (c) 2009 Dado Sutter and Bogdan Marinescu

Modified: branches/pre0.7/doc/eluadoc/refman_gen_adc.lua
===================================================================
--- branches/pre0.7/doc/eluadoc/refman_gen_adc.lua	2010-01-16 00:10:06 UTC (rev 664)
+++ branches/pre0.7/doc/eluadoc/refman_gen_adc.lua	2010-01-16 14:47:22 UTC (rev 665)
@@ -97,100 +97,4 @@
   }
 }
 
-data_pt = 
-{
-
-  -- Title
-  title = &quot;eLua reference manual - ADC&quot;,
-
-  -- Menu name
-  menu_name = &quot;adc&quot;,
-
-  -- Overview
-  overview = [[This module contains functions that access analog to digital converter (ADC) peripherals.&lt;/p&gt;
-  &lt;p&gt;When utilizing this module, acquiring ADC data is a two step process: requesting sample conversions (using $adc.sample$) and extraction of conversion results from a conversion buffer (using $adc.getsample$, $adc.getsamples$ or $adc.insertsamples$). Various configuration parameters are available to set conversion rate, how results are extracted from the buffer and how these results are processed prior to extraction.&lt;/p&gt;
-  &lt;p&gt;This module can be utilized if the device in use has a supported ADC peripheral (see @<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">status.html at status</A>@ for details) and if ADC functionality is enabled at build time (see @<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">building.html at building</A>@).]],
-
-  -- Functions
-  funcs = 
-  {
-    { sig = &quot;#adc.sample#( id, count )&quot;,
-      desc = &quot;Initiate conversion and buffering of samples on an ADC channel.&quot;,
-      args = 
-      {
-        &quot;$id$ - ADC channel ID. Optionally, this may be a table containing a list of channel IDs (i.e.: {0, 2, 3}), allowing synchronization of acquisition. NOTE: This acceptance of mixed types is only for the sample function.&quot;,
-        &quot;$count$ - number of samples to acquire and place in buffer.&quot;
-      }
-    },
-    { sig = &quot;sample = #adc.getsample#( id )&quot;,
-      desc = &quot;Get a single conversion value from the buffer associated with a given channel.&quot;,
-      args = 
-      {
-        &quot;$id$ - ADC channel ID.&quot;
-      },
-      ret = &quot;$sample$ - numeric value of conversion, or nil if sample was not available.&quot;
-    },
-    { sig = &quot;samples = #adc.getsamples#( id, count )&quot;,
-      desc = &quot;Get multiple conversion values from the buffer associated with a given channel.&quot;,
-      args = 
-      {
-        &quot;$id$ - ADC channel ID.&quot;,
-        &quot;$count$ - optional parameter to indicate number of samples to return. If not included, all available samples are returned.&quot;
-      },
-      ret = &quot;$samples$ - table containing integer conversion values. If not enough samples are available, remaining indices will be nil.&quot;
-    },
-    { sig = &quot;#adc.insertsamples#( id, table, idx, count )&quot;,
-      desc = &quot;Get multiple conversion values from a channel's buffer, and write them into a table.&quot;,
-      args = 
-      {
-        &quot;$id$ - ADC channel ID.&quot;,
-        &quot;$table$ - table to write samples to. Values at $table$[$idx$] to $table$[$idx$ + $count$ -1] will be overwritten with samples (or nil if not enough samples are available).&quot;,
-        &quot;$idx$ - first index to use in the table for writing samples.&quot;,
-        &quot;$count$ - number of samples to return. If not enough samples are available (after blocking, if enabled) remaining values will be nil.&quot;
-      }
-    },
-    { sig = &quot;maxval = #adc.maxval#( id )&quot;,
-      desc = &quot;Get the maximum value (corresponding to the maximum voltage) that can be returned on a given channel.&quot;,
-      args = 
-      {
-        &quot;$id$ - ADC channel ID.&quot;
-      },
-      ret = &quot;$maxval$ - maximum integer conversion value (based on channel resolution)&quot;
-    },
-    { sig = &quot;clock = #adc.setclock#( id, clock, timer_id )&quot;,
-      desc = &quot;Set the frequency (number of samples per second) at which voltages will be converted into samples.&quot;,
-      args = 
-      {
-        &quot;$id$ - ADC channel ID.&quot;,
-        &quot;$clock$ - frequency to acquire samples at in Hz (number of samples per second), 0 to acquire as fast as possible.&quot;,
-        &quot;$timer_id$ - Timer channel ID to use to control ADC conversion. &lt;strong&gt;Note:&lt;/strong&gt; At this time, a timer selection will apply to all channels on a given ADC peripheral.&quot;
-      },
-      ret = &quot;$clock$ - actual acquisition frequency to be used&quot;
-    },
-    { sig = &quot;status = #adc.isdone#( id )&quot;,
-      desc = &quot;Check whether samples are still being acquired on a channel.&quot;,
-      args = 
-      {
-        &quot;$id$ - ADC channel ID.&quot;
-      },
-      ret = &quot;$status$ - 1 if no samples are being acquired, 0 if samples are pending acquisition.&quot;
-    },
-    { sig = &quot;#adc.setblocking#( id, mode )&quot;,
-      desc = &quot;Set whether or not functions that request converted samples should wait for requested samples or return immediately with what is available.&quot;,
-      args = 
-      {
-        &quot;$id$ - ADC channel ID.&quot;,
-        &quot;$mode$ - 1 if requests to get samples should block until requested samples are available or sampling has completed, 0 to return immediately with available samples&quot;
-      },
-    },
-    { sig = &quot;#adc.setsmoothing#( id, length )&quot;,
-      desc = &quot;Set the length of the moving average filter. When $length$ is greater than 1, samples pulled from the conversion buffer will be averaged with the preceding $length$ - 1 buffered values.&quot;,
-      args = 
-      {
-        &quot;$id$ - ADC channel ID.&quot;,
-        &quot;$length$ - number of preceding samples to include in moving average filter (must be a power of 2). If 1, filter is disabled. When enabled, a filter buffer is filled before the main conversion buffer, so that averages are always over the same number of samples.&quot;
-      }
-    }
-  }
-}
-
+data_pt = data_en

Modified: branches/pre0.7/doc/eluadoc/refman_gen_bit.lua
===================================================================
--- branches/pre0.7/doc/eluadoc/refman_gen_bit.lua	2010-01-16 00:10:06 UTC (rev 664)
+++ branches/pre0.7/doc/eluadoc/refman_gen_bit.lua	2010-01-16 14:47:22 UTC (rev 665)
@@ -10,7 +10,7 @@
   menu_name = &quot;bit&quot;,
 
   -- Overview
-  overview = [[Since Lua doesn't have built-in capabilities for bit operations, the $bit$ module was added to eLua to fill this gap. It is based on the ^<A HREF="http://luaforge.net/projects/bitlib^bitlib^">http://luaforge.net/projects/bitlib^bitlib^</A>
+  overview = [[Since Lua doesn't have (yet) built-in capabilities for bit operations, the $bit$ module was added to eLua to fill this gap. It is based on the ^<A HREF="http://luaforge.net/projects/bitlib^bitlib^">http://luaforge.net/projects/bitlib^bitlib^</A>
   library written by Reuben Thomas (slightly adapted to eLua) and provides basic bit operations (like setting and clearing bits) and bitwise operations.]],
 
   -- Functions
@@ -19,7 +19,7 @@
     { sig = &quot;number = #bit.bit#( position )&quot;,
       desc = &quot;Generate a number with a 1 bit (used for mask generation). Equivalent to %1 &lt;&lt;&lt;&lt; position% in C.&quot;,
       args = &quot;$position$ - position of the bit that will be set to 1.&quot;,
-      ret = &quot;$number$ - a number with only one 1 bit at $position$ (the rest are set to 0.&quot;
+      ret = &quot;$number$ - a number with only one 1 bit at $position$ (the rest are set to 0).&quot;
     },
 
     { sig = &quot;flag = #bit.isset#( value, position )&quot;,
@@ -137,140 +137,4 @@
   }
 }
 
-data_pt = 
-{
-
-  -- Title
-  title = &quot;eLua reference manual - bit module&quot;,
-
-  -- Menu name
-  menu_name = &quot;bit&quot;,
-
-  -- Overview
-  overview = [[Since Lua doesn't have built-in capabilities for bit operations, the $bit$ module was added to eLua to fill this gap. It is based on the ^<A HREF="http://luaforge.net/projects/bitlib^bitlib^">http://luaforge.net/projects/bitlib^bitlib^</A>
-  library written by Reuben Thomas (slightly adapted to eLua) and provides basic bit operations (like setting and clearing bits) and bitwise operations.]],
-
-  -- Functions
-  funcs = 
-  {
-    { sig = &quot;number = #bit.bit#( position )&quot;,
-      desc = &quot;Generate a number with a 1 bit (used for mask generation). Equivalent to %1 &lt;&lt;&lt;&lt; position% in C.&quot;,
-      args = &quot;$position$ - position of the bit that will be set to 1.&quot;,
-      ret = &quot;$number$ - a number with only one 1 bit at $position$ (the rest are set to 0.&quot;
-    },
-
-    { sig = &quot;flag = #bit.isset#( value, position )&quot;,
-      desc = &quot;Test if a given bit is set.&quot;,
-      args = 
-      {
-        &quot;$value$ - the value to test.&quot;,
-        &quot;$position$ - bit position to test.&quot;
-      },
-      ret = &quot;$number$ - 1 if the bit at the given position is 1, 0 otherwise.&quot;
-    },
-
-    { sig = &quot;flag = #bit.isclear#( value, position )&quot;,
-      desc = &quot;Test if a given bit is cleared.&quot;,
-      args = 
-      {
-        &quot;$value$ - the value to test.&quot;,
-        &quot;$position$ - bit position to test.&quot;
-      },
-      ret = &quot;$number$ - 1 if the bit at the given position is 0, 0 othewise.&quot;
-    },
-
-    { sig = &quot;number = #bit.set#( value, pos1, pos2, ..., posn )&quot;,
-      desc = &quot;Set bits in a number.&quot;,
-      args =
-      {
-        &quot;$value$ - the base number.&quot;,
-        &quot;$pos1$ - position of the first bit to set.&quot;,
-        &quot;$pos2$ - position of the second bit to set.&quot;,
-        &quot;$posn$ - position of the nth bit to set.&quot;
-      },
-      ret = &quot;$number$ - the number with the bit(s) set in the given position(s).&quot;
-    },
-
-    { sig = &quot;number = #bit.clear#( value, pos1, pos2, ..., posn )&quot;,
-      desc = &quot;Clear bits in a number.&quot;,
-      args = 
-      {
-        &quot;$value$ - the base number.&quot;,
-        &quot;$pos1$ - position of the first bit to clear.&quot;,
-        &quot;$pos2$ - position of the second bit to clear.&quot;,
-        &quot;$posn$ - position of thet nth bit to clear.&quot;,
-      },
-      ret = &quot;$number$ - the number with the bit(s) cleared in the given position(s).&quot;
-    },
-
-    { sig = &quot;number = #bit.bnot#( value )&quot;,
-      desc = &quot;Bitwise negation, equivalent to %~~value% in C.&quot;,
-      args = &quot;$value$ - the number to negate.&quot;,
-      ret = &quot;$number$ - the bitwise negated value of the number.&quot;,
-    },
-
-    { sig = &quot;number = #bit.band#( val1, val2, ... valn )&quot;,
-      desc = &quot;Bitwise AND, equivalent to %val1 &amp; val2 &amp; ... &amp; valn% in C.&quot;,
-      args = 
-      {
-        &quot;$val1$ - first AND argument.&quot;,
-        &quot;$val2$ - second AND argument.&quot;,
-        &quot;$valn$ - nth AND argument.&quot;,
-      },
-      ret = &quot;$number$ - the bitwise AND of all the arguments.&quot;
-    },
-
-    { sig = &quot;number = #bit.bor#( val1, val2, ... valn )&quot;,
-      desc = &quot;Bitwise OR, equivalent to %val1 | val2 | ... | valn% in C.&quot;,
-      args = 
-      {
-        &quot;$val1$ - first OR argument.&quot;,
-        &quot;$val2$ - second OR argument.&quot;,
-        &quot;$valn$ - nth OR argument.&quot;
-      },
-      ret = &quot;$number$ - the bitwise OR of all the arguments.&quot;
-    },
-
-    { sig = &quot;number = #bit.bxor#( val1, val2, ... valn )&quot;,
-      desc = &quot;Bitwise exclusive OR (XOR), equivalent to %val1 ^^ val2 ^^ ... ^^ valn% in C.&quot;,
-      args = 
-      {
-        &quot;$val1$ - first XOR argument.&quot;,
-        &quot;$val2$ - second XOR argument.&quot;,
-        &quot;$valn$ - nth XOR argument.&quot;
-      },
-      ret = &quot;$number$ - the bitwise exclusive OR of all the arguments.&quot;
-    },
-
-    { sig = &quot;number = #bit.lshift#( value, shift )&quot;,
-      desc = &quot;Left-shift a number, equivalent to %value &lt;&lt; shift% in C.&quot;,
-      args = 
-      {
-        &quot;$value$ - the value to shift.&quot;,
-        &quot;$shift$ - positions to shift.&quot;,
-      },
-      ret = &quot;$number$ - the number shifted left&quot;,
-    },
-
-    { sig = &quot;number = #bit.rshift#( value, shift )&quot;,
-      desc = &quot;Logical right shift a number, equivalent to %( unsigned )value &gt;&gt;&gt;&gt; shift% in C.&quot;,
-      args = 
-      {
-        &quot;$value$ - the value to shift.&quot;,
-        &quot;$shift$ - positions to shift.&quot;,
-      },
-      ret = &quot;$number$ - the number shifted right (logically).&quot;
-    },
-
-    { sig = &quot;number = #bit.arshift#( value, shift )&quot;,
-      desc = &quot;Arithmetic right shift a number equivalent to %value &gt;&gt;&gt;&gt; shift% in C.&quot;,
-      args = 
-      {
-        &quot;$value$ - the value to shift.&quot;,
-        &quot;$shift$ - positions to shift.&quot;
-      },
-      ret = &quot;$number$ - the number shifted right (arithmetically).&quot;
-    }
-  }
-}
-
+data_pt = data_en

Modified: branches/pre0.7/doc/eluadoc/refman_gen_cpu.lua
===================================================================
--- branches/pre0.7/doc/eluadoc/refman_gen_cpu.lua	2010-01-16 00:10:06 UTC (rev 664)
+++ branches/pre0.7/doc/eluadoc/refman_gen_cpu.lua	2010-01-16 14:47:22 UTC (rev 665)
@@ -98,101 +98,4 @@
   },
 }
 
-data_pt = 
-{
-
-  -- Title
-  title = &quot;eLua reference manual - CPU module&quot;,
-
-  -- Menu name
-  menu_name = &quot;cpu&quot;,
-
-  -- Overview
-  overview = [[This module deals with low-level access to CPU (and related modules) functionality, such as reading and writing memory, or 
-  enabling and disabling interrupts. It also offers access to platform specific CPU-related constants using a special macro defined in the
-  platform's $platform_conf.h$ file, as exaplained @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">cpu_constants at here</A>@.]],
-
-  -- Data structures, constants and types
-  structures = 
-  {
-    { text = [[cpu.INT_GPIOA
-cpu.INT_GPIOB
-.............
-cpu.INT_UDMA]],
-      name = &quot;CPU constants&quot;,
-      desc = [[eLua has a mechanism that lets the user export an unlimited number of constants to the $cpu$ module. Although in theory any kind of constant can be exposed by this module,
-one should only use constants related to the CPU and its subsystems (as shown above, where a number of CPU specific interrupt masks are exposed to Lua using this mechanism). To use this
-mechanism, just declare the $PLATFORM_CPU_CONSTANTS$ macro in your platform's $platform_conf.h$ file and list all your constants as part of this macro, each enclosed in a special macro called
-$_C$. For example, to get the constants listed above declare your $PLATFORM_CPU_CONSTANTS$ macro like this:&lt;/p&gt;
-~#define PLATFORM_CPU_CONSTANTS\
-  _C( INT_GPIOA ),\
-  _C( INT_GPIOB ),\
-  .................
-  _C( INT_UDMA )~
-&lt;p&gt;It's worth to note that adding more constants does not increas RAM usage, only Flash usage, so you can expose as much constants as you need without worrying about RAM consumption.]]
-    },
-  },
-
-  -- Functions
-  funcs = 
-  {
-    { sig = &quot;#cpu.w32#( address, data )&quot;,
-      desc = &quot;Writes a 32-bit word to memory.&quot;,
-      args = 
-      {
-        &quot;$address$ - the memory address.&quot;,
-        &quot;$data$ - the 32-bit data to write.&quot;
-      },
-    },
-
-    { sig = &quot;data = #cpu.r32#( address )&quot;,
-      desc = &quot;Read a 32-bit word from memory.&quot;,
-      args = &quot;$address$ - the memory address.&quot;,
-      ret = &quot;$data$ - the 32-bit word read from memory.&quot;
-    },
-
-    { sig = &quot;#cpu.w16#( address, data )&quot;,
-      desc = &quot;Writes a 16-bit word to memory.&quot;,
-      args =
-      {
-        &quot;$address$ - the memory address.&quot;,
-        &quot;$data$ - the 16-bit data to write.&quot;
-      },
-    },
-
-    { sig = &quot;data = #cpu.r16#( address )&quot;,
-      desc = &quot;Reads a 16-bit word from memory.&quot;,
-      args = &quot;$address$ - the memory address.&quot;,
-      ret = &quot;$data$ - the 16-bit word read from memory.&quot;
-    },
-
-    { sig = &quot;#cpu.w8#( address, data )&quot;,
-      desc = &quot;Writes a byte to memory.&quot;,
-      args =
-      {
-        &quot;$address$ - the memory address.&quot;,
-        &quot;$data$ - the byte to write.&quot;
-      }
-    },
-
-    { sig = &quot;data = #cpu.r8#( address )&quot;,
-      desc = &quot;Reads a byte from memory.&quot;,
-      args = &quot;$address$ - the memory address&quot;,
-      ret = &quot;$data$ - the byte read from memory.&quot;
-    },
-
-    { sig = &quot;#cpu.cli#()&quot;,
-      desc = &quot;Disable CPU interrupts.&quot;
-    },
-
-    { sig = &quot;#cpu.sei#()&quot;,
-      desc = &quot;Enable CPU interrupts.&quot;
-    },
-
-    { sig = &quot;clock = #cpu.clock#()&quot;,
-      desc = &quot;Get the CPU core frequency.&quot;,
-      ret = &quot;$clock$ - the CPU clock (in Hertz).&quot;
-    }
-  },
-}
-
+data_pt = data_en

Modified: branches/pre0.7/doc/eluadoc/refman_gen_elua.lua
===================================================================
--- branches/pre0.7/doc/eluadoc/refman_gen_elua.lua	2010-01-16 00:10:06 UTC (rev 664)
+++ branches/pre0.7/doc/eluadoc/refman_gen_elua.lua	2010-01-16 14:47:22 UTC (rev 665)
@@ -26,3 +26,4 @@
   },
 }
 
+data_pt = data_en

Modified: branches/pre0.7/doc/eluadoc/refman_gen_net.lua
===================================================================
--- branches/pre0.7/doc/eluadoc/refman_gen_net.lua	2010-01-16 00:10:06 UTC (rev 664)
+++ branches/pre0.7/doc/eluadoc/refman_gen_net.lua	2010-01-16 14:47:22 UTC (rev 665)
@@ -160,163 +160,4 @@
   },
 }
 
-data_pt = 
-{
-
-  -- Title
-  title = &quot;eLua reference manual - net module&quot;,
-
-  -- Menu name
-  menu_name = &quot;net&quot;,
-
-  -- Overview
-  overview = [[This module contains functions for accessing a TCP/IP network from eLua. It can be enabled only if networking support is also enabled
-  (see @<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">building.html at building</A>@ for details).&lt;/p&gt;
-  &lt;p&gt;&lt;span class=&quot;warning&quot;&gt;NOTE:&lt;/span&gt; TCP/IP support is $experimental$ in eLua. While functional, it's still slow and suffers from a number of
-  other issues. It will most likely change a lot in the future, so expect major changes to this module as well.&lt;/p&gt;
-  &lt;p&gt;&lt;span class=&quot;warning&quot;&gt;NOTE:&lt;/span&gt; currently, only TCP sockets are supported by eLua.]],
-
-  -- Structures
-  structures =
-  {
-    { text = [[// eLua net error codes
-enum
-{
-  ELUA_NET_ERR_OK = 0,            // exported as $net.ERR_OK$
-  ELUA_NET_ERR_TIMEDOUT,          // exported as $net.ERR_TIMEDOUT$
-  ELUA_NET_ERR_CLOSED,            // exported as $net.ERR_CLOSED$
-  ELUA_NET_ERR_ABORTED,           // exported as $net.ERR_ABORTED$
-  ELUA_NET_ERR_OVERFLOW           // exported as $net.ERR_OVERFLOW$
-};]],
-      name = &quot;Error codes&quot;,
-      desc = &quot;These are the error codes defined by the eLua networking layer and they are also returned by a number of functions in this module.&quot;,
-    }
-  },
-
-  -- Functions
-  funcs = 
-  {
-    { sig = &quot;ip = #net.packip#( ip1, ip2, ip3, ip4 )&quot;,
-      desc = [[Returns an internal representation of an IP address that can be used with all function from the $net$ module that expect an IP address
-argument. The IP is considered to be in the format %ip1.ip2.ip3.ip4%.]],
-      args = 
-      {
-        &quot;$ip1$ - the first part of the IP address.&quot;,
-        &quot;$ip2$ - the second part of the IP address.&quot;,
-        &quot;$ip3$ - the third part of the IP address.&quot;,
-        &quot;$ip4$ - the fourth part of the IP address.&quot;
-      },
-      ret = &quot;An integer that encodes the IP address in an internal format.&quot;
-    },
-
-     { sig = &quot;ip = #net.packip#( 'ip' )&quot;,
-      desc = [[Returns an internal representation of an IP address that can be used with all function from the $net$ module that expect an IP address
-argument. The IP is given as a string.]],
-      args = &quot;$ip$ - the IP address in string format.&quot;,
-      ret = &quot;An integer that encodes the IP address in an internal format.&quot;
-    },
-
-    { sig = &quot;ip1, ip2, ip3, ip4 = #net.unpackip#( ip, '*n' )&quot;,
-      desc = &quot;Returns an unpacked representation of an IP address encoded by @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">net.packip at net.packip</A>@.&quot;,
-      args = &quot;$ip$ - the encoded IP address.&quot;,
-      ret = 
-      {
-        &quot;$ip1$ - the first part of the IP address.&quot;,
-        &quot;$ip2$ - the second part of the IP address.&quot;,
-        &quot;$ip3$ - the third part of the IP address.&quot;,
-        &quot;$ip4$ - the fourth part of the IP address.&quot;
-      }
-    },
-   
-    { sig = &quot;ip = #net.unpackip#( ip, '*s' )&quot;,
-      desc = &quot;Returns an unpacked representation of an IP address encoded by @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">net.packip at net.packip</A>@.&quot;,
-      args = &quot;$ip$ - the encoded IP address.&quot;,
-      ret = &quot;The IP address in string format.&quot;
-    },
-
-
-    { sig = &quot;ip = #net.lookup#( hostname )&quot;,
-      desc = &quot;Does a DNS lookup.&quot;,
-      args = &quot;$hostname$ - the name of the computer.&quot;,
-      ret = &quot;The IP address of the computer.&quot;
-    },
-
-    { sig = &quot;socket = #net.socket#( type )&quot;,
-      desc = &quot;Create a socket for TCP/IP communication.&quot;,
-      args = [[$type$ - can be either $net.SOCK_STREAM$ for TCP sockets or $net.SOCK_DGRAM$ for UDP sockets (&lt;span class=&quot;warning&quot;&gt;not yet supported&lt;/span&gt;).]],
-      ret = &quot;The socket that will be used in subsequent operations.&quot;
-    },
-
-    { sig = &quot;res = #net.close#( socket )&quot;,
-      desc = &quot;Close a socket.&quot;,
-      args = &quot;$socket$ - the socket to close.&quot;,
-      ret = &quot;An error code, as defined @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">error_codes at here</A>@.&quot;
-    },
-
-    { sig = &quot;err = #net.connect#( sock, ip, port )&quot;,
-      desc = &quot;Connect a socket to a remote system.&quot;,
-      args = 
-      {
-        &quot;$sock$ - a socket obtained from @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">net.socket at net.socket</A>@.&quot;,
-        &quot;$ip$ - the IP address obtained from @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">net.packip at net.packip</A>@.&quot;,
-        &quot;$port$ - the port to connecto to.&quot;
-      },
-      ret = &quot;$err$ - the error code, as defined @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">error_codes at here</A>@.&quot;
-    },
-
-    { sig = &quot;socket, remoteip, err = #net.accept#( port, [timer_id, timeout] )&quot;,
-      desc = &quot;Accept a connection from a remote system with an optional timeout.&quot;,
-      args =
-      {
-        &quot;$port$ - the port to wait for connections from the remote system.&quot;,
-        [[$timer_id (optional)$ - the timer ID of the timer used to timeout the accept function after a specified time. If this is specified, $timeout$ must also
-be specified.]],
-        [[$timeout (optional)$ - the timeout after which the accept function returns if no connection was requested. If this is specified, $timer_id$ must also
-be specified.]]
-      },
-      ret =
-      {
-        &quot;$socket$ - the socket created after accepting the remote connection.&quot;,
-        &quot;$remoteip$ - the IP of the remote system.&quot;,
-        &quot;$err$ - an error code, as defined @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">error_codes at here</A>@.&quot;
-      }
-    },
-
-    { sig = &quot;res, err = #net.send#( sock, str )&quot;,
-      desc = &quot;Send data to a socket.&quot;,
-      args = 
-      {
-        &quot;$sock$ - the socket.&quot;,
-        &quot;$str$ - the data to send.&quot;
-      },
-      ret = 
-      {
-        &quot;$res$ - the number of bytes actually sent or -1 for error.&quot;,
-        &quot;$err$ - the error code, as defined @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">error_codes at here</A>@.&quot;
-      }
-    },
-
-    { sig = &quot;res, err = #net.recv#( sock, format, [timer_id, timeout] )&quot;,
-      desc = &quot;Read data from a socket.&quot;,
-      args = 
-      {
-        &quot;$sock$ - the socket.&quot;,
-        [[$format$ - how to read the data. This can be either:
-&lt;ul&gt;
-  &lt;li&gt;$&quot;*l&quot;$: read a line (until the next '\n' character).&lt;/li&gt;
-  &lt;li&gt;$an integer$: read up to that many bytes.&lt;/li&gt;
-&lt;/ul&gt;]],
-        [[$timer_id (optional)$ - the timer ID of the timer used to timeout the recv function after a specified time. If this is specified, $timeout$ must also
-be specified.]],
-        [[$timeout (optional)$ - the timeout after which the recv function returns if no connection was requested. If this is specified, $timer_id$ must also
-be specified.]]
-      },
-      ret =
-      {
-        &quot;$res$ - the number of bytes read.&quot;,
-        &quot;$err$ - the error code, as defined @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">error_codes at here</A>@.&quot;
-      }
-    }
-  },
-}
-
+data_pt = data_en

Modified: branches/pre0.7/doc/eluadoc/refman_gen_pack.lua
===================================================================
--- branches/pre0.7/doc/eluadoc/refman_gen_pack.lua	2010-01-16 00:10:06 UTC (rev 664)
+++ branches/pre0.7/doc/eluadoc/refman_gen_pack.lua	2010-01-16 14:47:22 UTC (rev 665)
@@ -24,6 +24,7 @@
     &lt;li&gt;$'='$ for native endian (the platform's endian order, default).&lt;/li&gt;
   &lt;/ol&gt;&lt;/li&gt;
   &lt;li&gt;$format specifier$ describes what kind of variable will be packed/unpacked. $The format specifier is case-sensitive$. The possible values of this parameter are summarized in the table below:
+  &lt;p/&gt;
   &lt;table class=&quot;table_center&quot; style=&quot;margin-top: 4px; margin-bottom: 4px;&quot;&gt;
   &lt;tbody&gt;
   &lt;tr&gt;
@@ -134,137 +135,4 @@
   },
 }
 
-data_pt = 
-{
-
-  -- Title
-  title = &quot;eLua reference manual - pack&quot;,
-
-  -- Menu name
-  menu_name = &quot;pack&quot;,
-
-  -- Overview
-  overview = [[This module allows for arbitrary packing of data into Lua strings and unpacking data from Lua strings. In this way, a string can be used to store data in a platform-indepdendent 
-manner. It is based on the ^<A HREF="http://www.tecgraf.puc-rio.br/~~lhf/ftp/lua/#lpack^lpack^">http://www.tecgraf.puc-rio.br/~~lhf/ftp/lua/#lpack^lpack^</A> module from Luiz Henrique de Figueiredo (with some minor tweaks). &lt;/p&gt;
-&lt;p&gt;Both methods of this module (@#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">pack at pack</A>@ and @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">unpack at unpack</A>@) use a $format string$ to describe how to pack/unpack the data. The format string contains one or more $data specifiers$, each
-data specifier is applied to a single variable that must be packed/unpacked. The data specifier has the following general format:&lt;/p&gt;
-~[endianness]&lt;&lt;format specifier&gt;&gt;[count]~
-&lt;p&gt;where:&lt;/p&gt;
-&lt;ul&gt;
-  &lt;li&gt;$endianness$ is an optional endian flags that specifies how the numbers that are to be packed/unpacked are stored in memory. It can be either:
-  &lt;ol&gt;
-    &lt;li&gt;$'&lt;&lt;'$ for little endian.&lt;/li&gt;
-    &lt;li&gt;$'&gt;&gt;'$ for big endian.&lt;/li&gt;
-    &lt;li&gt;$'='$ for native endian (the platform's endian order, default).&lt;/li&gt;
-  &lt;/ol&gt;&lt;/li&gt;
-  &lt;li&gt;$format specifier$ describes what kind of variable will be packed/unpacked. $The format specifier is case-sensitive$. The possible values of this parameter are summarized in the table below:
-  &lt;table class=&quot;table_center&quot; style=&quot;margin-top: 4px; margin-bottom: 4px;&quot;&gt;
-  &lt;tbody&gt;
-  &lt;tr&gt;
-    &lt;th&gt;Format specifier&lt;/th&gt;
-    &lt;th&gt;Corresponding variable type&lt;/th&gt;
-  &lt;/tr&gt;
-  &lt;tr&gt;
-    &lt;td&gt;'z'&lt;/td&gt;
-    &lt;td&gt;zero-terminated string&lt;/td&gt;
-  &lt;/tr&gt;  
-  &lt;tr&gt;
-    &lt;td&gt;'p'   &lt;/td&gt;
-    &lt;td&gt;string preceded by length byte&lt;/td&gt;
-  &lt;/tr&gt;  
-  &lt;tr&gt;
-    &lt;td&gt;'P'   &lt;/td&gt;
-    &lt;td&gt;string preceded by length word&lt;/td&gt;
-  &lt;/tr&gt;  
-  &lt;tr&gt;
-    &lt;td&gt;'a'   &lt;/td&gt;
-    &lt;td&gt;string preceded by length size_t&lt;/td&gt;
-  &lt;/tr&gt;  
-  &lt;tr&gt;
-    &lt;td&gt;'A'   &lt;/td&gt;
-    &lt;td&gt;string&lt;/td&gt;
-  &lt;/tr&gt;  
-  &lt;tr&gt;
-    &lt;td&gt;'f'   &lt;/td&gt;
-    &lt;td&gt;float&lt;/td&gt;
-  &lt;/tr&gt;  
-  &lt;tr&gt;
-    &lt;td&gt;'d'   &lt;/td&gt;
-    &lt;td&gt;double&lt;/td&gt;
-  &lt;/tr&gt;  
-  &lt;tr&gt;
-    &lt;td&gt;'n'   &lt;/td&gt;
-    &lt;td&gt;Lua number&lt;/td&gt;
-  &lt;/tr&gt;  
-  &lt;tr&gt;
-    &lt;td&gt;'c'   &lt;/td&gt;
-    &lt;td&gt;char&lt;/td&gt;
-  &lt;/tr&gt;  
-  &lt;tr&gt;
-    &lt;td&gt;'b'   &lt;/td&gt;
-    &lt;td&gt;byte = unsigned char&lt;/td&gt;
-  &lt;/tr&gt;  
-  &lt;tr&gt;
-    &lt;td&gt;'h'   &lt;/td&gt;
-    &lt;td&gt;short&lt;/td&gt;
-  &lt;/tr&gt;  
-  &lt;tr&gt;
-    &lt;td&gt;'H'   &lt;/td&gt;
-    &lt;td&gt;unsigned short&lt;/td&gt;
-  &lt;/tr&gt;  
-  &lt;tr&gt;
-    &lt;td&gt;'i'   &lt;/td&gt;
-    &lt;td&gt;int&lt;/td&gt;
-  &lt;/tr&gt;  
-  &lt;tr&gt;
-    &lt;td&gt;'I'   &lt;/td&gt;
-    &lt;td&gt;unsigned int&lt;/td&gt;
-  &lt;/tr&gt;  
-  &lt;tr&gt;
-    &lt;td&gt;'l'   &lt;/td&gt;
-    &lt;td&gt;long&lt;/td&gt;
-  &lt;/tr&gt;  
-  &lt;tr&gt;
-    &lt;td&gt;'L'   &lt;/td&gt;
-    &lt;td&gt;unsigned long&lt;/td&gt;
-  &lt;/tr&gt;  
-  &lt;/tbody&gt;
-  &lt;/table&gt;&lt;/li&gt;
-  &lt;li&gt;$count$ is an optional counter for the $format specifier$. For example, $i5$ instructs the code to pack/unpack 5 integer variables, as opposed to $i$ that specifies a
-  single integer variable.&lt;/li&gt;
-&lt;/ul&gt;&lt;p&gt;]],
-
-  -- Functions
-  funcs = 
-  {
-    { sig = &quot;packed = #pack.pack#( format, val1, val2, ..., valn )&quot;,
-      desc = &quot;Packs variables in a string.&quot;,
-      args = 
-      {
-        &quot;$format$ - format specifier (as described @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">overview at here</A>@).&quot;,
-        &quot;$val1$ - first variable to pack.&quot;,
-        &quot;$val2$ - second variable to pack.&quot;,
-        &quot;$valn$ - nth variable to pack.&quot;,
-      },
-      ret = &quot;$packed$ - a string containing the packed representation of all variables according to the format.&quot;
-    },
-
-    { sig = &quot;nextpos, val1, val2, ..., valn = #pack.unpack#( string, format, [ init ] )&quot;,
-      desc = &quot;Unpacks a string&quot;,
-      args = 
-      {
-        &quot;$string$ - the string to unpack.&quot;,
-        &quot;$format$ - format specifier (as described @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">overview at here</A>@).&quot;,
-        &quot;$init$ - $(optional)$ marks where in $string$ the unpacking should start (1 if not specified).&quot;
-      },
-      ret = 
-      {
-        &quot;$nextpos$ - the position in the string after unpacking.&quot;,
-        &quot;$val1$ - the first unpacked value.&quot;,
-        &quot;$val2$ - the second unpacked value.&quot;,
-        &quot;$valn$ - the nth unpacked value.&quot;
-      }
-    }
-  },
-}
-
+data_pt = data_en

Modified: branches/pre0.7/doc/eluadoc/refman_gen_pd.lua
===================================================================
--- branches/pre0.7/doc/eluadoc/refman_gen_pd.lua	2010-01-16 00:10:06 UTC (rev 664)
+++ branches/pre0.7/doc/eluadoc/refman_gen_pd.lua	2010-01-16 14:47:22 UTC (rev 665)
@@ -32,35 +32,4 @@
   },
 }
 
-data_pt = 
-{
-
-  -- Title
-  title = &quot;eLua reference manual - platform data&quot;,
-
-  -- Menu name
-  menu_name = &quot;Platform data (pd)&quot;,
-
-  -- Overview
-  overview = [[This module contains functions that access specific platform data. Useful if the code needs to know on which platform it runs.]],
-
-  -- Functions
-  funcs = 
-  {
-    { sig = &quot;platform = #pd.platform#()&quot;,
-      desc = &quot;Get platform name.&quot;,
-      ret = &quot;$platform$ - the name of the platform on which eLua is running.&quot;,
-    },
-
-    { sig = &quot;cpu = #pd.cpu#()&quot;,
-      desc = &quot;Get CPU name.&quot;,
-      ret = &quot;$cpu$ - the name of the CPU of the platform on which eLua is running.&quot;,
-    },
-
-    { sig = &quot;board = #pd.board#()&quot;,
-      desc = &quot;Get board name.&quot;,
-      ret = &quot;$board$ - the name of the board on which eLua is running.&quot;,
-    }
-  },
-}
-
+data_pt = data_en

Modified: branches/pre0.7/doc/eluadoc/refman_gen_pio.lua
===================================================================
--- branches/pre0.7/doc/eluadoc/refman_gen_pio.lua	2010-01-16 00:10:06 UTC (rev 664)
+++ branches/pre0.7/doc/eluadoc/refman_gen_pio.lua	2010-01-16 14:47:22 UTC (rev 665)
@@ -156,159 +156,4 @@
 
 }
 
-data_pt = 
-{
-
-  -- Title
-  title = &quot;eLua reference manual - pio module&quot;,
-
-  -- Menu name
-  menu_name = &quot;pio&quot;,
-
-  -- Overview
-  overview = [[This module contains functions for accessing the CPU's PIO (Programmable Input Output) pins. It contains two set of functions with identical
-  names and behaviour. One set groups the functions used to access individual pins from ports, the other groups the functions used to access full ports.&lt;/p&gt;
-  &lt;p&gt;With the $pio$ module, you specifiy names of $ports$ as they appear in your eLua's CPU datasheet. For example, if your CPU's ports are named $PA, PB$ 
-  and $PC$, you can reffer to them using $pio.PA$, $pio.PB$ and $pio.PC$, respectively. If your CPU uses $P0$, $P1$, $P2$ instead of $PA$, $PB$ and $PC$, 
-  you can simply use $pio.P0$, $pio.P1$ and $pio.P2$ instead.&lt;/p&gt;
-  &lt;p&gt;You can also reffer to individual $pins$ instead of ports. With the same notation as above, $pio.PA_0$ refers to the first pin of port $PA$, 
-  $P0_15$ refers to the 16th pin of port $P0$ and so on.
-  ]],
-
-  -- Functions
-  funcs = 
-  {
-    { sig = &quot;#pio.pin.setdir#( direction, pin1, pin2, ..., pinn )&quot;,
-      desc = &quot;Set pin(s) direction&quot;,
-      args =
-      {
-        &quot;$direction$ - the pin direction, can be either $pio.INPUT$ or $pio.OUTPUT$&quot;,
-        &quot;$pin1$ - the first pin&quot;,
-        &quot;$pin2 (optional)$ - the second pin&quot;,
-        &quot;$pinn (optional)$ - the %n%-th pin&quot;
-      }
-    },
-
-    { sig = &quot;#pio.pin.setpull#( type, pin1, pin2, ..., pinn )&quot;,
-      desc = &quot;Enable/disable pullups/pulldowns on the specified pin(s)&quot;,    
-      args = 
-      {
-        [[$type$ - 'pull' type, can be either $pio.PULLUP$ to enable pullups, $pio.PULLDOWN$ to enable pulldowns, or $pio.NOPULL$ to disable both pullups and
-        pulldowns]],
-        &quot;$pin1$ - the first pin&quot;,
-        &quot;$pin2 (optional)$ - the second pin&quot;,
-        &quot;$pinn (optional)$ - the %n%-th pin&quot;,
-      }
-    },
-
-    { sig = &quot;#pio.pin.setval#( value, pin1, pin2, ..., pinn )&quot;,
-      desc = &quot;Set pin(s) value&quot;,
-      args=
-      {
-        &quot;$value$ - pin value, can be either 0 or 1&quot;,
-        &quot;$pin1$ - the first pin&quot;,
-        &quot;$pin2 (optional)$ - the second pin&quot;,
-        &quot;$pinn (optional)$ - the %n%-th pin&quot;
-      }
-    },
-
-    { sig = &quot;val1, val2, ..., valn = #pio.pin.getval#( pin1, pin2, ..., pinn )&quot;,
-      desc = &quot;Get value of pin(s)&quot;,
-      args =
-      {
-        &quot;$pin1$ - the first pin&quot;,
-        &quot;$pin2 (optional)$ - the second pin&quot;,
-        &quot;$pinn (optional)$ - the %n%-th pin&quot;,
-      },
-      ret = &quot;The value(s) of the pin(s), either 0 or 1&quot;
-    },
-
-    { sig = &quot;#pio.pin.sethigh#( pin1, pin2, ..., pinn )&quot;,
-      desc = &quot;Set pin(s) to 1 (high)&quot;,
-      args = 
-      {
-        &quot;$pin1$ - the first pin&quot;,
-        &quot;$pin2 (optional)$ - the second pin&quot;,
-        &quot;$pinn (optinoal)$ - the %n%-th pin&quot;
-      }
-    },
-
-    { sig = &quot;#pio.pin.setlow#( pin1, pin2, ..., pinn )&quot;,
-      desc = &quot;Set pin(s) to 0 (low)&quot;,
-      args = 
-      {
-        &quot;$pin1$ - the first pin&quot;,
-        &quot;$pin2 (optional)$ - the second pin&quot;,
-        &quot;$pinn (optinoal)$ - the %n%-th pin&quot;
-      }
-    },
-
-    { sig = &quot;#pio.port.setdir#( direction, port1, port2, ..., portn )&quot;,
-      desc = &quot;Set port(s) direction&quot;,
-      args =
-      {
-        &quot;$direction$ - the port direction, can be either $pio.INPUT$ or $pio.OUTPUT$&quot;,
-        &quot;$port1$ - the first port&quot;,
-        &quot;$port2 (optional)$ - the second port&quot;,
-        &quot;$portn (optional)$ - the %n%-th port&quot;
-      }
-    },
-
-    { sig = &quot;#pio.port.setpull#( type, port1, port2, ..., portn )&quot;,
-      desc = &quot;Enable/disable pullups/pulldowns on the specified port(s)&quot;,    
-      args = 
-      {
-        [[$type$ - 'pull' type, can be either $pio.PULLUP$ to enable pullups, $pio.PULLDOWN$ to enable pulldowns, or $pio.NOPULL$ to disable both pullups and
-        pulldowns]],
-        &quot;$port1$ - the first port&quot;,
-        &quot;$port2 (optional)$ - the second port&quot;,
-        &quot;$portn (optional)$ - the %n%-th port&quot;,
-      }
-    },
-
-    { sig = &quot;#pio.port.setval#( value, port1, port2, ..., portn )&quot;,
-      desc = &quot;Set port(s) value&quot;,
-      args=
-      {
-        &quot;$value$ - port value&quot;,
-        &quot;$port1$ - the first port&quot;,
-        &quot;$port2 (optional)$ - the second port&quot;,
-        &quot;$portn (optional)$ - the %n%-th port&quot;
-      }
-    },
-
-    { sig = &quot;val1, val2, ..., valn = #pio.port.getval#( port1, port2, ..., portn )&quot;,
-      desc = &quot;Get value of port(s)&quot;,
-      args =
-      {
-        &quot;$port1$ - the first port&quot;,
-        &quot;$port2 (optional)$ - the second port&quot;,
-        &quot;$portn (optional)$ - the %n%-th port&quot;,
-      },
-      ret = &quot;The value(s) of the port(s)&quot;
-    },
-
-    { sig = &quot;#pio.port.sethigh#( port1, port2, ..., portn )&quot;,
-      desc = &quot;Set port(s) to all 1 (high)&quot;,
-      args = 
-      {
-        &quot;$port1$ - the first port&quot;,
-        &quot;$port2 (optional)$ - the second port&quot;,
-        &quot;$portn (optinoal)$ - the %n%-th port&quot;
-      }
-    },
-
-    { sig = &quot;#pio.port.setlow#( port1, port2, ..., portn )&quot;,
-      desc = &quot;Set port(s) to all 0 (low)&quot;,
-      args = 
-      {
-        &quot;$port1$ - the first port&quot;,
-        &quot;$port2 (optional)$ - the second port&quot;,
-        &quot;$portn (optinoal)$ - the %n%-th port&quot;
-      }
-    },
-   
-  }
-
-}
-
+data_pt = data_en

Modified: branches/pre0.7/doc/eluadoc/refman_gen_pwm.lua
===================================================================
--- branches/pre0.7/doc/eluadoc/refman_gen_pwm.lua	2010-01-16 00:10:06 UTC (rev 664)
+++ branches/pre0.7/doc/eluadoc/refman_gen_pwm.lua	2010-01-16 14:47:22 UTC (rev 665)
@@ -56,59 +56,4 @@
 
 }
 
-data_pt = 
-{
-
-  -- Title
-  title = &quot;eLua reference manual - pwm module&quot;,
-
-  -- Menu name
-  menu_name = &quot;pwm&quot;,
-
-  -- Overview
-  overview = [[This module contains functions for accessing the PWM (Pulse Width Modulation) modules of the eLua CPU.]],
-
-  -- Functions
-  funcs = 
-  {
-    { sig = &quot;frequency = #pwm.setup#( id, frequency, duty )&quot;,
-      desc = &quot;Setup the PWM modules.&quot;,
-      args = 
-      {
-        &quot;$id$ - the ID of the PWM module.&quot;,
-        &quot;$frequency$ - the frequency of the PWM module (in Hz).&quot;,
-        [[$duty$ - the duty cycle of the PWM module given in percents. This must be an integer between 0 and 100. $NOTE$: depending on the hardware, some
-duty cycles (particulary 0 and 100) might not be achievable.]]
-      },
-      ret = &quot;The actual frequenct set on the PWM module. Depending on the hardware, this might have a different value than the $frequency$ argument.&quot;
-    },
-
-    { sig = &quot;#pwm.start#( id )&quot;,
-      desc = &quot;Start the PWM signal on the given module.&quot;,
-      args = &quot;$id$ - the ID of the PWM module.&quot;
-    },
-
-    { sig = &quot;#pwm.stop#( id )&quot;,
-      desc = &quot;Stop the PWM signal on the given module.&quot;,
-      args = &quot;$id$ - the ID of the PWM module.&quot;
-    },
-
-    { sig = &quot;clock = #pwm.setclock#( id, clock )&quot;,
-      desc = &quot;Set the base clock of the given PWM module.&quot;,
-      args = 
-      {
-        &quot;$id$ - the ID of the PWM module.&quot;,
-        &quot;$clock$ - the desired base clock.&quot;
-      },
-      ret = &quot;The actual base clock set on the PWM module.  Depending on the hardware, this might have a different value than the $clock$ argument.&quot;
-    },
-
-    {  sig = &quot;clock = #pwm.getclock#( id )&quot;,
-       desc = &quot;Get the base clock of the given PWM module.&quot;,
-       args = &quot;$id$ - the ID of the PWM module.&quot;,
-       ret = &quot;The base clock of the PWM module.&quot;
-    }
-  },
-
-}
-
+data_pt = data_en

Modified: branches/pre0.7/doc/eluadoc/refman_gen_spi.lua
===================================================================
--- branches/pre0.7/doc/eluadoc/refman_gen_spi.lua	2010-01-16 00:10:06 UTC (rev 664)
+++ branches/pre0.7/doc/eluadoc/refman_gen_spi.lua	2010-01-16 14:47:22 UTC (rev 665)
@@ -67,70 +67,4 @@
 
 }
 
-data_pt = 
-{
-
-  -- Title
-  title = &quot;eLua reference manual - SPI module&quot;,
-
-  -- Menu name
-  menu_name = &quot;spi&quot;,
-
-  -- Overview
-  overview = [[This module contains functions for accessing the SPI interfaces of the eLua CPU.&lt;/p&gt;
-  &lt;p&gt;&lt;span class=&quot;warning&quot;&gt;IMPORTANT&lt;/span&gt;: right now, only master SPI mode is implemented in eLua.]],
-
-  -- Functions
-  funcs = 
-  {
-    { sig = &quot;clock = #spi.setup#( id, type, clock, cpol, cpha, databits )&quot;,
-      desc = &quot;Setup the SPI interface&quot;,
-      args = 
-      {
-        &quot;$id$ - the ID of the SPI interface.&quot;,
-        &quot;$type$ - SPI interface type, can be either $spi.MASTER$ or $spi.SLAVE$. $NOTE: currently, only master SPI mode is supported$.&quot;,
-        &quot;$clock$ - the clock of the SPI interface.&quot;,
-        &quot;$cpol$ - the clock polarity (0 or 1).&quot;,
-        &quot;$cpha$ - the clock phase (0 or 1).&quot;,
-        &quot;$databits$ - the length of the SPI data word.&quot;,
-      },
-      ret = &quot;The actual clock set on the SPI interface. Depending on the hardware, this might have a different value than the $clock$ parameter.&quot;
-    },
-
-    { sig = &quot;#spi.sson#( id )&quot;,
-      desc = &quot;Select the SS line (Slave Select) of the SPI interface. This is only applicable for SPI interfaces with a dedicated SS pin.&quot;,
-      args = &quot;$id$ - the ID of the SPI interface.&quot;,
-    },
-
-    { sig = &quot;#spi.ssoff#( id )&quot;,
-      desc = &quot;Deselect the SS line (Slave Select) of the SPI interface. This is only applicable for SPI interfaces with a dedicated SS pin.&quot;,
-      args = &quot;$id$ - the ID of the SPI interface.&quot;,
-    },
-
-    { sig = &quot;#spi.write#( id, data1, [data2], ..., [datan] )&quot;,
-      desc = &quot;Write one or more strings/numbers to the SPI interface.&quot;,
-      args = 
-      {
-        &quot;$id$ - the ID os the SPI interface.&quot;,
-        &quot;$data1$ - the first string/number to send.&quot;,
-        &quot;$data2 (optional)$ - the second string/number to send.&quot;,
-        &quot;$datan (optional)$ - the %n%-th string/number to send.&quot;
-      },
-    },
-
-    { sig = &quot;#spi.readwrite#( id, data1, [data2], ..., [datan] )&quot;,
-      desc = &quot;Write one or more strings/numbers to the SPI interface and return the data read from the same interface.&quot;,
-      args =
-      {
-        &quot;$id$ - the ID os the SPI interface.&quot;,
-        &quot;$data1$ - the first string/number to send.&quot;,
-        &quot;$data2 (optional)$ - the second string/number to send.&quot;,
-        &quot;$datan (optional)$ - the %n%-th string/number to send.&quot;
-      },
-      ret = &quot;An array with all the data read from the SPI interface.&quot;
-    }
-   
-  },
-
-}
-
+data_pt = data_en

Modified: branches/pre0.7/doc/eluadoc/refman_gen_term.lua
===================================================================
--- branches/pre0.7/doc/eluadoc/refman_gen_term.lua	2010-01-16 00:10:06 UTC (rev 664)
+++ branches/pre0.7/doc/eluadoc/refman_gen_term.lua	2010-01-16 14:47:22 UTC (rev 665)
@@ -156,159 +156,4 @@
 
 }
 
-data_pt = 
-{
-
-  -- Title
-  title = &quot;eLua reference manual - term module&quot;,
-
-  -- Menu name
-  menu_name = &quot;term&quot;,
-
-  -- Overview
-  overview = [[This module contains functions for accessing ANSI-compatible terminals (and terminal emulators) from Lua.]],
-
-  -- Functions
-  funcs = 
-  {
-    { sig = &quot;#term.clrscr#()&quot;,
-      desc = &quot;Clear the screen&quot;,
-    },
-
-    { sig = &quot;#term.clreol#()&quot;,
-      desc = &quot;Clear from the current cursor position to the end of the line&quot;,
-    },
-
-    { sig = &quot;#term.moveto#( x, y )&quot;,
-      desc = &quot;Move the cursor to the specified coordinates&quot;,
-      args=
-      {
-        &quot;$x$ - the column (starting with 1)&quot;,
-        &quot;$y$ - the line (starting with 1)&quot;
-      }
-    },
-
-    { sig = &quot;#term.moveup#( delta )&quot;,
-      desc = &quot;Move the cursor up&quot;,
-      args = &quot;$delta$ - number of lines to move the cursor up&quot;
-    },
-
-    { sig = &quot;#term.movedown#( delta )&quot;,
-      desc = &quot;Move the cursor down&quot;,
-      args = &quot;$delta$ - number of lines to move the cursor down&quot;,
-    },
-
-    { sig = &quot;#term.moveleft#( delta )&quot;,
-      desc = &quot;Move the cursor left&quot;,
-      args = &quot;$delta$ - number of columns to move the cursor left&quot;,
-    },
- 
-    { sig = &quot;#term.moveright#( delta )&quot;,
-      desc = &quot;Move the cursor right&quot;,
-      args = &quot;$delta$ - number of columns to move the cursor right&quot;,
-    },
-
-    { sig = &quot;numlines = #term.getlines#()&quot;,
-      desc = &quot;Get the number of lines in the terminal&quot;,
-      ret = &quot;The number of lines in the terminal&quot;,
-    },
-
-    { sig = &quot;numcols = #term.getcols#()&quot;,
-      desc = &quot;Get the number of columns in the terminal&quot;,
-      ret = &quot;The number of columns in the terminal&quot;,
-    },
-
-    { sig = &quot;#term.print#( [ x, y ], str1, [ str2, ..., strn ] )&quot;,
-      desc = &quot;Write one or more strings in the terminal&quot;,
-      args = 
-      {
-        &quot;$x (optional)$ - write the string at this column. If $x$ is specified, $y$ must also be specified&quot;,
-        &quot;$y (optional)$ - write the string at this line. If $y$ is specified, $x$ must also be specified&quot;,
-        &quot;$str1$ - the first string to write&quot;,
-        &quot;$str2 (optional)$ - the second string to write&quot;,
-        &quot;$strn (optional)$ - the nth string to write&quot;
-      }
-    },
-
-    { sig = &quot;cx = #term.getcx#()&quot;,
-      desc = &quot;Get the current column of the cursor&quot;,
-      ret = &quot;The column of the cursor&quot;
-    },
-
-    { sig = &quot;cy = #term.getcy#()&quot;,
-      desc = &quot;Get the current line of the cursor&quot;,
-      ret = &quot;The line of the cursor&quot; 
-    },
-
-    { sig = &quot;ch = #term.getchar#( [ mode ] )&quot;,
-      desc = &quot;Read a char (a key press) from the terminal&quot;,
-      args = [[$mode (optional)$ - terminal input mode. It can be either:&lt;/p&gt;
-  &lt;ul&gt;
-    &lt;li&gt;$term.WAIT$ - wait for a key to be pressed, then return it. This is the default behaviour if $mode$ is not specified. &lt;/li&gt;
-    &lt;li&gt;$term.NOWAIT$ - if a key was pressed on the terminal return it, otherwise return -1.&lt;/li&gt;
-  &lt;/ul&gt;&lt;p&gt;]],
-      ret = [[The char read from a terminal or -1 if no char is available. The 'char' can be an actual ASCII char, or a 'pseudo-char' which encodes special keys on
-  the keyboard. The list of the special chars and their meaning is given in the table below:&lt;/p&gt;
-&lt;table style=&quot;text-align: left; margin-left: 2em;&quot;&gt;
-&lt;tbody&gt;
-&lt;tr&gt;
-  &lt;th style=&quot;text-align: left;&quot;&gt;Key code&lt;/th&gt;
-  &lt;th style=&quot;text-align: left;&quot;&gt;Meaning&lt;/th&gt;
-&lt;/tr&gt;
-&lt;tr&gt;
-  &lt;td&gt;$KC_UP$&lt;/td&gt;
-  &lt;td&gt;the UP key on the terminal&lt;/td&gt;
-&lt;/tr&gt;
-&lt;tr&gt;
-  &lt;td&gt;$KC_DOWN$&lt;/td&gt;
-  &lt;td&gt;the DOWN key on the terminal&lt;/td&gt;
-&lt;/tr&gt;
-&lt;tr&gt;
-  &lt;td&gt;$KC_LEFT$&lt;/td&gt;
-  &lt;td&gt;the LEFT key on the terminal&lt;/td&gt;
-&lt;/tr&gt;
-&lt;tr&gt;
-  &lt;td&gt;$KC_RIGHT$&lt;/td&gt;
-  &lt;td&gt;the RIGHT key on the terminal&lt;/td&gt;
-&lt;/tr&gt;
-&lt;tr&gt;
-  &lt;td&gt;$KC_HOME$&lt;/td&gt;
-  &lt;td&gt;the HOME key on the terminal&lt;/td&gt;
-&lt;/tr&gt;
-&lt;tr&gt;
-  &lt;td&gt;$KC_END$&lt;/td&gt;
-  &lt;td&gt;the END key on the terminal&lt;/td&gt;
-&lt;/tr&gt;
-&lt;tr&gt;
-  &lt;td&gt;$KC_PAGEUP$&lt;/td&gt;
-  &lt;td&gt;the PAGE UP key on the terminal&lt;/td&gt;
-&lt;/tr&gt;
-&lt;tr&gt;
-  &lt;td&gt;$KC_PAGEDOWN$&lt;/td&gt;
-  &lt;td&gt;the PAGE DOWN key on the terminal&lt;/td&gt;
-&lt;/tr&gt;
-&lt;tr&gt;
-  &lt;td&gt;$KC_ENTER$&lt;/td&gt;
-  &lt;td&gt;the ENTER (CR) key on the terminal&lt;/td&gt;
-&lt;/tr&gt;
-&lt;tr&gt;
-  &lt;td&gt;$KC_TAB$&lt;/td&gt;
-  &lt;td&gt;the TAB key on the terminal&lt;/td&gt;
-&lt;/tr&gt;
-&lt;tr&gt;
-  &lt;td&gt;$KC_BACKSPACE$&lt;/td&gt;
-  &lt;td&gt;the BACKSPACE key on the terminal&lt;/td&gt;
-&lt;/tr&gt;
-&lt;tr&gt;
-  &lt;td&gt;$KC_ESC$&lt;/td&gt;
-  &lt;td&gt;the ESC (escape) key on the terminal&lt;/td&gt;
-&lt;/tr&gt;
-&lt;/tbody&gt;
-&lt;/table&gt;
-&lt;p&gt;]]
-    },
-
-  },
-
-}
-
+data_pt = data_en

Modified: branches/pre0.7/doc/eluadoc/refman_gen_tmr.lua
===================================================================
--- branches/pre0.7/doc/eluadoc/refman_gen_tmr.lua	2010-01-16 00:10:06 UTC (rev 664)
+++ branches/pre0.7/doc/eluadoc/refman_gen_tmr.lua	2010-01-16 14:47:22 UTC (rev 665)
@@ -91,94 +91,4 @@
 
 }
 
-data_pt = 
-{
-
-  -- Title
-  title = &quot;eLua reference manual - tmr module&quot;,
-
-  -- Menu name
-  menu_name = &quot;tmr&quot;,
-
-  -- Overview
-  overview = [[This module contains functions for accessing the hardware timers of the eLua CPU. In addition, if virtual timers are enabled 
-  (see @arch_platform_timers.html#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">virtual_timers at here</A>@ and @<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">building.html at here</A>@ for details), they can be used just like the &quot;regular&quot; (hardware)
-  timers with a single exception: you can't set the clock of a virtual timer (using @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">tmr.setclock at tmr.setclock</A>@). To use virtual timers with this
-  module, specify $tmr.VIRTx$ as the timer ID instead of a number. For example, if the eLua image was configured to support 4 virtual timers, they will
-  be available by using $tmr.VIRT0$ to $tmr.VIRT3$ as timer IDs.&lt;/p&gt;
-  &lt;p&gt;All &quot;time units&quot; (delays, differences in time) in this module, as well as in other parts of eLua (timeouts) are expressed in microseconds. However,
-  please keep in mind that the actual timer resolution depends on many factors. For example, it's very likely that the @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">tmr.delay at tmr.delay</A>@ function won't
-  be able to delay for the exact amount you specify (in us), as the real delay depends ona number of variables, most notably the base clock of the timer 
-  and the size of the timer counter register (32 bits on some platforms, 16 bits on most platforms, other values are less common). To ensure that the delay 
-  you're requesting is achievable, use @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">tmr.getmindelay at tmr.getmindelay</A>@ and @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">tmr.getmaxdelay at tmr.getmaxdelay</A>@ to obtain the maximum and the minimum 
-  achievable wait times on your timer, respectively. Even if your delay is within these limits, the $precision$ of this function still varies a lot, 
-  mainly as a function of the timer base clock.]],
-
-  -- Functions
-  funcs = 
-  {
-    { sig = &quot;#tmr.delay#( id, period )&quot;,
-      desc = &quot;Waits for the specified period, then returns.&quot;,
-      args = 
-      {
-        &quot;$period$ - the timer ID.&quot;,
-        &quot;$period$ - how long to wait (in us).&quot;
-      }
-    },
-
-    { sig = &quot;counter = #tmr.read#( id )&quot;,
-      desc= &quot;Reads the timer counter register.&quot;,
-      args = &quot;$id$ - the timer ID.&quot;,
-      ret = &quot;The value of the timer counter register.&quot;
-    },
-
-    { sig = &quot;counter = #tmr.start#( id )&quot;,
-      desc = &quot;Starts the specified timer.&quot;,
-      args = &quot;$id$ - the timer ID.&quot;,
-      ret = &quot;The value of the timer counter register when the timer started.&quot;,
-    },
-
-    { sig = &quot;delta = #tmr.gettimediff#( id, counter1, counter2 )&quot;,
-      desc = &quot;Computes the time difference between two timer counter values (you can get counter values by calling @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">tmr.read at tmr.read</A>@ or @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">tmr.start at tmr.start</A>@).&quot;,
-      args = 
-      {
-        &quot;$id$ - the timer ID.&quot;,
-        &quot;$counter1$ - the first counter value.&quot;,
-        &quot;$counter2$ - the second counter value.&quot;,
-      },
-      ret = &quot;The time difference (in us).&quot;
-    },
-
-    { sig = &quot;mindelay = #tmr.getmindelay#( id )&quot;,
-      desc = &quot;Get the minimum achieavable delay on the specified timer.&quot;,
-      args = &quot;$id$ - the timer ID.&quot;,
-      ret = &quot;The minimum achievable delay on the specified timer (in us).&quot;
-    },
-
-    { sig = &quot;maxdelay = #tmr.getmaxdelay#( id )&quot;,
-      desc = &quot;Get the maximum achieavable delay on the specified timer.&quot;,
-      args = &quot;$id$ - the timer ID.&quot;,
-      ret = &quot;The maximum achievable delay on the specified timer (in us).&quot;
-    },
-
-    { sig = &quot;clock = #tmr.setclock#( id, clock )&quot;,
-      desc = &quot;Set the timer clock (the clock used to increment the timer counter register).&quot;,
-      args = 
-      {
-        &quot;$id$ - the timer ID.&quot;,
-        &quot;$clock$ - the timer clock (in Hz).&quot;
-      },
-       ret = [[The actual clock set on the timer (in Hz). Depending on the hardware, this might have a different value than the $clock$ argument. 
-$NOTE:$ this function does not work with virtual timers.]]       
-    },
-
-    { sig = &quot;clock = #tmr.getclock#( id )&quot;,
-      desc = &quot;Get the timer clock (the clock used to increment the timer counter register).&quot;,
-      args = &quot;$id$ - the timer ID.&quot;,
-      ret = &quot;The timer clock (in Hz).&quot;
-    }
-   
-  }
-
-}
-
+data_pt = data_en

Modified: branches/pre0.7/doc/eluadoc/refman_gen_uart.lua
===================================================================
--- branches/pre0.7/doc/eluadoc/refman_gen_uart.lua	2010-01-16 00:10:06 UTC (rev 664)
+++ branches/pre0.7/doc/eluadoc/refman_gen_uart.lua	2010-01-16 14:47:22 UTC (rev 665)
@@ -78,81 +78,4 @@
 
 }
 
-data_pt = 
-{
-
-  -- Title
-  title = &quot;eLua reference manual - UART module&quot;,
-
-  -- Menu name
-  menu_name = &quot;uart&quot;,
-
-  -- Overview
-  overview = [[This module contains functions for accessing the serial ports (UARTs) of the eLua CPU.]],
-
-  -- Functions
-  funcs = 
-  {
-    { sig = &quot;baud = #uart.setup#( id, baud, databits, parity, stopbits )&quot;,
-      desc = &quot;Setup the serial port&quot;,
-      args = 
-      {
-        &quot;$id$ - the ID of the serial port&quot;,
-        &quot;$baud$ - serial baud rate&quot;,
-        &quot;$databits$ - number of data bits&quot;,
-        &quot;$parity$ - parity type, can be either $uart.PAR_EVEN$, $uart.PAR_ODD$ or $uart.PAR_NONE$&quot;,
-        [[$stopbits$ - the number of stop bits, can be either $uart.STOP_1$ (for 1 stop bit), $uart.STOP_1_5$ (for 1.5 stop bits) or $uart.STOP_2$ 
-(for 2 stop bits)]]
-      },
-      ret = &quot;The actual baud rate set on the serial port. Depending on the hardware, this might have a different value than the $baud$ parameter&quot;
-    },
-
-    { sig = &quot;#uart.write#( id, data1, [data2], ..., [datan] )&quot;,
-      desc = [[Write one or more strings or numbers to the serial port. If writing a number, its value must be between 0 and 255.]],
-      args = 
-      {
-        &quot;$id$ - the ID of the serial port.&quot;,
-        &quot;$data1$ - the first string/number to write.&quot;,
-        &quot;$data2 (optional)$ - the second string/number to write.&quot;,
-        &quot;$datan (optional)$ - the %n%-th string/number to write.&quot;
-      }
-    },
-
-    { sig = &quot;str = #uart.getchar#( id, [timeout], [timer_id] )&quot;,
-      desc = &quot;Read a single character from the serial port&quot;,
-      args = 
-      {
-        &quot;$id$ - the ID of the serial port&quot;,
-        [[$timeout (optional)$ - timeout of the receive operation, can be either $uart.NO_TIMEOUT$ or 0 for non-blocking operation, $uart.INF_TIMEOUT$ for 
-blocking operation, or a positive number that specifies the timeout in microseconds (in this case, the $timer_id$ parameter is also required). The default
-value of this argument is $uart.INF_TIMEOUT$]],
-        [[$timer_id (optional)$ - the ID of the timer for the receive operation, needed if the $timeout$ parameter specifies an actual timeout (that is,
-$timeout$ is neither $uart.NO_TIMEOUT$, nor $uart.INF_TIMEOUT$).]]
-      },
-      ret = &quot;The character read from the serial port as a string, or the empty string it timeout occured while waiting for the character.&quot;
-    },
-
-    { sig = &quot;str = #uart.read#( id, format, [timeout], [timer_id] )&quot;,
-      desc = &quot;Reads one or more characters from the serial port according to a format specifier&quot;,
-      args = 
-      {
-        &quot;$id$ - the ID of the serial port&quot;,
-        [[$format$ - format of data to read. This can be either:
-&lt;ul&gt;
-  &lt;li&gt;$'*l'$ - read until an end of line character (a $\n$) is found (the $\n$ is not returned) or a timeout occurs.&lt;/li&gt;
-  &lt;li&gt;$'*n'$ - read an integer. The integer can optionally have a sign. Reading continues until the first non-digit character is detected or a timeout occurs. This is the only case in which $read$ returns a number instead of an integer.&lt;/li&gt;
-  &lt;li&gt;$'*s'$ - read until a spacing character (like a space or a TAB) is found (the spacing character is not returned) or a timeout occurs.&lt;/li&gt;
-  &lt;li&gt;$a positive number$ - read at most this many characters before returning (reading can stop earlier if a timeout occurs).&lt;/li&gt;
-&lt;/ul&gt;]],
-        [[$timeout (optional)$ - timeout of the receive operation, can be either $uart.NO_TIMEOUT$ or 0 for non-blocking operation, $uart.INF_TIMEOUT$ for 
-blocking operation, or a positive number that specifies the inter-char timeout in microseconds (in this case, the $timer_id$ parameter is also required). The default value of this argument is $uart.INF_TIMEOUT$]],
-        [[$timer_id (optional)$ - the ID of the timer for the receive operation, needed if the $timeout$ parameter specifies an actual timeout (that is,
-$timeout$ is neither $uart.NO_TIMEOUT$, nor $uart.INF_TIMEOUT$).]]
-      },
-      ret = [[The data read from the serial port as a string (or as a number if $format$ is $'*n'$). If a timeout occures, only the data read before the timeout is returned. If the function times out while trying to read the first character, the empty string is returned]]
-    }
-   
-  },
-
-}
-
+data_pt = data_en

Modified: branches/pre0.7/doc/eluadoc/refman_ps_lm3s_disp.lua
===================================================================
--- branches/pre0.7/doc/eluadoc/refman_ps_lm3s_disp.lua	2010-01-16 00:10:06 UTC (rev 664)
+++ branches/pre0.7/doc/eluadoc/refman_ps_lm3s_disp.lua	2010-01-16 14:47:22 UTC (rev 665)
@@ -67,70 +67,4 @@
   },
 }
 
-data_pt = 
-{
-
-  -- Title
-  title = &quot;eLua reference manual - LM3S disp module&quot;,
-
-  -- Menu name
-  menu_name = &quot;disp&quot;,
-
-  -- Overview
-  overview = [[This module contains functions for working with the RIT OLED display on the Luminary Micro EKx-LM3S8962 boards and others.]],
-
-  -- Functions
-  funcs = 
-  {
-    { sig = &quot;#lm3s.disp.init#( frequency )&quot;,
-      desc = &quot;Initialize the display.&quot;,
-      args = &quot;$frequency$ - Number, the clock frequency (in Hertz) of the SSI interface used to control the display.&quot;
-    },
-
-    { sig = &quot;#lm3s.disp.enable#( frequency )&quot;,
-      desc = &quot;Enable the display.&quot;,
-      args = &quot;$frequency$ - Number, the clock frequency (in Hertz) of the SSI interface used to control the display.&quot;     
-    },
-
-    { sig = &quot;#lm3s.disp.disable#()&quot;,
-      desc = &quot;Disable the display.&quot;,
-    },
-
-    { sig = &quot;#lm3s.disp.on#()&quot;,
-      desc = &quot;Turn the display on.&quot;
-    },
-
-    { sig = &quot;#lm3s.disp.off#()&quot;,
-      desc = &quot;Turn the display off.&quot;
-    },
-
-    { sig = &quot;#lm3s.disp.clear#()&quot;,
-      desc = &quot;Clear the display.&quot;
-    },
-
-    { sig = &quot;#lm3s.disp.print#( str, x, y, col )&quot;,
-      desc = &quot;Write a string on the display. A 5x7 font (in a 6x8 cell) is used for drawing the text.&quot;,
-      args = 
-      {
-        &quot;$str$ - String, the text to be written on the display.&quot;,
-        &quot;$x$ - Number [0-127], the horizonal position of the text (specified in columns).&quot;,
-        &quot;$y$ - Number [0-95], the vertical position of the text (specified in lines).&quot;,
-        &quot;$col$ - Number [0-15], the 4-bit gray scale value to be used for the text.&quot;
-      }
-    },
-
-    { sig = &quot;#lm3s.disp.draw#( img, x, y, width, height )&quot;,
-      desc = &quot;Draw an image on the display.&quot;,
-      args = 
-      {
-        &quot;$img$ - String, the image to draw in string format.&quot;,
-        &quot;$x$ - Number [0-127], the horizontal position of the image (specified in pixels).&quot;,
-        &quot;$y$ - Number [0-95], the vertical position of the image (specified in pixels).&quot;,
-        &quot;$width$ - Number [1-127], the width of the image.&quot;,
-        &quot;$height$ - Number [1-95], the height of the image.&quot;
-      }
-    },
-    
-  },
-}
-
+data_pt = data_en

Modified: branches/pre0.7/doc/eluadoc/refman_ps_str9_pio.lua
===================================================================
--- branches/pre0.7/doc/eluadoc/refman_ps_str9_pio.lua	2010-01-16 00:10:06 UTC (rev 664)
+++ branches/pre0.7/doc/eluadoc/refman_ps_str9_pio.lua	2010-01-16 14:47:22 UTC (rev 665)
@@ -33,3 +33,4 @@
   },
 }
 
+data_pt = data_en

Modified: branches/pre0.7/doc/en/news.html
===================================================================
--- branches/pre0.7/doc/en/news.html	2010-01-16 00:10:06 UTC (rev 664)
+++ branches/pre0.7/doc/en/news.html	2010-01-16 14:47:22 UTC (rev 665)
@@ -2,12 +2,12 @@
 
 &lt;h3&gt;eLua Project News&lt;/h3&gt;
 
-&lt;h2&gt;?? January 2010&lt;/h2&gt;
+&lt;h2&gt;18 January 2010&lt;/h2&gt;
 &lt;p&gt;Version 0.7 is released. Here's the changelog:&lt;/p&gt;
 &lt;ul&gt;
   &lt;li&gt;Added Robert Jakabosky's EGC (Emergency Garbage Collector) patch to &lt;b&gt;eLua&lt;/b&gt; (see &lt;a href=&quot;elua_egc.html&quot;&gt;here&lt;/a&gt; for details)&lt;/li&gt;
-  &lt;li&gt;Added generic and portable SD/MMC Card FAT File System support, check &lt;a href=&quot;fatfs.html&quot;&gt;here&lt;/a&gt; for details.&lt;/li&gt;
-  &lt;li&gt;Added &lt;a href=&quot;<A HREF="http://fanplastic.org/2009/05/11/lua-rpc/">http://fanplastic.org/2009/05/11/lua-rpc/</A>&quot;&gt;LuaRPC&lt;/a&gt; support (remote procedure calls in the embedded world)&lt;/li&gt;
+  &lt;li&gt;Added generic and portable SD/MMC Card FAT File System support, (see &lt;a href=&quot;fatfs.html&quot;&gt;here&lt;/a&gt; for details)&lt;/li&gt;
+  &lt;li&gt;Added &lt;a href=&quot;<A HREF="http://fanplastic.org/2009/05/11/lua-rpc/">http://fanplastic.org/2009/05/11/lua-rpc/</A>&quot;&gt;LuaRPC&lt;/a&gt; support. Remote procedure calls in the embedded world (!!!). (see &lt;a href=&quot;using.html#rpc&quot;&gt;here&lt;/a&gt; for details)&lt;/li&gt;
   &lt;li&gt;New shell cat/type command, lists text file contents&lt;/li&gt;
   &lt;li&gt;Added support for &lt;a href=&quot;<A HREF="http://www.olimex.com/dev/str-e912.html">http://www.olimex.com/dev/str-e912.html</A>&quot;&gt;Olimex STR-E912&lt;/a&gt; board&lt;/li&gt;
   &lt;li&gt;Added the STR9 platform specific &lt;a href=&quot;refman_ps_str9_pio.html&quot;&gt;pio module&lt;/a&gt;.&lt;/li&gt;

Modified: branches/pre0.7/doc/en/overview.html
===================================================================
--- branches/pre0.7/doc/en/overview.html	2010-01-16 00:10:06 UTC (rev 664)
+++ branches/pre0.7/doc/en/overview.html	2010-01-16 14:47:22 UTC (rev 665)
@@ -1,5 +1,5 @@
 $$HEADER$$
-&lt;a name=&quot;whatis&quot; /&gt;&lt;h3&gt;What is eLua ?&lt;/h3&gt;
+&lt;a name=&quot;whatis&quot; /&gt;&lt;h3&gt;What is eLua?&lt;/h3&gt;
 &lt;p&gt;&lt;strong&gt;eLua&lt;/strong&gt;
 stands for &lt;strong&gt;Embedded Lua&lt;/strong&gt; and the project
 aims to offer the full set of features of the &lt;a href=&quot;<A HREF="http://www.lua.org">http://www.lua.org</A>&quot;&gt;Lua Programming Language&lt;/a&gt; to the embedded world. &lt;/p&gt;
@@ -137,9 +137,56 @@
 &lt;br /&gt;
 &lt;br /&gt;
 &lt;a name=&quot;license&quot; /&gt;&lt;h3&gt;License&lt;/h3&gt;
-&lt;p&gt;&lt;strong&gt;eLua&lt;/strong&gt; is Open Source and is freely
-distributed under the MIT licence.&lt;/p&gt;
+&lt;p&gt;&lt;strong&gt;eLua&lt;/strong&gt; is Open Source and is freely distributed under the MIT licence.&lt;/p&gt;
 &lt;p&gt;The Lua code (with all the &lt;strong&gt;eLua&lt;/strong&gt; specific changes) is included in the source tree and is, of course, licensed under the same &lt;a href=&quot;<A HREF="http://en.wikipedia.org/wiki/MIT_License">http://en.wikipedia.org/wiki/MIT_License</A>&quot;&gt;MIT license that Lua uses.&lt;/a&gt;&lt;/p&gt;
-&lt;p&gt;There may be other components with different licenses in &lt;strong&gt;eLua&lt;/strong&gt;, see &lt;strong&gt;COPYING&lt;/strong&gt; in the source distribution for details.&lt;/p&gt;
+&lt;p&gt;Other (few) components have different licenses. Please see the file LICENCE in the source distribution for details.&lt;/p&gt;
+&lt;p&gt;
+The Lua part of eLua is licensed under the Lua licensing terms, which you can
+find at <A HREF="http://www.lua.org/license.html.">http://www.lua.org/license.html.</A>
+&lt;/p&gt;
+&lt;p&gt;
+The XMODEM code is adapted from the FreeBSD at91 library, which was written by
+M. Warner Losh, and is released under the BSD license.
+&lt;/p&gt;
+&lt;p&gt;
+The &quot;pack&quot; module is adapted from the &quot;lpack&quot; module by Luiz Henrique de 
+Figueiredo and it's placed in the public domain.
+&lt;/p&gt;
+&lt;p&gt;
+The &quot;bit&quot; module is adapted from the &quot;bitlib&quot; library by Reuben Thomas which
+is distributed under a MIT license.
+&lt;/p&gt;
+&lt;p&gt;
+The &quot;integer only lua&quot; is based on the &quot;Go Long Lua!&quot; patch by John D.
+Ramsdell (from the Lua Power Patches page) and is placed in the public
+domain.
+&lt;/p&gt;
+&lt;p&gt;
+The multiple memory allocator (dlmalloc) is written by Doug Lea and it's
+placed on the public domain.
+&lt;/p&gt;
+&lt;p&gt;
+uIP (the TCP/IP stack used by eLua) is written by Adam Dunkels and released 
+under a BSD license. The eLua version is slightly modified.
+&lt;/p&gt;
+&lt;p&gt;
+FatFs (the FAT file system implementation of eLua) is written by Elm Chan
+(<A HREF="http://elm-chan.org">http://elm-chan.org</A>), a copy of the FatFs license can be found in the
+LICENSE.fatfs file.
+&lt;/p&gt;
+&lt;p&gt;
+The RPC implementation of eLua is based on Russell Smith's Lua-RPC
+(<A HREF="http://q12.org/lua/index.html">http://q12.org/lua/index.html</A>), a copy of the Lua-RPC license can be found
+in the LICENSE.luarpc file.
+&lt;/p&gt;
+&lt;p&gt;
+Manufacturer provided CPU support libraries are licensed under their own
+terms, check src/platform/&lt;platform&gt; for details.
+&lt;/p&gt;
+&lt;p&gt;
+The rest of the eLua code is licensed under MIT, listed below.
+&lt;/p&gt;
+
+
 $$FOOTER$$
 

Added: branches/pre0.7/doc/pt/building_unix.html
===================================================================
--- branches/pre0.7/doc/pt/building_unix.html	2010-01-16 00:10:06 UTC (rev 664)
+++ branches/pre0.7/doc/pt/building_unix.html	2010-01-16 14:47:22 UTC (rev 665)
@@ -0,0 +1,36 @@
+$$HEADER$$
+&lt;h3&gt;Building eLua in Linux&lt;/h3&gt;
+&lt;p&gt;Building &lt;b&gt;eLua&lt;/b&gt; in Linux is fairly easy. This tutorial assumes that Ubuntu is used for building, however any distro should be fine, you just need to 
+convert the &quot;apt-get&quot; calls to your distro's package manager equivalent. You need a few packages installed to build &lt;b&gt;eLua&lt;/b&gt;:&lt;/p&gt;
+&lt;ul&gt;
+&lt;li&gt;&lt;b&gt;a toolchain&lt;/b&gt;: check &lt;a href=&quot;toolchains.html&quot;&gt;the toolchains page&lt;/a&gt; for
+toolchain instructions. Please note that even if you already have a
+compiled toolchain, the differences in the Newlib configure flags
+(mainly the --disable-newlib-supplied-syscalls flags) might prevent &lt;b&gt;eLua&lt;/b&gt;
+for building properly on your machine.&lt;/li&gt;
+&lt;li&gt;&lt;b&gt;Python&lt;/b&gt; : it should be already installed. If it's not, use
+apt-get to install it:
+&lt;pre&gt;&lt;code&gt;$ sudo apt-get install python&lt;/code&gt;&lt;/pre&gt;
+&lt;/li&gt;
+&lt;li&gt;&lt;b&gt;scons&lt;/b&gt; - &lt;b&gt;eLua&lt;/b&gt; uses scons instead of make
+and makefiles, because we find scons much more &quot;natural&quot; and easier to
+use than make. To install it:
+&lt;pre&gt;&lt;code&gt;$ sudo apt-get install scons&lt;/code&gt;&lt;/pre&gt;
+&lt;/li&gt;
+&lt;li&gt;your toolchain's &quot;bin&quot; directory (this is generally
+something like /usr/local/cross-arm/bin, where /usr/local/cross-arm is
+the directory in which you installed your toolchain) must be in $PATH.
+&lt;/li&gt;
+&lt;li&gt;if you're building for the i386 platform, you'll also need
+&quot;nasm&quot;:
+&lt;pre&gt;&lt;code&gt;$ sudo apt-get install nasm&lt;/code&gt;&lt;/pre&gt;
+&lt;/li&gt;
+&lt;li&gt;&lt;b&gt;gcc&lt;/b&gt;: if you want to use the ROMFS precompile feature (see &lt;a href=&quot;arch_romfs.html#mode&quot;&gt;here&lt;/a&gt; for details) you need to build an image of the &lt;b&gt;eLua&lt;/b&gt; cross compiler, and you need an i386
+toolchain for this. It should be already installed, but if you want to be on the safe side do this:
+  &lt;pre&gt;&lt;code&gt;sudo apt-get install build-essential&lt;/code&gt;&lt;/pre&gt;
+  Then build the &lt;b&gt;eLua&lt;/b&gt; cross compiler by executing this command: 
+  &lt;pre&gt;&lt;code&gt;scons -f cross-lua.py&lt;/code&gt;&lt;/pre&gt;
+&lt;/li&gt;
+&lt;/ul&gt;
+&lt;p&gt;After you setup your build environment as described above, follow &lt;a href=&quot;building.html#configuring&quot;&gt;this tutorial&lt;/a&gt; to build your &lt;b&gt;eLua&lt;/b&gt; image.&lt;/p&gt;
+$$FOOTER$$

Added: branches/pre0.7/doc/pt/building_win.html
===================================================================
--- branches/pre0.7/doc/pt/building_win.html	2010-01-16 00:10:06 UTC (rev 664)
+++ branches/pre0.7/doc/pt/building_win.html	2010-01-16 14:47:22 UTC (rev 665)
@@ -0,0 +1,35 @@
+$$HEADER$$
+&lt;h3&gt;Building eLua in Windows&lt;/h3&gt;
+&lt;p&gt;Starting with version 0.7, building &lt;b&gt;eLua&lt;/b&gt; in Windows is officialy supported. The following instructions were tested in Windows 7 Professional, but they
+should work with little or no modification in any version of Windows 7, Vista or XP. You need to download and install a few things first:&lt;/p&gt; 
+&lt;ul&gt;
+&lt;li&gt;&lt;b&gt;a toolchain&lt;/b&gt;: building a GCC-based toolchain under Windows is possible, but not easy. We found that the easiest thing to do is to download a pre-built toolchain 
+and install it. Currently, all the targets supported by &lt;b&gt;eLua&lt;/b&gt; (except i386) have at least one toolchain that runs under Windows:
+&lt;ul&gt; 
+  &lt;li&gt;For ARM7, ARM9 and Cortex-M3 targets, you can download and install the CodeSourcery Lite Edition (supported by &lt;b&gt;eLua&lt;/b&gt; out of the box) from 
+  &lt;a href=&quot;<A HREF="http://www.codesourcery.com/sgpp/lite/arm/portal/subscription?@template=lite">http://www.codesourcery.com/sgpp/lite/arm/portal/subscription?@template=lite</A>&quot;&gt;here&lt;/a&gt;. For reference, the version used in this tutorial is 
+  &quot;Sourcery G++ Lite 2009q3-68 for ARM EABI&quot;. Future (and some previous) versions of this toolchain should also work. Remember to specify 
+  &lt;code&gt;toolchain=codesourcery&lt;/code&gt; when using this toolchain (see &lt;a href=&quot;building.html#buildoptions&quot;&gt;here&lt;/a&gt; for details).&lt;/li&gt;
+  &lt;li&gt;AVR32 has its own Windows based GNU toolchain that can be downloaded from Atmel &lt;a href=&quot;<A HREF="http://www.atmel.com/dyn/products/tools_card.asp?tool_id=4118">http://www.atmel.com/dyn/products/tools_card.asp?tool_id=4118</A>&quot;&gt;here&lt;/a&gt;.&lt;/li&gt;
+&lt;/ul&gt;&lt;/li&gt;   
+&lt;li&gt;&lt;b&gt;Python&lt;/b&gt;: my favourite Windows distribution of Python is &lt;a href=&quot;<A HREF="http://www.activestate.com/activepython/">http://www.activestate.com/activepython/</A>&quot;&gt;ActivePython&lt;/a&gt;. Simply download it and install it. ActivePython
+2.6.4.8 will be used in this tutorial. Other Python distribution might work equally well.&lt;/li&gt;
+&lt;li&gt;&lt;b&gt;scons&lt;/b&gt;: download the Windows installer package from &lt;a href=&quot;<A HREF="http://www.scons.org/download.php">http://www.scons.org/download.php</A>&quot;&gt;here&lt;/a&gt;. For this tutorial, scons 1.2.0 will be used. Remember to install
+scons &lt;b&gt;after&lt;/b&gt; you install Python. &lt;/li&gt;
+&lt;li&gt;&lt;b&gt;lua&lt;/b&gt;: a very good and versatile Lua distribution for Windows is &quot;Lua for Windows&quot;, it can be downloaded from &lt;a href=&quot;<A HREF="http://luaforwindows.luaforge.net/">http://luaforwindows.luaforge.net/</A>&quot;&gt;here&lt;/a&gt;. Besides
+Lua itself, it includes a lot of very useful Lua modules, so I highly recommend it. Version 5.1.4.30 of Lua for Windows will be used in this tutorial.&lt;/li&gt;
+&lt;li&gt;&lt;b&gt;svn&lt;/b&gt;: if you need to checkout the &lt;b&gt;eLua&lt;/b&gt; source code from the SVN repository, you need to install SVN for windows. There are a few precompiled SVN packages for
+Windows available, I'm using the Tigris binaries that can be downloaded from &lt;a href=&quot;<A HREF="http://subversion.tigris.org/servlets/ProjectDocumentList?folderID=8100">http://subversion.tigris.org/servlets/ProjectDocumentList?folderID=8100</A>&quot;&gt;here&lt;/a&gt;. In this
+tutorial I'll use version 1.6.6. If you require developer access (svn+ssh), additional steps are needed to make &quot;svn+ssh&quot; work in Windows. A lot of tutorials
+that cover this topic are available, check for example &lt;a href=&quot;<A HREF="http://agateau.wordpress.com/2007/07/03/windows-svnssh-and-the-subversion-command-line-client/">http://agateau.wordpress.com/2007/07/03/windows-svnssh-and-the-subversion-command-line-client/</A>&quot;&gt;this one&lt;/a&gt;.&lt;/li&gt;
+&lt;li&gt;&lt;b&gt;gcc&lt;/b&gt;: if you want to use the ROMFS precompile feature (see &lt;a href=&quot;arch_romfs.html#mode&quot;&gt;here&lt;/a&gt; for details) you need to build an image of the &lt;b&gt;eLua&lt;/b&gt; cross compiler, and you need an i386
+toolchain for this. I'm using MinGW for this task, it can be downloaded from &lt;a href=&quot;<A HREF="http://www.mingw.org/">http://www.mingw.org/</A>&quot;&gt;here&lt;/a&gt;. This tutorial uses MinGW version 5.1.6. Note that you
+don't need to install MSYS, MinGW should be enough. Cygwin should work equally well, or even Microsoft's Visual Studio (not tested). To build the cross compiler, run
+this command from the command line:
+  &lt;pre&gt;&lt;code&gt;scons -f cross-lua.py&lt;/code&gt;&lt;/pre&gt;
+&lt;/li&gt;
+&lt;/ul&gt;
+&lt;p&gt;Make sure that all the programs listed above are added to %PATH%. Most of them do this automatically, or have an option to do this automatically, but some
+(for example MinGW) do not and you need to add them to %PATH% manually.&lt;/p&gt; 
+&lt;p&gt;After you setup your build environment as described above, follow &lt;a href=&quot;building.html#configuring&quot;&gt;this tutorial&lt;/a&gt; to build your &lt;b&gt;eLua&lt;/b&gt; image.&lt;/p&gt;
+$$FOOTER$$

Added: branches/pre0.7/doc/pt/elua_egc.html
===================================================================
--- branches/pre0.7/doc/pt/elua_egc.html	2010-01-16 00:10:06 UTC (rev 664)
+++ branches/pre0.7/doc/pt/elua_egc.html	2010-01-16 14:47:22 UTC (rev 665)
@@ -0,0 +1,38 @@
+$$HEADER$$
+&lt;h3&gt;Using the EGC patch with eLua&lt;/h3&gt;
+&lt;p&gt;The EGC (Emergency Garbage Collector) patch is a patch written originally for Lua by Robert Jakabosky, who was kind enough to port it to &lt;b&gt;eLua&lt;/b&gt;. You can find the author's detailed
+description of the patch &lt;a href=&quot;<A HREF="http://lua-users.org/wiki/EmergencyGarbageCollector">http://lua-users.org/wiki/EmergencyGarbageCollector</A>&quot;&gt;here&lt;/a&gt;. In short, what it does is that it lets you run a garbage collection cycle in Lua in a low memory
+situation, from inside Lua's memory allocation function (something that the current version of Lua can't do out of the box). By forcing a garbage collection cycle, Lua can reclaim memory that's
+not in use anymore, thus making more memory available for your program. The downside is reduced execution speed, as a direct result of running the gargabe collector when needed. For some
+applications, reducing the execution speed to fit the application in memory might be acceptable, and for other applications it might not. As usual, it all depends on your application. As a generic
+guideline, if your application isn't concerned with realtime processing, you should be fine with sacrifing execution speed to get more memory in many real life scenarios.&lt;/p&gt;
+&lt;p&gt;In &lt;b&gt;eLua&lt;/b&gt;, the EGC patch can be configured to run in 4 different modes:&lt;/p&gt;
+&lt;ol&gt;
+&lt;li&gt;&lt;b&gt;disabled&lt;/b&gt;: EGC inactive, no collection cycle will be forced in low memory situations.&lt;/li&gt;
+&lt;li&gt;&lt;b&gt;run on allocation failure&lt;/b&gt;: try to allocate a new block of memory, and run the garbage collector if the allocation fails. If the allocation fails even after running the garbage
+collector, the allocator will return with error. &lt;/li&gt;
+&lt;li&gt;&lt;b&gt;run on memory limit&lt;/b&gt;: run the garbage collector when the memory used by the Lua script goes beyond an upper limit. If the upper limit can't be satisfied even after running
+the garbage collector, the allocator will return with error.&lt;/li&gt;
+&lt;li&gt;&lt;b&gt;run before each allocation&lt;/b&gt;: run the garbage collector before each memory allocation. If the allocation fails even after running the garbage collector, the allocator will
+return with error. This mode is very efficient with regards to memory savings, but it's also the slowest.&lt;/li&gt;
+&lt;/ol&gt;
+&lt;p&gt;&lt;b&gt;eLua&lt;/b&gt; lets you use any of the above modes, or combine modes 2-4 above as needed. The C code API for EGC interfacing is defined in &lt;i&gt;src/lua/legc.h&lt;/i&gt;, shown partially below:&lt;/p&gt;
+&lt;p&gt;&lt;pre&gt;&lt;code&gt;// EGC operations modes
+#define EGC_NOT_ACTIVE        0   // EGC disabled
+#define EGC_ON_ALLOC_FAILURE  1   // run EGC on allocation failure
+#define EGC_ON_MEM_LIMIT      2   // run EGC when an upper memory limit is hit
+#define EGC_ALWAYS            4   // always run EGC before an allocation
+
+void legc_set_mode(lua_State *L, int mode, unsigned limit);&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
+&lt;p&gt;To set the EGC operation mode, call &lt;i&gt;legc_set_mode&lt;/i&gt; above with 3 parameters:&lt;/p&gt;
+&lt;ul&gt;
+&lt;li&gt;&lt;b&gt;L&lt;/b&gt;: a pointer to a Lua state structure.&lt;/li&gt;
+&lt;li&gt;&lt;b&gt;mode&lt;/b&gt;: EGC operation mode, as described by the &lt;b&gt;#define&lt;/b&gt; section above. You can specifiy a single mode, or a bitwise OR combination between &lt;b&gt;EGC_ON_ALLOC_FAILURE&lt;/b&gt;,
+&lt;b&gt;EGC_ON_MEM_LIMIT&lt;/b&gt; and &lt;b&gt;EGC_ALWAYS&lt;/b&gt;.&lt;/li&gt;
+&lt;li&gt;&lt;b&gt;memlimit&lt;/b&gt;: the upper memory limit used by the &lt;b&gt;EGC_ON_MEM_LIMIT&lt;/b&gt; mode. Must be higher than 0 for this mode to run properly, can be 0 for any other mode.&lt;/li&gt;
+&lt;/ul&gt;
+
+&lt;p&gt;The functionality of this C function is mirrored by the &lt;b&gt;elua&lt;/b&gt; generic module &lt;b&gt;egc_setup&lt;/b&gt; function, see &lt;a href=&quot;refman_gen_elua.html#elua.egc_setup&quot;&gt;here&lt;/a&gt; for more details. 
+Also, see &lt;a href=&quot;building.html#static&quot;&gt;here&lt;/a&gt; for details on how to configure the default (compile time) EGC behaviour.&lt;/p&gt;
+$$FOOTER$$
+

Added: branches/pre0.7/doc/pt/fatfs.html
===================================================================
--- branches/pre0.7/doc/pt/fatfs.html	2010-01-16 00:10:06 UTC (rev 664)
+++ branches/pre0.7/doc/pt/fatfs.html	2010-01-16 14:47:22 UTC (rev 665)
@@ -0,0 +1,20 @@
+$$HEADER$$
+&lt;h3&gt;The FAT file system&lt;/h3&gt;
+&lt;p&gt;The FAT file system implementation in &lt;b&gt;eLua&lt;/b&gt; uses Elm Chan's excellent FatFS package, available &lt;a href=&quot;<A HREF="http://elm-chan.org/fsw/ff/00index_e.html">http://elm-chan.org/fsw/ff/00index_e.html</A>&quot;&gt;here&lt;/a&gt;. It can handle FAT12, FAT16
+and FAT32 file systems in read/write mode, and it packs a lot of functionality in a low footprint.  Like the ROM filesystem it is integrated with the C library, so similar POSIX file manipulation will work in addition to accessing the filesystem via the Lua &lt;b&gt;io&lt;/b&gt; module. &lt;b&gt;eLua&lt;/b&gt; adds a platform abstraction layer on top of FatFS which makes it very easy to
+port the FAT file system implementation between different &lt;b&gt;eLua&lt;/b&gt; targets.  Since most SD/MMC cards can be accessed using the very common SPI interface, and since &lt;b&gt;eLua&lt;/b&gt; already provides
+a &lt;a href=&quot;arch_platform_spi.html&quot;&gt;SPI platform interface&lt;/a&gt;, porting the FAT file system to an &lt;b&gt;eLua&lt;/b&gt; board is a fairly simple process.&lt;/p&gt;
+&lt;p&gt;To use the FAT file system on your &lt;b&gt;elua&lt;/b&gt; board (that has the proper hardware to access SD/MMC cards), first make sure that there is a working implementation of the 
+&lt;a href=&quot;arch_platform_spi.html&quot;&gt;eLua SPI platform interface&lt;/a&gt; on your platform (as currently &lt;b&gt;eLua&lt;/b&gt; can access SD/MMC cards only via SPI). Then you need to enable the FAT file system module (MMCFS)
+in your &lt;b&gt;eLua&lt;/b&gt; binary image, as described on the &lt;a href=&quot;building.html&quot;&gt;building page&lt;/a&gt;.&lt;/p&gt;
+&lt;h2&gt;Using the FAT file system&lt;/h2&gt;
+&lt;p&gt;To use the FAT filesystem with an SD or MMC card, first ensure that the card has been properly formatted as a FAT filesystem (many come preformatted with this file system).&lt;/p&gt;
+&lt;p&gt;Next, connect the card to your board such that the SD card's DAT3/CS PIN is connected to the CS pin you selected in the building section. In addition, for the selected SPI port, the controller's SPI DO pin should be connected the the card's CMD/DI pin, the SPI DI pin should be connected to the card's DAT0/DO pin, and the SPI SCLK should connect to the cards CLK pin.  For more more information, see Elm Chan's page on &lt;a href=&quot;<A HREF="http://elm-chan.org/docs/mmc/mmc_e.html">http://elm-chan.org/docs/mmc/mmc_e.html</A>&quot;&gt;SD/MMC with SPI&lt;/a&gt;.&lt;/p&gt;
+
+&lt;p&gt;Once configured, connected, and &lt;b&gt;eLua&lt;/b&gt; has started up, you are ready to work with the files on your card. To open a file on the SD/MMC card, all you need to do is to prefix its name with &lt;i&gt;/mmc/&lt;/i&gt;, like this:&lt;/p&gt; 
+&lt;p&gt;&lt;pre&gt;&lt;code&gt;# lua /mmc/info.lua &lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
+&lt;p&gt;Similarly, if you wanted to access a text file &lt;b&gt;a.txt&lt;/b&gt; from your card, you could use fopen like this:&lt;/p&gt;
+&lt;p&gt;&lt;pre&gt;&lt;code&gt;f = fopen( &quot;/mmc/a.txt&quot;, &quot;rb&quot; )&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
+$$FOOTER$$
+
+

Added: branches/pre0.7/doc/pt/filesystems.html
===================================================================
--- branches/pre0.7/doc/pt/filesystems.html	2010-01-16 00:10:06 UTC (rev 664)
+++ branches/pre0.7/doc/pt/filesystems.html	2010-01-16 14:47:22 UTC (rev 665)
@@ -0,0 +1,10 @@
+$$HEADER$$
+&lt;h3&gt;eLua file systems&lt;/h3&gt;
+&lt;p&gt;You can compile and use more than one file system in &lt;b&gt;eLua&lt;/b&gt;, as listed below:&lt;/p&gt;
+&lt;ul&gt;
+  &lt;li&gt;&lt;b&gt;the ROM file system&lt;/b&gt;: a very simple, very low footprint read-only file system that can be included in the &lt;b&gt;eLua&lt;/b&gt; binary image. Check &lt;a href=&quot;arch_romfs.html&quot;&gt;here&lt;/a&gt; for details.&lt;/li&gt;
+  &lt;li&gt;&lt;b&gt;the FAT file system&lt;/b&gt;: a read-write FAT filesystem implementation (platform independent) that can currently be used with SD/MMC memory cards. Check &lt;a href=&quot;fatfs.html&quot;&gt;here&lt;/a&gt; for 
+  details. &lt;b&gt;(new in 0.7)&lt;/b&gt;&lt;/li&gt;
+&lt;/ul&gt;
+$$FOOTER$$
+

Added: branches/pre0.7/doc/pt/installing_lpc2468.html
===================================================================
--- branches/pre0.7/doc/pt/installing_lpc2468.html	2010-01-16 00:10:06 UTC (rev 664)
+++ branches/pre0.7/doc/pt/installing_lpc2468.html	2010-01-16 14:47:22 UTC (rev 665)
@@ -0,0 +1,55 @@
+$$HEADER$$
+&lt;h3&gt;Installing &lt;b&gt;eLua&lt;/b&gt; on the LPC2468 CPU from NXP&lt;/h3&gt;
+&lt;p&gt;The &lt;a href=&quot;<A HREF="http://ics.nxp.com/products/lpc2000/lpc24xx/">http://ics.nxp.com/products/lpc2000/lpc24xx/</A>&quot;&gt;LPC2468 CPU&lt;/a&gt; from &lt;a href=&quot;<A HREF="http://www.nxp.com">http://www.nxp.com</A>&quot;&gt;NXP&lt;/a&gt; is one of the CPUs on which &lt;b&gt;eLua&lt;/b&gt; is very happy to run, because of its
+very generous resources: 512k of Flash and 96k of SRAM on-chip memory, loads of peripherals, up to 72MHz operating frequency, external memory bus and other goodies. &lt;b&gt;eLua&lt;/b&gt; is so happy with
+this chip, in fact, that a board designed specifically for &lt;b&gt;eLua&lt;/b&gt; was built around it. You can find the full specifications of the board 
+&lt;a href=&quot;<A HREF="http://www.giga.puc-rio.br/site/embedded/eluademoboard">http://www.giga.puc-rio.br/site/embedded/eluademoboard</A>&quot;&gt;here&lt;/a&gt;. This is the board that we're going to use in this tutorial.&lt;/p&gt;
+ &lt;h3&gt;Prerequisites&lt;/h3&gt; 
+ &lt;p&gt;Before you'll be able to use &lt;b&gt;eLua&lt;/b&gt; on the LPC2468 CPU, make sure that:&lt;/p&gt;
+ &lt;ul&gt;
+ &lt;li&gt;you're using Windows. Using this board under Linux or other operating systems should be possible, but we're going to cover only Windows here.&lt;/li&gt;
+ &lt;li&gt;you downloaded the latest FTDI VCP drivers from &lt;a href=&quot;<A HREF="http://www.ftdichip.com/Drivers/VCP.htm">http://www.ftdichip.com/Drivers/VCP.htm</A>&quot;&gt;here&lt;/a&gt;.&lt;/li&gt;
+ &lt;li&gt;you downloaded and installed the FTDI FT_PROG tool from &lt;a href=&quot;<A HREF="http://www.ftdichip.com/Resources/Utilities.htm">http://www.ftdichip.com/Resources/Utilities.htm</A>&quot;&gt;here&lt;/a&gt;.&lt;/li&gt;
+ &lt;li&gt;you downloaded and installed the Flash Magic programming software from &lt;a href=&quot;<A HREF="http://www.flashmagictool.com/">http://www.flashmagictool.com/</A>&quot;&gt;here&lt;/a&gt;.&lt;/li&gt;
+ &lt;li&gt;you already have your &lt;b&gt;eLua&lt;/b&gt; image for the LPC2468 CPU (&lt;a href=&quot;building.html&quot;&gt;built&lt;/a&gt; or &lt;a href=&quot;downloads.html&quot;&gt;downloaded&lt;/a&gt;).&lt;/li&gt;
+ &lt;/ul&gt;
+ &lt;h3&gt;Burning &lt;b&gt;eLua&lt;/b&gt; to the LPC2468 using the Flash Magic software&lt;/h3&gt;
+ &lt;p&gt;Before actually downloading the &lt;b&gt;eLua&lt;/b&gt; image to the CPU, the board must be configured for proper USB operation (note that this should be done only once, not everytime you need to program
+ a new &lt;b&gt;eLua&lt;/b&gt; image). The steps for this procedure are listed below:&lt;/p&gt;
+&lt;ol&gt;
+  &lt;li&gt;make sure that jumper JP1 on the board is set to position &quot;USB&quot; (2-3) if you want to power your board from the USB bus.&lt;/li&gt;
+  &lt;li&gt;connect your board to the PC using an USB cable.&lt;/li&gt;
+  &lt;li&gt;if needed, install the FTDI drivers you downloaded earlier.&lt;/li&gt;
+  &lt;li&gt;once the drivers are properly installed, start the FTDI FT_PROG software downloaded earlier and choose &quot;Devices&quot;, &quot;Scan and Parse&quot;. If everything is OK, your device should show up in the 
+  left part of the FT_PROG window, under &quot;Device Tree&quot;.&lt;/li&gt;
+  &lt;li&gt;in &quot;Device Tree&quot;, select &quot;USB_Config_Descriptor&quot;, then enter &quot;500&quot; in the &quot;Max Bus Power&quot; field in the upper right part of the FT_PROG window. It should look like below:
+  &lt;img src=&quot;images/ft_prog_power.png&quot; alt=&quot;FT_PROG power settings&quot; style=&quot;margin-top: 10px;&quot; /&gt;
+  &lt;/li&gt;
+  &lt;li&gt;&lt;b&gt;(optional)&lt;/b&gt; now it's a good time to give your &lt;b&gt;eLua&lt;/b&gt; board a good description :) In &quot;Device Tree&quot;, select &quot;USB_String_Descriptors&quot;, then enter &quot;eluaproject.net&quot; in the 
+  &quot;Manufacturer&quot; field in the upper right part of the FT_PROG window, and &quot;eLua demo board&quot; in the &quot;Product Description&quot; field. It should look like below:
+  &lt;img src=&quot;images/ft_prog_strings.png&quot; alt=&quot;FT_PROG strings&quot; style=&quot;margin-top: 10px;&quot; /&gt;
+  &lt;/li&gt;
+  &lt;li&gt;choose &quot;Devices&quot;, &quot;Program&quot;. The new settings will be written to the FTDI chip internal memory, and the board will automatically re-enumerate.&lt;/li&gt;
+&lt;/ol&gt;
+&lt;p&gt;Once your board is properly configured (remember, you only need to do this ONCE!), follow the next steps to program your &lt;b&gt;eLua&lt;/b&gt; image to the board as many times as you need to:&lt;/p&gt;
+&lt;ol&gt;
+  &lt;li&gt;make sure that jumper JP1 on the board is set to position &quot;USB&quot; (2-3) if you want to power your board from the USB bus.&lt;/li&gt;
+  &lt;li&gt;make sure that JP2 (ISP), JP3 (RST), JP6 (RDX0) and JP7 (TDX0) are connected on the board.&lt;/li&gt;
+  &lt;li&gt;connect the board to the PC using an USB cable.&lt;/li&gt;
+  &lt;li&gt;find the serial port used by the board. Open &quot;Device Manager&quot; in Windows, go to &quot;Ports (COM &amp; LPT)&quot; and look for a serial port named &quot;USB serial port&quot; or something similar. If unsure,
+      simply unplug the board. The serial port that disappears from the list after unplugging the board is your board's serial port.&lt;/li&gt;
+  &lt;li&gt;start Flash Magic and click on &quot;Select Device&quot; under &quot;Step 1 - Communications&quot;. In the &quot;Device Database&quot; window that appears, select &quot;ARM7&quot; and then double click on &quot;LPC2468&quot; 
+  (&lt;b&gt;NOT&lt;/b&gt; &quot;LPC2468 Ethernet&quot;).&lt;/li&gt;
+  &lt;li&gt;select the COM port from step 4 in &quot;COM Port&quot;, set the baud rate to 230400, &quot;Interface&quot; to &quot;None (ISP)&quot;, and &quot;Oscillator (MHZ)&quot; to 12.&lt;/li&gt;
+  &lt;li&gt;under &quot;Step 2 - Erase&quot;, select &quot;Erase blocks used by Hex File&quot;.&lt;/li&gt;
+  &lt;li&gt;under &quot;Step 3 - Hex File&quot;, select your LPC2468 &lt;/b&gt;eLua&lt;/b&gt; hex file.&lt;/li&gt;
+  &lt;li&gt;&lt;b&gt;(optional)&lt;/b&gt; under &quot;Step 4 - Options&quot;, select &quot;Verify after programming&quot; if you want to verify your downloaded image.&lt;/li&gt;
+&lt;/ol&gt;
+&lt;p&gt;After all the steps above, the Flash Magic windows should look similar to the image below (my LPC2468 serial port is COM14):&lt;/p&gt;
+&lt;img src=&quot;images/flashmagic.png&quot; alt=&quot;Flash Magic Settings&quot; style=&quot;margin-left: 10px;&quot; /&gt;
+&lt;p&gt;All that's left to do is hit the &quot;Start&quot; button, and wait (the whole process takes a while). When it's finished, close Flash Magic and remove the JP2 (ISP) and JP3 (RST) jumpers from the
+board, then reset it.&lt;/p&gt;
+&lt;p&gt;That's it! You now have &lt;b&gt;eLua&lt;/b&gt; programmed on your board, so you can start your terminal emulator and enjoy it, as described in &lt;a href=&quot;using.html&quot;&gt;using eLua&lt;/a&gt;.&lt;/p&gt;
+
+$$FOOTER$$
+

Added: branches/pre0.7/doc/pt/modules_str9.html
===================================================================
--- branches/pre0.7/doc/pt/modules_str9.html	2010-01-16 00:10:06 UTC (rev 664)
+++ branches/pre0.7/doc/pt/modules_str9.html	2010-01-16 14:47:22 UTC (rev 665)
@@ -0,0 +1,5 @@
+$$HEADER$$
+&lt;h3&gt;Reference manual - STR9 platform dependent modules&lt;/h3&gt;
+&lt;p&gt;This paragraph presents all the modules specific to the &lt;a href=&quot;status.html&quot;&gt;STR9&lt;/a&gt; platform.&lt;/p&gt;
+$$FOOTER$$
+

Modified: branches/pre0.7/doc/pt/news.html
===================================================================
--- branches/pre0.7/doc/pt/news.html	2010-01-16 00:10:06 UTC (rev 664)
+++ branches/pre0.7/doc/pt/news.html	2010-01-16 14:47:22 UTC (rev 665)
@@ -1,23 +1,24 @@
 $$HEADER$$
 &lt;h3&gt;eLua Project News&lt;/h3&gt;
 
-&lt;h2&gt;24 de Dezembro de 2009&lt;/h2&gt;
-&lt;p&gt;Lan&#231;ada a vers&#227;o 0.7 de &lt;strong&gt;eLua&lt;/strong&gt;. As principais caracter&#237;sticas 
-est&#227;o descritas a seguir. Para uma lista mais completa das
-novidades, por favor consulte nossa p&#225;gina de &lt;a href=&quot;versionhistory.html&quot;&gt;Hist&#243;rico das Vers&#245;es:&lt;/a&gt;
+&lt;h2&gt;18 de Janeiro de 2010&lt;/h2&gt;
+&lt;p&gt;Lan&#231;ada a vers&#227;o 0.7 de &lt;strong&gt;eLua&lt;/strong&gt;. As principais caracter&#237;sticas adicionadas est&#227;o descritas a seguir. 
+Para uma lista mais completa das novidades, por favor consulte nossa p&#225;gina de &lt;a href=&quot;versionhistory.html&quot;&gt;Hist&#243;rico das Vers&#245;es:&lt;/a&gt;
 &lt;/p&gt;
 &lt;ul&gt;
-  &lt;li&gt;Adicionado o patch Lua EGC (Emergency Garbage Collection)&lt;/li&gt;
-  &lt;li&gt;Novo FAT File System para SD/MMC Cards, gen&#233;rico e port&#225;til.&lt;/li&gt;
-  &lt;li&gt;Suporte &#224; LuaRPC. Remote Procedure Calls no mundo embedded.&lt;/li&gt;
-  &lt;li&gt;Novo comando para o shell de eLua, cat/type, lista o conte&#250;do de arquivos de texto&lt;/li&gt;
-  &lt;li&gt;Suporte ao kit Olimex STR-E912, com MCU ST Electronics STR912FW44X&lt;/li&gt;
-  &lt;li&gt;Suporte ao kit PUC-Rio eLua Demo Board, com MCU NXP LPC2468&lt;/li&gt;
-  &lt;li&gt;Mais conte&#250;do traduzido para Portugu&#234;s&lt;/li&gt;
-  &lt;li&gt;M&#243;dulo ADC e sua doc melhorados&lt;/li&gt;
+  &lt;li&gt;Suporte oficial &#224; &lt;b&gt;eLua&lt;/b&gt; em Windows, com novo tutorial (por enquanto apenas em ingl&#234;s) &lt;a href=&quot;building_win.html&quot;&gt;aqui&lt;/a&gt;.&lt;/li&gt;
+  &lt;li&gt;Suporte ao kit &lt;a href=&quot;<A HREF="http://www.giga.puc-rio.br/site/embedded/eluademoboard">http://www.giga.puc-rio.br/site/embedded/eluademoboard</A>&quot;&gt;PUC-Rio &lt;b&gt;eLua&lt;/b&gt; Demo Board&lt;/a&gt;, com MCU NXP LPC2468.&lt;/li&gt;
+  &lt;li&gt;Suporte ao kit &lt;a href=&quot;<A HREF="http://www.olimex.com/dev/str-e912.html">http://www.olimex.com/dev/str-e912.html</A>&quot;&gt;Olimex STR-E912&lt;/a&gt;, com MCU ST Electronics STR912FW44X.&lt;/li&gt;
+  &lt;li&gt;Novo FAT File System para SD/MMC Cards, gen&#233;rico e port&#225;til. Mais detalhes &lt;a href=&quot;fatfs.html&quot;&gt;aqui&lt;/a&gt;.&lt;/li&gt;
+  &lt;li&gt;Suporte ao patch Lua EGC (Emergency Garbage Collection). Mais detalhes &lt;a href=&quot;elua_egc.html&quot;&gt;aqui&lt;/a&gt;.&lt;/li&gt;
+  &lt;li&gt;Suporte &#224; &lt;a href=&quot;<A HREF="http://fanplastic.org/2009/05/11/lua-rpc/">http://fanplastic.org/2009/05/11/lua-rpc/</A>&quot;&gt;LuaRPC&lt;/a&gt;. Remote Procedure Calls no mundo embedded (!!!).&lt;/li&gt;
+  &lt;li&gt;Novo comando &lt;a href=&quot;using.html#shell&quot;cat/type&lt;/a&gt; para o shell de eLua. Lista o conte&#250;do de arquivos de texto.&lt;/li&gt;
+  &lt;li&gt;Novos modos de build do ROM File System: Compress e Compile. Mais detalhes &lt;a href=&quot;arch_romfs.html#mode&quot;&gt;aqui&lt;/a&gt;.&lt;/li&gt;
+  &lt;li&gt;Mais conte&#250;do traduzido para Portugu&#234;s.&lt;/li&gt;
+  &lt;li&gt;Novas funcionalidades do M&#243;dulo ADC (conversor anal&#243;gico-digital) e sua doc melhorada.&lt;/li&gt;
+  &lt;li&gt;Mais tutoriais e melhorias gerais na documenta&#231;&#227;o e no site.&lt;/li&gt;
 &lt;/ul&gt;
 
-
 &lt;h2&gt;06 de Outubro de 2009&lt;/h2&gt;
 &lt;p&gt;A vers&#227;o 0.6 de &lt;strong&gt;eLua&lt;/strong&gt; foi lan&#231;ada. As principais
 caracter&#237;sticas est&#227;o descritas a seguir. Para uma lista mais completa das

Modified: branches/pre0.7/doc/pt/overview.html
===================================================================
--- branches/pre0.7/doc/pt/overview.html	2010-01-16 00:10:06 UTC (rev 664)
+++ branches/pre0.7/doc/pt/overview.html	2010-01-16 14:47:22 UTC (rev 665)
@@ -1,5 +1,5 @@
 $$HEADER$$
-&lt;a name=&quot;whatis&quot; /&gt;&lt;h3&gt;O que &#233; eLua ?&lt;/h3&gt;
+&lt;a name=&quot;whatis&quot; /&gt;&lt;h3&gt;O que &#233; eLua?&lt;/h3&gt;
 &lt;p&gt;&lt;strong&gt;eLua&lt;/strong&gt;
 significa &lt;strong&gt;Embedded Lua&lt;/strong&gt; e o projeto projeto visa trazer a
 funcionalidade completa da linguagem de programa&#231;&#227;o &lt;a href=&quot;<A HREF="http://www.lua.org">http://www.lua.org</A>&quot;&gt;Lua&lt;/a&gt; para o mundo
@@ -9,8 +9,7 @@
 mesmo usu&#225;rios finais dos sistemas, possam desenvolver e alterar os
 programas dos seus produtos.&lt;/p&gt;
 
-&lt;p&gt;&lt;strong&gt;eLua&lt;/strong&gt; n&#227;o &#233; uma vers&#227;o reduzida de Lua, muito pelo contr&#225;rio, ela
-oferece os recursos completos da vers&#227;o desktop de Lua, complementando-a
+&lt;p&gt;&lt;strong&gt;eLua&lt;/strong&gt; n&#227;o &#233; uma vers&#227;o reduzida de Lua, muito pelo contr&#225;rio, oferece os recursos completos da vers&#227;o desktop de Lua, complementando-a
 ainda com caracter&#237;sticas espec&#237;ficas para o uso embedded. 
 Oferece tamb&#233;m a mesma possibilidade de escolha no uso de implementa&#231;&#245;es diferentes
 de Lua (ex: Lua Inteiro x Lua Ponto-Flutuante). Muito trabalho foi e ainda ser&#225; feito no sentido de tornar Lua mais &quot;amig&#225;vel&quot; no mundo embedded, 
@@ -32,39 +31,57 @@
 &lt;b&gt;eLua&lt;/b&gt; herdou o design minimalista e funcional de Lua, mantendo a filosofia bem conhecida do &quot;&lt;b&gt;KISS&lt;/b&gt;&quot; - &quot;&lt;i&gt;Keep It Small and Simple&lt;/i&gt;&quot;, que significa &quot;Mantenha seu c&#243;digo
 e sua arquitetura simples e sua complexidade reduzida&quot;.&lt;/p&gt;
 
-&lt;a name=&quot;features&quot;&gt;&lt;/a&gt;&lt;h3&gt;Recursos&lt;/h3&gt;
-&lt;p&gt;&lt;b&gt;eLua&lt;/b&gt; permite que voc&#234; execute Lua diretamente no seu microcontrolador. 
-Um grande conjunto de m&#243;dulos complementares j&#225; existe para a programa&#231;&#227;o de perif&#233;ricos &lt;strong&gt;eLua&lt;/strong&gt;
-e o desenvolvimento de novos tem um crescimento cada vez mais r&#225;pido.&lt;/p&gt;
-&lt;p&gt;Relacionamos a seguir algumas fun&#231;&#245;es que est&#227;o prontas ou sendo implementadas:&lt;/p&gt;
+&lt;a name=&quot;features&quot;&gt;&lt;/a&gt;&lt;h3&gt;Funcionalidades&lt;/h3&gt;
+&lt;p&gt;
+&lt;b&gt;eLua&lt;/b&gt; permite que voc&#234; execute Lua diretamente no seu microcontrolador.
+Um grande conjunto de m&#243;dulos j&#225; existe para a programa&#231;&#227;o de perif&#233;ricos de
+um grande n&#250;mero de plataformas e o desenvolvimento de novos tem um crescimento cada vez mais r&#225;pido.
+&lt;/p&gt;
+&lt;p&gt;
+Relacionamos a seguir algumas fun&#231;&#245;es que est&#227;o prontas ou sendo implementadas:
+&lt;/p&gt;
 &lt;ul&gt;
-  &lt;li&gt;um sistema de configura&#231;&#227;o do build flex&#237;vel e um servi&#231;o de build
-  remoto via web&lt;/li&gt;
+  &lt;li&gt;um servi&#231;o online, sempre gratuito, de configura&#231;&#227;o e build de imagens
+  bin&#225;rias de &lt;b&gt;eLua&lt;/b&gt; para todas as plataformas suportadas.&lt;/li&gt;
   &lt;li&gt;acesso ao interpretador Lua diretamente na sua MCU, atrav&#233;s de uma variedade de
-  protocolos de transportes f&#237;sicos (RS-232, ethernet, ...)&lt;/li&gt;
-  &lt;li&gt;uma biblioteca de perif&#233;ricos independentes de plataforma (PIO, UART, PWM, SPI, TMR, ADC, NET,
-  I2C, CAN ...)&lt;/li&gt;
-  &lt;li&gt;um File System (por enquanto apenas em ROM), f&#225;cil de ser portado para diferentes tipos de chips de mem&#243;ria e outros dispositivos de armazenamento&lt;/li&gt;
-  &lt;li&gt;um pequeno Fyle System FAT R/W, para cart&#245;es MMC e SD&lt;/li&gt;
-  &lt;li&gt;um shell pr&#243;prio m&#237;nimo (para opera&#231;&#245;es com arquivos, configura&#231;&#227;o do ambiente e outros recursos)&lt;/li&gt;
+  protocolos de transportes (RS-232, Ethernet, ...)&lt;/li&gt;
+  &lt;li&gt;uma biblioteca gen&#233;rica, para acesso port&#225;til &#224; perif&#233;ricos (PIO, UART, PWM, SPI, TMR, ADC, NET,
+  I2C, CAN ...) de todas
+  as plataformas suportadas por &lt;b&gt;eLua&lt;/b&gt;. Portabilidade de c&#243;digo fonte no mundo
+  embedded !!! &lt;/li&gt;
+  &lt;li&gt;um File System para mem&#243;rias internas das MCUs (por enquanto apenas
+  para ROM), f&#225;cil de ser portado para diferentes chips e outros dispositivos de armazenamento&lt;/li&gt;
+  &lt;li&gt;um File System FAT, read/write, para cart&#245;es de mem&#243;ria SD e MMC&lt;/li&gt;
+  &lt;li&gt;um Command Shell pr&#243;prio, para opera&#231;&#245;es com arquivos, configura&#231;&#227;o do ambiente e outros recursos&lt;/li&gt;
   &lt;li&gt;suporte a redes TCP/IP&lt;/li&gt;
-  &lt;li&gt;um servidor http embedded escrito em Lua&lt;/li&gt;
-  &lt;li&gt;terminal/console via serial ou Ethernet&lt;/li&gt;
-  &lt;li&gt;depura&#231;&#227;o (diretamente no MCU ou remotamente com o PC)&lt;/li&gt;
-  &lt;li&gt;execu&#231;&#227;o distribuida de c&#243;digo (LuaRPC)&lt;/li&gt;
+  &lt;li&gt;um servidor web embedded, 100% escrito em Lua e integrado ao c&#243;digo na MCU&lt;/li&gt;
+  &lt;li&gt;suporte &#224; desenvolvimento via terminal/console (VT-100 e similares) via serial ou Ethernet&lt;/li&gt;
+  &lt;li&gt;ferramentas de depura&#231;&#227;o, diretamente na MCU ou remotamente com o PC (em desenvolvimento)&lt;/li&gt;
+  &lt;li&gt;execu&#231;&#227;o distribuida de c&#243;digo (LuaRPC) em MCUs interconectadas atrav&#233;s de
+  diversos perif&#233;ricos (UART, TCP/IP, SPI, ZigBee, ...). Remote Procedure
+  Calls no mundo embedded (!!! :)&lt;/li&gt;
+  &lt;li&gt;compartilhamento de arquivos entre os File Systems nas MCUs e PCs
+  remotos. File Sharing no mundo embedded (!!! :)&lt;/li&gt;
+  &lt;li&gt;suporte &#224; desenvolvimento em ambientes Linux, MacOS e Windows&lt;/li&gt;
+  &lt;li&gt;documenta&#231;&#227;o online e integrada &#224; distribui&#231;&#227;o, para acesso offline&lt;/li&gt;
 &lt;/ul&gt;
 
-&lt;p&gt;Para obter mais informa&#231;&#245;es sobre as funcionalidades (implementadas e previstas) em &lt;strong&gt;eLua&lt;/strong&gt; veja a &lt;a href=&quot;status.html&quot;&gt;p&#225;gina de status&lt;/a&gt;.&lt;/p&gt;
-&lt;p&gt;O projeto foi concebido de forma que migrar &lt;strong&gt;eLua&lt;/strong&gt; para uma outra plataforma
-ou mesmo arquitetura, seja algo f&#225;cil de ser realizado. 
-Atualmente, esta migra&#231;&#227;o est&#225; restrita &#224;s plataformas para as quais gcc + newlib
-ou toolchains completos (ex:CodeSourcery) estejam dispon&#237;veis. 
-Esta restri&#231;&#227;o ir&#225; desaparecer em um futuro pr&#243;ximo, j&#225; que &lt;b&gt;eLua&lt;/b&gt; ter&#225; sua pr&#243;pria libc e portanto 
-estar&#225; dispon&#237;vel em um leque mais amplo de MCUs.&lt;/p&gt;
-&lt;p&gt;Assim como para os ambientes Desktop, Lua em &lt;strong&gt;eLua&lt;/strong&gt; est&#225; dispon&#237;vel em duas implementa&#231;&#245;es: &quot;Lua padr&#227;o&quot; (usando ponto flutuante) e &quot;Lua inteiro&quot; (usando inteiro). 
-&quot;Lua padr&#227;o&quot; realiza opera&#231;&#245;es de ponto flutuante (mais lentas devido a emula&#231;&#227;o via software no MCU), 
-enquanto &quot;Lua inteiro&quot; realiza opera&#231;&#245;es com n&#250;meros inteiros 
-(suporte para ponto fixo e ponto flutuante podem ser adicionados em m&#243;dulos separados) e assim ser&#225; mais r&#225;pido.&lt;/p&gt;
+&lt;p&gt;
+Para obter mais informa&#231;&#245;es sobre as funcionalidades (implementadas e previstas) em &lt;strong&gt;eLua&lt;/strong&gt; veja a &lt;a href=&quot;status.html&quot;&gt;p&#225;gina de status&lt;/a&gt;.
+&lt;/p&gt;
+&lt;p&gt;
+O projeto foi concebido de forma que portar &lt;strong&gt;eLua&lt;/strong&gt; para uma outra plataforma
+ou mesmo arquitetura, seja algo f&#225;cil de ser realizado. Atualmente, esta migra&#231;&#227;o est&#225; restrita &#224;s plataformas para as quais gcc + newlib
+ou toolchains completos (ex: CodeSourcery) estejam dispon&#237;veis. Esta restri&#231;&#227;o ir&#225; desaparecer em um futuro pr&#243;ximo, j&#225; que &lt;b&gt;eLua&lt;/b&gt; ter&#225; sua pr&#243;pria libc e portanto 
+estar&#225; dispon&#237;vel em um leque mais amplo de MCUs.
+&lt;/p&gt;
+&lt;p&gt;
+Assim como para os ambientes desktop, Lua em &lt;strong&gt;eLua&lt;/strong&gt; est&#225; dispon&#237;vel em duas implementa&#231;&#245;es: &quot;Lua padr&#227;o&quot; (usando ponto flutuante) e &quot;Lua inteiro&quot; (usando
+n&#250;meros inteiros). 
+&quot;Lua padr&#227;o&quot;, realiza opera&#231;&#245;es de ponto flutuante (mais lentas devido a emula&#231;&#227;o via software no MCU), 
+enquanto &quot;Lua inteiro&quot; realiza opera&#231;&#245;es com n&#250;meros inteiros. Suporte para ponto fixo e ponto flutuante podem ser adicionados em m&#243;dulos
+separados, otimizando ainda mais a execu&#231;&#227;o se necess&#225;rio.
+&lt;/p&gt;
 
 &lt;a name=&quot;audience&quot;&gt;&lt;/a&gt;&lt;h3&gt;P&#250;blico Alvo&lt;/h3&gt;
 &lt;p&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;eLua&lt;/span&gt; tem uma audi&#234;ncia ampla e
@@ -74,9 +91,10 @@
 bibliotecas de alto n&#237;vel com muita portabilidade.&lt;/p&gt;
 &lt;p&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;eLua&lt;/span&gt; permite que programadores
 com pouca experi&#234;ncia no mundo embedded utilizem a simplicidade 
-e o poder da linguagem de programa&#231;&#227;o Lua, sem precisarem se preocupar com as complexidades e 
+e o poder da linguagem de programa&#231;&#227;o Lua, sem precisarem se preocupar com as complexidades
 da arquitetura do hardware em uso. 
-Utilizando &lt;b&gt;eLua&lt;/b&gt;, o programador pode concentrar-se na implementa&#231;&#227;o do seu programa, 
+Utilizando &lt;b&gt;eLua&lt;/b&gt;, o programador pode concentrar-se na implementa&#231;&#227;o da
+sua aplica&#231;&#227;o, 
 sem ter que se preocupar com detalhes de acessos &#224; registros, configura&#231;&#227;o de perif&#233;ricos e mesmo gerenciamento de mem&#243;ria.
 Com isso, aumentamos a produtividade e eliminamos tarefas muitas vezes frustrantes de lidar com drivers
 complexos de plataformas espec&#237;ficas. &lt;stront&gt;eLua&lt;/strong&gt; absorve a
@@ -128,12 +146,57 @@
 &lt;br /&gt;
 &lt;br /&gt;
 &lt;a name=&quot;license&quot; /&gt;&lt;h3&gt;Licen&#231;a&lt;/h3&gt;
-&lt;p&gt;&lt;strong&gt;eLua&lt;/strong&gt; &#233; Open Source e &#233; distribu&#237;da gratuitamente sob a licen&#231;a MIT.&lt;/p&gt;
-&lt;p&gt;A licen&#231;a MIT, diferentemente de outras licen&#231;as de c&#243;digo aberto (ex:
-GPL), permite que produtos de c&#243;digo propriet&#225;rio sejam desenvolvidos
-utilizando &lt;b&gt;eLua&lt;/b&gt;.&lt;/p&gt;
+&lt;p&gt;&lt;strong&gt;eLua&lt;/strong&gt; &#233; um projeto Livre e de C&#243;digo Aberto, distribu&#237;do gratuitamente sob a licen&#231;a MIT.&lt;/p&gt;
+&lt;p&gt;A &lt;a href=&quot;<A HREF="http://en.wikipedia.org/wiki/MIT_License">http://en.wikipedia.org/wiki/MIT_License</A>&quot;&gt;licen&#231;a MIT&lt;/a&gt;, diferentemente de outras licen&#231;as de c&#243;digo aberto (ex:
+GPL), permite que produtos de c&#243;digo propriet&#225;rio sejam desenvolvidos utilizando &lt;b&gt;eLua&lt;/b&gt;.
+&lt;/p&gt;
 &lt;p&gt;O c&#243;digo Lua (com todas as mudan&#231;as espec&#237;ficas de &lt;strong&gt;eLua&lt;/strong&gt;) est&#225; inclu&#237;do na &#225;rvore de origem e
-&#233;, naturalmente, licenciado sob a mesma &lt;a href=&quot;<A HREF="http://en.wikipedia.org/wiki/MIT_License">http://en.wikipedia.org/wiki/MIT_License</A>&quot;&gt;licen&#231;a MIT de Lua.&lt;/a&gt;&lt;/p&gt;
+&#233;, naturalmente, licenciado sob a mesma &lt;a href=&quot;<A HREF="http://www.lua.org/license.html">http://www.lua.org/license.html</A>&quot;&gt;licen&#231;a MIT de Lua.&lt;/a&gt;&lt;/p&gt;
 &lt;p&gt;H&#225; ainda outros (poucos) componentes com diferentes licen&#231;as hoje, em uso no c&#243;digo de &lt;strong&gt;eLua&lt;/strong&gt;. 
-Consulte o arquivo &lt;strong&gt;COPYING&lt;/strong&gt; na distribui&#231;&#227;o fonte para maiores detalhes.&lt;/p&gt;
+Consulte o arquivo &lt;strong&gt;LICENSE&lt;/strong&gt; na distribui&#231;&#227;o fonte para maiores detalhes.&lt;/p&gt;
+&lt;p&gt;
+O c&#243;digo de transporte XMODEM foi adaptado da biblioteca FreeBSD at91, de M. Warner Losh e &#233; distribu&#237;do sob a licen&#231;a BSD.
+&lt;/p&gt;
+&lt;p&gt;
+O m&#243;dulo &quot;pack&quot; foi adaptado do m&#243;dulo &quot;lpack&quot;, de Luiz Henrique de
+Figueiredo e foi posto em dom&#237;nio p&#250;blico.
+&lt;/p&gt;
+&lt;p&gt;
+O m&#243;dulo &quot;bit&quot; foi adaptado da biblioteca &quot;bitlib&quot;, de Reuben Thomas,
+distribu&#237;da sob a licen&#231;a MIT.
+&lt;/p&gt;
+&lt;p&gt;
+A vers&#227;o &quot;integer only Lua&quot; &#233; baseada no patch &quot;Go Long Lua!&quot;, de John D.
+Ramsdell (do site Lua Power Patches), posto em dom&#237;nio p&#250;blico.
+&lt;/p&gt;
+&lt;p&gt;
+O alocador m&#250;ltiplo de mem&#243;ria &quot;dlmalloc&quot; foi escrito por Doug Lea e foi
+posto em dom&#237;nio p&#250;blico.
+&lt;/p&gt;
+&lt;p&gt;
+O stack TCP/IP usado atualmente &#233; o uIP (Micro IP), escrito por Adam
+Dunkels e distribu&#237;do sob a licen&#231;a BSD. A vers&#227;o usada em &lt;b&gt;eLua&lt;/b&gt;
+sofreu pequenas adapta&#231;&#245;es para se adequar &#224; arquitetura embarcada.
+&lt;/p&gt;
+&lt;p&gt;
+O sistema de arquivos FAT usado &#233; uma adapta&#231;&#227;o do &quot;FatFs&quot;, escrito por &lt;a
+href=&quot;<A HREF="http://elm-chan.org">http://elm-chan.org</A>&quot;&gt;Elm Chan&lt;/a&gt; e uma c&#243;pia da licen&#231;a do FatFs
+pode ser encontrada na nossa distribui&#231;&#227;o, no arquivo LICENSE.fatfs.
+&lt;/p&gt;
+&lt;p&gt;
+A implementa&#231;&#227;o de RPC (Remote Procedure Calls) de &lt;b&gt;eLua&lt;/b&gt; &#233; baseada na
+&lt;a href=&quot;<A HREF="http://q12.org/lua/index.html">http://q12.org/lua/index.html</A>&quot;&gt;biblioteca LuaRPC&lt;/a&gt;, de Russell
+Smith e uma c&#243;pia da licen&#231;a de LuaRPC pode ser encontrada na nossa
+distribui&#231;&#227;o, no arquivo LICENCE.luarpc.
+&lt;/p&gt;
+&lt;p&gt;
+Bibliotecas de suporte &#224;s MCUs s&#227;o disponibilizadas por fabricantes das
+diversas plataformas suportadas, sob diversas licen&#231;as e termos. Detalhes
+podem ser encontrados na &#225;rvore do c&#243;digo fonte nas pastas
+src/platform/&lt;nome-da-plataforma&gt;.
+&lt;/p&gt;
+&lt;p&gt;
+Todo o restante do c&#243;digo de &lt;b&gt;eLua&lt;/b&gt; &#233; distribu&#237;do sob a licen&#231;a MIT.
+&lt;/p&gt;
+
 $$FOOTER$$


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000620.html">[Elua-svn] r664 - branches/pre0.7/doc/en
</A></li>
	<LI>Next message: <A HREF="000622.html">[Elua-svn] r666 - in branches/pre0.7: . doc doc/eluadoc doc/en	doc/pt
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#621">[ date ]</a>
              <a href="thread.html#621">[ thread ]</a>
              <a href="subject.html#621">[ subject ]</a>
              <a href="author.html#621">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/elua-svn">More information about the eLua-svn
mailing list</a><br>
</body></html>
